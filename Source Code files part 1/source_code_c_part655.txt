g as
    (EndBuffer - (CurrentBuffer + CurrentLength)). The header and
    tail padding is guaranteed to be at least the length that the
    miniport requested in response to a preceding OID_WAN_GET_INFO
    query. The header and/or tail padding for any packet given to
    <f MiniportWanSend> can be more than the length that was requested.

    <f MiniportWanSend> can neither return NDIS_STATUS_RESOURCES for an
    input packet nor call NdisMSendResourcesAvailable. Instead, the
    miniport must queue incoming send packets internally for subsequent
    transmission. The miniport controls how many packets NDIS will
    submit to MiniportWanSend when the NIC driver sets the SendWindow
    value in the driver's NDIS_MAC_LINE_UP indication to establish the
    given link. NDISWAN uses this value as an upper bound on uncompleted
    sends submitted to <f MiniportWanSend>, so the miniport's internal queue
    cannot be overrun, and the miniport can adjust the SendWindow
    dynamically with subsequent line-up indications for established
    links. If the miniport set the SendWindow to zero when it called
    NdisMIndicateStatus with a particular line-up indication, NDISWAN
    uses the MaxTransmit value that the driver originally set in response
    to the OID_WAN_GET_INFO query as its limit on submitted but uncompleted
    send packets.

    Each packet passed to <f MiniportWanSend> is set up according to one of
    the flags that the miniport set in the FramingBits member in response
    to the OID_WAN_GET_INFO query. It will contain simple HDLC PPP framing
    if the driver claimed to support PPP. For SLIP or RAS framing, such
    a packet contains only the data portion with no framing whatsoever.

    For more information about system-defined WAN and TAPI OIDs, see Part 2.

    <f Note>: A WAN driver cannot manage software loopback or promiscuous mode
    loopback internally. NDISWAN supplies this loopback support for
    WAN drivers.

    <f Note>: <f MiniportWanSend> can be pre-empted by an interrupt.

    By default, <f MiniportWanSend> runs at IRQL DISPATCH_LEVEL.


@rdesc

    <f MiniportWanSend> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        The driver (or its NIC) has accepted the packet data for
        transmission, so <f MiniportWanSend> is returning the packet.<nl>

    <f Note>: A non-zero return value indicates one of the following
    error codes:

@iex
    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_FAILURE
*/

NDIS_STATUS MiniportWanSend(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    // The structure contains a pointer to a contiguous buffer with guaranteed
    // padding at the beginning and end.  The driver may manipulate the buffer
    // in any way.
    )
{
    DBG_FUNC("MiniportWanSend")

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter == pBChannel->pAdapter);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the packet size is something we can deal with.
    */
    BytesToSend = pWanPacket->CurrentLength;
    if ((BytesToSend == 0) || (BytesToSend > pAdapter->pCard->BufferSize))
    {
        DBG_ERROR(pAdapter,("Bad packet size = %d\n",BytesToSend));
        Result = NDIS_STATUS_FAILURE;
    }
    /*
    // Return if line has been closed.
    */
    else if (pBChannel->CallClosing)
    {
        DBG_ERROR(pAdapter,("BChannel Closed\n"));
        Result = NDIS_STATUS_FAILURE;
    }
    else
    {
        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesToSend > pBChannel->WanLinkInfo.MaxSendFrameSize)
        {
            DBG_NOTICE(pAdapter,("Line=%d  Packet size=%d > %d\n",
                    pBChannel->BChannelIndex, BytesToSend,
                    pBChannel->WanLinkInfo.MaxSendFrameSize));
        }

        /*
        // We'll need to use these when the transmit completes.
        */
        pWanPacket->MacReserved1 = (PVOID) pBChannel;

        /*
        // Place the packet in the transmit list.
        */
        if (TransmitAddToQueue(pAdapter, pBChannel, pWanPacket) &&
            pAdapter->NestedDataHandler < 1)
        {
            /*
            // The queue was empty so we've gotta kick start it.
            // Once it's going, it runs off the DPC.
            //
            // No kick start is necessary if we're already running the the
            // TransmitCompleteHandler -- In fact, it will screw things up if
            // we call TransmitPacketHandler while TransmitCompleteHandler is
            // running.
            */
            TransmitPacketHandler(pAdapter);
        }
        Result = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspi.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Tspi Tspi_c

@module Tspi.c |

    This module contains all the Miniport TAPI OID processing routines.  It
    is called by the <f MiniportSetInformation> and <f MiniportQueryInformation>
    routines to handle the TAPI OIDs.

    This driver conforms to the NDIS 3.0 Miniport interface and provides
    extensions to support Telephonic Services.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Tspi_c

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 4.0 NDISWAN TAPI Service Provider Interface |

    The Connection Wrapper interface defines how WAN miniport NIC drivers
    implement telephonic services. It is closely related to the Service
    Provider Interface established in Windows Telephony version 1.0, with
    telephony-aware NDIS miniport NIC drivers taking the place of TAPI
    service providers.  This section touches briefly on the concepts
    embodied in Windows Telephony, but the reader is advised to consult the
    documentation published with the Telephony SDK for an in-depth
    discussion.

    <f Note>: There are subtle differences between the TAPI specification and the
    Windows 95 TAPI implementation.  Please refer to the Microsoft Win32 SDK
    for details on the Win32 TAPI specification.

    The Connection Wrapper itself is an extension of the NDIS WAN library,
    and serves as a router for telephonic requests passed down through TAPI
    from user-mode client applications. WAN Miniport NIC drivers register
    for Connection Wrapper services by calling NdisMRegisterMiniport, and
    then register one or more adapters. When registration and other driver
    initialization have successfully completed, WAN miniport NIC drivers can
    receive telephonic requests from the Connection Wrapper via the standard
    NdisMSetInformation and NdisMQueryInformation mechanisms, and respond by
    calling NdisMQueryInformationComplete or NdisMSetInformationComplete and
    NdisMIndicateStatus to notify the Connection Wrapper of asynchronous
    request completion and unsolicited events (e.g. incoming calls, remote
    disconnections), respectively.

@end
*/

#define  __FILEID__             TSPI_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Tspi Tspi_c STR_EQU


@func

    <f STR_EQU> compares two strings for equality, ignoring case.

@parm IN PCHAR | s1 |
    A pointer to the string to be compared.

@parm IN PCHAR | s2 |
    A pointer to the string to be compared.

@parm IN int | len |
    The length of the strings in bytes.

@rdesc STR_EQU returns TRUE if the strings are equal, otherwise FASLE.

*/

BOOLEAN STR_EQU(
    IN PCHAR                    s1,
    IN PCHAR                    s2,
    IN int                      len
    )
{
    DBG_FUNC("STR_EQU")

    int index;
    int c1 = 0;
    int c2 = 0;

    for (index = 0; index < len; index++)
    {
        c1 = *s1++;
        c2 = *s2++;
        if (c1 == 0 || c2 == 0)
        {
            break;
        }
        if (c1 >= 'A' && c1 <= 'Z')
        {
            c1 += 'a' - 'A';
        }
        if (c2 >= 'A' && c2 <= 'Z')
        {
            c2 += 'a' - 'A';
        }
        if (c1 != c2)
        {
            break;
        }
    }
    return (c1 == c2);
}

/*
// This defines the prototype for all TAPI OID request handlers.
*/
typedef NDIS_STATUS (__stdcall * PTSPI_REQUEST)
(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID Request,
    OUT PULONG BytesUsed,
    OUT PULONG                  BytesNeeded
);

/* @doc EXTERNAL INTERNAL Tspi Tspi_c TSPI_OID_INFO


@struct TSPI_OID_INFO |

    This structure defines the format of the TAPI OID table entries.

@comm

*/

typedef struct TSPI_OID_INFO
{
    ULONG           Oid;                                    // @field
    // TSPI OID value which identifies this record uniquely.

    ULONG           MinBytesNeeded;                         // @field
    // Minimum number of bytes needed when this request is given to
    // the miniport.

    PTSPI_REQUEST   Request;                                // @field
    // Pointer to a function which will be invoked to handle the
    // TSPI request.

    PUCHAR          OidString;                              // @field
    // OID description string.

} TSPI_OID_INFO, *PTSPI_OID_INFO;

/*
// The NDISTAPI.H file defines some of the variable length structures with
// an extra byte at end (e.g. UCHAR VarArgs[1]).  Since the caller is not
// required to use the optional fields, the length of the structure passed
// in can be exactly equal to the size of the TAPI request structure, without
// any extra bytes.  So we use TSPI_OPTIONAL_SIZE compensate for this
// problem in our minimum structure size requirements.  With structure pad,
// there is an additional 4 bytes at the end.
*/
#define TSPI_OPTIONAL_SIZE      sizeof(ULONG)

/*
// The following is a list of all the possible TAPI OIDs.
// WARNING! The list is ordered so that it can be indexed directly by the
// (OID_TAPI_xxx - OID_TAPI_ACCEPT).
*/
DBG_STATIC TSPI_OID_INFO TspiSupportedOidTable[] =
{
    {
        OID_TAPI_ACCEPT,
        sizeof(NDIS_TAPI_ACCEPT)-TSPI_OPTIONAL_SIZE,
        TspiAccept,
        "OID_TAPI_ACCEPT"
    },
    {
        OID_TAPI_ANSWER,
        sizeof(NDIS_TAPI_ANSWER)-TSPI_OPTIONAL_SIZE,
        TspiAnswer,
        "OID_TAPI_ANSWER"
    },
    {
        OID_TAPI_CLOSE,
        sizeof(NDIS_TAPI_CLOSE),
        TspiClose,
        "OID_TAPI_CLOSE"
    },
    {
        OID_TAPI_CLOSE_CALL,
        sizeof(NDIS_TAPI_CLOSE_CALL),
        TspiCloseCall,
        "OID_TAPI_CLOSE_CALL"
    },
    {
        OID_TAPI_CONDITIONAL_MEDIA_DETECTION,
        sizeof(NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION),
        TspiConditionalMediaDetection,
        "OID_TAPI_CONDITIONAL_MEDIA_DETECTION"
    },
    {
        OID_TAPI_DROP,
        sizeof(NDIS_TAPI_DROP)-TSPI_OPTIONAL_SIZE,
        TspiDrop,
        "OID_TAPI_DROP"
    },
    {
        OID_TAPI_GET_ADDRESS_CAPS,
        sizeof(NDIS_TAPI_GET_ADDRESS_CAPS),
        TspiGetAddressCaps,
        "OID_TAPI_GET_ADDRESS_CAPS"
    },
    {
        OID_TAPI_GET_ADDRESS_ID,
        sizeof(NDIS_TAPI_GET_ADDRESS_ID)-TSPI_OPTIONAL_SIZE,
        TspiGetAddressID,
        "OID_TAPI_GET_ADDRESS_ID"
    },
    {
        OID_TAPI_GET_ADDRESS_STATUS,
        sizeof(NDIS_TAPI_GET_ADDRESS_STATUS),
        TspiGetAddressStatus,
        "OID_TAPI_GET_ADDRESS_STATUS"
    },
    {
        OID_TAPI_GET_CALL_ADDRESS_ID,
        sizeof(NDIS_TAPI_GET_CALL_ADDRESS_ID),
        TspiGetCallAddressID,
        "OID_TAPI_GET_CALL_ADDRESS_ID"
    },
    {
        OID_TAPI_GET_CALL_INFO,
        sizeof(NDIS_TAPI_GET_CALL_INFO),
        TspiGetCallInfo,
        "OID_TAPI_GET_CALL_INFO"
    },
    {
        OID_TAPI_GET_CALL_STATUS,
        sizeof(NDIS_TAPI_GET_CALL_STATUS),
        TspiGetCallStatus,
        "OID_TAPI_GET_CALL_STATUS"
    },
    {
        OID_TAPI_GET_DEV_CAPS,
        sizeof(NDIS_TAPI_GET_DEV_CAPS),
        TspiGetDevCaps,
        "OID_TAPI_GET_DEV_CAPS"
    },
    {
        OID_TAPI_GET_DEV_CONFIG,
        sizeof(NDIS_TAPI_GET_DEV_CONFIG),
        TspiGetDevConfig,
        "OID_TAPI_GET_DEV_CONFIG"
    },
    {
        OID_TAPI_GET_ID,
        sizeof(NDIS_TAPI_GET_ID),
        TspiGetID,
        "OID_TAPI_GET_ID"
    },
    {
        OID_TAPI_GET_LINE_DEV_STATUS,
        sizeof(NDIS_TAPI_GET_LINE_DEV_STATUS),
        TspiGetLineDevStatus,
        "OID_TAPI_GET_LINE_DEV_STATUS"
    },
    {
        OID_TAPI_MAKE_CALL,
        sizeof(NDIS_TAPI_MAKE_CALL),
        TspiMakeCall,
        "OID_TAPI_MAKE_CALL"
    },
    {
        OID_TAPI_OPEN,
        sizeof(NDIS_TAPI_OPEN),
        TspiOpen,
        "OID_TAPI_OPEN"
    },
    {
        OID_TAPI_PROVIDER_INITIALIZE,
        sizeof(OID_TAPI_PROVIDER_INITIALIZE),
        TspiProviderInitialize,
        "OID_TAPI_PROVIDER_INITIALIZE"
    },
    {
        OID_TAPI_PROVIDER_SHUTDOWN,
        sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN),
        TspiProviderShutdown,
        "OID_TAPI_PROVIDER_SHUTDOWN"
    },
    {
        OID_TAPI_SET_APP_SPECIFIC,
        sizeof(NDIS_TAPI_SET_APP_SPECIFIC),
        TspiSetAppSpecific,
        "OID_TAPI_SET_APP_SPECIFIC"
    },
    {
        OID_TAPI_SET_CALL_PARAMS,
        sizeof(NDIS_TAPI_SET_CALL_PARAMS),
        TspiSetCallParams,
        "OID_TAPI_SET_CALL_PARAMS"
    },
    {
        OID_TAPI_SET_DEFAULT_MEDIA_DETECTION,
        sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION),
        TspiSetDefaultMediaDetection,
        "OID_TAPI_SET_DEFAULT_MEDIA_DETECTION"
    },
    {
        OID_TAPI_SET_DEV_CONFIG,
        sizeof(NDIS_TAPI_SET_DEV_CONFIG)-TSPI_OPTIONAL_SIZE,
        TspiSetDevConfig,
        "OID_TAPI_SET_DEV_CONFIG"
    },
    {
        OID_TAPI_SET_MEDIA_MODE,
        sizeof(NDIS_TAPI_SET_MEDIA_MODE),
        TspiSetMediaMode,
        "OID_TAPI_SET_MEDIA_MODE"
    },
    {
        OID_TAPI_SET_STATUS_MESSAGES,
        sizeof(NDIS_TAPI_SET_STATUS_MESSAGES),
        TspiSetStatusMessages,
        "OID_TAPI_SET_STATUS_MESSAGES"
    },
    {
        0,
        0,
        NULL,
        "OID_UNKNOWN"
    }
};

#define NUM_OID_ENTRIES (sizeof(TspiSupportedOidTable) / sizeof(TspiSupportedOidTable[0]))

/* @doc INTERNAL Tspi Tspi_c GetOidInfo


@func

    <f GetOidInfo> converts an NDIS TAPI OID to a TSPI_OID_INFO pointer.

@parm IN NDIS_OID | Oid |
    The OID to be converted.

@rdesc GetOidInfo returns a pointer into the TspiSupportedOidTable for the
    associated OID.  If the Oid is not supported in the table, a pointer
    to the last entry is returned, which will contain a NULL Request pointer.

*/

PTSPI_OID_INFO GetOidInfo(
    IN NDIS_OID Oid
    )
{
    DBG_FUNC("GetOidInfo")

    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (TspiSupportedOidTable[i].Oid == Oid)
        {
            break;
        }
    }
    return (&TspiSupportedOidTable[i]);
}

/* @doc INTERNAL Tspi Tspi_c TspiRequestHandler


@func

    The <f TspiRequestHandler> request allows for inspection of the TAPI
    portion of the driver's capabilities and current line status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until
    this request has been completed.

    <f Note>: Interrupts are in any state during this call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN NDIS_OID | Oid |
    The OID.  (See section 2.2.1,2 of the Extensions to NDIS 3.0 Miniports to
    support Telephonic Services specification for a complete description of
    the OIDs.)

@parm IN PVOID | InformationBuffer |
    The buffer that will receive the information. (See section 2.2.1,2 of
    the Extensions to NDIS 3.0 Miniports to support Telephonic Services
    specification for a description of the length required for each OID.)

@parm IN ULONG | InformationBufferLength |
    The length in bytes of InformationBuffer.

@parm OUT PULONG | BytesUsed |
    Returns the number of bytes used from the InformationBuffer.

@parm OUT PULONG | BytesNeeded |
    Returns the number of additional bytes needed to satisfy the OID.

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_SUCCESS

*/

NDIS_STATUS TspiRequestHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesUsed,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiRequestHandler")

    NDIS_STATUS Status;

    PTSPI_OID_INFO OidInfo;

    DBG_ENTER(pAdapter);

    /*
    // Get TSPI_OID_INFO pointer.
    */
    OidInfo = GetOidInfo(Oid);

    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X MinLength=%d\n",
               Oid, OidInfo->OidString,
               InformationBufferLength,
               InformationBuffer,
               OidInfo->MinBytesNeeded
              ));

    /*
    // Make sure this is a valid request.
    */
    if (OidInfo->Request != NULL)
    {
        /*
        // If the buffer provided is at least the minimum required,
        // call the handler to do the work.
        */
        if (InformationBufferLength >= OidInfo->MinBytesNeeded)
        {
            /*
            // Default BytesUsed indicates that we used the minimum necessary.
            */
            *BytesUsed = OidInfo->MinBytesNeeded;

            /*
            // Default BytesNeeded indicates that we don't need any more.
            */
            *BytesNeeded = 0;

            Status = OidInfo->Request(pAdapter, InformationBuffer,
                                      BytesUsed, BytesNeeded);
        }
        else
        {
            /*
            // The caller did not provide an adequate buffer, so we have to
            // tell them how much more we need to satisfy the request.
            // Actually, this is the minimum additional bytes we'll need,
            // the request handler may have even more bytes to add.
            */
            *BytesUsed = 0;
            *BytesNeeded = (OidInfo->MinBytesNeeded - InformationBufferLength);
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
    }
    else
    {
        Status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;
    }

    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Used=%d\n",
               Status, *BytesNeeded, *BytesUsed));

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Tspi Tspi_c TspiProviderInitialize


@func

    This request initializes the TAPI portion of the miniport.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_PROVIDER_INITIALIZE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceIDBase;
        OUT ULONG       ulNumLineDevs;
        OUT ULONG       ulProviderID;

    } NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL

*/

NDIS_STATUS TspiProviderInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiProviderInitialize")

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceIDBase=%d\n"
               "\tNumLineDevs=%d\n",
               Request->ulDeviceIDBase,
               pAdapter->NumBChannels
              ));
    /*
    // Save the device ID base value.
    */
    pAdapter->DeviceIdBase = Request->ulDeviceIDBase;

    /*
    // Return the number of lines.
    */
    Request->ulNumLineDevs = pAdapter->NumBChannels;

    /*
    // Before completing the PROVIDER_INIT request, the miniport should fill
    // in the ulNumLineDevs field of the request with the number of line
    // devices supported by the adapter. The miniport should also set the
    // ulProviderID field to a unique (per adapter) value. (There is no
    // method currently in place to guarantee unique ulProviderID values,
    // so we use the virtual address of our adapter structure.)
    */
    Request->ulProviderID = (ULONG) (ULONG_PTR)pAdapter;

    /*
    // TODO - Reinitialize the stat counters.
    */
    pAdapter->TotalRxBytes            = 0;
    pAdapter->TotalTxBytes            = 0;
    pAdapter->TotalRxPackets          = 0;
    pAdapter->TotalTxPackets          = 0;

    /*
    // Try to connect to the DChannel.
    */
    if (DChannelOpen(pAdapter->pDChannel) != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL Tspi Tspi_c TspiProviderShutdown


@func

    This request shuts down the miniport. The miniport should terminate any
    activities it has in progress.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_PROVIDER_SHUTDOWN | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
    {
        IN  ULONG       ulRequestID;

    } NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

*/

NDIS_STATUS TspiProviderShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiProviderShutdown")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    USHORT                      BChannelIndex;
    // Index into the pBChannelArray.

    DBG_ENTER(pAdapter);

    /*
    // Hangup all of the lines.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; BChannelIndex++)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // Close the BChannel - any open call will be dropped.
            */
            BChannelClose(pBChannel);
        }
    }
    pAdapter->NumLineOpens = 0;

    /*
    // Close DChannel.
    */
    DChannelClose(pAdapter->pDChannel);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL Tspi Tspi_c TspiResetHandler


@func

    <f TspiResetHandler> is called by the MiniportReset routine after the
    hardware has been reset due to some failure detection.  We need to make
    sure the line and call state information is conveyed properly to the
    Connection Wrapper.

    We only generate hangups on streams which have issued ENABLE_D_CHANNELs

    This function is called when the PRI board is RESET and when we receive a
    T1_STATUS message with RED alarm set.  When we get a RED alarm, we issue
    disable D channel messages for all open links. This is indicated by the
    argument nohup_Link set to NULL.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

*/

VOID TspiResetHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    )
{
    DBG_FUNC("TspiResetHandler")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    USHORT                      BChannelIndex;
    // Index into the pBChannelArray.

    DBG_ENTER(pAdapter);

    /*
    // Force disconnect on all lines.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; BChannelIndex++)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen &&
            pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE)
        {
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_IDLE,
                                 0);
            pBChannel->CallState = 0;
        }
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspi.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Tspi Tspi_h

@module Tspi.h |

    This module defines the interface to the <t TAPILINE_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Tspi_h

@end

*/

#ifndef _TSPI_H
#define _TSPI_H

#define TSPI_OBJECT_TYPE                ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'I'<<24)

#define TSPIDEV_OBJECT_TYPE             ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'D'<<24)

#define TSPILINE_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'L'<<24)

#define TSPIADDR_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'A'<<24)

#define TSPICALL_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'C'<<24)

/*
// There is only one TAPI address ID per line device (zero based).
*/
#define TSPI_NUM_ADDRESSES              1
#define TSPI_ADDRESS_ID                 0

/*
// The following constants are used by the TSPI to determine the DeviceClass.
*/
#define TAPI_DEVICECLASS_NAME       "tapi/line"
#define TAPI_DEVICECLASS_ID         1
#define NDIS_DEVICECLASS_NAME       "ndis"
#define NDIS_DEVICECLASS_ID         2


/* @doc INTERNAL Tspi Tspi_h TAPI_DEVICE_ID


@struct TAPI_DEVICE_ID |

    This structure is defined by the Win32 TAPI extensions for the "ndis"
    device class.

    The ndis device class consists of devices that can be associated with
    network driver interface specification (NDIS) media access control (MAC)
    drivers to support network communications. You access these devices by
    using functions.

    The lineGetID and phoneGetID functions fill a VARSTRING structure,
    setting the dwStringFormat member to the STRINGFORMAT_BINARY value and
    appending these additional members.

@iex

    HANDLE  hDevice;          // NDIS connection identifier
    CHAR    szDeviceType[1];  // name of device

@comm

    The hDevice member is the identifier to pass to a MAC, such as the
    asynchronous MAC for dial-up networking, to associate a network
    connection with the call/modem connection. The szDeviceType member is a
    null-terminated ASCII string specifying the name of the device associated
    with the identifier. For more information, see documentation about
    writing NDIS MAC drivers for use with dial-up networking.

*/

typedef struct TAPI_DEVICE_ID
{
    ULONG   hDevice;                                // @field
    // The NDIS Connection Wrapper identifier <p ConnectionWrapperID>.

    UCHAR   DeviceName[sizeof(VER_DEFAULT_MEDIATYPE)];    // @field
    // Name of device (e.g. "isdn", "x25", or "framerelay" )

} TAPI_DEVICE_ID, *PTAPI_DEVICE_ID;

/*


    Function prototypes.

*/

BOOLEAN STR_EQU(
    IN PCHAR                    s1,
    IN PCHAR                    s2,
    IN int                      len
    );

NDIS_STATUS TspiRequestHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesUsed,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiConfigDialog(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONFIG_DIALOG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallInfo(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetDevCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS  Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetLineDevStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_LINE_DEV_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiMakeCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_MAKE_CALL     Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiOpen(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_OPEN          Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiProviderInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiAccept(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ACCEPT Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiAnswer(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ANSWER        Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiClose(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE         Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiCloseCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL    Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiConditionalMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiDrop(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_DROP          Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiProviderShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetAppSpecific(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_APP_SPECIFIC Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetCallParams(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_CALL_PARAMS Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetDefaultMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEV_CONFIG Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetMediaMode(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_MEDIA_MODE Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetStatusMessages(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

VOID TspiAddressStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    AddressState
    );

VOID TspiCallStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    CallState,
    IN ULONG                    StateParam
    );

VOID TspiLineDevStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    LineDevState
    );

VOID TspiResetHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

VOID TspiCallTimerHandler(
    IN PVOID                    SystemSpecific1,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

#endif // _TSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vlang.h ===
// Define the language and sublanguge supported by your program.
#define VER_LANGUAGE_NUM                0x0409
#define VER_SUBLANGUAGE_NUM             0x04B0
// Concatenate the two, 4 digit hex numbers above.
#define VER_LANGUAGE_STRING             "040904B0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspicall.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiCall TspiCall_c

@module TspiCall.c |

    This module implements the Telephony Service Provider Interface for
    Call objects (TspiCall).

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiCall_c

@end

*/

#define  __FILEID__             TSPICALL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiCall TspiCall_c TspiMakeCall


@func

    This request places a call on the specified line to the specified
    destination address. Optionally, call parameters can be specified if
    anything but default call setup parameters are requested.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_MAKE_CALL | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_MAKE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  HTAPI_CALL  htCall;
        OUT HDRV_CALL   hdCall;
        IN  ULONG       ulDestAddressSize;
        IN  ULONG       ulDestAddressOffset;
        IN  BOOLEAN     bUseDefaultLineCallParams;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_ADDRESSBLOCKED
    NDIS_STATUS_TAPI_BEARERMODEUNAVAIL
    NDIS_STATUS_TAPI_CALLUNAVAIL
    NDIS_STATUS_TAPI_DIALBILLING
    NDIS_STATUS_TAPI_DIALQUIET
    NDIS_STATUS_TAPI_DIALDIALTONE
    NDIS_STATUS_TAPI_DIALPROMPT
    NDIS_STATUS_TAPI_INUSE
    NDIS_STATUS_TAPI_INVALADDRESSMODE
    NDIS_STATUS_TAPI_INVALBEARERMODE
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALRATE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLPARAMS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL
    NDIS_STATUS_TAPI_RATEUNAVAIL
    NDIS_STATUS_TAPI_USERUSERINFOTOOBIG

*/

NDIS_STATUS TspiMakeCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_MAKE_CALL Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiMakeCall")

    NDIS_STATUS                 Status = NDIS_STATUS_TAPI_INVALPARAM;

    PLINE_CALL_PARAMS           pLineCallParams;

    USHORT                      DialStringLength;

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\thtCall=0x%X\n"
               "\tulDestAddressSize=%d\n"
               "\tulDestAddressOffset=0x%X\n"
               "\tbUseDefaultLineCallParams=%d\n"
               "\tLineCallParams=0x%X:0x%X\n",
               Request->hdLine,
               Request->htCall,
               Request->ulDestAddressSize,
               Request->ulDestAddressOffset,
               Request->bUseDefaultLineCallParams,
               &Request->LineCallParams,
               Request
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // The line must be in-service before we can let this request go thru.
    */
    if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) == 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINESTATE\n"));
        return (NDIS_STATUS_TAPI_INVALLINESTATE);
    }

    /*
    // We should be idle when this call comes down, but if we're out of
    // state for some reason, don't let this go any further.
    */
    if (pBChannel->CallState != 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INUSE\n"));
        return (NDIS_STATUS_TAPI_INUSE);
    }

    /*
    // Which set of call parameters should we use?
    */
    if (Request->bUseDefaultLineCallParams)
    {
        pLineCallParams = &pAdapter->DefaultLineCallParams;
        DBG_NOTICE(pAdapter, ("UseDefaultLineCallParams\n"));
    }
    else
    {
        pLineCallParams = &Request->LineCallParams;
    }

    /*
    // Make sure the call parameters are valid for us.
    */
    if (pLineCallParams->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALBEARERMODE=0x%X\n",
                    pLineCallParams->ulBearerMode));
        return (NDIS_STATUS_TAPI_INVALBEARERMODE);
    }
    if (pLineCallParams->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE=0x%X\n",
                    pLineCallParams->ulMediaMode));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }
    if (pLineCallParams->ulMinRate > _64KBPS ||
        pLineCallParams->ulMinRate > pLineCallParams->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }
    if (pLineCallParams->ulMaxRate && pLineCallParams->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }

    /*
    // Remember the TAPI call connection handle.
    */
    pBChannel->htCall = Request->htCall;

    /*
    // Since we only allow one call per line, we use the same handle.
    */
    Request->hdCall = (HDRV_CALL) pBChannel;

    /*
    // Dial the number if it's available, otherwise it may come via
    // OID_TAPI_DIAL.  Be aware the the phone number format may be
    // different for other applications.  I'm assuming an ASCII digits
    // string.
    */
    DialStringLength = (USHORT) Request->ulDestAddressSize;
    if (DialStringLength > 0)
    {
        PUCHAR                  pDestAddress;
        UCHAR                   DialString[CARD_MAX_DIAL_DIGITS+1];
        // Temporary copy of dial string.  One extra for NULL terminator.

        pDestAddress = ((PUCHAR)Request) + Request->ulDestAddressOffset;

        /*
        // Dial the number, but don't include the null terminator.
        */
        DialStringLength = CardCleanPhoneNumber(DialString,
                                                pDestAddress,
                                                DialStringLength);

        if (DialStringLength > 0)
        {
            /*
            // Save the call parameters.
            */
            pBChannel->MediaMode  = pLineCallParams->ulMediaMode;
            pBChannel->BearerMode = pLineCallParams->ulBearerMode;
            pBChannel->LinkSpeed  = pLineCallParams->ulMaxRate == 0 ?
                                    _64KBPS : pLineCallParams->ulMaxRate;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                        ("#%d Call=0x%X CallState=0x%X DIALING: '%s'\n"
                         "Rate=%d-%d - MediaMode=0x%X - BearerMode=0x%X\n",
                        pBChannel->BChannelIndex,
                        pBChannel->htCall, pBChannel->CallState,
                        pDestAddress,
                        Request->LineCallParams.ulMinRate,
                        Request->LineCallParams.ulMaxRate,
                        Request->LineCallParams.ulMediaMode,
                        Request->LineCallParams.ulBearerMode
                        ));

            Status = DChannelMakeCall(pAdapter->pDChannel,
                                      pBChannel,
                                      DialString,
                                      DialStringLength,
                                      pLineCallParams);
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiDrop


@func

    This request drops or disconnects the specified call. User-to-user
    information can optionally be transmitted as part of the call disconnect.
    This function can be called by the application at any time. When
    OID_TAPI_DROP returns with success, the call should be idle.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_DROP | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_DROP
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_DROP, *PNDIS_TAPI_DROP;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiDrop(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_DROP Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiDrop")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // The user wants to disconnect, so make it happen cappen.
    */
    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    /*
    // Drop the call after flushing the transmit and receive buffers.
    */
    DChannelDropCall(pAdapter->pDChannel, pBChannel);

#if !defined(NDIS50_MINIPORT)
    /*
    // NDISWAN_BUG
    // Under some conditions, NDISWAN does not do a CLOSE_CALL,
    // so the line would be left unusable if we don't timeout
    // and force a close call condition.
    */
    NdisMSetTimer(&pBChannel->CallTimer, CARD_NO_CLOSECALL_TIMEOUT);
#endif // NDIS50_MINIPORT

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCloseCall


@func

    This request deallocates the call after completing or aborting all
    outstanding asynchronous requests on the call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CLOSE_CALL | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CLOSE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;

    } NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiCloseCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiCloseCall")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    /*
    // The results of this call.
    */
    NDIS_STATUS Status;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Mark the link as closing, so no more packets will be accepted,
    // and when the last transmit is complete, the link will be closed.
    */
    if (!IsListEmpty(&pBChannel->TransmitBusyList))
    {
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                    ("#%d Call=0x%X CallState=0x%X PENDING\n",
                    pBChannel->BChannelIndex,
                    pBChannel->htCall, pBChannel->CallState));

        pBChannel->CallClosing = TRUE;
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                    ("#%d Call=0x%X CallState=0x%X CLOSING\n",
                    pBChannel->BChannelIndex,
                    pBChannel->htCall, pBChannel->CallState));

        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        Status = NDIS_STATUS_SUCCESS;
    }

#if !defined(NDIS50_MINIPORT)
{
    /*
    // NDISWAN_BUG
    // Cancel the CARD_NO_CLOSECALL_TIMEOUT.
    */
    BOOLEAN                     TimerCancelled;
    // Flag tells whether call time-out routine was cancelled.

    NdisMCancelTimer(&pBChannel->CallTimer, &TimerCancelled);
}
#endif // NDIS50_MINIPORT

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiAccept


@func

    This request accepts the specified offered call. It may optionally send
    the specified user-to-user information to the calling party.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_ACCEPT | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_ACCEPT
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ACCEPT, *PNDIS_TAPI_ACCEPT;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

*/

NDIS_STATUS TspiAccept(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ACCEPT Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiAccept")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Note that the call has been accepted, we should see and answer soon.
    */
    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X ACCEPTING\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_ACCEPTED, 0);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiAnswer


@func

    This request answers the specified offering call.  It may optionally send
    the specified user-to-user information to the calling party.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_ANSWER | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_ANSWER
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiAnswer(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ANSWER Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiAnswer")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    /*
    // The results of this call.
    */
    NDIS_STATUS Status;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X ANSWERING\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    Status = DChannelAnswer(pAdapter->pDChannel, pBChannel);

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiGetCallInfo


@func

    This request returns detailed information about the specified call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_INFO | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_INFO
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_INFO  LineCallInfo;

    } NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;

    typedef struct _LINE_CALL_INFO
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   hLine;
        ULONG   ulLineDeviceID;
        ULONG   ulAddressID;

        ULONG   ulBearerMode;
        ULONG   ulRate;
        ULONG   ulMediaMode;

        ULONG   ulAppSpecific;
        ULONG   ulCallID;
        ULONG   ulRelatedCallID;
        ULONG   ulCallParamFlags;
        ULONG   ulCallStates;

        ULONG   ulMonitorDigitModes;
        ULONG   ulMonitorMediaModes;
        LINE_DIAL_PARAMS    DialParams;

        ULONG   ulOrigin;
        ULONG   ulReason;
        ULONG   ulCompletionID;
        ULONG   ulNumOwners;
        ULONG   ulNumMonitors;

        ULONG   ulCountryCode;
        ULONG   ulTrunk;

        ULONG   ulCallerIDFlags;
        ULONG   ulCallerIDSize;
        ULONG   ulCallerIDOffset;
        ULONG   ulCallerIDNameSize;
        ULONG   ulCallerIDNameOffset;

        ULONG   ulCalledIDFlags;
        ULONG   ulCalledIDSize;
        ULONG   ulCalledIDOffset;
        ULONG   ulCalledIDNameSize;
        ULONG   ulCalledIDNameOffset;

        ULONG   ulConnectedIDFlags;
        ULONG   ulConnectedIDSize;
        ULONG   ulConnectedIDOffset;
        ULONG   ulConnectedIDNameSize;
        ULONG   ulConnectedIDNameOffset;

        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectionIDSize;
        ULONG   ulRedirectionIDOffset;
        ULONG   ulRedirectionIDNameSize;
        ULONG   ulRedirectionIDNameOffset;

        ULONG   ulRedirectingIDFlags;
        ULONG   ulRedirectingIDSize;
        ULONG   ulRedirectingIDOffset;
        ULONG   ulRedirectingIDNameSize;
        ULONG   ulRedirectingIDNameOffset;

        ULONG   ulAppNameSize;
        ULONG   ulAppNameOffset;

        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;
        ULONG   ulCommentOffset;

        ULONG   ulDisplaySize;
        ULONG   ulDisplayOffset;

        ULONG   ulUserUserInfoSize;
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;
        ULONG   ulLowLevelCompOffset;

        ULONG   ulChargingInfoSize;
        ULONG   ulChargingInfoOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_INFO, *PLINE_CALL_INFO;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallInfo(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallInfo")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    Request->LineCallInfo.ulNeededSize =
    Request->LineCallInfo.ulUsedSize = sizeof(Request->LineCallInfo);

    if (Request->LineCallInfo.ulNeededSize > Request->LineCallInfo.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineCallInfo.ulTotalSize,
                   Request->LineCallInfo.ulNeededSize));
    }

    /*
    // The link has all the call information we need to return.
    */
    Request->LineCallInfo.hLine = (ULONG) (ULONG_PTR) pBChannel;
    Request->LineCallInfo.ulLineDeviceID = GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    Request->LineCallInfo.ulAddressID = TSPI_ADDRESS_ID;

    Request->LineCallInfo.ulBearerMode = pBChannel->BearerMode;
    Request->LineCallInfo.ulRate = pBChannel->LinkSpeed;
    Request->LineCallInfo.ulMediaMode = pBChannel->MediaMode;

    Request->LineCallInfo.ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    Request->LineCallInfo.ulCallStates = pBChannel->CallStatesMask;

    Request->LineCallInfo.ulAppSpecific = pBChannel->AppSpecificCallInfo;

    /*
    // We don't support any of the callerid functions.
    */
    Request->LineCallInfo.ulCallerIDFlags =
    Request->LineCallInfo.ulCalledIDFlags =
    Request->LineCallInfo.ulConnectedIDFlags =
    Request->LineCallInfo.ulRedirectionIDFlags =
    Request->LineCallInfo.ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiGetCallStatus


@func

    This request returns detailed information about the specified call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_STATUS    LineCallStatus;

    } NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;

    typedef struct _LINE_CALL_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulCallState;
        ULONG   ulCallStateMode;
        ULONG   ulCallPrivilege;
        ULONG   ulCallFeatures;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_STATUS, *PLINE_CALL_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("hdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    Request->LineCallStatus.ulNeededSize =
    Request->LineCallStatus.ulUsedSize = sizeof(Request->LineCallStatus);

    if (Request->LineCallStatus.ulNeededSize > Request->LineCallStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineCallStatus.ulTotalSize,
                   Request->LineCallStatus.ulNeededSize));
    }

    /*
    // The link has all the call information.
    */
    Request->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    Request->LineCallStatus.ulCallState = pBChannel->CallState;
    Request->LineCallStatus.ulCallStateMode = pBChannel->CallStateMode;

    /*
    // The call features depend on the call state.
    */
    switch (pBChannel->CallState)
    {
    case LINECALLSTATE_CONNECTED:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_DROP;
        break;

    case LINECALLSTATE_OFFERING:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ACCEPT |
                                                 LINECALLFEATURE_ANSWER;

    case LINECALLSTATE_ACCEPTED:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER;
        break;
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetAppSpecific


@func

    This request sets the application-specific field of the specified call's
    LINECALLINFO structure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_APP_SPECIFIC | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_APP_SPECIFIC
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulAppSpecific;

    } NDIS_TAPI_SET_APP_SPECIFIC, *PNDIS_TAPI_SET_APP_SPECIFIC;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetAppSpecific(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_APP_SPECIFIC Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetAppSpecific")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulAppSpecific=%d\n",
               Request->hdCall,
               Request->ulAppSpecific
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // The app wants us to save a ulong for him to associate with this call.
    */
    pBChannel->AppSpecificCallInfo = Request->ulAppSpecific;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetCallParams


@func

    This request sets certain call parameters for an existing call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_CALL_PARAMS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_CALL_PARAMS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulBearerMode;
        IN  ULONG       ulMinRate;
        IN  ULONG       ulMaxRate;
        IN  BOOLEAN     bSetLineDialParams;
        IN  LINE_DIAL_PARAMS    LineDialParams;

    } NDIS_TAPI_SET_CALL_PARAMS, *PNDIS_TAPI_SET_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetCallParams(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_CALL_PARAMS Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetCallParams")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulBearerMode=0x%X\n",
               "\tulMinRate=%d\n",
               "\tulMaxRate=%d\n",
               "\tbSetLineDialParams=%d\n",
               "\tLineDialParams=0x%X\n",
               Request->hdCall,
               Request->ulBearerMode,
               Request->ulMinRate,
               Request->ulMaxRate,
               Request->bSetLineDialParams,
               Request->LineDialParams
              ));

    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Make sure the call parameters are valid for us.
    */
    if (Request->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALBEARERMODE);
    }
    if (Request->ulMinRate > _64KBPS ||
        Request->ulMinRate > Request->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    Request->ulMinRate,Request->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }
    if (Request->ulMaxRate && Request->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    Request->ulMinRate,Request->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }

    /*
    // Make sure we've got an active call on this channel.
    */
    if (pBChannel->CallState == 0 ||
        pBChannel->CallState == LINECALLSTATE_IDLE ||
        pBChannel->CallState == LINECALLSTATE_DISCONNECTED)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLSTATE=0x%X\n",
                    pBChannel->CallState));
        return (NDIS_STATUS_TAPI_INVALCALLSTATE);
    }

    /*
    // RASTAPI only places calls through the MAKE_CALL interface.
    // So there's nothing to do here for the time being.
    */

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetMediaMode


@func

    This request changes a call's media mode as stored in the call's
    LINE_CALL_INFO structure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_MEDIA_MODE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_MEDIA_MODE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulMediaMode;

    } NDIS_TAPI_SET_MEDIA_MODE, *PNDIS_TAPI_SET_MEDIA_MODE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetMediaMode(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_MEDIA_MODE Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetMediaMode")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulMediaMode=0x%X\n",
               Request->hdCall,
               Request->ulMediaMode
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    /*
    // If you can detect different medias, you will need to setup to use
    // the selected media here.
    */
    pBChannel->MediaMode = Request->ulMediaMode & pBChannel->MediaModesCaps;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCallStateHandler


@func

    <f TspiCallStateHandler> will indicate the given LINECALLSTATE to the
    Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

*/

VOID TspiCallStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    CallState,                  // @parm
    // The LINECALLSTATE event to be posted to TAPI/WAN.

    IN ULONG                    StateParam                  // @parm
    // This value depends on the event being posted, and some events will
    // pass in zero if they don't use this parameter.
    )
{
    DBG_FUNC("TspiCallStateHandler")

    NDIS_TAPI_EVENT             CallEvent;
    // The event structure passed to the Connection Wrapper.

    BOOLEAN                     TimerCancelled;
    // Flag tells whether call time-out routine was cancelled.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("#%d Call=0x%X CallState=0x%X "
               "NewCallState=0x%X Param=0x%X\n",
               pBChannel->BChannelIndex,
               pBChannel->htCall,
               pBChannel->CallState,
               CallState, StateParam
              ));

    /*
    // Cancel any call time-outs events associated with this link.
    // Don't cancel for network status indications.
    */
    if (CallState != LINECALLSTATE_PROCEEDING &&
        CallState != LINECALLSTATE_RINGBACK &&
        CallState != LINECALLSTATE_UNKNOWN)
    {
        NdisMCancelTimer(&pBChannel->CallTimer, &TimerCancelled);
    }

    /*
    // Init the optional parameters.  They will be set as needed below.
    */
    CallEvent.ulParam2 = StateParam;
    CallEvent.ulParam3 = pBChannel->MediaMode;

    /*
    // OUTGOING) The expected sequence of events for outgoing calls is:
    // 0, LINECALLSTATE_DIALTONE, LINECALLSTATE_DIALING,
    // LINECALLSTATE_PROCEEDING, LINECALLSTATE_RINGBACK,
    // LINECALLSTATE_CONNECTED, LINECALLSTATE_DISCONNECTED,
    // LINECALLSTATE_IDLE
    //
    // INCOMING) The expected sequence of events for incoming calls is:
    // 0, LINECALLSTATE_OFFERING, LINECALLSTATE_ACCEPTED,
    // LINECALLSTATE_CONNECTED, LINECALLSTATE_DISCONNECTED,
    // LINECALLSTATE_IDLE
    //
    // Under certain failure conditions, these sequences may be violated.
    // So I used ASSERTs to verify the normal state transitions which will
    // cause a debug break point if an unusual transition is detected.
    */
    switch (CallState)
    {
    case 0:
    case LINECALLSTATE_IDLE:
        /*
        // Make sure that an idle line is disconnected.
        */
        if (pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE &&
            pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
        {
            DBG_WARNING(pAdapter, ("#%d NOT DISCONNECTED OldState=0x%X\n",
                        pBChannel->BChannelIndex, pBChannel->CallState));
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_UNKNOWN);
        }
        pBChannel->CallStateMode = 0;
        break;

    case LINECALLSTATE_DIALTONE:
        ASSERT(pBChannel->CallState == 0);
        break;

    case LINECALLSTATE_DIALING:
        ASSERT(pBChannel->CallState == 0 ||
               pBChannel->CallState == LINECALLSTATE_DIALTONE);
        break;

    case LINECALLSTATE_PROCEEDING:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        break;

    case LINECALLSTATE_RINGBACK:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        break;

    case LINECALLSTATE_BUSY:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        pBChannel->CallStateMode = StateParam;
        break;

    case LINECALLSTATE_CONNECTED:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_RINGBACK ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING ||
               pBChannel->CallState == LINECALLSTATE_OFFERING ||
               pBChannel->CallState == LINECALLSTATE_ACCEPTED);
        pBChannel->CallStateMode = 0;
        break;

    case LINECALLSTATE_DISCONNECTED:
        ASSERT(pBChannel->CallState == 0 ||
               pBChannel->CallState == LINECALLSTATE_IDLE ||
               pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_RINGBACK ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING ||
               pBChannel->CallState == LINECALLSTATE_OFFERING ||
               pBChannel->CallState == LINECALLSTATE_ACCEPTED ||
               pBChannel->CallState == LINECALLSTATE_CONNECTED ||
               pBChannel->CallState == LINECALLSTATE_DISCONNECTED);
        if (pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE &&
            pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
        {
            pBChannel->CallStateMode = StateParam;
        }
        else
        {
            // Don't do anything if there is no call on this line.
            CallState = pBChannel->CallState;
        }
        break;

    case LINECALLSTATE_OFFERING:
        ASSERT(pBChannel->CallState == 0);
        break;

    case LINECALLSTATE_ACCEPTED:
        ASSERT(pBChannel->CallState == LINECALLSTATE_OFFERING);
        break;

    case LINECALLSTATE_UNKNOWN:
        // Unknown call state doesn't cause any change here.
        CallState = pBChannel->CallState;
        break;

    default:
        DBG_ERROR(pAdapter, ("#%d UNKNOWN CALLSTATE=0x%X IGNORED\n",
                  pBChannel->BChannelIndex, CallState));
        CallState = pBChannel->CallState;
        break;
    }
    /*
    // Change the current CallState and notify the Connection Wrapper if it
    // wants to know about this event.
    */
    if (pBChannel->CallState != CallState)
    {
        pBChannel->CallState = CallState;
        if (pBChannel->CallStatesMask & CallState)
        {
            CallEvent.htLine   = pBChannel->htLine;
            CallEvent.htCall   = pBChannel->htCall;
            CallEvent.ulMsg    = LINE_CALLSTATE;
            CallEvent.ulParam1 = CallState;
            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &CallEvent,
                    sizeof(CallEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
        }
        else
        {
            DBG_NOTICE(pAdapter, ("#%d LINE_CALLSTATE=0x%X EVENT NOT ENABLED\n",
                       pBChannel->BChannelIndex, CallState));
        }
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCallTimerHandler


@func

    <f TspiCallTimerHandler> is called when the CallTimer timeout occurs.
    It will handle the event according to the current CallState and make
    the necessary indications and changes to the call state.

*/

VOID TspiCallTimerHandler(
    IN PVOID                    SystemSpecific1,            // @parm
    // UNREFERENCED_PARAMETER

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("TspiCallTimerHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    DBG_ERROR(pAdapter, ("#%d TIMEOUT CallState=0x%X\n",
              pBChannel->BChannelIndex, pBChannel->CallState));

    switch (pBChannel->CallState)
    {
    case LINECALLSTATE_DIALTONE:
    case LINECALLSTATE_DIALING:
#if !defined(NDIS50_MINIPORT)
        // NDISWAN_BUG
        // NDIS will hang if we try to disconnect before proceeding state!
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_PROCEEDING, 0);
        // Fall through.
#endif // NDIS50_MINIPORT

    case LINECALLSTATE_PROCEEDING:
    case LINECALLSTATE_RINGBACK:
        /*
        // We did not get a connect from remote end,
        // so hangup and abort the call.
        */
        LinkLineError(pBChannel, WAN_ERROR_TIMEOUT);
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_IDLE, 0);
        break;

    case LINECALLSTATE_OFFERING:
    case LINECALLSTATE_ACCEPTED:
        /*
        // Call has been offered, but no one has answered, so reject the call.
        // And
        */
        DChannelRejectCall(pAdapter->pDChannel, pBChannel);
        TspiCallStateHandler(pAdapter, pBChannel, 0, 0);
        break;

    case LINECALLSTATE_DISCONNECTED:
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_IDLE, 0);
        break;

    default:
        break;
    }

    DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspiaddr.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiAddr TspiAddr_c

@module TspiAddr.c |

    This module implements the Telephony Service Provider Interface for
    Address objects.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiAddr_c

@end

*/

#define  __FILEID__             TSPIADDR_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressID


@func

    This request returns the address ID associated with address in a different
    format on the specified line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        OUT ULONG       ulAddressID;
        IN  ULONG       ulAddressMode;
        IN  ULONG       ulAddressSize;
        IN  CHAR        szAddress[1];

    } NDIS_TAPI_GET_ADDRESS_ID, *PNDIS_TAPI_GET_ADDRESS_ID;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL

*/

NDIS_STATUS TspiGetAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressMode=0x%X\n"
               "\tulAddressSize=%d\n"
               "\tszAddress=0x%X\n",
               Request->hdLine,
               Request->ulAddressMode,
               Request->ulAddressSize,
               Request->szAddress
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // We only support ID mode.
    */
    if (Request->ulAddressMode != LINEADDRESSMODE_DIALABLEADDR)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_FAILURE\n"));
        return (NDIS_STATUS_FAILURE);
    }

    /*
    // Make sure we have enough room set aside for this address string.
    */
    if (Request->ulAddressSize > sizeof(pBChannel->pTapiLineAddress)-1)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_RESOURCEUNAVAIL\n"));
        return (NDIS_STATUS_TAPI_RESOURCEUNAVAIL);
    }

    /*
    // This driver only supports one address per link.
    */
    Request->ulAddressID = TSPI_ADDRESS_ID;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressCaps


@func

    This request queries the specified address on the specified line device
    to determine its telephony capabilities.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_CAPS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulAddressID;
        IN  ULONG       ulExtVersion;
        OUT LINE_ADDRESS_CAPS   LineAddressCaps;

    } NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;

    typedef struct _LINE_ADDRESS_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;
        ULONG   ulLineDeviceID;

        ULONG   ulAddressSize;
        ULONG   ulAddressOffset;
        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

        ULONG   ulAddressSharing;
        ULONG   ulAddressStates;
        ULONG   ulCallInfoStates;
        ULONG   ulCallerIDFlags;

        ULONG   ulCalledIDFlags;
        ULONG   ulConnectedIDFlags;
        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectingIDFlags;

        ULONG   ulCallStates;
        ULONG   ulDialToneModes;
        ULONG   ulBusyModes;
        ULONG   ulSpecialInfo;

        ULONG   ulDisconnectModes;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulMaxNumOnHoldCalls;
        ULONG   ulMaxNumOnHoldPendingCalls;

        ULONG   ulMaxNumConference;
        ULONG   ulMaxNumTransConf;
        ULONG   ulAddrCapFlags;
        ULONG   ulCallFeatures;

        ULONG   ulRemoveFromConfCaps;
        ULONG   ulRemoveFromConfState;
        ULONG   ulTransferModes;
        ULONG   ulParkModes;

        ULONG   ulForwardModes;
        ULONG   ulMaxForwardEntries;
        ULONG   ulMaxSpecificEntries;
        ULONG   ulMinFwdNumRings;

        ULONG   ulMaxFwdNumRings;
        ULONG   ulMaxCallCompletions;
        ULONG   ulCallCompletionConds;
        ULONG   ulCallCompletionModes;

        ULONG   ulNumCompletionMessages;
        ULONG   ulCompletionMsgTextEntrySize;
        ULONG   ulCompletionMsgTextSize;
        ULONG   ulCompletionMsgTextOffset;

    } LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetAddressCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressCaps")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        AddressLength;
    // Length of the address string assigned to this line device.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulAddressID=%d\n"
               "\tulExtVersion=0x%X\n",
               Request->ulDeviceID,
               Request->ulAddressID,
               Request->ulExtVersion
              ));
    /*
    // Make sure the address is within range - we only support one per line.
    */
    if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
        return (NDIS_STATUS_TAPI_INVALADDRESSID);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    Request->LineAddressCaps.ulNeededSize =
    Request->LineAddressCaps.ulUsedSize = sizeof(Request->LineAddressCaps);

    Request->LineAddressCaps.ulLineDeviceID = GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);

    /*
    // Return the various address capabilites for the adapter.
    */
    Request->LineAddressCaps.ulAddressSharing = LINEADDRESSSHARING_PRIVATE;
    Request->LineAddressCaps.ulAddressStates = pBChannel->AddressStatesCaps;
    Request->LineAddressCaps.ulCallStates = pBChannel->CallStatesCaps;
    Request->LineAddressCaps.ulDialToneModes = LINEDIALTONEMODE_NORMAL;
    Request->LineAddressCaps.ulDisconnectModes =
            LINEDISCONNECTMODE_NORMAL |
            LINEDISCONNECTMODE_UNKNOWN |
            LINEDISCONNECTMODE_BUSY |
            LINEDISCONNECTMODE_NOANSWER;
    /*
    // This driver does not support conference calls, transfers, or holds.
    */
    Request->LineAddressCaps.ulMaxNumActiveCalls = 1;
    Request->LineAddressCaps.ulAddrCapFlags = LINEADDRCAPFLAGS_DIALED;
    Request->LineAddressCaps.ulCallFeatures = LINECALLFEATURE_ACCEPT |
                                              LINECALLFEATURE_ANSWER |
                                              LINECALLFEATURE_DROP;

    /*
    // RASTAPI requires the "I-L-A" be placed in the Address field at the end
    // of this structure.  Where:
    // I = The device intance assigned to this adapter in the registry
    //     \LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\I
    // L = The device line number associated with this line (1..NumLines)
    // A = The address (channel) to be used on this line (0..NumAddresses-1)
    */
    AddressLength = strlen(pBChannel->pTapiLineAddress);
    Request->LineAddressCaps.ulNeededSize += AddressLength;
    *BytesNeeded += AddressLength;
    if (Request->LineAddressCaps.ulNeededSize <= Request->LineAddressCaps.ulTotalSize)
    {
        Request->LineAddressCaps.ulUsedSize += AddressLength;
        Request->LineAddressCaps.ulAddressSize = AddressLength;
        Request->LineAddressCaps.ulAddressOffset = sizeof(Request->LineAddressCaps);
        NdisMoveMemory((PUCHAR) &Request->LineAddressCaps +
                                 Request->LineAddressCaps.ulAddressOffset,
                pBChannel->pTapiLineAddress,
                AddressLength
                );
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineAddressCaps.ulTotalSize,
                   Request->LineAddressCaps.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressStatus


@func

    This request queries the specified address for its current status.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        OUT LINE_ADDRESS_STATUS LineAddressStatus;

    } NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;

    typedef struct _LINE_ADDRESS_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumInUse;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulAddressFeatures;

        ULONG   ulNumRingsNoAnswer;
        ULONG   ulForwardNumEntries;
        ULONG   ulForwardSize;
        ULONG   ulForwardOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID

*/

NDIS_STATUS TspiGetAddressStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressID=%d\n",
               Request->hdLine,
               Request->ulAddressID
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Make sure the address is within range - we only support one per line.
    */
    if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
        return (NDIS_STATUS_TAPI_INVALADDRESSID);
    }

    Request->LineAddressStatus.ulNeededSize =
    Request->LineAddressStatus.ulUsedSize = sizeof(Request->LineAddressStatus);

    if (Request->LineAddressStatus.ulNeededSize > Request->LineAddressStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineAddressStatus.ulTotalSize,
                   Request->LineAddressStatus.ulNeededSize));
    }

    /*
    // Return the current status information for the line.
    */
    Request->LineAddressStatus.ulNumInUse =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;
    Request->LineAddressStatus.ulNumActiveCalls =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;
    Request->LineAddressStatus.ulAddressFeatures =
            pBChannel->CallState <= LINECALLSTATE_IDLE ?
                LINEADDRFEATURE_MAKECALL : 0;
    Request->LineAddressStatus.ulNumRingsNoAnswer = 999;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetCallAddressID


@func

    This request retrieves the address ID for the indicated call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_ADDRESS_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_ADDRESS_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT ULONG       ulAddressID;

    } NDIS_TAPI_GET_CALL_ADDRESS_ID, *PNDIS_TAPI_GET_CALL_ADDRESS_ID;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallAddressID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Return the address ID associated with this call.
    */
    Request->ulAddressID = TSPI_ADDRESS_ID;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiAddressStateHandler


@func

    <f TspiAddressStateHandler> will indicate the given LINEADDRESSSTATE to
    the Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

@parm IN ULONG | AddressState |
    The LINEADDRESSSTATE event to be posted to TAPI/WAN.

*/

VOID TspiAddressStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    AddressState
    )
{
    DBG_FUNC("TspiAddressStateHandler")

    /*
    // The event structure passed to the Connection Wrapper.
    */
    NDIS_TAPI_EVENT Event;

    DBG_ENTER(pAdapter);

    if (pBChannel->AddressStatesMask & AddressState)
    {
        Event.htLine   = pBChannel->htLine;
        Event.htCall   = pBChannel->htCall;
        Event.ulMsg    = LINE_CALLSTATE;
        Event.ulParam1 = AddressState;
        Event.ulParam2 = 0;
        Event.ulParam3 = 0;

        /*
        // We really don't have much to do here with this adapter.
        // And RASTAPI doesn't handle these events anyway...
        */
        switch (AddressState)
        {
        case LINEADDRESSSTATE_INUSEZERO:
            break;

        case LINEADDRESSSTATE_INUSEONE:
            break;
        }
        NdisMIndicateStatus(
                pAdapter->MiniportAdapterHandle,
                NDIS_STATUS_TAPI_INDICATION,
                &Event,
                sizeof(Event)
                );
        pAdapter->NeedStatusCompleteIndication = TRUE;
    }
    else
    {
        DBG_NOTICE(pAdapter, ("#%d ADDRESSSTATE EVENT=0x%X IS NOT ENABLED\n",
                   pBChannel->BChannelIndex, AddressState));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspiline.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiLine TspiLine_c

@module TspiLine.c |

    This module implements the Telephony Service Provider Interface for
    Line objects (TapiLine).

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiLine_c

@end

*/

#define  __FILEID__             TSPILINE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiLine TspiLine_c TspiOpen


@func

    This function opens the line device whose device ID is given, returning
    the miniport's handle for the device. The miniport must retain the
    Connection Wrapper's handle for the device for use in subsequent calls to
    the LINE_EVENT callback procedure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_OPEN | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_OPEN
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  HTAPI_LINE  htLine;
        OUT HDRV_LINE   hdLine;

    } NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_ALLOCATED
    NDIS_STATUS_TAPI_NODRIVER

*/

NDIS_STATUS TspiOpen(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_OPEN          Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiOpen")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\thtLine=0x%X\n",
               Request->ulDeviceID,
               Request->htLine
              ));

    /*
    // If there is no DChannel, we can't allow an open line.
    */
    if (pAdapter->pDChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Make sure the requested line device is not already in use.
    */
    if (BChannelOpen(pBChannel, Request->htLine) != NDIS_STATUS_SUCCESS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_ALLOCATED\n"));
        return (NDIS_STATUS_TAPI_ALLOCATED);
    }

    /*
    // Tell the wrapper the line context and set the line/call state.
    */
    Request->hdLine = (HDRV_LINE) pBChannel;

    /*
    // Make sure the line is configured for dialing when we open up.
    */
    TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_OPEN);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiClose


@func

    This request closes the specified open line device after completing or
    aborting all outstanding calls and asynchronous requests on the device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CLOSE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CLOSE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;

    } NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiClose(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE         Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiClose")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n",
               Request->hdLine
              ));
    /*
    // This request must be associated with a line device.
    // And it must not be called until all calls are closed or idle.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL ||
        (pBChannel->DevState & LINEDEVSTATE_OPEN) == 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Close the TAPI line device and release the channel.
    */
    BChannelClose(pBChannel);

    TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CLOSE);

    Result = NDIS_STATUS_SUCCESS;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiGetLineDevStatus


@func

    This request queries the specified open line device for its current status.
    The information returned is global to all addresses on the line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_LINE_DEV_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_LINE_DEV_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        OUT LINE_DEV_STATUS LineDevStatus;

    } NDIS_TAPI_GET_LINE_DEV_STATUS, *PNDIS_TAPI_GET_LINE_DEV_STATUS;

    typedef struct _LINE_DEV_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumOpens;
        ULONG   ulOpenMediaModes;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulLineFeatures;
        ULONG   ulNumCallCompletions;
        ULONG   ulRingMode;
        ULONG   ulSignalLevel;
        ULONG   ulBatteryLevel;
        ULONG   ulRoamMode;

        ULONG   ulDevStatusFlags;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_STATUS, *PLINE_DEV_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiGetLineDevStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_LINE_DEV_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetLineDevStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n",
               Request->hdLine
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    Request->LineDevStatus.ulNeededSize =
    Request->LineDevStatus.ulUsedSize = sizeof(Request->LineDevStatus);

    if (Request->LineDevStatus.ulNeededSize > Request->LineDevStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineDevStatus.ulTotalSize,
                   Request->LineDevStatus.ulNeededSize));
    }

    /*
    // Return the current line status information.
    */
    Request->LineDevStatus.ulNumOpens = 1;

    Request->LineDevStatus.ulNumActiveCalls =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;

    Request->LineDevStatus.ulLineFeatures =
            pBChannel->CallState <= LINECALLSTATE_IDLE ?
                LINEFEATURE_MAKECALL : 0;

    Request->LineDevStatus.ulRingMode =
            pBChannel->CallState == LINECALLSTATE_OFFERING ? 1: 0;

    Request->LineDevStatus.ulDevStatusFlags =
            (pBChannel->DevState & LINEDEVSTATE_CONNECTED) ?
                LINEDEVSTATUSFLAGS_CONNECTED : 0;

    Request->LineDevStatus.ulDevStatusFlags |=
            (pBChannel->DevState & LINEDEVSTATE_INSERVICE) ?
                LINEDEVSTATUSFLAGS_INSERVICE : 0;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiSetDefaultMediaDetection


@func

    This request informs the miniport of the new set of media modes to detect
    for the indicated line (replacing any previous set).

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;

    } NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION, *PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

@comm

    <f Note>:
    After a miniport NIC driver has received an OPEN request for a line, it
    may also receive one or more SET_DEFAULT_MEDIA_DETECTION requests. This
    latter request informs the NIC driver of the type(s) of incoming calls,
    with respect to media mode, it should indicate to the Connection Wrapper
    with the LINE_NEWCALL message. If an incoming call appears with a media
    mode type not specified in the last (successfully completed)
    SET_DEFAULT_MEDIA_DETECTION request for that line, the miniport should
    not indicate the new call to the Connection Wrapper. If a miniport does
    not receive a SET_DEFAULT_MEDIA_DETECTION request for a line, it should
    not indicate any incoming calls to the Connection Wrapper; that line is
    to be used only for outbound calls.

*/

NDIS_STATUS TspiSetDefaultMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetDefaultMediaDetection")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulMediaModes=0x%X\n",
               Request->hdLine,
               Request->ulMediaModes
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaModes & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    /*
    // Set the media modes mask and make sure the adapter is ready to
    // accept incoming calls.  If you can detect different medias, you
    // will need to notify the approriate interface for the media detected.
    */
    pBChannel->MediaModesMask = Request->ulMediaModes & pBChannel->MediaModesCaps;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c XXX

@func

    This request is invoked by the Connection Wrapper whenever a client
    application uses LINEMAPPER as the dwDeviceID in the lineOpen function
    to request that lines be scanned to find one that supports the desired
    media mode(s) and call parameters. The Connection Wrapper scans based on
    the union of the desired media modes and the other media modes currently
    being monitored on the line, to give the miniport the opportunity to
    indicate if it cannot simultaneously monitor for all of the requested
    media modes. If the miniport can monitor for the indicated set of media
    modes AND support the capabilities indicated in CallParams, it replies
    with a success inidication. It leaves the active media monitoring modes
    for the line unchanged.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION, *PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiConditionalMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiConditionalMediaDetection")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulMediaModes=0x%X\n"
               "\tLineCallParams=0x%X\n",
               Request->hdLine,
               Request->ulMediaModes,
               &Request->LineCallParams
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // We don't expect user user info.
    */
    ASSERT(Request->LineCallParams.ulUserUserInfoSize == 0);

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaModes & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiSetStatusMessages


@func

    This request enables the Connection Wrapper to specify which notification
    messages the miniport should generate for events related to status changes
    for the specified line or any of its addresses. By default, address and
    line status reporting is initially disabled for a line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_STATUS_MESSAGES | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulLineStates;
        IN  ULONG       ulAddressStates;

    } NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        This function always returns success.

*/

NDIS_STATUS TspiSetStatusMessages(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetStatusMessages")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulLineStates=0x%X\n"
               "\tulAddressStates=0x%X\n",
               Request->hdLine,
               Request->ulLineStates,
               Request->ulAddressStates
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // TAPI may pass down more than we are capable of handling.
    // We have to accept the request, but can ignore the extras.
    */
    if (Request->ulLineStates & ~pBChannel->DevStatesCaps)
    {
        DBG_WARNING(pAdapter, ("ulLineStates=0x%X !< DevStatesCaps=0x%X\n",
                   Request->ulLineStates, pBChannel->DevStatesCaps));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }

    /*
    // TAPI may pass down more than we are capable of handling.
    // We have to accept the request, but can ignore the extras.
    */
    if (Request->ulAddressStates & ~pBChannel->AddressStatesCaps)
    {
        DBG_WARNING(pAdapter, ("ulAddressStates=0x%X !< AddressStatesCaps=0x%X\n",
                   Request->ulAddressStates, pBChannel->AddressStatesCaps));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }

    /*
    // Save the new event notification masks so we will only indicate the
    // appropriate events.
    */
    pBChannel->DevStatesMask     = Request->ulLineStates & pBChannel->DevStatesCaps;
    pBChannel->AddressStatesMask = Request->ulAddressStates & pBChannel->AddressStatesCaps;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiLineDevStateHandler


@func

    <f TspiLineDevStateHandler> will indicate the given LINEDEVSTATE to the
    Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

*/

VOID TspiLineDevStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    LineDevState                // @parm
    // The <t LINEDEVSTATE> event to be posted to TAPI/WAN.
    )
{
    DBG_FUNC("TspiLineDevStateHandler")

    NDIS_TAPI_EVENT             LineEvent;
    NDIS_TAPI_EVENT             CallEvent;
    // The event structure passed to the Connection Wrapper.

    ULONG                       NewCallState = 0;
    ULONG                       StateParam = 0;
    // The line state change may cause a call state change as well.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("#%d OldState=0x%X "
               "NewState=0x%X\n",
               pBChannel->BChannelIndex,
               pBChannel->DevState,
               LineDevState
              ));

    LineEvent.ulParam2 = 0;
    LineEvent.ulParam3 = 0;

    /*
    // Handle the line state transition as needed.
    */
    switch (LineDevState)
    {
    case LINEDEVSTATE_RINGING:
        /*
        // We have an incoming call, see if there's anyone who cares.
        */
        if (pBChannel->CallState == 0 &&
            pBChannel->MediaModesMask)
        {
            LineEvent.ulParam2 = 1;     // only one RingMode
            NewCallState = LINECALLSTATE_OFFERING;
        }
        else
        {
            DChannelRejectCall(pAdapter->pDChannel, pBChannel);
        }
        break;

    case LINEDEVSTATE_CONNECTED:
        /*
        // The line has been connected, but we may already know this.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_CONNECTED) == 0)
        {
            pBChannel->DevState |= LINEDEVSTATE_CONNECTED;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_DISCONNECTED:
        /*
        // The line has been dis-connected, but we may already know this.
        // If not, this will effect any calls on the line.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_CONNECTED) != 0)
        {
            pBChannel->DevState &= ~(LINEDEVSTATE_CONNECTED |
                                     LINEDEVSTATE_INSERVICE);
            NewCallState = LINECALLSTATE_DISCONNECTED;
            StateParam = LINEDISCONNECTMODE_NORMAL;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_INSERVICE:
        /*
        // The line has been placed in service, but we may already know this.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) == 0)
        {
            pBChannel->DevState |= LINEDEVSTATE_INSERVICE;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_OUTOFSERVICE:
        /*
        // The line has been taken out of service, but we may already know this.
        // If not, this will effect any calls on the line.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) != 0)
        {
            pBChannel->DevState &= ~LINEDEVSTATE_INSERVICE;
            NewCallState = LINECALLSTATE_DISCONNECTED;
            StateParam = LINEDISCONNECTMODE_UNKNOWN;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_OPEN:
        pBChannel->DevState |= LINEDEVSTATE_OPEN;
        pAdapter->NumLineOpens++;
        break;

    case LINEDEVSTATE_CLOSE:
        pBChannel->DevState &= ~LINEDEVSTATE_OPEN;
        pAdapter->NumLineOpens--;
        break;
    }

    /*
    // If this is the first indication of an incoming call, we need to
    // let TAPI know about it so we can get a htCall handle associated
    // with it.
    */
    if (pBChannel->DevState & LINEDEVSTATE_OPEN)
    {
        if (NewCallState == LINECALLSTATE_OFFERING)
        {
            CallEvent.htLine   = pBChannel->htLine;
            CallEvent.htCall   = (HTAPI_CALL)0;
            CallEvent.ulMsg    = LINE_NEWCALL;
            CallEvent.ulParam1 = (ULONG) (ULONG_PTR) pBChannel;
            CallEvent.ulParam2 = 0;
            CallEvent.ulParam3 = 0;

            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &CallEvent,
                    sizeof(CallEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
            pBChannel->htCall = (HTAPI_CALL)CallEvent.ulParam2;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d Call=0x%X CallState=0x%X NEW_CALL\n",
                       pBChannel->BChannelIndex,
                       pBChannel->htCall, pBChannel->CallState));

            if (pBChannel->htCall == 0)
            {
                /*
                // TAPI won't accept the call, so toss it.
                */
                NewCallState = 0;
                LineDevState = 0;
            }
        }

        /*
        // Only send those line messages TAPI wants to hear about.
        */
        if (pBChannel->DevStatesMask & LineDevState)
        {
            LineEvent.htLine   = pBChannel->htLine;
            LineEvent.htCall   = pBChannel->htCall;
            LineEvent.ulMsg    = LINE_LINEDEVSTATE;
            LineEvent.ulParam1 = LineDevState;

            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &LineEvent,
                    sizeof(LineEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d Line=0x%X LineState=0x%X\n",
                       pBChannel->BChannelIndex,
                       pBChannel->htLine, LineDevState));
        }
        else
        {
            DBG_NOTICE(pAdapter, ("#%d LINEDEVSTATE=0x%X EVENT NOT ENABLED\n",
                       pBChannel->BChannelIndex, LineDevState));
        }

        if (NewCallState != 0)
        {
            /*
            // Check to see if we need to disconnect the call, but only
            // if there is one active.
            */
            if (NewCallState == LINECALLSTATE_DISCONNECTED)
            {
                if (pBChannel->CallState != 0 &&
                    pBChannel->CallState != LINECALLSTATE_IDLE &&
                    pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
                {
                    TspiCallStateHandler(pAdapter, pBChannel,
                                         NewCallState, StateParam);
#if defined(NDIS40_MINIPORT)
                    /*
                    // NDISWAN_BUG
                    // Under some conditions, NDISWAN does not do a CLOSE_CALL,
                    // so the line would be left unusable if we don't timeout
                    // and force a close call condition.
                    */
                    NdisMSetTimer(&pBChannel->CallTimer, CARD_NO_CLOSECALL_TIMEOUT);
#endif // NDIS50_MINIPORT
                }
            }
            else
            {
                TspiCallStateHandler(pAdapter, pBChannel,
                                     NewCallState, StateParam);
                if (NewCallState == LINECALLSTATE_OFFERING)
                {
                    /*
                    // If an offered call is not accepted within N seconds, we
                    // need to force the line back to an idle state.
                    */
                    NdisMSetTimer(&pBChannel->CallTimer, pAdapter->NoAcceptTimeOut);
                }
            }
        }
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tspidev.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiDev TspiDev_c

@module TspiDev.c |

    This module implements the Telephony Service Provider Interface for
    TapiDevice objects.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiDev_c

@end

*/

#define  __FILEID__             TSPIDEV_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiDev TspiDev_c TspiGetDevCaps


@func

    This request queries a specified line device to determine its telephony
    capabilities. The returned information is valid for all addresses on the
    line device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_DEV_CAPS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_DEV_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulExtVersion;
        OUT LINE_DEV_CAPS   LineDevCaps;

    } NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;

    typedef struct _LINE_DEV_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulProviderInfoSize;
        ULONG   ulProviderInfoOffset;

        ULONG   ulSwitchInfoSize;
        ULONG   ulSwitchInfoOffset;

        ULONG   ulPermanentLineID;
        ULONG   ulLineNameSize;
        ULONG   ulLineNameOffset;
        ULONG   ulStringFormat;

        ULONG   ulAddressModes;
        ULONG   ulNumAddresses;
        ULONG   ulBearerModes;
        ULONG   ulMaxRate;
        ULONG   ulMediaModes;

        ULONG   ulGenerateToneModes;
        ULONG   ulGenerateToneMaxNumFreq;
        ULONG   ulGenerateDigitModes;
        ULONG   ulMonitorToneMaxNumFreq;
        ULONG   ulMonitorToneMaxNumEntries;
        ULONG   ulMonitorDigitModes;
        ULONG   ulGatherDigitsMinTimeout;
        ULONG   ulGatherDigitsMaxTimeout;

        ULONG   ulMedCtlDigitMaxListSize;
        ULONG   ulMedCtlMediaMaxListSize;
        ULONG   ulMedCtlToneMaxListSize;
        ULONG   ulMedCtlCallStateMaxListSize;

        ULONG   ulDevCapFlags;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulAnswerMode;
        ULONG   ulRingModes;
        ULONG   ulLineStates;

        ULONG   ulUUIAcceptSize;
        ULONG   ulUUIAnswerSize;
        ULONG   ulUUIMakeCallSize;
        ULONG   ulUUIDropSize;
        ULONG   ulUUISendUserUserInfoSize;
        ULONG   ulUUICallInfoSize;

        LINE_DIAL_PARAMS    MinDialParams;
        LINE_DIAL_PARAMS    MaxDialParams;
        LINE_DIAL_PARAMS    DefaultDialParams;

        ULONG   ulNumTerminals;
        ULONG   ulTerminalCapsSize;
        ULONG   ulTerminalCapsOffset;
        ULONG   ulTerminalTextEntrySize;
        ULONG   ulTerminalTextSize;
        ULONG   ulTerminalTextOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_CAPS, *PLINE_DEV_CAPS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetDevCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetDevCaps")

    static UCHAR                LineDeviceName[] = VER_DEVICE_STR " Line 00";
    static UCHAR                LineSwitchName[] = VER_DEVICE_STR " Switch";

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        InfoOffset;
    // Offset from the start of the Request buffer to the various information
    // fields we fill in and return to the caller.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulExtVersion=0x%X\n"
               "\tLineDevCaps=0x%X\n",
               Request->ulDeviceID,
               Request->ulExtVersion,
               &Request->LineDevCaps
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    Request->LineDevCaps.ulNeededSize =
    Request->LineDevCaps.ulUsedSize = sizeof(Request->LineDevCaps);

    /*
    // The driver numbers lines sequentially from 1, so this will always
    // be the same number.
    */
    Request->LineDevCaps.ulPermanentLineID = pBChannel->BChannelIndex+1;

    /*
    // All the strings are ASCII format rather than UNICODE.
    */
    Request->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;

    /*
    // Report the capabilities of this device.
    */
    Request->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID;
    Request->LineDevCaps.ulNumAddresses = 1;
    Request->LineDevCaps.ulBearerModes  = pBChannel->BearerModesCaps;
    Request->LineDevCaps.ulMaxRate      = pBChannel->LinkSpeed;
    Request->LineDevCaps.ulMediaModes   = pBChannel->MediaModesCaps;

    /*
    // Each line on the PRI only supports a single call.
    */
    Request->LineDevCaps.ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
    Request->LineDevCaps.ulMaxNumActiveCalls = 1;
    Request->LineDevCaps.ulAnswerMode = LINEANSWERMODE_DROP;
    Request->LineDevCaps.ulRingModes  = 1;
    Request->LineDevCaps.ulLineStates = pBChannel->DevStatesCaps;

    /*
    // RASTAPI requires the "MediaType\0DeviceName" be placed in the
    // ProviderInfo field at the end of this structure.
    */
    InfoOffset = sizeof(Request->LineDevCaps);
    Request->LineDevCaps.ulNeededSize += pAdapter->ProviderInfoSize;
    *BytesNeeded += pAdapter->ProviderInfoSize;
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        Request->LineDevCaps.ulProviderInfoSize   = pAdapter->ProviderInfoSize;
        Request->LineDevCaps.ulProviderInfoOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                pAdapter->ProviderInfo,
                pAdapter->ProviderInfoSize
                );
        Request->LineDevCaps.ulUsedSize += pAdapter->ProviderInfoSize;
        InfoOffset += pAdapter->ProviderInfoSize;
    }

    /*
    // LineName is displayed by the Dialup Networking App.
    // UniModem TSP returns the modem name here.
    // We'll return the name of the line.
    */
    Request->LineDevCaps.ulNeededSize += sizeof(LineDeviceName);
    *BytesNeeded += sizeof(LineDeviceName);
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        // FIXME - This code only handles 99 lines!
        LineDeviceName[sizeof(LineDeviceName)-3] = '0' +
                        (UCHAR) Request->LineDevCaps.ulPermanentLineID / 10;
        LineDeviceName[sizeof(LineDeviceName)-2] = '0' +
                        (UCHAR) Request->LineDevCaps.ulPermanentLineID % 10;

        Request->LineDevCaps.ulLineNameSize   = sizeof(LineDeviceName);
        Request->LineDevCaps.ulLineNameOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                LineDeviceName,
                sizeof(LineDeviceName)
                );
        Request->LineDevCaps.ulUsedSize += sizeof(LineDeviceName);
        InfoOffset += sizeof(LineDeviceName);
    }

    /*
    // SwitchName is not yet displayed by the Dialup Networking App,
    // but we'll return something reasonable just in case.
    */
    Request->LineDevCaps.ulNeededSize += sizeof(LineSwitchName);
    *BytesNeeded += sizeof(LineSwitchName);
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        Request->LineDevCaps.ulSwitchInfoSize   = sizeof(LineSwitchName);
        Request->LineDevCaps.ulSwitchInfoOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                LineSwitchName,
                sizeof(LineSwitchName)
                );
        Request->LineDevCaps.ulUsedSize += sizeof(LineSwitchName);
        InfoOffset += sizeof(LineSwitchName);
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineDevCaps.ulTotalSize,
                   Request->LineDevCaps.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiGetDevConfig


@func

    This request returns a data structure object, the contents of which are
    specific to the line (miniport) and device class, giving the current
    configuration of a device associated one-to-one with the line device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_DEV_CONFIG | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_DEV_CONFIG
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceConfig;

    } NDIS_TAPI_GET_DEV_CONFIG, *PNDIS_TAPI_GET_DEV_CONFIG;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetDevConfig")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X = '%s'\n",
               Request->ulDeviceID,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset)
              ));
    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Now we need to adjust the variable field to place the requested device
    // configuration.
    */
#   define DEVCONFIG_INFO       "Dummy Configuration Data"
#   define SIZEOF_DEVCONFIG     0 // sizeof(DEVCONFIG_INFO)

    Request->DeviceConfig.ulNeededSize = sizeof(VAR_STRING) + SIZEOF_DEVCONFIG;
    Request->DeviceConfig.ulUsedSize = sizeof(VAR_STRING);

    *BytesNeeded += SIZEOF_DEVCONFIG;
    if (Request->DeviceConfig.ulTotalSize >= Request->DeviceConfig.ulNeededSize)
    {
        Request->DeviceConfig.ulUsedSize     = Request->DeviceConfig.ulNeededSize;
        Request->DeviceConfig.ulStringFormat = STRINGFORMAT_BINARY;
        Request->DeviceConfig.ulStringSize   = SIZEOF_DEVCONFIG;
        Request->DeviceConfig.ulStringOffset = sizeof(VAR_STRING);

        /*
        // There are currently no return values defined for this case.
        // This is just a place holder for future extensions.
        */
        NdisMoveMemory((PUCHAR) &Request->DeviceConfig + sizeof(VAR_STRING),
               DEVCONFIG_INFO,
               SIZEOF_DEVCONFIG
               );
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->DeviceConfig.ulTotalSize,
                   Request->DeviceConfig.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiSetDevConfig


@func

    This request restores the configuration of a device associated one-to-one
    with the line device from an  data structure previously obtained using
    OID_TAPI_GET_DEV_CONFIG.  The contents of this data structure are specific
    to the line (miniport) and device class.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_DEV_CONFIG | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_DEV_CONFIG
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        IN  ULONG       ulDeviceConfigSize;
        IN  UCHAR       DeviceConfig[1];

    } NDIS_TAPI_SET_DEV_CONFIG, *PNDIS_TAPI_SET_DEV_CONFIG;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALPARAM
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiSetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetDevConfig")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X = '%s'\n"
               "\tulDeviceConfigSize=%d\n",
               Request->ulDeviceID,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset),
               Request->ulDeviceConfigSize
              ));
    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Make sure this configuration is the proper size.
    */
    if (Request->ulDeviceConfigSize)
    {
        if (Request->ulDeviceConfigSize != SIZEOF_DEVCONFIG)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALPARAM Size!=%d\n",
                        SIZEOF_DEVCONFIG));
            return (NDIS_STATUS_TAPI_INVALPARAM);
        }

        /*
        // Retore the configuration information returned by TspiGetDevConfig.
        //
        // There are currently no configuration values defined this case.
        // This is just a place holder for future extensions.
        */
        else if (!STR_EQU(Request->DeviceConfig,
                  DEVCONFIG_INFO, SIZEOF_DEVCONFIG))
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALPARAM DevCfg=0x%X\n",
                    *((ULONG *) &Request->DeviceConfig[0]) ));
#if DBG
            DbgPrintData(Request->DeviceConfig, SIZEOF_DEVCONFIG, 0);
#endif // DBG
            // Since we don't use this info, we'll just return success.
            // return (NDIS_STATUS_TAPI_INVALPARAM);
        }
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiGetID


@func

    This request returns a device ID for the specified device class
    associated with the selected line, address or call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulSelect;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceID;

    } NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

*/

NDIS_STATUS TspiGetID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    /*
    // A pointer to the requested device ID, and its size in bytes.
    */
    PUCHAR                      IDPtr;
    UINT                        IDLength;
    TAPI_DEVICE_ID              DeviceID;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressID=%d\n"
               "\thdCall=0x%X\n"
               "\tulSelect=0x%X\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X='%s'\n",
               Request->hdLine,
               Request->ulAddressID,
               Request->hdCall,
               Request->ulSelect,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset)
              ));

    /*
    // If there is no DChannel, we can't allow this.
    */
    if (pAdapter->pDChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // Find the link structure associated with the request/deviceclass.
    */
    if (Request->ulSelect == LINECALLSELECT_LINE)
    {
        pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
        }
        /*
        // TAPI wants the ulDeviceID for this line.
        */
        DeviceID.hDevice = (ULONG) GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    }
    else if (Request->ulSelect == LINECALLSELECT_ADDRESS)
    {
        pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
        }

        if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
            return (NDIS_STATUS_TAPI_INVALADDRESSID);
        }
        /*
        // TAPI wants the ulDeviceID for this line.
        */
        DeviceID.hDevice = (ULONG) GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    }
    else if (Request->ulSelect == LINECALLSELECT_CALL)
    {
        pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
        }
        /*
        // TAPI wants the htCall for this line.
        */
        DeviceID.hDevice = (ULONG) (ULONG_PTR) (pBChannel->htCall);
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_FAILURE\n"));
        return (NDIS_STATUS_FAILURE);
    }

    /*
    // NT RAS only expects to see hDevice.
    // Win95 RAS expects to see hDevice followed by "isdn\0".
    */
    IDLength = strlen(VER_DEFAULT_MEDIATYPE) + 1;
    NdisMoveMemory(&DeviceID.DeviceName, VER_DEFAULT_MEDIATYPE, IDLength);
    IDLength += sizeof(ULONG);
    IDPtr = (PUCHAR) &DeviceID;

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
               ("#%d Call=0x%X CallState=0x%X GETID-%d=0x%X-'%s'@%dKbps\n",
               pBChannel->BChannelIndex,
               pBChannel->htCall, pBChannel->CallState,
               Request->ulSelect, DeviceID.hDevice, DeviceID.DeviceName,
               pBChannel->LinkSpeed/1000));

    /*
    // Now we need to adjust the variable field to place the device ID.
    */
    Request->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
    Request->DeviceID.ulUsedSize  = sizeof(VAR_STRING);

    *BytesNeeded += IDLength;
    if (Request->DeviceID.ulTotalSize >= Request->DeviceID.ulNeededSize)
    {
        Request->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
        Request->DeviceID.ulUsedSize     = Request->DeviceID.ulNeededSize;
        Request->DeviceID.ulStringSize   = IDLength;
        Request->DeviceID.ulStringOffset = sizeof(VAR_STRING);

        /*
        // Now we return the requested ID value.
        */
        NdisMoveMemory(
                (PCHAR) &Request->DeviceID + sizeof(VAR_STRING),
                IDPtr,
                IDLength
                );
    }
    else
    {
        if ((Request->DeviceID.ulNeededSize - Request->DeviceID.ulTotalSize) >=
            sizeof(ULONG))
        {
            /*
            // Return just the hDevice part (the first 4 bytes).
            */
            NdisMoveMemory(
                    (PCHAR) &Request->DeviceID + sizeof(VAR_STRING),
                    IDPtr,
                    sizeof(ULONG)
                    );
            Request->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            Request->DeviceID.ulUsedSize    += sizeof(ULONG);
            Request->DeviceID.ulStringSize   = sizeof(ULONG);
            Request->DeviceID.ulStringOffset = sizeof(VAR_STRING);
        }

        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->DeviceID.ulTotalSize,
                   Request->DeviceID.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vtargnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_FILE_MAJOR_NUM      0
#define VER_FILE_MINOR_NUM      7
#define VER_FILE_SUB_MINOR_NUM  0
#define VER_FILE_MAJOR_STR      "0"
#define VER_FILE_MINOR_STR      "07"
#define VER_FILE_SUB_MINOR_STR  "00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vtarget.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.



@doc INTERNAL TpiBuild vTarget vTarget_h

@module vTarget.h |

    This module defines the version information as displayed in the Windows
    file property sheet.  You must change the fields below as appropriate
    for your target.  This file is then included by <f vTarget\.rc> to
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vTarget_h

@end

*/

#ifndef _VTARGET_H_
#define _VTARGET_H_

// The following file should be included from the project's include directory
#include <vProduct.h>   // Product specific information

// Base name of this target.
#define VER_TARGET_STR                  VER_PRODUCT_STR
// File name this target is distributed under.
#define VER_ORIGINAL_FILE_NAME_STR      DEFINE_STRING(VER_TARGET_STR ".sys")
// Description displayed in the Windows file property sheet - limit to 40 characters.
#define VER_FILE_DESCRIPTION_STR        DEFINE_STRING(VER_PRODUCT_STR \
                                        " NDIS WAN/TAPI Miniport for Windows.")
// Take credit for a job well done...
#define VER_INTERNAL_NAME_STR           "larryh@tpi.com"
// Look in winver.h for the proper settings of these values.
#define VER_FILE_OS                     VOS__WINDOWS32      // dwFileOS
#define VER_FILE_TYPE                   VFT_DRV             // dwFileType
#define VER_FILE_SUB_TYPE               VFT2_DRV_NETWORK    // dwFileSubtype

#endif // _VTARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vprodnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_PRODUCT_MAJOR_NUM      0
#define VER_PRODUCT_MINOR_NUM      7
#define VER_PRODUCT_SUB_MINOR_NUM  0
#define VER_PRODUCT_BUILD_NUM      24
#define VER_PRODUCT_MAJOR_STR      "0"
#define VER_PRODUCT_MINOR_STR      "07"
#define VER_PRODUCT_SUB_MINOR_STR  "00"
#define VER_PRODUCT_BUILD_STR      "0024"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vvendor.h ===
/*

                                                                             
    (C) Copyright 1998 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.



@doc INTERNAL TpiBuild vVendor vVendor_h

@module vVendor.h |

    This module defines the version information as displayed in the Windows 
    file property sheet.  You must change the fields below as appropriate 
    for your product.  This file is then included by <f vTarget\.rc> to 
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vVendor_h

@end

*/

#ifndef _VVENDOR_H_
#define _VVENDOR_H_

// Short vendor name - no spaces - limit to 32 characters if possible.
#define VER_VENDOR_STR                  "TriplePoint"
// Long vendor name - legal name of the company.
#define VER_VENDOR_NAME_STR             "TriplePoint, Inc."
// Legal copyright notice - limit to to 40 characters for appearance.
#define VER_COPYRIGHT_STR               "Copyright \251 1998"
// Short product name - no spaces - limit to 32 characters if possible.
#define VER_PRODUCT_STR                 "IsdnWan"
// Long product name - usually the same as put on the product packaging.
#define VER_PRODUCT_NAME_STR            "TriplePoint ISDNWAN Miniport for Windows."
// Vendor and product name - typically used as a registry key.
#define VER_VENDOR_PRODUCT_STR          VER_VENDOR_STR "\\" VER_PRODUCT_STR
// Device description used to identify the device in the NDIS/TAPI user interface.
#define VER_DEVICE_STR                  "TriplePoint ISDNWAN"
// IEEE Organization Unique Identifier assigned to your company.
#define VER_VENDOR_ID                   "TPI"
// Set according to NDISWAN MediaType supported by the driver.
#define VER_DEFAULT_MEDIATYPE           "ISDN"
// The default AddressList for the line devices supported by the driver.
#define VER_DEFAULT_ADDRESSLIST         "1-1-0\0" L"1-2-0\0"

#endif // _VVENDOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\vproduct.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vProduct vProduct_h

@module vProduct.h |

    This module defines the product version information.  It is included by 
    all the target components of the project by including <f vTarget\.h>.

    <f Note>:
    This file should not be changed.  The definitions used by this file 
    are defined in <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and 
    <f vTargNum\.h>

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vProduct_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic Versioning Overview |

    This section describes the interfaces defined in <f vProduct\.h>,
    <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and <f vTargNum\.h>

    A module is usually just one component of an entire product, so we've
    defined the versioning information for the module so that it can be
    easily included into a complete product package.
    
@flag <f vTarget\.rc> |
    Included this into your module specific rc file.  Do not change.
    You must remove any existing versioning information from your rc file.
    Place this file in a common include directory for the product.

@flag <f vTarget\.h> |
    Defines the module specific version information such as file name, type, etc.
    One of these files would exist for each component included in your product.

@flag <f vTargNum\.h> |
    Is meant to be updated whenever you make a change to a specific module.
    One of these files would exist for each component included in your product.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    
@flag <f vVendor\.h> |
    Defines the vendor specific version information such as company name,
    copyright. etc.  It is separate to allow easier OEM customization.
    Place this file in a common include directory for the product.
    
@flag <f vProdNum\.h> |
    Is meant to be updated whenever you release a new product version.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    Place this file in a common include directory for the product.
    
@flag <f vLang\.h> |
    Defines the language to be used to record the version information.
    If this file is modified for another language, you will generally have 
    to create localized versions of the vVendor.h and vTarget.h files as well.
    Place this file in a common include directory for the product.
    
@flag <f vProduct\.rc> |
    Is included by <f vTarget\.rc>.  Do not change.
    Place this file in a common include directory for the product.

@flag <f vProduct\.h> |
    Is included by <f vTarget\.h>.  You should not change this file unless you
    want to change the way version numbers are represented for all modules in
    your product.
    Place this file in a common include directory for the product.

*/

#ifndef _VPRODUCT_H_
#define _VPRODUCT_H_

#if !defined(_VTARGET_H_)
#  error You should not include vProduct.h directly, include vTarget.h instead.
#endif

// Only include winver.h if RC_INVOKED.  Otherwise we don't need it.
#if defined(RC_INVOKED)
# if defined(WIN32)
#  include <winver.h>
# else
#  include <ver.h>
# endif
#endif

#include "vVendor.h"    // Edit this file to change vendor specific information
#include "vLang.h"      // Edit this file to change language specific information

// The following file should be included from the target's include directory
#include "vTargNum.h"   // Target version information

#if !defined(VER_FILE_MAJOR_NUM) || !defined(VER_FILE_MINOR_NUM) || \
    !defined(VER_FILE_SUB_MINOR_NUM)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_FILE_MAJOR_STR) || !defined(VER_FILE_MINOR_STR) || \
    !defined(VER_FILE_SUB_MINOR_STR)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// The following file should be included from the project's include directory
#include "vProdNum.h"   // Product version and build information

#if !defined(VER_PRODUCT_MAJOR_NUM) || !defined(VER_PRODUCT_MINOR_NUM) || \
    !defined(VER_PRODUCT_SUB_MINOR_NUM) || !defined(VER_PRODUCT_BUILD_NUM)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_PRODUCT_MAJOR_STR) || !defined(VER_PRODUCT_MINOR_STR) || \
    !defined(VER_PRODUCT_SUB_MINOR_STR) || !defined(VER_PRODUCT_BUILD_STR)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// Macro used to force C preprocessor to concatenate string defines
#define DEFINE_STRING(STR)              STR

// Macro to make this stuff easier to read.
#define VER_STR_CAT(sep,maj,min,sub,bld) maj sep min sep sub sep bld

// PRODUCT version information is displayed in the About box of each
// component and is stored in the registry during installation.
// The About box code must get the value from the registry instead of
// using these macros in order to get the currently installed version.
// Therefore, these macros should only be used by the installer.
#define VER_PRODUCT_VERSION_NUM         ((VER_PRODUCT_MAJOR_NUM << 24) | \
                                            (VER_PRODUCT_MINOR_NUM << 16) | \
                                            (VER_PRODUCT_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_PRODUCT_VERSION_NUM_RC      VER_PRODUCT_MAJOR_NUM,\
                                            VER_PRODUCT_MINOR_NUM,\
                                            VER_PRODUCT_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_PRODUCT_VERSION_STR         VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_PRODUCT_VERSION_STR_RC      VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// COMPONENT version information is displayed in the ProductVersion 
// field of a file's Windows property sheet.  It is the same as the
// FILE version info with the addition of the build number.
#define VER_COMPONENT_VERSION_NUM       ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_COMPONENT_VERSION_NUM_RC    VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_COMPONENT_VERSION_STR       VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_COMPONENT_VERSION_STR_RC    VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// FILE version information is an abbreviated component version info
// and is displayed at the top of a file's Windows property sheet.
#define VER_FILE_VERSION_NUM            ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_FILE_VERSION_NUM_RC         VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_FILE_VERSION_STR            VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_FILE_VERSION_STR_RC         VER_FILE_MAJOR_STR "."\
                                            VER_FILE_MINOR_STR "."\
                                            VER_FILE_SUB_MINOR_STR

#endif /* _VPRODUCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\miniport.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_c

@module Miniport.c |

    This module implements the <f DriverEntry> routine, which is the first
    routine called when the driver is loaded into memory.  The Miniport
    initialization and termination routines are also implemented here.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 1.0 Miniport Overview |

    The NDIS wrapper provides services to both the Transport drivers, and the
    Miniport drivers.  The NDIS wrapper provides an abstraction layer between
    the two which allows them to interoperate with each other as long as they
    both adhere to the NDIS interfaces defined for Transports and Miniports.

    The NDIS wrapper also provides a set of services which isolate NDIS
    drivers from the specifics of the Operating System (Win 3.11, Win95,
    WinNT), as well as the platform specifics (Processor, Bus, Interrupts).
    The advantage of using the NDIS wrapper is that the Miniport can be
    easily ported to other Windows environments with little or no re-coding.

@iex

    This diagram shows how the NDIS wrapper provides services
    to both the Transport drivers, and the Miniport drivers.

|   +--------+    +-----+    +---------------------------------+
|   |        |    |     |<-->| Windows Transport Drivers (TDI) |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |      | Lower-Edge Functions  ^
|   |        |    |     |      |                       |
|   |        |    |     |      v                       |
|   |        |    |     +--------------------------------------+
|   |        |    |          NDIS Interface Library (Wrapper)  |
|   |        |    |     +--------------------------------------+
|   |Windows |    |     |      |                       ^
|   |   OS   |    |     |      |                       |
|   |Services|    |     |      v Upper-Edge Functions  |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |    | NDIS WAN/TAPI Driver (Miniport) |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |      ^ Lower-Edge Functions
|   |        |    |     |      |
|   |        |    |     |      v
|   |        |    |     +--------------------------------------+
|   |    +---|<-->|------------+                               |
|   +----|---+    +--------------------------------------------+
|        ^
|        |
|        v Hardware Bus
|   +------------------------------+
|   | Network Interface Card (NIC) |
|   +------------------------------+


    An NDISWAN Miniport consists of two, cooperating, drivers contained in
    the same binary.  The NDIS WAN portion of the driver handles packet
    transmits and receives.  While the WAN TAPI portion handles call setup
    and tear down.  Ultimately, it would be better if these two drivers
    were separated, and there was an interface defined between them, but
    history and expedience lead Microsoft to develop this interface model.

    The NDIS WAN side of the Miniport is very similar to an NDIS LAN style
    Miniport, except that some of the NDIS interfaces have been modified to
    support the WAN media type.  The primary difference from the Miniport's
    point of view is the packet structure and different set of NDIS requests,
    and more importantly the line can go up and down.

    The WAN TAPI portion of the Miniport adds significant complexity to the
    Miniport.  The WAN Miniport must provide a pseudo Telephony Service
    Provider Interface (TSPI) which lives under the WAN TSPI.  The NDIS WAN
    TSPI loads under TAPI as the 'real' service provider, and then routes all
    RAS related TAPI events to the Miniport's TSPI.

    The WAN TSPI can have multiple Miniport TSPI's living under its TSPI
    interface.  And since Remote Access Services (RAS) use the TAPI interface
    to place and accept all calls, any Dial Up Networking (DUN) requests
    associated with the Miniport, will end up at the Miniport's TSPI.

@topic 1.1 Call Control Interface |

    FIXME_DESCRIPTION

@topic 1.2 Data Channel Interface |

    FIXME_DESCRIPTION

    Once a call is connected, the data channel associated with the call is
    configured to transmit and receive raw HDLC packets.  Then NDIS is
    notified that the coresponding 'link' is up.  The NDIS documentation
    refers to a data pipe as a link, and the Miniport also uses this
    nomenclature.  In addition, NDIS/RAS wants to see each data channel as a
    separate TAPI line device, so the Miniport also uses this link structure
    to keep track of TAPI calls and lines since they are all mapped 1:1:1.
    Keep this in mind as you read through the code and documentation, because
    I often use line and link interchangeably.

@topic 1.3 Implementation Notes |

    The Miniport is built as a Windows NT Portable Executable (PE) system
    file (.SYS).  The reason for this is that the NDIS WAN interfaces
    routines are currently only defined in the Windows NT version of the NDIS
    library. On Windows 95, the Miniport's binary image file is dynamically
    loaded by the NDIS wrapper during initialization, and runs in Ring-0. A
    Windows 95 version of the NDIS.VXD is available which supports the new
    WAN interrfaces.

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 2.0 Reference Documents |

    The most reliable source of information is provided on the Microsoft
    Developer Network CD.  These documents will provide you with the complete
    NDIS interface requirements and architectural overviews.  In addition,
    there are many addendums and developer notes in the Microsoft Knowledge
    Base.  The most important references are:

@iex
    Product Documentation\DDKs\Windows 95 DDK\Network Drivers\
        Windows 95 Network Drivers
        NDIS 3.0 Netcard Driver
        NDIS Netcard Driver Tester
        Network Driver Installer

    Product Documentation\DDKs\Windows NT DDK\Network Drivers\
        Design Guide\PART2 NDIS 3.0 Driver Design
            Chapters 1-7 discuss all the NDIS interface routines.
            Chapters 8-11,17-18 provide details on WAN/TAPI extensions.

    Product Documentation\SDKs\Win32 SDK\Win32 Telephony\
        This section defines the Windows 95 TAPI implementation.
        Note that this is slightly different than the Windows 3.1 TAPI
        spec.  Pay special attention to lineGetID and line device classes.

@topic 2.1 NDIS Background Information |

    Microsoft is phasing out what they call the NDIS 3.0 Full MAC driver.
    These drivers were written to the NDIS 3.0 specification using the older
    interface routines which have now been augmented by the Miniport
    routines.  The Miniport extensions were added to the NDIS 3.0 interface
    with the goal of making network drivers easier to write.  By using the
    Miniport routines rather than the original NDIS routines, the driver
    writer can make many simplifying assumptions, because the NDIS Wrapper
    will provide most of the queuing, scheduling, and sychronization code.
    The Miniport only has to deal with moving packets on and off the wire.

    The WAN and TAPI extensions were added into the NDIS 3.0 specification
    shortly after the Miniport extensions.  These new WAN interface routines
    are very similar to the LAN interface routines.  The only significant
    difference is the packet format passed between the Miniport and the NDIS
    Wrapper.  The TAPI extensions have no counterpart in the LAN interface,
    so these are all new.  In fact, they turn out to be about half of the
    implementation in a typical WAN/TAPI Miniport.

    It would have been nice if Microsoft would have added these changes and
    bumped the version numbers, but they didn't.  So we are left with a real
    problem trying to identifiy which NDIS 3.0 we are talking about.  The
    thing to remember is that you should avoid the Full MAC interface routines,
    because Microsoft has said that these routines will not be supported in
    future releases.  This is largely due to the Plug-and-Play extensions
    that were introduced in NDIS 3.1 for Windows 95.

    In the near future Microsoft will be adding more features to NDIS 3.5 to
    support advanced routing and some other enhancements.  In addition,
    NDIS 4.0 will be coming out with MANY new features to support ATM and
    other virtual circuit type media.  There are also more TAPI services
    being defined for the NDIS interface.  So don't expect this specification
    to stand still long enough to read it all...

@topic 2.2 Differences between LAN and WAN miniports |

    There are several differences in the way a WAN miniport interfaces
    with NDIS as compared to a LAN miniport driver described in the
    previous chapters. Such differences affect how a WAN driver is
    implemented.

    A WAN miniport must not register a MiniportTransferData handler with
    NdisMRegisterMiniport. Instead, a WAN miniport always passes an entire
    packet to the NdisMWanIndicateReceive function. When
    NdisMWanIndicateReceive returns, the packet has been copied and the
    WAN miniport can reuse the packet resources it allocated.

    WAN miniports provide a MiniportWanSend function instead of a MiniportSend
    function. The MiniportWanSend function accepts an additional parameter that
    specifies a specific data channel on which a packet is to be sent.

    WAN miniports never return NDIS_STATUS_RESOURCES as the status of
    MiniportWanSend or any other MiniportXxx function and cannot call
    NdisMSendResourcesAvailable.

    WAN miniports support a set of WAN-specific OIDs to set and query
    operating characteristics.

    WAN miniports support a set of WAN-specific status indications
    which are passed to NdisMIndicateStatus. These status indications
    report changes in the status of a link.

    WAN miniports call alternative WAN-specific NDIS functions to
    complete the WAN-specific NDIS calls for send and receive. <nl>
    The two completion calls are: <nl>
        NdisMWanIndicateReceiveComplete <nl>
        NdisMWanSendComplete <nl>

    WAN miniport drivers use an NDIS_WAN_PACKET instead of an
    NDIS_PACKET-type descriptor.

    WAN miniport drivers keep a WAN-specific set of statistics.

    WAN miniport drivers never do loopback; it is always
    provided by NDIS.

    WAN miniport drivers cannot be full-duplex miniports.


@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.0 NDISWAN Miniport Interface |

    The Miniport provides the following functions to the NDIS wrapper.
    The NDIS wrapper calls these functions on behalf of other layers of the
    network software, such as a transport driver bound to a network interface
    card.  The Miniport uses <f NdisMRegisterMiniport> to give NDIS a list of
    entry points for the supported routines, unused routines are set to NULL.

    Some of the Miniport functions are synchronous, while others can
    complete either synchronously or asynchronously. The Miniport must
    indicate to the NDIS library when an asynchronous function has completed
    by calling the appropriate NDIS library completion function. The NDIS
    library can subsequently call completion functions in other layers of the
    network software for postprocessing, if necessary.

    <f DriverEntry> Called by the operating system to activate and
    initialize the Miniport. (Synchronous)

    <f MiniportCheckForHang> Checks the internal state of the network interface
    card. (Synchronous)

    <f MiniportHalt> Halts the network interface card so it is no longer
    functioning. (Synchronous)

    <f MiniportInitialize> Initializes the network interface card. (Synchronous)

    <f MiniportQueryInformation> Queries the capabilities and current status of
    the Miniport. NDISTAPI functions are also passed through this
    interface. (Asynchronous)

    <f MiniportReset> Issues a hardware reset to the network interface card.
    (Asynchronous)

    <f MiniportWanSend> Transmits a packet through the network interface card
    onto the network. (Asynchronous)

    <f MiniportSetInformation> Changes (sets) information about the Miniport
    driver.  NDISTAPI functions are also passed through this interface.
    (Asynchronous)

@iex

    The following routines are defined in the NDIS Miniport interface,
    but they are not used by this implementation.

    MiniportISR                     NOT USED by this Miniport.

    Associated with each Miniport upper-edge driver function that may operate
    asynchronously is a corresponding completion function in the NDIS library.
    When the Miniport function returns a status of NDIS_STATUS_PENDING
    indicating asynchronous operation, this is the completion function that
    must be called when the Miniport has finally completed the request.

@iex

    This table shows how each asynchronous Miniport routine maps to its
    associated NDIS completion routine.

    Miniport Function               Asynchronous Completion Routine
    -----------------               -------------------------------
    MiniportQueryInformation        NdisMQueryInformationComplete
    MiniportReset                   NdisMResetComplete
    MiniportWanSend                 NdisMSendComplete
    MiniportSetInformation          NdisMSetInformationComplete
    MiniportTransferData            NdisMTransferDataComplete (NOT USED)

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.1 Initialization and Setup |

    The following diagram shows the typical call sequence used during system
    initialization.  Typically this occurs once when Windows loads.  However,
    NDIS does allow drivers to be unloaded, and then reloaded at any time, so
    you must be prepared to handle this event.

@iex

|   NDIS Wrapper                 |          Miniport
|   -----------------------------+------------------------------------
|   Load NDIS Wrapper            |
|                      >---------+---->+    DriverEntry
|                                |     |
|   NdisMInitializeWrapper  <----+---->+
|                                |     |
|   NdisMRegisterMiniport   <----+---->+
|                                |     |
|                      <---------+----<+
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportInitialize
|                                |     |
|   NdisOpenConfiguration    <---+---->+
|                                |     |
|   NdisReadConfiguration... <---+---->+
|                                |     |
|   NdisCloseConfiguration   <---+---->+
|                                |     |
|   NdisMSetAttributes       <---+---->+
|                                |     |
|                      <---------+----<+
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_CURRENT_ADDRESS
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_MEDIUM_SUBTYPE
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_GET_INFO

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.6 Reset and Shutdown |

    Aside from the initialization and run-time operations, the Miniport must
    support being reset <f MiniportReset> and being shutdown <f MiniportHalt>.

    The reset routine is only called when the NDIS wrapper detects an error
    with the Miniport's operation.  There are two ways in which the wrapper
    determines an error condition.  First, the NDIS wrapper calls
    <f MiniportCheckForHang> once every couple seconds to ask the Miniport
    if it thinks it needs to be reset.  Second, the wrapper may detect a
    timeout condition on an outstanding request to the Miniport.  These are
    both fail-safe conditions which should not happen under normal, run-time
    conditions.

    <f Note>: My feeling is that if you see a reset call, the Miniport is
    broken, and you should find and fix the bug -- not the symptom.

    The shutdown routine is normally only called when Windows is shutting
    down.  However, with the advent of plug and play devices, it is likely to
    become more common to get a shutdown request followed by another load
    request in the same Windows session.  So it is very important to clean up
    properly when <f MiniportHalt> is called. All memory and other resources
    must be released, and all intefaces must be properly closed so they can
    release their resources too.

    NDIS will cleanup any outstanding requests, but the Miniport should
    bring down all calls, and close all TAPI lines using synchronous
    TAPI events.  You can't depend on any NDIS WAN or TAPI events because
    none will be passed through the wrapper as long as the reset is in
    progress.

@end
*/

#define  __FILEID__             MINIPORT_DRIVER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#include "TpiParam.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC NDIS_HANDLE          g_NdisWrapperHandle = NULL;
// Receives the context value representing the Miniport wrapper
// as returned from NdisMInitializeWrapper.

NDIS_PHYSICAL_ADDRESS           g_HighestAcceptableAddress =
                                        NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
// This constant is used for places where NdisAllocateMemory needs to be
// called and the g_HighestAcceptableAddress does not matter.


/* @doc INTERNAL Miniport Miniport_c DriverEntry


@func

    <f DriverEntry> is called by the operating system when a driver is loaded.
    This function creates an association between the miniport NIC driver and
    the NDIS library and registers the miniport's characteristics with NDIS.

    <f DriverEntry> calls NdisMInitializeWrapper and then NdisMRegisterMiniport.
    <f DriverEntry> passes both pointers it received to NdisMInitializeWrapper,
    which returns a wrapper handle.  <f DriverEntry> passes the wrapper handle to
    NdisMRegisterMiniport.

    The registry contains data that is persistent across system boots, as well
    as configuration information generated anew at each system boot.  During
    driver installation, data describing the driver and the NIC is stored in
    the registry. The registry contains adapter characteristics that are read
    by the NIC driver to initialize itself and the NIC. See the Kernel-Mode
    Driver Design Guide for more about the registry and the Programmer's Guide
    for more information about the .inf files that install the driver and
    write to the registry.

@comm

    Every miniport driver must provide a function called DriverEntry.  By
    convention, DriverEntry is the entry point address for a driver.  If a
    driver does not use the name DriverEntry, the driver developer must define
    the name of its entry function to the linker so that the entry point
    address can be known into the OS loader.

    It is interesting to note, that at the time DriverEntry is called, the OS
    doesn't know that the driver is an NDIS driver.  The OS thinks it is just
    another driver being loaded.  So it is possible to do anything any driver
    might do at this point.  Since NDIS is the one who requested this driver
    to be loaded, it would be polite to register with the NDIS wrapper.  But
    you can also hook into other OS functions to use and provide interfaces
    outside the NDIS wrapper.  (Not recommended for the faint of heart).<nl>

    NDIS miniports and intermediate drivers carry out two basic tasks in
    their <f DriverEntry> functions:<nl>

    1)  Call NdisMInitializeWrapper to notify the NDIS library that the
        driver is about to register itself as a miniport.
        NDIS sets up the state it needs to track the driver and
        returns an NdisWrapperHandle, which the driver saves for
        subsequent calls to NdisXxx configuration and initialization
        functions.<nl>

    2)  Fill in an NDISXX_MINIPORT_CHARCTERISTICS structure with the
        appropriate version numbers and the entry points for
        driver-supplied MiniportXxx functions and, then, call
        NdisMRegisterMiniport or NdisIMRegisterLayeredMiniport.
        Usually, NIC drivers call NdisMRegisterMiniport, as do
        intermediate drivers that export only a set of MiniportXxx
        functions. Usually, NDIS intermediate drivers call
        NdisIMRegisterLayeredMiniport, which effectively defers the
        initialization of such a driver's virtual NIC until the driver
        calls NdisIMInitializeDeviceInstance from its
        ProtocolBindAdapter function.<nl>

    <f DriverEntry> can allocate the NDISXX_MINIPORT_CHARACTERISTICS
    structure on the stack since the NDIS library copies the relevant
    information to its own storage. DriverEntry should clear the memory
    for this structure with NdisZeroMemory before setting any driver-supplied
    values in its members. The current MajorNdisVersion is 0x05, and the current
    MinorNdisVersion is 0x00. In each XxxHandler member of the
    characteristics structure, <f DriverEntry> must set the name of a
    driver-supplied MiniportXxx function, or the member must be NULL.

    Calling NdisMRegisterMiniport causes the driver's <f MiniportInitialize>
    function to run in the context of NdisMRegisterMiniport. Calling
    NdisIMRegisterLayeredMiniport defers the call to MiniportInitialize
    until the driver calls NdisIMInitializeDeviceInstance.

    Drivers that call NdisMRegisterMiniport must be prepared for an
    immediate call to their <f MiniportInitialize> functions. Such a driver
    must have sufficient installation and configuration information
    stored in the registry or available from calls to an NdisXxx
    bus-type-specific configuration function to set up any NIC-specific
    resources the driver will need to carry out network I/O operations.

    Drivers that call NdisIMRegisterLayeredMiniport defer the call to
    their <f MiniportInitialize> functions to another driver-supplied
    function that makes a call to NdisIMInitializeDeviceInstance.
    NDIS intermediate drivers usually register a ProtocolBindAdapter
    function and call NdisIMRegisterLayeredMiniport so that NDIS will
    call the ProtocolBindAdapter function after all underlying NIC
    drivers have initialized. This strategy gives such an NDIS
    intermediate driver, which makes the call to
    NdisIMInitializeDeviceInstance from ProtocolBindAdapter,
    the advantage of having its <f MiniportInitialize> function configure
    driver-allocated resources for the intermediate's virtual NIC to
    the features of the underlying NIC driver to which the intermediate
    has already bound itself.

    If NdisMRegisterMiniport or NdisIMRegisterLayeredMiniport does
    not return NDIS_STATUS_SUCCESS, <f DriverEntry> must release any
    resources it allocated, such as memory to hold the NdisWrapperHandle,
    and must call NdisTerminateWrapper before it returns control.
    The driver will not be loaded if this occurs.

    By default, <f DriverEntry> runs at IRQL PASSIVE_LEVEL in a
    system-thread context.

@devnote

    The parameters passed to <f DriverEntry> are OS specific! NT passes in valid
    values, but Windows 3.1 and Windows 95 just pass in zeros.  We don't
    care, because we just pass them to the NDIS wrapper anyway.

@rdesc

    <f DriverEntry> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

@xref

    <f MiniportInitialize>

*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,               // @parm
    // A pointer to the driver object, which was created by the I/O system.

    IN PUNICODE_STRING          RegistryPath                // @parm
    // A pointer to the registry path, which specifies where driver-specific
    // parameters are stored.
    )
{
    DBG_FUNC("DriverEntry")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    NTSTATUS                    Result;
    // Result code returned by this function.

    NDIS_WAN_MINIPORT_CHARACTERISTICS WanCharacteristics;
    // Characteristics table passed to NdisMWanRegisterMiniport.

    /*
    // Setup default debug flags then breakpoint so we can tweak them
    // when this module is first loaded.  It is also useful to see the
    // build date and time to be sure it's the one you think it is.
    */
#if DBG
    DbgInfo->DbgFlags = DBG_DEFAULTS;
    DbgInfo->DbgID[0] = '0';
    DbgInfo->DbgID[1] = ':';
    ASSERT (sizeof(VER_TARGET_STR) <= sizeof(DbgInfo->DbgID)-2);
    memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
#endif // DBG
    DBG_PRINT((VER_TARGET_STR": Build Date:"__DATE__" Time:"__TIME__"\n"));
    DBG_PRINT((VER_TARGET_STR": DbgInfo=0x%X DbgFlags=0x%X\n",
               DbgInfo, DbgInfo->DbgFlags));
    DBG_BREAK(DbgInfo);

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|DriverObject=0x%X\n"
               "\t|RegistryPath=0x%X\n",
               DriverObject,
               RegistryPath
              ));

    /*
    // Initialize the Miniport wrapper - THIS MUST BE THE FIRST NDIS CALL.
    */
    NdisMInitializeWrapper(
            &g_NdisWrapperHandle,
            DriverObject,
            RegistryPath,
            NULL
            );
    ASSERT(g_NdisWrapperHandle);

    /*
    // Initialize the characteristics table, exporting the Miniport's entry
    // points to the Miniport wrapper.
    */
    NdisZeroMemory((PVOID)&WanCharacteristics, sizeof(WanCharacteristics));
    WanCharacteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    WanCharacteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;
    WanCharacteristics.Reserved                = NDIS_USE_WAN_WRAPPER;

    WanCharacteristics.InitializeHandler       = MiniportInitialize;
    WanCharacteristics.WanSendHandler          = MiniportWanSend;
    WanCharacteristics.QueryInformationHandler = MiniportQueryInformation;
    WanCharacteristics.SetInformationHandler   = MiniportSetInformation;
    WanCharacteristics.CheckForHangHandler     = MiniportCheckForHang;
    WanCharacteristics.ResetHandler            = MiniportReset;
    WanCharacteristics.HaltHandler             = MiniportHalt;

    /*
    // If the adapter does not generate an interrupt, these entry points
    // are not required.  Otherwise, you can use the have the ISR routine
    // called each time an interupt is generated, or you can use the
    // enable/disable routines.
    */
#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)
    WanCharacteristics.DisableInterruptHandler = MiniportDisableInterrupt;
    WanCharacteristics.EnableInterruptHandler  = MiniportEnableInterrupt;
#endif // CARD_REQUEST_ISR == FALSE
    WanCharacteristics.HandleInterruptHandler  = MiniportHandleInterrupt;
    WanCharacteristics.ISRHandler              = MiniportISR;
#endif // defined(CARD_REQUEST_ISR)

    /*
    // Register the driver with the Miniport wrapper.
    */
    Status = NdisMRegisterMiniport(
                    g_NdisWrapperHandle,
                    (PNDIS_MINIPORT_CHARACTERISTICS) &WanCharacteristics,
                    sizeof(WanCharacteristics)
                    );

    /*
    // The driver will not load if this call fails.
    // The system will log the error for us.
    */
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_UNSUCCESSFUL;
    }
    else
    {
        DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_SUCCESS;
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Miniport Miniport_c MiniportInitialize


@func

    <f MiniportInitialize> is a required function that sets up a NIC (or
    virtual NIC) for network I/O operations, claims all hardware resources
    necessary to the NIC in the registry, and allocates resources the driver
    needs to carry out network I/O operations.

@comm

    NDIS submits no requests to a driver until its initialization
    is completed.

    In NIC and intermediate drivers that call NdisMRegisterMiniport
    from their DriverEntry functions, NDIS calls MiniportInitialize
    in the context of NdisMRegisterMiniport. The underlying device
    driver must initialize before an intermediate driver that depends
    on that device calls NdisMRegisterMiniport.

    For NDIS intermediate drivers that export both ProtocolXxx and
    MiniportXxx functions and that call NdisIMRegisterLayeredMiniport
    from their DriverEntry functions, NDIS calls <f MiniportInitialize>
    in the context of NdisIMInitializeDeviceInstance. Such a driver's
    ProtocolBindAdapter function usually makes the call to
    NdisIMInitializeDeviceInstance.

    For NIC drivers, NDIS must find at least the NIC's I/O bus
    interface type and, if it is not an ISA bus, the bus number
    already installed in the registry by the driver's installation
    script. For more information about installing Windows 2000 drivers,
    see the Driver Writer's Guide.

    The NIC driver obtains configuration information for its
    NIC by calling NdisOpenConfiguration and NdisReadConfiguration.
    The NIC driver obtains bus-specific information by calling the
    appropriate bus-specific function:

    Bus Function for Obtaining Bus-Specific Information:<nl>

    EISA:<nl>
        NdisReadEisaSlotInformation or NdisReadEisaSlotInformationEx

    PCI:<nl>
        NdisReadPciSlotInformation

    PCMCIA:<nl>
         NdisReadPcmciaAttributeMemory

    The NIC driver for an EISA NIC obtains information on the
    hardware resources for its NIC by calling
    NdisReadEisaSlotInformation or NdisReadEisaSlotInformationEx.
    NIC drivers for PCI NICs and PCMCIA NICs obtain such information
    by calling NdisMQueryAdapterResources.

    When it calls <f MiniportInitialize>, the NDIS library supplies an
    array of supported media types, specified as system-defined
    NdisMediumXxx values. <f MiniportInitialize> reads the array
    elements and provides the index of the medium type that NDIS
    should use with this driver for its NIC. If the miniport is
    emulating a medium type, its emulation must be transparent to NDIS.

    The <f MiniportInitialize> function of a NIC driver must call
    NdisMSetAttributes or NdisMSetAttributesEx before it calls
    any NdisXxx function, such as NdisRegisterIoPortRange or NdisMMapIoSpace,
    that claims hardware resources in the registry for the NIC.
    MiniportInitialize must call NdisMSetAttributes(Ex) before it
    attempts to allocate resources for DMA operations as well. If
    the NIC is a busmaster, <f MiniportInitialize> must call
    NdisMAllocateMapRegisters following its call to
    NdisMSetAttributes(Ex) and before it calls NdisMAllocateSharedMemory.
    If the NIC is a slave, MiniportInitialize must call
    NdisMSetAttributes(Ex) before it calls NdisMRegisterDmaChannel.

    Intermediate driver <f MiniportInitialize> functions must call
    NdisMSetAttributesEx with NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER
    set in the AttributeFlags argument. Setting this flag causes
    NDIS to treat every intermediate driver as a full-duplex miniport,
    thereby preventing rare but intermittant deadlocks when concurrent
    send and receive events occur. Consequently, every intermediate
    driver must be written as a full-duplex driver capable of handling
    concurrent sends and indications.

    If the NDIS library's default four-second time-out interval on
    outstanding sends and requests is too short for the driver's NIC,
    <f MiniportInitialize> can call NdisMSetAttributesEx to extend the
    interval. Every intermediate driver also should call
    NdisMSetAttributesEx with NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
    and NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT set in the AttributeFlags
    so that NDIS will not attempt to time out sends and requests that
    NDIS holds queued to the intermediate driver.

    The call to NdisMSetAttributes or NdisMSetAttributesEx includes a
    MiniportAdapterContext handle to a driver-allocated context area,
    in which the miniport maintains runtime state information. NDIS
    subsequently passes the supplied <t MiniportAdapterContext> handle as
    an input parameter to other MiniportXxx functions.

    Consequently, the <f MiniportInitialize> function of an intermediate
    driver must call NdisMSetAttributesEx to set up the <t MiniportAdapterContext>
    handle for a driver-allocated per-virtual-NIC context area. Otherwise,
    NDIS would pass a NULL <t MiniportAdapterContext> handle in its subsequent
    calls to the intermediate driver's other MiniportXxx functions.

    After a call to NdisMRegisterIoPortRange, a miniport must call
    the NdisRawXxx functions with the PortOffset value returned by
    NdisMRegisterIoPortRange to communicate with its NIC. The NIC
    driver can no longer call the NdisImmediateRead/WritePortXxx
    functions. Similarly, after a call to NdisMMapIoSpace, a NIC
    driver can no longer call NdisImmediateRead/WriteSharedMemory.

    After it has claimed any bus-relative hardware resources for its
    NIC in the registry, a miniport should no longer call any
    bus-type-specific NdisReadXxx function.

    After <f MiniportInitialize> calls NdisMRegisterInterrupt, the driver's
    <f MiniportISR> function is called if the driver's NIC generates an
    interrupt or if any other device with which the NIC shares an IRQ
    interrupts. NDIS does not call the <f MiniportDisableInterrupt> and
    <f MiniportEnableInterrupt> functions, if the driver supplied them,
    during initialization, so it is such a miniport's responsibility
    to acknowledge and clear any interrupts its NIC generates. If the
    NIC shares an IRQ, the driver must first determine whether its NIC
    generated the interrupt; if not, the miniport must return FALSE as
    soon as possible.

    If the NIC does not generate interrupts, <f MiniportInitialize> should
    call NdisMInitializeTimer with a driver-supplied polling
    MiniportTimer function and a pointer to driver-allocated memory
    for a timer object. Drivers of NICs that generate interrupts and
    intermediate drivers also can set up one or more <f MiniportTimer>
    functions, each with its own timer object. <f MiniportInitialize> usually
    calls NdisMSetPeriodicTimer to enable a polling <f MiniportTimer> function;
    a driver calls NdisMSetTimer subsequently when conditions occur such
    that the driver's nonpolling <f MiniportTimer> function should be run.

    If the driver subsequently indicates receives with
    NdisMIndicateReceivePacket, the MiniportInitialize function
    should call NdisAllocatePacketPool and NdisAllocateBufferPool
    and save the handles returned by these NDIS functions. The packets
    that the driver subsequently indicates with NdisMIndicateReceivePacket
    must reference descriptors that were allocated with NdisAllocatePacket
    and NdisAllocateBuffer.

    If driver functions other than <f MiniportISR> or <f MiniportDisableInterrupt>
    share resources, <f MiniportInitialize> should call NdisAllocateSpinLock
    to set up any spin lock necessary to synchronize access to such a set
    of shared resources, particularly in a full-duplex driver or in a
    driver with a polling <f MiniportTimer> function rather than an ISR.
    Resources shared by other driver functions with <f MiniportISR> or
    <f MiniportDisableInterrupt>, such as NIC registers, are protected
    by the interrupt object set up when <f MiniportInitialize> calls
    NdisMRegisterInterrupt and accessed subsequently by calling
    NdisMSynchronizeWithInterrupt.

    Any NIC driver's <f MiniportInitialize> function should test the
    NIC to be sure the hardware is configured correctly to carry
    out subsequent network I/O operations. If it must wait for
    state changes to occur in the hardware, <f MiniportInitialize>
    either can call NdisWaitEvent with the pointer to a driver-initialized
    event object, or it can call NdisMSleep.

    Unless the <f MiniportInitialize> function of a NIC driver will
    return an error status, it should call
    NdisMRegisterAdapterShutdownHandler with a driver-supplied
    MiniportShutdown function.

    If <f MiniportInitialize> will fail the initialization, it must
    release all resources it has already allocated before it
    returns control.

    If <f MiniportInitialize> returns NDIS_STATUS_OPEN_ERROR, NDIS can
    examine the value returned at OpenErrorStatus to obtain more
    information about the error.

    When <f MiniportInitialize> returns NDIS_STATUS_SUCCESS, the NDIS
    library calls the driver's <f MiniportQueryInformation> function next.

    By default, <f MiniportInitialize> runs at IRQL PASSIVE_LEVEL and in
    the context of a system thread.




@rdesc

    <f MiniportInitialize> can return either of the following:

    @flag NDIS_STATUS_SUCCESS |
        <f MiniportInitialize> configured and set up the NIC, and it allocated
        all the resources the driver needs to carry out network I/O operations.
    @flag NDIS_STATUS_FAILURE |
        <f MiniportInitialize> could not set up the NIC to an
        operational state or could not allocate needed resources.
        <f MiniportInitialize> called NdisWriteErrorLogEntry with parameters
        specifying the configuration or resource allocation failure.<nl>

    As alternatives to NDIS_STATUS_FAILURE, <f MiniportInitialize>
    can return one of the following values, as appropriate,
    when it fails an initialization:

    @flag NDIS_STATUS_UNSUPPORTED_MEDIA |
        The values at MediumArray did not include a medium
        the driver (or its NIC) can support.
    @flag NDIS_STATUS_ADAPTER_NOT_FOUND |
        <f MiniportInitialize> did not recognize the NIC either
        from its description in the registry, using
        NdisOpenConfiguration and NdisReadConfiguration,
        or by probing the NIC on a particular I/O bus, using
        one of the NdisImmediateXxx or bus-type-specific
        NdisXxx configuration functions. This return can be
        propagated from the miniport's call to certain NdisXxx
        functions, such as NdisOpenConfiguration.
    @flag NDIS_STATUS_OPEN_ERROR |
        <f MiniportInitialize> attempted to set up a NIC
        but was unsuccessful.
    @flag NDIS_STATUS_NOT_ACCEPTED |
        <f MiniportInitialize> could not get its NIC to
        accept the configuration parameters that it got from
        the registry or from a bus-type-specific NdisXxx
        configuration function.
    @flag NDIS_STATUS_RESOURCES |
        Either <f MiniportInitialize> could not allocate
        sufficient resources to carry out network I/O
        operations or an attempt to claim bus-relative
        hardware resources in the registry for the NIC
        failed. This return can be propagated from the
        miniport's call to an NdisXxx function.
        If another device has already claimed a
        resource in the registry that its NIC needs,
        <f MiniportInitialize> also should call
        NdisWriteErrorLogEntry to record the
        particular resource conflict (I/O port range,
        interrupt vector, device memory range, as appropriate).
        Supplying an error log record gives the user or system
        administrator information that can be used to reconfigure
        the machine to avoid such hardware resource conflicts.


@xref

    <f DriverEntry>
    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportISR>
    <f MiniportQueryInformation>
    <f MiniportShutdown>
    <f MiniportTimer>

*/

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,            // @parm
    // Points to a variable that MiniportInitialize sets to an
    // NDIS_STATUS_XXX code specifying additional information about the
    // error if MiniportInitialize will return NDIS_STATUS_OPEN_ERROR.

    OUT PUINT                   SelectedMediumIndex,        // @parm
    // Points to a variable in which MiniportInitialize sets the index of
    // the MediumArray element that specifies the medium type the driver
    // or its NIC uses.

    IN PNDIS_MEDIUM             MediumArray,                // @parm
    // Specifies an array of NdisMediumXxx values from which
    // MiniportInitialize selects one that its NIC supports or that the
    // driver supports as an interface to higher-level drivers.

    IN UINT                     MediumArraySize,            // @parm
    // Specifies the number of elements at MediumArray.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("MiniportInitialize")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    UINT                        Index;
    // Loop counter.

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|OpenErrorStatus=0x%X\n"
               "\t|SelectedMediumIndex=0x%X\n"
               "\t|MediumArray=0x%X\n"
               "\t|MediumArraySize=0x%X\n"
               "\t|MiniportAdapterHandle=0x%X\n"
               "\t|WrapperConfigurationContext=0x%X\n",
               OpenErrorStatus,
               SelectedMediumIndex,
               MediumArray,
               MediumArraySize,
               MiniportAdapterHandle,
               WrapperConfigurationContext
              ));

    /*
    // Search the MediumArray for the NdisMediumWan media type.
    */
    for (Index = 0; Index < MediumArraySize; Index++)
    {
        if (MediumArray[Index] == NdisMediumWan)
        {
            break;
        }
    }

    /*
    // Make sure the protocol has requested the proper media type.
    */
    if (Index < MediumArraySize)
    {
        /*
        // Allocate memory for the adapter information structure.
        */
        Status = AdapterCreate(
                        &pAdapter,
                        MiniportAdapterHandle,
                        WrapperConfigurationContext
                        );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            /*
            // Now it's time to initialize the hardware resources.
            */
            Status = AdapterInitialize(pAdapter);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Save the selected media type.
                */
                *SelectedMediumIndex = Index;
            }
            else
            {
                /*
                // Something went wrong, so let's make sure everything is
                // cleaned up.
                */
                MiniportHalt(pAdapter);
            }
        }
    }
    else
    {
        DBG_ERROR(DbgInfo,("No NdisMediumWan found (Array=0x%X, ArraySize=%d)\n",
                  MediumArray, MediumArraySize));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Index,
                __FILEID__,
                __LINE__
                );

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    /*
    // If all goes well, register a shutdown handler for this adapter.
    */
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMRegisterAdapterShutdownHandler(MiniportAdapterHandle,
                                            pAdapter, MiniportShutdown);
    }

    DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL Miniport Miniport_c MiniportHalt


@func

    <f MiniportHalt> request is used to halt the adapter such that it is
    no longer functioning.

@comm

    <f MiniportHalt> should stop the NIC, if it controls a physical
    NIC, and must free all resources that the driver allocated for
    it's NIC before <f MiniportHalt> returns control. In effect,
    <f MiniportHalt> undoes everything that was done by <f MiniportInitialize>
    for a particular NIC.

    If the NIC driver allocated memory, claimed an I/O port range,
    mapped on-board device memory to host memory, initialized timer(s)
    and/or spin lock(s), allocated map registers or claimed a DMA channel,
    and registered an interrupt, that driver must call the reciprocals of the
    NdisXxx functions with which it originally allocated these resources.

    As a general rule, a <f MiniportHalt> function should call reciprocal
    NdisXxx functions in inverse order to the calls the driver made from
    <f MiniportInitialize>. That is, if a NIC driver's <f MiniportInitialize>
    function called NdisMRegisterAdapterShutdownHandler just before
    it returned control, its <f MiniportHalt> function would call
    NdisMDeregisterAdapterShutdownHandler first.

    If its NIC generates interrupts or shares an IRQ, a NIC driver's
    <f MiniportHalt> function can be pre-empted by its <f MiniportISR> or
    <f MiniportDisableInterrupt> function until <f MiniportHalt> calls
    NdisMDeregisterInterrupt. Such a driver's <f MiniportHalt>
    function usually disables interrupts on the NIC, if
    possible, and calls NdisMDeregisterInterrupt as soon
    as it can.

    If the driver has a <f MiniportTimer> function associated
    with any timer object that might be in the system timer
    queue, <f MiniportHalt> should call NdisMCancelTimer.

    Otherwise, it is unnecessary for the miniport to complete
    outstanding requests to its NIC before <f MiniportHalt> begins
    releasing allocated resources. NDIS submits no further
    requests to the miniport for the NIC designated by the
    MiniportAdapterContext handle when NDIS has called <f MiniportHalt>.
    On return from <f MiniportHalt>, NDIS cleans up any state it was
    maintaining about this NIC and about its driver if this
    miniport supports no other NICs in the current machine.

    An NDIS intermediate driver's call to
    NdisIMDeinitializeDeviceInstance causes a
    call to it's <f MiniportHalt> function.

    By default, <f MiniportHalt> runs at IRQL PASSIVE_LEVEL.

    Interrupts are enabled during the call to this routine.

@xref
    <f MiniportInitialize>
    <f MiniportShutdown>

 */

VOID MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHalt")

    NDIS_TAPI_PROVIDER_SHUTDOWN TapiShutDown;
    // We use this message to make sure TAPI is cleaned up.

    ULONG                       DummyLong;
    // Don't care about the return value.

    DBG_ENTER(DbgInfo);

    /*
    // Remove our shutdown handler from the system.
    */
    NdisMDeregisterAdapterShutdownHandler(pAdapter->MiniportAdapterHandle);

    /*
    // Make sure all the lines are hungup and indicated.
    // This should already be the case, but let's be sure.
    */
    TapiShutDown.ulRequestID = OID_TAPI_PROVIDER_SHUTDOWN;
    TspiProviderShutdown(pAdapter, &TapiShutDown, &DummyLong, &DummyLong);

    /*
    // Free adapter instance.
    */
    AdapterDestroy(pAdapter);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Miniport Miniport_c MiniportShutdown


@func

    <f MiniportShutdown> is an optional function that restores a NIC to its
    initial state when the system is shut down, whether by the user or because
    an unrecoverable system error occurred.

@comm

    Every NIC driver should have a <f MiniportShutdown> function.
    <f MiniportShutdown> does nothing more than restore the NIC
    to its initial state (before the miniport's <f DriverEntry>
    function runs). However, this ensures that the NIC is in a
    known state and ready to be reinitialized when the machine is
    rebooted after a system shutdown occurs for any reason,
    including a crash dump.

    A NIC driver's <f MiniportInitialize> function must call
    NdisMRegisterAdapterShutdownHandler to set up a <f MiniportShutdown>
    function. The driver's <f MiniportHalt> function must make a
    reciprocal call to NdisMDeregisterAdapterShutdownHandler.

    If <f MiniportShutdown> is called due to a user-initiated
    system shutdown, it runs at IRQL PASSIVE_LEVEL in a
    system-thread context. If it is called due to an
    unrecoverable error, <f MiniportShutdown> runs at an
    arbitrary IRQL and in the context of whatever component
    raised the error. For example, <f MiniportShutdown> might be
    run at high DIRQL in the context of an ISR for a device
    essential to continued execution of the system.

    <f MiniportShutdown> should call no NdisXxx functions.

@xref

    <f MiniportHalt>
    <f MiniportInitialize>

*/

VOID MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    // This was supplied when the NIC driver's <f MiniportInitialize>
    // function called NdisMRegisterAdapterShutdownHandler. Usually,
    // this input parameter is the NIC-specific <t MINIPORT_ADAPTER_CONTEXT>
    // pointer passed to other MiniportXxx functions
    )
{
    DBG_FUNC("MiniportShutdown")

    DBG_ENTER(pAdapter);

    /*
    // Reset the hardware and bial out - don't release any resources!
    */
    CardReset(pAdapter->pCard);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Miniport Miniport_c MiniportReset


@func

    <f MiniportReset> request instructs the Miniport to issue a hardware
    reset to the network adapter.  The Miniport also resets its software
    state.

@comm

    <f MiniportReset> can reset the parameters of its NIC. If a reset
    causes a change in the NIC's station address, the miniport
    automatically restores the station address following the reset
    to its prior value. Any multicast or functional addressing masks
    reset by the hardware do not have to be reset in this function.

    If other information, such as multicast or functional addressing
    information or the lookahead size, is changed by a reset,
    <f MiniportReset> must set the variable at AddressingReset to TRUE
    before it returns control. This causes NDIS to call the
    <f MiniportSetInformation> function to restore the information.

    As a general rule, the <f MiniportReset> function of an NDIS
    intermediate driver should always set AddressingReset to TRUE.
    Until the underlying NIC driver resets its NIC, such an intermediate
    driver cannot determine whether it must restore addressing
    information for its virtual NIC. Because an intermediate driver
    disables the NDIS library's timing out of queued sends and requests
    to itself with an initialization-time call to NdisMSetAttributesEx,
    such a driver's <f MiniportReset> function is called only when a reset
    request is directed to the underlying NIC driver.

    Intermediate drivers that layer themselves above other types of
    device drivers also must have a <f MiniportReset> function. Such a
    <f MiniportReset> function must handle reset requests initiated by
    protocol drivers' calls to NdisReset. If the intermediate driver
    also has a <f MiniportCheckForHang> function, its <f MiniportReset> function
    will be called whenever MiniportCheckForHang returns TRUE.

    It is unnecessary for a driver to complete outstanding requests
    before <f MiniportReset> begins resetting the NIC or updating its
    software state. NDIS submits no further requests to the miniport
    for the NIC designated by the <t MINIPORT_ADAPTER_CONTEXT> handle when
    NDIS has called <f MiniportReset> until the reset operation is completed.
    A miniport need not call NdisM(Co)IndicateStatus to signal the start
    and finish of each reset operation because NDIS notifies bound
    protocols when a reset begins and ends.

    If <f MiniportReset> must wait for state changes in the NIC during
    reset operations, it can call NdisStallExecution. However, a
    MiniportReset function should never call NdisStallExecution
    with an interval greater than 50 microseconds.

    If <f MiniportReset> returns NDIS_STATUS_PENDING, the driver must
    complete the original request subsequently with a call to
    NdisMResetComplete.

    <f MiniportReset> can be pre-empted by an interrupt.

    If a NIC driver supplies a <f MiniportCheckForHang> function,
    the NDIS library calls it periodically to determine whether
    to call the driver's <f MiniportReset> function. Otherwise, the
    NDIS library calls a NIC driver's <f MiniportReset> function whenever
    requests NDIS submitted to the <f MiniportQueryInformation>,
    <f MiniportSetInformation>, MiniportSendPackets, MiniportSend,
    or <f MiniportWanSend> function seem to have timed out. (NDIS does
    not call a deserialized NIC driver's <f MiniportReset> function if
    the driver's MiniportSend or MiniportSendPackets function seems
    to have timed out, nor does NDIS call a connection-oriented NIC
    driver's <f MiniportReset> function if the driver's MiniportCoSendPackets
    function seems to have timed out.) By default, the NDIS-determined
    time-out interval for outstanding sends and requests is around
    four seconds. If this default is too short, a NIC driver can make
    an initialization-time call to NdisMSetAttributesEx, rather than
    NdisMSetAttributes, to lengthen the time-out interval to suit its NIC.

    Every NDIS intermediate driver should call NdisMSetAttributesEx
    from <f MiniportInitialize> and disable NDIS's attempts to time out
    requests and sends in the intermediate driver. NDIS runs an
    intermediate driver's <f MiniportCheckForHang> function, if any,
    approximately every two seconds.

    NDIS cannot determine whether a NIC might be hung on receives,
    so supplying a <f MiniportCheckForHang> function allows a driver to
    monitor its NIC for this condition and to force a reset if it occurs.

    By default, MiniportReset runs at IRQL DISPATCH_LEVEL.

@devnote

    I have only seen MiniportReset called when the driver is not working
    properly.  If this gets called, your code is probably broken, so fix
    it.  Don't try to recover here unless there is some hardware/firmware
    problem you must work around.

@rdesc

    <f MiniportReset> allways returns <f NDIS_STATUS_HARD_ERRORS>.

@xref
    <f MiniportCheckForHang>
    <f MiniportInitialize>
    <f MiniportQueryInformation>
    <f MiniportSetInformation>
    <f MiniportWanSend>

*/

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,            // @parm
    // The Miniport indicates if the wrapper needs to call
    // <f MiniportSetInformation> to restore the addressing information
    // to the current values by setting this value to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Result code returned by this function.

    DBG_ENTER(pAdapter);
    DBG_ERROR(pAdapter,("##### !!! THIS SHOULD NEVER BE CALLED !!! #####\n"));

    /*
    // If anything goes wrong here, it's very likely an unrecoverable
    // hardware failure.  So we'll just shut this thing down for good.
    */
    Result = NDIS_STATUS_HARD_ERRORS;
    *AddressingReset = TRUE;

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\mux.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    mux.h

Abstract:

    Data structures, defines and function prototypes for the MUX driver.

Environment:

    Kernel mode only.

Revision History:


--*/

#ifdef NDIS51_MINIPORT
#define MUX_MAJOR_NDIS_VERSION         5
#define MUX_MINOR_NDIS_VERSION         1
#else
#define MUX_MAJOR_NDIS_VERSION         4
#define MUX_MINOR_NDIS_VERSION         0
#endif

#ifdef NDIS51
#define MUX_PROT_MAJOR_NDIS_VERSION    5
#define MUX_PROT_MINOR_NDIS_VERSION    0
#else
#define MUX_PROT_MAJOR_NDIS_VERSION    4
#define MUX_PROT_MINOR_NDIS_VERSION    0
#endif

#define TAG 'SxuM'
#define WAIT_INFINITE 0

#if DBG
//
// Debug levels: lower values indicate higher urgency
//
#define MUX_EXTRA_LOUD       20
#define MUX_VERY_LOUD        10
#define MUX_LOUD             8
#define MUX_INFO             6
#define MUX_WARN             4
#define MUX_ERROR            2
#define MUX_FATAL            0

extern INT                muxDebugLevel;


#define DBGPRINT(lev, Fmt)                                   \
    {                                                        \
        if ((lev) <= muxDebugLevel)                          \
        {                                                    \
            DbgPrint("MUX-IM: ");                            \
            DbgPrint Fmt;                                    \
        }                                                    \
    }
#else

#define DBGPRINT(lev, Fmt)

#endif //DBG

#define ETH_IS_LOCALLY_ADMINISTERED(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x02))

// forward declarations
typedef struct _ADAPT ADAPT, *PADAPT;
typedef struct _VELAN VELAN, *PVELAN;
typedef struct _MUX_NDIS_REQUEST MUX_NDIS_REQUEST, *PMUX_NDIS_REQUEST;


typedef
VOID
(*PMUX_REQ_COMPLETE_HANDLER) (
    IN PADAPT                           pAdapt,
    IN struct _MUX_NDIS_REQUEST *       pMuxRequest,
    IN NDIS_STATUS                      Status
    );

// This OID specifies the NDIS version in use by the
// virtual miniport driver. The high byte is the major version.
// The low byte is the minor version.
#define VELAN_DRIVER_VERSION            ((MUX_MAJOR_NDIS_VERSION << 8) + \
                                         (MUX_MINOR_NDIS_VERSION))

// media type, we use ethernet, change if necessary
#define VELAN_MEDIA_TYPE                NdisMedium802_3

// change to your company name instead of using Microsoft
#define VELAN_VENDOR_DESC               "Microsoft"

// Highest byte is the NIC byte plus three vendor bytes, they are normally
// obtained from the NIC
#define VELAN_VENDOR_ID                 0x00FFFFFF

#define VELAN_MAX_MCAST_LIST            32
#define VELAN_MAX_SEND_PKTS             5

#define ETH_MAX_PACKET_SIZE             1514
#define ETH_MIN_PACKET_SIZE             60
#define ETH_HEADER_SIZE                 14


#define VELAN_SUPPORTED_FILTERS ( \
            NDIS_PACKET_TYPE_DIRECTED      | \
            NDIS_PACKET_TYPE_MULTICAST     | \
            NDIS_PACKET_TYPE_BROADCAST     | \
            NDIS_PACKET_TYPE_PROMISCUOUS   | \
            NDIS_PACKET_TYPE_ALL_MULTICAST)

#define MUX_ADAPTER_PACKET_FILTER           \
            NDIS_PACKET_TYPE_PROMISCUOUS

//
// Define flag bits we set on send packets to prevent
// loopback from occurring on the lower binding.
//
#ifdef NDIS51

#define MUX_SEND_PACKET_FLAGS           NDIS_FLAGS_DONT_LOOPBACK

#else

#define NDIS_FLAGS_SKIP_LOOPBACK_WIN2K  0x400
#define MUX_SEND_PACKET_FLAGS           (NDIS_FLAGS_DONT_LOOPBACK |  \
                                         NDIS_FLAGS_SKIP_LOOPBACK_WIN2K)
#endif
                                         

#define MIN_PACKET_POOL_SIZE            255
#define MAX_PACKET_POOL_SIZE            4096

typedef UCHAR   MUX_MAC_ADDRESS[6];

//
// Our context stored in packets sent down to the
// lower binding. Note that this sample driver only forwards
// sends down; it does not originate sends itself.
// These packets are allocated from the SendPacketPool.
//
typedef struct _MUX_SEND_RSVD
{
    PVELAN              pVElan;             // originating ELAN
    PNDIS_PACKET        pOriginalPacket;    // original packet

} MUX_SEND_RSVD, *PMUX_SEND_RSVD;

#define MUX_RSVD_FROM_SEND_PACKET(_pPkt)            \
        ((PMUX_SEND_RSVD)(_pPkt)->ProtocolReserved)

//
// Our context stored in each packet forwarded up to an
// ELAN from a lower binding. The original packet refers to
// a packet indicated up to us that should be returned via
// NdisReturnPackets when our packet is returned to us. This
// is set to NULL there isn't such a packet.
// These packets are allocated from the RecvPacketPool.
//
typedef struct _MUX_RECV_RSVD
{
    PNDIS_PACKET        pOriginalPacket;

} MUX_RECV_RSVD, *PMUX_RECV_RSVD;

#define MUX_RSVD_FROM_RECV_PACKET(_pPkt)            \
        ((PMUX_RECV_RSVD)(_pPkt)->MiniportReserved)

//
// Make sure we don't attempt to use more than the allowed
// room in MiniportReserved on received packets.
//
C_ASSERT(sizeof(MUX_RECV_RSVD) <= sizeof(((PNDIS_PACKET)0)->MiniportReserved));


//
// Out context stored in each packet that we use to forward
// a TransferData request to the lower binding.
// These packets are allocated from the RecvPacketPool.
//
typedef struct _MUX_TD_RSVD
{
    PVELAN              pVElan;
    PNDIS_PACKET        pOriginalPacket;
} MUX_TD_RSVD, *PMUX_TD_RSVD;

#define MUX_RSVD_FROM_TD_PACKET(_pPkt)              \
        ((PMUX_TD_RSVD)(_pPkt)->ProtocolReserved)


//
// Default values:
//
#define MUX_DEFAULT_LINK_SPEED          100000  // in 100s of bits/sec
#define MUX_DEFAULT_LOOKAHEAD_SIZE      512


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT            DriverObject,
    IN PUNICODE_STRING           RegistryPath
    );

NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT            DeviceObject,
    IN PIRP                      Irp
    );

NDIS_STATUS
PtRegisterDevice(
    VOID
    );

NDIS_STATUS
PtDeregisterDevice(
    VOID
   );
//
// Protocol proto-types
//

VOID
PtOpenAdapterComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status,
    IN    NDIS_STATUS               OpenErrorStatus
    );


VOID
PtQueryAdapterInfo(
    IN  PADAPT                      pAdapt
    );


VOID
PtQueryAdapterSync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength
    );


VOID
PtRequestAdapterAsync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength,
    IN  PMUX_REQ_COMPLETE_HANDLER   pCallback
    );

VOID
PtCloseAdapterComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status
    );


VOID
PtResetComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status
    );


VOID
PtRequestComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_REQUEST             NdisRequest,
    IN    NDIS_STATUS               Status
    );


VOID
PtCompleteForwardedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
PtPostProcessPnPCapabilities(
    IN PVELAN                       pVElan,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength
    );

VOID
PtCompleteBlockingRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
PtDiscardCompletedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );


VOID
PtStatus(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               GeneralStatus,
    IN    PVOID                     StatusBuffer,
    IN    UINT                      StatusBufferSize
    );


VOID
PtStatusComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext
    );


VOID
PtSendComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet,
    IN    NDIS_STATUS               Status
    );


VOID
PtTransferDataComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet,
    IN    NDIS_STATUS               Status,
    IN    UINT                      BytesTransferred
    );


NDIS_STATUS
PtReceive(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_HANDLE               MacReceiveContext,
    IN    PVOID                     HeaderBuffer,
    IN    UINT                      HeaderBufferSize,
    IN    PVOID                     LookAheadBuffer,
    IN    UINT                      LookaheadBufferSize,
    IN    UINT                      PacketSize
    );


VOID
PtReceiveComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext
    );


INT
PtReceivePacket(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet
    );


VOID
PtBindAdapter(
    OUT   PNDIS_STATUS              Status,
    IN    NDIS_HANDLE               BindContext,
    IN    PNDIS_STRING              DeviceName,
    IN    PVOID                     SystemSpecific1,
    IN    PVOID                     SystemSpecific2
    );


VOID
PtUnbindAdapter(
    OUT   PNDIS_STATUS              Status,
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_HANDLE               UnbindContext
    );



NDIS_STATUS
PtPNPHandler(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNET_PNP_EVENT            pNetPnPEvent
    );


NDIS_STATUS
PtCreateAndStartVElan(
    IN  PADAPT                      pAdapt,
    IN  PNDIS_STRING                pVElanKey
);

PVELAN
PtAllocateAndInitializeVElan(
    IN PADAPT                       pAdapt,
    IN PNDIS_STRING                 pVElanKey
    );

VOID
PtDeallocateVElan(
    IN PVELAN                   pVElan
    );

VOID
PtStopVElan(
    IN  PVELAN                      pVElan
);

VOID
PtUnlinkVElanFromAdapter(
    IN PVELAN                       pVElan
);

PVELAN
PtFindVElan(
    IN    PADAPT                    pAdapt,
    IN    PNDIS_STRING              pElanKey
);


NDIS_STATUS
PtBootStrapVElans(
    IN  PADAPT                      pAdapt
);

VOID
PtReferenceVElan(
    IN    PVELAN                    pVElan,
    IN    PUCHAR                    String
    );

ULONG
PtDereferenceVElan(
    IN    PVELAN                    pVElan,
    IN    PUCHAR                    String
    );

BOOLEAN
PtReferenceAdapter(
    IN    PADAPT                    pAdapt,
    IN    PUCHAR                    String
    );

ULONG
PtDereferenceAdapter(
    IN    PADAPT                    pAdapt,
    IN    PUCHAR                    String
    );

//
// Miniport proto-types
//
NDIS_STATUS
MPInitialize(
    OUT   PNDIS_STATUS              OpenErrorStatus,
    OUT   PUINT                     SelectedMediumIndex,
    IN    PNDIS_MEDIUM              MediumArray,
    IN    UINT                      MediumArraySize,
    IN    NDIS_HANDLE               MiniportAdapterHandle,
    IN    NDIS_HANDLE               WrapperConfigurationContext
    );

VOID
MPSendPackets(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PPNDIS_PACKET             PacketArray,
    IN    UINT                      NumberOfPackets
    );

NDIS_STATUS
MPQueryInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesWritten,
    OUT   PULONG                    BytesNeeded
    );

NDIS_STATUS
MPSetInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesRead,
    OUT   PULONG                    BytesNeeded
    );

VOID
MPReturnPacket(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PNDIS_PACKET              Packet
    );

NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET                Packet,
    OUT PUINT                       BytesTransferred,
    IN  NDIS_HANDLE                 MiniportAdapterContext,
    IN  NDIS_HANDLE                 MiniportReceiveContext,
    IN  UINT                        ByteOffset,
    IN  UINT                        BytesToTransfer
    );

VOID
MPHalt(
    IN    NDIS_HANDLE               MiniportAdapterContext
    );


NDIS_STATUS
MPSetPacketFilter(
    IN    PVELAN                    pVElan,
    IN    ULONG                     PacketFilter
    );

NDIS_STATUS
MPSetMulticastList(
    IN PVELAN                       pVElan,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesRead,
    OUT PULONG                      pBytesNeeded
    );

PUCHAR
MacAddrToString(PVOID In
    );

VOID
MPGenerateMacAddr(
    PVELAN                          pVElan
);

#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN    NDIS_HANDLE              MiniportAdapterContext,
    IN    PVOID                    CancelId
    );

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE                 MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT       DevicePnPEvent,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength
    );


VOID
MPAdapterShutdown(
    IN NDIS_HANDLE                  MiniportAdapterContext
    );

#endif //NDIS51_MINIPORT

VOID
MPUnload(
    IN    PDRIVER_OBJECT            DriverObject
    );

NDIS_STATUS
MPForwardRequest(
    IN PVELAN                       pVElan,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      BytesReadOrWritten,
    OUT PULONG                      BytesNeeded
    );


//
// Super-structure for NDIS_REQUEST, to allow us to keep context
// about requests sent down to a lower binding.
//
typedef struct _MUX_NDIS_REQUEST
{
    PVELAN                      pVElan;     // Set iff this is a forwarded
                                            // request from a VELAN.
    NDIS_STATUS                 Status;     // Completion status
    NDIS_EVENT                  Event;      // Used to block for completion.
    PMUX_REQ_COMPLETE_HANDLER   pCallback;  // Called on completion of request
    NDIS_REQUEST                Request;

} MUX_NDIS_REQUEST, *PMUX_NDIS_REQUEST;


//
// The ADAPT object represents a binding to a lower adapter by
// the protocol edge of this driver. Based on the configured
// Upper bindings, zero or more virtual miniport devices (VELANs)
// are created above this binding.
//
typedef struct _ADAPT
{
    // Chain adapters. Access to this is protected by the global lock.
    LIST_ENTRY                  Link;

    // References to this adapter.
    ULONG                       RefCount;

    // Handle to the lower adapter, used in NDIS calls referring
    // to this adapter.
    NDIS_HANDLE                 BindingHandle;

    // List of all the virtual ELANs created on this lower binding
    LIST_ENTRY                  VElanList;

    // Length of above list.
    ULONG                       VElanCount;

    // String used to access configuration for this binding.
    NDIS_STRING                 ConfigString;

    // Open Status. Used by bind/halt for Open/Close Adapter status.
    NDIS_STATUS                 Status;

    NDIS_EVENT                  Event;

    //
    // Packet filter set to the underlying adapter. This is
    // a combination (union) of filter bits set on all
    // attached VELAN miniports.
    //
    ULONG                       PacketFilter;

    // Medium of the underlying Adapter.
    NDIS_MEDIUM                 Medium;

    // Link speed of the underlying adapter.
    ULONG                       LinkSpeed;

    // Max lookahead size for the underlying adapter.
    ULONG                       MaxLookAhead;

    // Power state of the underlying adapter
    NDIS_DEVICE_POWER_STATE     PtDevicePowerState;

    // Ethernet address of the underlying adapter.
    UCHAR                       CurrentAddress[ETH_LENGTH_OF_ADDRESS];

#ifndef WIN9X
    //
    // Read/Write lock: allows multiple readers but only a single
    // writer. Used to protect the VELAN list and fields (e.g. packet
    // filter) shared on an ADAPT by multiple VELANs. Code that
    // needs to traverse the VELAN list safely acquires a READ lock.
    // Code that needs to safely modify the VELAN list or shared
    // fields acquires a WRITE lock (which also excludes READers).
    //
    // See macros MUX_ACQUIRE_ADAPT_xxx/MUX_RELEASE_ADAPT_xxx below.
    //
    // TBD - if we want to support this on Win9X, reimplement this!
    //
    NDIS_RW_LOCK                ReadWriteLock;
#endif // WIN9X

} ADAPT, *PADAPT;


//
// VELAN object represents a virtual ELAN instance and its
// corresponding virtual miniport adapter.
//
typedef struct _VELAN
{
    // Link into parent adapter's VELAN list.
    LIST_ENTRY                  Link;

    // References to this VELAN.
    ULONG                       RefCount;

    // Parent ADAPT.
    PADAPT                      pAdapt;

    // Copy of BindingHandle from ADAPT.
    NDIS_HANDLE                 BindingHandle;

    // Adapter handle for NDIS up-calls related to this virtual miniport.
    NDIS_HANDLE                 MiniportAdapterHandle;

    // Virtual miniport's power state.
    NDIS_DEVICE_POWER_STATE     MPDevicePowerState;

    // Has our Halt entry point been called?
    BOOLEAN                     MiniportHalting;

    // Do we need to indicate receive complete?
    BOOLEAN                     IndicateRcvComplete;

    // Do we need to indicate status complete?
    BOOLEAN                     IndicateStatusComplete;

    // Synchronization fields
    BOOLEAN                     MiniportInitPending;
    NDIS_EVENT                  MiniportInitEvent;

    // Uncompleted Sends/Requests to the adapter below.
    ULONG                       OutstandingSends;

    // Count outstanding indications, including received
    // packets, passed up to protocols on this VELAN.
    ULONG                       OutstandingReceives;

    // Packet pool for send packets
    NDIS_HANDLE                 SendPacketPoolHandle;

    // Packet pool for receive packets
    NDIS_HANDLE                 RecvPacketPoolHandle;

    // A request block that is used to forward a request presented
    // to the virtual miniport, to the lower binding. Since NDIS
    // serializes requests to a miniport, we only need one of these
    // per VELAN.
    //
    MUX_NDIS_REQUEST            Request;        
    PULONG                      BytesNeeded;
    PULONG                      BytesReadOrWritten;
    // Have we queued a request because the lower binding is
    // at a low power state?
    BOOLEAN                     QueuedRequest;

    // Have we started to deinitialize this VELAN?
    BOOLEAN                     DeInitializing;

    // configuration
    UCHAR                       PermanentAddress[ETH_LENGTH_OF_ADDRESS];
    UCHAR                       CurrentAddress[ETH_LENGTH_OF_ADDRESS];

    NDIS_STRING                 CfgDeviceName;  // used as the unique
                                                // ID for the VELAN
    ULONG                       VElanNumber;    // logical Elan number


    //
    //  ----- Buffer Management: Header buffers and Protocol buffers ----
    //

    // Some standard miniport parameters (OID values).
    ULONG                       PacketFilter;
    ULONG                       LookAhead;
    ULONG                       LinkSpeed;

    ULONG                       MaxBusySends;
    ULONG                       MaxBusyRecvs;

    // Packet counts
    ULONG64                     GoodTransmits;
    ULONG64                     GoodReceives;
    ULONG                       NumTxSinceLastAdjust;

    // Count of transmit errors
    ULONG                       TxAbortExcessCollisions;
    ULONG                       TxLateCollisions;
    ULONG                       TxDmaUnderrun;
    ULONG                       TxLostCRS;
    ULONG                       TxOKButDeferred;
    ULONG                       OneRetry;
    ULONG                       MoreThanOneRetry;
    ULONG                       TotalRetries;
    ULONG                       TransmitFailuresOther;

    // Count of receive errors
    ULONG                       RcvCrcErrors;
    ULONG                       RcvAlignmentErrors;
    ULONG                       RcvResourceErrors;
    ULONG                       RcvDmaOverrunErrors;
    ULONG                       RcvCdtFrames;
    ULONG                       RcvRuntErrors;
#if IEEE_VLAN_SUPPORT    
    ULONG                       RcvFormatErrors;
    ULONG                       RcvVlanIdErrors;
#endif    
    ULONG                       RegNumTcb;

    // Multicast list
    MUX_MAC_ADDRESS             McastAddrs[VELAN_MAX_MCAST_LIST];
    ULONG                       McastAddrCount;
#if IEEE_VLAN_SUPPORT
    ULONG                       VlanId;
    NDIS_HANDLE                 BufferPoolHandle;
    NPAGED_LOOKASIDE_LIST       TagLookaside;
#endif
    NDIS_STATUS                 LastIndicatedStatus;
    NDIS_STATUS                 LatestUnIndicateStatus;
    NDIS_SPIN_LOCK              Lock;


} VELAN, *PVELAN;

#if IEEE_VLAN_SUPPORT

#define TPID                            0x0081    
//
// Define tag_header structure
//
typedef struct _VLAN_TAG_HEADER
{
    UCHAR       TagInfo[2];    
} VLAN_TAG_HEADER, *PVLAN_TAG_HEADER;

//
// Define context struct that used when the lower driver
// uses non-packet indication. It contains the original
// context, the tagging information and the tag-header
// length
// 
typedef struct _MUX_RCV_CONTEXT
{
    ULONG                   TagHeaderLen;
    NDIS_PACKET_8021Q_INFO  NdisPacket8021QInfo;
    PVOID                   MacRcvContext;
}MUX_RCV_CONTEXT, *PMUX_RCV_CONTEXT;

//
// Macro definitions for VLAN support
// 
#define VLAN_TAG_HEADER_SIZE        4 

#define VLANID_DEFAULT              0 
#define VLAN_ID_MAX                 0xfff
#define VLAN_ID_MIN                 0x0

#define USER_PRIORITY_MASK          0xe0
#define CANONICAL_FORMAT_ID_MASK    0x10
#define HIGH_VLAN_ID_MASK           0x0F

//
// Get information for tag headre
// 
#define GET_CANONICAL_FORMAT_ID_FROM_TAG(_pTagHeader)  \
    ( _pTagHeader->TagInfo[0] & CANONICAL_FORMAT_ID_MASK)   
    
#define GET_USER_PRIORITY_FROM_TAG(_pTagHeader)  \
    ( _pTagHeader->TagInfo[0] & USER_PRIORITY_MASK)
    
#define GET_VLAN_ID_FROM_TAG(_pTagHeader)   \
    (ULONG)(((USHORT)(_pTagHeader->TagInfo[0] & HIGH_VLAN_ID_MASK) << 8) | (USHORT)(_pTagHeader->TagInfo[1]))
     
//
// Clear the tag header struct
// 
#define INITIALIZE_TAG_HEADER_TO_ZERO(_pTagHeader) \
{                                                  \
     _pTagHeader->TagInfo[0] = 0;                  \
     _pTagHeader->TagInfo[1] = 0;                  \
}
     
//
// Set VLAN information to tag header 
// Before we called all the set macro, first we need to initialize pTagHeader  to be 0
// 
#define SET_CANONICAL_FORMAT_ID_TO_TAG(_pTagHeader, CanonicalFormatId)  \
     _pTagHeader->TagInfo[0] |= ((UCHAR)CanonicalFormatId << 4)

#define SET_USER_PRIORITY_TO_TAG(_pTagHeader, UserPriority)  \
     _pTagHeader->TagInfo[0] |= ((UCHAR)UserPriority << 5)

#define SET_VLAN_ID_TO_TAG(_pTagHeader, VlanId)                 \
{                                                               \
    _pTagHeader->TagInfo[0] |= (((UCHAR)VlanId >> 8) & 0x0f);   \
     _pTagHeader->TagInfo[1] |= (UCHAR)VlanId;\
}

//
// Copy tagging information in the indicated frame to per packet info
// 
#define COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(_Ieee8021qInfo, _pTagHeader)                                   \
{                                                                                                               \
    (_Ieee8021qInfo).TagHeader.UserPriority = ((_pTagHeader->TagInfo[0] & USER_PRIORITY_MASK) >> 5);              \
    (_Ieee8021qInfo).TagHeader.CanonicalFormatId = ((_pTagHeader->TagInfo[0] & CANONICAL_FORMAT_ID_MASK) >> 4);   \
    (_Ieee8021qInfo).TagHeader.VlanId = (((USHORT)(_pTagHeader->TagInfo[0] & HIGH_VLAN_ID_MASK) << 8)| (USHORT)(_pTagHeader->TagInfo[1]));                                                                \
}

//
// Function to handle tagging on sending side
// 
NDIS_STATUS
MPHandleSendTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    );

//
// Functions to handle tagging on receiving side with packet indication
//
NDIS_STATUS
PtHandleRcvTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    );

#endif //IEEE_VLAN_SUPPORT

//
// Macro definitions for others.
//

//
// Is a given power state a low-power state?
//
#define MUX_IS_LOW_POWER_STATE(_PwrState)                       \
            ((_PwrState) > NdisDeviceStateD0)

#define MUX_INIT_ADAPT_RW_LOCK(_pAdapt) \
            NdisInitializeReadWriteLock(&(_pAdapt)->ReadWriteLock)


#define MUX_ACQUIRE_ADAPT_READ_LOCK(_pAdapt, _pLockState)       \
            NdisAcquireReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     FALSE,                     \
                                     _pLockState)

#define MUX_RELEASE_ADAPT_READ_LOCK(_pAdapt, _pLockState)       \
            NdisReleaseReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     _pLockState)

#define MUX_ACQUIRE_ADAPT_WRITE_LOCK(_pAdapt, _pLockState)      \
            NdisAcquireReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     TRUE,                      \
                                     _pLockState)

#define MUX_RELEASE_ADAPT_WRITE_LOCK(_pAdapt, _pLockState)      \
            NdisReleaseReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     _pLockState)

#define MUX_INCR_PENDING_RECEIVES(_pVElan)                      \
            NdisInterlockedIncrement((PLONG)&pVElan->OutstandingReceives)

#define MUX_DECR_PENDING_RECEIVES(_pVElan)                      \
            NdisInterlockedDecrement((PLONG)&pVElan->OutstandingReceives)

#define MUX_INCR_PENDING_SENDS(_pVElan)                         \
            NdisInterlockedIncrement((PLONG)&pVElan->OutstandingSends)

#define MUX_DECR_PENDING_SENDS(_pVElan)                         \
            NdisInterlockedDecrement((PLONG)&pVElan->OutstandingSends)




#define MUX_INCR_STATISTICS(_pUlongVal)                         \
            NdisInterlockedIncrement((PLONG)_pUlongVal)

#define MUX_INCR_STATISTICS64(_pUlong64Val)                     \
{                                                               \
    PLARGE_INTEGER      _pLargeInt = (PLARGE_INTEGER)_pUlong64Val;\
    if (NdisInterlockedIncrement((PLONG)&_pLargeInt->LowPart) == 0)    \
    {                                                           \
        NdisInterlockedIncrement(&_pLargeInt->HighPart);        \
    }                                                           \
}

#define ASSERT_AT_PASSIVE()                                     \
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL)



//
// Simple Mutual Exclusion constructs used in preference to
// using KeXXX calls since we don't have Mutex calls in NDIS.
// These can only be called at passive IRQL.
//

typedef struct _MUX_MUTEX
{
    ULONG                   Counter;
    ULONG                   ModuleAndLine;  // useful for debugging

} MUX_MUTEX, *PMUX_MUTEX;

#define MUX_INIT_MUTEX(_pMutex)                                 \
{                                                               \
    (_pMutex)->Counter = 0;                                     \
    (_pMutex)->ModuleAndLine = 0;                               \
}

#define MUX_ACQUIRE_MUTEX(_pMutex)                              \
{                                                               \
    while (NdisInterlockedIncrement((PLONG)&((_pMutex)->Counter)) != 1)\
    {                                                           \
        NdisInterlockedDecrement((PLONG)&((_pMutex)->Counter));        \
        NdisMSleep(10000);                                      \
    }                                                           \
    (_pMutex)->ModuleAndLine = (MODULE_NUMBER << 16) | __LINE__;\
}

#define MUX_RELEASE_MUTEX(_pMutex)                              \
{                                                               \
    (_pMutex)->ModuleAndLine = 0;                               \
    NdisInterlockedDecrement((PLONG)&(_pMutex)->Counter);              \
}


//
// Global variables
//
extern NDIS_HANDLE           ProtHandle, DriverHandle;
extern NDIS_MEDIUM           MediumArray[1];
extern NDIS_SPIN_LOCK        GlobalLock;
extern MUX_MUTEX             GlobalMutex;
extern LIST_ENTRY            AdapterList;
extern ULONG                 NextVElanNumber;


//
// Module numbers for debugging
//
#define MODULE_MUX          'X'
#define MODULE_PROT         'P'
#define MODULE_MINI         'M'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\miniport.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS Miniport Entry points and utility functions for the NDIS
    MUX Intermediate Miniport sample. The driver exposes zero or more
    Virtual Ethernet LANs (VELANs) as NDIS miniport instances over
    each lower (protocol-edge) binding to an underlying adapter.

Environment:

    Kernel mode.

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define MODULE_NUMBER           MODULE_MINI

NDIS_OID VElanSupportedOids[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_HEARTBEAT_FAILURE,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS,
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ADD_WAKE_UP_PATTERN,
    OID_PNP_REMOVE_WAKE_UP_PATTERN,
#if IEEE_VLAN_SUPPORT
    OID_GEN_VLAN_ID,
#endif    
    OID_PNP_ENABLE_WAKE_UP
    
};


NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS               OpenErrorStatus,
    OUT PUINT                      SelectedMediumIndex,
    IN  PNDIS_MEDIUM               MediumArray,
    IN  UINT                       MediumArraySize,
    IN  NDIS_HANDLE                MiniportAdapterHandle,
    IN  NDIS_HANDLE                WrapperConfigurationContext
    )
/*++

Routine Description:

    This is the Miniport Initialize routine which gets called as a
    result of our call to NdisIMInitializeDeviceInstanceEx.
    The context parameter which we pass there is the VELan structure
    which we retrieve here.

Arguments:

    OpenErrorStatus            Not used by us.
    SelectedMediumIndex        Place-holder for what media we are using
    MediumArray                Array of ndis media passed down to us to pick from
    MediumArraySize            Size of the array
    MiniportAdapterHandle       The handle NDIS uses to refer to us
    WrapperConfigurationContext    For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    UINT                i;
    PVELAN              pVElan;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    NDIS_HANDLE         ConfigurationHandle;
    PVOID               NetworkAddress;

#if IEEE_VLAN_SUPPORT
    PNDIS_CONFIGURATION_PARAMETER   Params;
    NDIS_STRING                     strVlanId = NDIS_STRING_CONST("VlanID");
#endif
    
    //
    // Start off by retrieving our virtual miniport context (VELAN) and 
    // storing the Miniport handle in it.
    //
    pVElan = NdisIMGetDeviceContext(MiniportAdapterHandle);

    DBGPRINT(MUX_LOUD, ("==> Miniport Initialize: VELAN %p\n", pVElan));

    ASSERT(pVElan != NULL);
    ASSERT(pVElan->pAdapt != NULL);

    do
    {
        pVElan->MiniportAdapterHandle = MiniportAdapterHandle;

        for (i = 0; i < MediumArraySize; i++)
        {
            if (MediumArray[i] == VELAN_MEDIA_TYPE)
            {
                *SelectedMediumIndex = i;
                break;
            }
        }

        if (i == MediumArraySize)
        {
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        //
        // Access configuration parameters for this miniport.
        //
        NdisOpenConfiguration(
            &Status,
            &ConfigurationHandle,
            WrapperConfigurationContext);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }


        NdisReadNetworkAddress(
            &Status,
            &NetworkAddress,
            &i,
            ConfigurationHandle);

        //
        // If there is a NetworkAddress override, use it 
        //
        if (((Status == NDIS_STATUS_SUCCESS) 
                && (i == ETH_LENGTH_OF_ADDRESS))
                && ((!ETH_IS_MULTICAST(NetworkAddress)) 
                && (ETH_IS_LOCALLY_ADMINISTERED (NetworkAddress))))
        {
            
            ETH_COPY_NETWORK_ADDRESS(
                        pVElan->CurrentAddress,
                        NetworkAddress);
        }
        else
        {
            MPGenerateMacAddr(pVElan);
        }
   
#if IEEE_VLAN_SUPPORT
        //
        // Read VLAN ID
        //
        NdisReadConfiguration(
                &Status,
                &Params,
                ConfigurationHandle,
                &strVlanId,
                NdisParameterInteger);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            //
            // Check for out of bound
            //
            if (Params->ParameterData.IntegerData > VLAN_ID_MAX)
            {
                pVElan->VlanId = VLANID_DEFAULT;
            }
            else
            {
                pVElan->VlanId = Params->ParameterData.IntegerData;
            }
        }
        else 
        {
            //
            // Should fail the initialization or use default value
            //
            pVElan->VlanId = VLANID_DEFAULT;
            Status = NDIS_STATUS_SUCCESS;
            
        }
                
#endif    
        
        NdisCloseConfiguration(ConfigurationHandle);

        //
        // Set the attributes now. NDIS_ATTRIBUTE_DESERIALIZE enables us
        // to make up-calls to NDIS from arbitrary execution contexts.
        // This also forces us to protect our data structures using
        // spinlocks where appropriate. Also in this case NDIS does not queue
        // packets on our behalf.
        //
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pVElan,
                             0,                                       
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    |
                                NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                                NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                                NDIS_ATTRIBUTE_DESERIALIZE |
                                NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                             0);


        //
        // Create an ioctl interface
        //
        (VOID)PtRegisterDevice();

        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);
    
    //
    // If we had received an UnbindAdapter notification on the underlying
    // adapter, we would have blocked that thread waiting for the IM Init
    // process to complete. Wake up any such thread.
    //
    // See PtUnbindAdapter for more details.
    //
    ASSERT(pVElan->MiniportInitPending == TRUE);
    pVElan->MiniportInitPending = FALSE;
    NdisSetEvent(&pVElan->MiniportInitEvent);

    DBGPRINT(MUX_INFO, ("<== Miniport Initialize: VELAN %p, Status %x\n", pVElan, Status));

	*OpenErrorStatus = Status;
    return Status;
}

VOID
MPSendPackets(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PPNDIS_PACKET             PacketArray,
    IN    UINT                      NumberOfPackets
    )
/*++

Routine Description:

    Send Packet Array handler. Called by NDIS whenever a protocol
    bound to our VELAN miniport sends one or more packets.

    We forward each packet to the lower binding.

    NOTE: NDIS will not Halt this VELAN miniport until all
    these packets are "send-completed", and we don't unbind
    the lower binding until all VELANs are halted. Therefore
    we don't need locks or references on VELAN or ADAPT structures.

Arguments:

    MiniportAdapterContext    Pointer to our VELAN
    PacketArray               Set of packets to send
    NumberOfPackets           Length of above array

Return Value:

    None - we call NdisMSendComplete whenever we are done with a packet.

--*/
{
    PVELAN          pVElan = (PVELAN)MiniportAdapterContext;
    PADAPT          pAdapt = pVElan->pAdapt;
    PNDIS_PACKET    Packet, MyPacket;
    NDIS_STATUS     Status;
    PVOID           MediaSpecificInfo;
    ULONG           MediaSpecificInfoSize;
    UINT            i;

    
    for (i = 0; i < NumberOfPackets; i++)
    {
        Packet = PacketArray[i];

        //
        // Allocate a new packet to encapsulate data from the original.
        //
        NdisAllocatePacket(&Status,
                           &MyPacket,
                           pVElan->SendPacketPoolHandle);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            PMUX_SEND_RSVD      pSendReserved;

            pSendReserved = MUX_RSVD_FROM_SEND_PACKET(MyPacket);
            pSendReserved->pOriginalPacket = Packet;
            pSendReserved->pVElan = pVElan;

            MyPacket->Private.Flags = NdisGetPacketFlags(Packet) |
                                        MUX_SEND_PACKET_FLAGS;

            MyPacket->Private.Head = Packet->Private.Head;
            MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
            //
            // Work around the fact that NDIS does not initialize this
            // to FALSE on Win9x.
            //
            MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

            //
            // Copy OOB data to the new packet.
            //
            NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
                           NDIS_OOB_DATA_FROM_PACKET(Packet),
                           sizeof(NDIS_PACKET_OOB_DATA));
            //
            // Copy relevant parts of per packet info into the new packet.
            //
#ifndef WIN9X
            NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif

            //
            // Copy Media specific information.
            //
            NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                                &MediaSpecificInfo,
                                                &MediaSpecificInfoSize);

            if (MediaSpecificInfo || MediaSpecificInfoSize)
            {
                NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
                                                    MediaSpecificInfo,
                                                    MediaSpecificInfoSize);
            }

#if IEEE_VLAN_SUPPORT
            Status = MPHandleSendTagging(pVElan, Packet, MyPacket);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                NdisFreePacket(MyPacket);
                NdisMSendComplete(pVElan->MiniportAdapterHandle,
                                    Packet,
                                    Status);
                continue;
            }
#endif                

            //
            // Make note of the upcoming send.
            //
            MUX_INCR_PENDING_SENDS(pVElan);

            //
            // Send it to the lower binding.
            //
            NdisSend(&Status,
                     pAdapt->BindingHandle,
                     MyPacket);

            if (Status != NDIS_STATUS_PENDING)
            {
                PtSendComplete((NDIS_HANDLE)pAdapt,
                               MyPacket,
                               Status);
            }
        }
        else
        {
            //
            // Failed to allocate a packet.
            //
            break;
        }
    }

    //
    // If we bailed out above, fail any unprocessed sends.
    //
    while (i < NumberOfPackets)
    {
        NdisMSendComplete(pVElan->MiniportAdapterHandle,
                          PacketArray[i],
                          NDIS_STATUS_RESOURCES);
        i++;
    }
}


NDIS_STATUS
MPQueryInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesWritten,
    OUT   PULONG                    BytesNeeded
    )
/*++

Routine Description:

    Entry point called by NDIS to query for the value of the specified OID.
    All OID values are responded to right here, since this is a virtual
    device (not pass-through).

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesWritten                Specifies how much info is written
    BytesNeeded                 In case the buffer is smaller than 
                                what we need, tell them how much is needed


Return Value:

    Return code from the NdisRequest below.

--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PVELAN                      pVElan;
    NDIS_HARDWARE_STATUS HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM                 Medium = VELAN_MEDIA_TYPE;
    UCHAR                       VendorDesc[] = VELAN_VENDOR_DESC;
    ULONG                       ulInfo;
    ULONG64                     ulInfo64;
    USHORT                      usInfo;
    PVOID                       pInfo = (PVOID) &ulInfo;
    ULONG                       ulInfoLen = sizeof(ulInfo);
    // Should we forward the request to the miniport below?
    BOOLEAN                     bForwardRequest = FALSE;

    
    pVElan = (PVELAN) MiniportAdapterContext;

    // Initialize the result
    *BytesWritten = 0;
    *BytesNeeded = 0;

    switch (Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            pInfo = (PVOID) VElanSupportedOids;
            ulInfoLen = sizeof(VElanSupportedOids);
            break;

        case OID_GEN_SUPPORTED_GUIDS:
            //
            // Do NOT forward this down, otherwise we will
            // end up with spurious instances of private WMI
            // classes supported by the lower driver(s).
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        case OID_GEN_HARDWARE_STATUS:
            pInfo = (PVOID) &HardwareStatus;
            ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pInfo = (PVOID) &Medium;
            ulInfoLen = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_LOOKAHEAD:
            ulInfo = pVElan->LookAhead - ETH_HEADER_SIZE;
            break;            
            
        case OID_GEN_MAXIMUM_FRAME_SIZE:
            ulInfo = ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE;

#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE;
#endif
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            ulInfo = (ULONG) ETH_MAX_PACKET_SIZE;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE;
#endif            
            break;
            
        case OID_GEN_MAC_OPTIONS:
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
                     NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_NO_LOOPBACK;

#if IEEE_VLAN_SUPPORT
            ulInfo |= (NDIS_MAC_OPTION_8021P_PRIORITY |
                        NDIS_MAC_OPTION_8021Q_VLAN);
#endif
            
            break;

        case OID_GEN_LINK_SPEED:
            bForwardRequest = TRUE;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            ulInfo = ETH_MAX_PACKET_SIZE * pVElan->MaxBusySends;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE * pVElan->MaxBusySends;
#endif            
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            ulInfo = ETH_MAX_PACKET_SIZE * pVElan->MaxBusyRecvs;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE * pVElan->MaxBusyRecvs;
#endif            
            
            break;

        case OID_GEN_VENDOR_ID:
            ulInfo = VELAN_VENDOR_ID;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pInfo = VendorDesc;
            ulInfoLen = sizeof(VendorDesc);
            break;
            
        case OID_GEN_VENDOR_DRIVER_VERSION:
            ulInfo = VELAN_VENDOR_ID;
            break;

        case OID_GEN_DRIVER_VERSION:
            usInfo = (USHORT) VELAN_DRIVER_VERSION;
            pInfo = (PVOID) &usInfo;
            ulInfoLen = sizeof(USHORT);
            break;

        case OID_802_3_PERMANENT_ADDRESS:
            pInfo = pVElan->PermanentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pInfo = pVElan->CurrentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            ulInfo = VELAN_MAX_MCAST_LIST;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            ulInfo = VELAN_MAX_SEND_PKTS;
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            //
            // Get this from the adapter below.
            //
            bForwardRequest = TRUE;
            break;

        case OID_PNP_QUERY_POWER:
            // simply succeed this.
            ulInfoLen = 0;
            break;

        case OID_PNP_CAPABILITIES:
        case OID_PNP_WAKE_UP_PATTERN_LIST:
            //
            // Pass down these power management/PNP OIDs.
            //
            bForwardRequest = TRUE;
            break;

        case OID_GEN_XMIT_OK:
            ulInfo64 = pVElan->GoodTransmits;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_RCV_OK:
            ulInfo64 = pVElan->GoodReceives;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_XMIT_ERROR:
            ulInfo = pVElan->TxAbortExcessCollisions +
                pVElan->TxDmaUnderrun +
                pVElan->TxLostCRS +
                pVElan->TxLateCollisions+
                pVElan->TransmitFailuresOther;
            break;
    
        case OID_GEN_RCV_ERROR:
            ulInfo = pVElan->RcvCrcErrors +
                pVElan->RcvAlignmentErrors +
                pVElan->RcvResourceErrors +
                pVElan->RcvDmaOverrunErrors +
                pVElan->RcvRuntErrors;
#if IEEE_VLAN_SUPPORT
            ulInfo +=
                (pVElan->RcvVlanIdErrors +
                pVElan->RcvFormatErrors);
#endif

            break;
    
        case OID_GEN_RCV_NO_BUFFER:
            ulInfo = pVElan->RcvResourceErrors;
            break;
    
        case OID_GEN_RCV_CRC_ERROR:
            ulInfo = pVElan->RcvCrcErrors;
            break;
    
        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            ulInfo = pVElan->RegNumTcb;
            break;
    
        case OID_802_3_RCV_ERROR_ALIGNMENT:
            ulInfo = pVElan->RcvAlignmentErrors;
            break;
    
        case OID_802_3_XMIT_ONE_COLLISION:
        	ulInfo = pVElan->OneRetry;
            break;
    
        case OID_802_3_XMIT_MORE_COLLISIONS:
        	ulInfo = pVElan->MoreThanOneRetry;
            break;
    
        case OID_802_3_XMIT_DEFERRED:
        	ulInfo = pVElan->TxOKButDeferred;
            break;
    
        case OID_802_3_XMIT_MAX_COLLISIONS:
            ulInfo = pVElan->TxAbortExcessCollisions;
            break;
    
        case OID_802_3_RCV_OVERRUN:
            ulInfo = pVElan->RcvDmaOverrunErrors;
            break;
    
        case OID_802_3_XMIT_UNDERRUN:
            ulInfo = pVElan->TxDmaUnderrun;
            break;
    
        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
            ulInfo = pVElan->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_TIMES_CRS_LOST:
            ulInfo = pVElan->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_LATE_COLLISIONS:
            ulInfo = pVElan->TxLateCollisions;
            break;
   
#if IEEE_VLAN_SUPPORT            
        case OID_GEN_VLAN_ID:
            ulInfo = pVElan->VlanId;
            break;

#endif

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    if (bForwardRequest == FALSE)
    {
        //
        // No need to forward this request down.
        //
        if (Status == NDIS_STATUS_SUCCESS)
        {
            if (ulInfoLen <= InformationBufferLength)
            {
                // Copy result into InformationBuffer
                *BytesWritten = ulInfoLen;
                if(ulInfoLen)
                {
                    NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);
                }
            }
            else
            {
                // too short
                *BytesNeeded = ulInfoLen;
                Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            }
        }
    }
    else
    {
        //
        // Send this request to the binding below.
        //
        Status = MPForwardRequest(pVElan,
                                   NdisRequestQueryInformation,
                                   Oid,
                                   InformationBuffer,
                                   InformationBufferLength,
                                   BytesWritten,
                                   BytesNeeded);
    }

    if ((Status != NDIS_STATUS_SUCCESS) &&
        (Status != NDIS_STATUS_PENDING))
    {
        DBGPRINT(MUX_WARN, ("MPQueryInformation VELAN %p, OID 0x%08x, Status = 0x%08x\n",
                    pVElan, Oid, Status));
    }
    
    return(Status);

}


NDIS_STATUS
MPSetInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesRead,
    OUT   PULONG                    BytesNeeded
    )
/*++

Routine Description:

    This is the handler for an OID set operation. Relevant
    OIDs are forwarded down to the lower miniport for handling.

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesRead                   Specifies how much info is read
    BytesNeeded                 In case the buffer is smaller than what 
                                we need, tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PVELAN                  pVElan = (PVELAN) MiniportAdapterContext;
    ULONG                   PacketFilter;
    NDIS_DEVICE_POWER_STATE NewDeviceState;
    
    // Should we forward the request to the miniport below?
    BOOLEAN                 bForwardRequest = FALSE;

    *BytesRead = 0;
    *BytesNeeded = 0;

    switch (Oid)
    {
        //
        // Let the miniport below handle these OIDs:
        //
        case OID_PNP_ADD_WAKE_UP_PATTERN:
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        case OID_PNP_ENABLE_WAKE_UP:
            bForwardRequest = TRUE;
            break;

        case OID_PNP_SET_POWER:
            //
            // Store new power state and succeed the request.
            //
            *BytesNeeded = sizeof(NDIS_DEVICE_POWER_STATE);
            if (InformationBufferLength < *BytesNeeded)
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }
           
            NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE)InformationBuffer);
            
            //
            // Check if the VELAN adapter goes from lower power state to D0
            // 
            if ((MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)) 
                    && (!MUX_IS_LOW_POWER_STATE(NewDeviceState)))
            {
                //
                // Indicate the media status is necessary
                // 
                if (pVElan->LastIndicatedStatus != pVElan->LatestUnIndicateStatus)
                {
                    NdisMIndicateStatus(pVElan->MiniportAdapterHandle,
                                        pVElan->LatestUnIndicateStatus,
                                        (PVOID)NULL,
                                        0);
                    NdisMIndicateStatusComplete(pVElan->MiniportAdapterHandle);
                    pVElan->LastIndicatedStatus = pVElan->LatestUnIndicateStatus;
                }
            }
            //
            // Check if the VELAN adapter goes from D0 to lower power state
            // 
            if ((!MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)) 
                    && (MUX_IS_LOW_POWER_STATE(NewDeviceState)))
            {
                //
                //  Initialize LastUnIndicateStatus 
                // 
                pVElan->LatestUnIndicateStatus = pVElan->LastIndicatedStatus;
            }
            
            NdisMoveMemory(&pVElan->MPDevicePowerState,
                           InformationBuffer,
                           *BytesNeeded);

            DBGPRINT(MUX_INFO, ("SetInfo: VElan %p, new miniport power state --- %d\n",
                    pVElan, pVElan->MPDevicePowerState));

            break;

        case OID_802_3_MULTICAST_LIST:
            Status = MPSetMulticastList(pVElan,
                                        InformationBuffer,
                                        InformationBufferLength,
                                        BytesRead,
                                        BytesNeeded);
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            if (InformationBufferLength != sizeof(ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                *BytesNeeded = sizeof(ULONG);
                break;
            }

            NdisMoveMemory(&PacketFilter, InformationBuffer, sizeof(ULONG));
            *BytesRead = sizeof(ULONG);

            Status = MPSetPacketFilter(pVElan,
                                       PacketFilter);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
#if IEEE_VLAN_SUPPORT
            //
            // In order to simplify parsing and to avoid excessive
            // copying, we need the tag header also to be present in the
            // lookahead buffer. Make sure that the driver below
            // includes that.
            //
            *(UNALIGNED PULONG)InformationBuffer += VLAN_TAG_HEADER_SIZE;
#endif            
            bForwardRequest = TRUE;
            break;
            
#if IEEE_VLAN_SUPPORT
        case OID_GEN_VLAN_ID:
            if (InformationBufferLength != sizeof(ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                *BytesNeeded = sizeof(ULONG);
                break;
            }
            NdisMoveMemory(&(pVElan->VlanId), InformationBuffer, sizeof(ULONG));
            break;
#endif
            
        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;

    }
    
    if (bForwardRequest == FALSE)
    {
        if (Status == NDIS_STATUS_SUCCESS)
        {
            *BytesRead = InformationBufferLength;
        }
    }
    else
    {
        //
        // Send this request to the binding below.
        //
        Status = MPForwardRequest(pVElan,
                                  NdisRequestSetInformation,
                                  Oid,
                                  InformationBuffer,
                                  InformationBufferLength,
                                  BytesRead,
                                  BytesNeeded);
    }

    return(Status);
}

VOID
MPReturnPacket(
    IN    NDIS_HANDLE             MiniportAdapterContext,
    IN    PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    NDIS Miniport entry point called whenever protocols are done with
    a packet that we had indicated up and they had queued up for returning
    later.

Arguments:

    MiniportAdapterContext    - pointer to VELAN structure
    Packet    - packet being returned.

Return Value:

    None.

--*/
{
    PVELAN              pVElan = (PVELAN)MiniportAdapterContext;
    PNDIS_PACKET        pOriginalPacket;
    PMUX_RECV_RSVD      pRecvRsvd;
#if IEEE_VLAN_SUPPORT
    NDIS_PACKET_8021Q_INFO  NdisPacket8021qInfo;
#endif    
    
    pRecvRsvd = MUX_RSVD_FROM_RECV_PACKET(Packet);
    pOriginalPacket = pRecvRsvd->pOriginalPacket;

    //
    // Reclaim our packet.
    //
#if IEEE_VLAN_SUPPORT
    //
    // We would have set per-packet information if we had
    // extracted a tag header from the received packet.
    // 
    NdisPacket8021qInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET (
                                                Packet,
                                                Ieee8021QInfo);
    //
    // If we did remove the tag header from the received packet,
    // we would have allocated a buffer to describe the "untagged"
    // header (see PtHandleRcvTagging); free it.
    // 
    if (NdisPacket8021qInfo.Value)
    {
        NdisFreeBuffer(Packet->Private.Head);
    }

#endif
    
    NdisFreePacket(Packet);

    //
    // Return the original packet received at our protocol
    // edge, if any.
    //
    // NOTE that we might end up calling NdisReturnPackets
    // multiple times with the same "lower" packet, based on
    // the number of VELANs to which we had indicated that
    // packet. The number of times we do so should match
    // the return value from our PtReceivePacket handler.
    //
    if (pOriginalPacket != NULL)
    {
        NdisReturnPackets(&pOriginalPacket, 1);
    }
    else
    {
        //
        // If no original packet, then we have been called
        // here to reclaim a packet used to forward up
        // a non-packet receive (see PtReceive). There
        // is nothing more to be done.
        //
    }


    MUX_DECR_PENDING_RECEIVES(pVElan);
}


NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET                Packet,
    OUT PUINT                       BytesTransferred,
    IN  NDIS_HANDLE                 MiniportAdapterContext,
    IN  NDIS_HANDLE                 MiniportReceiveContext,
    IN  UINT                        ByteOffset,
    IN  UINT                        BytesToTransfer
    )
/*++

Routine Description:

    Miniport's transfer data handler.  This is called if we had
    indicated receive data using a non-packet API, for e.g. if
    the lookahead buffer did not contain the entire data.

    We need to forward this to the miniport below to that it can
    copy in the rest of the data. We call NdisTransferData to do so.
    However, when that completes (see PtTransferDataComplete), we
    have to get back at the VELAN from which this packet came so that
    we can complete this request with the right MiniportAdapterHandle.
    We therefore allocate a new packet, pointing to the same buffer
    as the packet just passed in, and use reserved space in the packet
    to hold a backpointer to the VELAN from which this came.

Arguments:

    Packet                    Destination packet
    BytesTransferred          Place to return how much data was copied
    MiniportAdapterContext    Pointer to the VELAN structure
    MiniportReceiveContext    Context
    ByteOffset                Offset into the packet for copying data
    BytesToTransfer           How much to copy.

Return Value:

    Status of transfer

--*/
{
    PVELAN          pVElan = (PVELAN)MiniportAdapterContext;
    NDIS_STATUS     Status;
    PNDIS_PACKET    MyPacket;
    PMUX_TD_RSVD    pTDReserved;
#if IEEE_VLAN_SUPPORT
    PMUX_RCV_CONTEXT        pMuxRcvContext;
#endif    
    

    do
    {
        NdisAllocatePacket(&Status,
                           &MyPacket,
                           pVElan->SendPacketPoolHandle);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pTDReserved = MUX_RSVD_FROM_TD_PACKET(MyPacket);
        pTDReserved->pOriginalPacket = Packet;
        pTDReserved->pVElan = pVElan;

        MyPacket->Private.Flags = NdisGetPacketFlags(Packet) |
                                        MUX_SEND_PACKET_FLAGS;

        MyPacket->Private.Head = Packet->Private.Head;
        MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
        //
        // Work around the fact that NDIS does not initialize this
        // field on Win9x.
        //
        MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

#if IEEE_VLAN_SUPPORT
        //
        // Check if the original received packet did contain a
        // VLAN tag header. If so, make sure we get the upcoming
        // call to NdisTransferData to skip the tag header.
        //
        pMuxRcvContext = (PMUX_RCV_CONTEXT)MiniportReceiveContext;
        if (pMuxRcvContext->TagHeaderLen == VLAN_TAG_HEADER_SIZE)
        {
            //
            // There was a tag header in the received packet.
            //
            ByteOffset += VLAN_TAG_HEADER_SIZE;

            //
            // Copy the 8021Q info into the packet
            //
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) =
                                        pMuxRcvContext->NdisPacket8021QInfo.Value;
        }

        //
        // Get back the lower driver's receive context for this indication.
        //
        MiniportReceiveContext = pMuxRcvContext->MacRcvContext;
#endif
        
        NdisTransferData(&Status,
                         pVElan->pAdapt->BindingHandle,
                         MiniportReceiveContext,
                         ByteOffset,
                         BytesToTransfer,
                         MyPacket,
                         BytesTransferred);
    
        if (Status != NDIS_STATUS_PENDING)
        {
            PtTransferDataComplete(pVElan->pAdapt,
                                   MyPacket,
                                   Status,
                                   *BytesTransferred);

            Status = NDIS_STATUS_PENDING;
        }
    }
    while (FALSE);

    return(Status);
}
    
    

VOID
MPHalt(
    IN    NDIS_HANDLE                MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler. Add any further clean-up for the VELAN to this
    function.

    We wait for all pending I/O on the VELAN to complete and then
    unlink the VELAN from the adapter.

Arguments:

    MiniportAdapterContext    Pointer to the pVElan

Return Value:

    None.

--*/
{
    PVELAN            pVElan = (PVELAN)MiniportAdapterContext;
    

    DBGPRINT(MUX_LOUD, ("==>MiniportHalt: VELAN %p\n", pVElan));

    //
    // Mark the VELAN so that we don't send down any new requests or
    // sends to the adapter below, or new receives/indications to
    // protocols above.
    //
    pVElan->MiniportHalting = TRUE;

    //
    // Update the packet filter on the underlying adapter if needed.
    //
    if (pVElan->PacketFilter != 0)
    {
        MPSetPacketFilter(pVElan, 0);
    }

    //
    // Wait for any outstanding sends or requests to complete.
    //
    while (pVElan->OutstandingSends)
    {
        DBGPRINT(MUX_INFO, ("MiniportHalt: VELAN %p has %d outstanding sends\n",
                            pVElan, pVElan->OutstandingSends));
        NdisMSleep(20000);
    }

    //
    // Wait for all outstanding indications to be completed and
    // any pended receive packets to be returned to us.
    //
    while (pVElan->OutstandingReceives)
    {
        DBGPRINT(MUX_INFO, ("MiniportHalt: VELAN %p has %d outstanding receives\n",
                            pVElan, pVElan->OutstandingReceives));
        NdisMSleep(20000);
    }

    //
    // Delete the ioctl interface that was created when the miniport
    // was created.
    //
    (VOID)PtDeregisterDevice();

    //
    // Unlink the VELAN from its parent ADAPT structure. This will
    // dereference the VELAN.
    //
    pVElan->MiniportAdapterHandle = NULL;
    PtUnlinkVElanFromAdapter(pVElan);
    
    DBGPRINT(MUX_LOUD, ("<== MiniportHalt: pVElan %p\n", pVElan));
}


NDIS_STATUS
MPForwardRequest(
    IN PVELAN                       pVElan,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      BytesReadOrWritten,
    OUT PULONG                      BytesNeeded
    )
/*++

Routine Description:

    Utility routine that forwards an NDIS request made on a VELAN to the
    lower binding. Since at most a single request can be pended on a VELAN,
    we use the pre-allocated request structure embedded in the VELAN struct.

Arguments:


Return Value:

    NDIS_STATUS_PENDING if a request was sent down.

--*/
{
    NDIS_STATUS         Status;
    PMUX_NDIS_REQUEST   pMuxNdisRequest = &pVElan->Request;

    DBGPRINT(MUX_LOUD, ("MPForwardRequest: VELAN %p, OID %x\n", pVElan, Oid));

    do
    {
        MUX_INCR_PENDING_SENDS(pVElan);

        //
        // If the miniport below is going away, fail the request
        // 
        NdisAcquireSpinLock(&pVElan->Lock);
        if (pVElan->DeInitializing == TRUE)
        {
            NdisReleaseSpinLock(&pVElan->Lock);
            MUX_DECR_PENDING_SENDS(pVElan);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        NdisReleaseSpinLock(&pVElan->Lock);    

        //
        // If the virtual miniport edge is at a low power
        // state, fail this request.
        //
        if (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
        {
            MUX_DECR_PENDING_SENDS(pVElan);
            Status = NDIS_STATUS_ADAPTER_NOT_READY;
            break;
        }

        pVElan->BytesNeeded = BytesNeeded;
        pVElan->BytesReadOrWritten = BytesReadOrWritten;
        pMuxNdisRequest->pCallback = PtCompleteForwardedRequest;

        switch (RequestType)
        {
            case NdisRequestQueryInformation:
                pMuxNdisRequest->Request.RequestType = NdisRequestQueryInformation;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid = Oid;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBuffer = 
                                            InformationBuffer;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBufferLength = 
                                            InformationBufferLength;
                break;

            case NdisRequestSetInformation:
                pMuxNdisRequest->Request.RequestType = NdisRequestSetInformation;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.Oid = Oid;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.InformationBuffer = 
                                            InformationBuffer;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = 
                                            InformationBufferLength;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        //
        // If the miniport below is going away
        //
        NdisAcquireSpinLock(&pVElan->Lock);
        if (pVElan->DeInitializing == TRUE)
        {
            NdisReleaseSpinLock(&pVElan->Lock);
            MUX_DECR_PENDING_SENDS(pVElan);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
        // If the lower binding has been notified of a low
        // power state, queue this request; it will be picked
        // up again when the lower binding returns to D0.
        //
        if (MUX_IS_LOW_POWER_STATE(pVElan->pAdapt->PtDevicePowerState))
        {
            DBGPRINT(MUX_INFO, ("ForwardRequest: VELAN %p, Adapt %p power"
                                " state is %d, queueing OID %x\n",
                                pVElan, pVElan->pAdapt,
                                pVElan->pAdapt->PtDevicePowerState, Oid));

            pVElan->QueuedRequest = TRUE;
            NdisReleaseSpinLock(&pVElan->Lock);
            Status = NDIS_STATUS_PENDING;
            break;
        }
        NdisReleaseSpinLock(&pVElan->Lock);

        NdisRequest(&Status,
                    pVElan->BindingHandle,
                    &pMuxNdisRequest->Request);

        if (Status != NDIS_STATUS_PENDING)
        {
            PtRequestComplete(pVElan->pAdapt, &pMuxNdisRequest->Request, Status);
            Status = NDIS_STATUS_PENDING;
            break;
        }
    }
    while (FALSE);

    return (Status);
}

NDIS_STATUS
MPSetPacketFilter(
    IN PVELAN               pVElan,
    IN ULONG                PacketFilter
    )
/*++
Routine Description:

    This routine will set up the VELAN so that it accepts packets 
    that match the specified packet filter.  The only filter bits   
    that can truly be toggled are for broadcast and promiscuous.

    The MUX driver always sets the lower binding to promiscuous
    mode, but we do some optimization here to avoid turning on
    receives too soon. That is, we set the packet filter on the lower
    binding to a non-zero value iff at least one of the VELANs
    has a non-zero filter value.
    
    NOTE: setting the lower binding to promiscuous mode can
    impact CPU utilization. The only reason we set the lower binding
    to promiscuous mode in this sample is that we need to be able
    to receive unicast frames directed to MAC address(es) that do not
    match the local adapter's MAC address. If VELAN MAC addresses
    are set to be equal to that of the adapter below, it is sufficient
    to set the lower packet filter to the bitwise OR'ed value of
    packet filter settings on all VELANs.
                                    

Arguments:

    pVElan - pointer to VELAN
    PacketFilter - the new packet filter 
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PADAPT          pAdapt;
    PVELAN          pTmpVElan;
    PLIST_ENTRY     p;
    ULONG           AdapterFilter;
    BOOLEAN         bSendUpdate = FALSE;
    LOCK_STATE      LockState;

    DBGPRINT(MUX_LOUD, ("=> SetPacketFilter VELAN %p, Filter %x\n", pVElan, PacketFilter));
    
    do
    {
        //
        // Any bits not supported?
        //
        if (PacketFilter & ~VELAN_SUPPORTED_FILTERS)
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    
        AdapterFilter = 0;
        pAdapt = pVElan->pAdapt;

        //
        // Grab a Write lock on the adapter so that this operation
        // does not interfere with any receives that might be accessing
        // filter information.
        //
        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        //
        // Save the new packet filter value
        //
        pVElan->PacketFilter = PacketFilter;

        //
        // Compute the new combined filter for all VELANs on this
        // adapter.
        //
        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pTmpVElan = CONTAINING_RECORD(p, VELAN, Link);
            AdapterFilter |= pTmpVElan->PacketFilter;
        }

        //
        // If all VELANs have packet filters set to 0, turn off
        // receives on the lower adapter, if not already done.
        //
        if ((AdapterFilter == 0) && (pAdapt->PacketFilter != 0))
        {
            bSendUpdate = TRUE;
            pAdapt->PacketFilter = 0;
        }
        else
        //
        // If receives had been turned off on the lower adapter, and
        // the new filter is non-zero, turn on the lower adapter.
        // We set the adapter to promiscuous mode in this sample
        // so that we are able to receive packets directed to
        // any of the VELAN MAC addresses.
        //
        if ((AdapterFilter != 0) && (pAdapt->PacketFilter == 0))
        {
            bSendUpdate = TRUE;
            pAdapt->PacketFilter = MUX_ADAPTER_PACKET_FILTER;
        }
        
        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        if (bSendUpdate)
        {
            PtRequestAdapterAsync(
                pAdapt,
                NdisRequestSetInformation,
                OID_GEN_CURRENT_PACKET_FILTER,
                &pAdapt->PacketFilter,
                sizeof(pAdapt->PacketFilter),
                PtDiscardCompletedRequest);
        }

    }
    while (FALSE);

    DBGPRINT(MUX_INFO, ("<= SetPacketFilter VELAN %p, Status %x\n", pVElan, Status));
    
    return(Status);
}


NDIS_STATUS
MPSetMulticastList(
    IN PVELAN                   pVElan,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  pBytesRead,
    OUT PULONG                  pBytesNeeded
    )
/*++

Routine Description:

    Set the multicast list on the specified VELAN miniport.
    We simply validate all information and copy in the multicast
    list.

    We don't forward the multicast list information down since
    we set the lower binding to promisc. mode.

Arguments:

    pVElan - VELAN on which to set the multicast list
    InformationBuffer - pointer to new multicast list
    InformationBufferLength - length in bytes of above list
    pBytesRead - place to return # of bytes read from the above
    pBytesNeeded - place to return expected min # of bytes

Return Value:

    NDIS_STATUS

--*/
{
    NDIS_STATUS         Status;
    PADAPT              pAdapt;
    LOCK_STATE          LockState;

    //
    // Initialize.
    //
    *pBytesNeeded = sizeof(MUX_MAC_ADDRESS);
    *pBytesRead = 0;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        if (InformationBufferLength % sizeof(MUX_MAC_ADDRESS))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (InformationBufferLength > (VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS)))
        {
            Status = NDIS_STATUS_MULTICAST_FULL;
            *pBytesNeeded = VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS);
            break;
        }

        pAdapt = pVElan->pAdapt;

        //
        // Grab a Write lock on the adapter so that this operation
        // does not interfere with any receives that might be accessing
        // multicast list information.
        //
        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        NdisZeroMemory(&pVElan->McastAddrs[0],
                       VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS));
        
        NdisMoveMemory(&pVElan->McastAddrs[0],
                       InformationBuffer,
                       InformationBufferLength);
        
        pVElan->McastAddrCount = InformationBufferLength / sizeof(MUX_MAC_ADDRESS);
        
        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

    return (Status);
}


//
// Careful! Uses static storage for string. Used to simplify DbgPrints
// of MAC addresses.
//
PUCHAR
MacAddrToString(PVOID In)
{
    static UCHAR String[20];
    static PCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
    {
        *s++ = HexChars[(*EthAddr) >> 4];
        *s++ = HexChars[(*EthAddr) & 0xf];
    }
    *s = '\0';
    return String; 
}


VOID
MPGenerateMacAddr(
    PVELAN                    pVElan
)
/*++

Routine Description:

    Generates a "virtual" MAC address for a VELAN.
    NOTE: this is only a sample implementation of selecting
    a MAC address for the VELAN. Other implementations are possible,
    including using the MAC address of the underlying adapter as
    the MAC address of the VELAN.
    
Arguments:

    pVElan  - Pointer to velan structure

Return Value:

    None

--*/
{
    pVElan->PermanentAddress[0] = 
        0x02 | (((UCHAR)pVElan->VElanNumber & 0x3f) << 2);
    pVElan->PermanentAddress[1] = 
        0x02 | (((UCHAR)pVElan->VElanNumber & 0x3f) << 3);

    ETH_COPY_NETWORK_ADDRESS(
            pVElan->CurrentAddress,
            pVElan->PermanentAddress);
    
    DBGPRINT(MUX_LOUD, ("%d CurrentAddress %s\n",
        pVElan->VElanNumber, MacAddrToString(&pVElan->CurrentAddress)));
    DBGPRINT(MUX_LOUD, ("%d PermanentAddress  %s\n",
        pVElan->VElanNumber, MacAddrToString(&pVElan->PermanentAddress)));

}


#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PVOID                    CancelId
    )
/*++

Routine Description:

    The miniport entry point to handle cancellation of all send packets
    that match the given CancelId. If we have queued any packets that match
    this, then we should dequeue them and call NdisMSendComplete for all
    such packets, with a status of NDIS_STATUS_REQUEST_ABORTED.

    We should also call NdisCancelSendPackets in turn, on each lower binding
    that this adapter corresponds to. This is to let miniports below cancel
    any matching packets.

Arguments:

    MiniportAdapterContext    - pointer to VELAN structure
    CancelId    - ID of packets to be cancelled.

Return Value:

    None

--*/
{
    PVELAN  pVElan = (PVELAN)MiniportAdapterContext;

    //
    // If we queue packets on our VELAN/adapter structure, this would be 
    // the place to acquire a spinlock to it, unlink any packets whose
    // Id matches CancelId, release the spinlock and call NdisMSendComplete
    // with NDIS_STATUS_REQUEST_ABORTED for all unlinked packets.
    //

    //
    // Next, pass this down so that we let the miniport(s) below cancel
    // any packets that they might have queued.
    //
    NdisCancelSendPackets(pVElan->pAdapt->BindingHandle, CancelId);

    return;
}

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT    DevicePnPEvent,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength
    )
/*++

Routine Description:

    This handler is called to notify us of PnP events directed to
    our miniport device object.

Arguments:

    MiniportAdapterContext - pointer to VELAN structure
    DevicePnPEvent - the event
    InformationBuffer - Points to additional event-specific information
    InformationBufferLength - length of above

Return Value:

    None
--*/
{
    // TBD - add code/comments about processing this.

	UNREFERENCED_PARAMETER(MiniportAdapterContext);
    UNREFERENCED_PARAMETER(DevicePnPEvent);
    UNREFERENCED_PARAMETER(InformationBuffer);
    UNREFERENCED_PARAMETER(InformationBufferLength);
    
    return;
}


VOID
MPAdapterShutdown(
    IN NDIS_HANDLE              MiniportAdapterContext
    )
/*++

Routine Description:

    This handler is called to notify us of an impending system shutdown.
    Since this is not a hardware driver, there isn't anything specific
    we need to do about this.

Arguments:

    MiniportAdapterContext  - pointer to VELAN structure

Return Value:

    None
--*/
{
	UNREFERENCED_PARAMETER(MiniportAdapterContext);
	
    return;
}


#endif // NDIS51_MINIPORT

VOID
MPUnload(
    IN    PDRIVER_OBJECT        DriverObject
    )
{
    NDIS_STATUS Status;
    
#if !DBG
    UNREFERENCED_PARAMETER(DriverObject);
#endif
    
    DBGPRINT(MUX_LOUD, ("==> MPUnload: DriverObj %p\n", DriverObject));  
    NdisDeregisterProtocol(&Status, ProtHandle);
    DBGPRINT(MUX_LOUD, ("<== MPUnload \n"));    
}

#if IEEE_VLAN_SUPPORT
NDIS_STATUS
MPHandleSendTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    )
/*++

Routine Description:

    This function is called when the driver supports IEEE802Q tagging.
    It checks the packet to be sent on a VELAN and inserts a tag header
    if necessary.

Arguments:

    PVELAN  - pointer to VELAN structure
    Packet - pointer to original packet
    MyPacket - pointer to the new allocated packet
    
Return Value:

    NDIS_STATUS_SUCCESS if the packet was successfully parsed
    and hence should be passed down to the lower driver. NDIS_STATUS_XXX
    otherwise.
    
--*/
{
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    PVOID                       pEthTagBuffer;
    PNDIS_BUFFER                pNdisBuffer;
    PVOID                       pVa;
    ULONG                       BufferLength;
    PNDIS_BUFFER                pFirstBuffer;
    PNDIS_BUFFER                pSecondBuffer;
    NDIS_STATUS                 Status;
    NDIS_STATUS                 Status2;
    PVOID                       pStartVa = NULL;
    BOOLEAN                     IsFirstVa;
    PVLAN_TAG_HEADER            pTagHeader;
    PUSHORT                     pTpid;
    ULONG                       BytesToSkip;
    PUSHORT                     pTypeLength;
    //
    // Add tag header here
    //
    Status = NDIS_STATUS_SUCCESS;
    
    NdisPacket8021qInfo.Value =  NDIS_PER_PACKET_INFO_FROM_PACKET(
                                                            MyPacket,         
                                                            Ieee8021QInfo);
            
    do
    {
        //
        // If the vlan ID of the virtual miniport is 0, the miniport should act like it doesn't
        // support VELAN tag processing
        // 
        if (pVElan->VlanId == 0)
        {
            break;
        }
        //
        // Insert a tag only if we have a configured VLAN ID
        //
            
        //
        // We don't support E-RIF
        // 
        if (NdisPacket8021qInfo.TagHeader.CanonicalFormatId)
        {
            //
            // skip the packet, return NDIS_STATUS_FAILURE
            //
            Status = NDIS_STATUS_INVALID_PACKET;
            break;
        }

        //
        // The Vlan Id must be the same as the configured VLAN ID if it is non-zero
        // 
        if ((NdisPacket8021qInfo.TagHeader.VlanId)
                && (NdisPacket8021qInfo.TagHeader.VlanId != pVElan->VlanId))
        {
            Status = NDIS_STATUS_INVALID_PACKET;
            break;
        }
                
        //
        // Find the virtual address after the Ethernet Header
        //
        BytesToSkip = ETH_HEADER_SIZE;
        pNdisBuffer = Packet->Private.Head;
        IsFirstVa = TRUE;
            
        //
        // Assume the Ethernet Header is in the first buffer of the packet.
        // The following loop is to find the start address of the data after
        // the ethernet header. This may be either in the first NDIS buffer
        // or in the second.
        // 
        while (TRUE)
        {
#ifdef NDIS51_MINIPORT
            NdisQueryBufferSafe(pNdisBuffer, &pVa, (PUINT)&BufferLength, NormalPagePriority);
#else
            NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
            //
            // The query can fail if the system is low on resources.
            // 
            if (pVa == NULL)
            {
                break;
            }

            //
            // Remember the start of the ethernet header for later.
            // 
            if (IsFirstVa)
            {
                pStartVa = pVa;
                IsFirstVa = FALSE;
            }

            //
            // Have we gone far enough into the packet?
            // 
            if (BytesToSkip == 0)
            {
                break;
            }

            //
            // Does the current buffer contain bytes past the Ethernet
            // header? If so, stop.
            // 
            if (BufferLength > BytesToSkip)
            {
                pVa = (PVOID)((PUCHAR)pVa + BytesToSkip);
                BufferLength -= BytesToSkip;
                break;
            }

            //
            // We haven't gone past the Ethernet header yet, so go
            // to the next buffer.
            //
            BytesToSkip -= BufferLength;
            pNdisBuffer = NDIS_BUFFER_LINKAGE(pNdisBuffer);
        }

        if (pVa == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Allocate space for the Ethernet + VLAN tag header.
        // 
        pEthTagBuffer = NdisAllocateFromNPagedLookasideList(&pVElan->TagLookaside);
            
        //
        // Memory allocation failed, can't send out the packet
        // 
        if (pEthTagBuffer == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Allocate NDIS buffers for the Ethernet + VLAN tag header and
        // the data that follows these.
        //
        NdisAllocateBuffer(&Status,
                            &pSecondBuffer,
                            pVElan->BufferPoolHandle,
                            pVa,    // byte following the Eth+tag headers
                            BufferLength);
        
        NdisAllocateBuffer(&Status2,
                            &pFirstBuffer,
                            pVElan->BufferPoolHandle,
                            pEthTagBuffer,
                            ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE);

        if (Status != NDIS_STATUS_SUCCESS || Status2 != NDIS_STATUS_SUCCESS)
        {
            //
            // One of the buffer allocations failed.
            //
            if (Status == NDIS_STATUS_SUCCESS)
            {
                NdisFreeBuffer(pSecondBuffer);
            }   
        
            if (Status2 == NDIS_STATUS_SUCCESS)
            {
                NdisFreeBuffer(pFirstBuffer);
            }

            NdisFreeToNPagedLookasideList(&pVElan->TagLookaside, pEthTagBuffer);
        
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // All allocations were successful, now prepare the packet
        // to be sent down to the lower driver.
        //
        MyPacket->Private.Head = NDIS_BUFFER_LINKAGE(pNdisBuffer);
        NdisChainBufferAtFront(MyPacket, pSecondBuffer)
        NdisChainBufferAtFront(MyPacket, pFirstBuffer)
        
        //
        // Prepare the Ethernet and tag headers.
        //
        NdisMoveMemory(pEthTagBuffer, pStartVa, 2 * ETH_LENGTH_OF_ADDRESS);
        pTpid = (PUSHORT)((PUCHAR)pEthTagBuffer + 2 * ETH_LENGTH_OF_ADDRESS);
        *pTpid = TPID;
        pTagHeader = (PVLAN_TAG_HEADER)(pTpid + 1);
    
        //
        // Write Ieee 802Q info to packet frame
        // 
        INITIALIZE_TAG_HEADER_TO_ZERO(pTagHeader);
        if (NdisPacket8021qInfo.Value)
        {
            SET_USER_PRIORITY_TO_TAG(pTagHeader, NdisPacket8021qInfo.TagHeader.UserPriority);
        }
        else
        {
            SET_USER_PRIORITY_TO_TAG(pTagHeader, 0);
        }

        SET_CANONICAL_FORMAT_ID_TO_TAG (pTagHeader, 0);
            
        if (NdisPacket8021qInfo.TagHeader.VlanId)
        {
            SET_VLAN_ID_TO_TAG (pTagHeader, NdisPacket8021qInfo.TagHeader.VlanId);
        }
        else
        {
            SET_VLAN_ID_TO_TAG (pTagHeader, pVElan->VlanId);
        }   

        pTypeLength = (PUSHORT)((PUCHAR)pTagHeader + sizeof(pTagHeader->TagInfo));
        *pTypeLength = *((PUSHORT)((PUCHAR)pStartVa + 2 * ETH_LENGTH_OF_ADDRESS));

        //
        // Clear the Ieee8021QInfo field in packet being sent down
        // to prevent double tag insertion!
        // 
        NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 0;
      
    }
    while (FALSE);
    
    return Status;
}
    
#endif // IEEE_VLAN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\mux.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation
 
Module Name:
 
    mux.c

Abstract:

    DriverEntry and NT dispatch functions for the NDIS MUX Intermediate
    Miniport driver sample.

Environment:

    Kernel mode

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define MODULE_NUMBER           MODULE_MUX

#pragma NDIS_INIT_FUNCTION(DriverEntry)


#if DBG
//
// Debug level for mux driver
// 
INT     muxDebugLevel = MUX_WARN;

#endif //DBG
//
//  G L O B A L   V A R I A B L E S
//  -----------   -----------------
//

NDIS_MEDIUM        MediumArray[1] =
                    {
                        NdisMedium802_3,    // Ethernet
                    };


//
// Global Mutex protects the AdapterList;
// see macros MUX_ACQUIRE/RELEASE_MUTEX
//
MUX_MUTEX          GlobalMutex = {0};

//
// List of all bound adapters.
//
LIST_ENTRY         AdapterList;

//
// Total number of VELAN miniports in existance:
//
LONG               MiniportCount = 0;

//
// Used to assign VELAN numbers (which are used to generate MAC
// addresses).
//
ULONG              NextVElanNumber = 0; // monotonically increasing count

//
// Some global NDIS handles:
//
NDIS_HANDLE        NdisWrapperHandle = NULL;// From NdisMInitializeWrapper
NDIS_HANDLE        ProtHandle = NULL;       // From NdisRegisterProtocol
NDIS_HANDLE        DriverHandle = NULL;     // From NdisIMRegisterLayeredMiniport
NDIS_HANDLE        NdisDeviceHandle = NULL; // From NdisMRegisterDevice

PDEVICE_OBJECT     ControlDeviceObject = NULL;  // Device for IOCTLs
MUX_MUTEX          ControlDeviceMutex;



NTSTATUS
DriverEntry(
    IN    PDRIVER_OBJECT        DriverObject,
    IN    PUNICODE_STRING       RegistryPath
    )
/*++

Routine Description:

    First entry point to be called, when this driver is loaded.
    Register with NDIS as an intermediate driver.

Arguments:

    DriverObject - pointer to the system's driver object structure
        for this driver
    
    RegistryPath - system's registry path for this driver
    
Return Value:

    STATUS_SUCCESS if all initialization is successful, STATUS_XXX
    error code if not.

--*/
{
    NDIS_STATUS                     Status;
    NDIS_PROTOCOL_CHARACTERISTICS   PChars;
    NDIS_MINIPORT_CHARACTERISTICS   MChars;
    NDIS_STRING                     Name;

    NdisInitializeListHead(&AdapterList);
    MUX_INIT_MUTEX(&GlobalMutex);
    MUX_INIT_MUTEX(&ControlDeviceMutex);

    NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, NULL);

    do
    {
        //
        // Register the miniport with NDIS. Note that it is the
        // miniport which was started as a driver and not the protocol.
        // Also the miniport must be registered prior to the protocol
        // since the protocol's BindAdapter handler can be initiated
        // anytime and when it is, it must be ready to
        // start driver instances.
        //
        NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

        MChars.MajorNdisVersion = MUX_MAJOR_NDIS_VERSION;
        MChars.MinorNdisVersion = MUX_MINOR_NDIS_VERSION;

        MChars.InitializeHandler = MPInitialize;
        MChars.QueryInformationHandler = MPQueryInformation;
        MChars.SetInformationHandler = MPSetInformation;
        MChars.TransferDataHandler = MPTransferData;
        MChars.HaltHandler = MPHalt;
#ifdef NDIS51_MINIPORT
        MChars.CancelSendPacketsHandler = MPCancelSendPackets;
        MChars.PnPEventNotifyHandler = MPDevicePnPEvent;
        MChars.AdapterShutdownHandler = MPAdapterShutdown;
#endif // NDIS51_MINIPORT

        //
        // We will disable the check for hang timeout so we do not
        // need a check for hang handler!
        //
        MChars.CheckForHangHandler = NULL;
        MChars.ReturnPacketHandler = MPReturnPacket;

        //
        // Either the Send or the SendPackets handler should be specified.
        // If SendPackets handler is specified, SendHandler is ignored
        //
        MChars.SendHandler = NULL;   
        MChars.SendPacketsHandler = MPSendPackets;

        Status = NdisIMRegisterLayeredMiniport(NdisWrapperHandle,
                                               &MChars,
                                               sizeof(MChars),
                                               &DriverHandle);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisMRegisterUnloadHandler(NdisWrapperHandle, MPUnload);

        //
        // Now register the protocol.
        //
        NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
        PChars.MajorNdisVersion = MUX_PROT_MAJOR_NDIS_VERSION;
        PChars.MinorNdisVersion = MUX_PROT_MINOR_NDIS_VERSION;

        //
        // Make sure the protocol-name matches the service-name
        // (from the INF) under which this protocol is installed.
        // This is needed to ensure that NDIS can correctly determine
        // the binding and call us to bind to miniports below.
        //
        NdisInitUnicodeString(&Name, L"MUXP");    // Protocol name
        PChars.Name = Name;
        PChars.OpenAdapterCompleteHandler = PtOpenAdapterComplete;
        PChars.CloseAdapterCompleteHandler = PtCloseAdapterComplete;
        PChars.SendCompleteHandler = PtSendComplete;
        PChars.TransferDataCompleteHandler = PtTransferDataComplete;
        
        PChars.ResetCompleteHandler = PtResetComplete;
        PChars.RequestCompleteHandler = PtRequestComplete;
        PChars.ReceiveHandler = PtReceive;
        PChars.ReceiveCompleteHandler = PtReceiveComplete;
        PChars.StatusHandler = PtStatus;
        PChars.StatusCompleteHandler = PtStatusComplete;
        PChars.BindAdapterHandler = PtBindAdapter;
        PChars.UnbindAdapterHandler = PtUnbindAdapter;
        PChars.UnloadHandler = NULL;
        PChars.ReceivePacketHandler = PtReceivePacket;
        PChars.PnPEventHandler= PtPNPHandler;

        NdisRegisterProtocol(&Status,
                             &ProtHandle,
                             &PChars,
                             sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NdisIMDeregisterLayeredMiniport(DriverHandle);
            break;
        }

        //
        // Let NDIS know of the association between our protocol
        // and miniport entities.
        //
        NdisIMAssociateMiniport(DriverHandle, ProtHandle);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }

    return(Status);
}


NDIS_STATUS
PtRegisterDevice(
    VOID
    )
/*++

Routine Description:

    Register an ioctl interface - a device object to be used for this
    purpose is created by NDIS when we call NdisMRegisterDevice.

    This routine is called whenever a new miniport instance is
    initialized. However, we only create one global device object,
    when the first miniport instance is initialized. This routine
    handles potential race conditions with PtDeregisterDevice via
    the ControlDeviceMutex.

    NOTE: do not call this from DriverEntry; it will prevent the driver
    from being unloaded (e.g. on uninstall).

Arguments:

    None

Return Value:

    NDIS_STATUS_SUCCESS if we successfully register a device object.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      DeviceLinkUnicodeString;
    PDRIVER_DISPATCH    DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];

    DBGPRINT(MUX_LOUD, ("==>PtRegisterDevice\n"));

    MUX_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ++MiniportCount;
    
    if (1 == MiniportCount)
    {
        NdisZeroMemory(DispatchTable, (IRP_MJ_MAXIMUM_FUNCTION+1) * sizeof(PDRIVER_DISPATCH));
        
        DispatchTable[IRP_MJ_CREATE] = PtDispatch;
        DispatchTable[IRP_MJ_CLEANUP] = PtDispatch;
        DispatchTable[IRP_MJ_CLOSE] = PtDispatch;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = PtDispatch;
        

        NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);

        //
        // Create a device object and register our dispatch handlers
        //
        Status = NdisMRegisterDevice(
                    NdisWrapperHandle, 
                    &DeviceName,
                    &DeviceLinkUnicodeString,
                    &DispatchTable[0],
                    &ControlDeviceObject,
                    &NdisDeviceHandle
                    );
    }

    MUX_RELEASE_MUTEX(&ControlDeviceMutex);

    DBGPRINT(MUX_INFO, ("<==PtRegisterDevice: %x\n", Status));

    return (Status);
}


NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp
    )
/*++
Routine Description:

    Process IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    NTSTATUS - STATUS_SUCCESS always - change this when adding
    real code to handle ioctls.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               inlen;
    PVOID               buffer;

	DeviceObject;
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    DBGPRINT(MUX_LOUD, ("==>PtDispatch %d\n", irpStack->MajorFunction));
      
    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            break;
        
        case IRP_MJ_CLEANUP:
            break;
        
        case IRP_MJ_CLOSE:
            break;        
        
        case IRP_MJ_DEVICE_CONTROL: 
        {

          buffer = Irp->AssociatedIrp.SystemBuffer;  
          inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
          
          switch (irpStack->Parameters.DeviceIoControl.IoControlCode) 
          {
            //
            // Add code here to handle ioctl commands.
            //
          }
          break;  
        }
        default:
            break;
    }
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(MUX_LOUD, ("<== Pt Dispatch\n"));

    return status;

} 


NDIS_STATUS
PtDeregisterDevice(
    VOID
    )
/*++

Routine Description:

    Deregister the ioctl interface. This is called whenever a miniport
    instance is halted. When the last miniport instance is halted, we
    request NDIS to delete the device object

Arguments:

    NdisDeviceHandle - Handle returned by NdisMRegisterDevice

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(MUX_LOUD, ("==>PassthruDeregisterDevice\n"));

    MUX_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ASSERT(MiniportCount > 0);

    --MiniportCount;
    
    if (0 == MiniportCount)
    {
        //
        // All VELAN miniport instances have been halted.
        // Deregister the control device.
        //

        if (NdisDeviceHandle != NULL)
        {
            Status = NdisMDeregisterDevice(NdisDeviceHandle);
            NdisDeviceHandle = NULL;
        }
    }

    MUX_RELEASE_MUTEX(&ControlDeviceMutex);

    DBGPRINT(MUX_INFO, ("<== PassthruDeregisterDevice: %x\n", Status));
    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\precomp.h ===
#pragma warning(disable:4214)   // bit field types other than int

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4244)   // conversion from 'int' to 'BOOLEAN', possible loss of data


#include <ndis.h>
#include "mux.h"
#include "public.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\protocol.c ===
/*++

Copyright(c) 1992-2000  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    NDIS Protocol Entry points and utility functions for the NDIS
    MUX Intermediate Miniport sample.

    The protocol edge binds to Ethernet (NdisMedium802_3) adapters,
    and initiates creation of zero or more Virtual Ethernet LAN (VELAN)
    miniport instances by calling NdisIMInitializeDeviceInstanceEx once
    for each VELAN configured over a lower binding.

Environment:

    Kernel mode.

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define MODULE_NUMBER           MODULE_PROT

VOID
PtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
/*++

Routine Description:

    Called by NDIS to bind to a miniport below. This routine
    creates a binding by calling NdisOpenAdapter, and then
    initiates creation of all configured VELANs on this binding.

Arguments:

    Status            - Return status of bind here.
    BindContext       - Can be passed to NdisCompleteBindAdapter if this 
                        call is pended.
    DeviceName        - Device name to bind to. This is passed to 
                        NdisOpenAdapter.
    SystemSpecific1   - Can be passed to NdisOpenProtocolConfiguration to
                            read per-binding information
    SystemSpecific2   - Unused


Return Value:

    *Status is set to NDIS_STATUS_SUCCESS if no failure occurred
    while handling this call, otherwise an error code.

--*/
{
    PADAPT                            pAdapt = NULL;
    NDIS_STATUS                       OpenErrorStatus;
    UINT                              MediumIndex;
    PNDIS_STRING                      pConfigString;
    ULONG                             Length;

	UNREFERENCED_PARAMETER(BindContext);
	UNREFERENCED_PARAMETER(SystemSpecific2);
	
    pConfigString = (PNDIS_STRING)SystemSpecific1;
    
    DBGPRINT(MUX_LOUD, ("==> Protocol BindAdapter: %ws\n", pConfigString->Buffer));
   
    do
    {

        //
        // Allocate memory for Adapter struct plus the config
        // string with two extra WCHARs for NULL termination.
        //
        Length = sizeof(ADAPT) + 
                    pConfigString->MaximumLength + sizeof(WCHAR);
        
        NdisAllocateMemoryWithTag(&pAdapt, Length , TAG);

        if (pAdapt == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
             break;
        }
        
        //
        // Initialize the adapter structure
        //
        NdisZeroMemory(pAdapt, sizeof(ADAPT));        

        (VOID)PtReferenceAdapter(pAdapt, (PUCHAR)"openadapter");        
        

        //
        //  Copy in the Config string - we will use this to open the
        //  registry section for this adapter at a later point.
        //
        pAdapt->ConfigString.MaximumLength = pConfigString->MaximumLength;
        pAdapt->ConfigString.Length = pConfigString->Length;
        pAdapt->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapt + 
                            sizeof(ADAPT));

        NdisMoveMemory(pAdapt->ConfigString.Buffer,
                       pConfigString->Buffer,
                       pConfigString->Length);
        pAdapt->ConfigString.Buffer[pConfigString->Length/sizeof(WCHAR)] = 
                                    ((WCHAR)0);

        NdisInitializeEvent(&pAdapt->Event);
        NdisInitializeListHead(&pAdapt->VElanList);

        pAdapt->PtDevicePowerState = NdisDeviceStateD0;

        MUX_INIT_ADAPT_RW_LOCK(pAdapt);

        //
        // TODO: Allocate a packet pool and buffers for send & receive.
        //
        // Now open the adapter below and complete the initialization
        //
        NdisOpenAdapter(Status,
                          &OpenErrorStatus,
                          &pAdapt->BindingHandle,
                          &MediumIndex,
                          MediumArray,
                          sizeof(MediumArray)/sizeof(NDIS_MEDIUM),
                          ProtHandle,
                          pAdapt,
                          DeviceName,
                          0,
                          NULL);

        if (*Status == NDIS_STATUS_PENDING)
        {
              NdisWaitEvent(&pAdapt->Event, 0);
              *Status = pAdapt->Status;
        }

        if (*Status != NDIS_STATUS_SUCCESS)
        {
              pAdapt->BindingHandle = NULL;
              break;
        }
       
        pAdapt->Medium = MediumArray[MediumIndex];

        //
        // Add this adapter to the global AdapterList
        //
        MUX_ACQUIRE_MUTEX(&GlobalMutex);

        InsertTailList(&AdapterList, &pAdapt->Link);

        MUX_RELEASE_MUTEX(&GlobalMutex);

        //
        // Get some information from the adapter below.
        //
        PtQueryAdapterInfo(pAdapt);

        //
        // Start all VELANS configured on this adapter.
        //
        *Status = PtBootStrapVElans(pAdapt);        
       
    } while(FALSE);

    if (*Status != NDIS_STATUS_SUCCESS)
    {
        
        if (pAdapt != NULL)
        {
            //
            // For some reason, the driver cannot create velan for the binding
            //
            if (pAdapt->BindingHandle != NULL)
            {
                NDIS_STATUS LocalStatus;
                //
                // Close the binding the driver opened above
                // 
                NdisResetEvent(&pAdapt->Event);
                NdisCloseAdapter(&LocalStatus, pAdapt->BindingHandle);
                pAdapt->BindingHandle = NULL;
                if (LocalStatus == NDIS_STATUS_PENDING)
                {
                    NdisWaitEvent(&pAdapt->Event, 0);
                }
                MUX_ACQUIRE_MUTEX(&GlobalMutex);

                RemoveEntryList(&pAdapt->Link);

                MUX_RELEASE_MUTEX(&GlobalMutex);
            }
            PtDereferenceAdapter(pAdapt, (PUCHAR)"openadapter");
            pAdapt = NULL;
        }
    }


    DBGPRINT(MUX_INFO, ("<== Protocol BindAdapter: pAdapt %p, Status %x\n", pAdapt, *Status));
}


VOID
PtOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    )
/*++

Routine Description:

    Completion routine for NdisOpenAdapter issued from within the 
    PtBindAdapter. Simply unblock the caller.

Arguments:

    ProtocolBindingContext    Pointer to the adapter
    Status                    Status of the NdisOpenAdapter call
    OpenErrorStatus            Secondary status(ignored by us).

Return Value:

    None

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

	UNREFERENCED_PARAMETER(OpenErrorStatus);
	
    DBGPRINT(MUX_LOUD, ("==> PtOpenAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtQueryAdapterInfo(
    IN  PADAPT                  pAdapt
    )
/*++

Routine Description:

    Query the adapter we are bound to for some standard OID values
    which we cache.

Arguments:

    pAdapt              Pointer to the adapter


Return Value:

    None
--*/
{
    
    //
    // Get the link speed.
    //
    pAdapt->LinkSpeed = MUX_DEFAULT_LINK_SPEED;
    PtQueryAdapterSync(pAdapt,
                       OID_GEN_LINK_SPEED,
                       &pAdapt->LinkSpeed,
                       sizeof(pAdapt->LinkSpeed));

    //
    // Get the max lookahead size.
    //
    pAdapt->MaxLookAhead = MUX_DEFAULT_LOOKAHEAD_SIZE;
    PtQueryAdapterSync(pAdapt,
                       OID_GEN_MAXIMUM_LOOKAHEAD,
                       &pAdapt->MaxLookAhead,
                       sizeof(pAdapt->MaxLookAhead));

    //
    // Get the Ethernet MAC address.
    //
    PtQueryAdapterSync(pAdapt,
                       OID_802_3_CURRENT_ADDRESS,
                       &pAdapt->CurrentAddress,
                       sizeof(pAdapt->CurrentAddress));
}


VOID
PtQueryAdapterSync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength
    )
/*++

Routine Description:

    Utility routine to query the adapter for a single OID value. This
    blocks for the query to complete.

Arguments:

    pAdapt                      Pointer to the adapter
    Oid                         OID to query for
    InformationBuffer           Place for the result
    InformationBufferLength     Length of the above

Return Value:

    None.

--*/
{
    PMUX_NDIS_REQUEST       pMuxNdisRequest = NULL;
    NDIS_STATUS             Status;

    do
    {
        NdisAllocateMemoryWithTag(&pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), TAG);
        if (pMuxNdisRequest == NULL)
        {
            break;
        }

        pMuxNdisRequest->pVElan = NULL; // internal request

        //
        // Set up completion routine.
        //
        pMuxNdisRequest->pCallback = PtCompleteBlockingRequest;
        NdisInitializeEvent(&pMuxNdisRequest->Event);

        pMuxNdisRequest->Request.RequestType = NdisRequestQueryInformation;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid = Oid;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBuffer =
                            InformationBuffer;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBufferLength =
                                                InformationBufferLength;

        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    &pMuxNdisRequest->Request);
        
        if (Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&pMuxNdisRequest->Event, 0);
            Status = pMuxNdisRequest->Status;
        }
    }
    while (FALSE);

    if (NULL != pMuxNdisRequest)
    {
        NdisFreeMemory(pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), 0);
    }
}



VOID
PtRequestAdapterAsync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength,
    IN  PMUX_REQ_COMPLETE_HANDLER   pCallback
    )
/*++

Routine Description:

    Utility routine to query the adapter for a single OID value.
    This completes asynchronously, i.e. the calling thread is
    not blocked until the request completes.

Arguments:

    pAdapt                      Pointer to the adapter
    RequestType                 NDIS request type
    Oid                         OID to set/query
    InformationBuffer           Input/output buffer
    InformationBufferLength     Length of the above
    pCallback                   Function to call on request completion

Return Value:

    None.

--*/
{
    PMUX_NDIS_REQUEST       pMuxNdisRequest = NULL;
    PNDIS_REQUEST           pNdisRequest;
    NDIS_STATUS             Status;

    do
    {
        NdisAllocateMemoryWithTag(&pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), TAG);
        if (pMuxNdisRequest == NULL)
        {
            break;
        }

        pMuxNdisRequest->pVElan = NULL; // internal request

        //
        // Set up completion routine.
        //
        pMuxNdisRequest->pCallback = pCallback;

        pNdisRequest = &pMuxNdisRequest->Request;

        pNdisRequest->RequestType = RequestType;

        switch (RequestType)
        {
            case NdisRequestQueryInformation:
                pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                                    InformationBuffer;
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
        
                break;

            case NdisRequestSetInformation:
                pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
                pNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
                                    InformationBuffer;
                pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
        
                break;
            
            default:
                ASSERT(FALSE);
                break;
        }

        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    pNdisRequest);
        
        if (Status != NDIS_STATUS_PENDING)
        {
            PtRequestComplete(
                (NDIS_HANDLE)pAdapt,
                pNdisRequest,
                Status);
        }
    }
    while (FALSE);
}

            
VOID
PtUnbindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    )
/*++

Routine Description:

    Called by NDIS when we are required to unbind to the adapter below.
    Go through all VELANs on the adapter and shut them down.

Arguments:

    Status                    Placeholder for return status
    ProtocolBindingContext    Pointer to the adapter structure
    UnbindContext             Context for NdisUnbindComplete() if this pends

Return Value:

    Status from closing the binding.

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan = NULL;
    LOCK_STATE      LockState;

	UNREFERENCED_PARAMETER(UnbindContext);
	
    DBGPRINT(MUX_LOUD, ("==> PtUnbindAdapter: Adapt %p\n", pAdapt));

    //
    // Stop all VELANs associated with the adapter.
    // Repeatedly find the first unprocessed VELAN on
    // the adapter, mark it, and stop it.
    //
    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    do
    {
        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);
            if (!pVElan->DeInitializing)
            {
                pVElan->DeInitializing = TRUE;
                break;
            }
        }

        if (p != &pAdapt->VElanList)
        {
            ASSERT(pVElan == CONTAINING_RECORD(p, VELAN, Link));

            //
            // Got a VELAN to stop. Add a temp ref
            // so that the VELAN won't go away when
            // we release the ADAPT lock below.
            //
            PtReferenceVElan(pVElan, (PUCHAR)"UnbindTemp");

            //
            // Release the read lock because we want to
            // run StopVElan at passive IRQL.
            //
            MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    
            PtStopVElan(pVElan);
    
            PtDereferenceVElan(pVElan, (PUCHAR)"UnbindTemp");

            MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);
        }
        else
        {
            //
            // No unmarked VELAN, so exit.
            //
            break;
        }
    }
    while (TRUE);

    //
    // Wait until all VELANs are unlinked from the adapter.
    // This is so that we don't attempt to forward down packets
    // and/or requests from VELANs after calling NdisCloseAdapter.
    //
    while (!IsListEmpty(&pAdapt->VElanList))
    {
        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

        DBGPRINT(MUX_INFO, ("PtUnbindAdapter: pAdapt %p, VELANlist not yet empty\n",
                    pAdapt));

        NdisMSleep(2000);

        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

    //
    // Close the binding to the lower adapter.
    //
    if (pAdapt->BindingHandle != NULL)
    {
        NdisResetEvent(&pAdapt->Event);

        NdisCloseAdapter(Status, pAdapt->BindingHandle);

        //
        // Wait for it to complete.
        //
        if (*Status == NDIS_STATUS_PENDING)
        {
             NdisWaitEvent(&pAdapt->Event, 0);
             *Status = pAdapt->Status;
        }
    }
    else
    {
        //
        // Binding Handle should not be NULL.
        //
        *Status = NDIS_STATUS_FAILURE;
        ASSERT(0);
    }

    //
    // Remove the adapter from the global AdapterList
    //
    
    MUX_ACQUIRE_MUTEX(&GlobalMutex);

    RemoveEntryList(&pAdapt->Link);

    MUX_RELEASE_MUTEX(&GlobalMutex);

    //
    // Free all the resources associated with this Adapter except the
    // ADAPT struct itself, because that will be freed by 
    // PtDereferenceAdapter call when the reference drops to zero. 
    // Note: Every VELAN associated with this Adapter takes a ref count
    // on it. So the adapter memory wouldn't be freed until all the VELANs
    // are shutdown. 
    //
    
    PtDereferenceAdapter(pAdapt, (PUCHAR)"Unbind");
    DBGPRINT(MUX_INFO, ("<== PtUnbindAdapter: Adapt %p\n", pAdapt));
}



VOID
PtCloseAdapterComplete(
    IN    NDIS_HANDLE            ProtocolBindingContext,
    IN    NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the CloseAdapter call.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

    DBGPRINT(MUX_INFO, ("==> PtCloseAdapterComplete: Adapt %p, Status %x\n", 
                                pAdapt, Status));

    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtResetComplete(
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the reset.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{

#if DBG    
    PADAPT    pAdapt =(PADAPT)ProtocolBindingContext;
#endif

#if !DBG
    UNREFERENCED_PARAMETER(ProtocolBindingContext);
    UNREFERENCED_PARAMETER(Status);
#endif

    DBGPRINT(MUX_ERROR, ("==> PtResetComplete: Adapt %p, Status %x\n", 
                                pAdapt, Status));

    //
    // We never issue a reset, so we should not be here.
    //
    ASSERT(0);
}


VOID
PtRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               NdisRequest,
    IN  NDIS_STATUS                 Status
    )
/*++

Routine Description:

    Completion handler for an NDIS request sent to a lower
    miniport.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    NdisRequest               The completed request
    Status                    Completion status

Return Value:

    None

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext;
    PMUX_NDIS_REQUEST   pMuxNdisRequest;

    pMuxNdisRequest = CONTAINING_RECORD(NdisRequest, MUX_NDIS_REQUEST, Request);

    ASSERT(pMuxNdisRequest->pCallback != NULL);

    //
    // Completion is handled by the callback routine:
    //
    (*pMuxNdisRequest->pCallback)(pAdapt, 
                                  pMuxNdisRequest,
                                  Status);

}


VOID
PtCompleteForwardedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originally
    submitted to our VELAN miniport and was forwarded down
    to the lower binding.

    We do some postprocessing, to cache the results of
    certain queries.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
    PVELAN              pVElan = NULL;
    PNDIS_REQUEST       pNdisRequest = &pMuxNdisRequest->Request;
    NDIS_OID            Oid = pNdisRequest->DATA.SET_INFORMATION.Oid;

    UNREFERENCED_PARAMETER(pAdapt);
    
    //
    // Get the originating VELAN. The VELAN will not be dereferenced
    // away until the pended request is completed.
    //
    pVElan = pMuxNdisRequest->pVElan;

    ASSERT(pVElan != NULL);
    ASSERT(pMuxNdisRequest == &pVElan->Request);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(MUX_WARN, ("PtCompleteForwardedReq: pVElan %p, OID %x, Status %x\n", 
                    pVElan,
                    pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid,
                    Status));
    }

    //
    // Complete the original request.
    //
    switch (pNdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:

            *pVElan->BytesReadOrWritten = 
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
            *pVElan->BytesNeeded = 
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

            //
            // Before completing the request, do any necessary
            // post-processing.
            //
            Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;
            if (Status == NDIS_STATUS_SUCCESS)
            {
                if (Oid == OID_GEN_LINK_SPEED)
                {
                    NdisMoveMemory (&pVElan->LinkSpeed,
                                    pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                    sizeof(ULONG));
                }
                else if (Oid == OID_PNP_CAPABILITIES)
                {
                    PtPostProcessPnPCapabilities(pVElan,
                                                 pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                                 pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength);
                }
            }

            NdisMQueryInformationComplete(pVElan->MiniportAdapterHandle, Status);

            break;

        case NdisRequestSetInformation:

            *pVElan->BytesReadOrWritten =
                    pNdisRequest->DATA.SET_INFORMATION.BytesRead;
            *pVElan->BytesNeeded =
                    pNdisRequest->DATA.SET_INFORMATION.BytesNeeded;

            //
            // Before completing the request, cache relevant information
            // in our structure.
            //
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Oid = pNdisRequest->DATA.SET_INFORMATION.Oid;
                switch (Oid)
                {
                    case OID_GEN_CURRENT_LOOKAHEAD:
                        NdisMoveMemory(&pVElan->LookAhead,
                                 pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                 sizeof(ULONG));
                        break;

                    default:
                        break;
                }
            }

            NdisMSetInformationComplete(pVElan->MiniportAdapterHandle, Status);

            break;

        default:
            ASSERT(FALSE);
            break;
    }

    MUX_DECR_PENDING_SENDS(pVElan);

}



VOID
PtPostProcessPnPCapabilities(
    IN PVELAN                   pVElan,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength
    )
/*++

Routine Description:

    Postprocess a successfully completed query for OID_PNP_CAPABILITIES.
    We modify the returned information slightly before completing
    it to the VELAN above.

Arguments:

    pVElan - Pointer to VELAN
    InformationBuffer - points to buffer for the OID
    InformationBufferLength - byte length of the above.

Return Value:

    None

--*/
{
    PNDIS_PNP_CAPABILITIES          pPNPCapabilities;
    PNDIS_PM_WAKE_UP_CAPABILITIES   pPMstruct;

	UNREFERENCED_PARAMETER(pVElan);
	
    if (InformationBufferLength >= sizeof(NDIS_PNP_CAPABILITIES))
    {
        pPNPCapabilities = (PNDIS_PNP_CAPABILITIES)InformationBuffer;

        //
        // The following fields must be overwritten by an IM driver.
        //
        pPMstruct= &pPNPCapabilities->WakeUpCapabilities;
        pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
    }
}

VOID
PtCompleteBlockingRequest(
    IN PADAPT                   pAdapt,
    IN PMUX_NDIS_REQUEST        pMuxNdisRequest,
    IN NDIS_STATUS              Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originated
    by this driver and the calling thread is blocked waiting
    for completion.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
	UNREFERENCED_PARAMETER(pAdapt);
	
    pMuxNdisRequest->Status = Status;

    //
    // The request was originated from this driver. Wake up the
    // thread blocked for its completion.
    //
    pMuxNdisRequest->Status = Status;
    NdisSetEvent(&pMuxNdisRequest->Event);
}


VOID
PtDiscardCompletedRequest(
    IN PADAPT                   pAdapt,
    IN PMUX_NDIS_REQUEST        pMuxNdisRequest,
    IN NDIS_STATUS              Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originated
    by this driver - the request is to be discarded.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER(pAdapt);
    UNREFERENCED_PARAMETER(Status);

    NdisFreeMemory(pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), 0);
}


VOID
PtStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       StatusBuffer,
    IN  UINT                        StatusBufferSize
    )
/*++

Routine Description:

    Handle a status indication on the lower binding (ADAPT).
    If this is a media status indication, we also pass this
    on to all associated VELANs.

Arguments:

    ProtocolBindingContext      Pointer to the adapter structure
    GeneralStatus               Status code
    StatusBuffer                Status buffer
    StatusBufferSize            Size of the status buffer

Return Value:

    None

--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY p;
    PVELAN      pVElan;
    LOCK_STATE  LockState;

    DBGPRINT(MUX_LOUD, ("PtStatus: Adapt %p, Status %x\n", pAdapt, GeneralStatus));

    do
    {
        //
        // Ignore status indications that we aren't going
        // to pass up.
        //
        if ((GeneralStatus != NDIS_STATUS_MEDIA_CONNECT) &&
            (GeneralStatus != NDIS_STATUS_MEDIA_DISCONNECT))
        {
            break;
        }

        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            
            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            MUX_INCR_PENDING_RECEIVES(pVElan);

            //
            // Should the indication be sent on this VELAN?
            //
            if ((pVElan->MiniportHalting) ||
                (pVElan->MiniportAdapterHandle == NULL) ||   
                MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                if (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
                {
                    //
                    // Keep track of the lastest status to indicated when VELAN power is on
                    // 
                    ASSERT((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT));
                    pVElan->LatestUnIndicateStatus = GeneralStatus;
                }
                
                continue;
            }

            //
            // Save the last indicated status when 
            pVElan->LastIndicatedStatus = GeneralStatus;
            
            NdisMIndicateStatus(pVElan->MiniportAdapterHandle,
                                GeneralStatus,
                                StatusBuffer,
                                StatusBufferSize);
            
            //
            // Mark this so that we forward a status complete
            // indication as well.
            //
            pVElan->IndicateStatusComplete = TRUE;

            MUX_DECR_PENDING_RECEIVES(pVElan);
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

}


VOID
PtStatusComplete(
    IN    NDIS_HANDLE            ProtocolBindingContext
    )
/*++

Routine Description:

    Marks the end of a status indication. Pass it on to
    associated VELANs if necessary.

Arguments:

    ProtocolBindingContext - pointer to ADAPT

Return Value:

    None.

--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY p;
    PVELAN      pVElan;
    LOCK_STATE  LockState;

    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    for (p = pAdapt->VElanList.Flink;
         p != &pAdapt->VElanList;
         p = p->Flink)
    {
        

        pVElan = CONTAINING_RECORD(p, VELAN, Link);

        MUX_INCR_PENDING_RECEIVES(pVElan);

        //
        // Should this indication be sent on this VELAN?
        //
        if ((pVElan->MiniportHalting) ||
            (pVElan->MiniportAdapterHandle == NULL) ||
            (!pVElan->IndicateStatusComplete) ||
            (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
        {
            MUX_DECR_PENDING_RECEIVES(pVElan);
            continue;
        }

        pVElan->IndicateStatusComplete = FALSE;
        NdisMIndicateStatusComplete(pVElan->MiniportAdapterHandle);
        
        MUX_DECR_PENDING_RECEIVES(pVElan);
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

}


VOID
PtSendComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    Called by NDIS when the miniport below had completed a send.
    We complete the corresponding upper-edge send this represents.
    The packet being completed belongs to our send packet pool,
    however we store a pointer to the original packet this represents,
    in the packet's reserved field.

Arguments:

    ProtocolBindingContext - Points to ADAPT structure
    Packet - Packet being completed by the lower miniport
    Status - status of send

Return Value:

    None

--*/
{
    PVELAN              pVElan;
    PMUX_SEND_RSVD      pSendReserved;
    PNDIS_PACKET        OriginalPacket;
#if IEEE_VLAN_SUPPORT
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    BOOLEAN                     IsTagInsert;
    PNDIS_BUFFER                pNdisBuffer;
    PVOID                       pVa;
    ULONG                       BufferLength;
#endif

    UNREFERENCED_PARAMETER(ProtocolBindingContext);

    pSendReserved = MUX_RSVD_FROM_SEND_PACKET(Packet);
    OriginalPacket = pSendReserved->pOriginalPacket;
    pVElan = pSendReserved->pVElan;

#if IEEE_VLAN_SUPPORT
    //
    // Check if we had inserted a tag header
    //	    
    IsTagInsert = FALSE;
    NdisPacket8021qInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(    
                                        OriginalPacket,
                                        Ieee8021QInfo);
    if ((pVElan->VlanId != 0) || (NdisPacket8021qInfo.Value != NULL))
    {
        IsTagInsert = TRUE;
    }
#endif
    
    
#ifndef WIN9X
    NdisIMCopySendCompletePerPacketInfo(OriginalPacket, Packet);
#endif

    //
    // Update statistics.
    //
    if (Status == NDIS_STATUS_SUCCESS)
    {
        MUX_INCR_STATISTICS64(&pVElan->GoodTransmits);
    }
    else
    {
        MUX_INCR_STATISTICS(&pVElan->TransmitFailuresOther);
    }

    //
    // Complete the original send.
    //
    NdisMSendComplete(pVElan->MiniportAdapterHandle,
                      OriginalPacket,
                      Status);

#if IEEE_VLAN_SUPPORT
    //
    // If we had inserted a tag header, then remove the header
    // buffer and free it. We would also have created a new
    // NDIS buffer to map part of the original packet's header;
    // free that, too.
    //
    if (IsTagInsert)
    {

        pNdisBuffer = Packet->Private.Head;
#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe(pNdisBuffer, &pVa, (PUINT)&BufferLength, NormalPagePriority);
#else
        NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
        if (pVa != NULL)
        {
            NdisFreeToNPagedLookasideList(&pVElan->TagLookaside, pVa);
        }
        NdisFreeBuffer(NDIS_BUFFER_LINKAGE(pNdisBuffer));
        NdisFreeBuffer (pNdisBuffer);
    }
                
#endif

    //
    // Free our packet.
    //
    NdisFreePacket(Packet);

    //
    // Note down send-completion.
    //
    MUX_DECR_PENDING_SENDS(pVElan);
}       


VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    )
/*++

Routine Description:

    Entry point called by NDIS to indicate completion of a call by us
    to NdisTransferData. We locate the original packet and VELAN on
    which our TransferData function (see MPTransferData) was called,
    and complete the original request.

Arguments:

    ProtocolBindingContext - lower binding context, pointer to ADAPT
    Packet - Packet allocated by us
    Status - Completion status
    BytesTransferred - Number of bytes copied in

Return Value:

    None

--*/
{
    PVELAN          pVElan;
    PNDIS_PACKET    pOriginalPacket;
    PMUX_TD_RSVD    pTDReserved;

	UNREFERENCED_PARAMETER(ProtocolBindingContext);
	
    pTDReserved = MUX_RSVD_FROM_TD_PACKET(Packet);
    pOriginalPacket = pTDReserved->pOriginalPacket;
    pVElan = pTDReserved->pVElan;

    //
    // Complete the original TransferData request.
    //
    NdisMTransferDataComplete(pVElan->MiniportAdapterHandle,
                              pOriginalPacket,
                              Status,
                              BytesTransferred);

    //
    // Free our packet.
    //
    NdisFreePacket(Packet);
}


BOOLEAN
PtMulticastMatch(
    IN PVELAN                       pVElan,
    IN PUCHAR                       pDstMac
    )
/*++

Routine Description:

    Check if the given multicast destination MAC address matches
    any of the multicast address entries set on the VELAN.

    NOTE: the caller is assumed to hold a READ/WRITE lock
    to the parent ADAPT structure. This is so that the multicast
    list on the VELAN is invariant for the duration of this call.

Arguments:

    pVElan  - VELAN to look in
    pDstMac - Destination MAC address to compare

Return Value:

    TRUE iff the address matches an entry in the VELAN

--*/
{
    ULONG           i;
    UINT            AddrCompareResult;

    for (i = 0; i < pVElan->McastAddrCount; i++)
    {
        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pVElan->McastAddrs[i],
                                         pDstMac,
                                         &AddrCompareResult);
        
        if (AddrCompareResult == 0)
        {
            break;
        }
    }

    return (i != pVElan->McastAddrCount);
}


BOOLEAN
PtMatchPacketToVElan(
    IN PVELAN                       pVElan,
    IN PUCHAR                       pDstMac,
    IN BOOLEAN                      bIsMulticast,
    IN BOOLEAN                      bIsBroadcast
    )
/*++

Routine Description:

    Check if the destination address of a received packet
    matches the receive criteria on the specified VELAN.

    NOTE: the caller is assumed to hold a READ/WRITE lock
    to the parent ADAPT structure.

Arguments:

    pVElan  - VELAN to check on
    pDstMac - Destination MAC address in received packet
    bIsMulticast - is this a multicast address
    bIsBroadcast - is this a broadcast address

Return Value:

    TRUE iff this packet should be received on the VELAN

--*/
{
    UINT            AddrCompareResult;
    ULONG           PacketFilter;
    BOOLEAN         bPacketMatch;

    PacketFilter = pVElan->PacketFilter;

    //
    // Handle the directed packet case first.
    //
    if (!bIsMulticast)
    {
        //
        // If the VELAN is not in promisc. mode, check if
        // the destination MAC address matches the local
        // address.
        //
        if ((PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS) == 0)
        {
            ETH_COMPARE_NETWORK_ADDRESSES_EQ(pVElan->CurrentAddress,
                                             pDstMac,
                                             &AddrCompareResult);

            bPacketMatch = ((AddrCompareResult == 0) &&
                           ((PacketFilter & NDIS_PACKET_TYPE_DIRECTED) != 0));
        }
        else
        {
            bPacketMatch = TRUE;
        }
     }
     else
     {
        //
        // Multicast or broadcast packet.
        //

        //
        // Indicate if the filter is set to promisc mode ...
        //
        if ((PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)
                ||

            //
            // or if this is a broadcast packet and the filter
            // is set to receive all broadcast packets...
            //
            (bIsBroadcast &&
             (PacketFilter & NDIS_PACKET_TYPE_BROADCAST))
                ||

            //
            // or if this is a multicast packet, and the filter is
            // either set to receive all multicast packets, or
            // set to receive specific multicast packets. In the
            // latter case, indicate receive only if the destn
            // MAC address is present in the list of multicast
            // addresses set on the VELAN.
            //
            (!bIsBroadcast &&
             ((PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((PacketFilter & NDIS_PACKET_TYPE_MULTICAST) &&
               PtMulticastMatch(pVElan, pDstMac))))
           )
        {
            bPacketMatch = TRUE;
        }
        else
        {
            //
            // No protocols above are interested in this
            // multicast/broadcast packet.
            //
            bPacketMatch = FALSE;
        }
    }

    return (bPacketMatch);
}


NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookAheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    Handle receive data indicated up by the miniport below.

    We forward this up to all VELANs that are eligible to
    receive this packet:

    - If this is directed to a broadcast/multicast address,
      indicate up on all VELANs that have multicast or broadcast
      or promisc. bits set in their packet filters.

    - If this is a directed packet, indicate it up on all VELANs
      that have the a matching MAC address or have the promisc.
      bit set in their packet filters.

    We acquire a read lock on the ADAPT structure to ensure
    that the VELAN list on the adapter is undisturbed.

    If the miniport below indicates packets, NDIS would more
    likely call us at our ReceivePacket handler. However we
    might be called here in certain situations even though
    the miniport below has indicated a receive packet, e.g.
    if the miniport had set packet status to NDIS_STATUS_RESOURCES.
        
Arguments:

    <see DDK ref page for ProtocolReceive>

Return Value:

    NDIS_STATUS_SUCCESS if we processed the receive successfully,
    NDIS_STATUS_XXX error code if we discarded it.

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan;
    PNDIS_PACKET    MyPacket, Packet;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          pData;
    PUCHAR          pDstMac;
    BOOLEAN         bIsMulticast, bIsBroadcast;
    PMUX_RECV_RSVD  pRecvReserved;
    LOCK_STATE      LockState;
#if IEEE_VLAN_SUPPORT
    VLAN_TAG_HEADER UNALIGNED * pTagHeader;
    USHORT UNALIGNED *          pTpid;
    MUX_RCV_CONTEXT             MuxRcvContext;
#endif
    
    do
    {
        if (HeaderBufferSize != ETH_HEADER_SIZE)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        if (pAdapt->PacketFilter == 0)
        {
            //
            // We could get receives in the interval between
            // initiating a request to set the packet filter on
            // the binding to 0 and completion of that request.
            // Drop such packets.
            //
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        //
        // Collect some information from the packet.
        //
        pData = (PUCHAR)HeaderBuffer;
        pDstMac = pData;
        bIsMulticast = ETH_IS_MULTICAST(pDstMac);
        bIsBroadcast = ETH_IS_BROADCAST(pDstMac);

        //
        // Get at the packet, if any, indicated up by the miniport below.
        //
        Packet = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);

        //
        // Lock down the VELAN list on the adapter so that
        // no insertions/deletions to this list happen while
        // we loop through it. The packet filter will also not
        // change during the time we hold the read lock.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            BOOLEAN     bIndicateReceive;

            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            //
            // Should the packet be indicated up on this VELAN?
            //
            bIndicateReceive = PtMatchPacketToVElan(pVElan,
                                                    pDstMac,
                                                    bIsMulticast,
                                                    bIsBroadcast);
            if (!bIndicateReceive)
            {
                continue;
            }

            //
            // Make sure we don't Halt the VELAN miniport while
            // we are accessing it here. See MPHalt.
            //
            // Also don't indicate receives if the virtual miniport
            // has been set to a low power state. A specific case
            // is when the system is resuming from "Stand-by", if
            // the lower adapter is restored to D0 before the upper
            // miniports are.
            //
            //
            MUX_INCR_PENDING_RECEIVES(pVElan);

            if ((pVElan->MiniportHalting) ||
                (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                continue;
            }


            if (Packet != NULL)
            {
                //
                // The miniport below did indicate up a packet. Use information
                // from that packet to construct a new packet to indicate up.
                //

                //
                // Get a packet off our receive pool and indicate that up.
                //
                NdisDprAllocatePacket(&Status,
                                      &MyPacket,
                                      pVElan->RecvPacketPoolHandle);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    //
                    // Make our packet point to data from the original
                    // packet. NOTE: this works only because we are
                    // indicating a receive directly from the context of
                    // our receive indication. If we need to queue this
                    // packet and indicate it from another thread context,
                    // we will also have to allocate a new buffer and copy
                    // over the packet contents, OOB data and per-packet
                    // information. This is because the packet data
                    // is available only for the duration of this
                    // receive indication call.
                    //
                    MyPacket->Private.Head = Packet->Private.Head;
                    MyPacket->Private.Tail = Packet->Private.Tail;
#if IEEE_VLAN_SUPPORT
                    Status = PtHandleRcvTagging(pVElan, Packet, MyPacket);

                    if (Status != NDIS_STATUS_SUCCESS)
                    {
                        NdisFreePacket(MyPacket);
                        MUX_DECR_PENDING_RECEIVES(pVElan);
                        continue;
                    }
#endif               
                    
                    //
                    // Get the original packet (it could be the same packet
                    // as the one received or a different one based on the
                    // number of layered miniports below) and set it on the
                    // indicated packet so the OOB data is visible correctly
                    // at protocols above.
                    //
                    NDIS_SET_ORIGINAL_PACKET(MyPacket,
                                 NDIS_GET_ORIGINAL_PACKET(Packet));

                    NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);
    
                    //
                    // Copy packet flags.
                    //
                    NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

                    //
                    // Force protocols above to make a copy if they want to hang
                    // on to data in this packet. This is because we are in our
                    // Receive handler (not ReceivePacket), and the original
                    // packet can't be accessed after we return from here.
                    //
                    NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

                    //
                    // Set our context information in the packet. Since
                    // the original packet from the miniport below is not being
                    // queued up, set this to NULL:
                    //
                    pRecvReserved = MUX_RSVD_FROM_RECV_PACKET(MyPacket);
                    pRecvReserved->pOriginalPacket = NULL;
                    
                    MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
                    
                    //
                    // By setting NDIS_STATUS_RESOURCES, we also know that
                    // we can reclaim this packet as soon as the call to
                    // NdisMIndicateReceivePacket returns.
                    //
                                        
                    NdisMIndicateReceivePacket(pVElan->MiniportAdapterHandle,
                                               &MyPacket,
                                               1);

                    //
                    // Reclaim the indicated packet. Since we had set its status
                    // to NDIS_STATUS_RESOURCES, we are guaranteed that protocols
                    // above are done with it. Our ReturnPacket handler will
                    // not be called for this packet, so call it ourselves.
                    //
                    MPReturnPacket((NDIS_HANDLE)pVElan, MyPacket);

                    //
                    // Done with this VELAN.
                    //
                    continue;
                }

                //
                // else...
                //
                // Failed to allocate a packet to indicate up - fall through.
                // We will still indicate up using the non-packet API, but
                // other per-packet/OOB information won't be available
                // to protocols above.
                //
            }
            else
            {
                //
                // The miniport below us uses the old-style (not packet)
                // receive indication. Fall through.
                //
            }

            //
            // Fall through to here if the miniport below us has
            // either not indicated an NDIS_PACKET or we could not
            // allocate one.
            //

            //
            // Mark the VELAN so that we will forward up a receive
            // complete indication.
            //
            pVElan->IndicateRcvComplete = TRUE;

#if IEEE_VLAN_SUPPORT
            //
            // Get at the EtherType field.
            //
            pTpid = (PUSHORT)((PUCHAR)HeaderBuffer + 2 * ETH_LENGTH_OF_ADDRESS);

            //
            // Check if the EtherType indicates presence of a tag header.
            // 
            if (*pTpid == TPID)
            {
                pTagHeader = (VLAN_TAG_HEADER UNALIGNED *)LookAheadBuffer;
                //
                // Drop this frame if it contains Routing information;
                // we don't support this.
                // 
                if (GET_CANONICAL_FORMAT_ID_FROM_TAG(pTagHeader) != 0)
                {
                    Status = NDIS_STATUS_INVALID_PACKET;
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    MUX_INCR_STATISTICS(&pVElan->RcvFormatErrors);
                    continue;
                }
                //
                // If there is a VLAN ID in this frame, and we have
                // a configured VLAN ID for this VELAN, check if they
                // are the same - drop if not.
                // 
                if ((GET_VLAN_ID_FROM_TAG(pTagHeader) != (unsigned)0) &&
                     (pVElan->VlanId != (unsigned)0) &&
                     (ULONG)(GET_VLAN_ID_FROM_TAG(pTagHeader) != pVElan->VlanId))
                {
                    Status = NDIS_STATUS_NOT_ACCEPTED;
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    MUX_INCR_STATISTICS(&pVElan->RcvVlanIdErrors);
                    continue;
                }
                //
                // Copy information from the tag header to per-packet
                // info fields.
                //
                MuxRcvContext.NdisPacket8021QInfo.Value = NULL;
                COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(
                    MuxRcvContext.NdisPacket8021QInfo,
                    pTagHeader);
                //
                // Prepare for indicating up this frame (the tag
                // header must be removed). First, copy in the real
                // EtherType value from the tag header.
                // 
                *pTpid = *((PUSHORT)((PUCHAR)LookAheadBuffer + sizeof(pTagHeader->TagInfo)));
                //
                // Account for removing the tag header.
                //
                LookAheadBuffer = (PVOID)((PUCHAR)LookAheadBuffer + VLAN_TAG_HEADER_SIZE); 
                LookAheadBufferSize -= VLAN_TAG_HEADER_SIZE;
                PacketSize -= VLAN_TAG_HEADER_SIZE;
                //
                // Use MuxRcvContext to store context for the receive,
                // to be used in MpTransferData, if called.
                // 
                MuxRcvContext.TagHeaderLen = VLAN_TAG_HEADER_SIZE;
            }
            else
            {
                MuxRcvContext.TagHeaderLen = 0;
            }

            MuxRcvContext.MacRcvContext = MacReceiveContext;

            //
            // In order not to change the code a lot
            // 
            MacReceiveContext = &MuxRcvContext;
#endif            

            MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
            //
            // Indicate receive using the non-packet API.
            //
            NdisMEthIndicateReceive(pVElan->MiniportAdapterHandle,
                                    MacReceiveContext,
                                    HeaderBuffer,
                                    HeaderBufferSize,
                                    LookAheadBuffer,
                                    LookAheadBufferSize,
                                    PacketSize);

            MUX_DECR_PENDING_RECEIVES(pVElan);

        } // for (each VELAN)

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }
    while(FALSE);

    return Status;
}


VOID
PtReceiveComplete(
    IN    NDIS_HANDLE        ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of
    received packets. We forward this up on all VELANs that need
    this indication.

Arguments:

    ProtocolBindingContext    Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PADAPT          pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan;
    LOCK_STATE      LockState;

    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    for (p = pAdapt->VElanList.Flink;
         p != &pAdapt->VElanList;
         p = p->Flink)
    {
        pVElan = CONTAINING_RECORD(p, VELAN, Link);

        if (pVElan->IndicateRcvComplete)
        {
            pVElan->IndicateRcvComplete = FALSE;
            NdisMEthIndicateReceiveComplete(pVElan->MiniportAdapterHandle);
        }
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
}


INT
PtReceivePacket(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet
    )
/*++

Routine Description:

    ReceivePacket handler. Called by NDIS if the miniport below supports
    NDIS 4.0 style receives. Re-package the buffer chain in a new packet
    and indicate the new packet to interested protocols above us.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure.
    Packet - Pointer to the packet

Return Value:

    == 0 -> We are done with the packet
    != 0 -> We will keep the packet and call NdisReturnPackets() this
            many times when done.
--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;
    PVELAN                  pVElan;
    PLIST_ENTRY             p;
    NDIS_STATUS             Status;
    NDIS_STATUS             PacketStatus;
    PNDIS_PACKET            MyPacket;
    PUCHAR                  pData;
    PNDIS_BUFFER            pNdisBuffer;
    UINT                    FirstBufferLength;
    UINT                    TotalLength;
    PUCHAR                  pDstMac;
    BOOLEAN                 bIsMulticast, bIsBroadcast;
    PMUX_RECV_RSVD          pRecvReserved;
    ULONG                   ReturnCount;
    LOCK_STATE              LockState;
    
    
    ReturnCount = 0;

    do
    {
        if (pAdapt->PacketFilter == 0)
        {
            //
            // We could get receives in the interval between
            // initiating a request to set the packet filter on
            // the binding to 0 and completion of that request.
            // Drop such packets.
            //
            break;
        }

#ifdef NDIS51
        //
        // Collect some information from the packet.
        //
        NdisGetFirstBufferFromPacketSafe(Packet,
                                         &pNdisBuffer,
                                         &pData,
                                         &FirstBufferLength,
                                         &TotalLength,
                                         NormalPagePriority);
        if (pNdisBuffer == NULL)
        {
            //
            // Out of system resources. Drop this packet.
            //
            break;
        }
#else
        NdisGetFirstBufferFromPacket(Packet,
                                     &pNdisBuffer,
                                     &pData,
                                     &FirstBufferLength,
                                     &TotalLength);
#endif

        pDstMac = pData;
        bIsMulticast = ETH_IS_MULTICAST(pDstMac);
        bIsBroadcast = ETH_IS_BROADCAST(pDstMac);

        //
        // Lock down the VELAN list on the adapter so that
        // no insertions/deletions to this list happen while
        // we loop through it. The packet filter will also not
        // change during the time we hold the read lock.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            BOOLEAN     bIndicateReceive;

            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            //
            // Should the packet be indicated up on this VELAN?
            //
            bIndicateReceive = PtMatchPacketToVElan(pVElan,
                                                    pDstMac,
                                                    bIsMulticast,
                                                    bIsBroadcast);
            if (!bIndicateReceive)
            {
                continue;
            }

            //
            // Make sure we don't Halt the VELAN miniport while
            // we are accessing it here. See MPHalt.
            //
            // Also don't indicate receives if the virtual miniport
            // has been set to a low power state. A specific case
            // is when the system is resuming from "Stand-by", if
            // the lower adapter is restored to D0 before the upper
            // miniports are.
            //
            MUX_INCR_PENDING_RECEIVES(pVElan);

            if ((pVElan->MiniportHalting) ||
                (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                continue;
            }


            //
            // Get a packet off the pool and indicate that up
            //
            NdisDprAllocatePacket(&Status,
                                  &MyPacket,
                                  pVElan->RecvPacketPoolHandle);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                PacketStatus = NDIS_GET_PACKET_STATUS(Packet);
                
                pRecvReserved = MUX_RSVD_FROM_RECV_PACKET(MyPacket);
                if (PacketStatus != NDIS_STATUS_RESOURCES)
                {
                    pRecvReserved->pOriginalPacket = Packet;
                }
                else
                {
                    //
                    // This will ensure we don't call NdisReturnPacket for the packet if the packet
                    // status is NDIS_STATUS_RESOURCES
                    //
                    pRecvReserved->pOriginalPacket = NULL;
                }
        
                MyPacket->Private.Head = Packet->Private.Head;
                MyPacket->Private.Tail = Packet->Private.Tail;
        
                //
                // Get the original packet (it could be the same
                // packet as the one received or a different one
                // based on the number of layered miniports below)
                // and set it on the indicated packet so the OOB
                // data is visible correctly to protocols above us.
                //
                NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));
        
                //
                // Copy Packet Flags
                //
                NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);
        
                NDIS_SET_PACKET_STATUS(MyPacket, PacketStatus);
                NDIS_SET_PACKET_HEADER_SIZE(MyPacket, NDIS_GET_PACKET_HEADER_SIZE(Packet));

#if IEEE_VLAN_SUPPORT
                Status = PtHandleRcvTagging(pVElan, Packet, MyPacket);

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    NdisFreePacket(MyPacket);
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    continue;
                }
#endif                
                MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
                
                //
                // Indicate it up.
                //
                if (PacketStatus != NDIS_STATUS_RESOURCES)
                {
                    ReturnCount++;
                }
                NdisMIndicateReceivePacket(pVElan->MiniportAdapterHandle,
                                           &MyPacket,
                                           1);
        
                //
                // Check if we had indicated up the packet with
                // status set to NDIS_STATUS_RESOURCES.
                //
                // NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket)
                // for this since it might have changed! Use the value
                // saved in the local variable.
                //
                if (PacketStatus == NDIS_STATUS_RESOURCES)
                {
                    //
                    // Our ReturnPackets handler will not be called
                    // for this packet. We should reclaim it right here.
                    //
        
                    MPReturnPacket((NDIS_HANDLE)pVElan, MyPacket);
                }
            }
            else
            {
                //
                // Failed to allocate a packet.
                //
                MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
                MUX_DECR_PENDING_RECEIVES(pVElan);
            }

        } // for (loop thru all VELANs)

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

    }
    while (FALSE);

    //
    // Return the # of receive indications made for this packet.
    // We will call NdisReturnPackets for this packet as many
    // times (see MPReturnPackets).
    //
    return (ReturnCount);

}



NDIS_STATUS
PtPnPNetEventSetPower(
    IN PADAPT                   pAdapt,
    IN PNET_PNP_EVENT           pNetPnPEvent
    )
/*++
Routine Description:

    This is a notification to our protocol edge of the power state
    of the lower miniport. If it is going to a low-power state, we must
    wait here for all outstanding sends and requests to complete.

Arguments:

    pAdapt - Pointer to the adpater structure
    pNetPnPEvent - The Net Pnp Event. this contains the new device state

Return Value:

    NDIS_STATUS_SUCCESS

--*/
{
    PLIST_ENTRY                 p;
    PVELAN                      pVElan;
    LOCK_STATE                  LockState;
    NDIS_STATUS                 Status;

    //
    // Store the new power state.
    //
    
    pAdapt->PtDevicePowerState = *(PNDIS_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

    DBGPRINT(MUX_LOUD, ("PnPNetEventSetPower: Adapt %p, SetPower to %d\n",
            pAdapt, pAdapt->PtDevicePowerState));

    //
    // Check if the miniport below is going to a low power state.
    //
    if (MUX_IS_LOW_POWER_STATE(pAdapt->PtDevicePowerState))
    {
        ULONG       i;

        //
        // It is going to a low power state. Wait for outstanding
        // I/O to complete on the adapter.
        //
        for (i = 0; i < 10000; i++)
        {
            MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

            for (p = pAdapt->VElanList.Flink;
                 p != &pAdapt->VElanList;
                 p = p->Flink)
            {
                pVElan = CONTAINING_RECORD(p, VELAN, Link);
                if ((pVElan->OutstandingSends != 0) ||
                    (pVElan->OutstandingReceives != 0))
                {
                    break;
                }
            }

            MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

            if (p == &pAdapt->VElanList)
            {
                //
                // There are no VELANs with pending I/O.
                //
                break;
            }
            
            DBGPRINT(MUX_INFO, ("SetPower: Adapt %p, waiting for pending IO to complete\n",
                                pAdapt));

            NdisMSleep(1000);
        }

    }
    else
    {
        //
        // The device below is powered on. If we had requests
        // pending on any VELANs, send them down now.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            //
            // Need to make sure other threads do not try to acquire the write lock while holding
            // the same spin lock
            //
            NdisAcquireSpinLock(&pVElan->Lock);
            if (pVElan->QueuedRequest)
            {
                pVElan->QueuedRequest = FALSE;
                NdisReleaseSpinLock(&pVElan->Lock);

                NdisRequest(&Status,
                            pAdapt->BindingHandle,
                            &pVElan->Request.Request);
                
                if (Status != NDIS_STATUS_PENDING)
                {
                    PtRequestComplete(pAdapt,
                                      &pVElan->Request.Request,
                                      Status);
                }
            }
            else
            {
                NdisReleaseSpinLock(&pVElan->Lock);
            }
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PtPNPHandler(
    IN NDIS_HANDLE              ProtocolBindingContext,
    IN PNET_PNP_EVENT           pNetPnPEvent
    )

/*++
Routine Description:

    This is called by NDIS to notify us of a PNP event related to a lower
    binding. Based on the event, this dispatches to other helper routines.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure. Can be NULL
                for "global" notifications

    pNetPnPEvent - Pointer to the PNP event to be processed.

Return Value:

    NDIS_STATUS code indicating status of event processing.

--*/
{
    PADAPT              pAdapt  =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS         Status  = NDIS_STATUS_SUCCESS;
    PLIST_ENTRY         p;

    DBGPRINT(MUX_LOUD, ("PtPnPHandler: Adapt %p, NetPnPEvent %d\n", pAdapt, 
                            pNetPnPEvent->NetEvent));

    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventSetPower:

            Status = PtPnPNetEventSetPower(pAdapt, pNetPnPEvent);
            break;

        case NetEventReconfigure:
            //
            // Rescan configuration and bring up any VELANs that
            // have been newly added. Make sure that the global
            // adapter list is undisturbed while we traverse it.
            //
            MUX_ACQUIRE_MUTEX(&GlobalMutex);

            for (p = AdapterList.Flink;
                 p != &AdapterList;
                 p = p->Flink)
            {
                pAdapt = CONTAINING_RECORD(p, ADAPT, Link);

                PtBootStrapVElans(pAdapt);
            }

            MUX_RELEASE_MUTEX(&GlobalMutex);
                
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            Status = NDIS_STATUS_SUCCESS;

            break;
    }

    return Status;
}

NDIS_STATUS
PtCreateAndStartVElan(
    IN  PADAPT                      pAdapt,
    IN  PNDIS_STRING                pVElanKey
)
/*++

Routine Description:

    Create and start a VELAN with the given key name. Check if a VELAN
    with this key name already exists; if so do nothing.

    ASSUMPTION: this is called from either the BindAdapter handler for
    the underlying adapter, or from the PNP reconfig handler. Both these
    routines are protected by NDIS against pre-emption by UnbindAdapter.
    If this routine will be called from any other context, it should
    be protected against a simultaneous call to our UnbindAdapter handler.
    
Arguments:

    pAdapt        - Pointer to Adapter structure
    pVElanKey     - Points to a Unicode string naming the VELAN to create. 
    
Return Value:

    NDIS_STATUS_SUCCESS if we either found a duplicate VELAN or
    successfully initiated a new ELAN with the given key.

    NDIS_STATUS_XXX error code otherwise (failure initiating a new VELAN).

--*/
{
    NDIS_STATUS             Status;
    PVELAN                  pVElan;
    
    Status = NDIS_STATUS_SUCCESS;
    pVElan = NULL;

    DBGPRINT(MUX_LOUD, ("=> Create VElan: Adapter %p, ElanKey %ws\n", 
                            pAdapt, pVElanKey->Buffer));

    do
    {
        //
        //  Weed out duplicates.
        //
        if (pVElanKey != NULL)
        {

            pVElan = PtFindVElan(pAdapt, pVElanKey);

            if (NULL != pVElan)
            {
                //
                // Duplicate - bail out silently.
                //
                DBGPRINT(MUX_WARN, ("CreateElan: found duplicate pVElan %x\n", pVElan));

                Status = NDIS_STATUS_SUCCESS;
                pVElan = NULL;
                break;
            }
        }

        pVElan = PtAllocateAndInitializeVElan(pAdapt, pVElanKey);
        if (pVElan == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        //
        // Request NDIS to initialize the virtual miniport. Set
        // the flag below just in case an unbind occurs before
        // MiniportInitialize is called.
        //
        pVElan->MiniportInitPending = TRUE;
        NdisInitializeEvent(&pVElan->MiniportInitEvent);

        Status = NdisIMInitializeDeviceInstanceEx(DriverHandle,
                                                  &pVElan->CfgDeviceName,
                                                  pVElan);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            PtUnlinkVElanFromAdapter(pVElan);   // IMInit failed
            pVElan = NULL;
            break;
        }
    
    }
    while (FALSE);

    DBGPRINT(MUX_INFO, ("<= Create VElan: Adapter %p, VELAN %p\n", pAdapt, pVElan));

    return Status;
}


PVELAN
PtAllocateAndInitializeVElan(
    IN PADAPT                       pAdapt,
    IN PNDIS_STRING                 pVElanKey
    )
/*++

Routine Description:

    Allocates and initializes a VELAN structure. Also links it to
    the specified ADAPT.

Arguments:

    pAdapt - Adapter to link VELAN to
    pVElanKey - Key to the VELAN

Return Value:

    Pointer to VELAN structure if successful, NULL otherwise.

--*/
{
    PVELAN          pVElan;
    ULONG           Length;
    NDIS_STATUS     Status;
    LOCK_STATE      LockState;

    pVElan = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        Length = sizeof(VELAN) + pVElanKey->Length + sizeof(WCHAR);
        
        //
        // Allocate a VELAN data structure.
        //
        NdisAllocateMemoryWithTag(&pVElan, Length, TAG);
        if (pVElan == NULL)
        {
            DBGPRINT(MUX_FATAL, ("AllocateVElan: Failed to allocate %d bytes for VELAN\n",
                                 Length));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize it.
        //
        NdisZeroMemory(pVElan, Length);
        NdisInitializeListHead(&pVElan->Link);
        
        //
        // Initialize the built-in request structure to signify
        // that it is used to forward NDIS requests.
        //
        pVElan->Request.pVElan = pVElan;
        NdisInitializeEvent(&pVElan->Request.Event);
       
        //
        // Store in the key name.
        //
        pVElan->CfgDeviceName.Length = 0;
        pVElan->CfgDeviceName.Buffer = (PWCHAR)((PUCHAR)pVElan + 
                    sizeof(VELAN));       
        pVElan->CfgDeviceName.MaximumLength = 
                pVElanKey->MaximumLength + sizeof(WCHAR);
        (VOID)NdisUpcaseUnicodeString(&pVElan->CfgDeviceName, pVElanKey);
        pVElan->CfgDeviceName.Buffer[pVElanKey->Length/sizeof(WCHAR)] =
                        ((WCHAR)0);

        // 
        // Initialize LastIndicatedStatus to media connect
        //
        pVElan->LastIndicatedStatus = NDIS_STATUS_MEDIA_CONNECT;

        //
        // Set power state of virtual miniport to D0.
        //
        pVElan->MPDevicePowerState = NdisDeviceStateD0;

        //
        // Cache the binding handle for quick reference.
        //
        pVElan->BindingHandle = pAdapt->BindingHandle;
        pVElan->pAdapt = pAdapt;

        //
        // Copy in some adapter parameters.
        //
        pVElan->LookAhead = pAdapt->MaxLookAhead;
        pVElan->LinkSpeed = pAdapt->LinkSpeed;
        NdisMoveMemory(pVElan->PermanentAddress,
                       pAdapt->CurrentAddress,
                       sizeof(pVElan->PermanentAddress));

        NdisMoveMemory(pVElan->CurrentAddress,
                       pAdapt->CurrentAddress,
                       sizeof(pVElan->CurrentAddress));

        DBGPRINT(MUX_LOUD, ("Alloced VELAN %p, MAC addr %s\n",
                    pVElan, MacAddrToString(pVElan->CurrentAddress)));

        NdisAllocateSpinLock(&pVElan->Lock);
#if IEEE_VLAN_SUPPORT
        //
        // Allocate lookaside list for tag headers.
        // 
        NdisInitializeNPagedLookasideList (
                &pVElan->TagLookaside,
                NULL,
                NULL,
                0,
                ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE,
                'TxuM',
                0);
        
#endif
        //
        // Allocate a packet pool for sends.
        //
        NdisAllocatePacketPoolEx(&Status,
                                 &pVElan->SendPacketPoolHandle,
                                 MIN_PACKET_POOL_SIZE,
                                 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                 sizeof(MUX_SEND_RSVD));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MUX_FATAL, ("PtAllocateVElan: failed to allocate send packet pool\n"));
            break;
        }

        //
        // NOTE: this sample driver does not -originate- packets in the
        // send or receive directions. If the driver must originate packets,
        // here is a good place to allocate NDIS buffer pool(s) for
        // this purpose.
        //
#if IEEE_VLAN_SUPPORT
        //
        // Allocate a buffer pool for tag headers.
        //
        NdisAllocateBufferPool (&Status,
                                &pVElan->BufferPoolHandle,
                                MIN_PACKET_POOL_SIZE);

        ASSERT(Status == NDIS_STATUS_SUCCESS);
        
#endif
        
        //
        // Allocate a packet pool for receives.
        //
        NdisAllocatePacketPoolEx(&Status,
                                 &pVElan->RecvPacketPoolHandle,
                                 MIN_PACKET_POOL_SIZE,
                                 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                 PROTOCOL_RESERVED_SIZE_IN_PACKET);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MUX_FATAL, ("PtAllocateVElan: failed to allocate receive packet pool\n"));
            break;
        }

        //
        // Finally link this VELAN to the Adapter's VELAN list. 
        //
        PtReferenceVElan(pVElan, (PUCHAR)"adapter");        

        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        PtReferenceAdapter(pAdapt, (PUCHAR)"VElan");
        InsertTailList(&pAdapt->VElanList, &pVElan->Link);
        pAdapt->VElanCount++;
        pVElan->VElanNumber = NdisInterlockedIncrement((PLONG)&NextVElanNumber);

        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pVElan)
        {
            PtDeallocateVElan(pVElan);
            pVElan = NULL;
        }
    }

    return (pVElan);
}


VOID
PtDeallocateVElan(
    IN PVELAN                   pVElan
    )
/*++

Routine Description:

    Free up all resources allocated to a VELAN, and then the VELAN
    structure itself.

Arguments:

    pVElan - Pointer to VELAN to be deallocated.

Return Value:

    None

--*/
{
    
    if (pVElan->SendPacketPoolHandle != NULL)
    {
        NdisFreePacketPool(pVElan->SendPacketPoolHandle);
    }

    if (pVElan->RecvPacketPoolHandle != NULL)
    {
        NdisFreePacketPool(pVElan->RecvPacketPoolHandle);
    }
#if IEEE_VLAN_SUPPORT 
    NdisFreeBufferPool(pVElan->BufferPoolHandle);
    NdisDeleteNPagedLookasideList(&pVElan->TagLookaside);
#endif    
    NdisFreeMemory(pVElan, 0, 0);
}


VOID
PtStopVElan(
    IN  PVELAN            pVElan
)
/*++

Routine Description:

    Stop a VELAN by requesting NDIS to halt the virtual miniport.
    The caller has a reference on the VELAN, so it won't go away
    while we are executing in this routine.

    ASSUMPTION: this is only called in the context of unbinding
    from the underlying miniport. If it may be called from elsewhere,
    this should protect itself from re-entrancy.
    
Arguments:

    pVElan      - Pointer to VELAN to be stopped.
    
Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    NDIS_HANDLE             MiniportAdapterHandle;
    BOOLEAN                 bMiniportInitCancelled = FALSE;

    DBGPRINT(MUX_LOUD, ("=> StopVElan: VELAN %p, Adapt %p\n", pVElan, pVElan->pAdapt));

    //
    // We make blocking calls below.
    //
    ASSERT_AT_PASSIVE();

    //
    // If there was a queued request on this VELAN, fail it now.
    //
    NdisAcquireSpinLock(&pVElan->Lock);
    ASSERT(pVElan->DeInitializing == TRUE);
    if (pVElan->QueuedRequest)
    {
        pVElan->QueuedRequest = FALSE;
        NdisReleaseSpinLock(&pVElan->Lock);

        PtRequestComplete(pVElan->pAdapt,
                          &pVElan->Request.Request,
                          NDIS_STATUS_FAILURE);
    }

    else
    {
        NdisReleaseSpinLock(&pVElan->Lock);
    }
    //
    // Check if we had called NdisIMInitializeDeviceInstanceEx and
    // we are awaiting a call to MiniportInitialize.
    //
    if (pVElan->MiniportInitPending)
    {
        //
        // Attempt to cancel miniport init.
        //
        Status = NdisIMCancelInitializeDeviceInstance(
                    DriverHandle,
                    &pVElan->CfgDeviceName);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            //
            // Successfully cancelled IM initialization; our
            // Miniport Init routine will not be called for this
            // VELAN miniport.
            //
            pVElan->MiniportInitPending = FALSE;
            ASSERT(pVElan->MiniportAdapterHandle == NULL);
            bMiniportInitCancelled = TRUE;
        }
        else
        {
            //
            // Our Miniport Initialize routine will be called
            // (may be running on another thread at this time).
            // Wait for it to finish.
            //
            NdisWaitEvent(&pVElan->MiniportInitEvent, 0);
            ASSERT(pVElan->MiniportInitPending == FALSE);
        }
    }

    //
    // Check if Miniport Init has run. If so, deinitialize the virtual
    // miniport. This will result in a call to our Miniport Halt routine,
    // where the VELAN will be cleaned up.
    //
    MiniportAdapterHandle = pVElan->MiniportAdapterHandle;

    if ((NULL != MiniportAdapterHandle) &&
        (!pVElan->MiniportHalting))
    {
        //
        // The miniport was initialized, and has not yet halted.
        //
        ASSERT(bMiniportInitCancelled == FALSE);
        (VOID)NdisIMDeInitializeDeviceInstance(MiniportAdapterHandle);
    }
    else
    {
        if (bMiniportInitCancelled)
        {
            //
            // No NDIS events can come to this VELAN since it
            // was never initialized as a miniport. We need to unlink
            // it explicitly here.
            //
            PtUnlinkVElanFromAdapter(pVElan);
        }
    }
}


VOID
PtUnlinkVElanFromAdapter(
    IN PVELAN               pVElan
)
/*++

Routine Description:

    Utility routine to unlink a VELAN from its parent ADAPT structure.
    
Arguments:

    pVElan      - Pointer to VELAN to be unlinked.
    
Return Value:

    None

--*/
{
    PADAPT pAdapt = pVElan->pAdapt;    
    LOCK_STATE      LockState;
    
    ASSERT(pAdapt != NULL);

    //
    // Remove this VELAN from the Adapter list
    //
    MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

    RemoveEntryList(&pVElan->Link);
    pAdapt->VElanCount--;
        
    MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    pVElan->pAdapt = NULL;
    PtDereferenceVElan(pVElan, (PUCHAR)"adapter");

    PtDereferenceAdapter(pAdapt, (PUCHAR)"VElan");
}


PVELAN
PtFindVElan(
    IN    PADAPT                pAdapt,
    IN    PNDIS_STRING          pVElanKey
)
/*++

Routine Description:

    Find an ELAN by bind name/key

Arguments:

    pAdapt     -    Pointer to an adapter struct.
    pVElanKey  -    The VELAN's device name

Return Value:

    Pointer to matching VELAN or NULL if not found.
    
--*/
{
    PLIST_ENTRY         p;
    PVELAN              pVElan;
    BOOLEAN             Found;
    NDIS_STRING         VElanKeyName;
    LOCK_STATE          LockState;

    ASSERT_AT_PASSIVE();

    DBGPRINT(MUX_LOUD, ("FindElan: Adapter %p, ElanKey %ws\n", pAdapt, 
                                        pVElanKey->Buffer));

    pVElan = NULL;
    Found = FALSE;
    VElanKeyName.Buffer = NULL;

    do
    {
        //
        // Make an up-cased copy of the given string.
        //
        NdisAllocateMemoryWithTag(&VElanKeyName.Buffer, 
                                pVElanKey->MaximumLength, TAG);
        if (VElanKeyName.Buffer == NULL)
        {
            break;
        }

        VElanKeyName.Length = pVElanKey->Length;
        VElanKeyName.MaximumLength = pVElanKey->MaximumLength;

        (VOID)NdisUpcaseUnicodeString(&VElanKeyName, pVElanKey);

        //
        // Go through all VELANs on the ADAPT structure, looking
        // for a VELAN that has a matching device name.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        p = pAdapt->VElanList.Flink;
        while (p != &pAdapt->VElanList)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            if ((VElanKeyName.Length == pVElan->CfgDeviceName.Length) &&
                (memcmp(VElanKeyName.Buffer, pVElan->CfgDeviceName.Buffer, 
                VElanKeyName.Length) == 0))
            {
                Found = TRUE;
                break;
            }
        
            p = p->Flink;
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

    }
    while (FALSE);

    if (!Found)
    {
        DBGPRINT(MUX_INFO, ( "FindElan: No match found!\n"));
        pVElan = NULL;
    }

    if (VElanKeyName.Buffer)
    {
        NdisFreeMemory(VElanKeyName.Buffer, VElanKeyName.Length, 0);
    }

    return pVElan;
}


NDIS_STATUS
PtBootStrapVElans(
    IN  PADAPT            pAdapt
)
/*++

Routine Description:

    Start up the VELANs configured for an adapter.

Arguments:

    pAdapt    - Pointer to ATMLANE Adapter structure

Return Value:

    None

--*/
{
    NDIS_STATUS                     Status;
    NDIS_HANDLE                     AdapterConfigHandle;
    PNDIS_CONFIGURATION_PARAMETER   Param;
    NDIS_STRING                     DeviceStr = NDIS_STRING_CONST("UpperBindings");
    PWSTR                           buffer;
    LOCK_STATE                      LockState;
    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    AdapterConfigHandle = NULL;
    
    do
    {
        DBGPRINT(MUX_LOUD, ("BootStrapElans: Starting ELANs on adapter %x\n", pAdapt));

        //
        //  Open the protocol configuration section for this adapter.
        //

        NdisOpenProtocolConfiguration(&Status,
                                       &AdapterConfigHandle,
                                       &pAdapt->ConfigString);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            AdapterConfigHandle = NULL;
            DBGPRINT(MUX_ERROR, ("BootStrapElans: OpenProtocolConfiguration failed\n"));
            Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }
        
        //
        // Read the "UpperBindings" reserved key that contains a list
        // of device names representing our miniport instances corresponding
        // to this lower binding. The UpperBindings is a 
        // MULTI_SZ containing a list of device names. We will loop through
        // this list and initialize the virtual miniports.
        //
        NdisReadConfiguration(&Status,
                              &Param,
                              AdapterConfigHandle,
                              &DeviceStr,
                              NdisParameterMultiString);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(MUX_ERROR, ("BootStrapElans: NdisReadConfiguration failed\n"));
            break;
        }

        //
        // Parse the Multi_sz string to extract the device name of each VELAN.
        // This is used as the key name for the VELAN.
        //
        buffer = (PWSTR)Param->ParameterData.StringData.Buffer;
        while(*buffer != L'\0')
        {
            NDIS_STRING     DeviceName;
            
            NdisInitUnicodeString(&DeviceName, buffer);
           

            Status = PtCreateAndStartVElan(pAdapt, &DeviceName); 
            if (NDIS_STATUS_SUCCESS != Status)
            {
                DBGPRINT(MUX_ERROR, ("BootStrapElans: CreateVElan failed\n"));
                break;
            }
            buffer = (PWSTR)((PUCHAR)buffer + DeviceName.Length + sizeof(WCHAR));
        };
          
    } while (FALSE);

    //
    //    Close config handles
    //        
    if (NULL != AdapterConfigHandle)
    {
        NdisCloseConfiguration(AdapterConfigHandle);
    }
    //
    // If the driver cannot create any velan for the adapter
    // 
    if (Status != NDIS_STATUS_SUCCESS)
    {
        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
        //
        // No VElan is created for this adapter
        //
        if (pAdapt->VElanCount != 0)
        {
            Status = NDIS_STATUS_SUCCESS;
        }
        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    }   

    return Status;
}

VOID
PtReferenceVElan(
    IN    PVELAN            pVElan,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Add a references to an Elan structure.

Arguments:

    pElan    -    Pointer to the Elan structure.


Return Value:

    None.

--*/
{
    
    NdisInterlockedIncrement((PLONG)&pVElan->RefCount);

#if !DBG
    UNREFERENCED_PARAMETER(String);
#endif

    DBGPRINT(MUX_LOUD, ("ReferenceElan: Elan %p (%s) new count %d\n",
             pVElan, String, pVElan->RefCount));

    return;
}

ULONG
PtDereferenceVElan(
    IN    PVELAN            pVElan,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Subtract a reference from an VElan structure. 
    If the reference count becomes zero, deallocate it.

Arguments:

    pElan    -    Pointer to an VElan structure.


Return Value:

    None.

--*/
{
    ULONG        rc;

#if !DBG
    UNREFERENCED_PARAMETER(String);
#endif

    ASSERT(pVElan->RefCount > 0);

    rc = NdisInterlockedDecrement((PLONG)&pVElan->RefCount);

    if (rc == 0)
    {
        //
        // Free memory if there is no outstanding reference.
        // Note: Length field is not required if the memory 
        // is allocated with NdisAllocateMemoryWithTag.
        //
        PtDeallocateVElan(pVElan);
    }
    
    DBGPRINT(MUX_LOUD, ("DereferenceElan: VElan %p (%s) new count %d\n", 
                                    pVElan, String, rc));
    return (rc);
}


BOOLEAN
PtReferenceAdapter(
    IN    PADAPT            pAdapt,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Add a references to an Adapter structure.

Arguments:

    pAdapt    -    Pointer to the Adapter structure.

Return Value:

    None.

--*/
{
    
#if !DBG
    UNREFERENCED_PARAMETER(String);
#endif

    NdisInterlockedIncrement((PLONG)&pAdapt->RefCount);
    
    DBGPRINT(MUX_LOUD, ("ReferenceAdapter: Adapter %x (%s) new count %d\n",
                    pAdapt, String, pAdapt->RefCount));

    return TRUE;
}

ULONG
PtDereferenceAdapter(
    IN    PADAPT    pAdapt,
    IN    PUCHAR    String
    )
/*++

Routine Description:

    Subtract a reference from an Adapter structure. 
    If the reference count becomes zero, deallocate it.

Arguments:

    pAdapt    -    Pointer to an adapter structure.


Return Value:

    None.

--*/
{
    ULONG        rc;

#if !DBG
    UNREFERENCED_PARAMETER(String);
#endif

    ASSERT(pAdapt->RefCount > 0);


    rc = NdisInterlockedDecrement ((PLONG)&pAdapt->RefCount);

    if (rc == 0)
    {
        //
        // Free memory if there is no outstanding reference.
        // Note: Length field is not required if the memory 
        // is allocated with NdisAllocateMemoryWithTag.
        //
        NdisFreeMemory(pAdapt, 0, 0);
    }

    DBGPRINT(MUX_LOUD, ("DereferenceAdapter: Adapter %x (%s) new count %d\n", 
                        pAdapt, String, rc));

    return (rc);
}


#if IEEE_VLAN_SUPPORT
NDIS_STATUS
PtHandleRcvTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    )
/*++

Routine Description:

    Parse a received Ethernet frame for 802.1Q tag information.
    If a tag header is present, copy in relevant field values to
    per-packet information to the new packet (MyPacket) used to
    indicate up this frame.

Arguments:

    pVElan   -    Pointer to the VELAN structure.
    Packet   -    Pointer to the indicated packet from the lower miniport
    MyPacket -    Pointer to the new allocated packet
    
Return Value:

    NDIS_STATUS_SUCCESS if the frame was successfully parsed
    and hence should be indicated up this VELAN. NDIS_STATUS_XXX
    otherwise.

--*/
{
    VLAN_TAG_HEADER UNALIGNED * pTagHeader;
    USHORT UNALIGNED *          pTpid;
    PVOID                       pVa;
    ULONG                       BufferLength;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    PVOID                       pDst;
    BOOLEAN                     OnlyOneBuffer = FALSE;
    NDIS_STATUS                 Status;
    
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        //
        // If the vlan ID the virtual miniport is 0, the miniport should act like it doesn't support 
        // VELAN tag processing
        // 
        if (pVElan->VlanId == 0)
        {
            break;
        }
        pNdisBuffer = Packet->Private.Head;

#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe(pNdisBuffer, &pVa, (PUINT)&BufferLength, NormalPagePriority );
        if (pVa == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
            break;
        }
#else
        NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
    
        //
        // The first NDIS buffer (lookahead) must be longer than
        // ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE
        // 
        ASSERT(BufferLength >= ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE);

        //
        // Get at the EtherType field.
        //
        pTpid = (USHORT UNALIGNED *)((PUCHAR)pVa + 2 * ETH_LENGTH_OF_ADDRESS);
                    
        //
        // Check if a tag header is present.
        //
        if (*pTpid != TPID)
        {
            //
            // No tag header exists - nothing more to do here.
            // 
            NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 0;                  
            break;
        }

        //
        // We do have a tag header. Parse it further.
        //
        //
        // If E-RIF is present, discard the packet - we don't
        // support this variation.
        //
        pTagHeader = (VLAN_TAG_HEADER UNALIGNED *)(pTpid + 1);
        if (GET_CANONICAL_FORMAT_ID_FROM_TAG(pTagHeader) != 0)
        {
            //
            // Drop the packet
            // 
            Status = NDIS_STATUS_NOT_ACCEPTED;
            MUX_INCR_STATISTICS(&pVElan->RcvFormatErrors);
            break;
        }

        //
        // If there is a VLAN ID in this frame, and we have
        // a configured VLAN ID for this VELAN, check if they
        // are the same - drop if not.
        // 
        if ((GET_VLAN_ID_FROM_TAG(pTagHeader) != 0) &&
             (GET_VLAN_ID_FROM_TAG(pTagHeader) != pVElan->VlanId))
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            MUX_INCR_STATISTICS(&pVElan->RcvVlanIdErrors);
            break;
        }

        //
        // Parsed this frame successfully. Copy in relevant
        // parts of the tag header to per-packet information.
        //
        NdisPacket8021qInfo.Value = NULL; // initialize

        COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(NdisPacket8021qInfo, pTagHeader);

        NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 
                                    NdisPacket8021qInfo.Value;

        //
        // Strip off the tag header "in place":
        // 
        pDst = (PVOID)((PUCHAR)pVa + VLAN_TAG_HEADER_SIZE);
        RtlMoveMemory(pDst, pVa, 2 * ETH_LENGTH_OF_ADDRESS);

        //
        // Allocate a new buffer to describe the new first
        // buffer in the packet. This could very well be the
        // only buffer in the packet.
        // 
        NdisAllocateBuffer(&Status,
                            &pNdisBuffer,
                            pVElan->BufferPoolHandle,
                            pDst,
                            BufferLength - VLAN_TAG_HEADER_SIZE);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            // Drop the packet 
            // 
            Status = NDIS_STATUS_RESOURCES;
            MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
            break;
        }

        //
        // Prepare the new packet to be indicated up: this consists
        // of the buffer chain starting with the second buffer,
        // appended to the first buffer set up in the previous step.
        //
        MyPacket->Private.Head = NDIS_BUFFER_LINKAGE(Packet->Private.Head);

        //
        // Only one buffer in the packet
        // 
        if (MyPacket->Private.Head == NULL)
        {
            OnlyOneBuffer = TRUE;
        }

        NdisChainBufferAtFront(MyPacket, pNdisBuffer);

        if (OnlyOneBuffer)
        {
            MyPacket->Private.Tail = MyPacket->Private.Head;
        }
        else
        {
            MyPacket->Private.Tail = Packet->Private.Tail;
        }

    }
    while (FALSE);
                    
    return Status;
}
#endif  // IEEE_VLAN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\muxim\public.h ===
/*++
Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Author:

     
Environment:

    user and kernel
Notes:


Revision History:


--*/
#ifndef __PUBLIC_H
#define __PUBLIC_H

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Mux"
#define NTDEVICE_STRING     L"\\Device\\Mux"

#define  MUX_CUSTOM_EVENT      1

#define NOTIFY_SIGNATURE       0xAFCDABAB

typedef struct _NOTIFY_CUSTOM_EVENT {
  ULONG           uSignature;
  ULONG           uEvent;
  WCHAR           szMiniport[1];
} NOTIFY_CUSTOM_EVENT, *PNOTIFY_CUSTOM_EVENT;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for NDISPROT

Revision History:

    arvindm     04/11/2000    created based on rawwan.

Notes:

--*/

#ifndef _NUIODEBUG__H
#define _NUIODEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD       20
#define DL_VERY_LOUD        10
#define DL_LOUD             8
#define DL_INFO             6
#define DL_WARN             4
#define DL_ERROR            2
#define DL_FATAL            0

#if DBG_SPIN_LOCK

typedef struct _NPROT_LOCK
{
    ULONG                   Signature;
    ULONG                   IsAcquired;
    PKTHREAD                OwnerThread;
    ULONG                   TouchedByFileNumber;
    ULONG                   TouchedInLineNumber;
    NDIS_SPIN_LOCK          NdisLock;
} NPROT_LOCK, *PNPROT_LOCK;

#define NUIOL_SIG    'KCOL'

extern NDIS_SPIN_LOCK       ndisprotDbgLogLock;

extern
VOID
ndisprotAllocateSpinLock(
    IN  PNPROT_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisprotAcquireSpinLock(
    IN  PNPROT_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisprotReleaseSpinLock(
    IN  PNPROT_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)                                         \
            {                                                           \
                if ((INT)(Count) < 0)                                   \
                {                                                       \
                    DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",\
                        Count, __FILE__, __LINE__);                     \
                    DbgBreakPoint();                                    \
                }                                                       \
            }
#else

#define CHECK_LOCK_COUNT(Count)

typedef NDIS_SPIN_LOCK      NPROT_LOCK;
typedef PNDIS_SPIN_LOCK     PNPROT_LOCK;

#endif    // DBG_SPIN_LOCK

#if DBG

extern INT                ndisprotDebugLevel;


#define DEBUGP(lev, stmt)                                               \
        {                                                               \
            if ((lev) <= ndisprotDebugLevel)                             \
            {                                                           \
                DbgPrint("NdisProt: "); DbgPrint stmt;                   \
            }                                                           \
        }

#define DEBUGPDUMP(lev, pBuf, Len)                                      \
        {                                                               \
            if ((lev) <= ndisprotDebugLevel)                             \
            {                                                           \
                DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));          \
            }                                                           \
        }

#define NPROT_ASSERT(exp)                                                \
        {                                                               \
            if (!(exp))                                                 \
            {                                                           \
                DbgPrint("NdisProt: assert " #exp " failed in"           \
                    " file %s, line %d\n", __FILE__, __LINE__);         \
                DbgBreakPoint();                                        \
            }                                                           \
        }

#define NPROT_SET_SIGNATURE(s, t)\
        (s)->t##_sig = t##_signature;

#define NPROT_STRUCT_ASSERT(s, t)                                        \
        if ((s)->t##_sig != t##_signature)                              \
        {                                                               \
            DbgPrint("ndisprot: assertion failure"                       \
            " for type " #t " at 0x%x in file %s, line %d\n",           \
             (PUCHAR)s, __FILE__, __LINE__);                            \
            DbgBreakPoint();                                            \
        }


//
// Memory Allocation/Freeing Audit:
//

//
// The NUIOD_ALLOCATION structure stores all info about one allocation
//
typedef struct _NUIOD_ALLOCATION {

        ULONG                    Signature;
        struct _NUIOD_ALLOCATION *Next;
        struct _NUIOD_ALLOCATION *Prev;
        ULONG                    FileNumber;
        ULONG                    LineNumber;
        ULONG                    Size;
        ULONG_PTR                Location;  // where the returned ptr was stored
        union
        {
            ULONGLONG            Alignment;
            UCHAR                    UserData;
        };

} NUIOD_ALLOCATION, *PNUIOD_ALLOCATION;

#define NUIOD_MEMORY_SIGNATURE    (ULONG)'CSII'

extern
PVOID
ndisprotAuditAllocMem (
    PVOID        pPointer,
    ULONG        Size,
    ULONG        FileNumber,
    ULONG        LineNumber
);

extern
VOID
ndisprotAuditFreeMem(
    PVOID        Pointer
);

extern
VOID
ndisprotAuditShutdown(
    VOID
);

extern
VOID
DbgPrintHexDump(
    PUCHAR        pBuffer,
    ULONG        Length
);

#else

//
// No debug
//
#define DEBUGP(lev, stmt)
#define DEBUGPDUMP(lev, pBuf, Len)

#define NPROT_ASSERT(exp)
#define NPROT_SET_SIGNATURE(s, t)
#define NPROT_STRUCT_ASSERT(s, t)

#endif    // DBG


#endif // _NUIODEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\excallbk.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    ExCallbk.c

Abstract: The routines in this module helps to solve driver load order
          dependency between this sample and NDISWDM sample. These 
          routines are not required in a typical protocol driver. By default
          this module is not included in the sample. You include these routines
          by adding EX_CALLBACK defines to the 'sources' file. Read the
          NDISWDM samples readme file for more information on how ExCallback
          kernel interfaces are used to solve driver load order issue.


Author: Eliyas Yakub (Jan 12, 2003)

Environment:

    Kernel mode


Revision History:

--*/

#include "precomp.h"

#ifdef EX_CALLBACK

#define __FILENUMBER 'LCxE'

#define NDISPROT_CALLBACK_NAME  L"\\Callback\\NdisProtCallbackObject"

#define CALLBACK_SOURCE_NDISPROT    0
#define CALLBACK_SOURCE_NDISWDM     1

PCALLBACK_OBJECT                CallbackObject = NULL;
PVOID                           CallbackRegisterationHandle = NULL;

typedef VOID (* NOTIFY_PRESENCE_CALLBACK)(OUT PVOID Source);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, ndisprotRegisterExCallBack)
#pragma alloc_text(PAGE, ndisprotUnregisterExCallBack)

#endif // ALLOC_PRAGMA

BOOLEAN 
ndisprotRegisterExCallBack()
{
    OBJECT_ATTRIBUTES   ObjectAttr;
    UNICODE_STRING      CallBackObjectName;
    NTSTATUS            Status;
    BOOLEAN             bResult = TRUE;

    DEBUGP(DL_LOUD, ("--> ndisprotRegisterExCallBack\n"));

    PAGED_CODE();
    
    do {
        
        RtlInitUnicodeString(&CallBackObjectName, NDISPROT_CALLBACK_NAME);

        InitializeObjectAttributes(&ObjectAttr,
                                   &CallBackObjectName,
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                   NULL,
                                   NULL);
                                   
        Status = ExCreateCallback(&CallbackObject,
                                  &ObjectAttr,
                                  TRUE,
                                  TRUE);

        
        if (!NT_SUCCESS(Status))
        {

            DEBUGP(DL_ERROR, ("RegisterExCallBack: failed to create callback %lx\n", Status));
            bResult = FALSE;
            break;
        }
       
        CallbackRegisterationHandle = ExRegisterCallback(CallbackObject,
                                                                 ndisprotCallback,
                                                                 (PVOID)NULL);
        if (CallbackRegisterationHandle == NULL)
        {
            DEBUGP(DL_ERROR,("RegisterExCallBack: failed to register a Callback routine%lx\n", Status));
            bResult = FALSE;
            break;
        }

        ExNotifyCallback(CallbackObject,
                        (PVOID)CALLBACK_SOURCE_NDISPROT,
                        (PVOID)NULL);
       
    
    }while(FALSE);

    if(!bResult) {
        if (CallbackRegisterationHandle)
        {
            ExUnregisterCallback(CallbackRegisterationHandle);
            CallbackRegisterationHandle = NULL;
        }

        if (CallbackObject)
        {
            ObDereferenceObject(CallbackObject);
            CallbackObject = NULL;
        }        
    }

    DEBUGP(DL_LOUD, ("<-- ndisprotRegisterExCallBack\n"));

    return bResult;
    
}

VOID 
ndisprotUnregisterExCallBack()
{
    DEBUGP(DL_LOUD, ("--> ndisprotUnregisterExCallBack\n"));

    PAGED_CODE();

    if (CallbackRegisterationHandle)
    {
        ExUnregisterCallback(CallbackRegisterationHandle);
        CallbackRegisterationHandle = NULL;
    }

    if (CallbackObject)
    {
        ObDereferenceObject(CallbackObject);
        CallbackObject = NULL;
    }   
    
    DEBUGP(DL_LOUD, ("<-- ndisprotUnregisterExCallBack\n"));
    
}

VOID
ndisprotCallback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   CallbackAddr
    )
{
    NOTIFY_PRESENCE_CALLBACK func;
    
    DEBUGP(DL_LOUD, ("==>ndisprotoCallback: Source %lx, CallbackAddr %p\n", 
                            Source, CallbackAddr));
    
    //
    // if we are the one issuing this notification, just return
    //
    if (Source == CALLBACK_SOURCE_NDISPROT) {        
        return;
    }
    
    //
    // Notification is coming from NDISWDM
    // let it know that you are here
    //
    ASSERT(Source == (PVOID)CALLBACK_SOURCE_NDISWDM);
    
    if(Source == (PVOID)CALLBACK_SOURCE_NDISWDM) {

        ASSERT(CallbackAddr);
        
        if (CallbackAddr == NULL)
        {
            DEBUGP(DL_ERROR, ("Callback called with invalid address %p\n", CallbackAddr));
            return;     
        }

        func = CallbackAddr;
    
        func(CALLBACK_SOURCE_NDISPROT);
    }
    
    DEBUGP(DL_LOUD, ("<==ndisprotoCallback: Source,  %lx\n", Source));
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\macros.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Some macros for NDISPROT.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/


#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b)? (_a): (_b))
#endif

#if DBG
#define NPROT_REF_OPEN(_pOpen)   ndisprotDbgRefOpen(_pOpen, __FILENUMBER, __LINE__)
#define NPROT_DEREF_OPEN(_pOpen) ndisprotDbgDerefOpen(_pOpen, __FILENUMBER, __LINE__)
#else
#define NPROT_REF_OPEN(_pOpen)   ndisprotRefOpen(_pOpen)
#define NPROT_DEREF_OPEN(_pOpen) ndisprotDerefOpen(_pOpen)
#endif

//
//  Spinlock macros
//
#if DBG_SPIN_LOCK

#define NPROT_INIT_LOCK(_pLock)              \
           ndisprotAllocateSpinLock(_pLock, __FILENUMBER, __LINE__)

#define NPROT_ACQUIRE_LOCK(_pLock)           \
            ndisprotAcquireSpinLock(_pLock, __FILENUMBER, __LINE__)

#define NPROT_RELEASE_LOCK(_pLock)           \
            ndisprotReleaseSpinLock(_pLock, __FILENUMBER, __LINE__)

#else

#define NPROT_INIT_LOCK(_pLock)           NdisAllocateSpinLock(_pLock)
#define NPROT_ACQUIRE_LOCK(_pLock)        NdisAcquireSpinLock(_pLock)
#define NPROT_RELEASE_LOCK(_pLock)        NdisReleaseSpinLock(_pLock)

#endif // DBG

//
//  List manipulation.
//
#define NPROT_INIT_LIST_HEAD(_pList)             InitializeListHead(_pList)
#define NPROT_IS_LIST_EMPTY(_pList)              IsListEmpty(_pList)
#define NPROT_INSERT_HEAD_LIST(_pList, _pEnt)    InsertHeadList(_pList, _pEnt)
#define NPROT_INSERT_TAIL_LIST(_pList, _pEnt)    InsertTailList(_pList, _pEnt)
#define NPROT_REMOVE_ENTRY_LIST(_pEnt)           RemoveEntryList(_pEnt)


//
//  Receive packet queueing.
//
#define NPROT_LIST_ENTRY_TO_RCV_PKT(_pEnt)   \
    CONTAINING_RECORD(CONTAINING_RECORD(_pEnt, NPROT_RECV_PACKET_RSVD, Link), NDIS_PACKET, ProtocolReserved)

#define NPROT_RCV_PKT_TO_LIST_ENTRY(_pPkt)   \
    (&((PNPROT_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->Link)


//
//  In case we allocate a receive packet of our own to copy and queue
//  received data, we might have to also allocate an auxiliary NDIS_BUFFER
//  to map part of the receive buffer (skipping the header bytes), so as
//  to satisfy NdisTransferData. In such cases, we keep a pointer to the
//  fully mapped receive buffer in the packet reserved space:
//
#define NPROT_RCV_PKT_TO_ORIGINAL_BUFFER(_pPkt)  \
    (((PNPROT_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pOriginalBuffer)


//
//  Send packet context.
//
#define NPROT_IRP_FROM_SEND_PKT(_pPkt)        \
    (((PNPROT_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pIrp)

#define NPROT_SEND_PKT_RSVD(_pPkt)           \
    ((PNPROT_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))


#define NPROT_REF_SEND_PKT(_pPkt)            \
    (VOID)NdisInterlockedIncrement((PLONG)&NPROT_SEND_PKT_RSVD(_pPkt)->RefCount)


#define NPROT_DEREF_SEND_PKT(_pPkt)          \
    {                                                                               \
        if (NdisInterlockedDecrement((PLONG)&NPROT_SEND_PKT_RSVD(_pPkt)->RefCount) == 0)    \
        {                                                                           \
            NdisFreePacket(_pPkt);                                                  \
        }                                                                           \
    }


#ifdef NDIS51

//
//  Cancel IDs are generated by using the partial cancel ID we got from
//  NDIS ORed with a monotonically increasing locally generated ID.
//
#define NPROT_CANCEL_ID_LOW_MASK     (((ULONG_PTR)-1) >> 8) 

#define NPROT_GET_NEXT_CANCEL_ID()                                                   \
        (PVOID)(Globals.PartialCancelId |                                           \
         ((NdisInterlockedIncrement((PLONG)&Globals.LocalCancelId)) & NPROT_CANCEL_ID_LOW_MASK))

#endif // NDIS51

//
//  Memory allocation
//
#if DBG
#define NPROT_ALLOC_MEM(_pVar, _Size)        \
    (_pVar) = ndisprotAuditAllocMem(         \
                    (PVOID)&(_pVar),        \
                    _Size,                  \
                    __FILENUMBER,           \
                    __LINE__);

#define NPROT_FREE_MEM(_pMem)                \
    ndisprotAuditFreeMem(_pMem);

#else

#define NPROT_ALLOC_MEM(_pVar, _Size)        \
    NdisAllocateMemoryWithTag((PVOID *)(&_pVar), (_Size), NPROT_ALLOC_TAG)

#define NPROT_FREE_MEM(_pMem)                \
    NdisFreeMemory(_pMem, 0, 0)

#endif // DBG


#define NPROT_ZERO_MEM(_pMem, _ByteCount)        \
    NdisZeroMemory(_pMem, _ByteCount)

#define NPROT_COPY_MEM(_pDst, _pSrc, _ByteCount) \
    NdisMoveMemory(_pDst, _pSrc, _ByteCount)

#define NPROT_MEM_CMP(_p1, _p2, _ByteCount)      \
    NdisEqualMemory(_p1, _p2, _ByteCount)

#define NPROT_SET_MEM(_pMem, _ByteVal, _ByteCount)   \
    NdisFillMemory(_pMem, _ByteCount, _ByteVal)

//
//  Events.
//
#define NPROT_INIT_EVENT(_pEvent)            NdisInitializeEvent(_pEvent)
#define NPROT_SIGNAL_EVENT(_pEvent)          NdisSetEvent(_pEvent)
#define NPROT_WAIT_EVENT(_pEvent, _MsToWait) NdisWaitEvent(_pEvent, _MsToWait)


//
//  Flags
//
#define NPROT_SET_FLAGS(_FlagsVar, _Mask, _BitsToSet)    \
        (_FlagsVar) = ((_FlagsVar) & ~(_Mask)) | (_BitsToSet)

#define NPROT_TEST_FLAGS(_FlagsVar, _Mask, _BitsToCheck)    \
        (((_FlagsVar) & (_Mask)) == (_BitsToCheck))


//
//  Block the calling thread for the given duration:
//
#define NPROT_SLEEP(_Seconds)                            \
{                                                       \
    NDIS_EVENT  _SleepEvent;                            \
    NdisInitializeEvent(&_SleepEvent);                  \
    (VOID)NdisWaitEvent(&_SleepEvent, _Seconds*1000);   \
}


#define NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                           \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_FOUND == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_NO_MORE_ENTRIES;                                     \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_READY == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_DEVICE_NOT_READY;                                    \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}

#ifdef WIN9X
#undef NdisGetPoolFromPacket
#define NdisGetPoolFromPacket(_Pkt) ((_Pkt)->Private.Pool)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm        05-29-97    Created, based on ATM ARP.

Notes:

--*/

#include <precomp.h>

#define __FILENUMBER 'GBED'

#if DBG

INT                 ndisprotDebugLevel=DL_WARN;

NDIS_SPIN_LOCK        ndisprotDbgLogLock;

PNUIOD_ALLOCATION    ndisprotdMemoryHead = (PNUIOD_ALLOCATION)NULL;
PNUIOD_ALLOCATION    ndisprotdMemoryTail = (PNUIOD_ALLOCATION)NULL;
ULONG                ndisprotdAllocCount = 0;    // how many allocated so far (unfreed)

NDIS_SPIN_LOCK        ndisprotdMemoryLock;
BOOLEAN                ndisprotdInitDone = FALSE;


PVOID
ndisprotAuditAllocMem(
    PVOID    pPointer,
    ULONG    Size,
    ULONG    FileNumber,
    ULONG    LineNumber
)
{
    PVOID                pBuffer;
    PNUIOD_ALLOCATION    pAllocInfo;

    if (!ndisprotdInitDone)
    {
        NdisAllocateSpinLock(&(ndisprotdMemoryLock));
        ndisprotdInitDone = TRUE;
    }

    NdisAllocateMemoryWithTag(
        (PVOID *)&pAllocInfo,
        Size+sizeof(NUIOD_ALLOCATION),
        (ULONG)'oiuN'
    );

    if (pAllocInfo == (PNUIOD_ALLOCATION)NULL)
    {
        DEBUGP(DL_VERY_LOUD+50,
            ("ndisprotAuditAllocMem: file %d, line %d, Size %d failed!\n",
                FileNumber, LineNumber, Size));
        pBuffer = NULL;
    }
    else
    {
        pBuffer = (PVOID)&(pAllocInfo->UserData);
        NPROT_SET_MEM(pBuffer, 0xaf, Size);
        pAllocInfo->Signature = NUIOD_MEMORY_SIGNATURE;
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = (ULONG_PTR)pPointer;
        pAllocInfo->Next = (PNUIOD_ALLOCATION)NULL;

        NdisAcquireSpinLock(&(ndisprotdMemoryLock));

        pAllocInfo->Prev = ndisprotdMemoryTail;
        if (ndisprotdMemoryTail == (PNUIOD_ALLOCATION)NULL)
        {
            // empty list
            ndisprotdMemoryHead = ndisprotdMemoryTail = pAllocInfo;
        }
        else
        {
            ndisprotdMemoryTail->Next = pAllocInfo;
        }
        ndisprotdMemoryTail = pAllocInfo;
        
        ndisprotdAllocCount++;
        NdisReleaseSpinLock(&(ndisprotdMemoryLock));
    }

    DEBUGP(DL_VERY_LOUD+100,
     ("ndisprotAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
                 (CHAR)(FileNumber & 0xff),
                 (CHAR)((FileNumber >> 8) & 0xff),
                 (CHAR)((FileNumber >> 16) & 0xff),
                 (CHAR)((FileNumber >> 24) & 0xff),
                LineNumber, Size, pPointer, pBuffer));

    return (pBuffer);

}


VOID
ndisprotAuditFreeMem(
    PVOID    Pointer
)
{
    PNUIOD_ALLOCATION    pAllocInfo;

    NdisAcquireSpinLock(&(ndisprotdMemoryLock));

    pAllocInfo = CONTAINING_RECORD(Pointer, NUIOD_ALLOCATION, UserData);

    if (pAllocInfo->Signature != NUIOD_MEMORY_SIGNATURE)
    {
        DEBUGP(DL_ERROR,
         ("ndisprotAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
        NdisReleaseSpinLock(&(ndisprotdMemoryLock));
#if DBG
        DbgBreakPoint();
#endif
        return;
    }

    pAllocInfo->Signature = (ULONG)'DEAD';
    if (pAllocInfo->Prev != (PNUIOD_ALLOCATION)NULL)
    {
        pAllocInfo->Prev->Next = pAllocInfo->Next;
    }
    else
    {
        ndisprotdMemoryHead = pAllocInfo->Next;
    }
    if (pAllocInfo->Next != (PNUIOD_ALLOCATION)NULL)
    {
        pAllocInfo->Next->Prev = pAllocInfo->Prev;
    }
    else
    {
        ndisprotdMemoryTail = pAllocInfo->Prev;
    }
    ndisprotdAllocCount--;
    NdisReleaseSpinLock(&(ndisprotdMemoryLock));

    NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
ndisprotAuditShutdown(
    VOID
)
{
    if (ndisprotdInitDone)
    {
        if (ndisprotdAllocCount != 0)
        {
            DEBUGP(DL_ERROR, ("AuditShutdown: unfreed memory, %d blocks!\n",
                    ndisprotdAllocCount));
            DEBUGP(DL_ERROR, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
                    ndisprotdMemoryHead, ndisprotdMemoryTail));
            DbgBreakPoint();
            {
                PNUIOD_ALLOCATION        pAllocInfo;

                while (ndisprotdMemoryHead != (PNUIOD_ALLOCATION)NULL)
                {
                    pAllocInfo = ndisprotdMemoryHead;
                    DEBUGP(DL_INFO, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
                    ndisprotAuditFreeMem(&(pAllocInfo->UserData));
                }
            }
        }
        ndisprotdInitDone = FALSE;
    }
}

#define MAX_HD_LENGTH        128

VOID
DbgPrintHexDump(
    IN    PUCHAR            pBuffer,
    IN    ULONG            Length
)
/*++

Routine Description:

    Print a hex dump of the given contiguous buffer. If the length
    is too long, we truncate it.

Arguments:

    pBuffer            - Points to start of data to be dumped
    Length            - Length of above.

Return Value:

    None

--*/
{
    ULONG        i;

    if (Length > MAX_HD_LENGTH)
    {
        Length = MAX_HD_LENGTH;
    }

    for (i = 0; i < Length; i++)
    {
        //
        //  Check if we are at the end of a line
        //
        if ((i > 0) && ((i & 0xf) == 0))
        {
            DbgPrint("\n");
        }

        //
        //  Print addr if we are at start of a new line
        //
        if ((i & 0xf) == 0)
        {
            DbgPrint("%08x ", pBuffer);
        }

        DbgPrint(" %02x", *pBuffer++);
    }

    //
    //  Terminate the last line.
    //
    if (Length > 0)
    {
        DbgPrint("\n");
    }
}
#endif // DBG


#if DBG_SPIN_LOCK
ULONG    ndisprotdSpinLockInitDone = 0;
NDIS_SPIN_LOCK    ndisprotdLockLock;

VOID
ndisprotAllocateSpinLock(
    IN    PNPROT_LOCK        pLock,
    IN    ULONG                FileNumber,
    IN    ULONG                LineNumber
)
{
    if (ndisprotdSpinLockInitDone == 0)
    {
        ndisprotdSpinLockInitDone = 1;
        NdisAllocateSpinLock(&(ndisprotdLockLock));
    }

    NdisAcquireSpinLock(&(ndisprotdLockLock));
    pLock->Signature = NUIOL_SIG;
    pLock->TouchedByFileNumber = FileNumber;
    pLock->TouchedInLineNumber = LineNumber;
    pLock->IsAcquired = 0;
    pLock->OwnerThread = 0;
    NdisAllocateSpinLock(&(pLock->NdisLock));
    NdisReleaseSpinLock(&(ndisprotdLockLock));
}


VOID
ndisprotAcquireSpinLock(
    IN    PNPROT_LOCK        pLock,
    IN    ULONG                FileNumber,
    IN    ULONG                LineNumber
)
{
    PKTHREAD        pThread;

    pThread = KeGetCurrentThread();
    NdisAcquireSpinLock(&(ndisprotdLockLock));
    if (pLock->Signature != NUIOL_SIG)
    {
        DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                pLock,
                (CHAR)(FileNumber & 0xff),
                (CHAR)((FileNumber >> 8) & 0xff),
                (CHAR)((FileNumber >> 16) & 0xff),
                (CHAR)((FileNumber >> 24) & 0xff),
                LineNumber);
        DbgBreakPoint();
    }

    if (pLock->IsAcquired != 0)
    {
        if (pLock->OwnerThread == pThread)
        {
            DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
                pLock,
                (CHAR)(FileNumber & 0xff),
                (CHAR)((FileNumber >> 8) & 0xff),
                (CHAR)((FileNumber >> 16) & 0xff),
                (CHAR)((FileNumber >> 24) & 0xff),
                LineNumber);
            DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
                pLock,
                (CHAR)(pLock->TouchedByFileNumber & 0xff),
                (CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
                (CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
                (CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
                pLock->TouchedInLineNumber);
            DbgBreakPoint();
        }
    }

    pLock->IsAcquired++;

    NdisReleaseSpinLock(&(ndisprotdLockLock));
    NdisAcquireSpinLock(&(pLock->NdisLock));

    //
    //  Mark this lock.
    //
    pLock->OwnerThread = pThread;
    pLock->TouchedByFileNumber = FileNumber;
    pLock->TouchedInLineNumber = LineNumber;
}


VOID
ndisprotReleaseSpinLock(
    IN    PNPROT_LOCK        pLock,
    IN    ULONG                FileNumber,
    IN    ULONG                LineNumber
)
{
    NdisDprAcquireSpinLock(&(ndisprotdLockLock));
    if (pLock->Signature != NUIOL_SIG)
    {
        DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                pLock,
                (CHAR)(FileNumber & 0xff),
                (CHAR)((FileNumber >> 8) & 0xff),
                (CHAR)((FileNumber >> 16) & 0xff),
                (CHAR)((FileNumber >> 24) & 0xff),
                LineNumber);
        DbgBreakPoint();
    }

    if (pLock->IsAcquired == 0)
    {
        DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
                pLock,
                (CHAR)(FileNumber & 0xff),
                (CHAR)((FileNumber >> 8) & 0xff),
                (CHAR)((FileNumber >> 16) & 0xff),
                (CHAR)((FileNumber >> 24) & 0xff),
                LineNumber);
        DbgBreakPoint();
    }
    pLock->TouchedByFileNumber = FileNumber;
    pLock->TouchedInLineNumber = LineNumber;
    pLock->IsAcquired--;
    pLock->OwnerThread = 0;
    NdisDprReleaseSpinLock(&(ndisprotdLockLock));

    NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\ndisprot.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndisprot.h

Abstract:

    Data structures, defines and function prototypes for NDISPROT.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/

#ifndef __NDISPROT__H
#define __NDISPROT__H


#define NT_DEVICE_NAME          L"\\Device\\NdisProt"
#define DOS_DEVICE_NAME         L"\\DosDevices\\NdisProt"

//
//  Abstract types
//
typedef NDIS_EVENT              NPROT_EVENT;


#define NPROT_MAC_ADDR_LEN            6

//
//  The Open Context represents an open of our device object.
//  We allocate this on processing a BindAdapter from NDIS,
//  and free it when all references (see below) to it are gone.
//
//  Binding/unbinding to an NDIS device:
//
//  On processing a BindAdapter call from NDIS, we set up a binding
//  to the specified NDIS device (miniport). This binding is
//  torn down when NDIS asks us to Unbind by calling
//  our UnbindAdapter handler.
//
//  Receiving data:
//
//  While an NDIS binding exists, read IRPs are queued on this
//  structure, to be processed when packets are received.
//  If data arrives in the absense of a pended read IRP, we
//  queue it, to the extent of one packet, i.e. we save the
//  contents of the latest packet received. We fail read IRPs
//  received when no NDIS binding exists (or is in the process
//  of being torn down).
//
//  Sending data:
//
//  Write IRPs are used to send data. Each write IRP maps to
//  a single NDIS packet. Packet send-completion is mapped to
//  write IRP completion. We use NDIS 5.1 CancelSend to support
//  write IRP cancellation. Write IRPs that arrive when we don't
//  have an active NDIS binding are failed.
//
//  Reference count:
//
//  The following are long-lived references:
//  OPEN_DEVICE ioctl (goes away on processing a Close IRP)
//  Pended read IRPs
//  Queued received packets
//  Uncompleted write IRPs (outstanding sends)
//  Existence of NDIS binding
//
typedef struct _NDISPROT_OPEN_CONTEXT
{
    LIST_ENTRY              Link;           // Link into global list
    ULONG                   Flags;          // State information
    ULONG                   RefCount;
    NPROT_LOCK               Lock;

    PFILE_OBJECT            pFileObject;    // Set on OPEN_DEVICE

    NDIS_HANDLE             BindingHandle;
    NDIS_HANDLE             SendPacketPool;
    NDIS_HANDLE             SendBufferPool;
    NDIS_HANDLE             RecvPacketPool;
    NDIS_HANDLE             RecvBufferPool;
    ULONG                   MacOptions;
    ULONG                   MaxFrameSize;

    LIST_ENTRY              PendedWrites;   // pended Write IRPs
    ULONG                   PendedSendCount;

    LIST_ENTRY              PendedReads;    // pended Read IRPs
    ULONG                   PendedReadCount;
    LIST_ENTRY              RecvPktQueue;   // queued rcv packets
    ULONG                   RecvPktCount;

    NET_DEVICE_POWER_STATE  PowerState;
    NDIS_EVENT              PoweredUpEvent; // signalled iff PowerState is D0
    NDIS_STRING             DeviceName;     // used in NdisOpenAdapter
    NDIS_STRING                DeviceDescr;    // friendly name

    NDIS_STATUS             BindStatus;     // for Open/CloseAdapter
    NPROT_EVENT              BindEvent;      // for Open/CloseAdapter

    BOOLEAN                 bRunningOnWin9x;// TRUE if Win98/SE/ME, FALSE if NT

    ULONG                   oc_sig;         // Signature for sanity

    UCHAR                   CurrentAddress[NPROT_MAC_ADDR_LEN];

} NDISPROT_OPEN_CONTEXT, *PNDISPROT_OPEN_CONTEXT;

#define oc_signature        'OiuN'

//
//  Definitions for Flags above.
//
#define NUIOO_BIND_IDLE             0x00000000
#define NUIOO_BIND_OPENING          0x00000001
#define NUIOO_BIND_FAILED           0x00000002
#define NUIOO_BIND_ACTIVE           0x00000004
#define NUIOO_BIND_CLOSING          0x00000008
#define NUIOO_BIND_FLAGS            0x0000000F  // State of the binding

#define NUIOO_OPEN_IDLE             0x00000000
#define NUIOO_OPEN_ACTIVE           0x00000010
#define NUIOO_OPEN_FLAGS            0x000000F0  // State of the I/O open

#define NUIOO_RESET_IN_PROGRESS     0x00000100
#define NUIOO_NOT_RESETTING         0x00000000
#define NUIOO_RESET_FLAGS           0x00000100

#define NUIOO_MEDIA_CONNECTED       0x00000000
#define NUIOO_MEDIA_DISCONNECTED    0x00000200
#define NUIOO_MEDIA_FLAGS           0x00000200

#define NUIOO_READ_SERVICING        0x00100000  // Is the read service
                                                // routine running?
#define NUIOO_READ_FLAGS            0x00100000

#define NUIOO_UNBIND_RECEIVED       0x10000000  // Seen NDIS Unbind?
#define NUIOO_UNBIND_FLAGS          0x10000000


//
//  Globals:
//
typedef struct _NDISPROT_GLOBALS
{
    PDRIVER_OBJECT          pDriverObject;
    PDEVICE_OBJECT          ControlDeviceObject;
    NDIS_HANDLE             NdisProtocolHandle;
    UCHAR                   PartialCancelId;    // for cancelling sends
    ULONG                   LocalCancelId;
    LIST_ENTRY              OpenList;           // of OPEN_CONTEXT structures
    NPROT_LOCK               GlobalLock;         // to protect the above
    NPROT_EVENT              BindsComplete;      // have we seen NetEventBindsComplete?

} NDISPROT_GLOBALS, *PNDISPROT_GLOBALS;



//
//  NDIS Request context structure
//
typedef struct _NDISPROT_REQUEST
{
    NDIS_REQUEST            Request;
    NPROT_EVENT              ReqEvent;
    ULONG                   Status;

} NDISPROT_REQUEST, *PNDISPROT_REQUEST;


#define NUIOO_PACKET_FILTER  (NDIS_PACKET_TYPE_DIRECTED|    \
                              NDIS_PACKET_TYPE_MULTICAST|   \
                              NDIS_PACKET_TYPE_BROADCAST)

//
//  Send packet pool bounds
//
#define MIN_SEND_PACKET_POOL_SIZE    20
#define MAX_SEND_PACKET_POOL_SIZE    400

//
//  ProtocolReserved in sent packets. We save a pointer to the IRP
//  that generated the send.
//
//  The RefCount is used to determine when to free the packet back
//  to its pool. It is used to synchronize between a thread completing
//  a send and a thread attempting to cancel a send.
//
typedef struct _NPROT_SEND_PACKET_RSVD
{
    PIRP                    pIrp;
    ULONG                   RefCount;

} NPROT_SEND_PACKET_RSVD, *PNPROT_SEND_PACKET_RSVD;

//
//  Receive packet pool bounds
//
#define MIN_RECV_PACKET_POOL_SIZE    4
#define MAX_RECV_PACKET_POOL_SIZE    20

//
//  Max receive packets we allow to be queued up
//
#define MAX_RECV_QUEUE_SIZE          4

//
//  ProtocolReserved in received packets: we link these
//  packets up in a queue waiting for Read IRPs.
//
typedef struct _NPROT_RECV_PACKET_RSVD
{
    LIST_ENTRY              Link;
    PNDIS_BUFFER            pOriginalBuffer;    // used if we had to partial-map

} NPROT_RECV_PACKET_RSVD, *PNPROT_RECV_PACKET_RSVD;



#include <pshpack1.h>

typedef struct _NDISPROT_ETH_HEADER
{
    UCHAR       DstAddr[NPROT_MAC_ADDR_LEN];
    UCHAR       SrcAddr[NPROT_MAC_ADDR_LEN];
    USHORT      EthType;

} NDISPROT_ETH_HEADER;

typedef struct _NDISPROT_ETH_HEADER UNALIGNED * PNDISPROT_ETH_HEADER;

#include <poppack.h>


extern NDISPROT_GLOBALS      Globals;


#define NPROT_ALLOC_TAG      'oiuN'


#ifndef NDIS51
#define NdisGetPoolFromPacket(_Pkt) (_Pkt->Private.Pool)
#endif

//
//  Prototypes.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    );

VOID
NdisProtUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NdisProtOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisProtClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisProtCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisProtIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
ndisprotOpenDevice(
    IN PUCHAR                   pDeviceName,
    IN ULONG                    DeviceNameLength,
    IN PFILE_OBJECT             pFileObject,
    OUT PNDISPROT_OPEN_CONTEXT * ppOpenContext
    );

VOID
ndisprotRefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisprotDerefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

#if DBG
VOID
ndisprotDbgRefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );

VOID
ndisprotDbgDerefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );
#endif // DBG

VOID
NdisProtBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  BindContext,
    IN PNDIS_STRING                 DeviceName,
    IN PVOID                        SystemSpecific1,
    IN PVOID                        SystemSpecific2
    );

VOID
NdisProtOpenAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status,
    IN NDIS_STATUS                  OpenErrorCode
    );

VOID
NdisProtUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  UnbindContext
    );

VOID
NdisProtCloseAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );


NDIS_STATUS
NdisProtPnPEventHandler(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNET_PNP_EVENT               pNetPnPEvent
    );

VOID
NdisProtProtocolUnloadHandler(
    VOID
    );

NDIS_STATUS
ndisprotCreateBinding(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

VOID
ndisprotShutdownBinding(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisprotFreeBindResources(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisprotWaitForPendingIO(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN BOOLEAN                      DoCancelReads
    );

VOID
ndisprotDoProtocolUnload(
    VOID
    );

NDIS_STATUS
ndisprotDoRequest(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed
    );

NDIS_STATUS
ndisprotValidateOpenAndDoRequest(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed,
    IN BOOLEAN                      bWaitForPowerOn
    );

VOID
NdisProtResetComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );

VOID
NdisProtRequestComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_REQUEST                pNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
NdisProtStatus(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  GeneralStatus,
    IN PVOID                        StatusBuffer,
    IN UINT                         StatusBufferSize
    );

VOID
NdisProtStatusComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

NDIS_STATUS
ndisprotQueryBinding(
    IN PUCHAR                       pBuffer,
    IN ULONG                        InputLength,
    IN ULONG                        OutputLength,
    OUT PULONG                      pBytesReturned
    );

PNDISPROT_OPEN_CONTEXT
ndisprotLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

NDIS_STATUS
ndisprotQueryOidValue(
    IN  PNDISPROT_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    );

NDIS_STATUS
ndisprotSetOidValue(
    IN  PNDISPROT_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    );


NTSTATUS
NdisProtRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );


VOID
NdisProtCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
ndisprotServiceReads(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

NDIS_STATUS
NdisProtReceive(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  MacReceiveContext,
    IN PVOID                        pHeaderBuffer,
    IN UINT                         HeaderBufferSize,
    IN PVOID                        pLookaheadBuffer,
    IN UINT                         LookaheadBufferSize,
    IN UINT                         PacketSize
    );

VOID
NdisProtTransferDataComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  TransferStatus,
    IN UINT                         BytesTransferred
    );

VOID
NdisProtReceiveComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

INT
NdisProtReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisprotShutdownBinding(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisprotQueueReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pRcvPacket
    );

PNDIS_PACKET
ndisprotAllocateReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN UINT                         DataLength,
    OUT PUCHAR *                    ppDataBuffer
    );

VOID
ndisprotFreeReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisprotCancelPendingReads(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisprotFlushReceiveQueue(
    IN PNDISPROT_OPEN_CONTEXT            pOpenContext
    );

NTSTATUS
NdisProtWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
NdisProtCancelWrite(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
NdisProtSendComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  Status
    );

#ifdef EX_CALLBACK

BOOLEAN 
ndisprotRegisterExCallBack();

VOID 
ndisprotUnregisterExCallBack();

VOID
ndisprotCallback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   NotifyPresenceCallback
    );

#else

#define ndisprotRegisterExCallBack() TRUE
#define ndisprotUnregisterExCallBack() 

#endif

#endif // __NDISPROT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\ndisbind.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndisbind.c

Abstract:

    NDIS protocol entry points and utility routines to handle binding
    and unbinding from adapters.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/


#include "precomp.h"

#define __FILENUMBER 'DNIB'

VOID
NdisProtBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  BindContext,
    IN PNDIS_STRING                 pDeviceName,
    IN PVOID                        SystemSpecific1,
    IN PVOID                        SystemSpecific2
    )
/*++

Routine Description:

    Protocol Bind Handler entry point called when NDIS wants us
    to bind to an adapter. We go ahead and set up a binding.
    An OPEN_CONTEXT structure is allocated to keep state about
    this binding.

Arguments:

    pStatus - place to return bind status
    BindContext - handle to use with NdisCompleteBindAdapter
    DeviceName - adapter to bind to
    SystemSpecific1 - used to access protocol-specific registry
                 key for this binding
    SystemSpecific2 - unused

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT           pOpenContext;
    NDIS_STATUS                     Status, ConfigStatus;
    NDIS_HANDLE                     ConfigHandle;

    UNREFERENCED_PARAMETER(BindContext);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    
    do
    {
        //
        //  Allocate our context for this open.
        //
        NPROT_ALLOC_MEM(pOpenContext, sizeof(NDISPROT_OPEN_CONTEXT));
        if (pOpenContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Initialize it.
        //
        NPROT_ZERO_MEM(pOpenContext, sizeof(NDISPROT_OPEN_CONTEXT));
        NPROT_SET_SIGNATURE(pOpenContext, oc);

        NPROT_INIT_LOCK(&pOpenContext->Lock);
        NPROT_INIT_LIST_HEAD(&pOpenContext->PendedReads);
        NPROT_INIT_LIST_HEAD(&pOpenContext->PendedWrites);
        NPROT_INIT_LIST_HEAD(&pOpenContext->RecvPktQueue);
        NPROT_INIT_EVENT(&pOpenContext->PoweredUpEvent);

        //
        //  Start off by assuming that the device below is powered up.
        //
        NPROT_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);

        //
        //  Determine the platform we are running on.
        //
        pOpenContext->bRunningOnWin9x = TRUE;

        NdisOpenProtocolConfiguration(
            &ConfigStatus,
            &ConfigHandle,
            (PNDIS_STRING)SystemSpecific1);
        
        if (ConfigStatus == NDIS_STATUS_SUCCESS)
        {
            PNDIS_CONFIGURATION_PARAMETER   pParameter;
            NDIS_STRING                     VersionKey = NDIS_STRING_CONST("Environment");

            NdisReadConfiguration(
                &ConfigStatus,
                &pParameter,
                ConfigHandle,
                &VersionKey,
                NdisParameterInteger);
            
            if ((ConfigStatus == NDIS_STATUS_SUCCESS) &&
                ((pParameter->ParameterType == NdisParameterInteger) ||
                 (pParameter->ParameterType == NdisParameterHexInteger)))
            {
                pOpenContext->bRunningOnWin9x =
                    (pParameter->ParameterData.IntegerData == NdisEnvironmentWindows);
            }

            NdisCloseConfiguration(ConfigHandle);
        }

        NPROT_REF_OPEN(pOpenContext); // Bind

        //
        //  Add it to the global list.
        //
        NPROT_ACQUIRE_LOCK(&Globals.GlobalLock);

        NPROT_INSERT_TAIL_LIST(&Globals.OpenList,
                             &pOpenContext->Link);

        NPROT_RELEASE_LOCK(&Globals.GlobalLock);

        //
        //  Set up the NDIS binding.
        //
        Status = ndisprotCreateBinding(
                     pOpenContext,
                     (PUCHAR)pDeviceName->Buffer,
                     pDeviceName->Length);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
    }
    while (FALSE);

    *pStatus = Status;

    return;
}


VOID
NdisProtOpenAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status,
    IN NDIS_STATUS                  OpenErrorCode
    )
/*++

Routine Description:

    Completion routine called by NDIS if our call to NdisOpenAdapter
    pends. Wake up the thread that called NdisOpenAdapter.

Arguments:

    ProtocolBindingContext - pointer to open context structure
    Status - status of the open
    OpenErrorCode - if unsuccessful, additional information

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT           pOpenContext;

    UNREFERENCED_PARAMETER(OpenErrorCode);
    
    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    pOpenContext->BindStatus = Status;

    NPROT_SIGNAL_EVENT(&pOpenContext->BindEvent);
}


VOID
NdisProtUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  UnbindContext
    )
/*++

Routine Description:

    NDIS calls this when it wants us to close the binding to an adapter.

Arguments:

    pStatus - place to return status of Unbind
    ProtocolBindingContext - pointer to open context structure
    UnbindContext - to use in NdisCompleteUnbindAdapter if we return pending

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT           pOpenContext;

    UNREFERENCED_PARAMETER(UnbindContext);
    
    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Mark this open as having seen an Unbind.
    //
    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED);

    //
    //  In case we had threads blocked for the device below to be powered
    //  up, wake them up.
    //
    NPROT_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    ndisprotShutdownBinding(pOpenContext);

    *pStatus = NDIS_STATUS_SUCCESS;
    return;
}


VOID
NdisProtCloseAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    Called by NDIS to complete a pended call to NdisCloseAdapter.
    We wake up the thread waiting for this completion.

Arguments:

    ProtocolBindingContext - pointer to open context structure
    Status - Completion status of NdisCloseAdapter

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT           pOpenContext;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    pOpenContext->BindStatus = Status;

    NPROT_SIGNAL_EVENT(&pOpenContext->BindEvent);
}

    
NDIS_STATUS
NdisProtPnPEventHandler(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNET_PNP_EVENT               pNetPnPEvent
    )
/*++

Routine Description:

    Called by NDIS to notify us of a PNP event. The most significant
    one for us is power state change.

Arguments:

    ProtocolBindingContext - pointer to open context structure
                this is NULL for global reconfig events.

    pNetPnPEvent - pointer to the PNP event

Return Value:

    Our processing status for the PNP event.

--*/
{
    PNDISPROT_OPEN_CONTEXT           pOpenContext;
    NDIS_STATUS                     Status;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;

    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventSetPower:
            NPROT_STRUCT_ASSERT(pOpenContext, oc);
            pOpenContext->PowerState = *(PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

            if (pOpenContext->PowerState > NetDeviceStateD0)
            {
                //
                //  The device below is transitioning to a low power state.
                //  Block any threads attempting to query the device while
                //  in this state.
                //
                NPROT_INIT_EVENT(&pOpenContext->PoweredUpEvent);

                //
                //  Wait for any I/O in progress to complete.
                //
                ndisprotWaitForPendingIO(pOpenContext, FALSE);

                //
                //  Return any receives that we had queued up.
                //
                ndisprotFlushReceiveQueue(pOpenContext);
                DEBUGP(DL_INFO, ("PnPEvent: Open %p, SetPower to %d\n",
                    pOpenContext, pOpenContext->PowerState));
            }
            else
            {
                //
                //  The device below is powered up.
                //
                DEBUGP(DL_INFO, ("PnPEvent: Open %p, SetPower ON: %d\n",
                    pOpenContext, pOpenContext->PowerState));
                NPROT_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);
            }

            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventQueryPower:
            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventBindsComplete:
            
            NPROT_SIGNAL_EVENT(&Globals.BindsComplete);
            if(!ndisprotRegisterExCallBack()){
                DEBUGP(DL_ERROR, ("DriverEntry: ndisprotRegisterExCallBack failed\n"));
            }                    
            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventQueryRemoveDevice:
        case NetEventCancelRemoveDevice:
        case NetEventReconfigure:
        case NetEventBindList:
        case NetEventPnPCapabilities:
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    DEBUGP(DL_INFO, ("PnPEvent: Open %p, Event %d, Status %x\n",
            pOpenContext, pNetPnPEvent->NetEvent, Status));

    return (Status);
}
    
VOID
NdisProtProtocolUnloadHandler(
    VOID
    )
/*++

Routine Description:

    NDIS calls this on a usermode request to uninstall us.

Arguments:

    None

Return Value:

    None

--*/
{
    ndisprotDoProtocolUnload();
}

NDIS_STATUS
ndisprotCreateBinding(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    )
/*++

Routine Description:

    Utility function to create an NDIS binding to the indicated device,
    if no such binding exists.

    Here is where we also allocate additional resources (e.g. packet pool)
    for the binding.

    Things to take care of:
    1. Is another thread doing this (or has finished binding) already?
    2. Is the binding being closed at this time?
    3. NDIS calls our Unbind handler while we are doing this.

    These precautions are not needed if this routine is only called from
    the context of our BindAdapter handler, but they are here in case
    we initiate binding from elsewhere (e.g. on processing a user command).

    NOTE: this function blocks and finishes synchronously.

Arguments:

    pOpenContext - pointer to open context block
    pBindingInfo - pointer to unicode device name string
    BindingInfoLength - length in bytes of the above.

Return Value:

    NDIS_STATUS_SUCCESS if a binding was successfully set up.
    NDIS_STATUS_XXX error code on any failure.

--*/
{
    NDIS_STATUS             Status;
    NDIS_STATUS             OpenErrorCode;
    NDIS_MEDIUM             MediumArray[1] = {NdisMedium802_3};
    UINT                    SelectedMediumIndex;
    PNDISPROT_OPEN_CONTEXT   pTmpOpenContext;
    BOOLEAN                 fDoNotDisturb = FALSE;
    BOOLEAN                 fOpenComplete = FALSE;
    ULONG                   BytesProcessed;
    ULONG                   GenericUlong = 0;

    DEBUGP(DL_LOUD, ("CreateBinding: open %p/%x, device [%ws]\n",
                pOpenContext, pOpenContext->Flags, pBindingInfo));

    Status = NDIS_STATUS_SUCCESS;

    do
    {
        //
        //  Check if we already have a binding to this device.
        //
        pTmpOpenContext = ndisprotLookupDevice(pBindingInfo, BindingInfoLength);

        if (pTmpOpenContext != NULL)
        {
            DEBUGP(DL_WARN,
                ("CreateBinding: Binding to device %ws already exists on open %p\n",
                    pTmpOpenContext->DeviceName.Buffer, pTmpOpenContext));

            NPROT_DEREF_OPEN(pTmpOpenContext);  // temp ref added by Lookup
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if this open context is already bound/binding/closing.
        //
        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE) ||
            NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED))
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            Status = NDIS_STATUS_NOT_ACCEPTED;

            //
            // Make sure we don't abort this binding on failure cleanup.
            //
            fDoNotDisturb = TRUE;

            break;
        }

        NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Copy in the device name. Add room for a NULL terminator.
        //
        NPROT_ALLOC_MEM(pOpenContext->DeviceName.Buffer, BindingInfoLength + sizeof(WCHAR));
        if (pOpenContext->DeviceName.Buffer == NULL)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc device name buf (%d bytes)\n",
                BindingInfoLength + sizeof(WCHAR)));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NPROT_COPY_MEM(pOpenContext->DeviceName.Buffer, pBindingInfo, BindingInfoLength);
        *(PWCHAR)((PUCHAR)pOpenContext->DeviceName.Buffer + BindingInfoLength) = L'\0';
        NdisInitUnicodeString(&pOpenContext->DeviceName, pOpenContext->DeviceName.Buffer);

        //
        //  Allocate packet pools.
        //
        NdisAllocatePacketPoolEx(
            &Status,
            &pOpenContext->SendPacketPool,
            MIN_SEND_PACKET_POOL_SIZE,
            MAX_SEND_PACKET_POOL_SIZE - MIN_SEND_PACKET_POOL_SIZE,
            sizeof(NPROT_SEND_PACKET_RSVD));
       
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " send packet pool: %x\n", Status));
            break;
        }


        NdisAllocatePacketPoolEx(
            &Status,
            &pOpenContext->RecvPacketPool,
            MIN_RECV_PACKET_POOL_SIZE,
            MAX_RECV_PACKET_POOL_SIZE - MIN_RECV_PACKET_POOL_SIZE,
            sizeof(NPROT_RECV_PACKET_RSVD));
       
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " recv packet pool: %x\n", Status));
            break;
        }

        //
        //  Buffer pool for receives.
        //
        NdisAllocateBufferPool(
            &Status,
            &pOpenContext->RecvBufferPool,
            MAX_RECV_PACKET_POOL_SIZE);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " recv buffer pool: %x\n", Status));
            break;
        }

        //
        //  If we are running on Win9X, allocate a buffer pool for sends
        //  as well, since we can't simply cast MDLs to NDIS_BUFFERs.
        //
        if (pOpenContext->bRunningOnWin9x)
        {
            NdisAllocateBufferPool(
                &Status,
                &pOpenContext->SendBufferPool,
                MAX_SEND_PACKET_POOL_SIZE);
            
            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                        " send buffer pool: %x\n", Status));
                break;
            }
        }
        //
        //  Assume that the device is powered up.
        //
        pOpenContext->PowerState = NetDeviceStateD0;

        //
        //  Open the adapter.
        //
        NPROT_INIT_EVENT(&pOpenContext->BindEvent);

        NdisOpenAdapter(
            &Status,
            &OpenErrorCode,
            &pOpenContext->BindingHandle,
            &SelectedMediumIndex,
            &MediumArray[0],
            sizeof(MediumArray) / sizeof(NDIS_MEDIUM),
            Globals.NdisProtocolHandle,
            (NDIS_HANDLE)pOpenContext,
            &pOpenContext->DeviceName,
            0,
            NULL);
    
        if (Status == NDIS_STATUS_PENDING)
        {
            NPROT_WAIT_EVENT(&pOpenContext->BindEvent, 0);
            Status = pOpenContext->BindStatus;
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: NdisOpenAdapter (%ws) failed: %x\n",
                pOpenContext->DeviceName.Buffer, Status));
            break;
        }

        //
        //  Note down the fact that we have successfully bound.
        //  We don't update the state on the open just yet - this
        //  is to prevent other threads from shutting down the binding.
        //
        fOpenComplete = TRUE;

        //
        //  Get the friendly name for the adapter. It is not fatal for this
        //  to fail.
        //
        (VOID)NdisQueryAdapterInstanceName(
                &pOpenContext->DeviceDescr,
                pOpenContext->BindingHandle
                );
        //
        // Get Current address
        //
        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_802_3_CURRENT_ADDRESS,
                    &pOpenContext->CurrentAddress[0],
                    NPROT_MAC_ADDR_LEN,
                    &BytesProcessed
                    );
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry current address failed: %x\n",
                    Status));
            break;
        }
        
        //
        //  Get MAC options.
        //
        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MAC_OPTIONS,
                    &pOpenContext->MacOptions,
                    sizeof(pOpenContext->MacOptions),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry MAC options failed: %x\n",
                    Status));
            break;
        }

        //
        //  Get the max frame size.
        //
        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MAXIMUM_FRAME_SIZE,
                    &pOpenContext->MaxFrameSize,
                    sizeof(pOpenContext->MaxFrameSize),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry max frame failed: %x\n",
                    Status));
            break;
        }

        //
        //  Get the media connect status.
        //
        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MEDIA_CONNECT_STATUS,
                    &GenericUlong,
                    sizeof(GenericUlong),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry media connect status failed: %x\n",
                    Status));
            break;
        }

        if (GenericUlong == NdisMediaStateConnected)
        {
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_CONNECTED);
        }
        else
        {
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_DISCONNECTED);
        }



        //
        //  Mark this open. Also check if we received an Unbind while
        //  we were setting this up.
        //
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);

        //
        //  Did an unbind happen in the meantime?
        //
        if (NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED))
        {
            Status = NDIS_STATUS_FAILURE;
        }

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);
       
    }
    while (FALSE);

    if ((Status != NDIS_STATUS_SUCCESS) && !fDoNotDisturb)
    {
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if we had actually finished opening the adapter.
        //
        if (fOpenComplete)
        {
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);
        }
        else if (NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING))
        {
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_FAILED);
        }

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        ndisprotShutdownBinding(pOpenContext);
    }

    DEBUGP(DL_INFO, ("CreateBinding: OpenContext %p, Status %x\n",
            pOpenContext, Status));

    return (Status);
}



VOID
ndisprotShutdownBinding(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Utility function to shut down the NDIS binding, if one exists, on
    the specified open. This is written to be called from:

        ndisprotCreateBinding - on failure
        NdisProtUnbindAdapter

    We handle the case where a binding is in the process of being set up.
    This precaution is not needed if this routine is only called from
    the context of our UnbindAdapter handler, but they are here in case
    we initiate unbinding from elsewhere (e.g. on processing a user command).

    NOTE: this blocks and finishes synchronously.

Arguments:

    pOpenContext - pointer to open context block

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    BOOLEAN                 DoCloseBinding = FALSE;

    do
    {
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING))
        {
            //
            //  We are still in the process of setting up this binding.
            //
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
            break;
        }

        if (NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_CLOSING);
            DoCloseBinding = TRUE;
        }

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        if (DoCloseBinding)
        {
            ULONG    PacketFilter = 0;
            ULONG    BytesRead = 0;
            
            //
            // Set Packet filter to 0 before closing the binding
            // 
            Status = ndisprotDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesRead);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("ShutDownBinding: set packet filter failed: %x\n", Status));
            }
            
            //
            // Set multicast list to null before closing the binding
            // 
            Status = ndisprotDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_802_3_MULTICAST_LIST,
                        NULL,
                        0,
                        &BytesRead);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("ShutDownBinding: set multicast list failed: %x\n", Status));
            }
                
            //
            //  Wait for any pending sends or requests on
            //  the binding to complete.
            //
            ndisprotWaitForPendingIO(pOpenContext, TRUE);

            //
            //  Discard any queued receives.
            //
            ndisprotFlushReceiveQueue(pOpenContext);

            //
            //  Close the binding now.
            //
            NPROT_INIT_EVENT(&pOpenContext->BindEvent);

            DEBUGP(DL_INFO, ("ShutdownBinding: Closing OpenContext %p,"
                    " BindingHandle %p\n",
                    pOpenContext, pOpenContext->BindingHandle));

            NdisCloseAdapter(&Status, pOpenContext->BindingHandle);

            if (Status == NDIS_STATUS_PENDING)
            {
                NPROT_WAIT_EVENT(&pOpenContext->BindEvent, 0);
                Status = pOpenContext->BindStatus;
            }

            NPROT_ASSERT(Status == NDIS_STATUS_SUCCESS);

            pOpenContext->BindingHandle = NULL;
        }

        if (DoCloseBinding)
        {
            NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE);

            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, 0);

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        }

        //
        //  Remove it from the global list.
        //
        NPROT_ACQUIRE_LOCK(&Globals.GlobalLock);

        NPROT_REMOVE_ENTRY_LIST(&pOpenContext->Link);

        NPROT_RELEASE_LOCK(&Globals.GlobalLock);

        //
        //  Free any other resources allocated for this bind.
        //
        ndisprotFreeBindResources(pOpenContext);

        NPROT_DEREF_OPEN(pOpenContext);  // Shutdown binding

    }
    while (FALSE);
}


VOID
ndisprotFreeBindResources(
    IN PNDISPROT_OPEN_CONTEXT       pOpenContext
    )
/*++

Routine Description:

    Free any resources set up for an NDIS binding.

Arguments:

    pOpenContext - pointer to open context block

Return Value:

    None

--*/
{
    if (pOpenContext->SendPacketPool != NULL)
    {
        NdisFreePacketPool(pOpenContext->SendPacketPool);
        pOpenContext->SendPacketPool = NULL;
    }

    if (pOpenContext->RecvPacketPool != NULL)
    {
        NdisFreePacketPool(pOpenContext->RecvPacketPool);
        pOpenContext->RecvPacketPool = NULL;
    }

    if (pOpenContext->RecvBufferPool != NULL)
    {
        NdisFreeBufferPool(pOpenContext->RecvBufferPool);
        pOpenContext->RecvBufferPool = NULL;
    }

    if (pOpenContext->SendBufferPool != NULL)
    {
        NdisFreeBufferPool(pOpenContext->SendBufferPool);
        pOpenContext->SendBufferPool = NULL;
    }

    if (pOpenContext->DeviceName.Buffer != NULL)
    {
        NPROT_FREE_MEM(pOpenContext->DeviceName.Buffer);
        pOpenContext->DeviceName.Buffer = NULL;
        pOpenContext->DeviceName.Length =
        pOpenContext->DeviceName.MaximumLength = 0;
    }

    if (pOpenContext->DeviceDescr.Buffer != NULL)
    {
        //
        // this would have been allocated by NdisQueryAdpaterInstanceName.
        //
        NdisFreeMemory(pOpenContext->DeviceDescr.Buffer, 0, 0);
        pOpenContext->DeviceDescr.Buffer = NULL;
    }
}


VOID
ndisprotWaitForPendingIO(
    IN PNDISPROT_OPEN_CONTEXT            pOpenContext,
    IN BOOLEAN                          DoCancelReads
    )
/*++

Routine Description:

    Utility function to wait for all outstanding I/O to complete
    on an open context. It is assumed that the open context
    won't go away while we are in this routine.

Arguments:

    pOpenContext - pointer to open context structure
    DoCancelReads - do we wait for pending reads to go away (and cancel them)?

Return Value:

    None

--*/
{
    NDIS_STATUS     Status;
    ULONG           LoopCount;
    ULONG           PendingCount;

#ifdef NDIS51
    //
    //  Wait for any pending sends or requests on the binding to complete.
    //
    for (LoopCount = 0; LoopCount < 60; LoopCount++)
    {
        Status = NdisQueryPendingIOCount(
                    pOpenContext->BindingHandle,
                    &PendingCount);

        if ((Status != NDIS_STATUS_SUCCESS) ||
            (PendingCount == 0))
        {
            break;
        }

        DEBUGP(DL_INFO, ("WaitForPendingIO: Open %p, %d pending I/O at NDIS\n",
                pOpenContext, PendingCount));

        NPROT_SLEEP(2);
    }

    NPROT_ASSERT(LoopCount < 60);

#endif // NDIS51

    //
    //  Make sure any threads trying to send have finished.
    //
    for (LoopCount = 0; LoopCount < 60; LoopCount++)
    {
        if (pOpenContext->PendedSendCount == 0)
        {
            break;
        }

        DEBUGP(DL_WARN, ("WaitForPendingIO: Open %p, %d pended sends\n",
                pOpenContext, pOpenContext->PendedSendCount));

        NPROT_SLEEP(1);
    }

    NPROT_ASSERT(LoopCount < 60);

    if (DoCancelReads)
    {
        //
        //  Wait for any pended reads to complete/cancel.
        //
        while (pOpenContext->PendedReadCount != 0)
        {
            DEBUGP(DL_INFO, ("WaitForPendingIO: Open %p, %d pended reads\n",
                pOpenContext, pOpenContext->PendedReadCount));

            //
            //  Cancel any pending reads.
            //
            ndisprotCancelPendingReads(pOpenContext);

            NPROT_SLEEP(1);
        }
    }

}


VOID
ndisprotDoProtocolUnload(
    VOID
    )
/*++

Routine Description:

    Utility routine to handle unload from the NDIS protocol side.

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_HANDLE     ProtocolHandle;
    NDIS_STATUS     Status;

    DEBUGP(DL_INFO, ("ProtocolUnload: ProtocolHandle %lx\n", 
        Globals.NdisProtocolHandle));

    if (Globals.NdisProtocolHandle != NULL)
    {
        ProtocolHandle = Globals.NdisProtocolHandle;
        Globals.NdisProtocolHandle = NULL;

        NdisDeregisterProtocol(
            &Status,
            ProtocolHandle
            );

    }
}


NDIS_STATUS
ndisprotDoRequest(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed
    )
/*++

Routine Description:

    Utility routine that forms and sends an NDIS_REQUEST to the
    miniport, waits for it to complete, and returns status
    to the caller.

    NOTE: this assumes that the calling routine ensures validity
    of the binding handle until this returns.

Arguments:

    pOpenContext - pointer to our open context
    RequestType - NdisRequest[Set|Query]Information
    Oid - the object being set/queried
    InformationBuffer - data for the request
    InformationBufferLength - length of the above
    pBytesProcessed - place to return bytes read/written

Return Value:

    Status of the set/query request

--*/
{
    NDISPROT_REQUEST             ReqContext;
    PNDIS_REQUEST               pNdisRequest = &ReqContext.Request;
    NDIS_STATUS                 Status;

    NPROT_INIT_EVENT(&ReqContext.ReqEvent);

    pNdisRequest->RequestType = RequestType;

    switch (RequestType)
    {
        case NdisRequestQueryInformation:
            pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                                    InformationBuffer;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
            break;

        case NdisRequestSetInformation:
            pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
            pNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
                                    InformationBuffer;
            pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
            break;

        default:
            NPROT_ASSERT(FALSE);
            break;
    }

    NdisRequest(&Status,
                pOpenContext->BindingHandle,
                pNdisRequest);
    

    if (Status == NDIS_STATUS_PENDING)
    {
        NPROT_WAIT_EVENT(&ReqContext.ReqEvent, 0);
        Status = ReqContext.Status;
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        *pBytesProcessed = (RequestType == NdisRequestQueryInformation)?
                            pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten:
                            pNdisRequest->DATA.SET_INFORMATION.BytesRead;
        
        //
        // The driver below should set the correct value to BytesWritten 
        // or BytesRead. But now, we just truncate the value to InformationBufferLength
        //
        if (*pBytesProcessed > InformationBufferLength)
        {
            *pBytesProcessed = InformationBufferLength;
        }
    }

    return (Status);
}


NDIS_STATUS
ndisprotValidateOpenAndDoRequest(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed,
    IN BOOLEAN                      bWaitForPowerOn
    )
/*++

Routine Description:

    Utility routine to prevalidate and reference an open context
    before calling ndisprotDoRequest. This routine makes sure
    we have a valid binding.

Arguments:

    pOpenContext - pointer to our open context
    RequestType - NdisRequest[Set|Query]Information
    Oid - the object being set/queried
    InformationBuffer - data for the request
    InformationBufferLength - length of the above
    pBytesProcessed - place to return bytes read/written
    bWaitForPowerOn - Wait for the device to be powered on if it isn't already.

Return Value:

    Status of the set/query request

--*/
{
    NDIS_STATUS             Status;

    do
    {
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("ValidateOpenAndDoRequest: request on unassociated file object!\n"));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }
               
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Proceed only if we have a binding.
        //
        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        NPROT_ASSERT(pOpenContext->BindingHandle != NULL);

        //
        //  Make sure that the binding does not go away until we
        //  are finished with the request.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        if (bWaitForPowerOn)
        {
            //
            //  Wait for the device below to be powered up.
            //  We don't wait indefinitely here - this is to avoid
            //  a PROCESS_HAS_LOCKED_PAGES bugcheck that could happen
            //  if the calling process terminates, and this IRP doesn't
            //  complete within a reasonable time. An alternative would
            //  be to explicitly handle cancellation of this IRP.
            //
            NPROT_WAIT_EVENT(&pOpenContext->PoweredUpEvent, 4500);
        }

        Status = ndisprotDoRequest(
                    pOpenContext,
                    RequestType,
                    Oid,
                    InformationBuffer,
                    InformationBufferLength,
                    pBytesProcessed);
        
        //
        //  Let go of the binding.
        //
        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);
      
    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("ValidateOpenAndDoReq: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
}


VOID
NdisProtResetComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point indicating that a protocol initiated reset
    has completed. Since we never call NdisReset(), this should
    never be called.

Arguments:

    ProtocolBindingContext - pointer to open context
    Status - status of reset completion

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER(ProtocolBindingContext);
    UNREFERENCED_PARAMETER(Status);
    
    ASSERT(FALSE);
    return;
}


VOID
NdisProtRequestComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_REQUEST                pNdisRequest,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point indicating completion of a pended NDIS_REQUEST.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisRequest - pointer to NDIS request
    Status - status of reset completion

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;
    PNDISPROT_REQUEST            pReqContext;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Get at the request context.
    //
    pReqContext = CONTAINING_RECORD(pNdisRequest, NDISPROT_REQUEST, Request);

    //
    //  Save away the completion status.
    //
    pReqContext->Status = Status;

    //
    //  Wake up the thread blocked for this request to complete.
    //
    NPROT_SIGNAL_EVENT(&pReqContext->ReqEvent);
}


VOID
NdisProtStatus(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  GeneralStatus,
    IN PVOID                        StatusBuffer,
    IN UINT                         StatusBufferSize
    )
/*++

Routine Description:

    Protocol entry point called by NDIS to indicate a change
    in status at the miniport.

    We make note of reset and media connect status indications.

Arguments:

    ProtocolBindingContext - pointer to open context
    GeneralStatus - status code
    StatusBuffer - status-specific additional information
    StatusBufferSize - size of the above

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;

    UNREFERENCED_PARAMETER(StatusBuffer);
    UNREFERENCED_PARAMETER(StatusBufferSize);
    
    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    DEBUGP(DL_INFO, ("Status: Open %p, Status %x\n",
            pOpenContext, GeneralStatus));

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    do
    {
        if (pOpenContext->PowerState != NetDeviceStateD0)
        {
            //
            //  The device is in a low power state.
            //
            DEBUGP(DL_INFO, ("Status: Open %p in power state %d,"
                " Status %x ignored\n", pOpenContext,
                pOpenContext->PowerState, GeneralStatus));
            //
            //  We continue and make note of status indications
            //
            // break;
            //

            //
            //  NOTE that any actions we take based on these
            //  status indications should take into account
            //  the current device power state.
            //
        }

        switch(GeneralStatus)
        {
            case NDIS_STATUS_RESET_START:
    
                NPROT_ASSERT(!NPROT_TEST_FLAGS(pOpenContext->Flags,
                                             NUIOO_RESET_FLAGS,
                                             NUIOO_RESET_IN_PROGRESS));

                NPROT_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_RESET_FLAGS,
                               NUIOO_RESET_IN_PROGRESS);

                break;

            case NDIS_STATUS_RESET_END:

                NPROT_ASSERT(NPROT_TEST_FLAGS(pOpenContext->Flags,
                                            NUIOO_RESET_FLAGS,
                                            NUIOO_RESET_IN_PROGRESS));
   
                NPROT_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_RESET_FLAGS,
                               NUIOO_NOT_RESETTING);

                break;

            case NDIS_STATUS_MEDIA_CONNECT:

                NPROT_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_MEDIA_FLAGS,
                               NUIOO_MEDIA_CONNECTED);

                break;

            case NDIS_STATUS_MEDIA_DISCONNECT:

                NPROT_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_MEDIA_FLAGS,
                               NUIOO_MEDIA_DISCONNECTED);

                break;

            default:
                break;
        }
    }
    while (FALSE);
       
    NPROT_RELEASE_LOCK(&pOpenContext->Lock);
}

VOID
NdisProtStatusComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    )
/*++

Routine Description:

    Protocol entry point called by NDIS. We ignore this.

Arguments:

    ProtocolBindingContext - pointer to open context

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    return;
}


NDIS_STATUS
ndisprotQueryBinding(
    IN PUCHAR                       pBuffer,
    IN ULONG                        InputLength,
    IN ULONG                        OutputLength,
    OUT PULONG                      pBytesReturned
    )
/*++

Routine Description:

    Return information about the specified binding.

Arguments:

    pBuffer - pointer to NDISPROT_QUERY_BINDING
    InputLength - input buffer size
    OutputLength - output buffer size
    pBytesReturned - place to return copied byte count.

Return Value:

    NDIS_STATUS_SUCCESS if successful, failure code otherwise.

--*/
{
    PNDISPROT_QUERY_BINDING      pQueryBinding;
    PNDISPROT_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pEnt;
    ULONG                       Remaining;
    ULONG                       BindingIndex;
    NDIS_STATUS                 Status;

    do
    {
        if (InputLength < sizeof(NDISPROT_QUERY_BINDING))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        if (OutputLength < sizeof(NDISPROT_QUERY_BINDING))
        {
            Status = NDIS_STATUS_BUFFER_OVERFLOW;
            break;
        }

        Remaining = OutputLength - sizeof(NDISPROT_QUERY_BINDING);

        pQueryBinding = (PNDISPROT_QUERY_BINDING)pBuffer;
        BindingIndex = pQueryBinding->BindingIndex;

        Status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        pOpenContext = NULL;

        NPROT_ACQUIRE_LOCK(&Globals.GlobalLock);

        for (pEnt = Globals.OpenList.Flink;
             pEnt != &Globals.OpenList;
             pEnt = pEnt->Flink)
        {
            pOpenContext = CONTAINING_RECORD(pEnt, NDISPROT_OPEN_CONTEXT, Link);
            NPROT_STRUCT_ASSERT(pOpenContext, oc);

            NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

            //
            //  Skip if not bound.
            //
            if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
            {
                NPROT_RELEASE_LOCK(&pOpenContext->Lock);
                continue;
            }

            if (BindingIndex == 0)
            {
                //
                //  Got the binding we are looking for. Copy the device
                //  name and description strings to the output buffer.
                //
                DEBUGP(DL_INFO,
                    ("QueryBinding: found open %p\n", pOpenContext));

                pQueryBinding->DeviceNameLength = pOpenContext->DeviceName.Length + sizeof(WCHAR);
                pQueryBinding->DeviceDescrLength = pOpenContext->DeviceDescr.Length + sizeof(WCHAR);
                if (Remaining < pQueryBinding->DeviceNameLength +
                                pQueryBinding->DeviceDescrLength)
                {
                    NPROT_RELEASE_LOCK(&pOpenContext->Lock);
                    Status = NDIS_STATUS_BUFFER_OVERFLOW;
                    break;
                }

                NPROT_ZERO_MEM((PUCHAR)pBuffer + sizeof(NDISPROT_QUERY_BINDING),
                                pQueryBinding->DeviceNameLength +
                                pQueryBinding->DeviceDescrLength);

                pQueryBinding->DeviceNameOffset = sizeof(NDISPROT_QUERY_BINDING);
                NPROT_COPY_MEM((PUCHAR)pBuffer + pQueryBinding->DeviceNameOffset,
                                pOpenContext->DeviceName.Buffer,
                                pOpenContext->DeviceName.Length);
                
                pQueryBinding->DeviceDescrOffset = pQueryBinding->DeviceNameOffset +
                                                    pQueryBinding->DeviceNameLength;
                NPROT_COPY_MEM((PUCHAR)pBuffer + pQueryBinding->DeviceDescrOffset,
                                pOpenContext->DeviceDescr.Buffer,
                                pOpenContext->DeviceDescr.Length);
                
                NPROT_RELEASE_LOCK(&pOpenContext->Lock);

                *pBytesReturned = pQueryBinding->DeviceDescrOffset + pQueryBinding->DeviceDescrLength;
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            BindingIndex--;
        }

        NPROT_RELEASE_LOCK(&Globals.GlobalLock);

    }
    while (FALSE);

    return (Status);
}

PNDISPROT_OPEN_CONTEXT
ndisprotLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    )
/*++

Routine Description:

    Search our global list for an open context structure that
    has a binding to the specified device, and return a pointer
    to it.

    NOTE: we reference the open that we return.

Arguments:

    pBindingInfo - pointer to unicode device name string
    BindingInfoLength - length in bytes of the above.

Return Value:

    Pointer to the matching open context if found, else NULL

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pEnt;

    pOpenContext = NULL;

    NPROT_ACQUIRE_LOCK(&Globals.GlobalLock);

    for (pEnt = Globals.OpenList.Flink;
         pEnt != &Globals.OpenList;
         pEnt = pEnt->Flink)
    {
        pOpenContext = CONTAINING_RECORD(pEnt, NDISPROT_OPEN_CONTEXT, Link);
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Check if this has the name we are looking for.
        //
        if ((pOpenContext->DeviceName.Length == BindingInfoLength) &&
            NPROT_MEM_CMP(pOpenContext->DeviceName.Buffer, pBindingInfo, BindingInfoLength))
        {
            NPROT_REF_OPEN(pOpenContext);   // ref added by LookupDevice
            break;
        }

        pOpenContext = NULL;
    }

    NPROT_RELEASE_LOCK(&Globals.GlobalLock);

    return (pOpenContext);
}


NDIS_STATUS
ndisprotQueryOidValue(
    IN  PNDISPROT_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    )
/*++

Routine Description:

    Query an arbitrary OID value from the miniport.

Arguments:

    pOpenContext - pointer to open context representing our binding to the miniport
    pDataBuffer - place to store the returned value
    BufferLength - length of the above
    pBytesWritten - place to return length returned

Return Value:

    NDIS_STATUS_SUCCESS if we successfully queried the OID.
    NDIS_STATUS_XXX error code otherwise.

--*/
{
    NDIS_STATUS             Status;
    PNDISPROT_QUERY_OID      pQuery;
    NDIS_OID                Oid;

    Oid = 0;

    do
    {
        if (BufferLength < sizeof(NDISPROT_QUERY_OID))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            break;
        }

        pQuery = (PNDISPROT_QUERY_OID)pDataBuffer;
        Oid = pQuery->Oid;

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            DEBUGP(DL_WARN,
                ("QueryOid: Open %p/%x is in invalid state\n",
                    pOpenContext, pOpenContext->Flags));

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Make sure the binding doesn't go away.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    Oid,
                    &pQuery->Data[0],
                    BufferLength - FIELD_OFFSET(NDISPROT_QUERY_OID, Data),
                    pBytesWritten);

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            *pBytesWritten += FIELD_OFFSET(NDISPROT_QUERY_OID, Data);
        }

    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("QueryOid: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
    
}

NDIS_STATUS
ndisprotSetOidValue(
    IN  PNDISPROT_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    )
/*++

Routine Description:

    Set an arbitrary OID value to the miniport.

Arguments:

    pOpenContext - pointer to open context representing our binding to the miniport
    pDataBuffer - buffer that contains the value to be set
    BufferLength - length of the above

Return Value:

    NDIS_STATUS_SUCCESS if we successfully set the OID
    NDIS_STATUS_XXX error code otherwise.

--*/
{
    NDIS_STATUS             Status;
    PNDISPROT_SET_OID        pSet;
    NDIS_OID                Oid;
    ULONG                   BytesWritten;

    Oid = 0;

    do
    {
        if (BufferLength < sizeof(NDISPROT_SET_OID))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            break;
        }

        pSet = (PNDISPROT_SET_OID)pDataBuffer;
        Oid = pSet->Oid;

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            DEBUGP(DL_WARN,
                ("SetOid: Open %p/%x is in invalid state\n",
                    pOpenContext, pOpenContext->Flags));

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Make sure the binding doesn't go away.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        Status = ndisprotDoRequest(
                    pOpenContext,
                    NdisRequestSetInformation,
                    Oid,
                    &pSet->Data[0],
                    BufferLength - FIELD_OFFSET(NDISPROT_SET_OID, Data),
                    &BytesWritten);

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("SetOid: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\precomp.h ===
#pragma warning(disable:4214)   // bit field types other than int

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4244)   // conversion from 'int' to 'BOOLEAN', possible loss of data
#pragma warning(disable:4206)   // nonstandard extension used : translation unit is empty

#include "ndis.h"
#include "ntddk.h"
#include "debug.h"
#include "ndisprot.h"
#include "macros.h"
#include "nuiouser.h"
#include <wdmsec.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\nuiouser.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nuiouser.h

Abstract:

    Constants and types to access the NDISPROT driver.
    Users must also include ntddndis.h

Environment:

    User/Kernel mode.

Revision History:

    arvindm     4/12/2000    Created

--*/

#ifndef __NUIOUSER__H
#define __NUIOUSER__H


#define FSCTL_NDISPROT_BASE      FILE_DEVICE_NETWORK

#define _NDISPROT_CTL_CODE(_Function, _Method, _Access)  \
            CTL_CODE(FSCTL_NDISPROT_BASE, _Function, _Method, _Access)

#define IOCTL_NDISPROT_OPEN_DEVICE   \
            _NDISPROT_CTL_CODE(0x200, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISPROT_QUERY_OID_VALUE   \
            _NDISPROT_CTL_CODE(0x201, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISPROT_SET_OID_VALUE   \
            _NDISPROT_CTL_CODE(0x205, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISPROT_QUERY_BINDING   \
            _NDISPROT_CTL_CODE(0x203, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISPROT_BIND_WAIT   \
            _NDISPROT_CTL_CODE(0x204, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

    
//
//  Structure to go with IOCTL_NDISPROT_QUERY_OID_VALUE.
//  The Data part is of variable length, determined by
//  the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISPROT_QUERY_OID
{
    NDIS_OID        Oid;
    UCHAR           Data[sizeof(ULONG)];

} NDISPROT_QUERY_OID, *PNDISPROT_QUERY_OID;

//
//  Structure to go with IOCTL_NDISPROT_SET_OID_VALUE.
//  The Data part is of variable length, determined
//  by the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISPROT_SET_OID
{
    NDIS_OID        Oid;
    UCHAR           Data[sizeof(ULONG)];

} NDISPROT_SET_OID, *PNDISPROT_SET_OID;


//
//  Structure to go with IOCTL_NDISPROT_QUERY_BINDING.
//  The input parameter is BindingIndex, which is the
//  index into the list of bindings active at the driver.
//  On successful completion, we get back a device name
//  and a device descriptor (friendly name).
//
typedef struct _NDISPROT_QUERY_BINDING
{
    ULONG            BindingIndex;        // 0-based binding number
    ULONG            DeviceNameOffset;    // from start of this struct
    ULONG            DeviceNameLength;    // in bytes
    ULONG            DeviceDescrOffset;    // from start of this struct
    ULONG            DeviceDescrLength;    // in bytes

} NDISPROT_QUERY_BINDING, *PNDISPROT_QUERY_BINDING;
 
#endif // __NUIOUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\test\uiotest.c ===
//
// UIOTEST.C
//
// Test program for ndisprot.sys
//
// usage: UIOTEST [options] <devicename>
//
// options:
//        -e: Enumerate devices
//        -r: Read
//        -w: Write (default)
//        -l <length>: length of each packet (default: %d)\n", PacketLength
//        -n <count>: number of packets (defaults to infinity)
//        -m <MAC address> (defaults to local MAC)
//

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>

#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include "nuiouser.h"

#ifndef NDIS_STATUS
#define NDIS_STATUS     ULONG
#endif

#if DBG
#define DEBUGP(stmt)    printf stmt
#else
#define DEBUGP(stmt)
#endif

#define PRINTF(stmt)    printf stmt

#ifndef MAC_ADDR_LEN
#define MAC_ADDR_LEN                    6
#endif

#define MAX_NDIS_DEVICE_NAME_LEN        256

CHAR            NdisProtDevice[] = "\\\\.\\\\NdisProt";
CHAR *          pNdisProtDevice = &NdisProtDevice[0];

BOOLEAN         DoEnumerate = FALSE;
BOOLEAN         DoReads = FALSE;
INT             NumberOfPackets = -1;
ULONG           PacketLength = 100;
UCHAR           SrcMacAddr[MAC_ADDR_LEN];
UCHAR           DstMacAddr[MAC_ADDR_LEN];
BOOLEAN         bDstMacSpecified = FALSE;
CHAR *          pNdisDeviceName = "JUNK";
USHORT          EthType = 0x8e88;
BOOLEAN         bUseFakeAddress = FALSE;
UCHAR           FakeSrcMacAddr[MAC_ADDR_LEN] = {0};


#include <pshpack1.h>

typedef struct _ETH_HEADER
{
    UCHAR       DstAddr[MAC_ADDR_LEN];
    UCHAR       SrcAddr[MAC_ADDR_LEN];
    USHORT      EthType;
} ETH_HEADER, *PETH_HEADER;

#include <poppack.h>


VOID
PrintUsage()
{
    PRINTF(("usage: UIOTEST [options] <devicename>\n"));
    PRINTF(("options:\n"));
    PRINTF(("       -e: Enumerate devices\n"));
    PRINTF(("       -r: Read\n"));
    PRINTF(("       -w: Write (default)\n"));
    PRINTF(("       -l <length>: length of each packet (default: %d)\n", PacketLength));
    PRINTF(("       -n <count>: number of packets (defaults to infinity)\n"));
    PRINTF(("       -m <MAC address> (defaults to local MAC)\n"));
    PRINTF(("       -f Use a fake address to send out the packets.\n"));
    

}

BOOL
GetOptions(
    INT         argc,
    CHAR        *argv[]
)
{
    BOOL        bOkay;
    INT         i, j, increment;
    CHAR        *pOption;
    ULONG       DstMacAddrUlong[MAC_ADDR_LEN];
    INT         RetVal;

    bOkay = TRUE;

    do
    {
        if (argc < 2)
        {
            PRINTF(("Missing <devicename> argument\n"));
            bOkay = FALSE;
            break;
        }

        i = 1;
        while (i < argc)
        {
            increment = 1;
            pOption = argv[i];

            if ((*pOption == '-') || (*pOption == '/'))
            {
                pOption++;
                if (*pOption == '\0')
                {
                    DEBUGP(("Badly formed option\n"));
                    return (FALSE);
                }
            }
            else
            {
                break;
            }

            switch (*pOption)
            {
                case 'e':
                    DoEnumerate = TRUE;
                    break;
                
                case 'f':
                    bUseFakeAddress = TRUE;
                    break;

                case 'r':
                    DoReads = TRUE;
                    break;

                case 'w':
                    DoReads = FALSE;
                    break;

                case 'l':

                    if (i+1 < argc-1)
                    {
                        RetVal = atoi(argv[i+1]);
                        if (RetVal != 0)
                        {
                            PacketLength = RetVal;
                            DEBUGP((" Option: PacketLength = %d\n", PacketLength));
                            increment = 2;
                            break;
                        }
                    }    
                    PRINTF(("Option l needs PacketLength parameter\n"));
                    return (FALSE);
                
                case 'n':

                    if (i+1 < argc-1)
                    {
                        RetVal = atoi(argv[i+1]);
                        if (RetVal != 0)
                        {
                            NumberOfPackets = RetVal;
                            DEBUGP((" Option: NumberOfPackets = %d\n", NumberOfPackets));
                            increment = 2;
                            break;
                        }
                    }
                    PRINTF(("Option n needs NumberOfPackets parameter\n"));
                    return (FALSE);

                case 'm':

                    if (i+1 < argc-1)
                    {
                        RetVal = sscanf(argv[i+1], "%2x:%2x:%2x:%2x:%2x:%2x",
                                    &DstMacAddrUlong[0],
                                    &DstMacAddrUlong[1],
                                    &DstMacAddrUlong[2],
                                    &DstMacAddrUlong[3],
                                    &DstMacAddrUlong[4],
                                    &DstMacAddrUlong[5]);

                        if (RetVal == 6)
                        {
                            for (j = 0; j < MAC_ADDR_LEN; j++)
                            {
                                DstMacAddr[j] = (UCHAR)DstMacAddrUlong[j];
                            }
    
                            DEBUGP((" Option: Dest MAC Addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
                                DstMacAddr[0],
                                DstMacAddr[1],
                                DstMacAddr[2],
                                DstMacAddr[3],
                                DstMacAddr[4],
                                DstMacAddr[5]));
                            bDstMacSpecified = TRUE;

                            increment = 2;
                            break;
                        }
                    }
                        
                    PRINTF(("Option m needs MAC address parameter\n"));
                    return (FALSE);
                
                case '?':
                    return (FALSE);

                default:
                    PRINTF(("Unknown option %c\n", *pOption));
                    return (FALSE);
            }

            i+= increment;
        }

        pNdisDeviceName = argv[argc-1];
        
    }
    while (FALSE);

    return (bOkay);
}


HANDLE
OpenHandle(
    CHAR    *pDeviceName
)
{
    DWORD   DesiredAccess;
    DWORD   ShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;

    DWORD   CreationDistribution;
    DWORD   FlagsAndAttributes;
    HANDLE  TemplateFile;
    HANDLE  Handle;
    DWORD   BytesReturned;

    DesiredAccess = GENERIC_READ|GENERIC_WRITE;
    ShareMode = 0;
    CreationDistribution = OPEN_EXISTING;
    FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
    TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    Handle = CreateFile(
                pDeviceName,
                DesiredAccess,
                ShareMode,
                lpSecurityAttributes,
                CreationDistribution,
                FlagsAndAttributes,
                TemplateFile
            );
    if (Handle == INVALID_HANDLE_VALUE)
    {
        DEBUGP(("Creating file failed, error %x\n", GetLastError()));
        return Handle;
    }
    //
    //  Wait for the driver to finish binding.
    //
    if (!DeviceIoControl(
                Handle,
                IOCTL_NDISPROT_BIND_WAIT,
                NULL,
                0,
                NULL,
                0,
                &BytesReturned,
                NULL))
    {
        DEBUGP(("IOCTL_NDISIO_BIND_WAIT failed, error %x\n", GetLastError()));
        CloseHandle(Handle);
        Handle = INVALID_HANDLE_VALUE;
    }

    return (Handle);
}


BOOL
OpenNdisDevice(     
    HANDLE  Handle,
    CHAR   *pDeviceName
)
{
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];
    INT     wNameLength;
    INT     NameLength = strlen(pDeviceName);
    DWORD   BytesReturned;
    INT     i;


    //
    // Convert to unicode string - non-localized...
    //
    wNameLength = 0;
    for (i = 0; i < NameLength && i < MAX_NDIS_DEVICE_NAME_LEN-1; i++)
    {
        wNdisDeviceName[i] = (WCHAR)pDeviceName[i];
        wNameLength++;
    }
    wNdisDeviceName[i] = L'\0';

    DEBUGP(("Trying to access NDIS Device: %ws\n", wNdisDeviceName));

    return (DeviceIoControl(
                Handle,
                IOCTL_NDISPROT_OPEN_DEVICE,
                (LPVOID)&wNdisDeviceName[0],
                wNameLength*sizeof(WCHAR),
                NULL,
                0,
                &BytesReturned,
                NULL));

}


BOOL
GetSrcMac(
    HANDLE  Handle,
    PUCHAR  pSrcMacAddr
    )
{
    DWORD       BytesReturned;
    BOOLEAN     bSuccess;
    UCHAR       QueryBuffer[sizeof(NDISPROT_QUERY_OID) + MAC_ADDR_LEN];
    PNDISPROT_QUERY_OID  pQueryOid;

    
    DEBUGP(("Trying to get src mac address\n"));

    pQueryOid = (PNDISPROT_QUERY_OID)&QueryBuffer[0];
    pQueryOid->Oid = OID_802_3_CURRENT_ADDRESS;

    bSuccess = (BOOLEAN)DeviceIoControl(
                            Handle,
                            IOCTL_NDISPROT_QUERY_OID_VALUE,
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            &BytesReturned,
                            NULL);

    if (bSuccess)
    {
        DEBUGP(("GetSrcMac: IoControl success, BytesReturned = %d\n",
                BytesReturned));

        memcpy(pSrcMacAddr, pQueryOid->Data, MAC_ADDR_LEN);

                    
    }
    else
    {
        DEBUGP(("GetSrcMac: IoControl failed: %d\n", GetLastError()));
    }

    return (bSuccess);
}



VOID
DoReadProc(
    HANDLE  Handle
    )
{
    PUCHAR      pReadBuf = NULL;
    INT         ReadCount = 0;
    BOOLEAN     bSuccess;
    ULONG       BytesRead;

    DEBUGP(("DoReadProc\n"));

    do
    {
        pReadBuf = malloc(PacketLength);

        if (pReadBuf == NULL)
        {
            PRINTF(("DoReadProc: failed to alloc %d bytes\n", PacketLength));
            break;
        }

        ReadCount = 0; 
        while (TRUE)
        {
            bSuccess = (BOOLEAN)ReadFile(
                                    Handle,
                                    (LPVOID)pReadBuf,
                                    PacketLength,
                                    &BytesRead,
                                    NULL);
            
            if (!bSuccess)
            {
                PRINTF(("DoReadProc: ReadFile failed on Handle %p, error %x\n",
                        Handle, GetLastError()));
                break;
            }
            ReadCount++;

            DEBUGP(("DoReadProc: read pkt # %d, %d bytes\n", ReadCount, BytesRead));

            if ((NumberOfPackets != -1) && (ReadCount == NumberOfPackets))
            {
                break;
            }
        }
    }
    while (FALSE);

    if (pReadBuf)
    {
        free(pReadBuf);
    }

    PRINTF(("DoReadProc finished: read %d packets\n", ReadCount));

}


VOID
DoWriteProc(
    HANDLE  Handle
    )
{
    PUCHAR      pWriteBuf = NULL;
    PUCHAR      pData;
    UINT        i;
    INT         SendCount;
    PETH_HEADER pEthHeader;
    DWORD       BytesWritten;
    BOOLEAN     bSuccess;

    DEBUGP(("DoWriteProc\n"));
    SendCount = 0;

    do
    {
        pWriteBuf = malloc(PacketLength);

        if (pWriteBuf == NULL)
        {
            DEBUGP(("DoWriteProc: Failed to malloc %d bytes\n", PacketLength));
            break;
        }
        pEthHeader = (PETH_HEADER)pWriteBuf;
        pEthHeader->EthType = EthType;
        
        if (bUseFakeAddress)
        {
            memcpy(pEthHeader->SrcAddr, FakeSrcMacAddr, MAC_ADDR_LEN);
        }
        else
        {
            memcpy(pEthHeader->SrcAddr, SrcMacAddr, MAC_ADDR_LEN);
        }
        
        memcpy(pEthHeader->DstAddr, DstMacAddr, MAC_ADDR_LEN);

        pData = (PUCHAR)(pEthHeader + 1);
        for (i = 0; i < PacketLength - sizeof(ETH_HEADER); i++)
        {
            *pData++ = (UCHAR)i;
        }
        
        SendCount = 0;
        
        while (TRUE)
        {
            
            bSuccess = (BOOLEAN)WriteFile(
                                    Handle,
                                    pWriteBuf,
                                    PacketLength,
                                    &BytesWritten,
                                    NULL);
            if (!bSuccess)
            {
                PRINTF(("DoWriteProc: WriteFile failed on Handle %p\n", Handle));
                break;
            }
            SendCount++;
            
            DEBUGP(("DoWriteProc: sent %d bytes\n", BytesWritten));

            if ((NumberOfPackets != -1) && (SendCount == NumberOfPackets))
            {
                break;
            }
        }

    }
    while (FALSE);

    if (pWriteBuf)
    {
        free(pWriteBuf);
    }

    PRINTF(("DoWriteProc: finished sending %d packets of %d bytes each\n",
            SendCount, PacketLength));
}

VOID
EnumerateDevices(
    HANDLE  Handle
    )
{
    CHAR        Buf[1024];
    DWORD       BufLength = sizeof(Buf);
    DWORD       BytesWritten;
    DWORD       i;
    PNDISPROT_QUERY_BINDING pQueryBinding;

    pQueryBinding = (PNDISPROT_QUERY_BINDING)Buf;

    i = 0;
    for (pQueryBinding->BindingIndex = i;
         /* NOTHING */;
         pQueryBinding->BindingIndex = ++i)
    {
        if (DeviceIoControl(
                Handle,
                IOCTL_NDISPROT_QUERY_BINDING,
                pQueryBinding,
                sizeof(NDISPROT_QUERY_BINDING),
                Buf,
                BufLength,
                &BytesWritten,
                NULL))
        {
            PRINTF(("%2d. %ws\n     - %ws\n",
                pQueryBinding->BindingIndex,
                (WCHAR *)((PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset),
                (WCHAR *)((PUCHAR )pQueryBinding + pQueryBinding->DeviceDescrOffset)));

            memset(Buf, 0, BufLength);
        }
        else
        {
            ULONG   rc = GetLastError();
            if (rc != ERROR_NO_MORE_ITEMS)
            {
                PRINTF(("EnumerateDevices: terminated abnormally, error %d\n", rc));
            }
            break;
        }
    }
}




VOID __cdecl
main(
    INT         argc,
    CHAR        *argv[]
)
{
    HANDLE      DeviceHandle;

    DeviceHandle = INVALID_HANDLE_VALUE;

    do
    {
        if (!GetOptions(argc, argv))
        {
            PrintUsage();
            break;
        }

        DeviceHandle = OpenHandle(pNdisProtDevice);

        if (DeviceHandle == INVALID_HANDLE_VALUE)
        {
            PRINTF(("Failed to open %s\n", pNdisProtDevice));
            break;
        }

        if (DoEnumerate)
        {
            EnumerateDevices(DeviceHandle);
            break;
        }

        if (!OpenNdisDevice(DeviceHandle, pNdisDeviceName))
        {
            PRINTF(("Failed to access %s\n", pNdisDeviceName));
            break;
        }

        DEBUGP(("Opened device %s successfully!\n", pNdisDeviceName));

        if (!GetSrcMac(DeviceHandle, SrcMacAddr))
        {
            PRINTF(("Failed to obtain local MAC address\n"));
            break;
        }


        DEBUGP(("Got local MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
                    SrcMacAddr[0],
                    SrcMacAddr[1],
                    SrcMacAddr[2],
                    SrcMacAddr[3],
                    SrcMacAddr[4],
                    SrcMacAddr[5]));

        if (!bDstMacSpecified)
        {
            memcpy(DstMacAddr, SrcMacAddr, MAC_ADDR_LEN);
        }

        if (DoReads)
        {
            DoReadProc(DeviceHandle);
        }
        else
        {
            DoWriteProc(DeviceHandle);
            DoReadProc(DeviceHandle);
        }

    }
    while (FALSE);

    if (DeviceHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(DeviceHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\send.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    send.c

Abstract:

    NDIS protocol entry points and utility routines to handle sending
    data.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/10/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'DNES'




NTSTATUS
NdisProtWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_WRITE. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   DataLength;
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_BUFFER            pNdisBuffer;
    NDISPROT_ETH_HEADER UNALIGNED *pEthHeader;
#ifdef NDIS51
    PVOID                   CancelId;
#endif

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    pNdisPacket = NULL;

    do
    {
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("Write: FileObject %p not yet associated with a device\n",
                pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
               
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        if (pIrp->MdlAddress == NULL)
        {
            DEBUGP(DL_FATAL, ("Write: NULL MDL address on IRP %p\n", pIrp));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        //
        // Try to get a virtual address for the MDL.
        //
#ifndef WIN9X
        pEthHeader = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);

        if (pEthHeader == NULL)
        {
            DEBUGP(DL_FATAL, ("Write: MmGetSystemAddr failed for"
                    " IRP %p, MDL %p\n",
                    pIrp, pIrp->MdlAddress));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
#else
        pEthHeader = MmGetSystemAddressForMdl(pIrp->MdlAddress);   // for Win9X
#endif

        //
        // Sanity-check the length.
        //
        DataLength = MmGetMdlByteCount(pIrp->MdlAddress);
        if (DataLength < sizeof(NDISPROT_ETH_HEADER))
        {
            DEBUGP(DL_WARN, ("Write: too small to be a valid packet (%d bytes)\n",
                DataLength));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DataLength > (pOpenContext->MaxFrameSize + sizeof(NDISPROT_ETH_HEADER)))
        {
            DEBUGP(DL_WARN, ("Write: Open %p: data length (%d)"
                    " larger than max frame size (%d)\n",
                    pOpenContext, DataLength, pOpenContext->MaxFrameSize));

            NtStatus = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // To prevent applications from sending packets with spoofed
        // mac address, we will do the following check to make sure the source 
        // address in the packet is same as the current MAC address of the NIC.
        //
        if ((pIrp->RequestorMode == UserMode) && 
            !NPROT_MEM_CMP(pEthHeader->SrcAddr, pOpenContext->CurrentAddress, NPROT_MAC_ADDR_LEN))
        {
            DEBUGP(DL_WARN, ("Write: Failing with invalid Source address"));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
                
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            DEBUGP(DL_FATAL, ("Write: Open %p is not bound"
            " or in low power state\n", pOpenContext));

            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }

        //
        //  Allocate a send packet.
        //
        NPROT_ASSERT(pOpenContext->SendPacketPool != NULL);
        NdisAllocatePacket(
            &Status,
            &pNdisPacket,
            pOpenContext->SendPacketPool);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            DEBUGP(DL_FATAL, ("Write: open %p, failed to alloc send pkt\n",
                    pOpenContext));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Allocate a send buffer if necessary.
        //
        if (pOpenContext->bRunningOnWin9x)
        {
            NdisAllocateBuffer(
                &Status,
                &pNdisBuffer,
                pOpenContext->SendBufferPool,
                pEthHeader,
                DataLength);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                NPROT_RELEASE_LOCK(&pOpenContext->Lock);

                NdisFreePacket(pNdisPacket);

                DEBUGP(DL_FATAL, ("Write: open %p, failed to alloc send buf\n",
                        pOpenContext));
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }
        else
        {
            pNdisBuffer = pIrp->MdlAddress;
        }

        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NPROT_REF_OPEN(pOpenContext);  // pended send

        IoMarkIrpPending(pIrp);

        //
        //  Initialize the packet ref count. This packet will be freed
        //  when this count goes to zero.
        //
        NPROT_SEND_PKT_RSVD(pNdisPacket)->RefCount = 1;

#ifdef NDIS51

        //
        //  NDIS 5.1 supports cancelling sends. We set up a cancel ID on
        //  each send packet (which maps to a Write IRP), and save the
        //  packet pointer in the IRP. If the IRP gets cancelled, we use
        //  NdisCancelSendPackets() to cancel the packet.
        //

        CancelId = NPROT_GET_NEXT_CANCEL_ID();
        NDIS_SET_PACKET_CANCEL_ID(pNdisPacket, CancelId);
        pIrp->Tail.Overlay.DriverContext[0] = (PVOID)pOpenContext;
        pIrp->Tail.Overlay.DriverContext[1] = (PVOID)pNdisPacket;

        NPROT_INSERT_TAIL_LIST(&pOpenContext->PendedWrites, &pIrp->Tail.Overlay.ListEntry);

        IoSetCancelRoutine(pIrp, NdisProtCancelWrite);

#endif // NDIS51

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set a back pointer from the packet to the IRP.
        //
        NPROT_IRP_FROM_SEND_PKT(pNdisPacket) = pIrp;

        NtStatus = STATUS_PENDING;

        pNdisBuffer->Next = NULL;
        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

#if SEND_DBG
        {
            PUCHAR      pData;

#ifndef WIN9X
            pData = MmGetSystemAddressForMdlSafe(pNdisBuffer, NormalPagePriority);
            NPROT_ASSERT(pEthHeader == pData);
#else
            pData = MmGetSystemAddressForMdl(pNdisBuffer);  // Win9x
#endif

            DEBUGP(DL_VERY_LOUD, 
                ("Write: MDL %p, MdlFlags %x, SystemAddr %p, %d bytes\n",
                    pIrp->MdlAddress, pIrp->MdlAddress->MdlFlags, pData, DataLength));

            DEBUGPDUMP(DL_VERY_LOUD, pData, MIN(DataLength, 48));
        }
#endif // SEND_DBG

        NdisSendPackets(pOpenContext->BindingHandle, &pNdisPacket, 1);

    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return (NtStatus);
}


#ifdef NDIS51

VOID
NdisProtCancelWrite(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    )
/*++

Routine Description:

    Cancel a pending write IRP. This routine attempt to cancel the NDIS send.

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - IRP to be cancelled

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pIrpEntry;
    PNDIS_PACKET                pNdisPacket;

    UNREFERENCED_PARAMETER(pDeviceObject);
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    //  The NDIS packet representing this Write IRP.
    //
    pNdisPacket = NULL;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT) pIrp->Tail.Overlay.DriverContext[0];
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Try to locate the IRP in the pended write queue. The send completion
    //  routine may be running and might have removed it from there.
    //
    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    for (pIrpEntry = pOpenContext->PendedWrites.Flink;
         pIrpEntry != &pOpenContext->PendedWrites;
         pIrpEntry = pIrpEntry->Flink)
    {
        if (pIrp == CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry))
        {
            pNdisPacket = (PNDIS_PACKET) pIrp->Tail.Overlay.DriverContext[1];

            //
            //  Place a reference on this packet so that it won't get
            //  freed/reused until we are done with it.
            //
            NPROT_REF_SEND_PKT(pNdisPacket);
            break;
        }
    }

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    if (pNdisPacket != NULL)
    {
        //
        //  Either the send completion routine hasn't run, or we got a peak
        //  at the IRP/packet before it had a chance to take it out of the
        //  pending IRP queue.
        //
        //  We do not complete the IRP here - note that we didn't dequeue it
        //  above. This is because we always want the send complete routine to
        //  complete the IRP. And this in turn is because the packet that was
        //  prepared from the IRP has a buffer chain pointing to data associated
        //  with this IRP. Therefore we cannot complete the IRP before the driver
        //  below us is done with the data it pointed to.
        //

        //
        //  Request NDIS to cancel this send. The result of this call is that
        //  our SendComplete handler will be called (if not already called).
        //
        DEBUGP(DL_INFO, ("CancelWrite: cancelling pkt %p on Open %p\n",
            pNdisPacket, pOpenContext));
        NdisCancelSendPackets(
            pOpenContext->BindingHandle,
            NDIS_GET_PACKET_CANCEL_ID(pNdisPacket)
            );
        
        //
        //  It is now safe to remove the reference we had placed on the packet.
        //
        NPROT_DEREF_SEND_PKT(pNdisPacket);
    }
    //
    //  else the send completion routine has already picked up this IRP.
    //
}

#endif // NDIS51


VOID
NdisProtSendComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point called to signify completion of a packet send.
    We pick up and complete the Write IRP corresponding to this packet.

    NDIS 5.1: 

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - packet that completed send
    Status - status of send

Return Value:

    None

--*/
{
    PIRP                        pIrp;
    PIO_STACK_LOCATION          pIrpSp;
    PNDISPROT_OPEN_CONTEXT       pOpenContext;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    pIrp = NPROT_IRP_FROM_SEND_PKT(pNdisPacket);

    if (pOpenContext->bRunningOnWin9x)
    {
        //
        //  We would have attached our own NDIS_BUFFER. Take it out
        //  and free it.
        //
#ifndef NDIS51
        PNDIS_BUFFER                pNdisBuffer;
        PVOID                       VirtualAddr;
        UINT                        BufferLength;
        UINT                        TotalLength;
#endif

#ifdef NDIS51
        NPROT_ASSERT(FALSE); // NDIS 5.1 not on Win9X!
#else
        NdisGetFirstBufferFromPacket(
            pNdisPacket,
            &pNdisBuffer,
            &VirtualAddr,
            &BufferLength,
            &TotalLength);

        NPROT_ASSERT(pNdisBuffer != NULL);
        NdisFreeBuffer(pNdisBuffer);
#endif
    }


#ifdef NDIS51
    IoSetCancelRoutine(pIrp, NULL);

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    NPROT_REMOVE_ENTRY_LIST(&pIrp->Tail.Overlay.ListEntry);

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);
#endif

    //
    //  We are done with the NDIS_PACKET:
    //
    NPROT_DEREF_SEND_PKT(pNdisPacket);

    //
    //  Complete the Write IRP with the right status.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = pIrpSp->Parameters.Write.Length;
        pIrp->IoStatus.Status = STATUS_SUCCESS;
    }
    else
    {
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    }

    DEBUGP(DL_INFO, ("SendComplete: packet %p/IRP %p/Length %d "
                    "completed with status %x\n",
                    pNdisPacket, pIrp, pIrp->IoStatus.Information, pIrp->IoStatus.Status));

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

    NPROT_DEREF_OPEN(pOpenContext); // send complete - dequeued send IRP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\ntdisp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ntdisp.c

Abstract:

    NT Entry points and dispatch routines for NDISPROT.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/6/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'PSID'


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NdisProtUnload)
#pragma alloc_text(PAGE, NdisProtOpen)
#pragma alloc_text(PAGE, NdisProtClose)
#pragma alloc_text(PAGE, NdisProtIoControl)

#endif // ALLOC_PRAGMA


//
//  Globals:
//
NDISPROT_GLOBALS         Globals = {0};

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    )
/*++

Routine Description:

    Called on loading. We create a device object to handle user-mode requests
    on, and register ourselves as a protocol with NDIS.

Arguments:

    pDriverObject - Pointer to driver object created by system.

    pRegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    NT Status code
    
--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS   protocolChar;
    NTSTATUS                        status = STATUS_SUCCESS;
    NDIS_STRING                     protoName = NDIS_STRING_CONST("NdisProt");     
    UNICODE_STRING                  ntDeviceName;
    UNICODE_STRING                  win32DeviceName;
    BOOLEAN                         fSymbolicLink = FALSE;
    PDEVICE_OBJECT                  deviceObject = NULL;

    UNREFERENCED_PARAMETER(pRegistryPath);

    DEBUGP(DL_LOUD, ("DriverEntry\n"));

    Globals.pDriverObject = pDriverObject;
    NPROT_INIT_EVENT(&Globals.BindsComplete);

    do
    {

        //
        // Create our device object using which an application can
        // access NDIS devices.
        //
        RtlInitUnicodeString(&ntDeviceName, NT_DEVICE_NAME);
#ifndef WIN9X
        status = IoCreateDeviceSecure(pDriverObject,
                                 0,
                                 &ntDeviceName,
                                 FILE_DEVICE_NETWORK,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
                                 NULL,
                                 &deviceObject);

#elif     
        status = IoCreateDevice(pDriverObject,
                                 0,
                                 &ntDeviceName,
                                 FILE_DEVICE_NETWORK,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &deviceObject);
#endif
        if (!NT_SUCCESS (status))
        {
            //
            // Either not enough memory to create a deviceobject or another
            // deviceobject with the same name exits. This could happen
            // if you install another instance of this device.
            //
            break;
        }

        RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

        status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

        if (!NT_SUCCESS(status))
        {
            break;
        }

        fSymbolicLink = TRUE;
    
        deviceObject->Flags |= DO_DIRECT_IO;
        Globals.ControlDeviceObject = deviceObject;

        NPROT_INIT_LIST_HEAD(&Globals.OpenList);
        NPROT_INIT_LOCK(&Globals.GlobalLock);

        //
        // Initialize the protocol characterstic structure
        //
    
        NdisZeroMemory(&protocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        protocolChar.MajorNdisVersion            = 5;
        protocolChar.MinorNdisVersion            = 0;
        protocolChar.Name                        = protoName;
        protocolChar.OpenAdapterCompleteHandler  = NdisProtOpenAdapterComplete;
        protocolChar.CloseAdapterCompleteHandler = NdisProtCloseAdapterComplete;
        protocolChar.SendCompleteHandler         = NdisProtSendComplete;
        protocolChar.TransferDataCompleteHandler = NdisProtTransferDataComplete;
        protocolChar.ResetCompleteHandler        = NdisProtResetComplete;
        protocolChar.RequestCompleteHandler      = NdisProtRequestComplete;
        protocolChar.ReceiveHandler              = NdisProtReceive;
        protocolChar.ReceiveCompleteHandler      = NdisProtReceiveComplete;
        protocolChar.StatusHandler               = NdisProtStatus;
        protocolChar.StatusCompleteHandler       = NdisProtStatusComplete;
        protocolChar.BindAdapterHandler          = NdisProtBindAdapter;
        protocolChar.UnbindAdapterHandler        = NdisProtUnbindAdapter;
        protocolChar.UnloadHandler               = NULL;
        protocolChar.ReceivePacketHandler        = NdisProtReceivePacket;
        protocolChar.PnPEventHandler             = NdisProtPnPEventHandler;

        //
        // Register as a protocol driver
        //
    
        NdisRegisterProtocol(
            (PNDIS_STATUS)&status,
            &Globals.NdisProtocolHandle,
            &protocolChar,
            sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("Failed to register protocol with NDIS\n"));
            status = STATUS_UNSUCCESSFUL;
            break;
        }

#ifdef NDIS51
        Globals.PartialCancelId = NdisGeneratePartialCancelId();
        Globals.PartialCancelId <<= ((sizeof(PVOID) - 1) * 8);
        DEBUGP(DL_LOUD, ("DriverEntry: CancelId %lx\n", Globals.PartialCancelId));
#endif

        //
        // Now set only the dispatch points we would like to handle.
        //
        pDriverObject->MajorFunction[IRP_MJ_CREATE] = NdisProtOpen;
        pDriverObject->MajorFunction[IRP_MJ_CLOSE]  = NdisProtClose;
        pDriverObject->MajorFunction[IRP_MJ_READ]   = NdisProtRead;
        pDriverObject->MajorFunction[IRP_MJ_WRITE]  = NdisProtWrite;
        pDriverObject->MajorFunction[IRP_MJ_CLEANUP]  = NdisProtCleanup;
        pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = NdisProtIoControl;
        pDriverObject->DriverUnload = NdisProtUnload;

        status = STATUS_SUCCESS;
        
    }
    while (FALSE);
       

    if (!NT_SUCCESS(status))
    {
        if (deviceObject)
        {
            IoDeleteDevice(deviceObject);
            Globals.ControlDeviceObject = NULL;
        }

        if (fSymbolicLink)
        {
            IoDeleteSymbolicLink(&win32DeviceName);
        }
        
    }
    
    return status;

}


VOID
NdisProtUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    UNICODE_STRING     win32DeviceName;

    UNREFERENCED_PARAMETER(DriverObject);
	
    DEBUGP(DL_LOUD, ("Unload Enter\n"));

    ndisprotUnregisterExCallBack();
    
    //
    // First delete the Control deviceobject and the corresponding
    // symbolicLink
    //
    RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

    IoDeleteSymbolicLink(&win32DeviceName);           

    if (Globals.ControlDeviceObject)
    {
        IoDeleteDevice(Globals.ControlDeviceObject);
        Globals.ControlDeviceObject = NULL;
    }

    ndisprotDoProtocolUnload();

#if DBG
    ndisprotAuditShutdown();
#endif

    DEBUGP(DL_LOUD, ("Unload Exit\n"));
}



NTSTATUS
NdisProtOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CREATE.
    We simply succeed this.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->FileObject->FsContext = NULL;

    DEBUGP(DL_INFO, ("Open: FileObject %p\n", pIrpSp->FileObject));

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return NtStatus;
}

NTSTATUS
NdisProtClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CLOSE.
    We simply succeed this.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS                NtStatus;
    PIO_STACK_LOCATION      pIrpSp;
    PNDISPROT_OPEN_CONTEXT   pOpenContext;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    DEBUGP(DL_INFO, ("Close: FileObject %p\n",
        IoGetCurrentIrpStackLocation(pIrp)->FileObject));

    if (pOpenContext != NULL)
    {
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Deref the endpoint
        //
        NPROT_DEREF_OPEN(pOpenContext);  // Close
    }

    pIrpSp->FileObject->FsContext = NULL;
    NtStatus = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return NtStatus;
}

    

NTSTATUS
NdisProtCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CLEANUP.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus;
    NDIS_STATUS             NdisStatus;
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    ULONG                   PacketFilter;
    ULONG                   BytesProcessed;

    
    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    DEBUGP(DL_VERY_LOUD, ("Cleanup: FileObject %p, Open %p\n",
        pIrpSp->FileObject, pOpenContext));

    if (pOpenContext != NULL)
    {
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Mark this endpoint.
        //
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE);
        pOpenContext->pFileObject = NULL;

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set the packet filter to 0, telling NDIS that we aren't
        //  interested in any more receives.
        //
        PacketFilter = 0;
        NdisStatus = ndisprotValidateOpenAndDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesProcessed,
                        FALSE   // Don't wait for device to be powered on
                        );
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_INFO, ("Cleanup: Open %p, set packet filter (%x) failed: %x\n",
                    pOpenContext, PacketFilter, NdisStatus));
            //
            //  Ignore the result. If this failed, we may continue
            //  to get indicated receives, which will be handled
            //  appropriately.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }

        //
        //  Cancel any pending reads.
        //
        ndisprotCancelPendingReads(pOpenContext);
        //
        // Clean up the receive packet queue
        //
        ndisprotFlushReceiveQueue(pOpenContext);
    }

    NtStatus = STATUS_SUCCESS;

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    DEBUGP(DL_INFO, ("Cleanup: OpenContext %p\n", pOpenContext));

    return (NtStatus);
}

NTSTATUS
NdisProtIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling device ioctl requests.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   FunctionCode;
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    ULONG                   BytesReturned;
    USHORT                  EthType;

#if !DBG
    UNREFERENCED_PARAMETER(pDeviceObject);
#endif
    
    DEBUGP(DL_LOUD, ("IoControl: DevObj %p, Irp %p\n", pDeviceObject, pIrp));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    FunctionCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    pOpenContext = (PNDISPROT_OPEN_CONTEXT)pIrpSp->FileObject->FsContext;
    BytesReturned = 0;

    switch (FunctionCode)
    {
        case IOCTL_NDISPROT_BIND_WAIT:
            //
            //  Block until we have seen a NetEventBindsComplete event,
            //  meaning that we have finished binding to all running
            //  adapters that we are supposed to bind to.
            //
            //  If we don't get this event in 5 seconds, time out.
            //
            NPROT_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            
            if (NPROT_WAIT_EVENT(&Globals.BindsComplete, 5000))
            {
                NtStatus = STATUS_SUCCESS;
            }
            else
            {
                NtStatus = STATUS_TIMEOUT;
            }
            DEBUGP(DL_INFO, ("IoControl: BindWait returning %x\n", NtStatus));
            break;

        case IOCTL_NDISPROT_QUERY_BINDING:
            
            NPROT_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            
            Status = ndisprotQueryBinding(
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &BytesReturned
                            );

            NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);

            DEBUGP(DL_LOUD, ("IoControl: QueryBinding returning %x\n", NtStatus));

            break;

        case IOCTL_NDISPROT_OPEN_DEVICE:

            NPROT_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                NPROT_STRUCT_ASSERT(pOpenContext, oc);
                DEBUGP(DL_WARN, ("IoControl: OPEN_DEVICE: FileObj %p already"
                    " associated with open %p\n", pIrpSp->FileObject, pOpenContext));

                NtStatus = STATUS_DEVICE_BUSY;
                break;
            }

            NtStatus = ndisprotOpenDevice(
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            pIrpSp->FileObject,
                            &pOpenContext
                            );

            if (NT_SUCCESS(NtStatus))
            {

                DEBUGP(DL_VERY_LOUD, ("IoControl OPEN_DEVICE: Open %p <-> FileObject %p\n",
                        pOpenContext, pIrpSp->FileObject));

            }

            break;

        case IOCTL_NDISPROT_QUERY_OID_VALUE:

            NPROT_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                Status = ndisprotQueryOidValue(
                            pOpenContext,
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &BytesReturned
                            );

                NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            }
            else
            {
                NtStatus = STATUS_DEVICE_NOT_CONNECTED;
            }
            break;

        case IOCTL_NDISPROT_SET_OID_VALUE:

            NPROT_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                Status = ndisprotSetOidValue(
                            pOpenContext,
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            );

                BytesReturned = 0;

                NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            }
            else
            {
                NtStatus = STATUS_DEVICE_NOT_CONNECTED;
            }
            break;
                        
        default:

            NtStatus = STATUS_NOT_SUPPORTED;
            break;
    }

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Information = BytesReturned;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return NtStatus;
}



NTSTATUS
ndisprotOpenDevice(
    IN PUCHAR                   pDeviceName,
    IN ULONG                    DeviceNameLength,
    IN PFILE_OBJECT             pFileObject,
    OUT PNDISPROT_OPEN_CONTEXT * ppOpenContext
    )
/*++

Routine Description:

    Helper routine called to process IOCTL_NDISPROT_OPEN_DEVICE. Check if
    there is a binding to the specified device, and is not associated with
    a file object already. If so, make an association between the binding
    and this file object.

Arguments:

    pDeviceName - pointer to device name string
    DeviceNameLength - length of above
    pFileObject - pointer to file object being associated with the device binding

Return Value:

    Status is returned.
--*/
{
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    NTSTATUS                NtStatus;
    ULONG                   PacketFilter;
    NDIS_STATUS             NdisStatus;
    ULONG                   BytesProcessed;
    PNDISPROT_OPEN_CONTEXT   pCurrentOpenContext = NULL;

    pOpenContext = NULL;

    do
    {
        pOpenContext = ndisprotLookupDevice(
                        pDeviceName,
                        DeviceNameLength
                        );

        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("ndisprotOpenDevice: couldn't find device\n"));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
        }

        //
        //  else ndisprotLookupDevice would have addref'ed the open.
        //
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE))
        {
            NPROT_ASSERT(pOpenContext->pFileObject != NULL);

            DEBUGP(DL_WARN, ("ndisprotOpenDevice: Open %p/%x already associated"
                " with another FileObject %p\n", 
                pOpenContext, pOpenContext->Flags, pOpenContext->pFileObject));
            
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            NPROT_DEREF_OPEN(pOpenContext); // ndisprotOpenDevice failure
            NtStatus = STATUS_DEVICE_BUSY;
            break;
        }
        //
        // This InterlockedXXX function performs an atomic operation: First it compare
        // pFileObject->FsContext with NULL, if they are equal, the function puts  pOpenContext
        // into FsContext, and return NULL. Otherwise, it return pFileObject->FsContext without
        // changing anything.
        // 
            
        if ((pCurrentOpenContext = InterlockedCompareExchangePointer (& (pFileObject->FsContext), pOpenContext, NULL)) != NULL)
        {
            //
            // pFileObject->FsContext already is used by other open
            //
            DEBUGP(DL_WARN, ("ndisprotOpenDevice: FileObject %p already associated"
                " with another Open %p/%x\n", 
                pFileObject, pCurrentOpenContext, pCurrentOpenContext->Flags));  //BUG
            
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            NPROT_DEREF_OPEN(pOpenContext); // ndisprotOpenDevice failure
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        pOpenContext->pFileObject = pFileObject;

        NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_ACTIVE);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set the packet filter now.
        //
        PacketFilter = NUIOO_PACKET_FILTER;
        NdisStatus = ndisprotValidateOpenAndDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesProcessed,
                        TRUE    // Do wait for power on
                        );
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("openDevice: Open %p: set packet filter (%x) failed: %x\n",
                    pOpenContext, PacketFilter, NdisStatus));

            //
            //  Undo all that we did above.
            //
            NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
            //
            // Need to set pFileObject->FsContext to NULL again, so others can open a device
            // for this file object later
            //
            pCurrentOpenContext = InterlockedCompareExchangePointer (& (pFileObject->FsContext), NULL, pOpenContext);
            
     
            NPROT_ASSERT(pCurrentOpenContext == pOpenContext);
            
            NPROT_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE);
            pOpenContext->pFileObject = NULL;

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            NPROT_DEREF_OPEN(pOpenContext); // ndisprotOpenDevice failure

            NDIS_STATUS_TO_NT_STATUS(NdisStatus, &NtStatus);
            break;
        }

        *ppOpenContext = pOpenContext;
        
        NtStatus = STATUS_SUCCESS;
    }
    while (FALSE);

    return (NtStatus);
}


VOID
ndisprotRefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Reference the given open context.

    NOTE: Can be called with or without holding the opencontext lock.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    NdisInterlockedIncrement((PLONG)&pOpenContext->RefCount);
}


VOID
ndisprotDerefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Dereference the given open context. If the ref count goes to zero,
    free it.

    NOTE: called without holding the opencontext lock

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    if (NdisInterlockedDecrement((PLONG)&pOpenContext->RefCount) == 0)
    {
        DEBUGP(DL_INFO, ("DerefOpen: Open %p, Flags %x, ref count is zero!\n",
            pOpenContext, pOpenContext->Flags));
        
        NPROT_ASSERT(pOpenContext->BindingHandle == NULL);
        NPROT_ASSERT(pOpenContext->RefCount == 0);
        NPROT_ASSERT(pOpenContext->pFileObject == NULL);

        pOpenContext->oc_sig++;

        //
        //  Free it.
        //
        NPROT_FREE_MEM(pOpenContext);
    }
}


#if DBG
VOID
ndisprotDbgRefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("  RefOpen: Open %p, old ref %d, File %c%c%c%c, line %d\n",
            pOpenContext,
            pOpenContext->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    ndisprotRefOpen(pOpenContext);
}

VOID
ndisprotDbgDerefOpen(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("DerefOpen: Open %p, old ref %d, File %c%c%c%c, line %d\n",
            pOpenContext,
            pOpenContext->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    ndisprotDerefOpen(pOpenContext);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\ndisprot\sys\recv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    NDIS protocol entry points and utility routines to handle receiving
    data.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/6/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'VCER'



NTSTATUS
NdisProtRead(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_READ. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus;
    PNDISPROT_OPEN_CONTEXT   pOpenContext;

    UNREFERENCED_PARAMETER(pDeviceObject);
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    do
    {
        //
        // Validate!
        //
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL FsContext on FileObject %p\n",
                        pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
            
        NPROT_STRUCT_ASSERT(pOpenContext, oc);

        if (pIrp->MdlAddress == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL MDL address on IRP %p\n", pIrp));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Try to get a virtual address for the MDL.
        //
#ifndef WIN9X
        if (MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority) == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: MmGetSystemAddr failed for IRP %p, MDL %p\n",
                    pIrp, pIrp->MdlAddress));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
#endif
        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }

        //
        //  Add this IRP to the list of pended Read IRPs
        //
        NPROT_INSERT_TAIL_LIST(&pOpenContext->PendedReads, &pIrp->Tail.Overlay.ListEntry);
        NPROT_REF_OPEN(pOpenContext);  // pended read IRP
        pOpenContext->PendedReadCount++;

        //
        //  Set up the IRP for possible cancellation.
        //
        pIrp->Tail.Overlay.DriverContext[0] = (PVOID)pOpenContext;
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp, NdisProtCancelRead);

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        NtStatus = STATUS_PENDING;

        //
        //  Run the service routine for reads.
        //
        ndisprotServiceReads(pOpenContext);

    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        NPROT_ASSERT(NtStatus != STATUS_SUCCESS);
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return (NtStatus);
}


VOID
NdisProtCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    )
/*++

Routine Description:

    Cancel a pending read IRP. We unlink the IRP from the open context
    queue and complete it.

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - IRP to be cancelled

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pIrpEntry;
    BOOLEAN                     Found;

    UNREFERENCED_PARAMETER(pDeviceObject);
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    Found = FALSE;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT) pIrp->Tail.Overlay.DriverContext[0];
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    //
    //  Locate the IRP in the pended read queue and remove it if found.
    //
    for (pIrpEntry = pOpenContext->PendedReads.Flink;
         pIrpEntry != &pOpenContext->PendedReads;
         pIrpEntry = pIrpEntry->Flink)
    {
        if (pIrp == CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry))
        {
            NPROT_REMOVE_ENTRY_LIST(&pIrp->Tail.Overlay.ListEntry);
            pOpenContext->PendedReadCount--;
            Found = TRUE;
            break;
        }
    }

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    if (Found)
    {
        DEBUGP(DL_INFO, ("CancelRead: Open %p, IRP %p\n", pOpenContext, pIrp));
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        NPROT_DEREF_OPEN(pOpenContext); // Cancel removed pended Read
    }
}
        


VOID
ndisprotServiceReads(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Utility routine to copy received data into user buffers and
    complete READ IRPs.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;
    PNDIS_PACKET        pRcvPacket;
    PLIST_ENTRY         pRcvPacketEntry;
    PUCHAR              pSrc, pDst;
    ULONG               BytesRemaining; // at pDst
    PNDIS_BUFFER        pNdisBuffer;
    ULONG               BytesAvailable;
    BOOLEAN             FoundPendingIrp;

    DEBUGP(DL_VERY_LOUD, ("ServiceReads: open %p/%x\n",
            pOpenContext, pOpenContext->Flags));

    NPROT_REF_OPEN(pOpenContext);  // temp ref - service reads

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    while (!NPROT_IS_LIST_EMPTY(&pOpenContext->PendedReads) &&
           !NPROT_IS_LIST_EMPTY(&pOpenContext->RecvPktQueue))
    {
        FoundPendingIrp = FALSE;
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pOpenContext->PendedReads.Flink;
        while (pIrpEntry != &pOpenContext->PendedReads)
        {
            pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

            //
            //  Check to see if it is being cancelled.
            //
            if (IoSetCancelRoutine(pIrp, NULL))
            {
                //
                //  It isn't being cancelled, and can't be cancelled henceforth.
                //
                NPROT_REMOVE_ENTRY_LIST(pIrpEntry);
                FoundPendingIrp = TRUE;
                break;

                //
                //  NOTE: we decrement PendedReadCount way below in the
                //  while loop, to avoid letting through a thread trying
                //  to unbind.
                //
            }
            else
            {
                //
                //  The IRP is being cancelled; let the cancel routine handle it.
                //
                DEBUGP(DL_INFO, ("ServiceReads: open %p, skipping cancelled IRP %p\n",
                        pOpenContext, pIrp));
                pIrpEntry = pIrpEntry->Flink;

            }
        }
        //
        // If no pending IRP
        //
        if (FoundPendingIrp == FALSE)
        {
            break;
        }
        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pOpenContext->RecvPktQueue.Flink;
        NPROT_REMOVE_ENTRY_LIST(pRcvPacketEntry);

        pOpenContext->RecvPktCount --;

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        NPROT_DEREF_OPEN(pOpenContext);  // Service: dequeue rcv packet

        pRcvPacket = NPROT_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        //
        //  Copy as much data as possible from the receive packet to
        //  the IRP MDL.
        //
#ifndef WIN9X
        pDst = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
        NPROT_ASSERT(pDst != NULL);  // since it was already mapped
#else
        pDst = MmGetSystemAddressForMdl(pIrp->MdlAddress);  // Win9x
#endif
        BytesRemaining = MmGetMdlByteCount(pIrp->MdlAddress);

        pNdisBuffer = pRcvPacket->Private.Head;

        //
        // Copy the data in the received packet into the buffer provided by the client.
        // If the length of the receive packet is greater than length of the given buffer, 
        // we just copy as many bytes as we can. Once the buffer is full, we just discard 
        // the rest of the data, and complete the IRP sucessfully even we only did a partial copy.
        // 
        while (BytesRemaining && (pNdisBuffer != NULL))
        {
#ifndef WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &pSrc, &BytesAvailable, NormalPagePriority);

            if (pSrc == NULL) 
            {
                DEBUGP(DL_FATAL,
                    ("ServiceReads: Open %p, QueryBuffer failed for buffer %p\n",
                            pOpenContext, pNdisBuffer));
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &pSrc, &BytesAvailable);
#endif

            if (BytesAvailable)
            {
                ULONG       BytesToCopy = MIN(BytesAvailable, BytesRemaining);

                NPROT_COPY_MEM(pDst, pSrc, BytesToCopy);
                BytesRemaining -= BytesToCopy;
                pDst += BytesToCopy;
            }

            NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
        }

        //
        //  Complete the IRP.
        //
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = MmGetMdlByteCount(pIrp->MdlAddress) - BytesRemaining;

        DEBUGP(DL_INFO, ("ServiceReads: Open %p, IRP %p completed with %d bytes\n",
            pOpenContext, pIrp, pIrp->IoStatus.Information));

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        //
        //  Free up the receive packet - back to the miniport if it
        //  belongs to it, else reclaim it (local copy).
        //
        if (NdisGetPoolFromPacket(pRcvPacket) != pOpenContext->RecvPacketPool)
        {
            NdisReturnPackets(&pRcvPacket, 1);
        }
        else
        {
            ndisprotFreeReceivePacket(pOpenContext, pRcvPacket);
        }

        NPROT_DEREF_OPEN(pOpenContext);    // took out pended Read

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
        pOpenContext->PendedReadCount--;

    }

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    NPROT_DEREF_OPEN(pOpenContext);    // temp ref - service reads
}




NDIS_STATUS
NdisProtReceive(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  MacReceiveContext,
    IN PVOID                        pHeaderBuffer,
    IN UINT                         HeaderBufferSize,
    IN PVOID                        pLookaheadBuffer,
    IN UINT                         LookaheadBufferSize,
    IN UINT                         PacketSize
    )
/*++

Routine Description:

    Our protocol receive handler called by NDIS, typically if we have
    a miniport below that doesn't indicate packets.

    We make a local packet/buffer copy of this data, queue it up, and
    kick off the read service routine.

Arguments:

    ProtocolBindingContext - pointer to open context
    MacReceiveContext - for use in NdisTransferData
    pHeaderBuffer - pointer to data header
    HeaderBufferSize - size of the above
    pLookaheadBuffer - pointer to buffer containing lookahead data
    LookaheadBufferSize - size of the above
    PacketSize - size of the entire packet, minus header size.

Return Value:

    NDIS_STATUS_NOT_ACCEPTED - if this packet is uninteresting
    NDIS_STATUS_SUCCESS - if we processed this successfully

--*/
{
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    NDIS_STATUS             Status;
    PNDIS_PACKET            pRcvPacket;
    PUCHAR                  pRcvData;
    UINT                    BytesTransferred;
    PNDIS_BUFFER            pOriginalNdisBuffer, pPartialNdisBuffer;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);
    pRcvPacket = NULL;
    pRcvData = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        if (HeaderBufferSize != sizeof(NDISPROT_ETH_HEADER))
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        //
        //  Allocate resources for queueing this up.
        //
        pRcvPacket = ndisprotAllocateReceivePacket(
                        pOpenContext,
                        PacketSize + HeaderBufferSize,
                        &pRcvData
                        );

        if (pRcvPacket == NULL)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        NdisMoveMappedMemory(pRcvData, pHeaderBuffer, HeaderBufferSize);

        //
        //  Check if the entire packet is within the lookahead.
        //
        if (PacketSize == LookaheadBufferSize)
        {
            NdisCopyLookaheadData(pRcvData+HeaderBufferSize,
                                  pLookaheadBuffer,
                                  LookaheadBufferSize,
                                  pOpenContext->MacOptions);
            //
            //  Queue this up for receive processing, and
            //  try to complete some read IRPs.
            //
            ndisprotQueueReceivePacket(pOpenContext, pRcvPacket);
        }
        else
        {
            //
            //  Allocate an NDIS buffer to map the receive area
            //  at an offset "HeaderBufferSize" from the current
            //  start. This is so that NdisTransferData can copy
            //  in at the right point in the destination buffer.
            //

            NdisAllocateBuffer(
                &Status,
                &pPartialNdisBuffer,
                pOpenContext->RecvBufferPool,
                pRcvData + HeaderBufferSize,
                PacketSize);
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                //  Unlink and save away the original NDIS Buffer
                //  that maps the full receive buffer.
                //
                NdisUnchainBufferAtFront(pRcvPacket, &pOriginalNdisBuffer);
                NPROT_RCV_PKT_TO_ORIGINAL_BUFFER(pRcvPacket) = pOriginalNdisBuffer;

                //
                //  Link in the partial buffer for NdisTransferData to
                //  operate on.
                //
                NdisChainBufferAtBack(pRcvPacket, pPartialNdisBuffer);

                DEBUGP(DL_LOUD, ("Receive: setting up for TransferData:"
                        " Pkt %p, OriginalBuf %p, PartialBuf %p\n",
                        pRcvPacket, pOriginalNdisBuffer, pPartialNdisBuffer));

                NdisTransferData(
                    &Status,
                    pOpenContext->BindingHandle,
                    MacReceiveContext,
                    0,  // ByteOffset
                    PacketSize,
                    pRcvPacket,
                    &BytesTransferred);
            }
            else
            {
                //
                //  Failure handled below in TransferDataComplete.
                //
                BytesTransferred = 0;
            }
    
            if (Status != NDIS_STATUS_PENDING)
            {
                NdisProtTransferDataComplete(
                    (NDIS_HANDLE)pOpenContext,
                    pRcvPacket,
                    Status,
                    BytesTransferred);
            }
        }

    }
    while (FALSE);


    DEBUGP(DL_LOUD, ("Receive: Open %p, Pkt %p, Size %d\n",
            pOpenContext, pRcvPacket, PacketSize));

    return Status;
}



VOID
NdisProtTransferDataComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  TransferStatus,
    IN UINT                         BytesTransferred
    )
/*++

Routine Description:

    NDIS entry point called to signal completion of a call to
    NdisTransferData that had pended.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - our receive packet into which data is transferred
    TransferStatus - status of the transfer
    BytesTransferred - bytes copied into the packet.

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    PNDIS_BUFFER            pOriginalBuffer, pPartialBuffer;

    UNREFERENCED_PARAMETER(BytesTransferred);
    
    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Check if an NDIS_BUFFER was created to map part of the receive buffer;
    //  if so, free it and link back the original NDIS_BUFFER that maps
    //  the full receive buffer to the packet.
    //
    pOriginalBuffer = NPROT_RCV_PKT_TO_ORIGINAL_BUFFER(pNdisPacket);
    if (pOriginalBuffer != NULL)
    {
        //
        //  We had stashed off the NDIS_BUFFER for the full receive
        //  buffer in the packet reserved area. Unlink the partial
        //  buffer and link in the full buffer.
        //
        NdisUnchainBufferAtFront(pNdisPacket, &pPartialBuffer);
        NdisChainBufferAtBack(pNdisPacket, pOriginalBuffer);

        DEBUGP(DL_LOUD, ("TransferComp: Pkt %p, OrigBuf %p, PartialBuf %p\n",
                pNdisPacket, pOriginalBuffer, pPartialBuffer));

        //
        //  Free up the partial buffer.
        //
        NdisFreeBuffer(pPartialBuffer);
    }

    if (TransferStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  Queue this up for receive processing, and
        //  try to complete some read IRPs.
        //
        ndisprotQueueReceivePacket(pOpenContext, pNdisPacket);
    }
    else
    {
        ndisprotFreeReceivePacket(pOpenContext, pNdisPacket);
    }
}


VOID
NdisProtReceiveComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    )
/*++

Routine Description:

    Protocol entry point called by NDIS when the miniport
    has finished indicating up a batch of receives.

    We ignore this.

Arguments:

    ProtocolBindingContext - pointer to open context

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT   pOpenContext;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

    return;
}


INT
NdisProtReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    )
/*++

Routine Description:

    Protocol entry point called by NDIS if the driver below
    uses NDIS 4 style receive packet indications.

    If the miniport allows us to hold on to this packet, we
    use it as is, otherwise we make a copy.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - the packet being indicated up.

Return Value:

    None

--*/
{
    PNDISPROT_OPEN_CONTEXT   pOpenContext;
    PNDIS_BUFFER            pNdisBuffer;
    UINT                    BufferLength;
    PNDISPROT_ETH_HEADER     pEthHeader;
    PNDIS_PACKET            pCopyPacket;
    PUCHAR                  pCopyBuf;
    UINT                    TotalPacketLength;
    UINT                    BytesCopied;
    INT                     RefCount = 0;
    NDIS_STATUS             Status;

    pOpenContext = (PNDISPROT_OPEN_CONTEXT)ProtocolBindingContext;
    NPROT_STRUCT_ASSERT(pOpenContext, oc);

#ifdef NDIS51
    NdisGetFirstBufferFromPacketSafe(
        pNdisPacket,
        &pNdisBuffer,
        &pEthHeader,
        &BufferLength,
        &TotalPacketLength,
        NormalPagePriority);

    if (pEthHeader == NULL)
    {
        //
        //  The system is low on resources. Set up to handle failure
        //  below.
        //
        BufferLength = 0;
    }
#else
    NdisGetFirstBufferFromPacket(
        pNdisPacket,
        &pNdisBuffer,
        &pEthHeader,
        &BufferLength,
        &TotalPacketLength);
#endif

    do
    {
        if (BufferLength < sizeof(NDISPROT_ETH_HEADER))
        {
            DEBUGP(DL_WARN,
                ("ReceivePacket: Open %p, runt pkt %p, first buffer length %d\n",
                    pOpenContext, pNdisPacket, BufferLength));

            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        DEBUGP(DL_LOUD, ("ReceivePacket: Open %p, interesting pkt %p\n",
                    pOpenContext, pNdisPacket));

        //
        //  If the miniport is out of resources, we can't queue
        //  this packet - make a copy if this is so.
        //
        if ((NDIS_GET_PACKET_STATUS(pNdisPacket) == NDIS_STATUS_RESOURCES) ||
            pOpenContext->bRunningOnWin9x)
        {
            pCopyPacket = ndisprotAllocateReceivePacket(
                            pOpenContext,
                            TotalPacketLength,
                            &pCopyBuf
                            );
            
            if (pCopyPacket == NULL)
            {
                DEBUGP(DL_FATAL, ("ReceivePacket: Open %p, failed to"
                    " alloc copy, %d bytes\n", pOpenContext, TotalPacketLength));
                break;
            }

            NdisCopyFromPacketToPacket(
                pCopyPacket,
                0,
                TotalPacketLength,
                pNdisPacket,
                0,
                &BytesCopied);
            
            NPROT_ASSERT(BytesCopied == TotalPacketLength);

            pNdisPacket = pCopyPacket;
        }
        else
        {
            //
            //  We can queue the original packet - return
            //  a packet reference count indicating that
            //  we will call NdisReturnPackets when we are
            //  done with this packet.
            //
            RefCount = 1;
        }

        //
        //  Queue this up and service any pending Read IRPs.
        //
        ndisprotQueueReceivePacket(pOpenContext, pNdisPacket);
    
    }
    while (FALSE);

    return (RefCount);
}


VOID
ndisprotQueueReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pRcvPacket
    )
/*++

Routine Description:

    Queue up a received packet on the open context structure.
    If the queue size goes beyond a water mark, discard a packet
    at the head of the queue.

    Finally, run the queue service routine.

Arguments:
    
    pOpenContext - pointer to open context
    pRcvPacket - the received packet

Return Value:

    None

--*/
{
    PLIST_ENTRY     pEnt;
    PLIST_ENTRY     pDiscardEnt;
    PNDIS_PACKET    pDiscardPkt;

    do
    {
        pEnt = NPROT_RCV_PKT_TO_LIST_ENTRY(pRcvPacket);

        NPROT_REF_OPEN(pOpenContext);    // queued rcv packet

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if the binding is in the proper state to receive
        //  this packet.
        //
        if (NPROT_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE) &&
            (pOpenContext->PowerState == NetDeviceStateD0))
        {
            NPROT_INSERT_TAIL_LIST(&pOpenContext->RecvPktQueue, pEnt);
            pOpenContext->RecvPktCount++;

            DEBUGP(DL_VERY_LOUD, ("QueueReceivePacket: open %p,"
                    " queued pkt %p, queue size %d\n",
                    pOpenContext, pRcvPacket, pOpenContext->RecvPktCount));
        }
        else
        {
            //
            //  Received this packet when the binding is going away.
            //  Drop this.
            //
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            ndisprotFreeReceivePacket(pOpenContext, pRcvPacket);

            NPROT_DEREF_OPEN(pOpenContext);  // dropped rcv packet - bad state
            break;
        }

        //
        //  Trim the queue if it has grown too big.
        //
        if (pOpenContext->RecvPktCount > MAX_RECV_QUEUE_SIZE)
        {
            //
            //  Remove the head of the queue.
            //
            pDiscardEnt = pOpenContext->RecvPktQueue.Flink;
            NPROT_REMOVE_ENTRY_LIST(pDiscardEnt);

            pOpenContext->RecvPktCount --;

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            pDiscardPkt = NPROT_LIST_ENTRY_TO_RCV_PKT(pDiscardEnt);

            ndisprotFreeReceivePacket(pOpenContext, pDiscardPkt);

            NPROT_DEREF_OPEN(pOpenContext);  // dropped rcv packet - queue too long

            DEBUGP(DL_INFO, ("QueueReceivePacket: open %p queue"
                    " too long, discarded pkt %p\n",
                    pOpenContext, pDiscardPkt));
        }
        else
        {
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);
        }

        //
        //  Run the receive queue service routine now.
        //
        ndisprotServiceReads(pOpenContext);
    }
    while (FALSE);
}


PNDIS_PACKET
ndisprotAllocateReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN UINT                         DataLength,
    OUT PUCHAR *                    ppDataBuffer
    )
/*++

Routine Description:

    Allocate resources to copy and queue a received packet.

Arguments:

    pOpenContext - pointer to open context for received packet
    DataLength - total length in bytes of the packet
    ppDataBuffer - place to return pointer to allocated buffer

Return Value:

    Pointer to NDIS packet if successful, else NULL.

--*/
{
    PNDIS_PACKET            pNdisPacket;
    PNDIS_BUFFER            pNdisBuffer;
    PUCHAR                  pDataBuffer;
    NDIS_STATUS             Status;

    pNdisPacket = NULL;
    pNdisBuffer = NULL;
    pDataBuffer = NULL;

    do
    {
        NPROT_ALLOC_MEM(pDataBuffer, DataLength);

        if (pDataBuffer == NULL)
        {
            DEBUGP(DL_FATAL, ("AllocRcvPkt: open %p, failed to alloc"
                " data buffer %d bytes\n", pOpenContext, DataLength));
            break;
        }

        //
        //  Make this an NDIS buffer.
        //
        NdisAllocateBuffer(
            &Status,
            &pNdisBuffer,
            pOpenContext->RecvBufferPool,
            pDataBuffer,
            DataLength);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_FATAL, ("AllocateRcvPkt: open %p, failed to alloc"
                " NDIS buffer, %d bytes\n", pOpenContext, DataLength));
            break;
        }

        NdisAllocatePacket(&Status, &pNdisPacket, pOpenContext->RecvPacketPool);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_FATAL, ("AllocateRcvPkt: open %p, failed to alloc"
                " NDIS packet, %d bytes\n", pOpenContext, DataLength));
            break;
        }

        NDIS_SET_PACKET_STATUS(pNdisPacket, 0);
        NPROT_RCV_PKT_TO_ORIGINAL_BUFFER(pNdisPacket) = NULL;

        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

        *ppDataBuffer = pDataBuffer;

      
    }
    while (FALSE);

    if (pNdisPacket == NULL)
    {
        //
        //  Clean up
        //
        if (pNdisBuffer != NULL)
        {
            NdisFreeBuffer(pNdisBuffer);
        }

        if (pDataBuffer != NULL)
        {
            NPROT_FREE_MEM(pDataBuffer);
        }
    }

    return (pNdisPacket);
}



VOID
ndisprotFreeReceivePacket(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pNdisPacket
    )
/*++

Routine Description:

    Free up all resources associated with a received packet. If this
    is a local copy, free the packet to our receive pool, else return
    this to the miniport.

Arguments:
    
    pOpenContext - pointer to open context
    pNdisPacket - pointer to packet to be freed.

Return Value:

    None

--*/
{
    PNDIS_BUFFER        pNdisBuffer;
    UINT                TotalLength;
    UINT                BufferLength;
    PUCHAR              pCopyData;

    if (NdisGetPoolFromPacket(pNdisPacket) == pOpenContext->RecvPacketPool)
    {
        //
        //  This is a local copy.
        //
#ifdef NDIS51
        NdisGetFirstBufferFromPacketSafe(
            pNdisPacket,
            &pNdisBuffer,
            (PVOID *)&pCopyData,
            &BufferLength,
            &TotalLength,
            NormalPagePriority);
#else
        NdisGetFirstBufferFromPacket(
            pNdisPacket,
            &pNdisBuffer,
            (PVOID *)&pCopyData,
            &BufferLength,
            &TotalLength);
#endif

        NPROT_ASSERT(BufferLength == TotalLength);

        NPROT_ASSERT(pNdisBuffer != NULL);

        NPROT_ASSERT(pCopyData != NULL); // we would have allocated non-paged pool

        NdisFreePacket(pNdisPacket);

        NdisFreeBuffer(pNdisBuffer);

        NPROT_FREE_MEM(pCopyData);
    }
    else
    {
        NdisReturnPackets(&pNdisPacket, 1);
    }
}
        

VOID
ndisprotCancelPendingReads(
    IN PNDISPROT_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Cancel any pending read IRPs queued on the given open.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;

    NPROT_REF_OPEN(pOpenContext);  // temp ref - cancel reads

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);

    while (!NPROT_IS_LIST_EMPTY(&pOpenContext->PendedReads))
    {
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pOpenContext->PendedReads.Flink;
        pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

        //
        //  Check to see if it is being cancelled.
        //
        if (IoSetCancelRoutine(pIrp, NULL))
        {
            //
            //  It isn't being cancelled, and can't be cancelled henceforth.
            //
            NPROT_REMOVE_ENTRY_LIST(pIrpEntry);

            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            //
            //  Complete the IRP.
            //
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            DEBUGP(DL_INFO, ("CancelPendingReads: Open %p, IRP %p cancelled\n",
                pOpenContext, pIrp));

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);

            NPROT_DEREF_OPEN(pOpenContext);    // took out pended Read for cancelling

            NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
            pOpenContext->PendedReadCount--;
        }
        else
        {
            //
            //  It is being cancelled, let the cancel routine handle it.
            //
            NPROT_RELEASE_LOCK(&pOpenContext->Lock);

            //
            //  Give the cancel routine some breathing space, otherwise
            //  we might end up examining the same (cancelled) IRP over
            //  and over again.
            //
            NPROT_SLEEP(1);

            NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
        }
    }

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    NPROT_DEREF_OPEN(pOpenContext);    // temp ref - cancel reads
}


VOID
ndisprotFlushReceiveQueue(
    IN PNDISPROT_OPEN_CONTEXT            pOpenContext
    )
/*++

Routine Description:

    Free any receive packets queued up on the specified open

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PLIST_ENTRY         pRcvPacketEntry;
    PNDIS_PACKET        pRcvPacket;

    NPROT_REF_OPEN(pOpenContext);  // temp ref - flushRcvQueue

    NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
    
    while (!NPROT_IS_LIST_EMPTY(&pOpenContext->RecvPktQueue))
    {
        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pOpenContext->RecvPktQueue.Flink;
        NPROT_REMOVE_ENTRY_LIST(pRcvPacketEntry);

        pOpenContext->RecvPktCount --;

        NPROT_RELEASE_LOCK(&pOpenContext->Lock);

        pRcvPacket = NPROT_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        DEBUGP(DL_LOUD, ("FlushReceiveQueue: open %p, pkt %p\n",
            pOpenContext, pRcvPacket));

        ndisprotFreeReceivePacket(pOpenContext, pRcvPacket);

        NPROT_DEREF_OPEN(pOpenContext);    // took out pended Read

        NPROT_ACQUIRE_LOCK(&pOpenContext->Lock);
    }

    NPROT_RELEASE_LOCK(&pOpenContext->Lock);

    NPROT_DEREF_OPEN(pOpenContext);    // temp ref - flushRcvQueue
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\exe\testapp.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name: testapp.c


Abstract:


Author:

     Eliyas Yakub   Dec 15, 2002

Environment:

    User mode only.

Revision History:

    
--*/

#define UNICODE 1
#define INITGUID

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <setupapi.h>
#include <dbt.h>
#include <winioctl.h>
#include <ntddndis.h> // for IOCTL_NDIS_QUERY_GLOBAL_STATS
#include <ndisguid.h> // for GUID_NDIS_LAN_CLASS
#include "testapp.h"
#include "public.h" // for IOCTL_NETVMINI_HELLO
    
//
// Global variables
//
HINSTANCE   hInst;
HWND        hWndList;
TCHAR       szTitle[]=TEXT("NETVMINI's IOCTL Test Application");
LIST_ENTRY  ListHead;
HDEVNOTIFY  hInterfaceNotification;
TCHAR       OutText[500];
UINT        ListBoxIndex = 0;
GUID        InterfaceGuid;// = GUID_NDIS_LAN_CLASS;


_inline VOID Display(PWCHAR Format, PWCHAR Str) 
{
    if(Str) {
        wsprintf(OutText, Format, Str);
    } else {
        wcscpy(OutText, Format);
    }
    SendMessage(hWndList, LB_INSERTSTRING, ListBoxIndex++, (LPARAM)OutText);
}


int PASCAL WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpszCmdParam,
                    int       nCmdShow)
{
    static    TCHAR szAppName[]=TEXT("NETVMINI TESTAPP");
    HWND      hWnd;
    MSG       msg;
    WNDCLASS  wndclass;

    InterfaceGuid = GUID_NDIS_LAN_CLASS;
    hInst=hInstance;

    if (!hPrevInstance)
       {
         wndclass.style        =  CS_HREDRAW | CS_VREDRAW;
         wndclass.lpfnWndProc  =  WndProc;
         wndclass.cbClsExtra   =  0;
         wndclass.cbWndExtra   =  0;
         wndclass.hInstance    =  hInstance;
         wndclass.hIcon        =  LoadIcon (NULL, IDI_APPLICATION);
         wndclass.hCursor      =  LoadCursor(NULL, IDC_ARROW);
         wndclass.hbrBackground=  GetStockObject(WHITE_BRUSH);
         wndclass.lpszMenuName =  TEXT("GenericMenu");
         wndclass.lpszClassName=  szAppName;

         RegisterClass(&wndclass);
       }

    hWnd = CreateWindow (szAppName,
                         szTitle,
                         WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         NULL,
                         NULL,
                         hInstance,
                         NULL);

    ShowWindow (hWnd,nCmdShow);
    UpdateWindow(hWnd);

    while (GetMessage (&msg, NULL, 0,0))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }

    return (0);
}


LRESULT FAR PASCAL 
WndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD nEventType = (DWORD)wParam; 
    PDEV_BROADCAST_HDR p = (PDEV_BROADCAST_HDR) lParam;
    DEV_BROADCAST_DEVICEINTERFACE filter;
    
    switch (message)
    {

        case WM_COMMAND:
            HandleCommands(hWnd, message, wParam, lParam);
            return 0;

        case WM_CREATE:

            hWndList = CreateWindow (TEXT("listbox"),
                         NULL,
                         WS_CHILD|WS_VISIBLE|LBS_NOTIFY |
                         WS_VSCROLL | WS_BORDER,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         hWnd,
                         (HMENU)ID_EDIT,
                         hInst,
                         NULL);
                         
            filter.dbcc_size = sizeof(filter);
            filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            filter.dbcc_classguid = InterfaceGuid;
            hInterfaceNotification = RegisterDeviceNotification(hWnd, &filter, 0);

            InitializeListHead(&ListHead);
            EnumExistingDevices(hWnd);

            return 0;

      case WM_SIZE:

            MoveWindow(hWndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            return 0;

      case WM_SETFOCUS:
            SetFocus(hWndList);
            return 0;
            
      case WM_DEVICECHANGE:      

            //
            // All the events we're interested in come with lParam pointing to
            // a structure headed by a DEV_BROADCAST_HDR.  This is denoted by
            // bit 15 of wParam being set, and bit 14 being clear.
            //
            if((wParam & 0xC000) == 0x8000) {
            
                if (!p)
                    return 0;
                                  
                if (p->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {

                    HandleDeviceInterfaceChange(hWnd, nEventType, (PDEV_BROADCAST_DEVICEINTERFACE) p);
                } else if (p->dbch_devicetype == DBT_DEVTYP_HANDLE) {

                    HandleDeviceChange(hWnd, nEventType, (PDEV_BROADCAST_HANDLE) p);
                }
            }
            return 0;

      case WM_CLOSE:
            Cleanup(hWnd);
            UnregisterDeviceNotification(hInterfaceNotification);
            return  DefWindowProc(hWnd,message, wParam, lParam);

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }
    return DefWindowProc(hWnd,message, wParam, lParam);
  }


LRESULT
HandleCommands(
    HWND     hWnd,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM     lParam
    )

{
    switch (wParam) {

        case IDM_OPEN:
            Cleanup(hWnd); // close all open handles
            EnumExistingDevices(hWnd);
            break;

        case IDM_CLOSE:           
            Cleanup(hWnd);
            break;
            
        case IDM_CTL_IOCTL:   
            {
                PDEVICE_INFO deviceInfo = NULL;
                PLIST_ENTRY thisEntry;
                BOOLEAN    found = FALSE;
                //
                // Find the Virtual miniport driver
                // We need the deviceInfo to get the handle to the device.
                //
                for(thisEntry = ListHead.Flink; thisEntry != &ListHead;
                    thisEntry = thisEntry->Flink)
                {
                    deviceInfo = CONTAINING_RECORD(thisEntry, DEVICE_INFO, ListEntry);
                    if(deviceInfo && 
                        deviceInfo->hDevice != INVALID_HANDLE_VALUE &&
                        wcsstr(deviceInfo->DeviceName, TEXT("Microsoft Virtual Ethernet Adapter"))) {
                            found = TRUE;
                            SendIoctlToControlDevice(deviceInfo);
                    }
                }
                    
                if(!found) {
                    Display(TEXT("Didn't find any NETVMINI device"), NULL);                     
                }
            }                
            break;
                                    
        case IDM_CLEAR:           
            SendMessage(hWndList, LB_RESETCONTENT, 0, 0);
            ListBoxIndex = 0;
            break;
            
        case IDM_EXIT:           
            PostQuitMessage(0);
            break;
            
        default:
            break;
    }

    return TRUE;
}


BOOL 
HandleDeviceInterfaceChange(
    HWND hWnd, 
    DWORD evtype, 
    PDEV_BROADCAST_DEVICEINTERFACE dip
    )
{
    DEV_BROADCAST_HANDLE    filter;
    PDEVICE_INFO            deviceInfo = NULL;
    
    switch (evtype)
    {
        case DBT_DEVICEARRIVAL:
        //
        // New device arrived. Open handle to the device 
        // and register notification of type DBT_DEVTYP_HANDLE
        //

        deviceInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DEVICE_INFO));
        if(!deviceInfo)
            return FALSE;
            
        InitializeListHead(&deviceInfo->ListEntry);
        InsertTailList(&ListHead, &deviceInfo->ListEntry);
        

        if(!GetDeviceDescription(dip->dbcc_name, deviceInfo->DeviceName,
                                 NULL)) {
            MessageBox(hWnd, TEXT("GetDeviceDescription failed"), TEXT("Error!"), MB_OK);  
        }

        Display(TEXT("New device Arrived (Interface Change Notification): %ws"), 
                    deviceInfo->DeviceName);

        wcscpy(deviceInfo->DevicePath, dip->dbcc_name);
        
        deviceInfo->hDevice = CreateFile(dip->dbcc_name, 
                                        GENERIC_READ |GENERIC_WRITE, 0, NULL, 
                                        OPEN_EXISTING, 0, NULL);
        if(deviceInfo->hDevice == INVALID_HANDLE_VALUE) {
            Display(TEXT("Failed to open the device: %ws"), 
                    deviceInfo->DeviceName);
            break;
        }
        Display(TEXT("Opened handled to the device: %ws"), 
                    deviceInfo->DeviceName);
        memset (&filter, 0, sizeof(filter)); //zero the structure
        filter.dbch_size = sizeof(filter);
        filter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        filter.dbch_handle = deviceInfo->hDevice;
 
        deviceInfo->hHandleNotification = 
                            RegisterDeviceNotification(hWnd, &filter, 0);
        break;
 
        case DBT_DEVICEREMOVECOMPLETE:
        Display(TEXT("Remove Complete (Interface Change Notification)"), NULL);
        break;    

        //
        // Device Removed.
        // 

        default:
        Display(TEXT("Unknown (Interface Change Notification)"), NULL);
        break;
    }
    return TRUE;
}
 
BOOL 
HandleDeviceChange(
    HWND hWnd, 
    DWORD evtype, 
    PDEV_BROADCAST_HANDLE dhp
    )
{
    UINT i;
    DEV_BROADCAST_HANDLE    filter;
    PDEVICE_INFO            deviceInfo = NULL;
    PLIST_ENTRY             thisEntry;
    HANDLE                  tempHandle;
    
    //
    // Walk the list to get the deviceInfo for this device
    // by matching the handle given in the notification.
    //
    for(thisEntry = ListHead.Flink; thisEntry != &ListHead;
                        thisEntry = thisEntry->Flink)
    {
        deviceInfo = CONTAINING_RECORD(thisEntry, DEVICE_INFO, ListEntry);
        if(dhp->dbch_handle == deviceInfo->hDevice) {
            break;
        }
        deviceInfo = NULL;
    }

    if(!deviceInfo) {
        MessageBox(hWnd, TEXT("Unknown Device"), TEXT("Error"), MB_OK);  
        return FALSE;
    }

    switch (evtype)
    {
    
    case DBT_DEVICEQUERYREMOVE:

        Display(TEXT("Query Remove (Handle Notification)"),
                        deviceInfo->DeviceName);
        //
        // Close the handle so that target device can
        // get removed. Do not unregister the notification
        // at this point, because you want to know whether
        // the device is successfully removed or not.
        //

        tempHandle = deviceInfo->hDevice;
        
        CloseDeviceHandles(deviceInfo);
        //
        // Since we use the handle to locate the deviceinfo, we
        // will reset the handle to the original value and
        // clear it in the the remove_pending message callback.
        // ugly hack..
        //
        deviceInfo->hDevice = tempHandle;            
        break;
        
    case DBT_DEVICEREMOVECOMPLETE:
 
        Display(TEXT("Remove Complete (Handle Notification):%ws"),
                    deviceInfo->DeviceName);
        //
        // Device is removed so close the handle if it's there
        // and unregister the notification
        //
 
        if (deviceInfo->hHandleNotification) {
            UnregisterDeviceNotification(deviceInfo->hHandleNotification);
            deviceInfo->hHandleNotification = NULL;
         }

         CloseDeviceHandles(deviceInfo);
         
        //
        // Unlink this deviceInfo from the list and free the memory
        //
         RemoveEntryList(&deviceInfo->ListEntry);
         HeapFree (GetProcessHeap(), 0, deviceInfo);
         
        break;
        
    case DBT_DEVICEREMOVEPENDING:
 
        Display(TEXT("Remove Pending (Handle Notification):%ws"),
                                        deviceInfo->DeviceName);
        //
        // Device is removed so close the handle if it's there
        // and unregister the notification
        //
        if (deviceInfo->hHandleNotification) {
            UnregisterDeviceNotification(deviceInfo->hHandleNotification);
            deviceInfo->hHandleNotification = NULL;
            deviceInfo->hDevice = INVALID_HANDLE_VALUE;
        }
        //
        // Unlink this deviceInfo from the list and free the memory
        //
         RemoveEntryList(&deviceInfo->ListEntry);
         HeapFree (GetProcessHeap(), 0, deviceInfo);

        break;

    case DBT_DEVICEQUERYREMOVEFAILED :
        Display(TEXT("Remove failed (Handle Notification):%ws"),
                                    deviceInfo->DeviceName);
        //
        // Remove failed. So reopen the device and register for
        // notification on the new handle. But first we should unregister
        // the previous notification.
        //
        if (deviceInfo->hHandleNotification) {
            UnregisterDeviceNotification(deviceInfo->hHandleNotification);
            deviceInfo->hHandleNotification = NULL;
         }
        deviceInfo->hDevice = CreateFile(deviceInfo->DevicePath, 
                                GENERIC_READ | GENERIC_WRITE, 
                                0, NULL, OPEN_EXISTING, 0, NULL);
        if(deviceInfo->hDevice == INVALID_HANDLE_VALUE) {
            Display(TEXT("Failed to reopen the device: %ws"), 
                    deviceInfo->DeviceName);
            //
            // Unlink this deviceInfo from the list and free the memory
            //
            RemoveEntryList(&deviceInfo->ListEntry);
            HeapFree (GetProcessHeap(), 0, deviceInfo);
            break;
        }

        //
        // Register handle based notification to receive pnp 
        // device change notification on the handle.
        //
        memset (&filter, 0, sizeof(filter)); //zero the structure
        filter.dbch_size = sizeof(filter);
        filter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        filter.dbch_handle = deviceInfo->hDevice;
 
        deviceInfo->hHandleNotification = 
                            RegisterDeviceNotification(hWnd, &filter, 0);
        Display(TEXT("Reopened device %ws"), deviceInfo->DeviceName);        
        break;
        
    default:
        Display(TEXT("Unknown (Handle Notification)"),
                                    deviceInfo->DeviceName);
        break;
 
    }
    return TRUE;
}


BOOLEAN
EnumExistingDevices(
    HWND   hWnd
)
{
    HDEVINFO                            hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA            deviceInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceInterfaceDetailData = NULL;
    ULONG                               predictedLength = 0;
    ULONG                               requiredLength = 0, bytes=0;
    DWORD                               dwRegType, error;
    DEV_BROADCAST_HANDLE                filter;
    PDEVICE_INFO                        deviceInfo =NULL;
    UINT                                i=0;

    hardwareDeviceInfo = SetupDiGetClassDevs (
                       (LPGUID)&InterfaceGuid,
                       NULL, // Define no enumerator (global)
                       NULL, // Define no
                       (DIGCF_PRESENT | // Only Devices present
                       DIGCF_DEVICEINTERFACE)); // Function class devices.
    if(INVALID_HANDLE_VALUE == hardwareDeviceInfo)
    {
        goto Error;
    }
  
    //
    // Enumerate devices of toaster class
    //
    deviceInterfaceData.cbSize = sizeof(deviceInterfaceData);

    for(i=0; SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                 0, // No care about specific PDOs
                                 (LPGUID)&InterfaceGuid,
                                 i, //
                                 &deviceInterfaceData); i++ ) {
                                 
        //
        // Allocate a function class device data structure to 
        // receive the information about this particular device.
        //

        //
        // First find out required length of the buffer
        //
        if(deviceInterfaceDetailData)
                HeapFree (GetProcessHeap(), 0, deviceInterfaceDetailData);
                
        if(!SetupDiGetDeviceInterfaceDetail (
                hardwareDeviceInfo,
                &deviceInterfaceData,
                NULL, // probing so no output buffer yet
                0, // probing so output buffer length of zero
                &requiredLength,
                NULL) && (error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Error;
        }
        predictedLength = requiredLength;

        deviceInterfaceDetailData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                                        predictedLength);
        deviceInterfaceDetailData->cbSize = 
                        sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);


        if (! SetupDiGetDeviceInterfaceDetail (
                   hardwareDeviceInfo,
                   &deviceInterfaceData,
                   deviceInterfaceDetailData,
                   predictedLength,
                   &requiredLength,
                   NULL)) {              
            goto Error;
        }

        deviceInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                        sizeof(DEVICE_INFO));
        if(!deviceInfo)
            goto Error;
            
        InitializeListHead(&deviceInfo->ListEntry);
        InsertTailList(&ListHead, &deviceInfo->ListEntry);
        
        //
        // Get the device details such as friendly name and SerialNo
        //
        if(!GetDeviceDescription(deviceInterfaceDetailData->DevicePath, 
                                 deviceInfo->DeviceName,
                                 NULL)){
            goto Error;
        }

        Display(TEXT("Found device %ws"), deviceInfo->DeviceName );

        wcscpy(deviceInfo->DevicePath, deviceInterfaceDetailData->DevicePath);
        //
        // Open an handle to the device.
        //
        deviceInfo->hDevice = CreateFile ( 
                deviceInterfaceDetailData->DevicePath,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL, // no SECURITY_ATTRIBUTES structure
                OPEN_EXISTING, // No special create flags
                0, // No special attributes
                NULL);

        if (INVALID_HANDLE_VALUE == deviceInfo->hDevice) {
            Display(TEXT("Failed to open the device: %ws"), 
                    deviceInfo->DeviceName);            
            continue;
        }
        
        Display(TEXT("Opened handled to the device: %ws"), 
                    deviceInfo->DeviceName);
        //
        // Register handle based notification to receive pnp 
        // device change notification on the handle.
        //

        memset (&filter, 0, sizeof(filter)); //zero the structure
        filter.dbch_size = sizeof(filter);
        filter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        filter.dbch_handle = deviceInfo->hDevice;

        deviceInfo->hHandleNotification = RegisterDeviceNotification(hWnd, &filter, 0);        

    } 

    if(deviceInterfaceDetailData)
        HeapFree (GetProcessHeap(), 0, deviceInterfaceDetailData);

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return 0;

Error:

    error = GetLastError();
    MessageBox(hWnd, TEXT("EnumExisting Devices failed"), TEXT("Error!"), MB_OK);  
    if(deviceInterfaceDetailData)
        HeapFree (GetProcessHeap(), 0, deviceInterfaceDetailData);

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    Cleanup(hWnd);
    return 0;
}

BOOLEAN Cleanup(HWND hWnd)
{
    PDEVICE_INFO    deviceInfo =NULL;
    PLIST_ENTRY     thisEntry;

    while (!IsListEmpty(&ListHead)) {
        thisEntry = RemoveHeadList(&ListHead);
        deviceInfo = CONTAINING_RECORD(thisEntry, DEVICE_INFO, ListEntry);
        if (deviceInfo->hHandleNotification) {
            UnregisterDeviceNotification(deviceInfo->hHandleNotification);
            deviceInfo->hHandleNotification = NULL;
        }
        CloseDeviceHandles(deviceInfo);
        HeapFree (GetProcessHeap(), 0, deviceInfo);
    }
    return TRUE;
}

VOID CloseDeviceHandles(
    IN PDEVICE_INFO deviceInfo)
{
    if(!deviceInfo) return;
    
    if (deviceInfo->hDevice != INVALID_HANDLE_VALUE && 
            deviceInfo->hDevice != NULL) {
            
        CloseHandle(deviceInfo->hDevice);
        deviceInfo->hDevice = INVALID_HANDLE_VALUE;
        
        //
        // If there is a valid control device handle, close
        // that also. We aren't going to get any notification
        // on the control-device because it's not known to PNP
        // subsystem.
        //       
        if (deviceInfo->hControlDevice != INVALID_HANDLE_VALUE && 
                        deviceInfo->hControlDevice != NULL) {
            CloseHandle(deviceInfo->hControlDevice);
            deviceInfo->hControlDevice = INVALID_HANDLE_VALUE;                            
        }
        
        Display(TEXT("Closed handle to device %ws"), deviceInfo->DeviceName );
    }
}
BOOL 
GetDeviceDescription(
    LPTSTR DevPath, 
    LPTSTR OutBuffer,
    PULONG Unused
)
{
    HDEVINFO                            hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA            deviceInterfaceData;
    SP_DEVINFO_DATA                     deviceInfoData;
    DWORD                               dwRegType, error;

    hardwareDeviceInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(INVALID_HANDLE_VALUE == hardwareDeviceInfo)
    {
        goto Error;
    }
    
    //
    // Enumerate devices of toaster class
    //
    deviceInterfaceData.cbSize = sizeof(deviceInterfaceData);

    SetupDiOpenDeviceInterface (hardwareDeviceInfo, DevPath,
                                 0, //
                                 &deviceInterfaceData);
                                 
    deviceInfoData.cbSize = sizeof(deviceInfoData);
    if(!SetupDiGetDeviceInterfaceDetail (
            hardwareDeviceInfo,
            &deviceInterfaceData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            NULL,
            &deviceInfoData) && (error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        goto Error;
    }
    //
    // Get the friendly name for this instance, if that fails
    // try to get the device description.
    //

    if(!SetupDiGetDeviceRegistryProperty(hardwareDeviceInfo, &deviceInfoData,
                                     SPDRP_FRIENDLYNAME,
                                     &dwRegType,
                                     (BYTE*) OutBuffer,
                                     MAX_PATH,
                                     NULL))
    {
        if(!SetupDiGetDeviceRegistryProperty(hardwareDeviceInfo, &deviceInfoData,
                                     SPDRP_DEVICEDESC,
                                     &dwRegType,
                                     (BYTE*) OutBuffer,
                                     MAX_PATH,
                                     NULL)){
            goto Error;
                                     
        }
        

    }

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return TRUE;

Error:

    error = GetLastError();
    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return FALSE;
}

BOOLEAN
SendIoctlToControlDevice(
    IN PDEVICE_INFO deviceInfo)
{
    BOOLEAN result = FALSE;
    UINT bytes;       

    //
    // Open handle to the control device, if it's not already opened. Please
    // note that even a non-admin user can open handle to the device with 
    // FILE_READ_ATTRIBUTES | SYNCHRONIZE DesiredAccess and send IOCTLs if the 
    // IOCTL is defined with FILE_ANY_ACCESS. So for better security avoid 
    // specifying FILE_ANY_ACCESS in your IOCTL defintions. 
    // If you open the device with GENERIC_READ, you can send IOCTL with 
    // FILE_READ_DATA access rights. If you open the device with GENERIC_WRITE, 
    // you can sedn ioctl with FILE_WRITE_DATA access rights.
    // 
    //
    
    if(deviceInfo->hControlDevice != INVALID_HANDLE_VALUE) {
            
        deviceInfo->hControlDevice = CreateFile ( 
            TEXT("\\\\.\\NETVMINI"),
            GENERIC_READ | GENERIC_WRITE,//FILE_READ_ATTRIBUTES | SYNCHRONIZE,
            FILE_SHARE_READ,
            NULL, // no SECURITY_ATTRIBUTES structure
            OPEN_EXISTING, // No special create flags
            FILE_ATTRIBUTE_NORMAL, // No special attributes
            NULL);

        if (INVALID_HANDLE_VALUE == deviceInfo->hControlDevice) {
            Display(TEXT("Failed to open the control device: %ws"), 
                    deviceInfo->DeviceName);
            return result;
        } 
    }        
    
    //
    // send ioclt requests
    //
    if(!DeviceIoControl (deviceInfo->hControlDevice,
          IOCTL_NETVMINI_READ_DATA,
          NULL, 0,
          NULL, 0,
          &bytes, NULL)) {
       Display(TEXT("Read IOCTL to %ws failed"), deviceInfo->DeviceName);                    
    } else {
       Display(TEXT("Read IOCTL to %ws succeeded"), deviceInfo->DeviceName); 
       result = TRUE;
    }
   
    if(!DeviceIoControl (deviceInfo->hControlDevice,
          IOCTL_NETVMINI_WRITE_DATA,
          NULL, 0,
          NULL, 0,
          &bytes, NULL)) {
       Display(TEXT("Write IOCTL to %ws failed"), deviceInfo->DeviceName);                    
    } else {
       Display(TEXT("Write IOCTL to %ws succeeded"), deviceInfo->DeviceName); 
       result = TRUE;
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\init.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

   INIT.C

Abstract:

    This module contains initialization helper routines called during
    MiniportInitialize.

Revision History:

Notes:

--*/
#include "miniport.h"

#pragma NDIS_PAGEABLE_FUNCTION(NICAllocAdapter)
#pragma NDIS_PAGEABLE_FUNCTION(NICFreeAdapter)
#pragma NDIS_PAGEABLE_FUNCTION(NICInitializeAdapter)
#pragma NDIS_PAGEABLE_FUNCTION(NICReadRegParameters)

NDIS_STATUS NICAllocAdapter(
    PMP_ADAPTER *pAdapter)
{
    PMP_ADAPTER Adapter = NULL;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER Buffer;
    PUCHAR pTCBMem;
    PTCB  pTCB;
    NDIS_STATUS Status;

    LONG index;

    DEBUGP(MP_TRACE, ("--> NICAllocAdapter\n"));

    *pAdapter = NULL;

    do
    {
        //
        // Allocate memory for adapter context
        //
        Status = NdisAllocateMemoryWithTag(
            &Adapter, 
            sizeof(MP_ADAPTER), 
            NIC_TAG);
        if(Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(MP_ERROR, ("Failed to allocate memory for adapter context\n"));
            break;
        }
        //
        // Zero the memory block
        //
        NdisZeroMemory(Adapter, sizeof(MP_ADAPTER));
        NdisInitializeListHead(&Adapter->List);

        //
        // Initialize Send & Recv listheads and corresponding 
        // spinlocks.
        //
        NdisInitializeListHead(&Adapter->RecvWaitList);
        NdisInitializeListHead(&Adapter->SendWaitList);
        NdisInitializeListHead(&Adapter->SendFreeList);
        NdisAllocateSpinLock(&Adapter->SendLock);                                                  

        NdisInitializeListHead(&Adapter->RecvFreeList);
        NdisAllocateSpinLock(&Adapter->RecvLock);  

        //
        // Allocate lookside list for Receive Control blocks.
        //
        NdisInitializeNPagedLookasideList(
                    &Adapter->RecvLookaside,
                    NULL, // No Allocate function
                    NULL, // No Free function
                    0,    // Reserved for system use
                    sizeof(RCB),
                    NIC_TAG, 
                    0); // Reserved for system use
                    
        MP_SET_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE); 
        
        //
        // Allocate packet pool for receive indications
        //
        NdisAllocatePacketPool(
            &Status,
            &Adapter->RecvPacketPoolHandle,
            NIC_MAX_BUSY_RECVS,
            PROTOCOL_RESERVED_SIZE_IN_PACKET);
        
        if(Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(MP_ERROR, ("NdisAllocatePacketPool failed\n"));
            break;
        }
        //
        // Initialize receive packets
        //
        for(index=0; index < NIC_MAX_BUSY_RECVS; index++)
        {
            //
            // Allocate a packet descriptor for receive packets
            // from a preallocated pool.
            //
            NdisAllocatePacket(
                &Status,
                &Packet,
                Adapter->RecvPacketPoolHandle);
            if(Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(MP_ERROR, ("NdisAllocatePacket failed\n"));
                break;
            }

            NDIS_SET_PACKET_HEADER_SIZE(Packet, ETH_HEADER_SIZE);

            //
            // Insert it into the list of free receive packets.
            //
            NdisInterlockedInsertTailList(
                &Adapter->RecvFreeList, 
                (PLIST_ENTRY)&Packet->MiniportReserved[0], 
                &Adapter->RecvLock);
        }
        
        //
        // Allocate a huge block of memory for all TCB's
        //
        Status = NdisAllocateMemoryWithTag(
            &pTCBMem, 
            sizeof(TCB) * NIC_MAX_BUSY_SENDS, 
            NIC_TAG);
        
        if(Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(MP_ERROR, ("Failed to allocate memory for TCB's\n"));
            break;
        }
        NdisZeroMemory(pTCBMem, sizeof(TCB) * NIC_MAX_BUSY_SENDS);
        Adapter->TCBMem = pTCBMem;

        //
        // Allocate a buffer pool for send buffers.
        //

        NdisAllocateBufferPool(
            &Status,
            &Adapter->SendBufferPoolHandle,
            NIC_MAX_BUSY_SENDS);
        if(Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(MP_ERROR, ("NdisAllocateBufferPool for send buffer failed\n"));
            break;
        }

        //
        // Divide the TCBMem blob into TCBs and create a buffer
        // descriptor for the Data portion of the TCBs.
        //
        for(index=0; index < NIC_MAX_BUSY_SENDS; index++)
        {
            pTCB = (PTCB) pTCBMem;
            //
            // Create a buffer descriptor for the Data portion of the TCBs.
            // Buffer descriptors are nothing but MDLs on NT systems.
            //
            NdisAllocateBuffer(
                &Status,
                &Buffer,
                Adapter->SendBufferPoolHandle,
                (PVOID)&pTCB->Data[0],
                NIC_BUFFER_SIZE);
            if(Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(MP_ERROR, ("NdisAllocateBuffer failed\n"));
                break;
            }

            //
            // Initialize the TCB structure.
            // 
            pTCB->Buffer = Buffer;
            pTCB->pData = (PUCHAR) &pTCB->Data[0];       
            pTCB->Adapter = Adapter;

            NdisInterlockedInsertTailList(
                &Adapter->SendFreeList, 
                &pTCB->List, 
                &Adapter->SendLock);

            pTCBMem = pTCBMem + sizeof(TCB);
        }

    } while(FALSE);


    *pAdapter = Adapter;

    //
    // In the failure case, the caller of this routine will end up
    // calling NICFreeAdapter to free all the successfully allocated
    // resources.
    //
    DEBUGP(MP_TRACE, ("<-- NICAllocAdapter\n"));

    return(Status);

}

void NICFreeAdapter(
    PMP_ADAPTER Adapter)
{
    NDIS_STATUS    Status;
    PNDIS_PACKET   Packet;
    PNDIS_BUFFER   Buffer;
    PUCHAR         pMem;
    PTCB           pTCB;
    PLIST_ENTRY    pEntry;

    DEBUGP(MP_TRACE, ("--> NICFreeAdapter\n"));

    ASSERT(Adapter);
    ASSERT(!Adapter->RefCount);
    
    //
    // Free all the resources we allocated for send.
    //
    while(!IsListEmpty(&Adapter->SendFreeList))
    {
        pTCB = (PTCB) NdisInterlockedRemoveHeadList(
                     &Adapter->SendFreeList, 
                     &Adapter->SendLock);
        if(!pTCB)
        {
            break;
        }

        if(pTCB->Buffer)
        {
            NdisFreeBuffer(pTCB->Buffer);
        }
    }

    if(Adapter->SendBufferPoolHandle)
    {
        NdisFreeBufferPool(Adapter->SendBufferPoolHandle);
    }

    NdisFreeMemory(Adapter->TCBMem, sizeof(TCB) * NIC_MAX_BUSY_SENDS, 0);
    ASSERT(IsListEmpty(&Adapter->SendFreeList));                  
    ASSERT(IsListEmpty(&Adapter->RecvWaitList));                  
    ASSERT(IsListEmpty(&Adapter->SendWaitList));                  
    NdisFreeSpinLock(&Adapter->SendLock);

    //
    // Free all the resources we allocated for receive.
    //
    
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE))
    {
        NdisDeleteNPagedLookasideList(&Adapter->RecvLookaside);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE);
    }
  
    while(!IsListEmpty(&Adapter->RecvFreeList))
    {
        pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                        &Adapter->RecvFreeList, 
                        &Adapter->RecvLock);
        if(pEntry)
        {
            Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);
            NdisFreePacket(Packet);
        }
    }

    if(Adapter->RecvPacketPoolHandle)
    {
        NdisFreePacketPool(Adapter->RecvPacketPoolHandle);
    }

    ASSERT(IsListEmpty(&Adapter->RecvFreeList));                  
    NdisFreeSpinLock(&Adapter->RecvLock);

    //
    // Finally free the memory for adapter context.
    //
    NdisFreeMemory(Adapter, sizeof(MP_ADAPTER), 0);  

    DEBUGP(MP_TRACE, ("<-- NICFreeAdapter\n"));
}

void NICAttachAdapter(PMP_ADAPTER Adapter)
{
    DEBUGP(MP_TRACE, ("--> NICAttachAdapter\n"));

    NdisInterlockedInsertTailList(
        &GlobalData.AdapterList, 
        &Adapter->List, 
        &GlobalData.Lock);

    DEBUGP(MP_TRACE, ("<-- NICAttachAdapter\n"));
}

void NICDetachAdapter(PMP_ADAPTER Adapter)
{
    DEBUGP(MP_TRACE, ("--> NICDetachAdapter\n"));

    NdisAcquireSpinLock(&GlobalData.Lock);
    RemoveEntryList(&Adapter->List);
    NdisReleaseSpinLock(&GlobalData.Lock); 
    DEBUGP(MP_TRACE, ("<-- NICDetachAdapter\n"));
}

NDIS_STATUS 
NICReadRegParameters(
    PMP_ADAPTER Adapter,
    NDIS_HANDLE WrapperConfigurationContext)
/*++
Routine Description:

    Read device configuration parameters from the registry
 
Arguments:

    Adapter                         Pointer to our adapter
    WrapperConfigurationContext     For use by NdisOpenConfiguration

    Should be called at IRQL = PASSIVE_LEVEL.
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_RESOURCES                                       

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE     ConfigurationHandle;
    PUCHAR          NetworkAddress;
    UINT            Length;
    PUCHAR          pAddr;
    static ULONG    g_ulAddress = 0;
    
    DEBUGP(MP_TRACE, ("--> NICReadRegParameters\n"));

    //
    // Open the registry for this adapter to read advanced 
    // configuration parameters stored by the INF file.
    //
    NdisOpenConfiguration(
        &Status,
        &ConfigurationHandle,
        WrapperConfigurationContext);
    if(Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGP(MP_ERROR, ("NdisOpenConfiguration failed\n"));
        return NDIS_STATUS_FAILURE;
    }

    //
    // Read all of our configuration parameters using NdisReadConfiguration
    // and parse the value.
    //

    //
    // Just for testing purposes, let us make up a dummy mac address.
    // In order to avoid conflicts with MAC addresses, it is usually a good
    // idea to check the IEEE OUI list (e.g. at 
    // http://standards.ieee.org/regauth/oui/oui.txt). According to that
    // list 00-50-F2 is owned by Microsoft.
    //
    // An important rule to "generating" MAC addresses is to have the 
    // "locally administered bit" set in the address, which is bit 0x02 for 
    // LSB-type networks like Ethernet. Also make sure to never set the 
    // multicast bit in any MAC address: bit 0x01 in LSB networks.
    //

    pAddr = (PUCHAR) &g_ulAddress;

    ++g_ulAddress;
    Adapter->PermanentAddress[0] = 0x02;
    Adapter->PermanentAddress[1] = 0x50;   
    Adapter->PermanentAddress[2] = 0xF2;   
    Adapter->PermanentAddress[3] = 0x00;    
    Adapter->PermanentAddress[4] = 0x00;
    Adapter->PermanentAddress[5] = pAddr[0];


    //
    // Read NetworkAddress registry value and use it as the current address 
    // if there is a software configurable NetworkAddress specified in 
    // the registry.
    //
    NdisReadNetworkAddress(
        &Status,
        &NetworkAddress,
        &Length,
        ConfigurationHandle);

    if((Status == NDIS_STATUS_SUCCESS) && (Length == ETH_LENGTH_OF_ADDRESS))
    {
        ETH_COPY_NETWORK_ADDRESS(
            Adapter->CurrentAddress,
            NetworkAddress);
    } else {
        ETH_COPY_NETWORK_ADDRESS(
            Adapter->CurrentAddress,
            Adapter->PermanentAddress);
    }

    DEBUGP(MP_LOUD, ("Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
        Adapter->PermanentAddress[0],
        Adapter->PermanentAddress[1],
        Adapter->PermanentAddress[2],
        Adapter->PermanentAddress[3],
        Adapter->PermanentAddress[4],
        Adapter->PermanentAddress[5]));

    DEBUGP(MP_LOUD, ("Current Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
        Adapter->CurrentAddress[0],
        Adapter->CurrentAddress[1],
        Adapter->CurrentAddress[2],
        Adapter->CurrentAddress[3],
        Adapter->CurrentAddress[4],
        Adapter->CurrentAddress[5]));

    Adapter->ulLinkSpeed = NIC_LINK_SPEED;

    //
    // Close the configuration registry
    //
    NdisCloseConfiguration(ConfigurationHandle);
    DEBUGP(MP_TRACE, ("<-- NICReadRegParameters\n"));

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS NICInitializeAdapter(
    IN  PMP_ADAPTER  Adapter,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    )
/*++
Routine Description:

    Query assigned resources and initialize the adapter.

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_ADAPTER_NOT_FOUND  

--*/    
{

    
    NDIS_STATUS         Status = NDIS_STATUS_ADAPTER_NOT_FOUND;      
    UCHAR               resBuf[NIC_RESOURCE_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)resBuf;
    UINT                bufSize = NIC_RESOURCE_BUF_SIZE;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDesc;
    ULONG               index;

    DEBUGP(MP_TRACE, ("---> InitializeAdapter\n"));

    do
    {
        //     
        // Get the resources assigned by the PNP manager. NDIS gets
        // these resources in IRP_MN_START_DEVICE request.
        //
        NdisMQueryAdapterResources(
            &Status, 
            WrapperConfigurationContext, 
            resList, 
            &bufSize);
    
        if (Status == NDIS_STATUS_SUCCESS)
        {
            for (index=0; index < resList->Count; index++)
            {
                pResDesc = &resList->PartialDescriptors[index];

                switch(pResDesc->Type)
                {
                    case CmResourceTypePort:
                        DEBUGP(MP_INFO, ("IoBaseAddress = 0x%x\n", 
                            NdisGetPhysicalAddressLow(pResDesc->u.Port.Start)));
                        DEBUGP(MP_INFO, ("IoRange = x%x\n", 
                                    pResDesc->u.Port.Length));
                        break;

                    case CmResourceTypeInterrupt:                   
                        DEBUGP(MP_INFO, ("InterruptLevel = x%x\n", 
                                            pResDesc->u.Interrupt.Level));
                        break;

                    case CmResourceTypeMemory:
                        DEBUGP(MP_INFO, ("MemPhysAddress(Low) = 0x%0x\n", 
                           NdisGetPhysicalAddressLow(pResDesc->u.Memory.Start)));
                        DEBUGP(MP_INFO, ("MemPhysAddress(High) = 0x%0x\n", 
                            NdisGetPhysicalAddressHigh(pResDesc->u.Memory.Start)));
                        break;
                }
            } 
        }
        
        Status = NDIS_STATUS_SUCCESS;

        //
        // Map bus-relative IO range to system IO space using 
        // NdisMRegisterIoPortRange
        //

        //        
        // Map bus-relative registers to virtual system-space
        // using NdisMMapIoSpace
        //
        

        //
        // Disable interrupts here as soon as possible
        //
                     
        //
        // Register the interrupt using NdisMRegisterInterrupt
        //
        
        //
        // Initialize the hardware with mapped resources
        //
        
#ifdef NDIS50_MINIPORT
        //
        // Register a shutdown handler for NDIS50 or earlier miniports
        // For NDIS51 miniports, set AdapterShutdownHandler.
        //
        NdisMRegisterAdapterShutdownHandler(
            Adapter->AdapterHandle,
            (PVOID) Adapter,
            (ADAPTER_SHUTDOWN_HANDLER) MPShutdown);
#endif         

        //
        // Enable the interrupt
        //
        
    } while (FALSE);
     
    DEBUGP(MP_TRACE, ("<--- InitializeAdapter, Status=%x\n", Status));

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\public.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    Public.h

Abstract:

    Header file common to app and the driver. Contains ioctl definitions
    
Author:

     Eliyas Yakub   
     
Environment:

     User & Kernel-mode

Revision History:


--*/

#define IOCTL_NETVMINI_READ_DATA \
    CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_NETVMINI_WRITE_DATA \
    CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\exe\testapp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    TESTAPP.h

Abstract:


Author:

     Eliyas Yakub   
     
Environment:


Revision History:


--*/

#ifndef __TESTAPP_H
#define __TESTAPP_H



//
// Copied Macros from ntddk.h
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                          (PCHAR)(address) - \
                          (ULONG_PTR)(&((type *)0)->field)))


#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
    
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

typedef struct _DEVICE_INFO
{
   HANDLE       hDevice; // file handle
   HANDLE       hControlDevice; // file handle
   HDEVNOTIFY   hHandleNotification; // notification handle
   TCHAR        DeviceName[MAX_PATH];// friendly name of device description
   TCHAR        DevicePath[MAX_PATH];// 
   LIST_ENTRY   ListEntry;
} DEVICE_INFO, *PDEVICE_INFO;


#define ID_EDIT 1
    
#define  IDM_OPEN       100
#define  IDM_CLOSE      101
#define  IDM_EXIT       102
#define  IDM_CTL_IOCTL  103
#define  IDM_CLEAR     105

LRESULT FAR PASCAL 
WndProc (
    HWND hwnd, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    ); 

BOOLEAN EnumExistingDevices(
    HWND   hWnd
    );

BOOL HandleDeviceInterfaceChange(
    HWND hwnd, 
    DWORD evtype, 
    PDEV_BROADCAST_DEVICEINTERFACE dip
    );
    
BOOL HandleDeviceChange(
    HWND hwnd, 
    DWORD evtype, 
    PDEV_BROADCAST_HANDLE dhp
    );

LRESULT
HandleCommands(
    HWND     hWnd,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
    );

BOOLEAN Cleanup(
    HWND hWnd
    );

BOOL 
GetDeviceDescription(
    LPTSTR InputName, 
    LPTSTR OutBuffer,
    PULONG SerialNo
    );
    
VOID CloseDeviceHandles(
    IN PDEVICE_INFO deviceInfo);

BOOLEAN
SendIoctlToControlDevice(
    IN PDEVICE_INFO deviceInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\miniport.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

   Miniport.H

Abstract:
    This module contains structure definitons and function prototypes.

Revision History:

Notes:

--*/


#ifndef _MINIPORT_H
#define _MINIPORT_H

#include <ndis.h>

#if defined(NDIS50_MINIPORT)
    #define MP_NDIS_MAJOR_VERSION       5
    #define MP_NDIS_MINOR_VERSION       0
#elif defined(NDIS51_MINIPORT)
    #define MP_NDIS_MAJOR_VERSION       5
    #define MP_NDIS_MINOR_VERSION       1
#else
#error Unsupported NDIS version
#endif

#define     ETH_HEADER_SIZE             14
#define     ETH_MAX_DATA_SIZE           1500
#define     ETH_MAX_PACKET_SIZE         ETH_HEADER_SIZE + ETH_MAX_DATA_SIZE
#define     ETH_MIN_PACKET_SIZE         60


#define NIC_TAG                             ((ULONG)'NIMV')

// media type, we use ethernet, change if necessary
#define NIC_MEDIA_TYPE                    NdisMedium802_3

// we use Internal, change to Pci, Isa, etc. properly
#define NIC_INTERFACE_TYPE                NdisInterfaceInternal     

// change to your company name instead of using Microsoft
#define NIC_VENDOR_DESC                 "Microsoft"

// Highest byte is the NIC byte plus three vendor bytes, they are normally  
// obtained from the NIC 
#define NIC_VENDOR_ID                    0x00FFFFFF   

// Update the driver version number every time you release a new driver
// The high word is the major version. The low word is the minor version. 
#define NIC_VENDOR_DRIVER_VERSION       0x00010000

#define NIC_MAX_MCAST_LIST              32
#define NIC_MAX_BUSY_SENDS              20
#define NIC_MAX_SEND_PKTS               5
#define NIC_MAX_BUSY_RECVS              20
#define NIC_MAX_LOOKAHEAD               ETH_MAX_DATA_SIZE
#define NIC_BUFFER_SIZE                 ETH_MAX_PACKET_SIZE
#define NIC_LINK_SPEED                  1000000    // in 100 bps 


#define NIC_SUPPORTED_FILTERS ( \
                NDIS_PACKET_TYPE_DIRECTED   | \
                NDIS_PACKET_TYPE_MULTICAST  | \
                NDIS_PACKET_TYPE_BROADCAST  | \
                NDIS_PACKET_TYPE_PROMISCUOUS | \
                NDIS_PACKET_TYPE_ALL_MULTICAST)

#define fMP_RESET_IN_PROGRESS               0x00000001
#define fMP_DISCONNECTED                    0x00000002 
#define fMP_ADAPTER_HALT_IN_PROGRESS        0x00000004
#define fMP_ADAPTER_SURPRISE_REMOVED         0x00000008
#define fMP_ADAPTER_RECV_LOOKASIDE          0x00000010

//
// Buffer size passed in NdisMQueryAdapterResources                            
// We should only need three adapter resources (IO, interrupt and memory),
// Some devices get extra resources, so have room for 10 resources 
//
#define NIC_RESOURCE_BUF_SIZE           (sizeof(NDIS_RESOURCE_LIST) + \
                                        (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))

//
// Message verbosity: lower values indicate higher urgency
//
#define MP_LOUD    4
#define MP_INFO    3
#define MP_TRACE   2
#define MP_WARNING 1
#define MP_ERROR   0

extern INT MPDebugLevel;    

#if DBG
#define DEBUGP(Level, Fmt) \
{ \
    if (Level <= MPDebugLevel) \
    { \
        DbgPrint("NetVMini.SYS:"); \
        DbgPrint Fmt; \
    } \
}
#else 
#define DEBUGP(Level, Fmt)
#endif


#ifndef min
#define    min(_a, _b)      (((_a) < (_b)) ? (_a) : (_b))
#endif

#ifndef max
#define    max(_a, _b)      (((_a) > (_b)) ? (_a) : (_b))
#endif

//--------------------------------------
// Utility macros        
//--------------------------------------

#define MP_SET_FLAG(_M, _F)             ((_M)->Flags |= (_F))
#define MP_CLEAR_FLAG(_M, _F)            ((_M)->Flags &= ~(_F))
#define MP_TEST_FLAG(_M, _F)            (((_M)->Flags & (_F)) != 0)
#define MP_TEST_FLAGS(_M, _F)            (((_M)->Flags & (_F)) == (_F))

#define MP_IS_READY(_M)        (((_M)->Flags & \
                                 (fMP_DISCONNECTED | fMP_RESET_IN_PROGRESS | fMP_ADAPTER_HALT_IN_PROGRESS)) == 0) 

#define MP_INC_REF(_A)              NdisInterlockedIncrement(&(_A)->RefCount)

#define MP_DEC_REF(_A) {\
                            NdisInterlockedDecrement(&(_A)->RefCount);\
                            ASSERT(_A->RefCount >= 0);\
                            if((_A)->RefCount == 0){\
                                NdisSetEvent(&(_A)->RemoveEvent);\
                            }\
                        }

#define MP_GET_REF(_A)              ((_A)->RefCount)

typedef struct _MP_GLOBAL_DATA
{
    LIST_ENTRY      AdapterList;
    NDIS_SPIN_LOCK  Lock;
} MP_GLOBAL_DATA, *PMP_GLOBAL_DATA;

extern MP_GLOBAL_DATA GlobalData;

// TCB (Transmit Control Block)
typedef struct _TCB
{
    LIST_ENTRY              List;
    LONG                    Ref;
    PVOID                   Adapter;
    PNDIS_BUFFER            Buffer;
    PNDIS_PACKET            OrgSendPacket;
    PUCHAR                  pData;        
    ULONG                   ulSize;
    UCHAR                   Data[NIC_BUFFER_SIZE];
} TCB, *PTCB;

// RCB (Receive Control Block)
typedef struct _RCB
{
    LIST_ENTRY              List;
    PNDIS_PACKET            Packet;
} RCB, *PRCB;

typedef struct _MP_ADAPTER
{
    LIST_ENTRY              List;
    LONG                    RefCount;
    NDIS_EVENT              RemoveEvent;    
    //
    // Keep track of various device objects.
    //
#if defined(NDIS_WDM)

    PDEVICE_OBJECT          Pdo; 
    PDEVICE_OBJECT          Fdo; 
    PDEVICE_OBJECT          NextDeviceObject; 
#endif
    NDIS_HANDLE             AdapterHandle;    
    ULONG                   Flags;
    UCHAR                   PermanentAddress[ETH_LENGTH_OF_ADDRESS];
    UCHAR                   CurrentAddress[ETH_LENGTH_OF_ADDRESS];
    //
    // Variables to track resources for the send operation
    //
    NDIS_HANDLE             SendBufferPoolHandle;
    LIST_ENTRY              SendFreeList;
    LIST_ENTRY              SendWaitList;
    PUCHAR                  TCBMem;
    LONG                    nBusySend;
    UINT                    RegNumTcb;// number of transmit control blocks the registry says
    NDIS_SPIN_LOCK          SendLock;      
    //
    // Variables to track resources for the Reset operation
    //
    NDIS_TIMER              ResetTimer;
    LONG                    nResetTimerCount;    
    //
    // Variables to track resources for the Receive operation
    //
    NPAGED_LOOKASIDE_LIST   RecvLookaside;
    LIST_ENTRY              RecvFreeList;
    LIST_ENTRY              RecvWaitList;
    NDIS_SPIN_LOCK          RecvLock;
    LONG                    nBusyRecv;
    NDIS_HANDLE             RecvPacketPoolHandle;
    NDIS_HANDLE             RecvPacketPool; // not used 
    NDIS_HANDLE             RecvBufferPool; // not used 
    NDIS_TIMER              RecvTimer;
    
    //
    // Packet Filter and look ahead size.
    //
    ULONG                   PacketFilter;
    ULONG                   ulLookAhead;
    ULONG                   ulLinkSpeed;
    ULONG                   ulMaxBusySends;
    ULONG                   ulMaxBusyRecvs;

    // multicast list
    ULONG                   ulMCListSize;
    UCHAR                   MCList[NIC_MAX_MCAST_LIST][ETH_LENGTH_OF_ADDRESS];
    
    // Packet counts
    ULONG64                 GoodTransmits;
    ULONG64                 GoodReceives;
    ULONG                   NumTxSinceLastAdjust;

    // Count of transmit errors
    ULONG                   TxAbortExcessCollisions;
    ULONG                   TxLateCollisions;
    ULONG                   TxDmaUnderrun;
    ULONG                   TxLostCRS;
    ULONG                   TxOKButDeferred;
    ULONG                   OneRetry;
    ULONG                   MoreThanOneRetry;
    ULONG                   TotalRetries;
    ULONG                   TransmitFailuresOther;

    // Count of receive errors
    ULONG                   RcvCrcErrors;
    ULONG                   RcvAlignmentErrors;
    ULONG                   RcvResourceErrors;
    ULONG                   RcvDmaOverrunErrors;
    ULONG                   RcvCdtFrames;
    ULONG                   RcvRuntErrors;
    
} MP_ADAPTER, *PMP_ADAPTER;


//--------------------------------------
// Miniport routines
//--------------------------------------

NDIS_STATUS 
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID RegistryPath);

NDIS_STATUS 
MPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext);

VOID 
MPAllocateComplete(
    NDIS_HANDLE MiniportAdapterContext,
    IN PVOID VirtualAddress,
    IN PNDIS_PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN PVOID Context);

BOOLEAN 
MPCheckForHang(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID 
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext);

VOID 
MPHandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID 
MPUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

VOID 
MPDisableInterrupt(
    IN PVOID Adapter);

VOID 
MPEnableInterrupt(
    IN PVOID Adapter);
                              
VOID 
MPIsr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueMiniportHandleInterrupt,
    IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS 
MPQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded);

NDIS_STATUS 
MPReset(
    OUT PBOOLEAN AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext);

VOID 
MPReturnPacket(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN PNDIS_PACKET Packet);

VOID 
MPSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets);

NDIS_STATUS
MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded);

VOID 
MPShutdown(
    IN  NDIS_HANDLE MiniportAdapterContext);

                                                      
NDIS_STATUS 
NICSendPacket(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Pakcet);
    
BOOLEAN 
NICCopyPacket(
    PMP_ADAPTER Adapter,
    PTCB pTCB, 
    PNDIS_PACKET Packet);
    
VOID 
NICQueuePacketForRecvIndication(
    PMP_ADAPTER Adapter,
    PTCB pTCB);
                  
VOID 
NICFreeRecvPacket(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Packet);
    
VOID 
NICFreeSendTCB(
    IN PMP_ADAPTER Adapter,
    IN PTCB pTCB);

VOID 
NICResetCompleteTimerDpc(
    IN    PVOID                    SystemSpecific1,
    IN    PVOID                    FunctionContext,
    IN    PVOID                    SystemSpecific2,
    IN    PVOID                    SystemSpecific3);
    
VOID 
NICFreeQueuedSendPackets(
    PMP_ADAPTER Adapter
    );
    
  
NDIS_STATUS 
NICInitializeAdapter(
    IN PMP_ADAPTER Adapter, 
    IN  NDIS_HANDLE  WrapperConfigurationContext
);
                                
NDIS_STATUS 
NICAllocAdapter(
    PMP_ADAPTER *Adapter
    );

void 
NICFreeAdapter(
    PMP_ADAPTER Adapter
    );
                                                          
void 
NICAttachAdapter(
    PMP_ADAPTER Adapter
    );

void 
NICDetachAdapter(
    PMP_ADAPTER Adapter
    );
                   
NDIS_STATUS 
NICReadRegParameters(
    PMP_ADAPTER Adapter,
    NDIS_HANDLE ConfigurationHandle);

NDIS_STATUS 
NICGetStatsCounters(
    PMP_ADAPTER Adapter, 
    NDIS_OID Oid,
    PULONG pCounter);
    
NDIS_STATUS
NICSetPacketFilter(
    IN PMP_ADAPTER Adapter,
    IN ULONG PacketFilter);

NDIS_STATUS NICSetMulticastList(
    IN PMP_ADAPTER              Adapter,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  pBytesRead,
    OUT PULONG                  pBytesNeeded
    );
    
ULONG
NICGetMediaConnectStatus(
    PMP_ADAPTER Adapter);

#ifdef NDIS51_MINIPORT

VOID 
MPCancelSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PVOID           CancelId
    );
VOID MPPnPEventNotify(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    );

#endif

VOID
NICIndicateReceiveTimerDpc(
    IN PVOID             SystemSpecific1,
    IN PVOID             FunctionContext,
    IN PVOID             SystemSpecific2,
    IN PVOID             SystemSpecific3);

BOOLEAN
NICIsPacketTransmittable(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Packet
    );

VOID 
NICFreeQueuedRecvPackets(
    PMP_ADAPTER Adapter
    );

PUCHAR 
DbgGetOidName
    (ULONG oid
    );             


#if defined(IOCTL_INTERFACE)
NDIS_STATUS
NICRegisterDevice(
    VOID
    );

NDIS_STATUS
NICDeregisterDevice(
    VOID
    );
NTSTATUS
NICDispatch(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp
    );

#else

#define NICRegisterDevice()
#define NICDeregisterDevice()
#define NICDispatch()

#endif


#endif    // _MINIPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\request.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

        Request.c
        
Abstract:

    This module contains Miniport function and helper routines for handling 
    Set & Query Information requests.
    
Revision History:

Notes:

--*/


#include "miniport.h"

NDIS_OID NICSupportedOids[] =
{
        OID_GEN_SUPPORTED_LIST,
        OID_GEN_HARDWARE_STATUS,
        OID_GEN_MEDIA_SUPPORTED,
        OID_GEN_MEDIA_IN_USE,
        OID_GEN_MAXIMUM_LOOKAHEAD,
        OID_GEN_MAXIMUM_FRAME_SIZE,
        OID_GEN_LINK_SPEED,
        OID_GEN_TRANSMIT_BUFFER_SPACE,
        OID_GEN_RECEIVE_BUFFER_SPACE,
        OID_GEN_TRANSMIT_BLOCK_SIZE,
        OID_GEN_RECEIVE_BLOCK_SIZE,
        OID_GEN_VENDOR_ID,
        OID_GEN_VENDOR_DESCRIPTION,
        OID_GEN_VENDOR_DRIVER_VERSION,
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_CURRENT_LOOKAHEAD,
        OID_GEN_DRIVER_VERSION,
        OID_GEN_MAXIMUM_TOTAL_SIZE,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_GEN_MAC_OPTIONS,
        OID_GEN_MEDIA_CONNECT_STATUS,
        OID_GEN_MAXIMUM_SEND_PACKETS,
        OID_GEN_XMIT_OK,
        OID_GEN_RCV_OK,
        OID_GEN_XMIT_ERROR,
        OID_GEN_RCV_ERROR,
        OID_GEN_RCV_NO_BUFFER,
        OID_GEN_RCV_CRC_ERROR,
        OID_GEN_TRANSMIT_QUEUE_LENGTH,
        OID_802_3_PERMANENT_ADDRESS,
        OID_802_3_CURRENT_ADDRESS,
        OID_802_3_MULTICAST_LIST,
        OID_802_3_MAC_OPTIONS,
        OID_802_3_MAXIMUM_LIST_SIZE,
        OID_802_3_RCV_ERROR_ALIGNMENT,
        OID_802_3_XMIT_ONE_COLLISION,
        OID_802_3_XMIT_MORE_COLLISIONS,
        OID_802_3_XMIT_DEFERRED,
        OID_802_3_XMIT_MAX_COLLISIONS,
        OID_802_3_RCV_OVERRUN,
        OID_802_3_XMIT_UNDERRUN,
        OID_802_3_XMIT_HEARTBEAT_FAILURE,
        OID_802_3_XMIT_TIMES_CRS_LOST,
        OID_802_3_XMIT_LATE_COLLISIONS,
        OID_PNP_CAPABILITIES,
        OID_PNP_SET_POWER,
        OID_PNP_QUERY_POWER,
        OID_PNP_ADD_WAKE_UP_PATTERN,
        OID_PNP_REMOVE_WAKE_UP_PATTERN,
        OID_PNP_ENABLE_WAKE_UP
};

NDIS_STATUS MPQueryInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID     Oid,
    IN PVOID        InformationBuffer,
    IN ULONG        InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded)
/*++

Routine Description:

    Entry point called by NDIS to query for the value of the specified OID.

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesWritten                Specifies how much info is written
    BytesNeeded                 In case the buffer is smaller than 
                                what we need, tell them how much is needed


Return Value:

    Return code from the NdisRequest below.
    
Notes: Read "Minimizing Miniport Driver Initialization Time" in the DDK
    for more info on how to handle certain OIDs that affect the init of
    a miniport.

--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER             Adapter;
    NDIS_HARDWARE_STATUS    HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM             Medium = NIC_MEDIA_TYPE;
    UCHAR                   VendorDesc[] = NIC_VENDOR_DESC;
    ULONG                   ulInfo;
    USHORT                  usInfo;                                                              
    ULONG64                 ulInfo64;
    PVOID                   pInfo = (PVOID) &ulInfo;
    ULONG                   ulInfoLen = sizeof(ulInfo);   
              
    DEBUGP(MP_LOUD, ("---> MPQueryInformation %s\n", DbgGetOidName(Oid)));

    Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    // Initialize the result
    *BytesWritten = 0;
    *BytesNeeded = 0;

    switch(Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            //
            // The OID_GEN_SUPPORTED_LIST OID specifies an array of OIDs
            // for objects that the underlying driver or its NIC supports.
            // Objects include general, media-specific, and implementation-
            // specific objects. NDIS forwards a subset of the returned 
            // list to protocols that make this query. That is, NDIS filters
            // any supported statistics OIDs out of the list because 
            // protocols never make statistics queries. 
            //
            pInfo = (PVOID) NICSupportedOids;
            ulInfoLen = sizeof(NICSupportedOids);
            break;

        case OID_GEN_HARDWARE_STATUS:
            //
            // Specify the current hardware status of the underlying NIC as
            // one of the following NDIS_HARDWARE_STATUS-type values.
            //
            pInfo = (PVOID) &HardwareStatus;
            ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
            // 
            // Specify the media types that the NIC can support but not
            // necessarily the media types that the NIC currently uses.
            // fallthrough:
        case OID_GEN_MEDIA_IN_USE:
            //
            // Specifiy a complete list of the media types that the NIC
            // currently uses. 
            //
            pInfo = (PVOID) &Medium;
            ulInfoLen = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_LOOKAHEAD:
            //
            // If the miniport driver indicates received data by calling
            // NdisXxxIndicateReceive, it should respond to OID_GEN_MAXIMUM_LOOKAHEAD
            // with the maximum number of bytes the NIC can provide as 
            // lookahead data. If that value is different from the size of the 
            // lookahead buffer supported by bound protocols, NDIS will call 
            // MiniportSetInformation to set the size of the lookahead buffer 
            // provided by the miniport driver to the minimum of the miniport 
            // driver and protocol(s) values. If the driver always indicates
            // up full packets with NdisMIndicateReceivePacket, it should 
            // set this value to the maximum total packet size, which 
            // excludes the header.
            // Upper-layer drivers examine lookahead data to determine whether
            // a packet that is associated with the lookahead data is intended
            // for one or more of their clients. If the underlying driver 
            // supports multipacket receive indications, bound protocols are 
            // given full net packets on every indication. Consequently, 
            // this value is identical to that returned for 
            // OID_GEN_RECEIVE_BLOCK_SIZE. 
            //
            if(Adapter->ulLookAhead == 0)
            {
                Adapter->ulLookAhead = NIC_MAX_LOOKAHEAD;
            }
            ulInfo = Adapter->ulLookAhead;
            break;            
            
        case OID_GEN_MAXIMUM_FRAME_SIZE:
            //
            // Specifiy the maximum network packet size, in bytes, that the 
            // NIC supports excluding the header. A NIC driver that emulates
            // another medium type for binding to a transport must ensure that
            // the maximum frame size for a protocol-supplied net packet does
            // not exceed the size limitations for the true network medium. 
            //
            ulInfo = ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE;
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            //
            // Specify the maximum total packet length, in bytes, the NIC  
            // supports including the header. A protocol driver might use 
            // this returned length as a gauge to determine the maximum 
            // size packet that a NIC driver could forward to the 
            // protocol driver. The miniport driver must never indicate
            // up to the bound protocol driver packets received over the 
            // network that are longer than the packet size specified by 
            // OID_GEN_MAXIMUM_TOTAL_SIZE.
            //
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            //
            // The OID_GEN_TRANSMIT_BLOCK_SIZE OID specifies the minimum
            // number of bytes that a single net packet occupies in the 
            // transmit buffer space of the NIC. For example, a NIC that 
            // has a transmit space divided into 256-byte pieces would have 
            // a transmit block size of 256 bytes. To calculate the total 
            // transmit buffer space on such a NIC, its driver multiplies 
            // the number of transmit buffers on the NIC by its transmit 
            // block size. In our case, the transmit block size is 
            // identical to its maximum packet size. 
            
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            //
            // The OID_GEN_RECEIVE_BLOCK_SIZE OID specifies the amount of 
            // storage, in bytes, that a single packet occupies in the receive 
            // buffer space of the NIC.
            //
            ulInfo = (ULONG) ETH_MAX_PACKET_SIZE;
            break;
            
        case OID_GEN_MAC_OPTIONS:
            //
            // Specify a bitmask that defines optional properties of the NIC.             
            // This miniport indicates receive with NdisMIndicateReceivePacket 
            // function. It has no MiniportTransferData function. Such a driver 
            // should set this NDIS_MAC_OPTION_TRANSFERS_NOT_PEND flag. 
            //
            // NDIS_MAC_OPTION_NO_LOOPBACK tells NDIS that NIC has no internal
            // loopback support so NDIS will manage loopbacks on behalf of 
            // this driver. 
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA tells the protocol that 
            // our receive buffer is not on a device-specific card. If 
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA is not set, multi-buffer
            // indications are copied to a single flat buffer.
            //
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
                NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                NDIS_MAC_OPTION_NO_LOOPBACK;
            break;

        case OID_GEN_LINK_SPEED:
            //
            // Specify the maximum speed of the NIC in kbps.
            //
            ulInfo = Adapter->ulLinkSpeed;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            //
            // Specify the amount of memory, in bytes, on the NIC that 
            // is available for buffering transmit data. A protocol can 
            // use this OID as a guide for sizing the amount of transmit 
            // data per send.            
            //
            ulInfo = ETH_MAX_PACKET_SIZE * Adapter->ulMaxBusySends;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            //
            // Specify the amount of memory on the NIC that is available 
            // for buffering receive data. A protocol driver can use this 
            // OID as a guide for advertising its receive window after it 
            // establishes sessions with remote nodes.            
            //
            ulInfo = ETH_MAX_PACKET_SIZE * Adapter->ulMaxBusyRecvs;
            break;

        case OID_GEN_VENDOR_ID:
            //
            // Specify a three-byte IEEE-registered vendor code, followed 
            // by a single byte that the vendor assigns to identify a 
            // particular NIC. The IEEE code uniquely identifies the vendor
            // and is the same as the three bytes appearing at the beginning
            // of the NIC hardware address. Vendors without an IEEE-registered
            // code should use the value 0xFFFFFF.
            //
            ulInfo = NIC_VENDOR_ID;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            //
            // Specify a zero-terminated string describing the NIC vendor.
            //
            pInfo = VendorDesc;
            ulInfoLen = sizeof(VendorDesc);
            break;
            
        case OID_GEN_VENDOR_DRIVER_VERSION:
            //
            // Specify the vendor-assigned version number of the NIC driver. 
            // The low-order half of the return value specifies the minor 
            // version; the high-order half specifies the major version.
            //
            ulInfo = NIC_VENDOR_DRIVER_VERSION;
            break;

        case OID_GEN_DRIVER_VERSION:
            //
            // Specify the NDIS version in use by the NIC driver. The high 
            // byte is the major version number; the low byte is the minor 
            // version number.
            //
            usInfo = (USHORT) (MP_NDIS_MAJOR_VERSION<<8) + MP_NDIS_MINOR_VERSION;
            pInfo = (PVOID) &usInfo;
            ulInfoLen = sizeof(USHORT);
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            //
            // If a miniport driver registers a MiniportSendPackets function,
            // MiniportQueryInformation will be called with the 
            // OID_GEN_MAXIMUM_SEND_PACKETS request. The miniport driver must
            // respond with the maximum number of packets it is prepared to 
            // handle on a single send request. The miniport driver should 
            // pick a maximum that minimizes the number of packets that it 
            // has to queue internally because it has no resources 
            // (its device is full). A miniport driver for a bus-master DMA 
            // NIC should attempt to pick a value that keeps its NIC filled
            // under anticipated loads.
            //
            ulInfo = NIC_MAX_SEND_PKTS;
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            //
            // Return the connection status of the NIC on the network as one 
            // of the following system-defined values: NdisMediaStateConnected
            // or NdisMediaStateDisconnected.
            //
            ulInfo = NICGetMediaConnectStatus(Adapter);
            break;
            
        case OID_GEN_CURRENT_PACKET_FILTER:
            //
            // Specifiy the types of net packets such as directed, broadcast 
            // multicast, for which a protocol receives indications from a 
            // NIC driver. After NIC is initialized, a protocol driver 
            // can send a set OID_GEN_CURRENT_PACKET_FILTER to a non-zero value, 
            // thereby enabling the miniport driver to indicate receive packets
            // to that protocol.
            //
            ulInfo = Adapter->PacketFilter;
            break;
                       
        case OID_PNP_CAPABILITIES:
            //
            // Return the wake-up capabilities of its NIC. If you return 
            // NDIS_STATUS_NOT_SUPPORTED, NDIS considers the miniport driver 
            // to be not Power management aware and doesn't send any power
            // or wake-up related queries such as 
            // OID_PNP_SET_POWER, OID_PNP_QUERY_POWER,
            // OID_PNP_ADD_WAKE_UP_PATTERN, OID_PNP_REMOVE_WAKE_UP_PATTERN,
            // OID_PNP_ENABLE_WAKE_UP.
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;

            break;
            //
            // Following 4 OIDs are for querying Ethernet Operational 
            // Characteristics.
            //
        case OID_802_3_PERMANENT_ADDRESS:
            //
            // Return the MAC address of the NIC burnt in the hardware.
            //
            pInfo = Adapter->PermanentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            //
            // Return the MAC address the NIC is currently programmed to
            // use. Note that this address could be different from the
            // permananent address as the user can override using 
            // registry. Read NdisReadNetworkAddress doc for more info.
            //
            pInfo = Adapter->CurrentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            //
            // The maximum number of multicast addresses the NIC driver
            // can manage. This list is global for all protocols bound 
            // to (or above) the NIC. Consequently, a protocol can receive
            // NDIS_STATUS_MULTICAST_FULL from the NIC driver when 
            // attempting to set the multicast address list, even if 
            // the number of elements in the given list is less than 
            // the number originally returned for this query.
            //
            ulInfo = NIC_MAX_MCAST_LIST;
            break;
            
        case OID_802_3_MAC_OPTIONS:
            //
            // A protocol can use this OID to determine features supported
            // by the underlying driver such as NDIS_802_3_MAC_OPTION_PRIORITY. 
            // Return zero indicating that it supports no options.
            //
            ulInfo = 0;
            break;
            
            //
            // Following list  consists of both general and Ethernet 
            // specific statistical OIDs.
            //
            
        case OID_GEN_XMIT_OK:
            ulInfo64 = Adapter->GoodTransmits;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_RCV_OK:
            ulInfo64 = Adapter->GoodReceives;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_XMIT_ERROR:
            ulInfo = Adapter->TxAbortExcessCollisions +
                Adapter->TxDmaUnderrun +
                Adapter->TxLostCRS +
                Adapter->TxLateCollisions+
                Adapter->TransmitFailuresOther;
            break;
    
        case OID_GEN_RCV_ERROR:
            ulInfo = Adapter->RcvCrcErrors +
                Adapter->RcvAlignmentErrors +
                Adapter->RcvResourceErrors +
                Adapter->RcvDmaOverrunErrors +
                Adapter->RcvRuntErrors;
            break;
    
        case OID_GEN_RCV_NO_BUFFER:
            ulInfo = Adapter->RcvResourceErrors;
            break;
    
        case OID_GEN_RCV_CRC_ERROR:
            ulInfo = Adapter->RcvCrcErrors;
            break;
    
        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            ulInfo = Adapter->RegNumTcb;
            break;
    
        case OID_802_3_RCV_ERROR_ALIGNMENT:
            ulInfo = Adapter->RcvAlignmentErrors;
            break;
    
        case OID_802_3_XMIT_ONE_COLLISION:
            ulInfo = Adapter->OneRetry;
            break;
    
        case OID_802_3_XMIT_MORE_COLLISIONS:
            ulInfo = Adapter->MoreThanOneRetry;
            break;
    
        case OID_802_3_XMIT_DEFERRED:
            ulInfo = Adapter->TxOKButDeferred;
            break;
    
        case OID_802_3_XMIT_MAX_COLLISIONS:
            ulInfo = Adapter->TxAbortExcessCollisions;
            break;
    
        case OID_802_3_RCV_OVERRUN:
            ulInfo = Adapter->RcvDmaOverrunErrors;
            break;
    
        case OID_802_3_XMIT_UNDERRUN:
            ulInfo = Adapter->TxDmaUnderrun;
            break;
    
        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
            ulInfo = Adapter->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_TIMES_CRS_LOST:
            ulInfo = Adapter->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_LATE_COLLISIONS:
            ulInfo = Adapter->TxLateCollisions;
            break;
          
        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;            
    }

    if(Status == NDIS_STATUS_SUCCESS)
    {
        if(ulInfoLen <= InformationBufferLength)
        {
            // Copy result into InformationBuffer
            *BytesWritten = ulInfoLen;
            if(ulInfoLen)
            {
                NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);
            }
        }
        else
        {
            // too short
            *BytesNeeded = ulInfoLen;
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        }
    }

    DEBUGP(MP_LOUD, ("<--- MPQueryInformation Status = 0x%08x\n", Status));
    
    return(Status);
}     

NDIS_STATUS MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded)
/*++

Routine Description:

    This is the handler for an OID set operation. 

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesRead                   Specifies how much info is read
    BytesNeeded                 In case the buffer is smaller than what 
                                we need, tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER           Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    DEBUGP(MP_LOUD, ("---> MPSetInformation %s\n", DbgGetOidName(Oid)));
    
    *BytesRead = 0;
    *BytesNeeded = 0;

    switch(Oid)
    {
        case OID_802_3_MULTICAST_LIST:
            //
            // Set the multicast address list on the NIC for packet reception.
            // The NIC driver can set a limit on the number of multicast 
            // addresses bound protocol drivers can enable simultaneously. 
            // NDIS returns NDIS_STATUS_MULTICAST_FULL if a protocol driver 
            // exceeds this limit or if it specifies an invalid multicast 
            // address.
            //
            Status = NICSetMulticastList(
                            Adapter,
                            InformationBuffer,
                            InformationBufferLength,
                            BytesRead,
                            BytesNeeded);
            
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            // 
            // Program the hardware to indicate the packets
            // of certain filter types.
            //
            if(InformationBufferLength != sizeof(ULONG))
            {
                *BytesNeeded = sizeof(ULONG);
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }

            *BytesRead = InformationBufferLength;
                             
            Status = NICSetPacketFilter(
                            Adapter,
                            *((PULONG)InformationBuffer));

            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            //
            // A protocol driver can set a suggested value for the number
            // of bytes to be used in its binding; however, the underlying
            // NIC driver is never required to limit its indications to 
            // the value set.
            //            
            if(InformationBufferLength != sizeof(ULONG)){
                *BytesNeeded = sizeof(ULONG);
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }                
            Adapter->ulLookAhead = *(PULONG)InformationBuffer;                

            *BytesRead = sizeof(ULONG);
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;

    }
    
    if(Status == NDIS_STATUS_SUCCESS)
    {
        *BytesRead = InformationBufferLength;
    }

    DEBUGP(MP_LOUD, ("<-- MPSetInformation Status = 0x%08x\n", Status));
    
    return(Status);
}

ULONG NICGetMediaConnectStatus(
    PMP_ADAPTER Adapter
    )
/*++
Routine Description:
    This routine will query the hardware and return      
    the media status.

Arguments:
    IN PMP_ADAPTER Adapter - pointer to adapter block
   
Return Value:
    NdisMediaStateDisconnected or
    NdisMediaStateConnected
    
--*/
{
    if(MP_TEST_FLAG(Adapter, fMP_DISCONNECTED))
    {
        return(NdisMediaStateDisconnected);
    }
    else
    {
        return(NdisMediaStateConnected);
    }
}

NDIS_STATUS NICSetPacketFilter(
    IN PMP_ADAPTER Adapter,
    IN ULONG PacketFilter)
/*++
Routine Description:
    This routine will set up the adapter so that it accepts packets 
    that match the specified packet filter.  The only filter bits   
    that can truly be toggled are for broadcast and promiscuous     

Arguments:
    IN PMP_ADAPTER Adapter - pointer to adapter block
    IN ULONG PacketFilter - the new packet filter 
    
Return Value:
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/

{
    NDIS_STATUS      Status = NDIS_STATUS_SUCCESS;
    
    DEBUGP(MP_TRACE, ("--> NICSetPacketFilter\n"));
    
    // any bits not supported?
    if(PacketFilter & ~NIC_SUPPORTED_FILTERS)
    {
        return(NDIS_STATUS_NOT_SUPPORTED);
    }
    
    // any filtering changes?
    if(PacketFilter != Adapter->PacketFilter)
    {   
        //
        // Change the filtering modes on hardware
        // TODO 
                
                
        // Save the new packet filter value                                                               
        Adapter->PacketFilter = PacketFilter;
    }

    DEBUGP(MP_TRACE, ("<-- NICSetPacketFilter\n"));
    
    return(Status);
}


NDIS_STATUS NICSetMulticastList(
    IN PMP_ADAPTER              Adapter,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  pBytesRead,
    OUT PULONG                  pBytesNeeded
    )
/*++
Routine Description:
    This routine will set up the adapter for a specified multicast
    address list.                                                 
    
Arguments:
    IN PMP_ADAPTER Adapter - Pointer to adapter block
    InformationBuffer       - Buffer for information
    InformationBufferLength   Size of this buffer
    pBytesRead                Specifies how much info is read
    BytesNeeded               In case the buffer is smaller than 
                                what we need, tell them how much is needed
    
Return Value:

    NDIS_STATUS
    
--*/
{
    NDIS_STATUS            Status = NDIS_STATUS_SUCCESS;
    ULONG                  index;

    DEBUGP(MP_TRACE, ("--> NICSetMulticastList\n"));
    
    //
    // Initialize.
    //
    *pBytesNeeded = ETH_LENGTH_OF_ADDRESS;
    *pBytesRead = InformationBufferLength;

    do
    {
        if (InformationBufferLength % ETH_LENGTH_OF_ADDRESS)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (InformationBufferLength > (NIC_MAX_MCAST_LIST * ETH_LENGTH_OF_ADDRESS))
        {
            Status = NDIS_STATUS_MULTICAST_FULL;
            *pBytesNeeded = NIC_MAX_MCAST_LIST * ETH_LENGTH_OF_ADDRESS;
            break;
        }

        //
        // Protect the list update with a lock if it can be updated by
        // another thread simultaneously.
        //

        NdisZeroMemory(Adapter->MCList,
                       NIC_MAX_MCAST_LIST * ETH_LENGTH_OF_ADDRESS);
        
        NdisMoveMemory(Adapter->MCList,
                       InformationBuffer,
                       InformationBufferLength);
        
        Adapter->ulMCListSize =    InformationBufferLength / ETH_LENGTH_OF_ADDRESS;
        
#if DBG
        // display the multicast list
        for(index = 0; index < Adapter->ulMCListSize; index++)
        {
            DEBUGP(MP_LOUD, ("MC(%d) = %02x-%02x-%02x-%02x-%02x-%02x\n", 
                index,
                Adapter->MCList[index][0],
                Adapter->MCList[index][1],
                Adapter->MCList[index][2],
                Adapter->MCList[index][3],
                Adapter->MCList[index][4],
                Adapter->MCList[index][5]));
        }
#endif        
    }
    while (FALSE);    

    //
    // Program the hardware to add suport for these muticast addresses
    // 

    DEBUGP(MP_TRACE, ("<-- NICSetMulticastList\n"));
    
    return(Status);

}

PUCHAR DbgGetOidName(ULONG oid)
{
    PCHAR oidName;

    switch (oid){

        #undef MAKECASE
        #define MAKECASE(oidx) case oidx: oidName = #oidx; break;

        MAKECASE(OID_GEN_SUPPORTED_LIST)
        MAKECASE(OID_GEN_HARDWARE_STATUS)
        MAKECASE(OID_GEN_MEDIA_SUPPORTED)
        MAKECASE(OID_GEN_MEDIA_IN_USE)
        MAKECASE(OID_GEN_MAXIMUM_LOOKAHEAD)
        MAKECASE(OID_GEN_MAXIMUM_FRAME_SIZE)
        MAKECASE(OID_GEN_LINK_SPEED)
        MAKECASE(OID_GEN_TRANSMIT_BUFFER_SPACE)
        MAKECASE(OID_GEN_RECEIVE_BUFFER_SPACE)
        MAKECASE(OID_GEN_TRANSMIT_BLOCK_SIZE)
        MAKECASE(OID_GEN_RECEIVE_BLOCK_SIZE)
        MAKECASE(OID_GEN_VENDOR_ID)
        MAKECASE(OID_GEN_VENDOR_DESCRIPTION)
        MAKECASE(OID_GEN_CURRENT_PACKET_FILTER)
        MAKECASE(OID_GEN_CURRENT_LOOKAHEAD)
        MAKECASE(OID_GEN_DRIVER_VERSION)
        MAKECASE(OID_GEN_MAXIMUM_TOTAL_SIZE)
        MAKECASE(OID_GEN_PROTOCOL_OPTIONS)
        MAKECASE(OID_GEN_MAC_OPTIONS)
        MAKECASE(OID_GEN_MEDIA_CONNECT_STATUS)
        MAKECASE(OID_GEN_MAXIMUM_SEND_PACKETS)
        MAKECASE(OID_GEN_VENDOR_DRIVER_VERSION)
        MAKECASE(OID_GEN_SUPPORTED_GUIDS)
        MAKECASE(OID_GEN_NETWORK_LAYER_ADDRESSES)
        MAKECASE(OID_GEN_TRANSPORT_HEADER_OFFSET)
        MAKECASE(OID_GEN_MEDIA_CAPABILITIES)
        MAKECASE(OID_GEN_PHYSICAL_MEDIUM)
        MAKECASE(OID_GEN_XMIT_OK)
        MAKECASE(OID_GEN_RCV_OK)
        MAKECASE(OID_GEN_XMIT_ERROR)
        MAKECASE(OID_GEN_RCV_ERROR)
        MAKECASE(OID_GEN_RCV_NO_BUFFER)
        MAKECASE(OID_GEN_DIRECTED_BYTES_XMIT)
        MAKECASE(OID_GEN_DIRECTED_FRAMES_XMIT)
        MAKECASE(OID_GEN_MULTICAST_BYTES_XMIT)
        MAKECASE(OID_GEN_MULTICAST_FRAMES_XMIT)
        MAKECASE(OID_GEN_BROADCAST_BYTES_XMIT)
        MAKECASE(OID_GEN_BROADCAST_FRAMES_XMIT)
        MAKECASE(OID_GEN_DIRECTED_BYTES_RCV)
        MAKECASE(OID_GEN_DIRECTED_FRAMES_RCV)
        MAKECASE(OID_GEN_MULTICAST_BYTES_RCV)
        MAKECASE(OID_GEN_MULTICAST_FRAMES_RCV)
        MAKECASE(OID_GEN_BROADCAST_BYTES_RCV)
        MAKECASE(OID_GEN_BROADCAST_FRAMES_RCV)
        MAKECASE(OID_GEN_RCV_CRC_ERROR)
        MAKECASE(OID_GEN_TRANSMIT_QUEUE_LENGTH)
        MAKECASE(OID_GEN_GET_TIME_CAPS)
        MAKECASE(OID_GEN_GET_NETCARD_TIME)
        MAKECASE(OID_GEN_NETCARD_LOAD)
        MAKECASE(OID_GEN_DEVICE_PROFILE)
        MAKECASE(OID_GEN_INIT_TIME_MS)
        MAKECASE(OID_GEN_RESET_COUNTS)
        MAKECASE(OID_GEN_MEDIA_SENSE_COUNTS)
        MAKECASE(OID_PNP_CAPABILITIES)
        MAKECASE(OID_PNP_SET_POWER)
        MAKECASE(OID_PNP_QUERY_POWER)
        MAKECASE(OID_PNP_ADD_WAKE_UP_PATTERN)
        MAKECASE(OID_PNP_REMOVE_WAKE_UP_PATTERN)
        MAKECASE(OID_PNP_ENABLE_WAKE_UP)
        MAKECASE(OID_802_3_PERMANENT_ADDRESS)
        MAKECASE(OID_802_3_CURRENT_ADDRESS)
        MAKECASE(OID_802_3_MULTICAST_LIST)
        MAKECASE(OID_802_3_MAXIMUM_LIST_SIZE)
        MAKECASE(OID_802_3_MAC_OPTIONS)
        MAKECASE(OID_802_3_RCV_ERROR_ALIGNMENT)
        MAKECASE(OID_802_3_XMIT_ONE_COLLISION)
        MAKECASE(OID_802_3_XMIT_MORE_COLLISIONS)
        MAKECASE(OID_802_3_XMIT_DEFERRED)
        MAKECASE(OID_802_3_XMIT_MAX_COLLISIONS)
        MAKECASE(OID_802_3_RCV_OVERRUN)
        MAKECASE(OID_802_3_XMIT_UNDERRUN)
        MAKECASE(OID_802_3_XMIT_HEARTBEAT_FAILURE)
        MAKECASE(OID_802_3_XMIT_TIMES_CRS_LOST)
        MAKECASE(OID_802_3_XMIT_LATE_COLLISIONS)

        default: 
            oidName = "<** UNKNOWN OID **>";
            break;
    }

    return oidName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\miniport.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

   Miniport.C

Abstract:

    The purpose of this sample is to illustrate functionality of a deserialized
    NDIS miniport driver without requiring a physical network adapter. This 
    sample is based on E100BEX sample present in the DDK. It is basically a 
    simplified version of E100bex driver. The driver can be installed either 
    manually using Add Hardware wizard as a root enumerated virtual miniport 
    driver or on a virtual bus (like toaster bus). Since the driver does not 
    interact with any hardware, it makes it very easy to understand the miniport
    interface and the usage of various NDIS functions without the clutter of
    hardware specific code normally found in a fully functional driver. 

    This sample provides an example of minimal driver intended for education
    purposes. Neither the driver or it's sample test programs are intended
    for use in a production environment. 

Author:  Eliyas Yakub (Nov 20th 2002)

Revision History:

Notes:

--*/
#include "miniport.h"

#pragma NDIS_INIT_FUNCTION(DriverEntry)
#pragma NDIS_PAGEABLE_FUNCTION(MPInitialize)
#pragma NDIS_PAGEABLE_FUNCTION(MPHalt)
#pragma NDIS_PAGEABLE_FUNCTION(MPUnload)

#ifdef NDIS51_MINIPORT   
#pragma NDIS_PAGEABLE_FUNCTION(MPPnPEventNotify)
#endif    

MP_GLOBAL_DATA  GlobalData;
INT             MPDebugLevel = MP_INFO;
NDIS_HANDLE     NdisWrapperHandle;

NDIS_STATUS 
DriverEntry(
    PVOID DriverObject,
    PVOID RegistryPath)
/*++
Routine Description:

    In the context of its DriverEntry function, a miniport driver associates
    itself with NDIS, specifies the NDIS version that it is using, and 
    registers its entry points. 


Arguments:
    PVOID DriverObject - pointer to the driver object. 
    PVOID RegistryPath - pointer to the driver registry path.

    Return Value:
    
    NDIS_STATUS_xxx code

--*/
{

    NDIS_STATUS                   Status;
    NDIS_MINIPORT_CHARACTERISTICS MPChar;

    DEBUGP(MP_TRACE, ("---> DriverEntry built on "__DATE__" at "__TIME__ "\n"));

    //
    // Associate the miniport driver with NDIS by calling the 
    // NdisMInitializeWrapper. This function allocates a structure
    // to represent this association, stores the miniport driver-
    // specific information that the NDIS Library needs in this 
    // structure, and returns NdisWrapperHandle. The driver must retain and 
    // pass this handle to NdisMRegisterMiniport when it registers its entry 
    // points. NDIS will use NdisWrapperHandle to identify the miniport driver. 
    // The miniport driver must retain this handle but it should never attempt
    // to access or interpret this handle.
    //
    NdisMInitializeWrapper(
            &NdisWrapperHandle,
            DriverObject,
            RegistryPath,
            NULL
            );
    //
    // Fill in the Miniport characteristics structure with the version numbers 
    // and the entry points for driver-supplied MiniportXxx 
    //
    NdisZeroMemory(&MPChar, sizeof(MPChar));
    
    //
    // The NDIS version number, in addition to being included in 
    // NDIS_MINIPORT_CHARACTERISTICS, must also be specified when the 
    // miniport driver source code is compiled.
    //
    MPChar.MajorNdisVersion          = MP_NDIS_MAJOR_VERSION;
    MPChar.MinorNdisVersion          = MP_NDIS_MINOR_VERSION;
    
    MPChar.InitializeHandler         = MPInitialize;
    MPChar.HaltHandler               = MPHalt;
    
    MPChar.SetInformationHandler     = MPSetInformation;
    MPChar.QueryInformationHandler   = MPQueryInformation;
    
    MPChar.SendPacketsHandler        = MPSendPackets;
    MPChar.ReturnPacketHandler       = MPReturnPacket;

    MPChar.ResetHandler              = MPReset;
    MPChar.CheckForHangHandler       = MPCheckForHang; //optional

    MPChar.AllocateCompleteHandler   = MPAllocateComplete;//optional

    MPChar.DisableInterruptHandler   = MPDisableInterrupt; //optional
    MPChar.EnableInterruptHandler    = MPEnableInterrupt; //optional
    MPChar.HandleInterruptHandler    = MPHandleInterrupt;
    MPChar.ISRHandler                = MPIsr;

#ifdef NDIS51_MINIPORT
    MPChar.CancelSendPacketsHandler = MPCancelSendPackets;
    MPChar.PnPEventNotifyHandler    = MPPnPEventNotify;
    MPChar.AdapterShutdownHandler   = MPShutdown;
#endif


    DEBUGP(MP_LOUD, ("Calling NdisMRegisterMiniport...\n"));

    //
    // Registers miniport's entry points with the NDIS library as the first
    // step in NIC driver initialization. The NDIS will call the 
    // MiniportInitialize when the device is actually started by the PNP
    // manager.
    //
    Status = NdisMRegisterMiniport(
                    NdisWrapperHandle,
                    &MPChar,
                    sizeof(NDIS_MINIPORT_CHARACTERISTICS));
    if (Status != NDIS_STATUS_SUCCESS) {
        
        DEBUGP(MP_ERROR, ("Status = 0x%08x\n", Status));
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
        
    } else {
        //
        // Initialize the global variables. The ApaterList in the
        // GloablData structure is used to track the multiple instances
        // of the same adapter. Make sure you do that before registering
        // the unload handler.
        //
        NdisAllocateSpinLock(&GlobalData.Lock);
        NdisInitializeListHead(&GlobalData.AdapterList);        
        //
        // Register an Unload handler for global data cleanup. The unload handler
        // has a more global scope, whereas the scope of the MiniportHalt function
        // is restricted to a particular miniport instance.
        //
        NdisMRegisterUnloadHandler(NdisWrapperHandle, MPUnload);

    }

    
    DEBUGP(MP_TRACE, ("<--- DriverEntry\n"));
    return Status;
    
}

NDIS_STATUS 
MPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext)
/*++
Routine Description:

    The MiniportInitialize function is a required function that sets up a 
    NIC (or virtual NIC) for network I/O operations, claims all hardware 
    resources necessary to the NIC in the registry, and allocates resources
    the driver needs to carry out network I/O operations.

    MiniportInitialize runs at IRQL = PASSIVE_LEVEL.
    
Arguments:

    Return Value:
    
    NDIS_STATUS_xxx code

--*/
{
    NDIS_STATUS          Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER          Adapter=NULL;
    NDIS_HANDLE          ConfigurationHandle;
    UINT                 index;
   
    DEBUGP(MP_TRACE, ("---> MPInitialize\n"));

    do {
        //
        // Check to see if our media type exists in an array of supported 
        // media types provided by NDIS.
        //
        for(index = 0; index < MediumArraySize; ++index)
        {
            if(MediumArray[index] == NIC_MEDIA_TYPE) {
                break;
            }
        }

        if(index == MediumArraySize)
        {
            DEBUGP(MP_ERROR, ("Expected media is not in MediumArray.\n"));
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        //
        // Set the index value as the selected medium for our device.
        //
        *SelectedMediumIndex = index;

        //
        // Allocate adapter context structure and initialize all the 
        // memory resources for sending and receiving packets.
        //
        Status = NICAllocAdapter(&Adapter);
        if(Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        MP_INC_REF(Adapter);  

        //
        // NdisMGetDeviceProperty function enables us to get the:
        // PDO - created by the bus driver to represent our device.
        // FDO - created by NDIS to represent our miniport as a function driver.
        // NextDeviceObject - deviceobject of another driver (filter)
        //                      attached to us at the bottom.
        // In a pure NDIS miniport driver, there is no use for this
        // information, but a NDISWDM driver would need to know this so that it 
        // can transfer packets to the lower WDM stack using IRPs.
        //
        NdisMGetDeviceProperty(MiniportAdapterHandle,
                           &Adapter->Pdo,
                           &Adapter->Fdo,
                           &Adapter->NextDeviceObject,
                           NULL,
                           NULL);

        Adapter->AdapterHandle = MiniportAdapterHandle;

        //
        // Read Advanced configuration information from the registry
        //
        
        Status = NICReadRegParameters(Adapter, WrapperConfigurationContext);
        if(Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Inform NDIS about significant features of the NIC. A 
        // MiniportInitialize function must call NdisMSetAttributesEx 
        // (or NdisMSetAttributes) before calling any other NdisMRegisterXxx 
        // or NdisXxx function that claims hardware resources. If your 
        // hardware supports busmaster DMA, you must specify NDIS_ATTRIBUTE_BUS_MASTER.
        // If this is NDIS51 miniport, it should use safe APIs. But if this 
        // is NDIS 5.0, the driver claim to use safe APIs by setting 
        // NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE) Adapter,
            0,
#ifdef NDIS51_MINIPORT            
            NDIS_ATTRIBUTE_DESERIALIZE, // NDIS does not maintain a send-packet queue
#else 
            NDIS_ATTRIBUTE_DESERIALIZE|
            NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS, 
#endif               
            NIC_INTERFACE_TYPE);

        // 
        // Get the Adapter Resources & Initialize the hardware.
        //
        
        Status = NICInitializeAdapter(Adapter, WrapperConfigurationContext);
        if(Status != NDIS_STATUS_SUCCESS) {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Setup a timer function for Receive Indication
        //
        NdisInitializeTimer(
            &Adapter->RecvTimer, 
            (PNDIS_TIMER_FUNCTION)NICIndicateReceiveTimerDpc, 
            (PVOID)Adapter);
        
        //
        // Setup a timer function for use with our MPReset routine.
        //
        NdisInitializeTimer(
                &Adapter->ResetTimer,
                (PNDIS_TIMER_FUNCTION) NICResetCompleteTimerDpc,
                (PVOID) Adapter);
        
        NdisInitializeEvent(&Adapter->RemoveEvent);
        
        
    } while(FALSE);

    if(Status == NDIS_STATUS_SUCCESS) {
        //
        // Attach this Adapter to the global list of adapters managed by
        // this driver.
        //
        NICAttachAdapter(Adapter);

        //
        // Create an IOCTL interface
        //
        NICRegisterDevice();
    }
    else {
        if(Adapter){
            MP_DEC_REF(Adapter);              
            NICFreeAdapter(Adapter);
        }
    }

    DEBUGP(MP_TRACE, ("<--- MPInitialize Status = 0x%08x%\n", Status));

    return Status;

}



VOID 
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler is called when NDIS receives IRP_MN_STOP_DEVICE,
    IRP_MN_SUPRISE_REMOVE or IRP_MN_REMOVE_DEVICE requests from the 
    PNP manager. Here, the driver should free all the resources acquired
    in MiniportInitialize and stop access to the hardware. NDIS will
    not submit any further request once this handler is invoked.

    1) Free and unmap all I/O resources.
    2) Disable interrupt and deregister interrupt handler.
    3) Deregister shutdown handler regsitered by 
        NdisMRegisterAdapterShutdownHandler .
    4) Cancel all queued up timer callbacks.
    5) Finally wait indefinitely for all the outstanding receive 
        packets indicated to the protocol to return. 

    MiniportHalt runs at IRQL = PASSIVE_LEVEL. 


Arguments:

    MiniportAdapterContext	Pointer to the Adapter

Return Value:

    None.

--*/
{
    PMP_ADAPTER       Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    BOOLEAN           bDone=TRUE;
    BOOLEAN           bCancelled;
    LONG              nHaltCount = 0, Count;
                 
    MP_SET_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS);

    DEBUGP(MP_TRACE, ("---> MPHalt\n"));

    //
    // Call Shutdown handler to disable interrupt and turn the hardware off 
    // by issuing a full reset
    //
#if defined(NDIS50_MINIPORT)
    MPShutdown(MiniportAdapterContext);
#elif defined(NDIS51_MINIPORT)
    //
    // On XP and later, NDIS notifies our PNP event handler the 
    // reason for calling Halt. So before accessing the device, check to see
    // if the device is surprise removed, if so don't bother calling
    // the shutdown handler to stop the hardware because it doesn't exist.
    //
    if(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_SURPRISE_REMOVED)) {       
        MPShutdown(MiniportAdapterContext);
    }        
#endif

    //
    // Free the packets on SendWaitList 
    //
    NICFreeQueuedSendPackets(Adapter);

    //
    // Cancel the ResetTimer.
    //    
    NdisCancelTimer(&Adapter->ResetTimer, &bCancelled);

    //
    // Cancel the ReceiveIndication Timer.
    //    
    NdisCancelTimer(&Adapter->RecvTimer, &bCancelled);
    if(bCancelled) {
        //
        // We are able to cancel a queued Timer. So there is a
        // possibility for the packets to be waiting in the 
        // RecvWaitList. So let us free them by calling..
        //
        NICFreeQueuedRecvPackets(Adapter);
    }            
    
    //
    // Decrement the ref count which was incremented in MPInitialize
    //

    MP_DEC_REF(Adapter);
    
    //
    // Possible non-zero ref counts mean one or more of the following conditions: 
    // 1) Reset DPC is still running.
    // 2) Receive Indication DPC is still running.
    //

    DEBUGP(MP_INFO, ("RefCount=%d --- waiting!\n", MP_GET_REF(Adapter)));

    NdisWaitEvent(&Adapter->RemoveEvent, 0);

    while(TRUE)
    {
        bDone = TRUE;
        
        //
        // Are all the packets indicated up returned?
        //
        if(Adapter->nBusyRecv)
        {
            DEBUGP(MP_INFO, ("nBusyRecv = %d\n", Adapter->nBusyRecv));
            bDone = FALSE;
        }
        
        //
        // Are there any outstanding send packets?                                                         
        //
        if(Adapter->nBusySend)
        {
            DEBUGP(MP_INFO, ("nBusySend = %d\n", Adapter->nBusySend));
            bDone = FALSE;
        }

        if(bDone)
        {
            break;   
        }

        if(++nHaltCount % 100)
        {
            DEBUGP(MP_ERROR, ("Halt timed out!!!\n"));
            DEBUGP(MP_ERROR, ("RecvWaitList = %p\n", &Adapter->RecvWaitList));
            ASSERT(FALSE);       
        }
        
        DEBUGP(MP_INFO, ("MPHalt - waiting ...\n"));
        NdisMSleep(1000);        
    }

    ASSERT(bDone);
    
#ifdef NDIS50_MINIPORT
    //
    // Deregister shutdown handler as it's being halted
    //
    NdisMDeregisterAdapterShutdownHandler(Adapter->AdapterHandle);
#endif  

    //
    // Unregister the ioctl interface.
    //
    NICDeregisterDevice();

    NICDetachAdapter(Adapter);

    NICFreeAdapter(Adapter);
    
    DEBUGP(MP_TRACE, ("<--- MPHalt\n"));
}

NDIS_STATUS 
MPReset(
    OUT PBOOLEAN AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    MiniportReset is a required to issue a hardware reset to the NIC 
    and/or to reset the driver's software state. 

    1) The miniport driver can optionally complete any pending
        OID requests. NDIS will submit no further OID requests 
        to the miniport driver for the NIC being reset until 
        the reset operation has finished. After the reset, 
        NDIS will resubmit to the miniport driver any OID requests
        that were pending but not completed by the miniport driver
        before the reset.
    2) A deserialized miniport driver must complete any pending send 
        operations. NDIS will not requeue pending send packets for 
        a deserialized driver since NDIS does not maintain the send 
        queue for such a driver. 
        
    3) If MiniportReset returns NDIS_STATUS_PENDING, the driver must 
        complete the original request subsequently with a call to 
        NdisMResetComplete.

    MiniportReset runs at IRQL = DISPATCH_LEVEL.

Arguments:

AddressingReset - If multicast or functional addressing information 
                  or the lookahead size, is changed by a reset, 
                  MiniportReset must set the variable at AddressingReset 
                  to TRUE before it returns control. This causes NDIS to
                  call the MiniportSetInformation function to restore 
                  the information. 

MiniportAdapterContext - Pointer to our adapter

Return Value:

    NDIS_STATUS

--*/
{
    NDIS_STATUS       Status;
    PMP_ADAPTER       Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    BOOLEAN           bDone = TRUE;

    DEBUGP(MP_TRACE, ("---> MPReset\n"));

    do
    {
        ASSERT(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS));
        
        if(MP_TEST_FLAG(Adapter, fMP_RESET_IN_PROGRESS))
        {
            Status = NDIS_STATUS_RESET_IN_PROGRESS;
            break;   
        }

        MP_SET_FLAG(Adapter, fMP_RESET_IN_PROGRESS);

        //
        // Complete all the queued up send packets
        //
        NICFreeQueuedSendPackets(Adapter);

        //
        // Check to see if all the packets indicated up are returned.
        //
        if(Adapter->nBusyRecv)
        {
            DEBUGP(MP_INFO, ("nBusyRecv = %d\n", Adapter->nBusyRecv));
            bDone = FALSE;
        }

        //
        // Are there any send packets in the processes of being 
        // transmitted?
        //
        if(Adapter->nBusySend)
        {
            DEBUGP(MP_INFO, ("nBusySend = %d\n", Adapter->nBusySend));
            bDone = FALSE;
        }

        if(!bDone)
        {
            Adapter->nResetTimerCount = 0;
            //
            // We can't complete the reset request now. So let us queue
            // a timer callback for 500ms and check again whether we can 
            // successfully reset the hardware.
            //
            NdisSetTimer(&Adapter->ResetTimer, 500);

            //
            // By returning NDIS_STATUS_PENDING, we are promising NDIS that
            // we will complete the reset request by calling NdisMResetComplete.
            //
            Status = NDIS_STATUS_PENDING;
            break;
        }

        *AddressingReset = FALSE;
        MP_CLEAR_FLAG(Adapter, fMP_RESET_IN_PROGRESS);
        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);
    
    DEBUGP(MP_TRACE, ("<--- MPReset Status = 0x%08x\n", Status));
    
    return(Status);
}


VOID 
NICResetCompleteTimerDpc(
    IN PVOID             SystemSpecific1,
    IN PVOID             FunctionContext,
    IN PVOID             SystemSpecific2,
    IN PVOID             SystemSpecific3)
/*++

Routine Description:

    Timer callback function for Reset operation. 
        
Arguments:

FunctionContext - Pointer to our adapter

Return Value:

    VOID

--*/
{
    PMP_ADAPTER Adapter = (PMP_ADAPTER)FunctionContext;
    BOOLEAN bDone = TRUE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGP(MP_TRACE, ("--> NICResetCompleteTimerDpc\n"));

    //
    // Increment the ref count on the adapter to prevent the driver from
    // unloding while the DPC is running. The Halt handler waits for the
    // ref count to drop to zero before returning. 
    //
    MP_INC_REF(Adapter);            

    //
    // Check to see if all the packets indicated up are returned.
    //
    if(Adapter->nBusyRecv)
    {
        DEBUGP(MP_INFO, ("nBusyRecv = %d\n", Adapter->nBusyRecv));
        bDone = FALSE;
    }

    //
    // Are there any send packets in the processes of being 
    // transmitted?
    //
    if(Adapter->nBusySend)
    {
        DEBUGP(MP_INFO, ("nBusySend = %d\n", Adapter->nBusySend));
        bDone = FALSE;
    }

    if(!bDone && ++Adapter->nResetTimerCount <= 20)
    {
        //
        // Let us try one more time.
        //
        NdisSetTimer(&Adapter->ResetTimer, 500);
    }
    else
    {
        if(!bDone)
        {
        
            //
            // We have tried enough. Something is wrong. Let us
            // just complete the reset request with failure.
            //
            DEBUGP(MP_ERROR, ("Reset timed out!!!\n"));
            DEBUGP(MP_ERROR, ("nBusySend = %d\n", Adapter->nBusySend));
            DEBUGP(MP_ERROR, ("RecvWaitList = %p\n", &Adapter->RecvWaitList));
            DEBUGP(MP_ERROR, ("nBusyRecv = %d\n", Adapter->nBusyRecv));
            
            ASSERT(FALSE);       

            Status = NDIS_STATUS_FAILURE;
        }

        DEBUGP(MP_INFO, ("Done - NdisMResetComplete\n"));

        MP_CLEAR_FLAG(Adapter, fMP_RESET_IN_PROGRESS);
        NdisMResetComplete(
            Adapter->AdapterHandle,
            Status,
            FALSE);
        
    }

    MP_DEC_REF(Adapter);     

    DEBUGP(MP_TRACE, ("<-- NICResetCompleteTimerDpc Status = 0x%08x\n", Status));
}



VOID 
MPUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:
    
    The unload handler is called during driver unload to free up resources
    acquired in DriverEntry. This handler is registered through 
    NdisMRegisterUnloadHandler. Note that an unload handler differs from 
    a MiniportHalt function in that the unload handler has a more global
    scope, whereas the scope of the MiniportHalt function is restricted 
    to a particular miniport driver instance.

    Runs at IRQL = PASSIVE_LEVEL. 
    
Arguments:

    DriverObject        Not used

Return Value:

    None
    
--*/
{
    DEBUGP(MP_TRACE, ("--> MPUnload\n"));

    ASSERT(IsListEmpty(&GlobalData.AdapterList));
    NdisFreeSpinLock(&GlobalData.Lock);
    
    DEBUGP(MP_TRACE, ("<--- MPUnload\n"));   
}

VOID 
MPShutdown(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:
    
    The MiniportShutdown handler restores a NIC to its initial state when
    the system is shut down, whether by the user or because an unrecoverable
    system error occurred. This is to ensure that the NIC is in a known 
    state and ready to be reinitialized when the machine is rebooted after
    a system shutdown occurs for any reason, including a crash dump.

    Here just disable the interrupt and stop the DMA engine.
    Do not free memory resources or wait for any packet transfers
    to complete.


    Runs at an arbitrary IRQL <= DIRQL. So do not call any passive-level
    function.
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    
    DEBUGP(MP_TRACE, ("---> MPShutdown\n"));
    
    DEBUGP(MP_TRACE, ("<--- MPShutdown\n"));

}

BOOLEAN 
MPCheckForHang(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:
    
    The MiniportCheckForHang handler is called to report the state of the
    NIC, or to monitor the responsiveness of an underlying device driver. 
    This is an optional function. If this handler is not specified, NDIS
    judges the driver unresponsive when the driver holds 
    MiniportQueryInformation or MiniportSetInformation requests for a 
    time-out interval (deafult 4 sec), and then calls the driver's 
    MiniportReset function. A NIC driver's MiniportInitialize function can
    extend NDIS's time-out interval by calling NdisMSetAttributesEx to 
    avoid unnecessary resets. 

    Always runs at IRQL = DISPATCH_LEVEL.
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    TRUE    NDIS calls the driver's MiniportReset function.
    FALSE   Everything is fine

Note: 
    CheckForHang handler is called in the context of a timer DPC. 
    take advantage of this fact when acquiring/releasing spinlocks

--*/
{
    DEBUGP(MP_LOUD, ("---> MPCheckForHang\n"));
    DEBUGP(MP_LOUD, ("<--- MPCheckForHang\n"));
    return(FALSE);
}


VOID 
MPHandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportHandleInterrupt is a DPC function called to do deferred 
    processing of all outstanding interrupt operations. When a NIC 
    generates an interrupt, a miniport's MiniportISR or 
    MiniportDisableInterrupt function dismisses the interrupt on the 
    NIC, saves any necessary state about the operation, and returns 
    control as quickly as possible, thereby deferring most 
    interrupt-driven I/O operations to MiniportHandleInterrupt. This
    handler is called only if the MiniportISR function returned 
    QueueMiniportHandleInterrupt set to TRUE.

    MiniportHandleInterrupt then re-enables interrupts on the NIC, 
    either by letting NDIS call the miniport driver's 
    MiniportEnableInterrupt function after MiniportHandleInterrupt 
    returns control or by enabling the interrupt from within
    MiniportHandleInterrupt, which is faster. 

    Note that more than one instance of this function can execute 
    concurrently in SMP machines.
    
    Runs at IRQL = DISPATCH_LEVEL    
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    DEBUGP(MP_TRACE, ("---> MPHandleInterrupt\n"));
    DEBUGP(MP_TRACE, ("<--- MPHandleInterrupt\n"));
}

VOID 
MPIsr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueMiniportHandleInterrupt,
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportIsr handler is called to when the device asserts an interrupt.
    MiniportISR dismisses the interrupt on the NIC, saves whatever state
    it must about the interrupt, and defers as much of the I/O processing
    for each interrupt as possible to the MiniportHandleInterrupt function. 
    
    MiniportISR is not re-entrant, although two instantiations of this 
    function can execute concurrently in SMP machines, particularly if 
    the miniport driver supports full-duplex sends and receives. A driver
    writer should not rely on a one-to-one correspondence between the 
    execution of MiniportISR and MiniportHandleInterrupt. 

    If the NIC shares an IRQ with other devices (check NdisMRegisterInterrupt), 
    this function should determine whether the NIC generated the interrupt. 
    If the NIC did not generated the interrupt, MiniportISR should return FALSE 
    immediately so that the driver of the device that generated the interrupt
    is called quickly. 

    Runs at IRQL = DIRQL assigned when the NIC driver's MiniportInitialize
    function called NdisMRegisterInterrupt.   

Arguments:

    InterruptRecognized             TRUE on return if the interrupt comes 
                                    from this NIC    
    QueueMiniportHandleInterrupt    TRUE on return if MiniportHandleInterrupt 
                                    should be called
    MiniportAdapterContext          Pointer to our adapter

Return Value:

    None
    
--*/
{

    DEBUGP(MP_TRACE, ("---> MPIsr\n"));
    DEBUGP(MP_TRACE, ("<--- MPIsr\n"));
}

VOID 
MPDisableInterrupt(
    IN PVOID MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportDisableInterrupt typically disables interrupts by writing 
    a mask to the NIC. If a driver does not have this function, typically
    its MiniportISR disables interrupts on the NIC.

    This handler is required by drivers of NICs that support dynamic 
    enabling and disabling of interrupts but do not share an IRQ.

    Runs at IRQL = DIRQL    
    
Arguments:

    MiniportAdapterContext          Pointer to our adapter

Return Value:

    None
    
--*/
{
    DEBUGP(MP_TRACE, ("---> MPDisableInterrupt\n"));
    DEBUGP(MP_TRACE, ("<--- MPDisableInterrupt\n"));

}

VOID 
MPEnableInterrupt(
    IN PVOID MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportEnableInterrupt typically enables interrupts by writing a mask
    to the NIC. A NIC driver that exports a MiniportDisableInterrupt function
    need not have a reciprocal MiniportEnableInterrupt function. 
    Such a driver's MiniportHandleInterrupt function is responsible for 
    re-enabling interrupts on the NIC. 

    Runs at IRQL = DIRQL    
    
Arguments:

    MiniportAdapterContext          Pointer to our adapter

Return Value:

    None
    
--*/
{
    DEBUGP(MP_TRACE, ("---> MPEnableInterrupt\n"));
    DEBUGP(MP_TRACE, ("<--- MPEnableInterrupt\n"));

}

VOID 
MPAllocateComplete(
    NDIS_HANDLE MiniportAdapterContext,
    IN PVOID VirtualAddress,
    IN PNDIS_PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN PVOID Context
    )
/*++

Routine Description:
    
    This handler is needed if the driver makes calls to 
    NdisMAllocateSharedMemoryAsync. Drivers of bus-master DMA NICs call 
    NdisMAllocateSharedMemoryAsync to dynamically allocate shared memory
    for transfer operations when high network traffic places excessive 
    demands on the shared memory space that the driver allocated during 
    initialization. 

    Runs at IRQL = DISPATCH_LEVEL.
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    VirtualAddress          Pointer to the allocated memory block 
    PhysicalAddress         Physical address of the memory block       
    Length                  Length of the memory block                
    Context                 Context in NdisMAllocateSharedMemoryAsync              

Return Value:

    None
    
--*/
{
    DEBUGP(MP_TRACE, ("---> MPAllocateComplete\n"));
}

#ifdef NDIS51_MINIPORT
VOID 
MPCancelSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PVOID           CancelId
    )
/*++

Routine Description:
    
    MiniportCancelSendPackets cancels the transmission of all packets that
    are marked with a specified cancellation identifier. Miniport drivers
    that queue send packets for more than one second should export this
    handler. When a protocol driver or intermediate driver calls the
    NdisCancelSendPackets function, NDIS calls the MiniportCancelSendPackets 
    function of the appropriate lower-level driver (miniport driver or 
    intermediate driver) on the binding.

    Runs at IRQL <= DISPATCH_LEVEL.
  
    Available - NDIS5.1 (WinXP) and later.
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    CancelId                    All the packets with this Id should be cancelled

Return Value:

    None
    
--*/
{
    PNDIS_PACKET    Packet;
    PVOID           PacketId;
    PLIST_ENTRY     thisEntry, nextEntry, listHead;
    SINGLE_LIST_ENTRY SendCancelList;
    PSINGLE_LIST_ENTRY entry;
    
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

#define MP_GET_PACKET_MR(_p)    (PSINGLE_LIST_ENTRY)(&(_p)->MiniportReserved[0]) 

    DEBUGP(MP_TRACE, ("---> MPCancelSendPackets\n"));

    SendCancelList.Next = NULL;
    
    NdisAcquireSpinLock(&Adapter->SendLock);

    //
    // Walk through the send wait queue and complete the sends with matching Id
    //
    listHead = &Adapter->SendWaitList;
    
    for(thisEntry = listHead->Flink,nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry,nextEntry = thisEntry->Flink) {
        Packet = CONTAINING_RECORD(thisEntry, NDIS_PACKET, MiniportReserved);

        PacketId = NdisGetPacketCancelId(Packet);
        if (PacketId == CancelId)
        {       
            //
            // This packet has the right CancelId
            //
            RemoveEntryList(thisEntry);
            //
            // Put this packet on SendCancelList
            //
            PushEntryList(&SendCancelList, MP_GET_PACKET_MR(Packet));
        }
    }
       
    NdisReleaseSpinLock(&Adapter->SendLock);

    //
    // Get the packets from SendCancelList and complete them if any
    //

    entry = PopEntryList(&SendCancelList);
    
    while (entry)
    {
        Packet = CONTAINING_RECORD(entry, NDIS_PACKET, MiniportReserved);

        NdisMSendComplete(
            Adapter->AdapterHandle,
            Packet,
            NDIS_STATUS_REQUEST_ABORTED);
        
        entry = PopEntryList(&SendCancelList);        
    }

    DEBUGP(MP_TRACE, ("<--- MPCancelSendPackets\n"));

}

VOID MPPnPEventNotify(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    )
/*++

Routine Description:
    
    MiniportPnPEventNotify is to handle PnP notification messages.
    All NDIS 5.1 miniport drivers must export a MiniportPnPEventNotify
    function. Miniport drivers that have a WDM lower edge should export
    a MiniportPnPEventNotify function.

    Runs at IRQL = PASSIVE_LEVEL in the context of system thread.

    Available - NDIS5.1 (WinXP) and later.
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    PnPEvent                    Self-explanatory 
    InformationBuffer           Self-explanatory 
    InformationBufferLength     Self-explanatory 

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    PNDIS_POWER_PROFILE NdisPowerProfile;
    
    //
    // Turn off the warings.
    //
    UNREFERENCED_PARAMETER(Adapter);

    DEBUGP(MP_TRACE, ("---> MPPnPEventNotify\n"));

    switch (PnPEvent)
    {
        case NdisDevicePnPEventQueryRemoved:
            //
            // Called when NDIS receives IRP_MN_QUERY_REMOVE_DEVICE.
            //
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventQueryRemoved\n"));
            break;

        case NdisDevicePnPEventRemoved:
            //
            // Called when NDIS receives IRP_MN_REMOVE_DEVICE.
            // NDIS calls MiniportHalt function after this call returns.
            //
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventRemoved\n"));
            break;       

        case NdisDevicePnPEventSurpriseRemoved:
            //
            // Called when NDIS receives IRP_MN_SUPRISE_REMOVAL. 
            // NDIS calls MiniportHalt function after this call returns.
            //
            MP_SET_FLAG(Adapter, fMP_ADAPTER_SURPRISE_REMOVED);
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventSurpriseRemoved\n"));
            break;

        case NdisDevicePnPEventQueryStopped:
            //
            // Called when NDIS receives IRP_MN_QUERY_STOP_DEVICE. ??
            //
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventQueryStopped\n"));
            break;

        case NdisDevicePnPEventStopped:
            //
            // Called when NDIS receives IRP_MN_STOP_DEVICE.
            // NDIS calls MiniportHalt function after this call returns.
            // 
            //
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventStopped\n"));
            break;      
            
        case NdisDevicePnPEventPowerProfileChanged:
            //
            // After initializing a miniport driver and after miniport driver
            // receives an OID_PNP_SET_POWER notification that specifies 
            // a device power state of NdisDeviceStateD0 (the powered-on state), 
            // NDIS calls the miniport's MiniportPnPEventNotify function with 
            // PnPEvent set to NdisDevicePnPEventPowerProfileChanged. 
            //            
            DEBUGP(MP_INFO, ("MPPnPEventNotify: NdisDevicePnPEventPowerProfileChanged\n"));
            
            if(InformationBufferLength == sizeof(NDIS_POWER_PROFILE)) {
                NdisPowerProfile = (PNDIS_POWER_PROFILE)InformationBuffer;
                if(*NdisPowerProfile == NdisPowerProfileBattery) {
                    DEBUGP(MP_INFO, 
                        ("The host system is running on battery power\n"));
                }
                if(*NdisPowerProfile == NdisPowerProfileAcOnLine) {
                    DEBUGP(MP_INFO, 
                        ("The host system is running on AC power\n"));
               }
            }
            break;      
            
        default:
            DEBUGP(MP_ERROR, ("MPPnPEventNotify: unknown PnP event %x \n", PnPEvent));
            break;         
    }

    DEBUGP(MP_TRACE, ("<--- MPPnPEventNotify\n"));

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\ioctl.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

   IOCTL.C

Abstract:

    This modules contains functions to register/deregsiter a control-
    deviceobject for ioctl purposes and dispatch routine for handling
    ioctl requests from usermode.

Revision History:

Notes:

--*/

#if defined(IOCTL_INTERFACE)


#include "miniport.h"
#include "public.h"

//
// Simple Mutual Exclusion constructs used in preference to
// using KeXXX calls since we don't have Mutex calls in NDIS.
// These can only be called at passive IRQL.
//

typedef struct _NIC_MUTEX
{
    ULONG                   Counter;
    ULONG                   ModuleAndLine;  // useful for debugging

} NIC_MUTEX, *PNIC_MUTEX;

#define NIC_INIT_MUTEX(_pMutex)                                 \
{                                                               \
    (_pMutex)->Counter = 0;                                     \
    (_pMutex)->ModuleAndLine = 0;                               \
}

#define NIC_ACQUIRE_MUTEX(_pMutex)                              \
{                                                               \
    while (NdisInterlockedIncrement((PLONG)&((_pMutex)->Counter)) != 1)\
    {                                                           \
        NdisInterlockedDecrement((PLONG)&((_pMutex)->Counter));        \
        NdisMSleep(10000);                                      \
    }                                                           \
    (_pMutex)->ModuleAndLine = ('I' << 16) | __LINE__;\
}

#define NIC_RELEASE_MUTEX(_pMutex)                              \
{                                                               \
    (_pMutex)->ModuleAndLine = 0;                               \
    NdisInterlockedDecrement((PLONG)&(_pMutex)->Counter);              \
}

#define LINKNAME_STRING     L"\\DosDevices\\NETVMINI"
#define NTDEVICE_STRING     L"\\Device\\NETVMINI"

//
// Global variables
//

NDIS_HANDLE        NdisDeviceHandle = NULL; // From NdisMRegisterDevice
LONG               MiniportCount = 0; // Total number of miniports in existance
PDEVICE_OBJECT     ControlDeviceObject = NULL;  // Device for IOCTLs
NIC_MUTEX          ControlDeviceMutex;
extern NDIS_HANDLE NdisWrapperHandle;

#pragma NDIS_PAGEABLE_FUNCTION(NICRegisterDevice)
#pragma NDIS_PAGEABLE_FUNCTION(NICDeregisterDevice)
#pragma NDIS_PAGEABLE_FUNCTION(NICDispatch)


NDIS_STATUS
NICRegisterDevice(
    VOID
    )
/*++

Routine Description:

    Register an ioctl interface - a device object to be used for this
    purpose is created by NDIS when we call NdisMRegisterDevice.

    This routine is called whenever a new miniport instance is
    initialized. However, we only create one global device object,
    when the first miniport instance is initialized. This routine
    handles potential race conditions with NICDeregisterDevice via
    the ControlDeviceMutex.

    NOTE: do not call this from DriverEntry; it will prevent the driver
    from being unloaded (e.g. on uninstall).

Arguments:

    None

Return Value:

    NDIS_STATUS_SUCCESS if we successfully register a device object.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      DeviceLinkUnicodeString;
    PDRIVER_DISPATCH    DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];

    DEBUGP(MP_TRACE, ("==>NICRegisterDevice\n"));

    NIC_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ++MiniportCount;
    
    if (1 == MiniportCount)
    {
        NdisZeroMemory(DispatchTable, (IRP_MJ_MAXIMUM_FUNCTION+1) * sizeof(PDRIVER_DISPATCH));
        
        DispatchTable[IRP_MJ_CREATE] = NICDispatch;
        DispatchTable[IRP_MJ_CLEANUP] = NICDispatch;
        DispatchTable[IRP_MJ_CLOSE] = NICDispatch;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = NICDispatch;
        

        NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);

        //
        // Create a device object and register our dispatch handlers
        //
        Status = NdisMRegisterDevice(
                    NdisWrapperHandle, 
                    &DeviceName,
                    &DeviceLinkUnicodeString,
                    &DispatchTable[0],
                    &ControlDeviceObject,
                    &NdisDeviceHandle
                    );
    }

    NIC_RELEASE_MUTEX(&ControlDeviceMutex);

    DEBUGP(MP_TRACE, ("<==NICRegisterDevice: %x\n", Status));

    return (Status);
}


NTSTATUS
NICDispatch(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp
    )
/*++
Routine Description:

    Process IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    NTSTATUS - STATUS_SUCCESS always - change this when adding
    real code to handle ioctls.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               inlen;
    PVOID               buffer;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEBUGP(MP_TRACE, ("==>NICDispatch %d\n", irpStack->MajorFunction));
      
    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            break;
        
        case IRP_MJ_CLEANUP:
            break;
        
        case IRP_MJ_CLOSE:
            break;        
        
        case IRP_MJ_DEVICE_CONTROL: 
        {

          buffer = Irp->AssociatedIrp.SystemBuffer;  
          inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
          
          switch (irpStack->Parameters.DeviceIoControl.IoControlCode) 
          {

            //
            // Add code here to handle ioctl commands.
            //
            case IOCTL_NETVMINI_READ_DATA:
                DEBUGP(MP_TRACE, ("Received Read IOCTL\n"));
                break;
            case IOCTL_NETVMINI_WRITE_DATA:
                DEBUGP(MP_TRACE, ("Received Write IOCTL\n"));
                break;
            default:
                status = STATUS_UNSUCCESSFUL;
                break;
          }
          break;  
        }
        default:
            break;
    }
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DEBUGP(MP_TRACE, ("<== NIC Dispatch\n"));

    return status;

} 


NDIS_STATUS
NICDeregisterDevice(
    VOID
    )
/*++

Routine Description:

    Deregister the ioctl interface. This is called whenever a miniport
    instance is halted. When the last miniport instance is halted, we
    request NDIS to delete the device object

Arguments:

    NdisDeviceHandle - Handle returned by NdisMRegisterDevice

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGP(MP_TRACE, ("==>NICDeregisterDevice\n"));

    NIC_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ASSERT(MiniportCount > 0);

    --MiniportCount;
    
    if (0 == MiniportCount)
    {
        //
        // All miniport instances have been halted.
        // Deregister the control device.
        //

        if (NdisDeviceHandle != NULL)
        {
            Status = NdisMDeregisterDevice(NdisDeviceHandle);
            NdisDeviceHandle = NULL;
        }
    }

    NIC_RELEASE_MUTEX(&ControlDeviceMutex);

    DEBUGP(MP_TRACE, ("<== NICDeregisterDevice: %x\n", Status));
    return Status;
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\cdata.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    cdata.c

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

    10-July-1995    KyleB    Added spinlock logging debug code.

--*/

#include <precomp.h>
#pragma hdrstop

#include <initguid.h>
#include <ndisguid.h>
//
// Memphis uses a private wdmguid.h becuase the power guids are not defined
// in wdmguid.h in the build, so use "" instead of <>
//
#include "wdmguid.h"

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DATA

OID_SETINFO_HANDLER ndisMSetInfoHandlers[] =
{
    { OID_GEN_CURRENT_PACKET_FILTER,    ndisMSetPacketFilter } ,
    { OID_GEN_CURRENT_LOOKAHEAD,        ndisMSetCurrentLookahead } ,
    { OID_GEN_PROTOCOL_OPTIONS,         ndisMSetProtocolOptions } ,
    { OID_802_3_MULTICAST_LIST,         ndisMSetMulticastList } ,
    { OID_802_5_CURRENT_FUNCTIONAL,     ndisMSetFunctionalAddress } ,
    { OID_802_5_CURRENT_GROUP,          ndisMSetGroupAddress } ,
    { OID_FDDI_LONG_MULTICAST_LIST,     ndisMSetFddiMulticastList } ,
    { OID_PNP_ADD_WAKE_UP_PATTERN,      ndisMSetAddWakeUpPattern } ,
    { OID_PNP_REMOVE_WAKE_UP_PATTERN,   ndisMSetRemoveWakeUpPattern } ,
    { OID_PNP_ENABLE_WAKE_UP,           ndisMSetEnableWakeUp },
    { 0,                                NULL }
};


BOOLEAN ndisMediaTypeCl[NdisMediumMax] =
{
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    FALSE,
    FALSE
};

NDIS_MEDIUM ndisMediumBuffer[NdisMediumMax + EXPERIMENTAL_SIZE] =   // Keep some space for experimental media
{
    NdisMedium802_3,
    NdisMedium802_5,
    NdisMediumFddi,
    NdisMediumWan,
    NdisMediumLocalTalk,
    NdisMediumDix,
    NdisMediumArcnetRaw,
    NdisMediumArcnet878_2,
    NdisMediumAtm,
    NdisMediumWirelessWan,
    NdisMediumIrda,
    NdisMediumBpc,
    NdisMediumCoWan,
    NdisMedium1394,
    NdisMediumInfiniBand
};

NDIS_MEDIUM *           ndisMediumArray = ndisMediumBuffer;
UINT                    ndisMediumArraySize = NdisMediumMax * sizeof(NDIS_MEDIUM);
UINT                    ndisMediumArrayMaxSize = sizeof(ndisMediumBuffer);
WCHAR                   ndisHexLookUp[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
ULONG                   ndisInstanceNumber = 0;
UINT                    ndisPacketStackSize = NUM_PACKET_STACKS;


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
//  Array of the GUIDs that represent the General OIDs
//
NDIS_GUID               ndisSupportedGuids[36] =
{
    //
    //  GUIDs that do get passed to the miniport.
    //
    {{0x981f2d7f, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ENUMERATE_ADAPTER
     0,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_ALLOW_READ
    },
    {{0x981f2d80, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_ADAPTER_REMOVAL
     0,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS
    },
    {{0x981f2d81, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL
     0,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS
    },
    {{0x827c0a6fL, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a}, //  GUID_POWER_DEVICE_ENABLE
     0,
    (ULONG)-1,
    fNDIS_GUID_NDIS_ONLY
    },
    {{0xa9546a82L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a}, //  GUID_POWER_DEVICE_WAKE_ENABLE
     0,
    (ULONG)-1,
    fNDIS_GUID_NDIS_ONLY
    },
    {{0x981f2d82, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ENUMERATE_VC
     0,
     0, //  No data for this GUID
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_ALLOW_READ
    },
    {{0x981f2d79, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_VC_REMOVAL
     0,
     0, //  No data for this GUID 
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS | fNDIS_GUID_CO_NDIS
    },
    {{0x182f9e0c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_VC_ARRIVAL
     0,
     0, //  No data for this GUID 
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS | fNDIS_GUID_CO_NDIS
    },
    {{0xa14f1c97, 0x8839, 0x4f8a, 0x99, 0x96, 0xa2, 0x89, 0x96, 0xeb, 0xbf, 0x1d},  //  GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY
     0,
    (ULONG)-1,
    fNDIS_GUID_NDIS_ONLY
    },
    

    //
    //  General oids.
    //
    {{0x5ec10354, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_HARDWARE_STATUS
     OID_GEN_HARDWARE_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10355, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_SUPPORTED
     OID_GEN_MEDIA_SUPPORTED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10356, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_IN_USE
     OID_GEN_MEDIA_IN_USE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10357, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD
     OID_GEN_MAXIMUM_LOOKAHEAD,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10358, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE
     OID_GEN_MAXIMUM_FRAME_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10359, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_LINK_SPEED
     OID_GEN_LINK_SPEED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035a, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE
     OID_GEN_TRANSMIT_BUFFER_SPACE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035b, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE
     OID_GEN_RECEIVE_BUFFER_SPACE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035c, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE
     OID_GEN_TRANSMIT_BLOCK_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035d, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE
     OID_GEN_RECEIVE_BLOCK_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035e, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_ID
     OID_GEN_VENDOR_ID,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035f, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_DESCRIPTION
     OID_GEN_VENDOR_DESCRIPTION,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ANSI_STRING | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10360, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_CURRENT_PACKET_FILTER
     OID_GEN_CURRENT_PACKET_FILTER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10361, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_CURRENT_LOOKAHEAD
     OID_GEN_CURRENT_LOOKAHEAD,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10362, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_DRIVER_VERSION
     OID_GEN_DRIVER_VERSION,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10363, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE
     OID_GEN_MAXIMUM_TOTAL_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10365, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAC_OPTIONS
     OID_GEN_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10366, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_CONNECT_STATUS
     OID_GEN_MEDIA_CONNECT_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10367, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS
     OID_GEN_MAXIMUM_SEND_PACKETS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956f9, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_DRIVER_VERSION
     OID_GEN_VENDOR_DRIVER_VERSION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x765dc702, 0xc5e8, 0x4b67, 0x84, 0x3b, 0x3f, 0x5a, 0x4f, 0xf2, 0x64, 0x8b},   //  GUID_NDIS_GEN_VLAN_ID
     OID_GEN_VLAN_ID,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x418ca16d, 0x3937, 0x4208, 0x94, 0x0a, 0xec, 0x61, 0x96, 0x27, 0x80, 0x85},   //  GUID_NDIS_GEN_PHYSICAL_MEDIUM
     OID_GEN_PHYSICAL_MEDIUM,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },    

    //
    //  General required statistics.
    //
    {{0x447956fa, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_XMIT_OK
     OID_GEN_XMIT_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fb, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_OK
     OID_GEN_RCV_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fc, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_XMIT_ERROR
     OID_GEN_XMIT_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fd, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_ERROR
     OID_GEN_RCV_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fe, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_NO_BUFFER
     OID_GEN_RCV_NO_BUFFER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisCoSupportedGuids[16] =
{
    //
    //  CoNDIS general required oids
    //
    {{0x791ad192, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_HARDWARE_STATUS
     OID_GEN_CO_HARDWARE_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad193, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_SUPPORTED
     OID_GEN_CO_MEDIA_SUPPORTED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad194, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_IN_USE
     OID_GEN_CO_MEDIA_IN_USE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad195, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_LINK_SPEED
     OID_GEN_CO_LINK_SPEED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad196, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_ID
     OID_GEN_CO_VENDOR_ID,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad197, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION
     OID_GEN_CO_VENDOR_DESCRIPTION,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ANSI_STRING | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad198, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_DRIVER_VERSION
     OID_GEN_CO_DRIVER_VERSION,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19a, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MAC_OPTIONS
     OID_GEN_CO_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19b, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS
     OID_GEN_CO_MEDIA_CONNECT_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19c, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION
     OID_GEN_CO_VENDOR_DRIVER_VERSION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19d, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED
     OID_GEN_CO_MINIMUM_LINK_SPEED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },

    //
    //  CoNDIS general required statistics.
    //
    {{0x0a214805, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  NDIS_GUID_GEN_CO_XMIT_PDUS_OK
     OID_GEN_CO_XMIT_PDUS_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214806, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_OK
     OID_GEN_CO_RCV_PDUS_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214807, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR
     OID_GEN_CO_XMIT_PDUS_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214808, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_ERROR
     OID_GEN_CO_RCV_PDUS_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214809, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER
     OID_GEN_CO_RCV_PDUS_NO_BUFFER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisMediaSupportedGuids[75] =
{
    //
    //  802.3 required oids.
    //
    {{0x447956ff, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_802_3_PERMANENT_ADDRESS
     OID_802_3_PERMANENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795700, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_CURRENT_ADDRESS
     OID_802_3_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795701, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MULTICAST_LIST
     OID_802_3_MULTICAST_LIST,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795702, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MAXIMUM_LIST_SIZE
     OID_802_3_MAXIMUM_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795703, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MAC_OPTIONS
     OID_802_3_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.3 required statistics oids.
    //
    {{0x44795704, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT
     OID_802_3_RCV_ERROR_ALIGNMENT,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795705, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_XMIT_ONE_COLLISION
     OID_802_3_XMIT_ONE_COLLISION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795706, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_XMIT_MORE_COLLISIONS
     OID_802_3_XMIT_MORE_COLLISIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.5 required oids.
    //
    {{0x44795707, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_802_5_PERMANENT_ADDRESS
     OID_802_5_PERMANENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795708, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_ADDRESS
     OID_802_5_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795709, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_FUNCTIONAL
     OID_802_5_CURRENT_FUNCTIONAL,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x4479570a, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_GROUP
     OID_802_5_CURRENT_GROUP,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x4479570b, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LAST_OPEN_STATUS
     OID_802_5_LAST_OPEN_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x890a36ec, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_RING_STATUS
     OID_802_5_CURRENT_RING_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14032, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_RING_STATE
     OID_802_5_CURRENT_RING_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.5 required statistics oids.
    //
    {{0xacf14033, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LINE_ERRORS
     OID_802_5_LINE_ERRORS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14034, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LOST_FRAMES
     OID_802_5_LOST_FRAMES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  FDDI required oids.
    //
    {{0xacf14035, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_FDDI_LONG_PERMANENT_ADDR
     OID_FDDI_LONG_PERMANENT_ADDR,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14036, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_CURRENT_ADDR
     OID_FDDI_LONG_CURRENT_ADDR,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14037, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_MULTICAST_LIST
     OID_FDDI_LONG_MULTICAST_LIST,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14038, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_MAX_LIST_SIZE
     OID_FDDI_LONG_MAX_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14039, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_PERMANENT_ADDR
     OID_FDDI_SHORT_PERMANENT_ADDR,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403a, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_CURRENT_ADDR
     OID_FDDI_SHORT_CURRENT_ADDR,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403b, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_MULTICAST_LIST
     OID_FDDI_SHORT_MULTICAST_LIST,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403c, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_MAX_LIST_SIZE
     OID_FDDI_SHORT_MAX_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  FDDI required statistics oids.
    //
    {{0xacf1403d, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_ATTACHMENT_TYPE
     OID_FDDI_ATTACHMENT_TYPE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403e, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_UPSTREAM_NODE_LONG
     OID_FDDI_UPSTREAM_NODE_LONG,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403f, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_DOWNSTREAM_NODE_LONG
     OID_FDDI_DOWNSTREAM_NODE_LONG,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14040, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_FRAME_ERRORS
     OID_FDDI_FRAME_ERRORS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14041, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_FRAMES_LOST
     OID_FDDI_FRAMES_LOST,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14042, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_RING_MGT_STATE
     OID_FDDI_RING_MGT_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14043, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LCT_FAILURES
     OID_FDDI_LCT_FAILURES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14044, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LEM_REJECTS
     OID_FDDI_LEM_REJECTS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14045, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LCONNECTION_STATE
     OID_FDDI_LCONNECTION_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  Wireless (802.11) OIDs.
    //
    {{0x2504b6c2, 0x1fa5, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_BSSID
     OID_802_11_BSSID,
     sizeof(NDIS_802_11_MAC_ADDRESS),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x7d2a90ea, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_SSID
     OID_802_11_SSID,
     sizeof(NDIS_802_11_SSID),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x8531d6e6, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NETWORK_TYPES_SUPPORTED
     OID_802_11_NETWORK_TYPES_SUPPORTED,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x857e2326, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NETWORK_TYPE_IN_USE
     OID_802_11_NETWORK_TYPE_IN_USE,
     sizeof(NDIS_802_11_NETWORK_TYPE),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x85be837c, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_POWER_MODE
     OID_802_11_POWER_MODE,
     sizeof(NDIS_802_11_POWER_MODE),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x11e6ba76, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_TX_POWER_LEVEL
     OID_802_11_TX_POWER_LEVEL,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x1507db16, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RSSI
     OID_802_11_RSSI,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x155689b8, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RSSI_TRIGGER
     OID_802_11_RSSI_TRIGGER,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x69526f9a, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_BSSID_LIST
     OID_802_11_BSSID_LIST,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x697d5a7e, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_INFRASTRUCTURE_MODE
     OID_802_11_INFRASTRUCTURE_MODE,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x69aaa7c4, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_FRAGMENTATION_THRESHOLD
     OID_802_11_FRAGMENTATION_THRESHOLD,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x0134d07e, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RTS_THRESHOLD
     OID_802_11_RTS_THRESHOLD,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01779336, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NUMBER_OF_ANTENNAS
     OID_802_11_NUMBER_OF_ANTENNAS,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01ac07a2, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RX_ANTENNA_SELECTED
     OID_802_11_RX_ANTENNA_SELECTED,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01dbb74a, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_TX_ANTENNA_SELECTED
     OID_802_11_TX_ANTENNA_SELECTED,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x49db8722, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_SUPPORTED_RATES
     OID_802_11_SUPPORTED_RATES,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x452ee08e, 0x2536, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_DESIRED_RATES
     OID_802_11_DESIRED_RATES,
     (ULONG)-1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x4a4df982, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_CONFIGURATION
     OID_802_11_CONFIGURATION,
     sizeof(NDIS_802_11_CONFIGURATION),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x42bb73b0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_STATISTICS
     OID_802_11_STATISTICS,
     sizeof(NDIS_802_11_STATISTICS),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x4307bff0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_ADD_WEP
     OID_802_11_ADD_WEP,
     sizeof(NDIS_802_11_WEP),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x433c345c, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_REMOVE_WEP
     OID_802_11_REMOVE_WEP,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x43671f40, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_DISASSOCIATE
     OID_802_11_DISASSOCIATE,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x0d9e01e1, 0xba70, 0x11d4, 0xb6, 0x75, 0x00, 0x20, 0x48, 0x57, 0x03, 0x37},  // GUID_NDIS_802_11_BSSID_LIST_SCAN
     OID_802_11_BSSID_LIST_SCAN,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x43920a24, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_AUTHENTICATION_MODE
     OID_802_11_AUTHENTICATION_MODE,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x6733c4e9, 0x4792, 0x11d4, 0x97, 0xf1, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_PRIVACY_FILTER
     OID_802_11_PRIVACY_FILTER,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0xb027a21f, 0x3cfa, 0x4125, 0x80, 0x0b, 0x3f, 0x7a, 0x18, 0xfd, 0xdc, 0xdc},  // GUID_NDIS_802_11_WEP_STATUS
     OID_802_11_WEP_STATUS,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x748b14e8, 0x32ee, 0x4425, 0xb9, 0x1b, 0xc9, 0x84, 0x8c, 0x58, 0xb5, 0x5a},  // GUID_NDIS_802_11_RELOAD_DEFAULTS
     OID_802_11_RELOAD_DEFAULTS,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },


    //
    //  ATM required oids.
    //
    {{0x791ad19e, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_VC_RATES
     OID_ATM_SUPPORTED_VC_RATES,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad19f, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_SERVICE_CATEGORY
     OID_ATM_SUPPORTED_SERVICE_CATEGORY,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a0, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_AAL_TYPES
     OID_ATM_SUPPORTED_AAL_TYPES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a1, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_HW_CURRENT_ADDRESS
     OID_ATM_HW_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a2, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VCS
     OID_ATM_MAX_ACTIVE_VCS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a3, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VCI_BITS
     OID_ATM_MAX_ACTIVE_VCI_BITS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a4, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VPI_BITS
     OID_ATM_MAX_ACTIVE_VPI_BITS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a5, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL0_PACKET_SIZE
     OID_ATM_MAX_AAL0_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a6, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL1_PACKET_SIZE
     OID_ATM_MAX_AAL1_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a7, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL34_PACKET_SIZE
     OID_ATM_MAX_AAL34_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad191, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL5_PACKET_SIZE
     OID_ATM_MAX_AAL5_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },

    //
    //  ATM required statistics oids.
    //
    {{0x0a21480a, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_RCV_CELLS_OK
     OID_ATM_RCV_CELLS_OK,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a21480b, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_XMIT_CELLS_OK
     OID_ATM_XMIT_CELLS_OK,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a21480c, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_RCV_CELLS_DROPPED
     OID_ATM_RCV_CELLS_DROPPED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisStatusSupportedGuids[10] =
{
    //
    //  NDIS Status indications (WMI Events)
    //
    {
     {0x981f2d76, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_RESET_START,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d77, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_RESET_END,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d7d, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_CONNECT,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d7e, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_DISCONNECT,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d84, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
     1,
     fNDIS_GUID_TO_STATUS | fNDIS_GUID_ARRAY
    },
    {
     {0x981f2d85, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_LINK_SPEED_CHANGE,
     8,     //  sizeof(NDIS_CO_LINK_SPEED)
     fNDIS_GUID_TO_STATUS
    },

    /* The following are not really status indications, however we park them here for convenience */
    {
     {0x5413531c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c}, // GUID_NDIS_NOTIFY_BIND
     0,
     (ULONG)-1,
     fNDIS_GUID_TO_STATUS,
    },
    {
     {0x6e3ce1ec, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c}, // GUID_NDIS_NOTIFY_UNBIND
     0,
     (ULONG)-1,
     fNDIS_GUID_TO_STATUS,
    },
    {
     {0x5f81cfd0, 0xf046, 0x4342, 0xaf, 0x61, 0x89, 0x5a, 0xce, 0xda, 0xef, 0xd9}, // GUID_NDIS_NOTIFY_DEVICE_POWER_ON
     0,
     (ULONG)-1,
     fNDIS_GUID_TO_STATUS,
    },
    {
     {0x81bc8189, 0xb026, 0x46ab, 0xb9, 0x64, 0xf1, 0x82, 0xe3, 0x42, 0x93, 0x4e}, // GUID_NDIS_NOTIFY_DEVICE_POWER_OFF
     0,
     (ULONG)-1,
     fNDIS_GUID_TO_STATUS,
    }
     
};


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\common.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    common.c

Abstract:

    NDIS wrapper functions common to miniports and full mac drivers

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization
    09-Apr-1996  KyleB          Added resource remove and acquisition routines.

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_COMMON

//
// Routines for dealing with making the PKG specific routines pagable
//

VOID FASTCALL
ndisInitializePackage(
    IN  PPKG_REF                pPkg
    )
{
    //
    // Lock and unlock the section to obtain the handle. Subsequent locks will be faster
    //
    pPkg->ImageHandle = MmLockPagableCodeSection(pPkg->Address);
    MmUnlockPagableImageSection(pPkg->ImageHandle);
}


VOID FASTCALL
ndisReferencePackage(
    IN  PPKG_REF                pPkg
    )
{
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    MmLockPagableSectionByHandle(pPkg->ImageHandle);
    InterlockedIncrement(&pPkg->ReferenceCount);    
}


VOID FASTCALL
ndisDereferencePackage(
    IN  PPKG_REF                pPkg
    )
{
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    MmUnlockPagableImageSection(pPkg->ImageHandle);
    InterlockedDecrement(&pPkg->ReferenceCount);    
}



NDIS_STATUS
NdisAllocateMemory(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    )
/*++

Routine Description:

    Allocate memory for use by a protocol or a MAC driver

Arguments:

    VirtualAddress - Returns a pointer to the allocated memory.
    Length - Size of requested allocation in bytes.
    MaximumPhysicalAddress - Highest addressable address of the allocated
                            memory.. 0 means highest system memory possible.
    MemoryFlags - Bit mask that allows the caller to specify attributes
                of the allocated memory.  0 means standard memory.

    other options:

        NDIS_MEMORY_CONTIGUOUS
        NDIS_MEMORY_NONCACHED

Return Value:

    NDIS_STATUS_SUCCESS if successful.
    NDIS_STATUS_FAILURE if not successful.  *VirtualAddress will be NULL.


--*/
{
    //
    // Depending on the value of MemoryFlags, we allocate three different
    // types of memory.
    //

    if (MemoryFlags == 0)
    {
        *VirtualAddress = ALLOC_FROM_POOL(Length, NDIS_TAG_ALLOC_MEM);
    }
    else if (MemoryFlags & NDIS_MEMORY_NONCACHED)
    {
        *VirtualAddress = MmAllocateNonCachedMemory(Length);
    }
    else if (MemoryFlags & NDIS_MEMORY_CONTIGUOUS)
    {
        *VirtualAddress = MmAllocateContiguousMemory(Length, HighestAcceptableAddress);
    }
    else
    {
        //
        // invalid flags
        //
        *VirtualAddress = NULL;
    }

    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NdisAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    )
/*++

Routine Description:

    Allocate memory for use by a protocol or a MAC driver

Arguments:

    VirtualAddress - Returns a pointer to the allocated memory.
    Length - Size of requested allocation in bytes.
    Tag - tag to associate with this memory.

Return Value:

    NDIS_STATUS_SUCCESS if successful.
    NDIS_STATUS_FAILURE if not successful.  *VirtualAddress will be NULL.

--*/
{
    *VirtualAddress = ALLOC_FROM_POOL(Length, Tag);
    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}


VOID
NdisFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    )
/*++

Routine Description:

    Releases memory allocated using NdisAllocateMemory.

Arguments:

    VirtualAddress - Pointer to the memory to be freed.
    Length - Size of allocation in bytes.
    MemoryFlags - Bit mask that allows the caller to specify attributes
                of the allocated memory.  0 means standard memory.

    other options:

        NDIS_MEMORY_CONTIGUOUS
        NDIS_MEMORY_NONCACHED

Return Value:

    None.

--*/
{
    //
    // Depending on the value of MemoryFlags, we allocate three free 3
    // types of memory.
    //

    if (MemoryFlags == 0)
    {
        FREE_POOL(VirtualAddress);
    }
    else if (MemoryFlags & NDIS_MEMORY_NONCACHED)
    {
        MmFreeNonCachedMemory(VirtualAddress, Length);
    }
    else if (MemoryFlags & NDIS_MEMORY_CONTIGUOUS)
    {
        MmFreeContiguousMemory(VirtualAddress);
    }
}

//1  With the new packet pool allocation, there is no need to export this any more
UINT
NdisPacketSize(
    IN  UINT                    ProtocolReservedSize
    )
/*++

Routine Description:

    Returns the size of the packet given the amount of protocolreserved. This lets the caller
    do a better job with # of packets it allocates in a single pool.

Arguments:

    ProtocolReservedSize - Size of protocol reserved in bytes

Return Value:

    None.

--*/
{
    UINT    PacketLength;

    PacketLength = SIZE_PACKET_STACKS + sizeof(NDIS_PACKET_OOB_DATA) + sizeof(NDIS_PACKET_EXTENSION);
    PacketLength += ((FIELD_OFFSET(NDIS_PACKET, ProtocolReserved) + ProtocolReservedSize + sizeof(ULONGLONG) - 1) & ~(sizeof(ULONGLONG) -1));

    //
    // Round the entire length up to a memory allocation alignment.
    //

    PacketLength = (PacketLength + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~(MEMORY_ALLOCATION_ALIGNMENT - 1);

    return(PacketLength);
}


NDIS_HANDLE
NdisGetPoolFromPacket(
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:

    Packet  - Packet in question

Return Value:

    Pool handle corresponding to the packet

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)Packet->Private.Pool;

    return(Pool);
}

PNDIS_PACKET_STACK
NdisIMGetCurrentPacketStack(
    IN  PNDIS_PACKET    Packet,
    OUT BOOLEAN *       StacksRemaining
    )
/*++

Routine Description:


Arguments:

    Packet  - Packet in question

Return Value:

    Pointer to the new stack location or NULL if we are out of stacks

--*/
{
    PNDIS_PACKET_STACK  pStack;

    GET_CURRENT_PACKET_STACK_X(Packet, &pStack, StacksRemaining);

    return(pStack);
}


VOID
NdisAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
/*++

Routine Description:

    See ndisAllocPacketPool.

Arguments:

    Status - Returns the final status (always NDIS_STATUS_SUCCESS).
    PoolHandle - Returns a pointer to the pool.
    NumberOfDescriptors - Number of packet descriptors needed.
    ProtocolReservedLength - How long the ProtocolReserved field
            should be for packets in this pool.

Return Value:

    None.

--*/
{
    PVOID   Caller, CallersCaller;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    NdisAllocatePacketPoolEx(Status,
                             PoolHandle,
                             NumberOfDescriptors,
                             0,
                             ProtocolReservedLength);

    if (*Status == NDIS_STATUS_SUCCESS)
    {
        PNDIS_PKT_POOL          Pool = *PoolHandle;

        Pool->Allocator = Caller;
    }
}


VOID
NdisAllocatePacketPoolEx(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
/*++

Routine Description:

    Initializes a packet pool. All packets are the same size for a given pool
    (as determined by ProtocolReservedLength).

    Pool is organized as a pool-header and a number of page-size blocks

Arguments:

    Status - Returns the final status (always NDIS_STATUS_SUCCESS).
    PoolHandle - Returns a pointer to the pool.
    NumberOfDescriptors - Number of packet descriptors needed.
    NumberOfOverflowDescriptors - Number of packet descriptors needed.
    ProtocolReservedLength - How long the ProtocolReserved field should be for packets in this pool.

Return Value:

    None.

--*/
{
    PNDIS_PKT_POOL          Pool;
    PNDIS_PACKET            Packet;
    UINT                    NumPkts = (NumberOfDescriptors + NumberOfOverflowDescriptors);
    ULONG                   Tag = NDIS_TAG_PKT_POOL;
    NDIS_HANDLE             tag = *PoolHandle;
    ULONG_PTR               TmpTag;
    PVOID                   Caller, CallersCaller;
    KIRQL                   OldIrql;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisAllocatePacketPoolEx\n"));

    do
    {
        *PoolHandle = NULL;
        TmpTag = (ULONG_PTR)tag & 0xffffff;
        
        if ((TmpTag == '\0PDN') ||
            (TmpTag == '\0pDN'))
        {
            //
            // zero out the high order bit otherwise the verifier gets confused
            //
            Tag = (ULONG)((ULONG_PTR)tag & 0x7fffffff);
        }
    
        Pool = (PNDIS_PKT_POOL)ALLOC_FROM_POOL(sizeof(NDIS_PKT_POOL), Tag);
        if (Pool == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            return;
        }
    
        ZeroMemory(Pool, sizeof(NDIS_PKT_POOL));
    
        Pool->Tag = Tag;
        Pool->PacketLength = (USHORT)NdisPacketSize(ProtocolReservedLength);
        Pool->PktsPerBlock = (USHORT)((PAGE_SIZE - sizeof(NDIS_PKT_POOL_HDR))/Pool->PacketLength);
        if (Pool->PktsPerBlock != 0)
        {
            Pool->MaxBlocks = (NumPkts + Pool->PktsPerBlock - 1)/Pool->PktsPerBlock;
            Pool->BlockSize = PAGE_SIZE;
        }
        
        INITIALIZE_SPIN_LOCK(&Pool->Lock);

        if ((Pool->PktsPerBlock > NumPkts) || (Pool->PktsPerBlock == 0))
        {
            //
            // This is a pool which does not warrant a full-page or packet is too big to fit in
            // one page.
            //
            Pool->BlockSize = (ULONG)(sizeof(NDIS_PKT_POOL_HDR) + (NumPkts*Pool->PacketLength));
            Pool->PktsPerBlock = (USHORT)NumPkts;
            Pool->MaxBlocks = 1;
        }

        Pool->ProtocolId = NDIS_PROTOCOL_ID_DEFAULT;
        InitializeListHead(&Pool->AgingBlocks);
        InitializeListHead(&Pool->FreeBlocks);
        InitializeListHead(&Pool->UsedBlocks);

        ACQUIRE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, &OldIrql);
        InsertHeadList(&ndisGlobalPacketPoolList, &Pool->GlobalPacketPoolList);
        RELEASE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, OldIrql);

            
        //
        // Prime the pool by allocating a packet and freeing it.
        // Aging will ensure it is not immediately freed
        //
        NdisAllocatePacket(Status, &Packet, Pool);
        if (*Status != NDIS_STATUS_SUCCESS)
        {
            ACQUIRE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, &OldIrql);
            RemoveEntryList(&Pool->GlobalPacketPoolList);
            RELEASE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, OldIrql);
            FREE_POOL(Pool);
            break;
        }
        NdisFreePacket(Packet);
        *PoolHandle = Pool;
        Pool->Allocator = Caller;
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisAllocatePacketPoolEx, Status %.8x\n", *Status));
}

VOID
NdisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    )
{
    ndisFreePacketPool(PoolHandle, FALSE);
}   

VOID
ndisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle,
    IN  BOOLEAN                 Verify
    )
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

    if (Verify)
        ASSERTMSG("NdisFreePacketPool: Freeing non-empty pool\n", IsListEmpty(&Pool->UsedBlocks));
    
    while (!IsListEmpty(&Pool->AgingBlocks))
    {
        List = RemoveHeadList(&Pool->AgingBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        if (Verify)
            ASSERT(ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock);
        Pool->BlocksAllocated --;
        FREE_POOL(Hdr);
    }

    while (!IsListEmpty(&Pool->FreeBlocks))
    {
        List = RemoveHeadList(&Pool->FreeBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        if (Verify)
            ASSERT(ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock);
        Pool->BlocksAllocated --;
        FREE_POOL(Hdr);
    }

    //
    // We should never be executing the code below (see assertmsg() above). This should perhaps
    // be turned into a KeBugCheckEx()
    //
    while (!IsListEmpty(&Pool->UsedBlocks))
    {
        List = RemoveHeadList(&Pool->UsedBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        FREE_POOL(Hdr);
        Pool->BlocksAllocated --;
    }

    ASSERT(Pool->BlocksAllocated == 0);

    ACQUIRE_SPIN_LOCK_DPC(&ndisGlobalPacketPoolListLock);
    RemoveEntryList(&Pool->GlobalPacketPoolList);
    RELEASE_SPIN_LOCK_DPC(&ndisGlobalPacketPoolListLock);
                                
    RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);

    FREE_POOL(Pool);
}


#define ndisInitializePacket(_Packet)                                       \
    {                                                                       \
        /*                                                                  \
         * Set the current stack pointer to -1                              \
         */                                                                 \
        CURR_STACK_LOCATION(_Packet) = (ULONG)-1;                           \
        CURR_XFER_DATA_STACK_LOCATION(_Packet) = (ULONG)-1;                 \
        NDIS_SET_ORIGINAL_PACKET(_Packet, _Packet);                         \
        (_Packet)->Private.Head = NULL;                                     \
        (_Packet)->Private.ValidCounts = FALSE;                             \
        (_Packet)->Private.NdisPacketFlags = fPACKET_ALLOCATED_BY_NDIS;     \
    }

VOID
NdisAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    )
/*++

Routine Description:

    Allocates a packet out of a packet pool.

Arguments:

    Status      -   Returns the final status.
    Packet      -   Return a pointer to the packet.
    PoolHandle  - The packet pool to allocate from.

Return Value:

    NDIS_STATUS_SUCCESS     If we succeeded.
    NDIS_STATUS_RESOURCES   On a failure to allocate or exceeded limit

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    PSLIST_ENTRY            SList;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==> NdisAllocatePacket\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Pool))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NdisAllocatePacket: NULL Pool address\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
    }

    do
    {
        SList = NULL;

        //
        // First check if we have any free packets readily available
        // but get a pointer to Flink before doing the check. this will save us aginst
        // the situations that List can become empty right after the check below.
        //
        List = Pool->FreeBlocks.Flink;
        
        if (List != &Pool->FreeBlocks)
        {
            Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
            SList = InterlockedPopEntrySList(&Hdr->FreeList);

            //
            // Another processor can exhaust the block between the check for non-empty and the pop
            //
            if (SList == NULL)
            {
                goto try_aging_block;
            }

#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cAllocatedFromFreeBlocks);
#endif
            //
            // We got the packet, now see if some book-keeping is in order
            //
            if ((Pool->MaxBlocks > 1) &&
                ExQueryDepthSList(&Hdr->FreeList) == 0)
            {
                //
                // This block is now completely used up. Move it to the UsedBlocks list.
                // The sequence below guarantees that there is no race condition
                //
                ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

                RemoveEntryList(&Hdr->List);
                if (ExQueryDepthSList(&Hdr->FreeList) == 0)
                {
                    InsertTailList(&Pool->UsedBlocks, List);
                    Hdr->State = NDIS_PACKET_POOL_BLOCK_USED;

#ifdef NDIS_PKT_POOL_STATISTICS
                    InterlockedIncrement(&Pool->cMovedFreeBlocksToUsed);
#endif
                }
                else
                {
                    InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
                    Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                }

                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            }
            break;
        }

    try_aging_block:
        //
        // Try taking an aging block and move it into the free block
        //
        ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

        if (!IsListEmpty(&Pool->AgingBlocks))
        {
            List = RemoveHeadList(&Pool->AgingBlocks);
            ASSERT (List != NULL);

            Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
            SList = InterlockedPopEntrySList(&Hdr->FreeList);
            ASSERT(SList != NULL);
            InsertHeadList(&Pool->FreeBlocks, List);
            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
            
#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cMovedAgedBlocksToFree);
#endif
            
            if (!IsListEmpty(&Pool->AgingBlocks))
            {
                List = Pool->AgingBlocks.Flink;
                Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
                Pool->NextScavengeTick.QuadPart = Hdr->TimeStamp.QuadPart + PoolAgingTicks.QuadPart;
            }
            else
            {
                Pool->NextScavengeTick.QuadPart = 0;
            }

            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            break;
        }

        //
        // See if have any head room to allocate more blocks
        //
        if (Pool->BlocksAllocated < Pool->MaxBlocks)
        {
            PUCHAR  pTmp;
            ULONG   i, j;

            Hdr = (PNDIS_PKT_POOL_HDR)ALLOC_FROM_POOL(Pool->BlockSize, Pool->Tag);
            if (Hdr == NULL)
            {
                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
                break;
            }
            NdisZeroMemory(Hdr, Pool->BlockSize);

            Pool->BlocksAllocated ++;
            InitializeListHead(&Hdr->List);
            ExInitializeSListHead(&Hdr->FreeList);
            pTmp = (PUCHAR)Hdr + sizeof(NDIS_PKT_POOL_HDR);
            for (i = Pool->PktsPerBlock; i > 0; i --)
            {
                PNDIS_PACKET    p;
                PNDIS_STACK_RESERVED NSR;

                p = (PNDIS_PACKET)(pTmp + SIZE_PACKET_STACKS);
                p->Private.NdisPacketFlags = 0;
                pTmp += Pool->PacketLength;
#ifdef _WIN64
                InterlockedPushEntrySList(&Hdr->FreeList,
                                            (PSLIST_ENTRY)p);
#else

                InterlockedPushEntrySList(&Hdr->FreeList,
                                            (PSLIST_ENTRY)(&p->Private.Head));
#endif

                p->Private.Pool = Pool;
                p->Private.Flags = Pool->ProtocolId;
        
                //
                // Set the offset to the out of band data.
                //
                p->Private.NdisPacketOobOffset = (USHORT)(Pool->PacketLength -
                                                            (SIZE_PACKET_STACKS +
                                                             sizeof(NDIS_PACKET_OOB_DATA) +
                                                             sizeof(NDIS_PACKET_EXTENSION)));
                NDIS_SET_ORIGINAL_PACKET(p, p);

                //
                // initialize the spinlocks on packet stack
                //
                for (j = 0; j < ndisPacketStackSize; j++)
                {
                    CURR_STACK_LOCATION(p) = j;
                    NDIS_STACK_RESERVED_FROM_PACKET(p, &NSR);
                    INITIALIZE_SPIN_LOCK(&NSR->Lock);
                }
            }

            SList = InterlockedPopEntrySList(&Hdr->FreeList);

            InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;

#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cAllocatedNewBlocks);
#endif

            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            break;
        }

        RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);

    } while (FALSE);

    if (SList != NULL)
    {

#ifdef _WIN64
        *Packet = (PNDIS_PACKET)SList;
#else
        *Packet = CONTAINING_RECORD(SList, NDIS_PACKET, Private.Head);
#endif
        *Status = NDIS_STATUS_SUCCESS;
        ndisInitializePacket(*Packet);
    }
    else
    {
        *Packet = NULL;
        *Status = NDIS_STATUS_RESOURCES;
    }

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisAllocatePacket, Status %.8x\n", *Status));
}


VOID
NdisFreePacket(
    IN  PNDIS_PACKET    Packet
    )
{
    PNDIS_PKT_POOL_HDR  Hdr;
    PNDIS_PKT_POOL      Pool;
    LARGE_INTEGER       CurrTick;
    KIRQL               OldIrql;
    LARGE_INTEGER       HdrDeadTicks;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisFreePacket\n"));

    ASSERT(Packet->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS);
    Packet->Private.NdisPacketFlags =0;

    Pool = Packet->Private.Pool;

    Hdr = (PNDIS_PKT_POOL_HDR)((ULONG_PTR)Packet & ~(PAGE_SIZE - 1));
    if (Pool->BlockSize != PAGE_SIZE)
    {
        PLIST_ENTRY List;

        //
        // This pool is not a page-sized pool and so the hdr is not page-aligned.
        // However we know that for such as pool, the Hdr is part of the FreeBlocks
        // list and is never moved to either Used or Aging blocks.
        //
        List = Pool->FreeBlocks.Flink;
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
    }

#ifdef _WIN64
    ExInterlockedPushEntrySList(&Hdr->FreeList, (PSLIST_ENTRY)Packet, &Pool->Lock);
#else

    ExInterlockedPushEntrySList(&Hdr->FreeList,
                                CONTAINING_RECORD(&Packet->Private.Head, SLIST_ENTRY, Next),
                                &Pool->Lock);
#endif

    //
    // If this pool is a pool > 1 block and more than one has been allocated then ...
    //
    // If this hdr is completely free , then move it from the FreeBlocks list to the AgingBlocks and time-stamp it.
    // Add it at the tail since this makes it sorted in time.
    // While we are at it, check the head of the list and age out an entry if it needs to be.
    //
    if (Pool->MaxBlocks > 1)
    {

        if (((Pool->BlocksAllocated > 1) && (ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock))||
            (Hdr->State == NDIS_PACKET_POOL_BLOCK_USED))
        {
            ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);
            if (ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock)
            {
                //
                // This block is completely free. Move it to the aged blocks list.
                //
                GET_CURRENT_TICK(&CurrTick);
                Hdr->TimeStamp = CurrTick;
                RemoveEntryList(&Hdr->List);
                InsertTailList(&Pool->AgingBlocks, &Hdr->List);
                Hdr->State = NDIS_PACKET_POOL_BLOCK_AGING;
                
#ifdef NDIS_PKT_POOL_STATISTICS
                InterlockedIncrement(&Pool->cMovedFreeBlocksToAged);
#endif
            }
            else if (Hdr->State == NDIS_PACKET_POOL_BLOCK_USED)
            {
                //
                // This block was completely used up but now has one or more
                // free packet. Move it to the tail of the free blocks list.
                //
                RemoveEntryList(&Hdr->List);
                InsertTailList(&Pool->FreeBlocks, &Hdr->List);
                Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                
#ifdef NDIS_PKT_POOL_STATISTICS
                InterlockedIncrement(&Pool->cMovedUsedBlocksToFree);
#endif
            }
            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
        }

        if (!IsListEmpty(&Pool->AgingBlocks))
        {
            GET_CURRENT_TICK(&CurrTick);
            if (CurrTick.QuadPart > Pool->NextScavengeTick.QuadPart)
            {
                ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

                while (!IsListEmpty(&Pool->AgingBlocks))
                {
                    PLIST_ENTRY     List = Pool->AgingBlocks.Flink;

                    Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);

                    HdrDeadTicks.QuadPart = Hdr->TimeStamp.QuadPart + PoolAgingTicks.QuadPart;
                    if (CurrTick.QuadPart > HdrDeadTicks.QuadPart)
                    {
                        RemoveHeadList(&Pool->AgingBlocks);
                        
                        if (ExQueryDepthSList(&Hdr->FreeList) != Pool->PktsPerBlock)
                        {
                            //
                            // somehow we ended up allocating a packet from an aged block
                            // put the block back on free list. this can happen if during 
                            // NdisAllocatePacket, right after getting a packet from a free
                            // block list, the block moves to aging list.
                            //
#if DBG
                            DbgPrint("Ndis: pool %p: aged packet pool block at %p contains allocated packets!\n", Pool, Hdr);
#endif
                            InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
                            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                        }
                        else
                        {
                            FREE_POOL(Hdr);
                            Pool->BlocksAllocated --;
                            
#ifdef NDIS_PKT_POOL_STATISTICS
                            InterlockedIncrement(&Pool->cFreedAgedBlocks);
#endif
                        }
                    } 
                    else
                    {
                        //
                        // Compute the next tick value which represents the earliest time
                        // that we will scavenge this pool again.
                        //
                        Pool->NextScavengeTick.QuadPart = HdrDeadTicks.QuadPart;
                        break;
                    }
                }
                
                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            }
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisFreePacket\n"));
}

UINT
NdisPacketPoolUsage(
    IN  PNDIS_HANDLE            PoolHandle
    )
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    UINT                    NumUsed = 0;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);
        
    for (List = Pool->UsedBlocks.Flink; List != &Pool->UsedBlocks; List = List->Flink)
    {
        NumUsed += Pool->PktsPerBlock;
    }

    for (List = Pool->FreeBlocks.Flink; List != &Pool->FreeBlocks; List = List->Flink)
    {
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);

        NumUsed += (Pool->PktsPerBlock - ExQueryDepthSList(&Hdr->FreeList));
    }

    RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
    
    return NumUsed;
}

//1 we probably don't need this API any more.
VOID
NdisSetPacketPoolProtocolId(
    IN  NDIS_HANDLE             PacketPoolHandle,
    IN  UINT                    ProtocolId
    )
/*++

Routine Description:

    Set the protocol id in the pool and all the packets allocated to the pool. This api has to be called
    prior to any packets that are allocated out of the pool. The code below is linked to the NdisAllocatePacket
    code in that the first empty pool (Pool->BlocksAllocated == 1) is left at the FreeBlocks list and not
    moved to the AgingList.

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PacketPoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    PNDIS_PACKET            Packet;
    PUCHAR                  p;
    UINT                    j;

    Pool->ProtocolId = ProtocolId;

    ASSERT(IsListEmpty(&Pool->AgingBlocks));
    ASSERT(IsListEmpty(&Pool->UsedBlocks));

    for (List = Pool->FreeBlocks.Flink; List != &Pool->FreeBlocks; List = List->Flink)
    {
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        p = (PUCHAR)Hdr + sizeof(NDIS_PKT_POOL_HDR);

        for (j = Pool->PktsPerBlock; j > 0; j--, p += Pool->PacketLength)
        {
            Packet = (PNDIS_PACKET)(p + SIZE_PACKET_STACKS);
            Packet->Private.Flags |= ProtocolId;
        }
    }
}

//1 Deprecate this function for non-binary compatible drivers.
VOID
NdisAllocateBufferPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors
    )
/*++

Routine Description:

    Initializes a block of storage so that buffer descriptors can be
    allocated.

Arguments:

    Status - status of the request.
    PoolHandle - handle that is used to specify the pool
    NumberOfDescriptors - Number of buffer descriptors in the pool.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(NumberOfDescriptors);
    
    *PoolHandle = NULL;
    *Status = NDIS_STATUS_SUCCESS;
}


//1 Deprecate this function for non-binary compatible drivers.
VOID
NdisFreeBufferPool(
    IN  NDIS_HANDLE             PoolHandle
    )
/*++

Routine Description:

    Terminates usage of a buffer descriptor pool.

Arguments:

    PoolHandle - handle that is used to specify the pool

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(PoolHandle);

    return;
}


VOID
NdisAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
/*++

Routine Description:

    Creates a buffer descriptor to describe a segment of virtual memory
    allocated via NdisAllocateMemory (which always allocates nonpaged).

Arguments:

    Status - Status of the request.
    Buffer - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    VirtualAddress - The virtual address of the buffer.
    Length - The Length of the buffer.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(PoolHandle);

    *Status = NDIS_STATUS_FAILURE;
    if ((*Buffer = IoAllocateMdl(VirtualAddress,
                                 Length,
                                 FALSE,
                                 FALSE,
                                 NULL)) != NULL)
    {
        MmBuildMdlForNonPagedPool(*Buffer);
        (*Buffer)->Next = NULL;
        *Status = NDIS_STATUS_SUCCESS;
    }
}


VOID
NdisAdjustBufferLength(
    IN  PNDIS_BUFFER            Buffer,
    IN  UINT                    Length
    )
{
    Buffer->ByteCount = Length;
}


VOID
NdisCopyBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   MemoryDescriptor,
    IN  UINT                    Offset,
    IN  UINT                    Length
    )
/*++

Routine Description:

    Used to create a buffer descriptor given a memory descriptor.

Arguments:

    Status - Status of the request.
    Buffer - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    MemoryDescriptor - Pointer to the descriptor of the source memory.
    Offset - The Offset in the sources memory from which the copy is to begin
    Length - Number of Bytes to copy.

Return Value:

    None.

--*/
{
    PNDIS_BUFFER SourceDescriptor = (PNDIS_BUFFER)MemoryDescriptor;
    PVOID BaseVa = (((PUCHAR)MDL_VA(SourceDescriptor)) + Offset);

    UNREFERENCED_PARAMETER(PoolHandle);


    *Status = NDIS_STATUS_FAILURE;
    if ((*Buffer = IoAllocateMdl(BaseVa,
                                 Length,
                                 FALSE,
                                 FALSE,
                                 NULL)) != NULL)
    {
        IoBuildPartialMdl(SourceDescriptor,
                          *Buffer,
                          BaseVa,
                          Length);

        (*Buffer)->Next = NULL;
        *Status = NDIS_STATUS_SUCCESS;
    }
}


VOID
NdisUnchainBufferAtFront(
    IN  OUT PNDIS_PACKET        Packet,
    OUT PNDIS_BUFFER *          Buffer
    )

/*++

Routine Description:

    Takes a buffer off the front of a packet.

Arguments:

    Packet - The packet to be modified.
    Buffer - Returns the packet on the front, or NULL.

Return Value:

    None.

--*/

{
    *Buffer = Packet->Private.Head;

    //
    // If packet is not empty, remove head buffer.
    //

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisUnchainBufferAtFront\n"));

    if (*Buffer != (PNDIS_BUFFER)NULL)
    {
        Packet->Private.Head = (*Buffer)->Next; // may be NULL
        (*Buffer)->Next = (PNDIS_BUFFER)NULL;
        Packet->Private.ValidCounts = FALSE;
    }
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisUnchainBufferAtFront\n"));
}


VOID
NdisUnchainBufferAtBack(
    IN  OUT PNDIS_PACKET        Packet,
    OUT PNDIS_BUFFER *          Buffer
    )

/*++

Routine Description:

    Takes a buffer off the end of a packet.

Arguments:

    Packet - The packet to be modified.
    Buffer - Returns the packet on the end, or NULL.

Return Value:

    None.

--*/

{
    PNDIS_BUFFER BufP = Packet->Private.Head;
    PNDIS_BUFFER Result;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisUnchainBufferAtBack\n"));

    if (BufP != (PNDIS_BUFFER)NULL)
    {
        //
        // The packet is not empty, return the tail buffer.
        //

        Result = Packet->Private.Tail;
        if (BufP == Result)
        {
            //
            // There was only one buffer on the queue.
            //

            Packet->Private.Head = (PNDIS_BUFFER)NULL;
        }
        else
        {
            //
            // Determine the new tail buffer.
            //

            while (BufP->Next != Result)
            {
                BufP = BufP->Next;
            }
            Packet->Private.Tail = BufP;
            BufP->Next = NULL;
        }

        Result->Next = (PNDIS_BUFFER)NULL;
        Packet->Private.ValidCounts = FALSE;
    }
    else
    {
        //
        // Packet is empty.
        //

        Result = (PNDIS_BUFFER)NULL;
    }

    *Buffer = Result;
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisUnchainBufferAtBack\n"));
}



VOID
NdisCopyFromPacketToPacket(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied
    )

/*++

Routine Description:

    Copy from an ndis packet to an ndis packet.

Arguments:

    Destination - The packet should be copied in to.

    DestinationOffset - The offset from the beginning of the packet
    into which the data should start being placed.

    BytesToCopy - The number of bytes to copy from the source packet.

    Source - The ndis packet from which to copy data.

    SourceOffset - The offset from the start of the packet from which
    to start copying data.

    BytesCopied - The number of bytes actually copied from the source
    packet.  This can be less than BytesToCopy if the source or destination
    packet is too short.

Return Value:

    None

--*/

{

    //
    // Points to the buffer into which we are putting data.
    //
    PNDIS_BUFFER DestinationCurrentBuffer;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER SourceCurrentBuffer;

    //
    // Holds the virtual address of the current destination buffer.
    //
    PVOID DestinationVirtualAddress;

    //
    // Holds the virtual address of the current source buffer.
    //
    PVOID SourceVirtualAddress;

    //
    // Holds the length of the current destination buffer.
    //
    UINT DestinationCurrentLength;

    //
    // Holds the length of the current source buffer.
    //
    UINT SourceCurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer of the destination.
    //

    DestinationCurrentBuffer = Destination->Private.Head;
    //
    // Could have a null packet.
    //
    if (DestinationCurrentBuffer == NULL)
        return;

    DestinationVirtualAddress = MDL_ADDRESS(DestinationCurrentBuffer);
    DestinationCurrentLength = MDL_SIZE(DestinationCurrentBuffer);


    //
    // Get the first buffer of the source.
    //

    SourceCurrentBuffer = Source->Private.Head;

    //
    // Could have a null packet.
    //

    if (SourceCurrentBuffer == NULL)
        return;


    SourceVirtualAddress = MDL_ADDRESS(SourceCurrentBuffer);
    SourceCurrentLength = MDL_SIZE(SourceCurrentBuffer);

    while (LocalBytesCopied < BytesToCopy)
    {
        //
        // Check to see whether we've exhausted the current destination
        // buffer.  If so, move onto the next one.
        //

        if (!DestinationCurrentLength)
        {
            DestinationCurrentBuffer = DestinationCurrentBuffer->Next;

            if (!DestinationCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;

            }

            DestinationVirtualAddress = MDL_ADDRESS(DestinationCurrentBuffer);
            DestinationCurrentLength = MDL_SIZE(DestinationCurrentBuffer);

            continue;
        }


        //
        // Check to see whether we've exhausted the current source
        // buffer.  If so, move onto the next one.
        //

        if (!SourceCurrentLength)
        {
            SourceCurrentBuffer = SourceCurrentBuffer->Next;

            if (!SourceCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;
            }
            
            SourceVirtualAddress = MDL_ADDRESS(SourceCurrentBuffer);
            SourceCurrentLength = MDL_SIZE(SourceCurrentBuffer);
            
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (DestinationOffset)
        {
            if (DestinationOffset > DestinationCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                DestinationOffset -= DestinationCurrentLength;
                DestinationCurrentLength = 0;
                continue;
            }
            else
            {
                DestinationVirtualAddress = (PCHAR)DestinationVirtualAddress
                                            + DestinationOffset;
                DestinationCurrentLength -= DestinationOffset;
                DestinationOffset = 0;
            }
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (SourceOffset)
        {
            if (SourceOffset > SourceCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                SourceOffset -= SourceCurrentLength;
                SourceCurrentLength = 0;
                continue;
            }
            else
            {
                SourceVirtualAddress = (PCHAR)SourceVirtualAddress
                                            + SourceOffset;
                SourceCurrentLength -= SourceOffset;
                SourceOffset = 0;
            }
        }

        //
        // Copy the data.
        //

        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            //
            // Holds the amount desired remaining.
            //
            UINT Remaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = ((SourceCurrentLength <= DestinationCurrentLength) ?
                                            (SourceCurrentLength) : (DestinationCurrentLength));

            AmountToMove = ((Remaining < AmountToMove)?
                            (Remaining):(AmountToMove));

            CopyMemory(DestinationVirtualAddress, SourceVirtualAddress, AmountToMove);

            DestinationVirtualAddress =
                (PCHAR)DestinationVirtualAddress + AmountToMove;
            SourceVirtualAddress =
                (PCHAR)SourceVirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            SourceCurrentLength -= AmountToMove;
            DestinationCurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

//1 Deprecate this function
VOID
NdisUpdateSharedMemory(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Length,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
/*++

Routine Description:

    Ensures that the data to be read from a shared memory region is
    fully up-to-date.

Arguments:

    NdisAdapterHandle - handle returned by NdisRegisterAdapter.
    Length - The length of the shared memory.
    VirtualAddress - Virtual address returned by NdisAllocateSharedMemory.
    PhysicalAddress - The physical address returned by NdisAllocateSharedMemory.

Return Value:

    None.

--*/

{
    //
    // There is no underlying HAL routine for this anymore,
    // it is not needed.
    //
    UNREFERENCED_PARAMETER(NdisAdapterHandle);
    UNREFERENCED_PARAMETER(Length);
    UNREFERENCED_PARAMETER(VirtualAddress);
    UNREFERENCED_PARAMETER(PhysicalAddress);

}


BOOLEAN
ndisCheckPortUsage(
    IN  ULONG                               u32PortNumber,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PULONG                              pTranslatedPort,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor
)
/*++

Routine Description:

    This routine checks if a port is assigned to this miniport.

Arguments:

    BusNumber - Bus number in the system
    PortNumber - Address of the port to access.

Return Value:

    TRUE if the port is assigned to this miniport, FALSE otherwise

--*/

{
    PHYSICAL_ADDRESS Port;
    PHYSICAL_ADDRESS u64Port;

    Port.QuadPart = u32PortNumber;
    
    if (NDIS_STATUS_SUCCESS == ndisTranslateResources(Miniport,
                                                      CmResourceTypePort,
                                                      Port,
                                                      &u64Port,
                                                      pResourceDescriptor))
    {
        *pTranslatedPort = u64Port.LowPart;
        return TRUE;
    }
    else
    {
        *pTranslatedPort = 0;
        return FALSE;
    }
}


NTSTATUS
ndisStartMapping(
    IN   INTERFACE_TYPE         InterfaceType,
    IN   ULONG                  BusNumber,
    IN   ULONG                  InitialAddress,
    IN   ULONG                  Length,
    IN   ULONG                  AddressSpace,
    OUT PVOID *                 InitialMapping,
    OUT PBOOLEAN                Mapped
    )

/*++

Routine Description:

    This routine initialize the mapping of a address into virtual
    space dependent on the bus number, etc.

Arguments:

    InterfaceType - The bus type (ISA)
    BusNumber - Bus number in the system
    InitialAddress - Address to access.
    Length - Number of bytes from the base address to access.
    InitialMapping - The virtual address space to use when accessing the
     address.
    Mapped - Did an MmMapIoSpace() take place.

Return Value:

    The function value is the status of the operation.

--*/
{
    PHYSICAL_ADDRESS TranslatedAddress;
    PHYSICAL_ADDRESS InitialPhysAddress;

    //
    // Get the system physical address for this card.  The card uses
    // I/O space, except for "internal" Jazz devices which use
    // memory space.
    //

    *Mapped = FALSE;

    InitialPhysAddress.LowPart = InitialAddress;

    InitialPhysAddress.HighPart = 0;

    if (InterfaceType != -1)
    {
        if ((InterfaceType != Isa) &&
            (InterfaceType != PCIBus))
        {
            InterfaceType = Isa;
        }
        
        if (!HalTranslateBusAddress(InterfaceType,              // InterfaceType
                                    BusNumber,                  // BusNumber
                                    InitialPhysAddress,         // Bus Address
                                    &AddressSpace,              // AddressSpace
                                    &TranslatedAddress))        // Translated address
        {
            //
            // It would be nice to return a better status here, but we only get
            // TRUE/FALSE back from HalTranslateBusAddress.
            //

            return NDIS_STATUS_FAILURE;
        }
    }
    else
    {
        TranslatedAddress = InitialPhysAddress;
    }
    
    if (AddressSpace == 0)
    {
        //
        // memory space
        //

        *InitialMapping = MmMapIoSpace(TranslatedAddress, Length, FALSE);

        if (*InitialMapping == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        *Mapped = TRUE;
    }
    else
    {
        //
        // I/O space
        //

        *(ULONG_PTR *)InitialMapping = TranslatedAddress.LowPart;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ndisEndMapping(
    IN  PVOID                   InitialMapping,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Mapped
    )

/*++

Routine Description:

    This routine undoes the mapping of an address into virtual
    space dependent on the bus number, etc.

Arguments:

    InitialMapping - The virtual address space to use when accessing the
     address.
    Length - Number of bytes from the base address to access.
    Mapped - Do we need to call MmUnmapIoSpace.

Return Value:

    The function value is the status of the operation.

--*/
{

    if (Mapped)
    {
        //
        // memory space
        //

        MmUnmapIoSpace(InitialMapping, Length);
    }

    return STATUS_SUCCESS;
}

VOID
ndisImmediateReadWritePort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  OUT PVOID               Data,
    IN  ULONG                   Size,
    IN  BOOLEAN                 Read
    )
/*++

Routine Description:

    This routine reads from a port a UCHAR.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport;
    BOOLEAN                     Mapped = FALSE;
    PVOID                       PortMapping;
    NDIS_INTERFACE_TYPE         BusType;
    ULONG                       BusNumber;
    NTSTATUS                    Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;

    Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;
    
    ASSERT(Miniport != NULL);
    
    do
    {
        if (Read)
        {
            switch (Size)
            {
                case sizeof (UCHAR):
                    *((PUCHAR)Data) = (UCHAR)0xFF;
                    break;
                    
                case sizeof (USHORT):
                    *((PUSHORT)Data) = (USHORT)0xFFFF;
                    break;
                    
                case sizeof (ULONG):
                    *((PULONG)Data) = (ULONG)0xFFFFFFFF;
                    break;
            }
        }
        
        //
        // Check that the port is available. If so map the space.
        //
        if (ndisCheckPortUsage(Port,
                               Miniport,
                               (PULONG)&PortMapping,
                               &pResourceDescriptor) == FALSE)
        {
            //
            // the resource was not part of already allocated resources,
            // nor could we allocate the resource
            //
            break;
        }

        if (pResourceDescriptor == NULL)
        {
            //
            // the port is not part of allocated resources, try to 
            // temporray allocate the resource
            //
            if (!NT_SUCCESS(Status = ndisStartMapping(BusType,
                                                      BusNumber,
                                                      Port,
                                                      Size,
                                                      (BusType == Internal) ? 0 : 1,
                                                      &PortMapping,
                                                      &Mapped)))
            {
                break;
            }
        }
        else
        {
            Mapped = FALSE;
        }

        if (Read)
        {
            //
            // Read from the port
            //
            switch (Size)
            {
                case sizeof (UCHAR):
                    *((PUCHAR)Data) = READ_PORT_UCHAR((PUCHAR)PortMapping);
                    break;
                    
                case sizeof (USHORT):
                    *((PUSHORT)Data) = READ_PORT_USHORT((PUSHORT)PortMapping);
                    break;
                    
                case sizeof (ULONG):
                    *((PULONG)Data) = READ_PORT_ULONG((PULONG)PortMapping);
                    break;
            }
        }
        else
        {
            //
            // write to the port
            //
            switch (Size)
            {
                case sizeof (UCHAR):
                    WRITE_PORT_UCHAR((PUCHAR)PortMapping, *((PUCHAR)Data));
                    break;
                    
                case sizeof (USHORT):
                    WRITE_PORT_USHORT((PUSHORT)PortMapping, *((PUSHORT)Data));
                    break;
                    
                case sizeof (ULONG):
                    WRITE_PORT_ULONG((PULONG)PortMapping, *((PULONG)Data));
                    break;
            }
        }
        
        if (Mapped)
        {
            //
            // End port mapping
            //

            ndisEndMapping(PortMapping, Size, Mapped);
        }
    } while (FALSE);
}



//1 Deprecated function
VOID
NdisImmediateReadPortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    )
/*++

Routine Description:

    This routine reads from a port a UCHAR.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUchar: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (UCHAR),
                               TRUE);
}

//1 Deprecated function
VOID
NdisImmediateReadPortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUSHORT                 Data
    )
/*++

Routine Description:

    This routine reads from a port a USHORT.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUshort: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (USHORT),
                               TRUE);

}

//1 Deprecated function
VOID
NdisImmediateReadPortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PULONG                  Data
    )
/*++

Routine Description:

    This routine reads from a port a ULONG.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUlong: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (ULONG),
                               TRUE);

}

//1 Deprecated function
VOID
NdisImmediateWritePortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    )
/*++

Routine Description:

    This routine writes to a port a UCHAR.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUchar: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (UCHAR),
                               FALSE);

}

//1 Deprecated function
VOID
NdisImmediateWritePortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    )
/*++

Routine Description:

    This routine writes to a port a USHORT.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUshort: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (USHORT),
                               FALSE);

}

//1 Deprecated function
VOID
NdisImmediateWritePortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    )
/*++

Routine Description:

    This routine writes to a port a ULONG.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUlong: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (ULONG),
                               FALSE);

}

BOOLEAN
ndisCheckMemoryUsage(
    IN  ULONG                               u32Address,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PULONG                              pTranslatedAddress,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor
)
/*++
Routine Description:

    This routine checks if a range of memory is currently in use somewhere
    in the system via IoReportUsage -- which fails if there is a conflict.

Arguments:

    Address - Starting Address of the memory to access.
    Length - Length of memory from the base address to access.

Return Value:

    FALSE if there is a conflict, else TRUE

--*/
{
    PHYSICAL_ADDRESS Address;
    PHYSICAL_ADDRESS u64Address;

    Address.QuadPart = u32Address;

    if (NDIS_STATUS_SUCCESS == ndisTranslateResources(Miniport,
                                                      CmResourceTypeMemory,
                                                      Address,
                                                      &u64Address,
                                                      pResourceDescriptor))
    {
        *pTranslatedAddress = u64Address.LowPart;
        return TRUE;
    }
    else
    {
        *pTranslatedAddress = 0;
        return FALSE;
    }

}

VOID
ndisImmediateReadWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Read
    )
/*++

Routine Description:

    This routine read into a buffer from shared ram.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to read from.

    Buffer - The buffer to read into.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;
    NDIS_INTERFACE_TYPE BusType;
    PNDIS_MINIPORT_BLOCK Miniport;
    BOOLEAN             Mapped;
    PVOID               MemoryMapping;
    ULONG               BusNumber;

    Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;

    ASSERT(Miniport != NULL);

    do
    {
        //
        // Check that the memory is available. Map the space
        //

        if (ndisCheckMemoryUsage(SharedMemoryAddress,
                                  Miniport,
                                  (PULONG)&MemoryMapping,
                                  &pResourceDescriptor
                                  ) == FALSE)
        {
            //
            // the resource was not part of already allocated resources,
            // nor could we allocate the resource
            //

            break;
        }
        
        //
        // the port is not part of allocated resources, try to 
        // temporray allocate the resource
        //
        if (!NT_SUCCESS(ndisStartMapping((pResourceDescriptor == NULL) ? BusType : -1,
                                     BusNumber,
                                     SharedMemoryAddress,
                                     Length,
                                     0,
                                     &MemoryMapping,
                                     &Mapped)))
        {
            break;
        }

        if (Read)
        {
            //
            // Read from memory
            //

#ifdef _M_IX86

            memcpy(Buffer, MemoryMapping, Length);

#else

            READ_REGISTER_BUFFER_UCHAR(MemoryMapping,Buffer,Length);

#endif
        }
        else
        {
            //
            // Write to memory
            //

#ifdef _M_IX86

            memcpy(MemoryMapping, Buffer, Length);

#else

            WRITE_REGISTER_BUFFER_UCHAR(MemoryMapping,Buffer,Length);

#endif
        }
        
        //
        // End mapping
        //

        ndisEndMapping(MemoryMapping,
                       Length,
                       Mapped);

    } while (FALSE);
}

//1 Deprecated function
VOID
NdisImmediateReadSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
/*++

Routine Description:

    This routine read into a buffer from shared ram.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to read from.

    Buffer - The buffer to read into.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadSharedMemory: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWriteSharedMemory(
        WrapperConfigurationContext,
        SharedMemoryAddress,
        Buffer,
        Length,
        TRUE
        );
}



VOID
NdisImmediateWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
/*++

Routine Description:

    This routine writes a buffer to shared ram.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to write to.

    Buffer - The buffer to write.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWriteSharedMemory: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWriteSharedMemory(
        WrapperConfigurationContext,
        SharedMemoryAddress,
        Buffer,
        Length,
        FALSE
        );
}

//1 Should we check for path?
VOID
NdisOpenFile(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            FileHandle,
    OUT PUINT                   FileLength,
    IN  PNDIS_STRING            FileName,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    )

/*++

Routine Description:

    This routine opens a file for future mapping and reads its contents
    into allocated memory.

Arguments:

    Status - The status of the operation

    FileHandle - A handle to be associated with this open

    FileLength - Returns the length of the file

    FileName - The name of the file

    HighestAcceptableAddress - The highest physical address at which
      the memory for the file can be allocated.

Return Value:

    None.

--*/
{
    NTSTATUS                NtStatus;
    IO_STATUS_BLOCK         IoStatus;
    HANDLE                  NtFileHandle;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    ULONG                   LengthOfFile;
#define PathPrefix      L"\\SystemRoot\\system32\\drivers\\"
    NDIS_STRING             FullFileName;
    PNDIS_FILE_DESCRIPTOR   FileDescriptor;
    PVOID                   FileImage;
    FILE_STANDARD_INFORMATION StandardInfo;

    UNREFERENCED_PARAMETER(HighestAcceptableAddress);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisOpenFile\n"));

    do
    {
        //
        // Insert the correct path prefix.
        //
        FullFileName.MaximumLength = sizeof(PathPrefix) + FileName->MaximumLength;
        FullFileName.Buffer = ALLOC_FROM_POOL(FullFileName.MaximumLength, NDIS_TAG_FILE_NAME);

        if (FullFileName.Buffer == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }
        FullFileName.Length = sizeof (PathPrefix) - sizeof(WCHAR);
        CopyMemory(FullFileName.Buffer, PathPrefix, sizeof(PathPrefix));
        RtlAppendUnicodeStringToString (&FullFileName, FileName);

        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("  Attempting to open %Z\n", &FullFileName));

        InitializeObjectAttributes(&ObjectAttributes,
                                   &FullFileName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        NtStatus = ZwCreateFile(&NtFileHandle,
                                SYNCHRONIZE | FILE_READ_DATA,
                                &ObjectAttributes,
                                &IoStatus,
                                NULL,
                                0,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,
                                0);

        FREE_POOL(FullFileName.Buffer);

        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Error opening file %x\n", NtStatus));
            *Status = NDIS_STATUS_FILE_NOT_FOUND;
            break;
        }

        //
        // Query the object to determine its length.
        //

        NtStatus = ZwQueryInformationFile(NtFileHandle,
                                          &IoStatus,
                                          &StandardInfo,
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);

        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Error querying info on file %x\n", NtStatus));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        LengthOfFile = StandardInfo.EndOfFile.LowPart;

        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
                ("File length is %d\n", LengthOfFile));

        //
        // Might be corrupted.
        //
        if (LengthOfFile < 1)
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Bad file length %d\n", LengthOfFile));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        //
        // Allocate buffer for this file
        //

        FileImage = ALLOC_FROM_POOL(LengthOfFile, NDIS_TAG_FILE_IMAGE);

        if (FileImage == NULL)
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Could not allocate buffer\n"));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        //
        // Read the file into our buffer.
        //

        NtStatus = ZwReadFile(NtFileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatus,
                              FileImage,
                              LengthOfFile,
                              NULL,
                              NULL);

        ZwClose(NtFileHandle);

        if ((!NT_SUCCESS(NtStatus)) || (IoStatus.Information != LengthOfFile))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("error reading file %x\n", NtStatus));
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            FREE_POOL(FileImage);
            break;
        }

        //
        // Allocate a structure to describe the file.
        //

        FileDescriptor = ALLOC_FROM_POOL(sizeof(NDIS_FILE_DESCRIPTOR), NDIS_TAG_FILE_DESCRIPTOR);

        if (FileDescriptor == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            FREE_POOL(FileImage);
            break;
        }

        FileDescriptor->Data = FileImage;
        INITIALIZE_SPIN_LOCK (&FileDescriptor->Lock);
        FileDescriptor->Mapped = FALSE;

        *FileHandle = (NDIS_HANDLE)FileDescriptor;
        *FileLength = LengthOfFile;
        *Status = STATUS_SUCCESS;
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisOpenFile, Status %.8x\n", *Status));
}


VOID
NdisCloseFile(
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:

    This routine closes a file previously opened with NdisOpenFile.
    The file is unmapped if needed and the memory is freed.

Arguments:

    FileHandle - The handle returned by NdisOpenFile

Return Value:

    None.

--*/
{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisCloseFile\n"));

    FREE_POOL(FileDescriptor->Data);
    FREE_POOL(FileDescriptor);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisCloseFile\n"));
}


VOID
NdisMapFile(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 MappedBuffer,
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:

    This routine maps an open file, so that the contents can be accessed.
    Files can only have one active mapping at any time.

Arguments:

    Status - The status of the operation

    MappedBuffer - Returns the virtual address of the mapping.

    FileHandle - The handle returned by NdisOpenFile.

Return Value:

    None.

--*/
{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMapFile\n"));

    if (FileDescriptor->Mapped == TRUE)
    {
        *Status = NDIS_STATUS_ALREADY_MAPPED;
    }
    else
    {
        FileDescriptor->Mapped = TRUE;
    
        *MappedBuffer = FileDescriptor->Data;
        *Status = STATUS_SUCCESS;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMapFile, Status %.8x \n", *Status));
}


VOID
NdisUnmapFile(
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:
    This routine unmaps a file previously mapped with NdisOpenFile.
    The file is unmapped if needed and the memory is freed.

Arguments:
    FileHandle - The handle returned by NdisOpenFile

Return Value:
    None.

--*/

{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisUnmapFile\n"));

    FileDescriptor->Mapped = FALSE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisUnmapFile\n"));
}


CCHAR
NdisSystemProcessorCount(
    VOID
    )
/*++

Routine Description:
    This function returns the number of processors in the machine

Arguments:
    None.
    
Return Value:
    NdisSystemProcessorCount returns the number of processors in the machine

Callers of NdisSystemProcessorCount can be running at IRQL == PASSIVE

--*/

{
    return KeNumberProcessors;
}


VOID
NdisGetSystemUpTime(
    OUT PULONG                  pSystemUpTime
    )
/*++

Routine Description:
    NdisGetSystemUpTime returns the number of milliseconds that have elapsed since the 
    system was booted.
    
Arguments:
   pSystemUpTime: Pointer to a caller-supplied variable in which this function returns the 
   system uptime.
    
Return Value:
    None.
    
Callers of NdisGetSystemUpTime can be running at any IRQL.

--*/
{
    LARGE_INTEGER TickCount;

    //
    // Get tick count and convert to hundreds of nanoseconds.
    //
    KeQueryTickCount(&TickCount);

    TickCount = RtlExtendedIntegerMultiply(TickCount, (LONG)ndisTimeIncrement);

    TickCount.QuadPart /= 10000;

    ASSERT(TickCount.HighPart == 0);

    *pSystemUpTime = TickCount.LowPart;
}

VOID
NdisGetCurrentProcessorCpuUsage(
    IN  PULONG                  pCpuUsage
    )
/*++

Routine Description:
    NdisGetCurrentProcessorCpuUsage returns how busy the current processor is as a percentage. 
    
Arguments:
    pCpuUsage: Pointer to a caller-supplied variable in which this function returns the percentage 
    of CPU, on which the caller is running, that is currently in use.    

Return Value:
    None.
    
Callers of NdisGetCurrentProcessorCpuUsage can be running at any IRQL.

--*/

{
    ExGetCurrentProcessorCpuUsage(pCpuUsage);
}

VOID
NdisGetCurrentProcessorCounts(
    OUT PULONG          pIdleCount,
    OUT PULONG          pKernelAndUser,
    OUT PULONG          pIndex
    )
/*++

Routine Description:
    NdisGetCurrentProcessorCounts returns counts for the current processor that a 
    driver can use to determine CPU utilization for a particular time interval.


Arguments:
    pIdleCount: Pointer to a caller-supplied variable in which this function 
    returns the cumulative idle time for the processor since the system was booted. 
    
    pKernelAndUser: Pointer to a caller-supplied variable in which this function 
    returns the cumulative processing time (kernel-mode time plus user-mode time) 
    for the processor since the system was booted. 
    
    pIndex: Pointer to a caller-supplied variable in which this function returns
    a zero-based index that identifies the processor within the machine

Return Value:
    None.

Callers of NdisGetCurrentProcessorCounts must be running at IRQL <= DISPATCH_LEVEL.

--*/
{
    ExGetCurrentProcessorCounts(pIdleCount, pKernelAndUser, pIndex);
}

VOID
NdisGetCurrentSystemTime(
    IN  PLARGE_INTEGER          pCurrentTime
    )
/*++

Routine Description:
    NdisGetCurrentSystemTime returns the current system time, 
    suitable for setting timestamps. 

Arguments:
    pSystemTime: Pointer to a caller-supplied variable in which this function returns 
    a count of 100-nanosecond intervals since January 1, 1601. 

Return Value:
    None.
    
Callers of NdisGetCurrentSystemTime can be running at any IRQL.

--*/
{
    KeQuerySystemTime(pCurrentTime);
}

//1 deprecated function
NDIS_STATUS
NdisQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(BusType);
    
    *MapRegisterCount = 0;
    return NDIS_STATUS_NOT_SUPPORTED;
}


//
// NDIS Event support
//

VOID
NdisInitializeEvent(
    IN  PNDIS_EVENT             Event
    )
/*++

Routine Description:
    NdisInitializeEvent sets up an event object during driver initialization to be 
    used subsequently as a synchronization mechanism. 

Arguments:
    Event: Pointer to caller-supplied storage for the event object, which is opaque to drivers.

Return Value:
    None.

Callers of NdisInitializeEvent run at IRQL = PASSIVE_LEVEL.

--*/
{
    INITIALIZE_EVENT(&Event->Event);
}

VOID
NdisSetEvent(
    IN  PNDIS_EVENT             Event
    )
/*++

Routine Description:
    NdisSetEvent sets a given event to the signaled state if it was not already Signaled.
    
Arguments:
    Event: Pointer to an initialized event object for which the caller provides the storage.

Return Value:
    None.

Callers of NdisSetEvent run at IRQL <= DISPATCH_LEVEL.

--*/
{
    SET_EVENT(&Event->Event);
}

VOID
NdisResetEvent(
    IN  PNDIS_EVENT             Event
    )
/*++

Routine Description:
    NdisResetEvent clears the Signaled state of a given event.
    
Arguments:
    Event: Pointer to an initialized event object for which the caller provided the storage. 

Return Value:
    None.
   
Callers of NdisResetEvent run at IRQL <= DISPATCH_LEVEL.

--*/
{
    RESET_EVENT(&Event->Event);
}

BOOLEAN
NdisWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    MsToWait
    )
/*++

Routine Description:
    NdisWaitEvent puts the caller into a wait state until the given event is set 
    to the Signaled state or the wait times out.
    
Arguments:
    Event: Pointer to an initialized event object for which the caller provides the storage. 
    
    MsToWait: Specifies the number of milliseconds the caller will wait if the event is not 
    set to the Signaled state within that interval. A value of zero specifies that the caller 
    will wait for the event indefinitely. 

Return Value:
    NdisWaitEvent returns TRUE if the event is in the Signaled state when the wait is satisfied.

Callers of NdisWaitEvent must be running at IRQL = PASSIVE_LEVEL.

--*/
{
    NTSTATUS    Status;
    TIME        Time, *pTime;

    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    
    pTime = NULL;
    if (MsToWait != 0)
    {
        Time.QuadPart = Int32x32To64(MsToWait, -10000);
        pTime = &Time;
    }

    Status = WAIT_FOR_OBJECT(&Event->Event, pTime);

    return(Status == NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
NdisScheduleWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem
    )
/*++

Routine Description:
    NdisScheduleWorkItem inserts a given work item into a queue from which
    a system worker thread removes the item and gives control to the callback 
    function that the driver previously supplied to NdisInitializeWorkItem.
    
Arguments:
    WorkItem: Pointer to the work item that was set up by a preceding call 
    to NdisInitializeWorkItem. 

Return Value:
    This function always return NDIS_STATUS_SUCCESS.

Callers of NdisScheduleWorkItem must be running at IRQL <= DISPATCH_LEVEL.
--*/
{
    INITIALIZE_WORK_ITEM((WORK_QUEUE_ITEM *)WorkItem->WrapperReserved,
                         ndisWorkItemHandler,
                         WorkItem);
    XQUEUE_WORK_ITEM((WORK_QUEUE_ITEM *)WorkItem->WrapperReserved, CriticalWorkQueue);

    return NDIS_STATUS_SUCCESS;
}

VOID
ndisWorkItemHandler(
    IN  PNDIS_WORK_ITEM         WorkItem
    )
/*++

Routine Description:
    ndisWorkItemHandler is the common callback routine for all the workitems 
    scheduled by a call to NdisScheduleWorkItem INITIALIZE_WORK_ITEM. 
    This routine will call the real callback function from the workitem.

Arguments:
    WorkItem: a pointer to workitem.

Return Value:
    None.

ndisWorkItemHandler is called at PASSIVE level.    
--*/
{
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    (*WorkItem->Routine)(WorkItem, WorkItem->Context);
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
}

//1 deprectae this function
VOID
NdisInitializeString(
    OUT PNDIS_STRING            Destination,
    IN PUCHAR                   Source
    )
/*++

Routine Description:
    NdisInitializeString allocates storage for and initializes a counted string 
    in the system-default character set. 
    
Arguments:
    DestinationString: Specifies NULL when NdisInitializeString is called; 
    on return from this function, points to an NDIS_STRING type that describes 
    an initialized counted string. For Windows 2000 and later, NDIS defines the 
    NDIS_STRING type as a UNICODE_STRING type. 
    
    SourceString: Pointer to a zero-terminated string with which to initialize 
    the counted string.
    
Return Value:
    None.
    
Callers of NdisInitializeString run at IRQL = PASSIVE_LEVEL.

--*/
{
    WCHAR   *strptr;

    //1 don't use strlen, set an upper limit on length
    Destination->Length = (USHORT)(strlen((CONST char *)Source) * sizeof(WCHAR));
    Destination->MaximumLength = Destination->Length + sizeof(WCHAR);
    Destination->Buffer = ALLOC_FROM_POOL(Destination->MaximumLength, NDIS_TAG_STRING);

    if (Destination->Buffer != NULL)
    {
        strptr = Destination->Buffer;
        //1 this loop should put a limit on how far it goes.
        while (*Source != '\0')
        {
            *strptr = (WCHAR)*Source;
            Source++;
            strptr++;
        }
        *strptr = UNICODE_NULL;
    }
}

VOID
NdisSetPacketStatus(
    IN          PNDIS_PACKET    Packet,
    IN          NDIS_STATUS     Status,
    IN          NDIS_HANDLE     Handle,
    IN          ULONG           Code
    )
/*++

Routine Description:
    NdisSetPacketStatus sets the Status value in the out-of-band data block associated with 
    a given packet descriptor just before a driver calls NdisMIndicateReceivePacket or 
    before a driver's MiniportSendPackets function returns control. 


Arguments:
    Packet: Pointer to a packet descriptor either allocated by the caller for a receive 
    indication or by a protocol for a send.
    
    Status: Specifies the status to be set.

Return Value:
    None.

Callers of NDIS_SET_PACKET_STATUS run at IRQL <= DISPATCH_LEVEL.

--*/
{
#ifdef TRACK_RECEIVED_PACKETS
    NDIS_STATUS     OldStatus =  NDIS_GET_PACKET_STATUS(Packet);

    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)Packet;
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)Handle;
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)PsGetCurrentThread();
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)((Status<<24)            |
                                                        ((OldStatus&0xff)<<16)  |
                                                        (Code&0xffff)
                                                        );
#else
    UNREFERENCED_PARAMETER(Handle);
    UNREFERENCED_PARAMETER(Code);
#endif

    NDIS_SET_PACKET_STATUS(Packet, Status);
   
}

VOID
NdisCopyFromPacketToPacketSafe(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied,
    IN  MM_PAGE_PRIORITY        Priority
    )

/*++

Routine Description:

    safe version of Copy from NdisCopyFromPacketToPacket

Arguments:

    Destination - The packet should be copied in to.

    DestinationOffset - The offset from the beginning of the packet
    into which the data should start being placed.

    BytesToCopy - The number of bytes to copy from the source packet.

    Source - The ndis packet from which to copy data.

    SourceOffset - The offset from the start of the packet from which
    to start copying data.

    BytesCopied - The number of bytes actually copied from the source
    packet.  This can be less than BytesToCopy if the source or destination
    packet is too short.
    
    Priority: Indicates the priority of the request.

Return Value:

    None

Callers of NdisCopyFromPacketToPacketSafe run at IRQL <= DISPATCH_LEVEL.

--*/

{

    //
    // Points to the buffer into which we are putting data.
    //
    PNDIS_BUFFER DestinationCurrentBuffer;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER SourceCurrentBuffer;

    //
    // Holds the virtual address of the current destination buffer.
    //
    PVOID DestinationVirtualAddress;

    //
    // Holds the virtual address of the current source buffer.
    //
    PVOID SourceVirtualAddress;

    //
    // Holds the length of the current destination buffer.
    //
    UINT DestinationCurrentLength;

    //
    // Holds the length of the current source buffer.
    //
    UINT SourceCurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer of the destination.
    //

    DestinationCurrentBuffer = Destination->Private.Head;
    if (DestinationCurrentBuffer == NULL)
        return;

    DestinationVirtualAddress = MmGetSystemAddressForMdlSafe(DestinationCurrentBuffer, Priority);
    if (DestinationVirtualAddress == NULL)
        return;
    
    DestinationCurrentLength = MmGetMdlByteCount(DestinationCurrentBuffer);

    //
    // Get the first buffer of the source.
    //

    SourceCurrentBuffer = Source->Private.Head;
    if (SourceCurrentBuffer == NULL)
        return;
    
    SourceVirtualAddress = MmGetSystemAddressForMdlSafe(SourceCurrentBuffer, Priority);
    if (SourceVirtualAddress == NULL)
        return;

    SourceCurrentLength = MmGetMdlByteCount(SourceCurrentBuffer);

    while (LocalBytesCopied < BytesToCopy)
    {
        //
        // Check to see whether we've exhausted the current destination
        // buffer.  If so, move onto the next one.
        //

        if (!DestinationCurrentLength)
        {
            DestinationCurrentBuffer = DestinationCurrentBuffer->Next;

            if (!DestinationCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;

            }

            DestinationVirtualAddress = MmGetSystemAddressForMdlSafe(DestinationCurrentBuffer, Priority);
            if (DestinationVirtualAddress == NULL)
                break;
            
            DestinationCurrentLength = MmGetMdlByteCount(DestinationCurrentBuffer);
            
            continue;
        }


        //
        // Check to see whether we've exhausted the current source
        // buffer.  If so, move onto the next one.
        //

        if (!SourceCurrentLength)
        {
            SourceCurrentBuffer = SourceCurrentBuffer->Next;

            if (!SourceCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;
            }
            
            SourceVirtualAddress = MmGetSystemAddressForMdlSafe(SourceCurrentBuffer, Priority);
            if (SourceVirtualAddress == NULL)
                break;

            SourceCurrentLength = MmGetMdlByteCount(SourceCurrentBuffer);
            
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (DestinationOffset)
        {
            if (DestinationOffset > DestinationCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                DestinationOffset -= DestinationCurrentLength;
                DestinationCurrentLength = 0;
                continue;
            }
            else
            {
                DestinationVirtualAddress = (PCHAR)DestinationVirtualAddress
                                            + DestinationOffset;
                DestinationCurrentLength -= DestinationOffset;
                DestinationOffset = 0;
            }
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (SourceOffset)
        {
            if (SourceOffset > SourceCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                SourceOffset -= SourceCurrentLength;
                SourceCurrentLength = 0;
                continue;
            }
            else
            {
                SourceVirtualAddress = (PCHAR)SourceVirtualAddress
                                            + SourceOffset;
                SourceCurrentLength -= SourceOffset;
                SourceOffset = 0;
            }
        }

        //
        // Copy the data.
        //

        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            //
            // Holds the amount desired remaining.
            //
            UINT Remaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = ((SourceCurrentLength <= DestinationCurrentLength) ?
                                            (SourceCurrentLength) : (DestinationCurrentLength));

            AmountToMove = ((Remaining < AmountToMove)?
                            (Remaining):(AmountToMove));

            CopyMemory(DestinationVirtualAddress, SourceVirtualAddress, AmountToMove);

            DestinationVirtualAddress =
                (PCHAR)DestinationVirtualAddress + AmountToMove;
            SourceVirtualAddress =
                (PCHAR)SourceVirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            SourceCurrentLength -= AmountToMove;
            DestinationCurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\wmi\wmitest.c ===
//
// WMITEST.C
//
// Test program for NDIS WMI interface
//
// usage: WMITEST
//
//

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>

#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include <ndisguid.h>
#include <wmium.h>

#ifndef NDIS_STATUS
#define NDIS_STATUS     ULONG
#endif

#if DBG
#define DEBUGP(stmt)    printf stmt
#else
#define DEBUGP(stmt)
#endif

#define PRINTF(stmt)    printf stmt

#define MAX_NDIS_DEVICE_NAME_LEN        256
#define MAX_ADAPTER_NAME_LENGTH         512

#define DEVICE_PREFIX L"\\Device\\"

LPGUID WmiEvent[] = {
    (LPGUID) &GUID_NDIS_STATUS_MEDIA_CONNECT,
    (LPGUID) &GUID_NDIS_STATUS_MEDIA_DISCONNECT,
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_OFF
};


PWCHAR
GetAdapterName(
    PWNODE_SINGLE_INSTANCE  Instance,
    PWCHAR                  AdapterName,
    BOOLEAN                 HaveLength
    );


DWORD
__inline
EnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    );

VOID
__inline
DeregisterWmiEventNotification(
    VOID
    );

DWORD
__inline
RegisterWmiEventNotification(
    VOID
    );

VOID
WINAPI
WmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    );


VOID __cdecl
main(
    INT         argc,
    CHAR        *argv[]
    )
{
    DWORD       ErrorCode;
    
    printf("testing NDIS wmi notifications. press 'q' to abort.\n");
    
    //
    // test wmi
    //
    if ((ErrorCode = RegisterWmiEventNotification()) != NO_ERROR)
    {
        printf("error %d calling RegisterWmiEventNotification.\n", ErrorCode);
        return;
    }
    while (_fgetchar() != 'q')
    {
        Sleep(1000);
    }
    DeregisterWmiEventNotification();

    return;
}


DWORD
__inline
EnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    )
{
    return WmiNotificationRegistrationW(
        EventGuid,                      // Event Type.
        Enable,                         // Enable or Disable.
        WmiEventNotification,           // Callback.
        0,                              // Context.
        NOTIFICATION_CALLBACK_DIRECT);  // Notification Flags.
}


VOID
__inline
DeregisterWmiEventNotification(
    VOID
    )
{
    int i;
    
    for (i = 0; i < (sizeof(WmiEvent) / sizeof(LPGUID)); i++) {
        (VOID) EnableWmiEvent(WmiEvent[i], FALSE);
    }
}


DWORD
__inline
RegisterWmiEventNotification(
    VOID
    )
{
    DWORD Error;
    int i;
    
    for (i = 0; i < (sizeof(WmiEvent) / sizeof(LPGUID)); i++) {
        Error = EnableWmiEvent(WmiEvent[i], TRUE);
        if (Error != NO_ERROR)
        {
            printf("failed enabling event for %lx\n", i);
        }
    }
    
    if (Error != NO_ERROR)
    {
        DeregisterWmiEventNotification();
    }
    
    return Error;

}


VOID
WINAPI
WmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    )
/*++

Routine Description:

    Process a WMI event (specifically adapter arrival or removal).
    
Arguments:

    Event - Supplies event specific information.

    Context - Supplies the context registered.
    
Return Value:

    None.
    
--*/ 
{
    PWNODE_SINGLE_INSTANCE Instance = (PWNODE_SINGLE_INSTANCE) Event;
    USHORT AdapterNameLength;
    WCHAR AdapterName[MAX_ADAPTER_NAME_LENGTH];
    PWCHAR AdapterGuid = NULL;
    USHORT AdapterInstanceNameLength;
    WCHAR AdapterInstanceName[MAX_ADAPTER_NAME_LENGTH];

    if (Instance == NULL)
    {
        return;
    }

    AdapterInstanceNameLength =
        *((PUSHORT) (((PUCHAR) Instance) + Instance->OffsetInstanceName));

    if ((AdapterInstanceNameLength / sizeof(WCHAR)) > (MAX_ADAPTER_NAME_LENGTH - 1))
    {
        return;
    }

    RtlCopyMemory(
        AdapterInstanceName,
        ((PUCHAR) Instance) + Instance->OffsetInstanceName + sizeof(USHORT),
        AdapterInstanceNameLength);
    
    AdapterInstanceName[AdapterInstanceNameLength / sizeof(WCHAR)] = L'\0';

    do 
    {
        if (memcmp(
            &(Event->Guid),
            &GUID_NDIS_STATUS_MEDIA_CONNECT,
            sizeof(GUID)) == 0) 
        {
            //
            // Media connect
            //
            printf("Media connect. %ws\n", AdapterInstanceName);
            break;            
        }
        if (memcmp(
            &(Event->Guid),
            &GUID_NDIS_STATUS_MEDIA_DISCONNECT,
            sizeof(GUID)) == 0) 
        {
            //
            // Media disconnect
            //
            printf("Media disconnect. %ws\n", AdapterInstanceName);
            break;            
        }
        if (memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
            sizeof(GUID)) == 0)
        {
            //
            // Adapter arrival.
            //
            AdapterGuid = GetAdapterName(Instance, AdapterName, TRUE);
            if (AdapterGuid)
                printf("Adapter arrival. %ws\n", AdapterGuid);
            break;            
        }

        if (memcmp(
            &(Event->Guid),
            &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
            sizeof(GUID)) == 0)
        {
            //
            // Adapter removal.
            //
            AdapterGuid = GetAdapterName(Instance, AdapterName, TRUE);
            if (AdapterGuid)
                printf("Adapter removal. %ws\n", AdapterGuid);
            break;
        }

        if (memcmp(
            &(Event->Guid),
            (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
            sizeof(GUID)) == 0)
        {
            //
            // Adapter powered on
            //
            printf("Adapter powered on. %ws\n", AdapterInstanceName );
            break;
        }

        if (memcmp(
            &(Event->Guid),
            (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
            sizeof(GUID)) == 0)
        {
            //
            // Adapter powered off
            //
            printf("Adapter powered off. %ws\n", AdapterInstanceName );
            
            break;
        }
    } while (FALSE);

}

PWCHAR
GetAdapterName(
    PWNODE_SINGLE_INSTANCE  Instance,
    PWCHAR                  AdapterName,
    BOOLEAN                 HaveLength
    )
{
    USHORT AdapterNameLength;
    PWCHAR AdapterGuid = NULL;
    PWCHAR Src;
    USHORT   i;

    do
    {
        if (HaveLength)
        {
            //
            //  WNODE_SINGLE_INSTANCE is organized thus...
            // +-----------------------------------------------------------+
            // |<--- DataBlockOffset --->| AdapterNameLength | AdapterName |
            // +-----------------------------------------------------------+
            //
            // AdapterName is defined as "\DEVICE\"AdapterGuid
            //
            AdapterNameLength =
                *((PUSHORT) (((PUCHAR) Instance) + Instance->DataBlockOffset));
            
            if (((AdapterNameLength / sizeof(WCHAR)) > (MAX_ADAPTER_NAME_LENGTH  - 1)) ||
                ((AdapterNameLength / sizeof(WCHAR)) < wcslen(DEVICE_PREFIX)))
            {
                break;
            }
            
            RtlCopyMemory(
                AdapterName,
                ((PUCHAR) Instance) + Instance->DataBlockOffset + sizeof(USHORT),
                AdapterNameLength);
            AdapterName[AdapterNameLength / sizeof(WCHAR)] = L'\0';
            AdapterGuid = AdapterName + wcslen(DEVICE_PREFIX);        
        }
        else
        {
            //
            //  WNODE_SINGLE_INSTANCE is NULL terminated
            // +-----------------------------------------------------------+
            // |<--- DataBlockOffset --->| AdapterName | L'\0'
            // +-----------------------------------------------------------+
            //
            // AdapterName is defined as "\DEVICE\"AdapterGuid
            //
            Src = (PWCHAR)((PUCHAR) Instance + Instance->DataBlockOffset);
        
            for (i = 0; i < MAX_ADAPTER_NAME_LENGTH - 1; i++)
            {
                if (Src[i] == L'\0')
                    break;
                AdapterName[i]= Src[i];                
            }
            
            AdapterName[i] = L'\0';
            AdapterNameLength = i * sizeof(WCHAR);

            if (AdapterNameLength > wcslen(DEVICE_PREFIX))
            {
                AdapterGuid = AdapterName + wcslen(DEVICE_PREFIX);        
            }
        }
        
    } while (FALSE);
    

    return AdapterGuid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\afilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    afilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers. It also provides routines for collecting fragmented packets and
    breaking up a packet into fragmented packets

Author:

    Alireza Dabagh  3-22-1993, (partially borrowed from EFILTER.C)


Revision History:

    Jameel Hyder (JameelH) Re-organization 01-Jun-95
--*/

#include <precomp.h>
#pragma hdrstop

#if ARCNET

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_AFILTER

//
//  Given an NDIS_PACKET this macro will tell us if it is
//  encapsulated ethernet.
//
#define ARC_PACKET_IS_ENCAPSULATED(_NSR) \
        ((_NSR)->Open->Flags & fMINIPORT_OPEN_USING_ETH_ENCAPSULATION)

//
// Defines for resource growth
//
#define ARC_BUFFER_SIZE 1024
#define ARC_BUFFER_ALLOCATION_UNIT 8
#define ARC_PACKET_ALLOCATION_UNIT 2


NDIS_STATUS
ArcAllocateBuffers(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine allocates Receive buffers for the filter database.

Arguments:

    Filter - The filter db to allocate for.

Returns:

    NDIS_STATUS_SUCCESS if any buffer was allocated.

--*/
{
    ULONG            i;
    PARC_BUFFER_LIST Buffer;
    PVOID            DataBuffer;
    NDIS_STATUS      Status = NDIS_STATUS_SUCCESS;

    for (i = ARC_BUFFER_ALLOCATION_UNIT; i != 0; i--)
    {
        Buffer = ALLOC_FROM_POOL(sizeof(ARC_BUFFER_LIST), NDIS_TAG_ARC_BUFFER);
        if (Buffer == NULL)
        {
            if (i == ARC_BUFFER_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }

        DataBuffer = ALLOC_FROM_POOL(ARC_BUFFER_SIZE, NDIS_TAG_ARC_DATA);

        if (DataBuffer == NULL)
        {
            FREE_POOL(Buffer);

            if (i == ARC_BUFFER_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            //
            // We allocated some packets, that is good enough for now
            //
            break;
        }

        Buffer->BytesLeft = Buffer->Size = ARC_BUFFER_SIZE;
        Buffer->Buffer = DataBuffer;
        Buffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer;
    }

    return Status;
}


NDIS_STATUS
ArcAllocatePackets(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine allocates Receive packets for the filter database.

Arguments:

    Filter - The filter db to allocate for.

Returns:

    NDIS_STATUS_SUCCESS if any packet was allocated.

--*/
{
    ULONG       i;
    PARC_PACKET Packet;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    for (i = ARC_PACKET_ALLOCATION_UNIT; i != 0; i--)
    {
        Packet = ALLOC_FROM_POOL(sizeof(ARC_PACKET), NDIS_TAG_ARC_PACKET);
        if (Packet == NULL)
        {
            if (i == ARC_PACKET_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }

        ZeroMemory(Packet, sizeof(ARC_PACKET));

        NdisReinitializePacket(&(Packet->TmpNdisPacket));

        Packet->Next = Filter->FreePackets;
        Filter->FreePackets = Packet;
    }

    return Status;
}


VOID
ArcDiscardPacketBuffers(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine description:

    This routine takes an arcnet packet that contains buffers of data and
    puts the buffers on the free list.

    NOTE: This assumes that LastBuffer points to the real last buffer
    in the chain.

Arguments:

    Filter - The filter to free the buffers to.

    Packet - The packet to free up.

Return values:

    None

--*/
{
    PARC_BUFFER_LIST Buffer;

    //
    // Reset Packet info
    //
    Packet->LastFrame = FALSE;
    Packet->TotalLength = 0;

    //
    // Reset buffer sizes
    //
    Buffer = Packet->FirstBuffer;
    while (Buffer != NULL)
    {
        Buffer->BytesLeft = Buffer->Size;
        Buffer = Buffer->Next;
    }

    //
    // Put buffers on free list
    //
    if (Packet->LastBuffer != NULL)
    {
        Packet->LastBuffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Packet->FirstBuffer;
        Packet->FirstBuffer = Packet->LastBuffer = NULL;
    }
}


VOID
ArcDestroyPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine description:

    This routine takes an arcnet packet and frees up the entire packet.

Arguments:

    Filter - Filter to free to.

    Packet - The packet to free up.

Return values:

    None

--*/
{
    PNDIS_BUFFER NdisBuffer, NextNdisBuffer;

    NdisQueryPacket(&Packet->TmpNdisPacket,
                    NULL,
                    NULL,
                    &NdisBuffer,
                    NULL);

    while (NdisBuffer != NULL)
    {
        NdisGetNextBuffer(NdisBuffer, &NextNdisBuffer);

        NdisFreeBuffer(NdisBuffer);

        NdisBuffer = NextNdisBuffer;
    }

    NdisReinitializePacket(&(Packet->TmpNdisPacket));

    ArcDiscardPacketBuffers(Filter, Packet);

    //
    // Now put packet on free list
    //
    Packet->Next = Filter->FreePackets;
    Filter->FreePackets = Packet;
}


BOOLEAN
ArcConvertToNdisPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet,
    IN  BOOLEAN                 ConvertWholePacket
    )
/*++

Routine description:

    This routine builds a corresponding NDIS_PACKET in TmpNdisPacket,
    that corresponds to the arcnet packet. The flag ConvertWholePacket
    is used to convert only part of the arcnet packet, or the whole
    stream. If the flag is FALSE, then only the buffers that have
    free space (starting with buffer LastBuffer on up) are converted.

    NOTE: It assumes TmpNdisPacket is an initialized ndis_packet structure.

Arguments:

    Filter - Filter to allocate from.

    Packet - The packet to convert.

    ConvertWholePacket - Convert the whole stream, or only part?

Return values:

    TRUE - If successful, else FALSE

--*/
{
    PNDIS_BUFFER NdisBuffer;
    PARC_BUFFER_LIST Buffer;
    NDIS_STATUS NdisStatus;

    UNREFERENCED_PARAMETER(ConvertWholePacket);
    
    Buffer = Packet->FirstBuffer;

    while (Buffer != NULL)
    {
        NdisAllocateBuffer(&NdisStatus,
                           &NdisBuffer,
                           Filter->ReceiveBufferPool,
                           Buffer->Buffer,
                           Buffer->Size - Buffer->BytesLeft);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            return(FALSE);
        }

        NdisChainBufferAtBack(&(Packet->TmpNdisPacket), NdisBuffer);

        Buffer = Buffer->Next;
    }

    return(TRUE);
}


VOID
ArcFilterDprIndicateReceive(
    IN  PARC_FILTER             Filter,             // Pointer to filter database
    IN  PUCHAR                  pRawHeader,         // Pointer to Arcnet frame header
    IN  PUCHAR                  pData,              // Pointer to data portion of Arcnet frame
    IN  UINT                    Length              // Data Length
    )
{
    ARC_PACKET_HEADER   NewFrameInfo;
    PARC_PACKET         Packet, PrevPacket;
    BOOLEAN             NewFrame, LastFrame;
    PARC_BUFFER_LIST    Buffer;
    UCHAR               TmpUchar;
    UINT                TmpLength;
    USHORT              TmpUshort;
    
    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        return;     
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

    //
    // Check for ethernet encapsulation first
    //
    TmpUchar = ((ARC_PROTOCOL_HEADER *)pRawHeader)->ProtId;

    if ( TmpUchar == 0xE8 )
    {
        if ((Length < (ARC_MAX_FRAME_SIZE + 4)) && (Length > 0))
        {
            //
            // Yes! Indicate it to the wrapper for indicating to all
            // protocols running ethernet on top of the arcnet miniport
            // driver.
            //
            ndisMArcIndicateEthEncapsulatedReceive(Filter->Miniport,// miniport.
                                                   pRawHeader,      // 878.2 header.
                                                   pData,           // ethernet header.
                                                   Length);         // length of ethernet frame.
            //
            // Ethernet header should be pData now
            // Length should be data now
            // We're done.
            //
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
        return;
    }

    // If the data portion is greater than 507 its a bad deal
    if ((Length > ARC_MAX_FRAME_SIZE + 3) || (Length == 0))
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
        return;
    }

    //
    // Get information from packet
    //
    NewFrameInfo.ProtHeader.SourceId[0] = *((PUCHAR)pRawHeader);
    NewFrameInfo.ProtHeader.DestId[0] = *((PUCHAR)pRawHeader + 1);

    NewFrameInfo.ProtHeader.ProtId = TmpUchar;

    //
    //  Read the split flag. If this is an exception packet (i.e.
    //  TmpUChar == 0xFF then we need to add an extra 3 onto
    //  pData to skip the series of 0xFF 0xFF 0xFF.
    //
    TmpUchar = *((PUCHAR)pData);

    if (TmpUchar == 0xFF)
    {
        pData += 4;
        Length -= 4;

        //
        //  Re-read the split flag.
        //
        TmpUchar = *((PUCHAR)pData);
    }

    //
    //  Save off the split flag.
    //
    NewFrameInfo.SplitFlag = TmpUchar;

    //
    //  Read the sequence number, which follows the split flag.
    //
    TmpUshort = 0;
    TmpUshort = *((PUCHAR)pData + 1);
    TmpUchar = *((PUCHAR)pData + 2);

    TmpUshort = TmpUshort | (TmpUchar << 8);
    NewFrameInfo.FrameSequence = TmpUshort;
    //
    //  Point pData at protocol data.
    //
    Length -= 3;            //... Length of protocol data.
    pData += 3;          //... Beginning of protocol data.
    // Length is decreased by SF + SEQ0 + SEQ 1 = 3

    //
    // NOTE: Length is now the Length of the data portion of this packet
    //
    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_INFO,
            ("ArcFilter: Frame received: SourceId= %#1x\nDestId=%#1x\nProtId=%#1x\nSplitFlag=%#1x\nFrameSeq=%d\n",
                (USHORT)NewFrameInfo.ProtHeader.SourceId[0],
                (USHORT)NewFrameInfo.ProtHeader.DestId[0],
                (USHORT)NewFrameInfo.ProtHeader.ProtId,
                (USHORT)NewFrameInfo.SplitFlag,
                NewFrameInfo.FrameSequence));
    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_INFO,
            ("ArcFilter: Data at address: %p, Length = %ld\n", pData, Length));

    NewFrame = TRUE;
    LastFrame = TRUE;

    PrevPacket = NULL;
    Packet = Filter->OutstandingPackets;

    //
    // Walk throgh all outstanding packet to see if this frame belongs to any one of them
    //

    while ( Packet != NULL )
    {
        if (Packet->Header.ProtHeader.SourceId[0] == NewFrameInfo.ProtHeader.SourceId[0])
        {
            //
            // A packet received from the same source, check packet Sequence number and throw away
            // outstanding packet if they don't match. We are allowed to do this since we know
            // all the frames belonging to one packet are sent before starting a new packet. We
            // HAVE to do this, because this is how we find out that a send at the other end, was aborted
            // after some of the frames were already sent and received here.
            //

            if((Packet->Header.FrameSequence == NewFrameInfo.FrameSequence) &&
               (Packet->Header.ProtHeader.DestId[0] == NewFrameInfo.ProtHeader.DestId[0]) &&
               (Packet->Header.ProtHeader.ProtId == NewFrameInfo.ProtHeader.ProtId))
            {
                //
                // We found a packet that this frame belongs to, check split flag
                //
                if (Packet->Header.FramesReceived * 2 == NewFrameInfo.SplitFlag)
                {
                    //
                    //  A packet found for this frame and SplitFlag is OK, check to see if it is
                    //  the last frame of the packet
                    //
                    NewFrame = FALSE;
                    LastFrame = (BOOLEAN)(NewFrameInfo.SplitFlag == Packet->Header.LastSplitFlag);
                }
                else
                {
                    //
                    // compare current split flag with the one from the last frame, if not equal
                    // the whole packet should be dropped.
                    //

                    if (Packet->Header.SplitFlag != NewFrameInfo.SplitFlag)
                    {
                        //
                        // Corrupted incomplete packet, get rid of it, but keep the new frame
                        // and we will re-use this Packet pointer.
                        //
                        ArcDiscardPacketBuffers(Filter, Packet);
                        break;
                    }
                    else
                    {
                        //
                        // We see to have received a duplicate frame. Ignore it.
                        //
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                        return;
                    }
                }
            }
            else
            {
                //
                // We received a frame from a source that already has an incomplete packet outstanding
                // But Frame Seq. or DestId or ProtId are not the same.
                // We have to discard the old packet and check the new frame for validity,
                // we will re-use this packet pointer below.
                //
                ArcDiscardPacketBuffers(Filter, Packet);
            }

            break;
        }
        else
        {
            PrevPacket = Packet;
            Packet = Packet->Next;
        }
    }

    if (NewFrame)
    {
        //
        // first frame of a packet, split flag must be odd or zero
        // NewFrame is already TRUE
        // LastFrame is already TRUE
        //
        if (NewFrameInfo.SplitFlag)
        {
            if (!(NewFrameInfo.SplitFlag & 0x01))
            {
                //
                // This frame is the middle of another split, but we
                // don't have it on file.  Drop the frame.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }

            //
            // First Frame of a multiple frame packet
            //
            NewFrameInfo.LastSplitFlag = NewFrameInfo.SplitFlag + 1;
            NewFrameInfo.FramesReceived = 1;
            LastFrame = FALSE;    // New packet and SplitFlag not zero
        }
        else
        {
            //
            // The frame is fully contained in this packet.
            //
        }

        //
        // allocate a new packet descriptor if it is a new packet
        //
        if (Packet == NULL)
        {
            if (Filter->FreePackets == NULL)
            {
                ArcAllocatePackets(Filter);

                if (Filter->FreePackets == NULL)
                {
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                    return;
                }
            }

            Packet = Filter->FreePackets;
            Filter->FreePackets = Packet->Next;

            if (!LastFrame)
            {
                //
                // Insert the packet in list of outstanding packets
                //
                Packet->Next = Filter->OutstandingPackets;
                Filter->OutstandingPackets = Packet;
            }
        }
        else
        {
            if (LastFrame)
            {
                //
                // remove it from the list
                //
                if (PrevPacket == NULL)
                {
                    Filter->OutstandingPackets = Packet->Next;
                }
                else
                {
                    PrevPacket->Next = Packet->Next;
                }
            }
        }

        Packet->Header = NewFrameInfo;
    }
    else
    {
        if (LastFrame)
        {
            //
            // Remove it from the queue
            //

            if (PrevPacket == NULL)
            {
                Filter->OutstandingPackets = Packet->Next;
            }
            else
            {
                PrevPacket->Next = Packet->Next;
            }
        }

        Packet->Header.FramesReceived++;

        //
        // keep track of last split flag to detect duplicate frames
        //
        Packet->Header.SplitFlag=NewFrameInfo.SplitFlag;
    }

    //
    // At this point we know Packet points to the packet to receive
    // the buffer into. If this is the LastFrame, then Packet will
    // have been removed from the OutstandingPackets list, otw it will
    // be in the list.
    //
    // Now get around to getting space for the buffer.
    //

    //
    // Find the last buffer in the packet
    //
    Buffer = Packet->LastBuffer;

    if (Buffer == NULL)
    {
        //
        // Allocate a new buffer to hold the packet
        //
        if (Filter->FreeBufferList == NULL)
        {
            if (ArcAllocateBuffers(Filter) != NDIS_STATUS_SUCCESS)
            {
                ArcDiscardPacketBuffers(Filter,Packet);
                //
                // Do not have to discard any packet that may have
                // been allocated above, as it will get discarded
                // the next time a packet comes in from that source.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }
        }

        Buffer = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer->Next;

        Packet->FirstBuffer = Packet->LastBuffer = Buffer;
        Buffer->Next = NULL;
    }

    // Copy the data off into the ARC_PACKET list.
    // If it doesn't fit within the current buffer, we'll need to
    // allocate more

    TmpLength = Length;

    while ( Buffer->BytesLeft < TmpLength )
    {
        //
        // Copy the data
        //

        NdisMoveFromMappedMemory((PUCHAR) Buffer->Buffer + (Buffer->Size - Buffer->BytesLeft),
                                 pData,
                                 Buffer->BytesLeft);

        pData += Buffer->BytesLeft;
        TmpLength -= Buffer->BytesLeft;
        Buffer->BytesLeft = 0;

        //
        // Need to allocate more
        //
        if (Filter->FreeBufferList == NULL)
        {
            if (ArcAllocateBuffers(Filter) != NDIS_STATUS_SUCCESS)
            {
                ArcDiscardPacketBuffers(Filter,Packet);
                //
                // Do not have to discard any packet that may have
                // been allocated above, as it will get discarded
                // the next time a packet comes in from that source.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }
        }

        Buffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Filter->FreeBufferList->Next;
        Buffer = Buffer->Next;
        Buffer->Next = NULL;

        Packet->LastBuffer->Next = Buffer;
        Packet->LastBuffer = Buffer;
    }

    //
    // Copy the last bit
    //

    NdisMoveFromMappedMemory((PUCHAR) Buffer->Buffer + (Buffer->Size - Buffer->BytesLeft),
                             pData,
                             TmpLength);


    Buffer->BytesLeft -= TmpLength;
    Packet->TotalLength += Length;

    //
    // And now we can start indicating the packet to the bindings that want it
    //
    if (LastFrame)
    {
        ArcFilterDoIndication(Filter, Packet);
        ArcDestroyPacket(Filter, Packet);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
}



BOOLEAN
ArcCreateFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UCHAR                   AdapterAddress,
    OUT PARC_FILTER *           Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the Arcnet filter database.

Arguments:

    Miniport - Pointer to the mini-port object.

    AdapterAddress - the address of the adapter associated with this filter
    database.

    Lock - Pointer to the lock that should be held when mutual exclusion
    is required.

    Filter - A pointer to an ARC_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PARC_FILTER LocalFilter;
    BOOLEAN     rc = TRUE;

    do
    {

        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(ARC_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter == NULL)
        {
            rc = FALSE;
            break;
        }
    
        ZeroMemory(LocalFilter, sizeof(ARC_FILTER));
    
        LocalFilter->Miniport = Miniport;
        LocalFilter->OpenList = NULL;
        LocalFilter->AdapterAddress = AdapterAddress;

        ArcReferencePackage();
    } while (FALSE);
    return rc;
}

//
// NOTE: THIS CANNOT BE PAGEABLE
//
VOID
ArcDeleteFilter(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an ARC_FILTER to be deleted.

Return Value:

    None.

--*/
{
    PARC_PACKET Packet;
    PARC_BUFFER_LIST Buffer;

    ASSERT(Filter->OpenList == NULL);


    //
    // Free all ARC_PACKETS
    //
    
    //
    // get rid of received partial packets
    //
    while (Filter->OutstandingPackets != NULL)
    {
        Packet = Filter->OutstandingPackets;
        Filter->OutstandingPackets = Packet->Next;

        //
        // This puts all the component parts on the free lists.
        //
        ArcDestroyPacket(Filter, Packet);
    }

    while (Filter->FreePackets != NULL)
    {
        Packet = Filter->FreePackets;
        Filter->FreePackets = Packet->Next;

        FREE_POOL(Packet);
    }

    while (Filter->FreeBufferList)
    {
        Buffer = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer->Next;

        FREE_POOL(Buffer->Buffer);
        FREE_POOL(Buffer);
    }

    FREE_POOL(Filter);

    ArcDereferencePackage();
}


BOOLEAN
ArcNoteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    )
/*++

Routine Description:

    This routine is used to add a new binding to the filter database.

    NOTE: THIS ROUTINE ASSUMES THAT THE DATABASE IS LOCKED WHEN
    IT IS CALLED.

Arguments:

    Filter - A pointer to the previously created and initialized filter
    database.

    NdisBindingHandle - a pointer to Ndis Open block

    NdisFilterHandle - A pointer to filter open.

Return Value:

    Will return false if creating a new filter index will cause the maximum
    number of filter indexes to be exceeded.

--*/
{
    PARC_BINDING_INFO LocalOpen;


    //
    // Get the first free binding slot and remove that slot from
    // the free list.  We check to see if the list is empty.
    //
    LocalOpen = ALLOC_FROM_POOL(sizeof(ARC_BINDING_INFO), NDIS_TAG_ARC_BINDING_INFO);
    if (LocalOpen == NULL)
    {
        return FALSE;
    }

    LocalOpen->NextOpen = Filter->OpenList;
    Filter->OpenList = LocalOpen;

    LocalOpen->References = 1;
    LocalOpen->NdisBindingHandle = NdisBindingHandle;
    LocalOpen->PacketFilters = 0;
    LocalOpen->ReceivedAPacket = FALSE;

    *NdisFilterHandle = (NDIS_HANDLE)LocalOpen;

    return TRUE;
}


NDIS_STATUS
ArcDeleteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    NdisRequest - If it is necessary to call the action routines,
    this will be passed to it.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    //
    // Holds the status returned from the packet filter and address
    // deletion routines.  Will be used to return the status to
    // the caller of this routine.
    //
    NDIS_STATUS StatusToReturn;

    //
    // Local variable.
    //
    PARC_BINDING_INFO LocalOpen = (PARC_BINDING_INFO)NdisFilterHandle;

    StatusToReturn = ArcFilterAdjust(Filter,
                                     NdisFilterHandle,
                                     NdisRequest,
                                     (UINT)0,
                                     FALSE);

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //

        if (--(LocalOpen->References) == 0)
        {
            PARC_BINDING_INFO   *ppBI;

            //
            // Remove it from the list.
            //

            for (ppBI = &Filter->OpenList;
                 *ppBI != NULL;
                 ppBI = &(*ppBI)->NextOpen)
            {
                if (*ppBI == LocalOpen)
                {
                    *ppBI = LocalOpen->NextOpen;
                    break;
                }
            }
            ASSERT(*ppBI == LocalOpen->NextOpen);

            //
            // First we finish any NdisIndicateReceiveComplete that
            // may be needed for this binding.
            //

            if (LocalOpen->ReceivedAPacket)
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
            }

            FREE_POOL(LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //

            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return StatusToReturn;
}


VOID
arcUndoFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  PARC_BINDING_INFO       Binding
    )
{
    Binding->PacketFilters = Binding->OldPacketFilters;
    Filter->CombinedPacketFilter = Filter->OldCombinedPacketFilter;
}



NDIS_STATUS
ArcFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The FilterAdjust routine will call an action routine when a
    particular filter class is changes from not being used by any
    binding to being used by at least one binding or vice versa.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the packet filters
    for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

    NdisRequest - If it is necessary to call the action routine,
    this will be passed to it.

    FilterClasses - The filter classes that are to be added or
    deleted.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    //
    // Contains the value of the combined filter classes before
    // it is adjusted.
    //
    UINT OldCombined = Filter->CombinedPacketFilter;

    PARC_BINDING_INFO LocalOpen = (PARC_BINDING_INFO)NdisFilterHandle;
    PARC_BINDING_INFO OpenList;

    UNREFERENCED_PARAMETER(NdisRequest);
    UNREFERENCED_PARAMETER(Set);
    
    //
    // Set the new filter information for the open.
    //
    LocalOpen->OldPacketFilters = LocalOpen->PacketFilters;
    LocalOpen->PacketFilters = FilterClasses;

    //
    // We always have to reform the compbined filter since
    // this filter index may have been the only filter index
    // to use a particular bit.
    //
    Filter->OldCombinedPacketFilter = Filter->CombinedPacketFilter;


    for (OpenList = Filter->OpenList, Filter->CombinedPacketFilter = 0;
         OpenList != NULL;
         OpenList = OpenList->NextOpen)
    {
        Filter->CombinedPacketFilter |= OpenList->PacketFilters;
    }

    return ((OldCombined != Filter->CombinedPacketFilter) ?
                                    NDIS_STATUS_PENDING : NDIS_STATUS_SUCCESS);
}



VOID
ArcFilterDoIndication(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine Description:

    This routine is called by the filter package only to indicate
    that a packet is ready to be indicated to procotols.

Arguments:

    Filter - Pointer to the filter database.

    Packet - Packet to indicate.

Return Value:

    None.

--*/
{

    //
    // Will hold the type of address that we know we've got.
    //
    UINT AddressType;

    NDIS_STATUS StatusOfReceive;

    //
    // Current Open to indicate to.
    //
    PARC_BINDING_INFO LocalOpen, NextOpen;

    if (Packet->Header.ProtHeader.DestId[0] != 0x00)
    {
        AddressType = NDIS_PACKET_TYPE_DIRECTED;
    }
    else
    {
        AddressType = NDIS_PACKET_TYPE_BROADCAST;
    }

    //
    // We need to acquire the filter exclusively while we're finding
    // bindings to indicate to.
    //

    if (!ArcConvertToNdisPacket(Filter, Packet, TRUE))
    {
        //
        // Out of resources, abort.
        //
        return;
    }

    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        //
        // Reference the open during indication.
        //
        if (LocalOpen->PacketFilters & AddressType)
        {
            LocalOpen->References++;

            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            //
            // Indicate the packet to the binding.
            //
            FilterIndicateReceive(&StatusOfReceive,
                                  LocalOpen->NdisBindingHandle,
                                  &Packet->TmpNdisPacket,
                                  &(Packet->Header.ProtHeader),
                                  3,
                                  Packet->FirstBuffer->Buffer,
                                  Packet->FirstBuffer->Size - Packet->FirstBuffer->BytesLeft,
                                  Packet->TotalLength);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            LocalOpen->ReceivedAPacket = TRUE;

            if ((--(LocalOpen->References)) == 0)
            {
                PARC_BINDING_INFO   *ppBI;

                //
                // This binding is shutting down.  We have to kill it.
                //

                //
                // Remove it from the list.
                //

                for (ppBI = &Filter->OpenList;
                     *ppBI != NULL;
                     ppBI = &(*ppBI)->NextOpen)
                {
                    if (*ppBI == LocalOpen)
                    {
                        *ppBI = LocalOpen->NextOpen;
                        break;
                    }
                }
                ASSERT(*ppBI == LocalOpen->NextOpen);

                //
                // Call the IndicateComplete routine.
                //


                if (LocalOpen->ReceivedAPacket)
                {
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

                    FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                }

                //
                // Call the macs action routine so that they know we
                // are no longer referencing this open binding.
                //
                ndisMDereferenceOpen((PNDIS_OPEN_BLOCK)LocalOpen->NdisBindingHandle);

                FREE_POOL(LocalOpen);
            }   // end of if binding is shutting down

        }       // end of if any binding wants the packet
    }   // end of there are more open bindings
}


VOID
ArcFilterDprIndicateReceiveComplete(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine is called by to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{

    PARC_BINDING_INFO LocalOpen, NextOpen;

    //
    // We need to acquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

    for (LocalOpen = Filter->OpenList; LocalOpen != NULL; LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //

            LocalOpen->ReceivedAPacket = FALSE;

            LocalOpen->References++;

            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            if ((--(LocalOpen->References)) == 0)
            {
                PARC_BINDING_INFO   *ppBI;

                //
                // This binding is shutting down.  We have to kill it.
                //

                //
                // Remove it from the list.
                //

                for (ppBI = &Filter->OpenList;
                     *ppBI != NULL;
                     ppBI = &(*ppBI)->NextOpen)
                {
                    if (*ppBI == LocalOpen)
                    {
                        *ppBI = LocalOpen->NextOpen;
                        break;
                    }
                }
                ASSERT(*ppBI == LocalOpen->NextOpen);

                //
                // Call the macs action routine so that they know we
                // are no longer referencing this open binding.
                //
                ndisMDereferenceOpen((PNDIS_OPEN_BLOCK)LocalOpen->NdisBindingHandle);

                FREE_POOL(LocalOpen);
            }
        }
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
}


NDIS_STATUS
ArcConvertOidListToEthernet(
    IN  PNDIS_OID               OidList,
    IN  PULONG                  NumberOfOids
    )
/*++

Routine Description:

    This routine converts an arcnet supported OID list into
    an ethernet OID list by replacing or removing arcnet
    OID's.

Arguments:

Return Value:

    None.

--*/

{
    ULONG       c;
    ULONG       cArcOids;
    NDIS_OID    EthernetOidList[ARC_NUMBER_OF_EXTRA_OIDS] = {
                    OID_802_3_MULTICAST_LIST,
                    OID_802_3_MAXIMUM_LIST_SIZE
                };

    //
    // Now we need to copy the returned results into the callers buffer,
    // removing arcnet OID's and adding in ethernet OID's. At this point
    // we do not know if the callers buffer is big enough since we may
    // remove some entries, checking it up front may not yield correct
    // results (i.e. it may actually be big enough).
    //
    for (c = 0, cArcOids = 0; c < *NumberOfOids; c++)
    {
        switch (OidList[c])
        {
            case OID_ARCNET_PERMANENT_ADDRESS:
                OidList[cArcOids++] = OID_802_3_PERMANENT_ADDRESS;
                break;

            case OID_ARCNET_CURRENT_ADDRESS:
                OidList[cArcOids++] = OID_802_3_CURRENT_ADDRESS;
                break;

            case OID_ARCNET_RECONFIGURATIONS:
                break;

            default:
                if ((OidList[c] & 0xFFF00000) != 0x06000000)
                    OidList[cArcOids++] = OidList[c];
                break;
        }
    }

    //
    //  Add the ethernet OIDs.
    //
    CopyMemory((PUCHAR)OidList + (cArcOids * sizeof(NDIS_OID)),
               EthernetOidList,
               ARC_NUMBER_OF_EXTRA_OIDS * sizeof(NDIS_OID));

    //
    //  Update the size of the buffer to send back to the caller.
    //
    *NumberOfOids = cArcOids + ARC_NUMBER_OF_EXTRA_OIDS;

    return(NDIS_STATUS_SUCCESS);
}

VOID
ndisMArcIndicateEthEncapsulatedReceive(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PVOID                   HeaderBuffer,
    IN  PVOID                   DataBuffer,
    IN  UINT                    Length
    )
/*++

    HeaderBuffer - This is the 878.2 header.
    DataBuffer  - This is the 802.3 header.
    Length   - This is the length of the ethernet frame.

--*/
{
    ULONG_PTR   MacReceiveContext[2];

    UNREFERENCED_PARAMETER(HeaderBuffer);
    
    //
    //  Indicate the packet.
    //

    MacReceiveContext[0] = (ULONG_PTR) DataBuffer;
    MacReceiveContext[1] = Length;

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
    if (Length > 14)
    {
        ULONG   PacketLength = 0;
        PUCHAR  Header = DataBuffer;

        PacketLength = (ULONG)(((USHORT)Header[12] << 8) | (USHORT)Header[13]);

        NdisMEthIndicateReceive((NDIS_HANDLE)Miniport,          // miniport handle.
                                (NDIS_HANDLE)MacReceiveContext, // receive context.
                                DataBuffer,                     // ethernet header.
                                14,                             // ethernet header length.
                                (PUCHAR)DataBuffer + 14,        // ethernet data.
                                PacketLength,                   // ethernet data length.
                                PacketLength);                  // ethernet data length.
    }
    else
    {
        NdisMEthIndicateReceive((NDIS_HANDLE)Miniport,          // miniport handle.
                                (NDIS_HANDLE)MacReceiveContext, // receive context.
                                DataBuffer,                     // ethernet header.
                                Length,                         // ethernet header length.
                                NULL,                           // ethernet data.
                                0,                              // ethernet data length.
                                0);                             // ethernet data length.
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
}

NDIS_STATUS
ndisMArcTransferData(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN  OUT PNDIS_PACKET        DstPacket,
    OUT PUINT                   BytesTransferred
    )
/*++

Routine Description:

    This routine handles the transfer data calls to arcnet mini-port.

Arguments:

    NdisBindingHandle - Pointer to open block.

    MacReceiveContext - Context given for the indication

    ByteOffset - Offset to start transfer at.

    BytesToTransfer - Number of bytes to transfer

    Packet - Packet to transfer into

    BytesTransferred - the number of actual bytes copied

Return values:

    NDIS_STATUS_SUCCESS, if successful, else NDIS_STATUS_FAILURE.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        MiniportOpen;
    PNDIS_PACKET            SrcPacket;
    PNDIS_BUFFER            NdisBuffer;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    NDIS_PACKET             TempPacket;
    KIRQL                   OldIrql;

    MiniportOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport     = MiniportOpen->MiniportHandle;
    NdisBuffer  = NULL;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  If this is encapsulated ethernet then we don't currently
    //  have the source packet from which to copy from.
    //

    if (MINIPORT_TEST_FLAG(MiniportOpen, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        //
        //  If this is not loopback then we need to create a
        //  temp NDIS_PACKET for the packet-to-packet copy.
        //
        if (INDICATED_PACKET(Miniport) == NULL)
        {
            PUCHAR  DataBuffer = (PUCHAR)((PULONG_PTR) MacReceiveContext)[0];
            UINT    DataLength = (UINT)((PULONG_PTR) MacReceiveContext)[1];

            //
            //  We'll always be in the scope of this function so we
            //  can use local stack space rather than allocating dynamic
            //  memory.
            //
            SrcPacket = &TempPacket;    // Use the local stack for packet store.

            ZeroMemory(SrcPacket, sizeof(NDIS_PACKET));

            NdisAllocateBuffer(&Status,     // Status code.
                               &NdisBuffer, // NDIS buffer to chain onto the packet.
                               NULL,        // On NT, this parameter is ignored.
                               DataBuffer,  // The ethernet frame.
                               DataLength); // The ethernet frame length.

            if (Status == NDIS_STATUS_SUCCESS)
            {
                NdisChainBufferAtFront(SrcPacket, NdisBuffer);
            }
        }
        else
        {
            SrcPacket = INDICATED_PACKET(Miniport);

            ByteOffset += 3;        // Skip fake arcnet header.
        }

        //
        // Skip the ethernet header.
        //

        ByteOffset += 14;
    }
    else
    {
        SrcPacket = (PNDIS_PACKET) MacReceiveContext;
    }

    //
    // Now we can simply copy from the source packet to the
    // destination packet.
    //
    NdisCopyFromPacketToPacket(DstPacket,       // destination packet.
                               0,               // destination offset.
                               BytesToTransfer, // bytes to copy.
                               SrcPacket,       // source packet.
                               ByteOffset,      // source offset.
                               BytesTransferred);// bytes copied.

    //
    //  If we allocated an NDIS_BUFFER then we need to free it. We don't
    //  need to unchain the buffer from the packet since the packet is
    //  a local stack variable the will just get trashed anyway.
    //

    if (NdisBuffer != NULL)
    {
        NdisFreeBuffer(NdisBuffer);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}

NDIS_STATUS
ndisMBuildArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_BUFFER        TmpBuffer;
    UINT                i, Flags;
    PUCHAR              Address;
    PARC_BUFFER_LIST    Buffer;
    PNDIS_BUFFER        NdisBuffer;
    NDIS_STATUS         Status;

    //
    //  Only ethernet encapsulation needs this.
    //
    if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        return(NDIS_STATUS_SUCCESS);
    }

    if (Miniport->ArcBuf->NumFree == 0)
    {
        //
        // Set flag
        //
        CLEAR_RESOURCE(Miniport, 'S');

        return(NDIS_STATUS_PENDING);
    }

    NdisQueryPacket(Packet, NULL, NULL, &TmpBuffer, NULL);
    NdisQueryBuffer(TmpBuffer, &Address, &Flags);

    for (i = 0, Buffer = &Miniport->ArcBuf->ArcnetBuffers[0];
         i < ARC_SEND_BUFFERS;
         Buffer++, i++)
    {
        if (Buffer->Next == NULL)
        {
            Buffer->Next = (PARC_BUFFER_LIST)-1;
            Miniport->ArcBuf->NumFree --;
            break;
        }
    }
    ASSERT(i < ARC_SEND_BUFFERS);

    NdisAllocateBuffer(&Status,
                       &NdisBuffer,
                       Miniport->ArcBuf->ArcnetBufferPool,
                       Buffer->Buffer,
                       3);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        CLEAR_RESOURCE(Miniport, 'S');

        return(NDIS_STATUS_PENDING);
    }

    NdisChainBufferAtFront(Packet, NdisBuffer);

    ((PUCHAR)Buffer->Buffer)[0] = Miniport->ArcnetAddress;

    if (Address[0] & 0x01)
    {
        //
        // Broadcast
        //
        ((PUCHAR)Buffer->Buffer)[1] = 0x00;
    }
    else
    {
        ((PUCHAR)Buffer->Buffer)[1] = Address[5];
    }

    ((PUCHAR) Buffer->Buffer)[2] = 0xE8;

    Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_CONTAINS_ARCNET_HEADER;

    return(NDIS_STATUS_SUCCESS);
}

VOID
ndisMFreeArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet,
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    This function strips off the arcnet header appended to
    ethernet encapsulated packets

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Packet - Ndis packet.


    None.

--*/
{
    PARC_BUFFER_LIST        Buffer;
    PNDIS_BUFFER            NdisBuffer = NULL;
    PVOID                   BufferVa;
    UINT                    i, Length;

    if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION) &&
        (NdisGetPacketFlags(Packet) & NDIS_FLAGS_CONTAINS_ARCNET_HEADER))
    {
        NdisUnchainBufferAtFront(Packet, &NdisBuffer);

        if (NdisBuffer != NULL)
        {
            NdisQueryBuffer(NdisBuffer, (PVOID *)&BufferVa, &Length);

            NdisFreeBuffer(NdisBuffer);

            for (i = 0, Buffer = &Miniport->ArcBuf->ArcnetBuffers[0];
                 i < ARC_SEND_BUFFERS;
                 Buffer++, i++)
            {
                if (Buffer->Buffer == BufferVa)
                {
                    Buffer->Next = NULL;
                    Miniport->ArcBuf->NumFree ++;
                    break;
                }
            }
        }
        
        NdisClearPacketFlags(Packet, NDIS_FLAGS_CONTAINS_ARCNET_HEADER);
    }
}

BOOLEAN
FASTCALL
ndisMArcnetSendLoopback(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

    Routine Description:
    
        Checks if a packet needs to be loopbacked and does so if necessary.
        
        NOTE: Must be called at DPC_LEVEL with lock HELD!
    
    Arguments:
    
        Miniport    -   Miniport to send to.
        Packet      -   Packet to loopback.
    
    Return Value:
    
        FALSE if the packet should be sent on the net, TRUE if it is
        a self-directed packet.

--*/
{
    BOOLEAN                 Loopback;
    BOOLEAN                 SelfDirected;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_BUFFER            FirstBuffer, NewBuffer;
    PNDIS_PACKET            pNewPacket = NULL;
    UINT                    BufferLength = 0;
    PUCHAR                  BufferAddress;
    UINT                    Length;
    UINT                    BytesToCopy;
    UINT                    Offset;
    PVOID                   PacketMemToFree = NULL;


    // We should not be here if the driver handles loopback
    ASSERT(Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK);
    ASSERT(MINIPORT_AT_DPC_LEVEL);
    ASSERT(NdisMediumArcnet878_2 == Miniport->MediaType);

    FirstBuffer = Packet->Private.Head;
    BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);
    if (BufferAddress == NULL)
    {
        return(FALSE);      // Can't determine if it is a loopback packet
    }

    //
    //  Is this an ethernet encapsulated packet?
    //
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    if (ARC_PACKET_IS_ENCAPSULATED(NSR))
    {
        //
        // The second buffer in the packet is the ethernet
        // header so we need to get that one before we can
        // proceed.
        //
        NdisGetNextBuffer(FirstBuffer, &FirstBuffer);

        BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);

        if (BufferAddress == NULL)
        {
            return(FALSE);      // Can't determine if it is a loopback packet
        }

        //
        // Now we can continue as though this were ethernet.
        //
        EthShouldAddressLoopBackMacro(Miniport->EthDB,
                                      BufferAddress,
                                      &Loopback,
                                      &SelfDirected);
    }
    else
    {
        Loopback = ((BufferAddress[0] == BufferAddress[1]) ||
                   ((BufferAddress[1] == 0x00) &&
                   (ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB) |
                   NDIS_PACKET_TYPE_BROADCAST)));
    
        if (BufferAddress[0] == BufferAddress[1])
        {
            SelfDirected = TRUE;
            Loopback = TRUE;
        }
        else
        {
            SelfDirected = FALSE;
        }
    }

    //
    //  If it's not a loopback packet then get out of here!
    //  
    if (!Loopback)
    {
        ASSERT(!SelfDirected);
        return(FALSE);
    }

    //
    // Get the buffer length
    //
    NdisQueryPacket(Packet, NULL, NULL, NULL, &Length);

    //
    // See if we need to copy the data from the packet
    // into the loopback buffer.
    //
    // We need to copy to the local loopback buffer if
    // the first buffer of the packet is less than the
    // minimum loopback size AND the first buffer isn't
    // the total packet. We always need to copy in case of encapsulation
    //
    if (ARC_PACKET_IS_ENCAPSULATED(NSR))
    {
        PNDIS_STACK_RESERVED NewPacketNSR;
        NDIS_STATUS Status;
        UINT    PktSize;
        ULONG   j;


        //
        //  If the packet is encapsulated ethernet then don't count the
        //  arcnet header in with the length.
        //
        Length -= ARC_PROTOCOL_HEADER_SIZE;

        //
        //  Skip the fake arcnet header.
        //
        Offset = ARC_PROTOCOL_HEADER_SIZE;
        
        PktSize = NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET);


        //
        //  Allocate a buffer for the packet.
        //
        pNewPacket = (PNDIS_PACKET)ALLOC_FROM_POOL(Length + PktSize, NDIS_TAG_LOOP_PKT);
        PacketMemToFree = (PVOID)pNewPacket;
        
        if (NULL == pNewPacket)
        {
            return(FALSE);
        }
    
        ZeroMemory(pNewPacket, PktSize);
        BufferAddress = (PUCHAR)pNewPacket + PktSize;
        pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket + SIZE_PACKET_STACKS);

        for (j = 0; j < ndisPacketStackSize; j++)
        {
            CURR_STACK_LOCATION(pNewPacket) = j;
            NDIS_STACK_RESERVED_FROM_PACKET(pNewPacket, &NewPacketNSR);
            INITIALIZE_SPIN_LOCK(&NewPacketNSR->Lock);
        }

        CURR_STACK_LOCATION(pNewPacket) = (UINT)-1;
        
        //
        //  Allocate an MDL for the packet.
        //
        NdisAllocateBuffer(&Status, &NewBuffer, NULL, BufferAddress, Length);
        if (NDIS_STATUS_SUCCESS != Status)
        {    
            FREE_POOL(PacketMemToFree);
            return(FALSE);
        }
    
        //
        //  NdisChainBufferAtFront()
        //
        pNewPacket->Private.Head = NewBuffer;
        pNewPacket->Private.Tail = NewBuffer;
        pNewPacket->Private.Pool = (PVOID)'pooL';
        pNewPacket->Private.NdisPacketOobOffset = (USHORT)(PktSize - (SIZE_PACKET_STACKS +
                                                                      sizeof(NDIS_PACKET_OOB_DATA) +
                                                                      sizeof(NDIS_PACKET_EXTENSION)));
                                                                      
        NDIS_SET_ORIGINAL_PACKET(pNewPacket, pNewPacket);
                                                                      
        ndisMCopyFromPacketToBuffer(Packet,     // Packet to copy from.
                                    Offset,     // Offset from beginning of packet.
                                    Length,     // Number of bytes to copy.
                                    BufferAddress,// The destination buffer.
                                    &BufferLength);
    
        MINIPORT_SET_PACKET_FLAG(pNewPacket, fPACKET_IS_LOOPBACK);
        pNewPacket->Private.Flags = NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK;
        pNewPacket->Private.Flags |= NDIS_FLAGS_IS_LOOPBACK_PACKET;
    }
    else if ((BufferLength < NDIS_M_MAX_LOOKAHEAD) && (BufferLength != Length))
    {
        //
        //  Copy the arcnet header.
        //
        BufferLength = MDL_SIZE(FirstBuffer);
        BytesToCopy = ARC_PROTOCOL_HEADER_SIZE;

        //
        //  Don't skip anything.
        //
        Offset = 0;

        BufferAddress = Miniport->ArcBuf->ArcnetLookaheadBuffer;
        BytesToCopy += Miniport->CurrentLookahead;

        ndisMCopyFromPacketToBuffer(Packet,             // Packet to copy from.
                                    Offset,             // Offset from beginning of packet.
                                    BytesToCopy,        // Number of bytes to copy.
                                    BufferAddress,      // The destination buffer.
                                    &BufferLength);     // The number of bytes copied.
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    //
    // Indicate the packet to every open binding
    // that could want it.
    //
    if (ARC_PACKET_IS_ENCAPSULATED(NSR) && pNewPacket)
    {
        NDIS_SET_PACKET_HEADER_SIZE(pNewPacket, 14);
        ethFilterDprIndicateReceivePacket(Miniport,
                                          &pNewPacket,
                                          1);
        NdisFreeBuffer(pNewPacket->Private.Head);
        FREE_POOL(PacketMemToFree);
    }
    else
    {
        PUCHAR  PlaceInBuffer;
        PUCHAR  ArcDataBuffer;
        UINT    ArcDataLength;
        UINT    PacketDataOffset;
        UCHAR   FrameCount;
        UCHAR   i;
        UINT    IndicateDataLength;

        //
        // Calculate how many frames we will need.
        //
        ArcDataLength = Length - ARC_PROTOCOL_HEADER_SIZE;
        PacketDataOffset = ARC_PROTOCOL_HEADER_SIZE;

        FrameCount = (UCHAR)(ArcDataLength / ARC_MAX_FRAME_SIZE);

        if ((ArcDataLength % ARC_MAX_FRAME_SIZE) != 0)
        {
            FrameCount++;
        }

        for (i = 0; i < FrameCount; ++i)
        {
            PlaceInBuffer = Miniport->ArcBuf->ArcnetLookaheadBuffer;

            //
            // Point data buffer to start of 'data'
            // Don't include system code as part of data
            //
            ArcDataBuffer = Miniport->ArcBuf->ArcnetLookaheadBuffer + ARC_PROTOCOL_HEADER_SIZE;

            //
            // Copy Header (SrcId/DestId/ProtId)
            //
            ndisMCopyFromPacketToBuffer(Packet,
                                        0,
                                        ARC_PROTOCOL_HEADER_SIZE,
                                        PlaceInBuffer,
                                        &BufferLength);

            PlaceInBuffer += ARC_PROTOCOL_HEADER_SIZE;

            //
            // Put in split flag
            //
            if (FrameCount > 1)
            {
                //
                // Multi-frame indication...
                //
                if ( i == 0 )
                {
                    //
                    // first frame
                    //

                    // *PlaceInBuffer = ( (FrameCount - 2) * 2 ) + 1;

                    *PlaceInBuffer = 2 * FrameCount - 3;
                }
                else
                {
                    //
                    // Subsequent frame
                    //
                    *PlaceInBuffer = ( i * 2 );
                }
            }
            else
            {
                //
                // Only frame in the indication
                //
                *PlaceInBuffer = 0;
            }

            //
            // Skip split flag
            //
            PlaceInBuffer++;

            //
            // Put in packet number.
            //
            *PlaceInBuffer++ = 0;
            *PlaceInBuffer++ = 0;

            //
            // Copy data
            //
            if (ArcDataLength > ARC_MAX_FRAME_SIZE)
            {
                IndicateDataLength = ARC_MAX_FRAME_SIZE;
            }
            else
            {
                IndicateDataLength = ArcDataLength;
            }

            ndisMCopyFromPacketToBuffer(Packet,
                                        PacketDataOffset,
                                        IndicateDataLength,
                                        PlaceInBuffer,
                                        &BufferLength);

            //
            //  Indicate the actual data length which should not
            //  include the system code.
            //
            ArcFilterDprIndicateReceive(Miniport->ArcDB,
                                        Miniport->ArcBuf->ArcnetLookaheadBuffer,
                                        ArcDataBuffer,
                                        IndicateDataLength + ARC_PROTOCOL_HEADER_SIZE);

            ArcDataLength -= ARC_MAX_FRAME_SIZE;
            PacketDataOffset += ARC_MAX_FRAME_SIZE;
        }

        ArcFilterDprIndicateReceiveComplete(Miniport->ArcDB);
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    return(SelfDirected);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\config.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    config.c

Abstract:

    NDIS wrapper functions for full mac drivers configuration/initialization

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder        (JameelH) 01-Jun-95 Re-organization/optimization

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_CONFIG

//
// Requests Used by MAC Drivers
//
//

VOID
NdisInitializeWrapper(
    OUT PNDIS_HANDLE            NdisWrapperHandle,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    Called at the beginning of every MAC's initialization routine.

Arguments:

    NdisWrapperHandle - A MAC specific handle for the wrapper.

    SystemSpecific1, a pointer to the driver object for the MAC.
    SystemSpecific2, a PUNICODE_STRING containing the location of
                     the registry subtree for this driver.
    SystemSpecific3, unused on NT.

Return Value:

    None.

--*/
{
    PNDIS_WRAPPER_HANDLE    WrapperHandle;
    ULONG                   cbSize;

    UNREFERENCED_PARAMETER (SystemSpecific3);

#if TRACK_UNLOAD
    DbgPrint("NdisInitializeWrapper: DriverObject %p\n",SystemSpecific1);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisInitializeWrapper\n"));

    *NdisWrapperHandle = NULL;
    cbSize = sizeof(NDIS_WRAPPER_HANDLE) + ((PUNICODE_STRING)SystemSpecific2)->Length + sizeof(WCHAR);

    WrapperHandle = (PNDIS_WRAPPER_HANDLE)ALLOC_FROM_POOL(cbSize, NDIS_TAG_WRAPPER_HANDLE);

    if (WrapperHandle != NULL)
    {
        *NdisWrapperHandle = WrapperHandle;
        NdisZeroMemory(WrapperHandle, cbSize);
        WrapperHandle->DriverObject = (PDRIVER_OBJECT)SystemSpecific1;
        WrapperHandle->ServiceRegPath.Buffer = (PWSTR)((PUCHAR)WrapperHandle + sizeof(NDIS_WRAPPER_HANDLE));
        WrapperHandle->ServiceRegPath.Length = ((PUNICODE_STRING)SystemSpecific2)->Length;
        WrapperHandle->ServiceRegPath.MaximumLength = WrapperHandle->ServiceRegPath.Length + sizeof(WCHAR);
        NdisMoveMemory(WrapperHandle->ServiceRegPath.Buffer,
                       ((PUNICODE_STRING)SystemSpecific2)->Buffer,
                       WrapperHandle->ServiceRegPath.Length);
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisInitializeWrapper\n"));
}


VOID
NdisTerminateWrapper(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PVOID                   SystemSpecific
    )
/*++

Routine Description:

    Called at the end of every MAC's termination routine.

Arguments:

    NdisWrapperHandle - The handle returned from NdisInitializeWrapper.

    SystemSpecific - No defined value.

Return Value:

    None.

--*/
{
    PNDIS_WRAPPER_HANDLE    WrapperHandle = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;


#if TRACK_UNLOAD
    DbgPrint("NdisTerminateWrapper: WrapperHandle %p\n",WrapperHandle);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisTerminateWrapper: NdisWrapperHandle %p\n", NdisWrapperHandle));

    UNREFERENCED_PARAMETER(SystemSpecific);

    if ((WrapperHandle != NULL) && (WrapperHandle->DriverObject != NULL))
    {
#if TRACK_UNLOAD
        DbgPrint("NdisTerminateWrapper: DriverObject %p\n",WrapperHandle->DriverObject);
#endif      
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(WrapperHandle->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
        if (MiniBlock != NULL)
        {
#if TRACK_UNLOAD
            DbgPrint("NdisTerminateWrapper: MiniBlock %p\n",MiniBlock);
#endif
            MiniBlock->Flags |= fMINIBLOCK_RECEIVED_TERMINATE_WRAPPER;
            //
            //  Miniports should not be terminating the wrapper unless they are failing DriverEntry
            //
            if ((MiniBlock->MiniportQueue != NULL) || (MiniBlock->Flags & fMINIBLOCK_UNLOADING))
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                            ("<==NdisTerminateWrapper\n"));
                return;
            }

            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("NdisTerminateWrapper: MiniBlock %p\n", MiniBlock));
            //
            // if the driver is going to fail DriverEntry, we expect it to have enough sense
            // to undo what it is done so far and not to wait for UnloadHandler
            //
            MiniBlock->UnloadHandler = NULL;

            MiniBlock->Flags |= fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD;
            //
            //  call unload entry point since PnP is not going to do it
            //
            ndisMUnload(WrapperHandle->DriverObject);
        }
        else
        {
            FREE_POOL(WrapperHandle);
        }
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisTerminateWrapper\n"));
}


VOID
NdisSetupDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )
/*++

Routine Description:

    Sets up the host DMA controller for a DMA transfer. The
    DMA controller is set up to transfer the specified MDL.
    Since we register all DMA channels as non-scatter/gather,
    IoMapTransfer will ensure that the entire MDL is
    in a single logical piece for transfer.

Arguments:

    Status - Returns the status of the request.

    NdisDmaHandle - Handle returned by NdisAllocateDmaChannel.

    Buffer - An NDIS_BUFFER which describes the host memory involved in the
            transfer.

    Offset - An offset within buffer where the transfer should
            start.

    Length - The length of the transfer. VirtualAddress plus Length must not
            extend beyond the end of the buffer.

    WriteToDevice - TRUE for a download operation (host to adapter); FALSE
            for an upload operation (adapter to host).

Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)NdisDmaHandle;
    PMAP_TRANSFER mapTransfer = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->MapTransfer;
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FlushAdapterBuffers;
    ULONG           LengthMapped;

    //
    // Make sure another request is not in progress.
    //
    if (DmaBlock->InProgress)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    DmaBlock->InProgress = TRUE;

    //
    // Use IoMapTransfer to set up the transfer.
    //
    LengthMapped = Length;

    mapTransfer(DmaBlock->SystemAdapterObject,
                (PMDL)Buffer,
                DmaBlock->MapRegisterBase,
                (PUCHAR)(MDL_VA(Buffer)) + Offset,
                &LengthMapped,
                WriteToDevice);

    if (LengthMapped != Length)
    {
        //
        // Somehow the request could not be mapped competely,
        // this should not happen for a non-scatter/gather adapter.
        //

        flushAdapterBuffers(DmaBlock->SystemAdapterObject,
                            (PMDL)Buffer,
                            DmaBlock->MapRegisterBase,
                            (PUCHAR)(MDL_VA(Buffer)) + Offset,
                            LengthMapped,
                            WriteToDevice);

        DmaBlock->InProgress = FALSE;
        *Status = NDIS_STATUS_RESOURCES;
    }

    else *Status = NDIS_STATUS_SUCCESS;
}


VOID
NdisCompleteDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )

/*++

Routine Description:

    Completes a previously started DMA transfer.

Arguments:

    Status - Returns the status of the transfer.

    NdisDmaHandle - Handle returned by NdisAllocateDmaChannel.

    Buffer - An NDIS_BUFFER which was passed to NdisSetupDmaTransfer.

    Offset - the offset passed to NdisSetupDmaTransfer.

    Length - The length passed to NdisSetupDmaTransfer.

    WriteToDevice - TRUE for a download operation (host to adapter); FALSE
            for an upload operation (adapter to host).


Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)NdisDmaHandle;
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FlushAdapterBuffers;
    BOOLEAN         Successful;

    Successful = flushAdapterBuffers(DmaBlock->SystemAdapterObject,
                                     (PMDL)Buffer,
                                     DmaBlock->MapRegisterBase,
                                     (PUCHAR)(MDL_VA(Buffer)) + Offset,
                                     Length,
                                     WriteToDevice);

    *Status = (Successful ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES);
    DmaBlock->InProgress = FALSE;
}

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\netvmini\sys\sendrcv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

        SendRCV.C
        
Abstract:

    This module contains miniport functions for handling Send & Receive
    packets and other helper routines called by these miniport functions.

    In order to excercise the send and receive code path of this driver, 
    you should install more than one instance of the miniport. If there 
    is only one instance installed, the driver throws the send packet on
    the floor and completes the send successfully. If there are more 
    instances present, it indicates the incoming send packet to the other
    instances. For example, if there 3 instances: A, B, & C installed. 
    Packets coming in for A instance would be indicated to B & C; packets 
    coming into B would be indicated to C, & A; and packets coming to C 
    would be indicated to A & B. 
    
Revision History:

Notes:

--*/
#include "miniport.h"


VOID 
MPSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets)
/*++

Routine Description:

    Send Packet Array handler. Called by NDIS whenever a protocol
    bound to our miniport sends one or more packets.

    The input packet descriptor pointers have been ordered according 
    to the order in which the packets should be sent over the network 
    by the protocol driver that set up the packet array. The NDIS 
    library preserves the protocol-determined ordering when it submits
    each packet array to MiniportSendPackets

    As a deserialized driver, we are responsible for holding incoming send 
    packets in our internal queue until they can be transmitted over the 
    network and for preserving the protocol-determined ordering of packet
    descriptors incoming to its MiniportSendPackets function. 
    A deserialized miniport driver must complete each incoming send packet
    with NdisMSendComplete, and it cannot call NdisMSendResourcesAvailable. 

    Runs at IRQL <= DISPATCH_LEVEL
    
Arguments:

    MiniportAdapterContext    Pointer to our adapter context
    PacketArray               Set of packets to send
    NumberOfPackets           Length of above array

Return Value:

    None
    
--*/
{
    PMP_ADAPTER       Adapter;
    NDIS_STATUS       Status;
    UINT              PacketCount;

    DEBUGP(MP_TRACE, ("---> MPSendPackets\n"));

    Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    for(PacketCount=0;PacketCount < NumberOfPackets; PacketCount++)
    {
        //
        // Check for a zero pointer
        //
        ASSERT(PacketArray[PacketCount]);

        Status = NICSendPacket(Adapter, PacketArray[PacketCount]);

    }

    DEBUGP(MP_TRACE, ("<--- MPSendPackets\n"));

    return;
}

VOID 
MPReturnPacket(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN PNDIS_PACKET Packet)
/*++

Routine Description:

    NDIS Miniport entry point called whenever protocols are done with
    a packet that we had indicated up and they had queued up for returning
    later.

Arguments:

    MiniportAdapterContext    - pointer to MP_ADAPTER structure
    Packet    - packet being returned.

Return Value:

    None.

--*/
{
    PMP_ADAPTER Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    DEBUGP(MP_TRACE, ("---> MPReturnPacket\n"));

    NICFreeRecvPacket(Adapter, Packet);
    
    DEBUGP(MP_TRACE, ("<--- MPReturnPacket\n"));
}



NDIS_STATUS 
NICSendPacket(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Packet)
/*++

Routine Description:

    This routine copies the packet content to a TCB, gets a receive packet,
    associates the TCB buffer to this recive packet and queues
    receive packet with the same data on one or more miniport instances
    controlled by this driver. For receive path to be active, you have
    to install more than one instance of this miniport.
        
Arguments:

    Adapter    - pointer to the MP_ADAPTER structure
    Packet    - packet to be transfered.


Return Value:

    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING

--*/
{
    PMP_ADAPTER       DestAdapter;
    NDIS_STATUS       Status = NDIS_STATUS_SUCCESS;
    PTCB              pTCB = NULL;

    DEBUGP(MP_TRACE, ("--> NICSendPacket, Packet= %p\n", Packet));
    
    //
    // Go through the adapter list and queue packet for
    // indication on them if there are any. Otherwise
    // just drop the packet on the floor and tell NDIS that
    // you have completed send.
    //
    NdisAcquireSpinLock(&GlobalData.Lock);
    DestAdapter = (PMP_ADAPTER) &GlobalData.AdapterList;       

    while(MP_IS_READY(Adapter))
    {
        DestAdapter = (PMP_ADAPTER) DestAdapter->List.Flink;
        if((PLIST_ENTRY)DestAdapter == &GlobalData.AdapterList)
        {
            //
            // We have reached the end of the adapter list. So
            //
            break;
        }

        //
        // We wouldn't transmit the packet if:
        // a) The destination adapter is same as the Send Adapter.
        // b) The destination adapter is not ready to receive packets.
        // c) The packet itself is not worth transmitting.
        //
        if(DestAdapter == Adapter ||
            !MP_IS_READY(DestAdapter) || 
            !NICIsPacketTransmittable(DestAdapter, Packet))
        {
            continue;
        }

        DEBUGP(MP_LOUD, ("Packet is accepted...\n"));

        if(!pTCB)
        {
            pTCB = (PTCB) NdisInterlockedRemoveHeadList(
                         &Adapter->SendFreeList, 
                         &Adapter->SendLock);
            if(pTCB == NULL)
            {
                DEBUGP(MP_WARNING, ("Can't allocate a TCB......!\n")); 

                Status = NDIS_STATUS_PENDING;    

                //
                // Not able to get TCB block for this send. So queue
                // it for later transmission and break out of the loop.
                //
                NdisInterlockedInsertTailList(
                    &Adapter->SendWaitList, 
                    (PLIST_ENTRY)&Packet->MiniportReserved[0], 
                    &Adapter->SendLock);
                break;
            }
            else
            {
                NdisInterlockedIncrement(&Adapter->nBusySend);
                ASSERT(Adapter->nBusySend <= NIC_MAX_BUSY_SENDS);
                //
                // Copy the packet content into the TCB data buffer, 
                // assuming the NIC is doing a common buffer DMA. For
                // scatter/gather DMA, this copy operation is not required.
                // For efficiency, I could have avoided the copy operation
                // in this driver and directly indicated the send buffers to 
                // other miniport instances since I'm holding the send packet
                // until all the indicated packets are returned. Oh, well!
                //
                if(!NICCopyPacket(Adapter, pTCB, Packet)){
                    DEBUGP(MP_ERROR, ("NICCopyPacket failed\n"));  
                    Status = NDIS_STATUS_FAILURE;
                    break;
                }
            }
        }

        Status = NDIS_STATUS_PENDING;    

        NICQueuePacketForRecvIndication(DestAdapter, pTCB);              

    } // while

    NdisReleaseSpinLock(&GlobalData.Lock);

    NDIS_SET_PACKET_STATUS(Packet, Status);

    if(Status == NDIS_STATUS_SUCCESS || 
        (pTCB && (NdisInterlockedDecrement(&pTCB->Ref) == 0)))
    {

        DEBUGP(MP_LOUD, ("Calling NdisMSendComplete \n"));

        Status = NDIS_STATUS_SUCCESS;

        NdisMSendComplete(
            Adapter->AdapterHandle,
            Packet,
            Status);

        if(pTCB)
        {
            NICFreeSendTCB(Adapter, pTCB);
        }
    }

    DEBUGP(MP_TRACE, ("<-- NICSendPacket Status = 0x%08x\n", Status));

    return(Status);
}  



VOID
NICQueuePacketForRecvIndication(
    PMP_ADAPTER Adapter,
    PTCB pTCB)
/*++

Routine Description:

    This routine queues the send packet in to the destination
    adapters RecvWaitList and fires a timer DPC so that it 
    cab be indicated as soon as possible.

Arguments:

    Adapter    - pointer to the destination adapter structure
    pTCB      - pointer to TCB block
        

Return Value:

    VOID

--*/
{
    PNDIS_PACKET     SendPacket = pTCB->OrgSendPacket;
    PNDIS_PACKET     RecvPacket = NULL;
    PNDIS_BUFFER     CurrentBuffer = NULL;   
    UINT             NumPhysDesc, BufferCount, PacketLength, RecvPacketLength;             
    PLIST_ENTRY      pEntry;
    PRCB             pRCB;
    NDIS_STATUS      Status;
    

    DEBUGP(MP_TRACE, ("--> NICQueuePacketForRecvIndication\n"));

    //
    // Allocate memory for RCB. 
    //
    pRCB = NdisAllocateFromNPagedLookasideList(&Adapter->RecvLookaside);
    if(!pRCB)
    {
        DEBUGP(MP_ERROR, ("Failed to allocate memory for RCB\n"));
        return;
    }  
    
    //
    // Get a free recv packet descriptor from the list.
    //
    pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                    &Adapter->RecvFreeList, 
                    &Adapter->RecvLock);
    if(!pEntry)
    {
        ++Adapter->RcvResourceErrors;
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pRCB);
    }
    else
    {
        ++Adapter->GoodReceives;
    
        RecvPacket = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);
        
        //
        // Prepare the recv packet
        //
        NdisReinitializePacket(RecvPacket);
        *((PTCB *)RecvPacket->MiniportReserved) = pTCB;

        //
        // Chain the TCB buffers to the packet
        //
        NdisChainBufferAtBack(RecvPacket, pTCB->Buffer);
                    
#if DBG
        NdisQueryPacket(
            RecvPacket,
            NULL,
            NULL,
            &CurrentBuffer,
            &RecvPacketLength);
    
        ASSERT(CurrentBuffer == pTCB->Buffer);
        
        NdisQueryPacket(
            SendPacket,
            NULL,
            NULL,
            NULL,
            &PacketLength);
    
        if((RecvPacketLength != 60) && (RecvPacketLength != PacketLength))
        {
            DEBUGP(MP_ERROR, ("RecvPacketLength = %d, PacketLength = %d\n",
                RecvPacketLength, PacketLength));
            DEBUGP(MP_ERROR, ("RecvPacket = %p, Packet = %p\n",
                RecvPacket, SendPacket));
            ASSERT(FALSE);
        }
#endif    
                  
        NDIS_SET_PACKET_STATUS(RecvPacket, NDIS_STATUS_SUCCESS);
    
        DEBUGP(MP_LOUD, ("RecvPkt= %p\n", RecvPacket));

        //
        // Initialize RCB 
        //
        NdisInitializeListHead(&pRCB->List);
        pRCB->Packet = RecvPacket;
        
        //
        // Increment the Ref count on the TCB to denote that it's being
        // used. This reference will be removed when the indicated
        // Recv packet finally returns from the protocol.
        //
        NdisInterlockedIncrement(&pTCB->Ref);     

        //
        // Insert the packet in the recv wait queue to be picked up by
        // the receive indication DPC.
        // 
        NdisInterlockedIncrement(&Adapter->nBusyRecv);     
        ASSERT(Adapter->nBusyRecv <= NIC_MAX_BUSY_RECVS);
        NdisInterlockedInsertTailList(
                            &Adapter->RecvWaitList, 
                            &pRCB->List, 
                            &Adapter->RecvLock);

        //
        // Fire a timer DPC. By specifing zero timeout, the DPC will
        // be serviced whenever the next system timer interrupt arrives.
        //
        NdisMSetTimer(&Adapter->RecvTimer, 0);
    
    }

    DEBUGP(MP_TRACE, ("<-- NICQueuePacketForRecvIndication\n"));
}

VOID
NICIndicateReceiveTimerDpc(
    IN PVOID             SystemSpecific1,
    IN PVOID             FunctionContext,
    IN PVOID             SystemSpecific2,
    IN PVOID             SystemSpecific3)
/*++

Routine Description:

    Timer callback function for Receive Indication. Please note that receive
    timer DPC is not required when you are talking to a real device. In real
    miniports, this DPC is usually provided by NDIS as MPHandleInterrupt
    callback whenever the device interrupts for receive indication.
        
Arguments:

FunctionContext - Pointer to our adapter

Return Value:

    VOID

--*/
{
    PMP_ADAPTER Adapter = (PMP_ADAPTER)FunctionContext;
    PRCB pRCB = NULL;
    PLIST_ENTRY pEntry = NULL;
    
    DEBUGP(MP_TRACE, ("--->NICIndicateReceiveTimerDpc = %p\n", Adapter));

    //
    // Increment the ref count on the adapter to prevent the driver from
    // unloding while the DPC is running. The Halt handler waits for the
    // ref count to drop to zero before returning. 
    //
    MP_INC_REF(Adapter); 
    
    //
    // Remove the packet from waitlist and indicate it to the protocols
    // above us.
    //
    while (pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                    &Adapter->RecvWaitList, 
                    &Adapter->RecvLock)) {
    
        pRCB = CONTAINING_RECORD(pEntry, RCB, List);

        ASSERT(pRCB);
        ASSERT(pRCB->Packet);
        
        DEBUGP(MP_LOUD, ("Indicating packet = %p\n", pRCB->Packet));
        
        NdisMIndicateReceivePacket(
            Adapter->AdapterHandle,
            &pRCB->Packet,
            1);

        //
        // We are done with RCB memory. So free it.
        //
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pRCB);
        
    }
    
    MP_DEC_REF(Adapter);
    DEBUGP(MP_TRACE, ("<---NICIndicateReceiveTimerDpc\n"));    
}

VOID 
NICFreeRecvPacket(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Packet)
/*++

Routine Description:

    Adapter    - pointer to the adapter structure
    Packet      - pointer to the receive packet
        
Arguments:

    This is called by MPReturnPacket to free the Receive packet
    indicated above. Since we have used the send-side TCB, we 
    will also carefully complete the pending SendPacket if we are 
    the last one to use the TCB buffers.
    
Return Value:

    VOID

--*/
{

    PTCB pTCB = *(PTCB *)Packet->MiniportReserved;
    PMP_ADAPTER SendAdapter = (PMP_ADAPTER)pTCB->Adapter;
    PNDIS_PACKET SendPacket = pTCB->OrgSendPacket;    
    PLIST_ENTRY pEntry;
    
    DEBUGP(MP_TRACE, ("--> NICFreeRecvPacket\n"));
    DEBUGP(MP_INFO, ("Adapter= %p FreePkt= %p Ref=%d\n", 
                            SendAdapter, SendPacket, pTCB->Ref));

    ASSERT(pTCB->Ref > 0);
    ASSERT(Adapter);
    //
    // Put the packet back in the free list for reuse.
    //
    NdisInterlockedInsertTailList(
        &Adapter->RecvFreeList, 
        (PLIST_ENTRY)&Packet->MiniportReserved[0], 
        &Adapter->RecvLock);

    NdisInterlockedDecrement(&Adapter->nBusyRecv);     
    ASSERT(Adapter->nBusyRecv >= 0);

    //
    // Check to see whether we are the last one to use the TCB
    // by decrementing the refcount. If so, complete the pending
    // Send packet and free the TCB block for reuse.
    // 
    if(NdisInterlockedDecrement(&pTCB->Ref) == 0)
    {
        NdisMSendComplete(
            SendAdapter->AdapterHandle,
            SendPacket,
            NDIS_STATUS_SUCCESS);
    
        NICFreeSendTCB(SendAdapter, pTCB);
        //
        // Before we exit, since we have the control, let use see if there any 
        // more packets waiting in the queue to be sent.
        //
        if(MP_IS_READY(SendAdapter))
        {
            pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                            &SendAdapter->SendWaitList, 
                            &SendAdapter->SendLock);
            if(pEntry)
            {
                SendPacket = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);
                NICSendPacket(SendAdapter, SendPacket);             
            }
        }
    }

    DEBUGP(MP_TRACE, ("<-- NICFreeRecvPacket\n"));
}

VOID 
NICFreeSendTCB(
    IN PMP_ADAPTER Adapter,
    IN PTCB pTCB)
/*++

Routine Description:

    Adapter    - pointer to the adapter structure
    pTCB      - pointer to TCB block
        
Arguments:

    This routine reinitializes the TCB block and puts it back
    into the SendFreeList for reuse.
    

Return Value:

    VOID

--*/
{
    DEBUGP(MP_TRACE, ("--> NICFreeSendTCB %p\n", pTCB));
    
    pTCB->OrgSendPacket = NULL;
    pTCB->Buffer->Next = NULL;

    ASSERT(!pTCB->Ref);
    
    //
    // Re adjust the length to the originl size
    //
    NdisAdjustBufferLength(pTCB->Buffer, NIC_BUFFER_SIZE);

    //
    // Insert the TCB back in the send free list     
    //
    NdisAcquireSpinLock(&Adapter->SendLock);
    NdisInitializeListHead(&pTCB->List);
    InsertHeadList(&Adapter->SendFreeList, &pTCB->List);
    NdisReleaseSpinLock(&Adapter->SendLock); 
    
    NdisInterlockedDecrement(&Adapter->nBusySend);
    ASSERT(Adapter->nBusySend >= 0);
    DEBUGP(MP_TRACE, ("<-- NICFreeSendTCB\n"));
    
}



VOID 
NICFreeQueuedSendPackets(
    PMP_ADAPTER Adapter
    )
/*++

Routine Description:

    This routine is called by the Halt or Reset handler to fail all
    the queued up SendPackets because the device is either
    gone, being stopped for resource rebalance, or reset.
    
Arguments:

    Adapter    - pointer to the adapter structure

Return Value:

    VOID

--*/
{
    PLIST_ENTRY       pEntry;
    PNDIS_PACKET      Packet;

    DEBUGP(MP_TRACE, ("--> NICFreeQueuedSendPackets\n"));

    while(TRUE)
    {
        pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                        &Adapter->SendWaitList, 
                        &Adapter->SendLock);
        if(!pEntry)
        {
            break;
        }

        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);
        NdisMSendComplete(
            Adapter->AdapterHandle,
            Packet,
            NDIS_STATUS_FAILURE);
    }

    DEBUGP(MP_TRACE, ("<-- NICFreeQueuedSendPackets\n"));

}

VOID 
NICFreeQueuedRecvPackets(
    PMP_ADAPTER Adapter
    )
/*++

Routine Description:

    This routine is called by the Halt handler to fail all
    the queued up RecvPackets if it succeeds in cancelling
    the RecvIndicate timer DPC.
    
Arguments:

    Adapter    - pointer to the adapter structure

Return Value:

    VOID

--*/
{
    PLIST_ENTRY       pEntry;
    PRCB pRCB = NULL;

    DEBUGP(MP_TRACE, ("--> NICFreeQueuedRecvPackets\n"));

    while(TRUE)
    {
        pEntry = (PLIST_ENTRY) NdisInterlockedRemoveHeadList(
                        &Adapter->RecvWaitList, 
                        &Adapter->RecvLock);
        if(!pEntry)
        {
            break;
        }

        pRCB = CONTAINING_RECORD(pEntry, RCB, List);

        ASSERT(pRCB);
        ASSERT(pRCB->Packet);
        
        NICFreeRecvPacket(Adapter, pRCB->Packet);
        
        //
        // We are done with RCB memory. So free it.
        //
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pRCB);
        
    }

    DEBUGP(MP_TRACE, ("<-- NICFreeQueuedRecvPackets\n"));

}



BOOLEAN
NICIsPacketTransmittable(
    PMP_ADAPTER Adapter,
    PNDIS_PACKET Packet
    )
/*++

Routine Description:

    This routines checks to see whether the packet can be accepted
    for transmission based on the currently programmed filter type 
    of the NIC and the mac address of the packet.
    
Arguments:

    Adapter    - pointer to the adapter structure
    Packet      - pointer to the send packet


Return Value:

    True or False

--*/
{
    int               Equal;            
    UINT              PacketLength;
    PNDIS_BUFFER      FirstBuffer;
    PUCHAR            Address;
    UINT              CurrentLength;
    ULONG             index;
    BOOLEAN           result = FALSE;
    
    NdisGetFirstBufferFromPacket(
        Packet,
        &FirstBuffer,
        &Address,
        &CurrentLength,
        &PacketLength);


    DEBUGP(MP_LOUD, 
        ("DestAdapter=%p, PacketFilter = 0x%08x\n", 
        Adapter,
        Adapter->PacketFilter));

    DEBUGP(MP_LOUD, ("Dest Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
        Address[0], Address[1], Address[2],
        Address[3], Address[4], Address[5]));
    
    do {
        
        //
        // If the NIC is in promiscuous mode, we will transmit anything
        // and everything.
        //
        if(Adapter->PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS) {
            result = TRUE;
            break;
        } 
        else if(ETH_IS_BROADCAST(Address)) {
            //
            // If it's a broadcast packet, check our filter settings to see
            // we can transmit that.
            //
            if(Adapter->PacketFilter & NDIS_PACKET_TYPE_BROADCAST) {
                result = TRUE;
                break;
            }
        }
        else if(ETH_IS_MULTICAST(Address)) {
            //
            // If it's a multicast packet, check our filter settings to see
            // we can transmit that.
            //
            if(Adapter->PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) {
                result = TRUE;
                break;
            }
            else if(Adapter->PacketFilter & NDIS_PACKET_TYPE_MULTICAST) {
                //
                // Check to see if the multicast address is in our list
                //
                for(index=0; index <  Adapter->ulMCListSize; index++) {
                    ETH_COMPARE_NETWORK_ADDRESSES_EQ(
                        Address,
                        Adapter->MCList[index], 
                        &Equal);
                    if(Equal == 0){ // 0 Implies equality
                        result = TRUE;
                        break;
                    }
                }
            }
        }
        else if(Adapter->PacketFilter & NDIS_PACKET_TYPE_DIRECTED) {
            //
            // This has to be a directed packet. If so, does packet source 
            // address match with the mac address of the NIC.
            // 
            ETH_COMPARE_NETWORK_ADDRESSES_EQ(
                Address,
                Adapter->CurrentAddress, 
                &Equal);
            if(Equal == 0){
                result = TRUE;
                break;
            }
        }
        //
        // This is a junk packet. We can't transmit this.
        //
        result = FALSE;
        
    }while(FALSE);
    
    return result;
}

BOOLEAN
NICCopyPacket(
    PMP_ADAPTER Adapter,
    PTCB pTCB, 
    PNDIS_PACKET Packet)
/*++

Routine Description:

    This routine copies the packet data into the TCB data block.
        
Arguments:

    Adapter    - pointer to the MP_ADAPTER structure
    pTCB      - pointer to TCB block
    Packet    - packet to be transfered.


Return Value:

    VOID

--*/
{
    PNDIS_BUFFER   MyBuffer;
    PNDIS_BUFFER   CurrentBuffer;
    PVOID          VirtualAddress;
    UINT           CurrentLength;
    UINT           BytesToCopy;
    UINT           BytesCopied = 0;
    UINT           BufferCount;
    UINT           PacketLength;    
    UINT           DestBufferSize = NIC_BUFFER_SIZE;        
    PUCHAR         pDest;
    BOOLEAN        bResult = TRUE;
    
    DEBUGP(MP_TRACE, ("--> NICCopyPacket\n"));

    pTCB->OrgSendPacket = Packet;
    pTCB->Ref = 1;

    MyBuffer = pTCB->Buffer;
    pDest = pTCB->pData;
    
    MyBuffer->Next = NULL;

    NdisQueryPacket(Packet,
                    NULL,
                    &BufferCount,
                    &CurrentBuffer,
                    &PacketLength);

    ASSERT(PacketLength <= NIC_BUFFER_SIZE);

    BytesToCopy = min(PacketLength, NIC_BUFFER_SIZE); 
    
    if(BytesToCopy < ETH_MIN_PACKET_SIZE)
    {
        BytesToCopy = ETH_MIN_PACKET_SIZE;   // padding
    }
             
    while(CurrentBuffer && DestBufferSize)
    {
        NdisQueryBufferSafe(
            CurrentBuffer,
            &VirtualAddress,
            &CurrentLength,
            NormalPagePriority);
        
        if(VirtualAddress == NULL){
            bResult = FALSE;
            break;
        }

        CurrentLength = min(CurrentLength, DestBufferSize); 

        if(CurrentLength)
        {
            // Copy the data.
            NdisMoveMemory(pDest, VirtualAddress, CurrentLength);
            BytesCopied += CurrentLength;
            DestBufferSize -= CurrentLength;
            pDest += CurrentLength;
        }

        NdisGetNextBuffer(
            CurrentBuffer,
            &CurrentBuffer);
    }

    if(bResult) {
        if(BytesCopied < BytesToCopy)
        {
            //
            // This would be the case if the packet size is less than 
            // ETH_MIN_PACKET_SIZE
            //
            BytesCopied = BytesToCopy;
        }
        NdisAdjustBufferLength(MyBuffer, BytesCopied);        
    }

    DEBUGP(MP_TRACE, ("<-- NICCopyPacket\n"));

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\bus.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    NDIS wrapper functions to handle specific buses

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization

--*/


#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_BUS

VOID
NdisReadEisaSlotInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION EisaData
    )

/*++

Routine Description:

    This routine reads the EISA data from the slot given.

Arguments:

    Status - Status of request to be returned to the user.
    WrapperConfigurationContext - Context passed to MacAddAdapter.
    SlotNumber - the EISA Slot where the card is at.
    EisaData - pointer to a buffer where the EISA configuration is to be returned.

Return Value:

    None.

--*/
{

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadEisaSlotInformation: WrapperConfigurationContext %p\n", WrapperConfigurationContext));

#if !DBG
    UNREFERENCED_PARAMETER(WrapperConfigurationContext);
#endif

    UNREFERENCED_PARAMETER(SlotNumber);
    UNREFERENCED_PARAMETER(EisaData);
    
    *Status = NDIS_STATUS_NOT_SUPPORTED;

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadEisaSlotInformation: WrapperConfigurationContext %p, Status %lx\n", WrapperConfigurationContext, *Status));
    
    return;
}


VOID
NdisReadEisaSlotInformationEx(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION *EisaData,
    OUT PUINT                   NumberOfFunctions
    )

/*++

Routine Description:

    This routine reads the EISA data from the slot given.

Arguments:

    Status - Status of request to be returned to the user.
    WrapperConfigurationContext - Context passed to MacAddAdapter.
    SlotNumber - the EISA Slot where the card is at.
    EisaData - pointer to a buffer where the EISA configuration is to be returned.
    NumberOfFunctions - Returns the number of function structures in the EisaData.

Return Value:

    None.

--*/
{
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadEisaSlotInformationEx: WrapperConfigurationContext %p\n", WrapperConfigurationContext));

#if !DBG
    UNREFERENCED_PARAMETER(WrapperConfigurationContext);
#endif

    UNREFERENCED_PARAMETER(SlotNumber);
    UNREFERENCED_PARAMETER(EisaData);
    UNREFERENCED_PARAMETER(NumberOfFunctions);

    *Status = NDIS_STATUS_NOT_SUPPORTED;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadEisaSlotInformationEx: WrapperConfigurationContext %p, Status %lx\n", WrapperConfigurationContext, *Status));

    return;
}


ULONG
NdisImmediateReadPciSlotInformation(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine reads from the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    WrapperConfigurationContext - Context passed to MacAddAdapter.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes read.

--*/
{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    ULONG                       BytesRead;

#if !DBG
    UNREFERENCED_PARAMETER(SlotNumber);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisImmediateReadPciSlotInformation: Miniport %p\n", Miniport));

    ASSERT(Miniport != NULL);

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisImmediateReadPciSlotInformation: this API is going away. Use NdisReadPciSlotInformation\n", Miniport));
        
    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisImmediateReadPciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));

    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCI_WHICHSPACE_CONFIG,
                                         TRUE);             
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisImmediateReadPciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesRead;
            
}


ULONG
NdisImmediateWritePciSlotInformation(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine writes to the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    WrapperConfigurationContext - Context passed to MacAddAdapter.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes written.

--*/
{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    ULONG                       BytesWritten;
    
#if !DBG
    UNREFERENCED_PARAMETER(SlotNumber);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisImmediateWritePciSlotInformation: Miniport %p\n", Miniport));

    ASSERT(Miniport != NULL);
    
    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisImmediateWritePciSlotInformation: this API is going away. Use NdisWritePciSlotInformation\n", Miniport));
        
    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisImmediateWritePciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));
    
    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCI_WHICHSPACE_CONFIG,
                                            FALSE);             

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisImmediateWritePciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesWritten;
}


ULONG
NdisReadPciSlotInformation(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine reads from the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    NdisAdapterHandle - Adapter we are talking about.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes read.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    ULONG                BytesRead;
    
#if !DBG
    UNREFERENCED_PARAMETER(SlotNumber);
#endif

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadPciSlotInformation: Miniport %p\n", Miniport));

    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisReadPciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));
        
    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCI_WHICHSPACE_CONFIG,
                                         TRUE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadPciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesRead;   
}


ULONG
NdisWritePciSlotInformation(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine writes to the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    NdisAdapterHandle - Adapter we are talking about.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes written.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    ULONG BytesWritten;

#if !DBG
    UNREFERENCED_PARAMETER(SlotNumber);
#endif
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisWritePciSlotInformation: Miniport %p\n", Miniport));

    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisWritePciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));

    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCI_WHICHSPACE_CONFIG,
                                            FALSE);
                            
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisWritePciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesWritten;
}


NTSTATUS
FASTCALL
ndisQueryBusInterface(
    IN PNDIS_MINIPORT_BLOCK     Miniport
    )
{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          NextDeviceObject;
    BUS_INTERFACE_STANDARD  BusInterfaceStandard = {0};
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisQueryBusInterface: Miniport %p\n", Miniport));

    do {
    
        NextDeviceObject = Miniport->NextDeviceObject; 
        
        //
        //  Allocate an irp to send to PCI bus device driver.
        //
        Irp = IoAllocateIrp((CCHAR)(NextDeviceObject->StackSize + 1),
                            FALSE);
                        
        if (Irp == NULL)
        {
            ASSERT(FALSE);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        //
        //  Get the stack location for the next device.
        //
        IrpSp = IoGetNextIrpStackLocation(Irp);
        ASSERT(IrpSp != NULL);
        
        IrpSp->MajorFunction = IRP_MJ_PNP;
        IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpSp->DeviceObject = NextDeviceObject;
        Irp->IoStatus.Status  = STATUS_NOT_SUPPORTED;
        
        IrpSp->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
        IrpSp->Parameters.QueryInterface.Size = sizeof (BUS_INTERFACE_STANDARD);
        IrpSp->Parameters.QueryInterface.Version = 1;
        IrpSp->Parameters.QueryInterface.Interface = (PINTERFACE)&BusInterfaceStandard;

        ASSERT(KeGetCurrentIrql() == 0);
        Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

        if (NT_SUCCESS(Status))
        {
            Miniport->SetBusData = BusInterfaceStandard.SetBusData;
            Miniport->GetBusData = BusInterfaceStandard.GetBusData;
            Miniport->BusDataContext = BusInterfaceStandard.Context;
            Status = NDIS_STATUS_SUCCESS;
        }

        IoFreeIrp(Irp);
        
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisQueryBusInterface: Miniport %p\n", Miniport));

    return Status;
}       

ULONG
ndisGetSetBusConfigSpace(
    IN PNDIS_MINIPORT_BLOCK     Miniport,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length,
    IN ULONG                    WhichSpace,
    IN BOOLEAN                  Read
    )
{
    ULONG   ActualLength = 0;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>ndisGetSetBusConfigSpace: Miniport %p\n", Miniport));


    if ((Read && MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_READ_CONFIG_SPACE)) ||
        MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_WRITE_CONFIG_SPACE))
    {
#if DBG
            DbgPrint("ndisGetSetBusConfigSpace failed to verify miniport %p\n", Miniport);
#endif
            return 0;
    }

    do
    {
        if ((Miniport->SetBusData == NULL) ||  (Miniport->BusDataContext  == NULL))
            break;
            
        ActualLength = (Read ? Miniport->GetBusData : Miniport->SetBusData)(
                                            Miniport->BusDataContext,
                                            WhichSpace,
                                            Buffer,
                                            Offset,
                                            Length);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==ndisGetSetBusConfigSpace: Miniport %p\n", Miniport));
            
    return ActualLength;
}

NDIS_STATUS
ndisTranslateResources(
    IN PNDIS_MINIPORT_BLOCK                 Miniport,
    IN CM_RESOURCE_TYPE                     ResourceType,
    IN PHYSICAL_ADDRESS                     Resource,
    OUT PPHYSICAL_ADDRESS                   pTranslatedResource,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor OPTIONAL
    )
{
    UINT                    j;
    PCM_RESOURCE_LIST       AllocatedResources, AllocatedResourcesTranslated;
    PHYSICAL_ADDRESS        Offset;
    PCM_PARTIAL_RESOURCE_LIST pResourceList, pResourceListTranslated;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>ndisTranslateResources: Miniport %p\n", Miniport));
            
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("    translating resource  type: %lx, value: %I64x\n", ResourceType, Resource));

    do
    {
        AllocatedResources = Miniport->AllocatedResources;
        AllocatedResourcesTranslated = Miniport->AllocatedResourcesTranslated;

        if ((AllocatedResources == NULL) || (AllocatedResourcesTranslated == NULL))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
        pResourceList = &(AllocatedResources->List[0].PartialResourceList);
        pResourceListTranslated = &(AllocatedResourcesTranslated->List[0].PartialResourceList);
        
        for (j = 0; j < pResourceList->Count; j++)
        {
            if (pResourceList->PartialDescriptors[j].Type != ResourceType)
                continue;
                
            switch (ResourceType)
            {
              case CmResourceTypePort:
              case CmResourceTypeMemory:
                Offset.QuadPart = Resource.QuadPart - pResourceList->PartialDescriptors[j].u.Port.Start.QuadPart;
                if ((Offset.QuadPart >= 0) && (Offset.u.HighPart == 0) && 
                    (((ULONG)(Offset.u.LowPart)) < pResourceList->PartialDescriptors[j].u.Port.Length))
                {
                    pTranslatedResource->QuadPart = pResourceListTranslated->PartialDescriptors[j].u.Memory.Start.QuadPart + 
                                                      Offset.QuadPart;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
                    
              case CmResourceTypeInterrupt:
                if (Resource.QuadPart == pResourceList->PartialDescriptors[j].u.Interrupt.Level)
                {
                    pTranslatedResource->QuadPart = (LONGLONG)pResourceListTranslated->PartialDescriptors[j].u.Interrupt.Level;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
                                    
              case CmResourceTypeDma:
                if (Resource.QuadPart == pResourceList->PartialDescriptors[j].u.Dma.Channel)
                {
                    pTranslatedResource->QuadPart = (LONGLONG)pResourceListTranslated->PartialDescriptors[j].u.Dma.Channel;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
            }
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        ("    ndisTranslateResources translated %I64x to %I64x\n", Resource, *pTranslatedResource));
                        
                if (pResourceDescriptor != NULL)
                {
                    *pResourceDescriptor = &pResourceListTranslated->PartialDescriptors[j];
                }
                
                break;
            }
        }
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==ndisTranslateResources: Miniport %p, Status %lx\n", Miniport, Status));
            
    return Status;
    
}

ULONG
NdisReadPcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    PDEVICE_OBJECT       NextDeviceObject;
    ULONG                BytesRead;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadPcmciaAttributeMemory: Miniport %p\n", Miniport));
    
    NextDeviceObject = Miniport->NextDeviceObject;

    ASSERT(NextDeviceObject != NULL);

    //
    // use direct entry points in bus driver to get/set bus data
    //
    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCCARD_ATTRIBUTE_MEMORY,
                                         TRUE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadPcmciaAttributeMemory: Miniport %p, Bytes Read %lx\n", Miniport, BytesRead));

    return BytesRead;
}

ULONG
NdisWritePcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    PDEVICE_OBJECT          NextDeviceObject;
    ULONG                   BytesWritten;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisWritePcmciaAttributeMemory: Miniport %p\n", Miniport));
    
    NextDeviceObject = Miniport->NextDeviceObject;

    ASSERT(NextDeviceObject != NULL);

    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCCARD_ATTRIBUTE_MEMORY,
                                            FALSE);             

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisWritePcmciaAttributeMemory: Miniport %p, Bytes Written %.8x\n", Miniport, BytesWritten));
            
    return BytesWritten;
}


VOID
NdisOverrideBusNumber(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN NDIS_HANDLE              MiniportAdapterHandle OPTIONAL,
    IN ULONG                    BusNumber
    )
{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisOverrideBusNumber: This API is going away.\n", Miniport));

#else
    UNREFERENCED_PARAMETER(WrapperConfigurationContext);
#endif
    UNREFERENCED_PARAMETER(MiniportAdapterHandle);
    UNREFERENCED_PARAMETER(BusNumber);
}

VOID
NdisReadMcaPosInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   ChannelNumber,
    OUT PNDIS_MCA_POS_DATA      McaData
    )
{
    UNREFERENCED_PARAMETER(WrapperConfigurationContext);
    UNREFERENCED_PARAMETER(ChannelNumber);
    UNREFERENCED_PARAMETER(McaData);
    
    *Status = NDIS_STATUS_NOT_SUPPORTED;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\debug.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    10/22/95        Kyle Brandon    Created.
--*/

#include <precomp.h>
#pragma hdrstop

#if DBG

//
//  Define module number for debug code
//
#define MODULE_NUMBER   MODULE_DEBUG

VOID
ndisDbgPrintUnicodeString(
    IN  PUNICODE_STRING     UnicodeString
        )
{
    UCHAR Buffer[256];


    USHORT i;

    for (i = 0; (i < UnicodeString->Length / 2) && (i < 255); i++)
        Buffer[i] = (UCHAR)UnicodeString->Buffer[i];
        
    Buffer[i] = '\0';
    
    DbgPrint("%s", Buffer);
}

#endif // DBG

#if ASSERT_ON_FREE_BUILDS

VOID
ndisAssert(
    IN  PVOID               exp,
    IN  PUCHAR              File,
    IN  UINT                Line
    )
{
    DbgPrint("Assertion failed: \"%s\", File %s, Line %d\n", exp, File, Line);
    DbgBreakPoint();
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\data.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    data.c

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

    10-July-1995    KyleB    Added spinlock logging debug code.

--*/

#include <precomp.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DATA

UCHAR                   ndisValidProcessors[NDIS_MAX_CPU_COUNT] = { 0 };
UCHAR                   ndisMaximumProcessor = 0;
UCHAR                   ndisCurrentProcessor = 0;
UCHAR                   ndisNumberOfProcessors = 0;
BOOLEAN                 ndisSkipProcessorAffinity = FALSE;
const                   NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
KSPIN_LOCK              ndisGlobalLock;
PNDIS_M_DRIVER_BLOCK    ndisMiniDriverList = NULL;
PNDIS_PROTOCOL_BLOCK    ndisProtocolList = NULL;
PNDIS_MINIPORT_BLOCK    ndisMiniportList = NULL;
PNDIS_OPEN_BLOCK        ndisGlobalOpenList = NULL;
LIST_ENTRY              ndisGlobalPacketPoolList = {0};
TDI_REGISTER_CALLBACK   ndisTdiRegisterCallback = NULL;
TDI_PNP_HANDLER         ndisTdiPnPHandler = NULL;
ULONG                   ndisDmaAlignment = 0;
ULONG                   ndisTimeIncrement = 0;
ERESOURCE               SharedMemoryResource = {0};
HANDLE                  ndisSystemProcess = {0};
PDEVICE_OBJECT          ndisDeviceObject = NULL;
PDRIVER_OBJECT          ndisDriverObject = NULL;
PETHREAD                ndisThreadObject = NULL;
NDIS_STATUS             ndisLastFailedInitErrorCode = NDIS_STATUS_SUCCESS;
NDIS_STRING             ndisDeviceStr =  NDIS_STRING_CONST("\\DEVICE\\");
// NDIS_STRING             ndisDosDevicesStr = NDIS_STRING_CONST("\\DOSDEVICES\\");
NDIS_STRING             ndisDosDevicesStr = NDIS_STRING_CONST("\\GLOBAL??\\");
#if NDIS_NO_REGISTRY
PWSTR                   ndisDefaultExportName = NDIS_DEFAULT_EXPORT_NAME;
#endif
ULONG                   ndisVerifierLevel = 0;
ULONG                   ndisVeriferFailedAllocations = 0;
PCALLBACK_OBJECT        ndisPowerStateCallbackObject = NULL;
PVOID                   ndisPowerStateCallbackHandle = NULL;
ULONG                   ndisAcOnLine = 1;
LONG                    ndisCancelId = 0;
BOOLEAN                 VerifierSystemSufficientlyBooted = FALSE;
BOOLEAN                 ndisGuidsSecured = FALSE;
    
KQUEUE                  ndisWorkerQueue = {0};

#if NDIS_UNLOAD
WORK_QUEUE_ITEM         ndisPoisonPill = {0};
#endif

LARGE_INTEGER           PoolAgingTicks = {0};

PKG_REF                 ndisPkgs[MAX_PKG] =
    {
        {   0, FALSE, (PVOID)NdisSend,                     NULL},
        {   0, FALSE, (PVOID)ndisMIsr,                     NULL},
        {   0, FALSE, (PVOID)ndisDispatchRequest,          NULL},
        {   0, FALSE, (PVOID)NdisCoSendPackets,            NULL},
        {   0, FALSE, (PVOID)EthFilterDprIndicateReceive,  NULL},
        {   0, FALSE, (PVOID)FddiFilterDprIndicateReceive, NULL},
        {   0, FALSE, (PVOID)TrFilterDprIndicateReceive,   NULL},
#if ARCNET
        {   0, FALSE, (PVOID)ArcFilterDprIndicateReceive,  NULL}
#endif
    };

LONG                    ndisFlags = 0;
LARGE_INTEGER           KeBootTime = {0, 0};

#if DBG
ULONG                   ndisDebugSystems = 0;
LONG                    ndisDebugLevel = DBG_LEVEL_FATAL;
ULONG                   ndisDebugBreakPoint = 0;
ULONG                   MiniportDebug = 0;   // MINIPORT_DEBUG_LOUD;
#endif

#if TRACK_MEMORY

KSPIN_LOCK  ALock = 0;
#define MAX_PTR_COUNT   2048

struct _MemPtr
{
    PVOID   Ptr;
    ULONG   Size;
    ULONG   ModLine;
    ULONG   Tag;
} ndisMemPtrs[MAX_PTR_COUNT] = { 0 };

PVOID
AllocateM(
    IN  UINT    Size,
    IN  ULONG   ModLine,
    IN  ULONG   Tag
    )
{
    PVOID   p;

    p = ExAllocatePoolWithTag(NonPagedPool, Size, Tag);

    if (p != NULL)
    {
        KIRQL   OldIrql;
        UINT    i;

        ACQUIRE_SPIN_LOCK(&ALock, &OldIrql);

        for (i = 0; i < MAX_PTR_COUNT; i++)
        {
            if (ndisMemPtrs[i].Ptr == NULL)
            {
                ndisMemPtrs[i].Ptr = p;
                ndisMemPtrs[i].Size = Size;
                ndisMemPtrs[i].ModLine = ModLine;
                ndisMemPtrs[i].Tag = Tag;
                break;
            }
        }

        RELEASE_SPIN_LOCK(&ALock, OldIrql);
    }

    return(p);
}

VOID
FreeM(
    IN  PVOID   MemPtr
    )
{
    KIRQL   OldIrql;
    UINT    i;

    ACQUIRE_SPIN_LOCK(&ALock, &OldIrql);

    for (i = 0; i < MAX_PTR_COUNT; i++)
    {
        if (ndisMemPtrs[i].Ptr == MemPtr)
        {
            ndisMemPtrs[i].Ptr = NULL;
            ndisMemPtrs[i].Size = 0;
            ndisMemPtrs[i].ModLine = 0;
            ndisMemPtrs[i].Tag = 0;
        }
    }

    RELEASE_SPIN_LOCK(&ALock, OldIrql);

    ExFreePool(MemPtr);
}

#endif

#ifdef TRACK_MOPEN_REFCOUNTS

USHORT ndisLogfileIndex = 0;
ULONG_PTR ndisLogfile[NDIS_LOGFILE_SIZE];

#endif //TRACK_MOPEN_REFCOUNTS

#ifdef TRACK_MINIPORT_REFCOUNTS

USHORT ndisMiniportLogfileIndex = 0;
ULONG_PTR ndisMiniportLogfile[NDIS_MINIPORT_LOGFILE_SIZE];

#endif //TRACK_MINIPORT_REFCOUNTS

#if TRACK_RECEIVED_PACKETS

USHORT ndisRcvLogfileIndex = 0;
ULONG_PTR ndisRcvLogfile[NDIS_RCV_LOGFILE_SIZE];

#endif

KSPIN_LOCK  ndisProtocolListLock;
KSPIN_LOCK  ndisMiniDriverListLock;
KSPIN_LOCK  ndisMiniportListLock;
KSPIN_LOCK  ndisGlobalPacketPoolListLock;
KSPIN_LOCK  ndisGlobalOpenListLock;

NDIS_STRING ndisBuildDate = {0, 0, NULL}; 
NDIS_STRING ndisBuildTime = {0, 0, NULL};
NDIS_STRING ndisBuiltBy = {0, 0, NULL};

KMUTEX      ndisPnPMutex;
ULONG       ndisPnPMutexOwner = 0;

#if DBG
ULONG   ndisChecked = 1;
#else
ULONG   ndisChecked = 0;
#endif

PNDIS_MINIPORT_BLOCK    ndisMiniportTrackAlloc = NULL;
LIST_ENTRY              ndisMiniportTrackAllocList;
PNDIS_M_DRIVER_BLOCK    ndisDriverTrackAlloc = NULL;
LIST_ENTRY              ndisDriverTrackAllocList;
KSPIN_LOCK              ndisTrackMemLock;

PCALLBACK_OBJECT        ndisBindUnbindCallbackObject = NULL;
PVOID                   ndisBindUnbindCallbackRegisterationHandle = NULL;
LUID                    SeWmiAccessPrivilege = {SE_LOAD_DRIVER_PRIVILEGE, 0};

#if NDIS_LOG_ABORTED_REQUESTS
NDIS_REQUEST            ndisAbortedRequests[16];
ULONG                   ndisAbortedRequestsIndex = 0;
#endif

volatile ULONG          ndisSpin = 0;

PSECURITY_DESCRIPTOR    ndisSecurityDescriptor = NULL;
WORK_QUEUE_ITEM LastWorkerThreadWI = {0} ;
CHAR                    AllUsersReadSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
CHAR                    AllUsersWriteSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
CHAR                    AllUsersReadWriteSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
CHAR                    AllUsersNotificationSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
CHAR                    AdminsSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
PACL                    AllUsersAclRead = NULL;
PACL                    AllUsersAclWrite = NULL;
PACL                    AllUsersAclReadWrite = NULL;
PACL                    AllUsersAclNotification = NULL;
PACL                    AdminsAcl = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\configm.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    configm.c

Abstract:

    NDIS wrapper functions for miniport configuration/initialization

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder        (JameelH) 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_CONFIGM

NDIS_STATUS
NdisMRegisterMiniport(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength
    )

/*++

Routine Description:

    Used to register a Miniport driver with the wrapper.

Arguments:

    Status - Status of the operation.

    NdisWrapperHandle - Handle returned by NdisWInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

Return Value:

    None.

--*/
{
    NDIS_STATUS             Status;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMRegisterMiniport: NdisWrapperHandle %p\n", NdisWrapperHandle));


    Status = ndisRegisterMiniportDriver(NdisWrapperHandle,
                                        MiniportCharacteristics,
                                        CharacteristicsLength,
                                        &MiniBlock);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("NdisMRegisterMiniport: MiniBlock %p\n", MiniBlock));

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMRegisterMiniport: MiniBlock %p, Status %lx\n", MiniBlock, Status));

    return Status;
}

NDIS_STATUS
NdisIMRegisterLayeredMiniport(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength,
    OUT PNDIS_HANDLE            DriverHandle
    )

/*++

Routine Description:

    Used to register a layered Miniport driver with the wrapper.

Arguments:

    Status - Status of the operation.

    NdisWrapperHandle - Handle returned by NdisInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

    DriverHandle - Returns a handle which can be used to call NdisMInitializeDeviceInstance.

Return Value:

    None.

--*/
{
    NDIS_STATUS Status;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMRegisterLayeredMiniport: NdisWrapperHandle %p\n", NdisWrapperHandle));

    Status = ndisRegisterMiniportDriver(NdisWrapperHandle,
                                        MiniportCharacteristics,
                                        CharacteristicsLength,
                                        DriverHandle);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        PNDIS_M_DRIVER_BLOCK MiniBlock = (PNDIS_M_DRIVER_BLOCK)(*DriverHandle);

        MiniBlock->Flags |= fMINIBLOCK_INTERMEDIATE_DRIVER;
        
        INITIALIZE_MUTEX(&MiniBlock->IMStartRemoveMutex); 
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMRegisterLayeredMiniport: MiniBlock %p, Status %lx\n", *DriverHandle, Status));

    return Status;
}

//1 deprecated function
VOID
NdisIMDeregisterLayeredMiniport(    
    IN  NDIS_HANDLE         DriverHandle
    )
/*++

Routine Description:
    NdisIMDeregisterLayeredMiniport releases a previously registered intermediate driver. 
    
Arguments:
    DriverHandle: Specifies the handle returned by NdisIMRegisterLayeredMiniport.
    
Return Value:
    None.
    
Callers of NdisIMDeregisterLayeredMiniport run at IRQL = PASSIVE_LEVEL.
--*/
{
    //
    // Do nothing for now
    //
    UNREFERENCED_PARAMETER(DriverHandle);
}

VOID
NdisIMAssociateMiniport(    
    IN  NDIS_HANDLE         DriverHandle,
    IN  NDIS_HANDLE         ProtocolHandle
    )
/*++

Routine Description:
    NdisIMAssociateMiniport informs NDIS that the specified lower and upper interfaces 
    for miniport and protocol drivers respectively belong to the same intermediate driver. 

Arguments:
    DriverHandle: Specifies the handle to the miniport driver interface that is returned by 
    NdisIMRegisterLayeredMiniport. 
    
    ProtocolHandle: Specifies the handle to the protocol interface that is returned by 
    NdisRegisterProtocol

Return Value:
    None.
    
Callers of NdisIMAssociateMiniport run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_M_DRIVER_BLOCK    MiniDriver = (PNDIS_M_DRIVER_BLOCK)DriverHandle;
    PNDIS_PROTOCOL_BLOCK    Protocol = (PNDIS_PROTOCOL_BLOCK)ProtocolHandle;

    MiniDriver->AssociatedProtocol = Protocol;
    Protocol->AssociatedMiniDriver = MiniDriver;
}

NDIS_STATUS
ndisRegisterMiniportDriver(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength,
    OUT PNDIS_HANDLE            DriverHandle
    )

/*++

Routine Description:

    Used to register a layered Miniport driver with the wrapper.

Arguments:

    NdisWrapperHandle - Handle returned by NdisWInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

    DriverHandle - Returns a handle which can be used to call NdisMInitializeDeviceInstance.

Return Value:

    Status of the operation.

ndisRegisterMiniportDriver is called at IRQL == PASSIVE.

--*/

{
    PNDIS_M_DRIVER_BLOCK    MiniBlock = NULL;
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    USHORT                  i, size;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisRegisterMiniportDriver: NdisWrapperHandle %p\n", NdisWrapperHandle));


    do
    {
        if (DriverInfo == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Check version numbers and CharacteristicsLength.
        //
        size = 0;   // Used to indicate bad version below
        if (MiniportCharacteristics->MinorNdisVersion == 0)
        {
            if (MiniportCharacteristics->MajorNdisVersion == 3)
            {
                size = sizeof(NDIS30_MINIPORT_CHARACTERISTICS);
            }

            else if (MiniportCharacteristics->MajorNdisVersion == 4)
            {
                size = sizeof(NDIS40_MINIPORT_CHARACTERISTICS);
            }
            else if (MiniportCharacteristics->MajorNdisVersion == 5)
            {
                size = sizeof(NDIS50_MINIPORT_CHARACTERISTICS);
            }
        }
        else if (MiniportCharacteristics->MinorNdisVersion == 1)
        {
            if (MiniportCharacteristics->MajorNdisVersion == 5)
            {
                size = sizeof(NDIS51_MINIPORT_CHARACTERISTICS);
            }
        }

        //
        // Check that this is an NDIS 3.0/4.0/5.0 miniport.
        //
        if (size == 0)
        {
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        //
        // Check that CharacteristicsLength is enough.
        //
        if (CharacteristicsLength < size)
        {
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //
        // Validate some stuff for NDIS 5.0
        //
        if (MiniportCharacteristics->MajorNdisVersion == 5)
        {
            if (MiniportCharacteristics->CoSendPacketsHandler != NULL)
            {
                if (MiniportCharacteristics->CoRequestHandler == NULL)
                {
                    Status = NDIS_STATUS_BAD_CHARACTERISTICS;
                    break;
                }
            }
            
            if (MiniportCharacteristics->MinorNdisVersion >= 1)
            {
                //
                // for 5.1 miniports, having an AdapterShutdownHandler is mandatory
                //
                if (MiniportCharacteristics->AdapterShutdownHandler == NULL)
                {
                    Status = NDIS_STATUS_BAD_CHARACTERISTICS;
                    break;
                }
            }
        }

        //
        // Allocate memory for the NDIS MINIPORT block.
        //
        Status = IoAllocateDriverObjectExtension(DriverInfo->DriverObject,          // DriverObject
                                                 (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID,// MiniDriver magic number
                                                 sizeof(NDIS_M_DRIVER_BLOCK),
                                                 (PVOID)&MiniBlock);
        if (!NT_SUCCESS(Status))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(MiniBlock, sizeof(NDIS_M_DRIVER_BLOCK));

        //
        // Copy over the characteristics table.
        //
        CopyMemory(&MiniBlock->MiniportCharacteristics,
                   MiniportCharacteristics,
                   size);

        //
        // Check if the Driver is verifying
        //
        if (MmIsDriverVerifying(DriverInfo->DriverObject))
        {
            MiniBlock->Flags |= fMINIBLOCK_VERIFYING;
            if (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION)
            {
                if (ndisDriverTrackAlloc == NULL)
                {
                    ndisDriverTrackAlloc = MiniBlock;
                }
                else
                {
                    //
                    // tracking memory alocation is allowed
                    // for one driver only. otherwise null out the
                    // global ndisDriverTrackAlloc to avoid confusion
                    // memory allocations will continue to get tracked
                    // but the result will not be very useful
                    //
                    ndisDriverTrackAlloc = NULL;
                }

            }            
        }

        //
        // No adapters yet registered for this Miniport.
        //
        MiniBlock->MiniportQueue = (PNDIS_MINIPORT_BLOCK)NULL;

        //
        // Set up the handlers for this driver. First setup Dummy handlers and then specific ones
        //
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++)
        {
            DriverInfo->DriverObject->MajorFunction[i] = ndisDummyIrpHandler;
        }

        //
        // set up AddDevice handler for this miniport
        //
        DriverInfo->DriverObject->DriverExtension->AddDevice = ndisPnPAddDevice;

        //
        // Set up unload handler
        //
        DriverInfo->DriverObject->DriverUnload = ndisMUnload;

        DriverInfo->DriverObject->MajorFunction[IRP_MJ_CREATE] = ndisCreateIrpHandler;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ndisDeviceControlIrpHandler;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_CLOSE] = ndisCloseIrpHandler;

        //
        // setup a handler for PnP messages
        //
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_PNP] = ndisPnPDispatch;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_POWER] = ndisPowerDispatch;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ndisWMIDispatch;

        //
        // Use this event to tell us when all adapters are removed from the mac
        // during an unload
        //
        INITIALIZE_EVENT(&MiniBlock->MiniportsRemovedEvent);

        // let the initial state stay reset, because the ref count
        // going to zero is going to signal the event
        
        MiniBlock->NdisDriverInfo = DriverInfo;
        InitializeListHead(&MiniBlock->DeviceList);

        ndisInitializeRef(&MiniBlock->Ref);

        //
        // Put Driver on global list.
        //
        PnPReferencePackage();
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        MiniBlock->NextDriver = ndisMiniDriverList;
        ndisMiniDriverList = MiniBlock;
        
        REF_NDIS_DRIVER_OBJECT();
        
        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        PnPDereferencePackage();

        *DriverHandle = MiniBlock;

        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisRegisterMiniportDriver: MiniBlock %p\n", MiniBlock));

    return Status;
}


NDIS_STATUS
NdisMRegisterDevice(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_STRING            DeviceName,
    IN  PNDIS_STRING            SymbolicName,
    IN  PDRIVER_DISPATCH    *   MajorFunctions,
    OUT PDEVICE_OBJECT      *   pDeviceObject,
    OUT NDIS_HANDLE         *   NdisDeviceHandle
    )
/*++

Routine Description:
    The NdisMRegisterDevice function creates a named device object and a symbolic link 
    between the device object and a user-visible name for that device.


Arguments:
    NdisWrapperHandle: Specifies the handle returned by NdisMInitializeWrapper. 
    
    DeviceName: Pointer to an NDIS_STRING type containing a zero-terminated Unicode string 
    that names the device object. The string must be a full-path namefor example, 
    \Device\DeviceName. For Windows 2000 and later, NDIS defines the NDIS_STRING type as 
    a UNICODE_STRING type.
    
    SymbolicName: Pointer to an NDIS_STRING type containing a Unicode string that is 
    the Win32-visible name of the device being registered. Typically, the SymbolicName has 
    the following format: \DosDevices\SymbolicName.
    
    MajorFunctions: Pointer to an array of one or more entry points for the device driver's 
    dispatch routines. A driver must set as many separate dispatch entry points as the IRP_MJ_XXX
    codes that the driver handles for the device object.
    
    pDeviceObject: Pointer to the newly created device object if the call succeeds. 
    
    NdisDeviceHandle: Pointer to a caller-supplied variable in which this function, 
    if it succeeds, returns a handle to the device object. This handle is a required 
    parameter to the NdisMDeregisterDevice function that the driver calls subsequently.

Return Value:
    Status of the call.

Callers of NdisMRegisterDevice run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PDRIVER_OBJECT          DriverObject;
    PDEVICE_OBJECT          DeviceObject;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_DEVICE_LIST       DeviceList = NULL;
    KIRQL                   OldIrql;

    *pDeviceObject = NULL;
    *NdisDeviceHandle = NULL;
    
    //
    // Check if the passed parameter is a NdisWrapperHandle or NdisMiniportHandle
    //
    if (DriverInfo->DriverObject == NULL)
    {
        Miniport = (PNDIS_MINIPORT_BLOCK)NdisWrapperHandle;
        MiniBlock = Miniport->DriverHandle;
    }
    else
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverInfo->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
    }

    if (MiniBlock != NULL)
    {
        DriverObject = MiniBlock->NdisDriverInfo->DriverObject;

        //
        // we need room for NDIS_WRAPPER_CONTEXT to align the singature
        // of this device with the one for miniport drivers.
        //
        Status = IoCreateDevice(DriverObject,                           // DriverObject
                                sizeof(NDIS_WRAPPER_CONTEXT) +
                                sizeof(NDIS_DEVICE_LIST) +              // DeviceExtension
                                DeviceName->Length + sizeof(WCHAR) +
                                SymbolicName->Length + sizeof(WCHAR),
                                DeviceName,                             // DeviceName
                                FILE_DEVICE_NETWORK,                    // DeviceType
                                FILE_DEVICE_SECURE_OPEN,                // DeviceCharacteristics
                                FALSE,                                  // Exclusive
                                &DeviceObject);                         // DeviceObject
    
        if (NT_SUCCESS(Status))
        {
            DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            Status = IoCreateSymbolicLink(SymbolicName, DeviceName);

            if (!NT_SUCCESS(Status))
            {
                IoDeleteDevice(DeviceObject);
            }
            else
            {
                DeviceList = (PNDIS_DEVICE_LIST)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
                RtlZeroMemory(DeviceList, sizeof(NDIS_DEVICE_LIST) +
                                          DeviceName->Length + sizeof(WCHAR) +
                                          SymbolicName->Length + sizeof(WCHAR));
        
                DeviceList->Signature = (PVOID)CUSTOM_DEVICE_MAGIC_VALUE;
                InitializeListHead(&DeviceList->List);
                DeviceList->MiniBlock = MiniBlock;
                DeviceList->DeviceObject = DeviceObject;

                //
                // this will copy the handlers up to but not including
                // IRP_MJ_PNP. so it will intentionally leave out
                // IRP_MJ_PNP and IRP_MJ_PNP_POWER
                //
                RtlCopyMemory(DeviceList->MajorFunctions,
                              MajorFunctions,
                              (IRP_MJ_PNP)*sizeof(PDRIVER_DISPATCH));
        
                DeviceList->DeviceName.Buffer = (PWCHAR)(DeviceList + 1);
                DeviceList->DeviceName.Length = DeviceName->Length;
                DeviceList->DeviceName.MaximumLength = DeviceName->Length + sizeof(WCHAR);
                RtlCopyMemory(DeviceList->DeviceName.Buffer,
                              DeviceName->Buffer,
                              DeviceName->Length);
        
                DeviceList->SymbolicLinkName.Buffer = (PWCHAR)((PUCHAR)DeviceList->DeviceName.Buffer + DeviceList->DeviceName.MaximumLength);
                DeviceList->SymbolicLinkName.Length = SymbolicName->Length;
                DeviceList->SymbolicLinkName.MaximumLength = SymbolicName->Length + sizeof(WCHAR);
                RtlCopyMemory(DeviceList->SymbolicLinkName.Buffer,
                              SymbolicName->Buffer,
                              SymbolicName->Length);
        
                PnPReferencePackage();
        
                ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);
        
                InsertHeadList(&MiniBlock->DeviceList, &DeviceList->List);
        
                RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
                PnPDereferencePackage();
        
                *pDeviceObject = DeviceObject;
                *NdisDeviceHandle = DeviceList;
            }
        }
    }
    else
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;
    }

    return Status;
}


NDIS_STATUS
NdisMDeregisterDevice(
    IN  NDIS_HANDLE             NdisDeviceHandle
    )
/*++

Routine Description:
    The NdisMDeregisterDevice function removes from the system a device object that was 
    created with NdisMRegisterDevice. NdisMDeregisterDevice also removes the symbolic link 
    that is associated with this device object.


Arguments:
    NdisDeviceHandle: Specifies the handle returned by NdisMRegisterDevice that identifies 
    the device object to be deregistered. 


Return Value:
    NdisMDeregisterDevice returns NDIS_STATUS_SUCCESS if the device object and its associated 
    symbolic link object are deleted.

Callers of NdisMDeregisterDevice run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_DEVICE_LIST       DeviceList = (PNDIS_DEVICE_LIST)NdisDeviceHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    KIRQL                   OldIrql;

    MiniBlock = DeviceList->MiniBlock;

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    RemoveEntryList(&DeviceList->List);

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();
    IoDeleteSymbolicLink(&DeviceList->SymbolicLinkName);
    IoDeleteDevice(DeviceList->DeviceObject);

    return NDIS_STATUS_SUCCESS;
}


VOID
NdisMRegisterUnloadHandler(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PDRIVER_UNLOAD          UnloadHandler
    )
/*++

Routine Description:
    The NdisMRegisterUnloadHandler function registers an unload handler for a driver.
    
Arguments:
    NdisWrapperHandle: Specifies the handle returned by NdisMInitializeWrapper. 

    UnloadHandler: Specifies the entry point for the driver's unload routine.
    
Return Value:
    None.
    
Callers of NdisMRegisterUnloadHandler run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;

    if (DriverInfo->DriverObject == NULL)
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)NdisWrapperHandle;
    }
    else
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverInfo->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
    }

    if (MiniBlock != NULL)
    {
        MiniBlock->UnloadHandler = UnloadHandler;
    }
}

NDIS_STATUS
NdisIMDeInitializeDeviceInstance(
    IN  NDIS_HANDLE             NdisMiniportHandle
    )
/*++

Routine Description:
    NdisIMDeInitializeDeviceInstance calls an NDIS intermediate driver's MiniportHalt 
    function to tear down the driver's virtual NIC.

Arguments:
    NdisMiniportHandle: Specifies the handle originally input to MiniportInitialize. 

Return Value:
    NdisIMDeInitializeDeviceInstance returns NDIS_STATUS_SUCCESS if the NIC has been 
    torn down. Otherwise, it can return NDIS_STATUS_FAILURE if the given NdisMiniportHandle 
    is invalid.
    
Callers of NdisIMDeInitializeDevice instance run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMDeInitializeDeviceInstance: Miniport %p\n", NdisMiniportHandle));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    Miniport = (PNDIS_MINIPORT_BLOCK)NdisMiniportHandle;
    MiniBlock = Miniport->DriverHandle;

    if (MINIPORT_INCREMENT_REF(Miniport))
    {
        ndisReferenceDriver(MiniBlock);

        //
        // for all practical purposes we want the same thing happens as in 
        // stopping the device, i.e. device objects remain and some certain fields that
        // get initialized during AddDevice to be preserved.
        //
        Miniport->PnPDeviceState = NdisPnPDeviceStopped;
        ndisPnPRemoveDevice(Miniport->DeviceObject, NULL);
        Miniport->CurrentDevicePowerState = PowerDeviceUnspecified;
        MINIPORT_DECREMENT_REF(Miniport);
        ndisDereferenceDriver(MiniBlock, FALSE);
        Status = NDIS_STATUS_SUCCESS;
    }
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMDeInitializeDeviceInstance: Miniport %p, Status %lx\n", NdisMiniportHandle, Status));

    return Status;
}

VOID
ndisMFinishQueuedPendingOpen(
    IN  PNDIS_POST_OPEN_PROCESSING      PostOpen
    )
/*++

Routine Description:
    This workitem Handles any pending NdisOpenAdapter() calls for miniports.

Arguments:
    PostOpen: a tempoary structure to carry the open information around

Return Value:
    None.

ndisMFinishQueuedPendingOpen is called at IRQL==PASSIVE

--*/
{
    PNDIS_OPEN_BLOCK    Open = PostOpen->Open;
    PNDIS_MINIPORT_BLOCK Miniport = Open->MiniportHandle;
    PNDIS_AF_NOTIFY     AfNotify = NULL;
    NDIS_STATUS         Status;
    KIRQL               OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisMFinishQueuedPendingOpen: PostOpen %p\n", PostOpen));

    PnPReferencePackage();
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    // If this is a binding that involves registration/open of address families, notify
    //
    ASSERT (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
            (Open->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL));

    Status = ndisCreateNotifyQueue(Miniport,
                                   Open,
                                   NULL,
                                   &AfNotify);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);


    if (AfNotify != NULL)
    {
        //
        // Notify existing clients of this registration
        //
        ndisNotifyAfRegistration(AfNotify);
    }
    

    FREE_POOL(PostOpen);    

    ndisDereferenceAfNotification(Open);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    ndisMDereferenceOpen(Open);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisMFinishQueuedPendingOpen: Open %p\n", Open));
}


NDIS_STATUS
NdisMRegisterIoPortRange(
    OUT PVOID   *               PortOffset,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts
    )

/*++

Routine Description:
    Sets up an IO port range for operations. in reality this function checks to make sure
    the I/O range is allocated to the device and if it is, it returns the translated
    I/O resources to the caller.

Arguments:
    PortOffset - The mapped port address the Miniport uses for NdisRaw functions.

    MiniportAdapterHandle - Handle passed to Miniport Initialize.

    InitialPort - Physical address of the starting port number.

    NumberOfPorts - Number of ports to map.

Return Value:
    None.

Callers of NdisMRegisterIoPortRange run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    PHYSICAL_ADDRESS                PortAddress;
    PHYSICAL_ADDRESS                InitialPortAddress;
    NDIS_STATUS                     Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;
#if !defined(_M_IX86)
    ULONG                           addressSpace;
#endif


    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMRegisterIoPortRange: Miniport %p\n", Miniport));

    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_IO;

    do
    {
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_REGISTER_IO))
        {
#if DBG
            DbgPrint("NdisMRegisterIoPortRange failed to verify miniport %p\n", Miniport);
#endif
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        InitialPortAddress.QuadPart = InitialPort;
        
#if !defined(_M_IX86)


        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypePort,
                                        InitialPortAddress,
                                        &PortAddress,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pResourceDescriptor->Type == CmResourceTypeMemory)
            addressSpace = 0;
        else
            addressSpace = (ULONG)-1;

        if (addressSpace == 0)
        {
            //
            // memory space
            //

            *(PortOffset) = (PULONG)MmMapIoSpace(PortAddress,
                                                 NumberOfPorts,
                                                 FALSE);

            if (*(PortOffset) == (PULONG)NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
        else
        {
            //
            // I/O space
            //
            *(PortOffset) = ULongToPtr(PortAddress.LowPart);
        }
#else   // x86 platform

        //
        // make sure the port belongs to the device
        //
        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypePort,
                                        InitialPortAddress,
                                        &PortAddress,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (pResourceDescriptor->Type == CmResourceTypeMemory)
        {
            //
            // memory space
            //

            *(PortOffset) = (PULONG)MmMapIoSpace(PortAddress,
                                                 NumberOfPorts,
                                                 FALSE);

            if (*(PortOffset) == (PULONG)NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
        else
        {
            //
            // I/O space
            //
            *(PortOffset) = (PULONG)PortAddress.LowPart;
        }
#endif
        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMRegisterIoPortRange: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}


VOID
NdisMDeregisterIoPortRange(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts,
    IN  PVOID                   PortOffset
    )

/*++

Routine Description:
    NdisMDeregisterIoPortRange releases a mapping that was set up with NdisMRegisterIoPortRange 
    during driver initialization.
    
Arguments:
    MiniportAdapterHandle: Specifies the handle input to MiniportInitialize. 
    
    InitialPort: Specifies the bus-relative address of the first port in the range of ports. 
    
    NumberOfPorts: Specifies the number of ports in the range. 
    
    PortOffset: Specifies the mapped base port address returned by NdisMRegisterIoPortRange. 

Return Value:
    None.

Callers of NdisMDeregisterIoPortRange run at IRQL = PASSIVE_LEVEL.

--*/
{
#if !DBG
    UNREFERENCED_PARAMETER(MiniportAdapterHandle);
#endif

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterIoPortRange: Miniport %p\n", MiniportAdapterHandle));

    UNREFERENCED_PARAMETER(InitialPort);
    UNREFERENCED_PARAMETER(NumberOfPorts);
    UNREFERENCED_PARAMETER(PortOffset);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterIoPortRange: Miniport %p\n", MiniportAdapterHandle));

    return;
}


NDIS_STATUS
NdisMMapIoSpace(
    OUT PVOID *                 VirtualAddress,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  UINT                    Length
    )
/*++

Routine Description:
    NdisMMapIoSpace maps a given bus-relative "physical" range of device RAM or registers 
    onto a system-space virtual range. in practice, NDIS makes sure the physical address
    range is assigned to the device and returns the virtual address if it is.

Arguments:
    Virtual Address: Pointer to a caller-supplied variable that is set to the converted 
    virtual address if the call is successful.
    
    MiniportAdapterHandle: Specifies the handle input to MiniportInitialize. 
    
    PhysicalAddress: Specifies the bus-relative base physical address of the device memory 
    range to be mapped.
    
    Length: Specifies the number of bytes to be mapped. 

Return Value:
    NDIS_STATUS_SUCCESS if the address range is assigned to the device and could be mapped
    to a virtual address. otherwise an error status code.

Callers of NdisMMapIoSpace run at IRQL = PASSIVE_LEVEL.    

--*/
{
    NDIS_STATUS                     Status;
    ULONG                           addressSpace = 0;
    PHYSICAL_ADDRESS                PhysicalTemp;
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMMapIoSpace\n"));
    
    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_MEMORY;

    if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_MAP_IO_SPACE))
    {
#if DBG
        DbgPrint("NdisMMapIoSpace failed to verify miniport %p\n", Miniport);
#endif
        *VirtualAddress = NULL;
        return NDIS_STATUS_RESOURCES;       
    }
    

    do
    {

#if !defined(_M_IX86)

        PhysicalTemp.HighPart = 0;

        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypeMemory,
                                        PhysicalAddress,
                                        &PhysicalTemp,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pResourceDescriptor->Type == CmResourceTypeMemory)
            addressSpace = 0;
        else
            //1 looks like this will never happen otherwise our NdisMUnmapIoSpace is broken
            
            addressSpace = (ULONG)-1;
#else
        addressSpace = 0;               // need to do MmMapIoSpace
        
        Status = ndisTranslateResources(Miniport,
                                         CmResourceTypeMemory,
                                         PhysicalAddress,
                                         &PhysicalTemp,
                                         &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {

            Status = NDIS_STATUS_FAILURE;
            break;
        }


#endif

        if (addressSpace == 0)
        {
            *VirtualAddress = MmMapIoSpace(PhysicalTemp, (Length), FALSE);
        }
        else
        {
            *VirtualAddress = ULongToPtr(PhysicalTemp.LowPart);
        }
        
        Status = NDIS_STATUS_SUCCESS;
        
        if (*VirtualAddress == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMMapIoSpace: Miniport %p, Status %lx\n", MiniportAdapterHandle, Status));

    return Status;
}


VOID
NdisMUnmapIoSpace(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
/*++

Routine Description:
    NdisMUnmapIoSpace releases a virtual range mapped by an initialization-time call to NdisMMapIoSpace.

Arguments:
    MiniportAdapterHandle: Specifies the handle originally input to MiniportInitialize. 
    
    VirtualAddress: Specifies the base virtual address for the mapped range that was returned 
    by NdisMMapIoSpace. 
    
    Length: Specifies the number of bytes in the range that was mapped with NdisMMapIoSpace. 
    
Return Value:
    None.
    
Callers of NdisMUnmapIoSpace run at IRQL = PASSIVE_LEVEL.

--*/
{
#if !DBG
    UNREFERENCED_PARAMETER(MiniportAdapterHandle);
#endif

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMUnmapIoSpace: Miniport %p\n", MiniportAdapterHandle));

    MmUnmapIoSpace(VirtualAddress, Length);

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMUnmapIoSpace: Miniport %p\n", MiniportAdapterHandle));
}


VOID
NdisMAllocateSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    OUT PVOID   *               VirtualAddress,
    OUT PNDIS_PHYSICAL_ADDRESS  PhysicalAddress
    )
/*++

Routine Description:
    NdisMAllocateSharedMemory allocates and maps a host memory range so it is simultaneously 
    accessible from both the system and a bus-master DMA NIC.


Arguments:
    MiniportAdapterHandle: Specifies the handle input to MiniportInitialize. 
    
    Length: Specifies the number of bytes to allocate. 

    Cached: Specifies TRUE if the range can be allocated from cached memory. 
    
    VirtualAddress: Pointer to a caller-supplied variable in which this function returns the 
    base virtual address of the allocation for use by the miniport driver.
    If NdisMAllocateSharedMemory cannot satisfy its caller, it returns NULL to indicate that no 
    memory was allocated.
    
    PhysicalAddress: Pointer to a caller-supplied variable in which this function returns 
    a physical address, suitable for use by the NIC, that corresponds to that returned at 
    VirtualAddress, or it returns NULL.
    
Return Value:
    None.
    
Callers of NdisMAllocateSharedMemory run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PDMA_ADAPTER            SystemAdapterObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext;
    PULONG                  Page;
    ULONG                   Type;
    PNDIS_SHARED_MEM_SIGNATURE pSharedMemSignature = NULL;
    KIRQL                   Irql;
    
    SystemAdapterObject = Miniport->SystemAdapterObject;
    WrapperContext = Miniport->WrapperContext;


    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMAllocateSharedMemory: Miniport %p, Length %lx\n", Miniport, Length));
    
    PhysicalAddress->HighPart = PhysicalAddress->LowPart = 0;

    if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_SHARED_MEM_ALLOC))
    {
#if DBG
        DbgPrint("NdisMAllocateSharedMemory failed to verify miniport %p\n", Miniport);
#endif
        *VirtualAddress = NULL;
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==NdisMAllocateSharedMemory: Miniport %p, Length %lx\n", Miniport, Length));
        return;
    }


    if (Miniport->SystemAdapterObject == NULL)
    {
        *VirtualAddress = NULL;
        return;
    }

    Irql = CURRENT_IRQL;
    if (Irql >= DISPATCH_LEVEL)
    {
        BAD_MINIPORT(Miniport, "Allocating Shared Memory at raised IRQL");
        KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                    1,
                    (ULONG_PTR)Miniport,
                    (ULONG_PTR)Length,
                    (ULONG_PTR)Irql);


    }

    //
    // Compute allocation size by aligning to the proper boundary.
    //
    ASSERT(Length != 0);

    Length = (Length + ndisDmaAlignment - 1) & ~(ndisDmaAlignment - 1);

    //
    // Check to determine is there is enough room left in the current page
    // to satisfy the allocation.
    //
    Type = Cached ? 1 : 0;
    ExAcquireResourceExclusiveLite(&SharedMemoryResource, TRUE);

    do
    {
        PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
        allocateCommonBuffer = *SystemAdapterObject->DmaOperations->AllocateCommonBuffer;

        if (WrapperContext->SharedMemoryLeft[Type] < Length)
        {
            if ((Length + sizeof(NDIS_SHARED_MEM_SIGNATURE)) >= PAGE_SIZE)
            {
                //
                // The allocation is greater than a page.
                //
                *VirtualAddress = allocateCommonBuffer(SystemAdapterObject,
                                                       Length,
                                                       PhysicalAddress,
                                                       Cached);
                
                break;
            }

            //
            // Allocate a new page for shared alocation.
            //
            WrapperContext->SharedMemoryPage[Type] =
                allocateCommonBuffer(SystemAdapterObject,
                                     PAGE_SIZE,
                                     &WrapperContext->SharedMemoryAddress[Type],
                                     Cached);

            if (WrapperContext->SharedMemoryPage[Type] == NULL)
            {
                WrapperContext->SharedMemoryLeft[Type] = 0;
                *VirtualAddress = NULL;
                break;
            }

            //
            // Initialize the reference count in the last ULONG of the page.
            // Initialize the Tag in the second last ulong of the page
            //
            Page = (PULONG)WrapperContext->SharedMemoryPage[Type];
            pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page+ (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));
            pSharedMemSignature->Tag = NDIS_TAG_SHARED_MEMORY;
            pSharedMemSignature->PageRef = 0;   
            WrapperContext->SharedMemoryLeft[Type] = PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE);
        }

        //
        // Increment the reference count, set the address of the allocation,
        // compute the physical address, and reduce the space remaining.
        //
        Page = (PULONG)WrapperContext->SharedMemoryPage[Type];

        //
        // First check whether Page is pointing to shared memory. Bugcheck to catch the driver
        //
        pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page+ (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));

        if (pSharedMemSignature->Tag  != NDIS_TAG_SHARED_MEMORY)
        {
            ASSERT (pSharedMemSignature->Tag == NDIS_TAG_SHARED_MEMORY);
            BAD_MINIPORT(Miniport, "Overwrote past allocated shared memory");
            KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                        2,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Page,
                        (ULONG_PTR)WrapperContext);
        }
        
        pSharedMemSignature->PageRef += 1;

        *VirtualAddress = (PVOID)((PUCHAR)Page +
                            (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE) - WrapperContext->SharedMemoryLeft[Type]));

        PhysicalAddress->QuadPart = WrapperContext->SharedMemoryAddress[Type].QuadPart +
                                        ((ULONG_PTR)(*VirtualAddress) & (PAGE_SIZE - 1));

        WrapperContext->SharedMemoryLeft[Type] -= Length;
    } while (FALSE);

    if (*VirtualAddress)
    {
        InterlockedIncrement(&Miniport->DmaAdapterRefCount);
    }

    ExReleaseResourceLite(&SharedMemoryResource);

#if DBG
    if (*VirtualAddress == NULL)
    {
         DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
            ("NdisMAllocateSharedMemory: Miniport %p, allocateCommonBuffer failed for %lx bytes\n", Miniport, Length));

    }
#endif                    
        
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_64BITS_DMA) &&
        (PhysicalAddress->HighPart > 0))
    {
         
#if DBG
        DbgPrint("NdisMAllocateSharedMemory: Miniport %p, allocateCommonBuffer returned a physical address > 4G for a"
                 " non-64bit DMA adapter. PhysAddress->HighPart = %p", Miniport, PhysicalAddress->HighPart);
#endif

        ASSERT(PhysicalAddress->HighPart == 0);
        
    }

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMAllocateSharedMemory: Miniport %p, Length %lx, Virtual Address %p\n", Miniport, Length, *VirtualAddress));


    
}

NDIS_STATUS
NdisMAllocateSharedMemoryAsync(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   Context
    )
/*++

Routine Description:
    NdisMAllocateSharedMemoryAsync allocates additional memory shared between a miniport driver 
    and its bus-master DMA NIC, usually when the miniport driver is running low on available NIC 
    receive buffers. 


Arguments:
    MiniportAdapterHandle: Specifies the handle originally input to MiniportInitialize. 

    Length: Specifies the number of bytes to allocate. 
    
    Cached: Specifies TRUE if the memory can be cached. 
    
    Context: Pointer to driver-detemined context to be passed to the MiniportAllocateComplete 
    function when it is called. 


Return Value:
    NDIS_STATUS_PENDING The caller's MiniportAllocateComplete function will be called. 
    otherwise the error code.

Callers of NdisMAllocateSharedMemoryAsync run at IRQL <= DISPATCH_LEVEL.    

--*/
{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;
    PASYNC_WORKITEM         pWorkItem = NULL;


    // Allocate a workitem
    if ((Miniport->SystemAdapterObject != NULL) &&
        (Miniport->DriverHandle->MiniportCharacteristics.AllocateCompleteHandler != NULL))
    {
        pWorkItem = ALLOC_FROM_POOL(sizeof(ASYNC_WORKITEM), NDIS_TAG_ALLOC_SHARED_MEM_ASYNC);
    }

    if ((pWorkItem == NULL) ||
        !MINIPORT_INCREMENT_REF(Miniport))
    {
        if (pWorkItem != NULL)
            FREE_POOL(pWorkItem);
        return NDIS_STATUS_FAILURE;
    }

    InterlockedIncrement(&Miniport->DmaAdapterRefCount);

    // Initialize the workitem and queue it up to a worker thread
    pWorkItem->Miniport = Miniport;
    pWorkItem->Length = Length;
    pWorkItem->Cached = Cached;
    pWorkItem->Context = Context;
    INITIALIZE_WORK_ITEM(&pWorkItem->ExWorkItem, ndisMQueuedAllocateSharedHandler, pWorkItem);
    QUEUE_WORK_ITEM(&pWorkItem->ExWorkItem, CriticalWorkQueue);

    return NDIS_STATUS_PENDING;
}


VOID
ndisMQueuedAllocateSharedHandler(
    IN  PASYNC_WORKITEM         pWorkItem
    )
/*++

Routine Description:
    callback function to allocate shared memory for callers of NdisMAllocateSharedMemoryAsync.

Arguments:
    pWorkItem: allocation workitem.

Return Value:
    None.

  
ndisMQueuedAllocateSharedHandler is called at IRQL==PASSIVE.    

--*/
{
    KIRQL   OldIrql;


    // Allocate the memory
    NdisMAllocateSharedMemory(pWorkItem->Miniport,
                              pWorkItem->Length,
                              pWorkItem->Cached,
                              &pWorkItem->VAddr,
                              &pWorkItem->PhyAddr);

    //
    // we shouldn't need to reference package here
    //
    ASSERT(ndisPkgs[NDSM_PKG].ReferenceCount > 0);

    if (MINIPORT_TEST_FLAG(pWorkItem->Miniport, fMINIPORT_DESERIALIZE))
    {
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(pWorkItem->Miniport, &OldIrql);
    }

    // Call the miniport back
    (*pWorkItem->Miniport->DriverHandle->MiniportCharacteristics.AllocateCompleteHandler)(
                                pWorkItem->Miniport->MiniportAdapterContext,
                                pWorkItem->VAddr,
                                &pWorkItem->PhyAddr,
                                pWorkItem->Length,
                                pWorkItem->Context);

    if (MINIPORT_TEST_FLAG(pWorkItem->Miniport, fMINIPORT_DESERIALIZE))
    {
        KeLowerIrql(OldIrql);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(pWorkItem->Miniport, OldIrql);
    }

    ndisDereferenceDmaAdapter(pWorkItem->Miniport);

    // Dereference the miniport
    MINIPORT_DECREMENT_REF(pWorkItem->Miniport);

    // And finally free the work-item
    FREE_POOL(pWorkItem);
}


VOID
ndisFreeSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
/*++

Routine Description:
    Common routine to be called from NdisMFreeSharedMemory (when it is called at PASSIVE)
    or the callback routine ndisMQueuedFreeSharedHandler if NdisMFreeSharedMemory was
    called at DISPATCH.
    
Arguments:
    MiniportAdapterHandle: Specifies the handle originally input to MiniportInitialize. 

    Length: Specifies the number of bytes originally allocated. 
    
    Cached: Specifies TRUE if the original allocation was cacheable. 
    
    VirtualAddress: Specifies the base virtual address returned by NdisMAllocateSharedMemory(Async). 
    
    PhysicalAddress: Specifies the corresponding physical address returned by NdisMAllocateSharedMemory(Async). 

Return Value:
    None.
    
ndisFreeSharedMemory runs at IRQL == PASSIVE.    

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PDMA_ADAPTER            SystemAdapterObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext;
    PULONG                  Page;
    ULONG                   Type;
    PNDIS_SHARED_MEM_SIGNATURE pSharedMemSignature = NULL; 
    PFREE_COMMON_BUFFER     freeCommonBuffer;
    
    //
    // Get interesting information from the miniport.
    //
    SystemAdapterObject = Miniport->SystemAdapterObject;
    WrapperContext = Miniport->WrapperContext;
    

    if (SystemAdapterObject == NULL)
    {
        if (Miniport->SavedSystemAdapterObject)
            SystemAdapterObject = Miniport->SavedSystemAdapterObject;

        //
        // Non-busmasters shouldn't call this routine.
        //
        ASSERT(SystemAdapterObject != NULL);

#if DBG
        DbgPrint("Ndis: WARNING... Miniport %p freeing shared memory -after- freeing map registers.\n", Miniport);

        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_VERIFYING) && (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING))
            DbgBreakPoint();

#endif
        Miniport->SystemAdapterObject = Miniport->SavedSystemAdapterObject;

    }


    freeCommonBuffer = *SystemAdapterObject->DmaOperations->FreeCommonBuffer;

    //
    // Compute allocation size by aligning to the proper boundary.
    //
    ASSERT(Length != 0);
    
    Length = (Length + ndisDmaAlignment - 1) & ~(ndisDmaAlignment - 1);
    
    //
    // Free the specified memory.
    //
    ExAcquireResourceExclusiveLite(&SharedMemoryResource, TRUE);
    if ((Length + sizeof(NDIS_SHARED_MEM_SIGNATURE)) >= PAGE_SIZE)
    {
        //
        // The allocation is greater than a page free the page directly.
        //
        freeCommonBuffer(SystemAdapterObject,
                         Length,
                         PhysicalAddress,
                         VirtualAddress,
                         Cached);
    
    }
    else
    {
        //
        // Decrement the reference count and if the result is zero, then free
        // the page.
        //
    
        Page = (PULONG)((ULONG_PTR)VirtualAddress & ~(PAGE_SIZE - 1));
        //
        // First check whether Page is pointing to shared memory. Bugcheck to catch the driver
        //
        pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page + (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));
        
        if (pSharedMemSignature->Tag != NDIS_TAG_SHARED_MEMORY)
        {
            ASSERT (pSharedMemSignature->Tag == NDIS_TAG_SHARED_MEMORY);
            BAD_MINIPORT(Miniport, "Freeing shared memory not allocated");
            KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                        3,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Page,
                        (ULONG_PTR)VirtualAddress);
  
        }

        pSharedMemSignature->PageRef -= 1;

        //
        //  If the references on the page have gone to zero then free the page
        //
        
        if (pSharedMemSignature->PageRef == 0)
        {
            //
            // Compute the physical address of the page and free it.
            //

            PhysicalAddress.LowPart &= ~(PAGE_SIZE - 1);
            freeCommonBuffer(SystemAdapterObject,
                             PAGE_SIZE,
                             PhysicalAddress,
                             Page,
                             Cached);

            Type = Cached ? 1 : 0;
            if ((PVOID)Page == WrapperContext->SharedMemoryPage[Type])
            {
                WrapperContext->SharedMemoryLeft[Type] = 0;
                WrapperContext->SharedMemoryPage[Type] = NULL;
            }
        }
    }

    ndisDereferenceDmaAdapter(Miniport);

    ExReleaseResourceLite(&SharedMemoryResource);
}
VOID
NdisMFreeSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
/*++

Routine Description:
    NdisMFreeSharedMemory frees memory that was previously allocated by NdisMAllocateSharedMemory
    or NdisMAllocateSharedMemoryAsync by the driver of a bus-master DMA NIC.

Arguments:
    MiniportAdapterHandle: Specifies the handle originally input to MiniportInitialize. 

    Length: Specifies the number of bytes originally allocated. 
    
    Cached: Specifies TRUE if the original allocation was cacheable. 
    
    VirtualAddress: Specifies the base virtual address returned by NdisMAllocateSharedMemory(Async). 
    
    PhysicalAddress: Specifies the corresponding physical address returned by NdisMAllocateSharedMemory(Async). 

Return Value:
    None.
    
Callers of NdisMFreeSharedMemory run at IRQL <= DISPATCH_LEVEL

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PASYNC_WORKITEM pWorkItem = NULL;
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMFreeSharedMemory: Miniport %p, Length %lx, VirtualAddress %lx\n", 
                        Miniport, Length, VirtualAddress));

    if (CURRENT_IRQL < DISPATCH_LEVEL)
    {
        ndisFreeSharedMemory(MiniportAdapterHandle,
                             Length,
                             Cached,
                             VirtualAddress,
                             PhysicalAddress);
    }
    else
    {
        MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);

        // Allocate a work-item and queue it up to a worker thread
        pWorkItem = ALLOC_FROM_POOL(sizeof(ASYNC_WORKITEM), NDIS_TAG_FREE_SHARED_MEM_ASYNC);
        if (pWorkItem != NULL)
        {
            // Initialize the workitem and queue it up to a worker thread
            pWorkItem->Miniport = Miniport;
            pWorkItem->Length = Length;
            pWorkItem->Cached = Cached;
            pWorkItem->VAddr = VirtualAddress;
            pWorkItem->PhyAddr = PhysicalAddress;
            INITIALIZE_WORK_ITEM(&pWorkItem->ExWorkItem, ndisMQueuedFreeSharedHandler, pWorkItem);
            QUEUE_WORK_ITEM(&pWorkItem->ExWorkItem, CriticalWorkQueue);
        }
        else
        {
            //1 what to do now?
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMFreeSharedMemory: Miniport %p, Length %lx, VirtualAddress %lx\n", 
                        Miniport, Length, VirtualAddress));
}

VOID
ndisMQueuedFreeSharedHandler(
    IN  PASYNC_WORKITEM         pWorkItem
    )
/*++

Routine Description:
    callback routine to free shared memory if NdisMFreeSharedMemory is called at DISPATCH.

Arguments:
    Free workitem.

Return Value:
    None.

ndisMQueuedFreeSharedHandler runs at IRQL==PASSIVE.    

--*/
{
    // Free the memory
    ndisFreeSharedMemory(pWorkItem->Miniport,
                         pWorkItem->Length,
                         pWorkItem->Cached,
                         pWorkItem->VAddr,
                         pWorkItem->PhyAddr);

    // Dereference the miniport
    MINIPORT_DECREMENT_REF(pWorkItem->Miniport);

    // And finally free the work-item
    FREE_POOL(pWorkItem);
}


NDIS_STATUS
NdisMRegisterDmaChannel(
    OUT PNDIS_HANDLE            MiniportDmaHandle,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  BOOLEAN                 Dma32BitAddresses,
    IN  PNDIS_DMA_DESCRIPTION   DmaDescription,
    IN  ULONG                   MaximumLength
    )
/*++

Routine Description:
    NdisMRegisterDmaChannel claims a system DMA controller channel during initialization 
    for DMA operations on a slave NIC or on an ISA bus-master NIC.
    
Arguments:
    MiniportDmaHandle: Pointer to a caller-supplied variable in which this function returns 
    a handle the miniport driver uses in subsequent calls to the NdisMXxx system DMA functions. 
    
    MiniportAdapterHandle: Specifies the handle input to MiniportInitialize. 
    
    DmaChannel: Ignored. Set the DMA channel, if any, at DmaDescription. 
    
    Dma32BitAddresses: Specifies TRUE if the NIC has 32 address lines.
    
    DmaDescription: Pointer to an NDIS_DMA_DESCRIPTION structure filled in by the caller.
    
    DemandMode: Specifies TRUE if the slave NIC uses the system DMA controller's demand mode. 
    
    AutoInitialize: Specifies TRUE if the slave NIC uses the system DMA controller's autoinitialize mode. 
    
    DmaChannelSpecified: Specifies TRUE if DmaChannel is set to the bus-relative value of the 
    system DMA controller channel used by the NIC. 
    
    DmaWidth: Specifies the transfer width for DMA operations, one of Width8Bits, 
    Width16Bits, or Width32Bits. 
    
    DmaSpeed: Specifies one of Compatible, TypeA, TypeB, or TypeC. 
    
    DmaPort: This refers to the MCA bus, which is no longer supported. This member must be zero. 
    
    DmaChannel: Specifies the bus-relative number of the system DMA controller channel used by the NIC.
    
    MaximumLength: Specifies the maximum number of bytes the NIC can transfer in a single DMA operation. 
    If the NIC has unlimited transfer capacity,set this parameter to -1.
    
Return Value:
    Status of the request.

Callers of NdisMRegisterDmaChannel run at IRQL = PASSIVE_LEVEL.

--*/
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    NDIS_STATUS                     Status;
    NDIS_INTERFACE_TYPE             BusType;
    ULONG                           BusNumber;
    DEVICE_DESCRIPTION              DeviceDescription;
    PDMA_ADAPTER                    AdapterObject = NULL;
    ULONG                           MapRegistersNeeded;
    ULONG                           MapRegistersAllowed;
    PNDIS_DMA_BLOCK                 DmaBlock;
    KIRQL                           OldIrql;
    NTSTATUS                        NtStatus;

    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMRegisterDmaChannel: Miniport %p\n", Miniport));

    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;

    do
    {
        //
        // Set up the device description; zero it out in case its
        // size changes.
        //
    
        ZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));
    
        DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    
        DeviceDescription.Master = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER);
    
        DeviceDescription.ScatterGather = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER);
    
        DeviceDescription.DemandMode = DmaDescription->DemandMode;
        DeviceDescription.AutoInitialize = DmaDescription->AutoInitialize;
    
        DeviceDescription.Dma32BitAddresses = Dma32BitAddresses;
    
        DeviceDescription.BusNumber = Miniport->BusNumber;
        DeviceDescription.DmaChannel = DmaChannel;
        DeviceDescription.InterfaceType = BusType;
        DeviceDescription.DmaWidth = DmaDescription->DmaWidth;
        DeviceDescription.DmaSpeed = DmaDescription->DmaSpeed;
        DeviceDescription.MaximumLength = MaximumLength;
        DeviceDescription.DmaPort = DmaDescription->DmaPort;
    
        MapRegistersNeeded = ((MaximumLength - 2) / PAGE_SIZE) + 2;
    
        //
        // Get the adapter object.
        //
        AdapterObject =
                    IoGetDmaAdapter(Miniport->PhysicalDeviceObject,
                                    &DeviceDescription,
                                    &MapRegistersAllowed);
    
        if ((AdapterObject == NULL) || (MapRegistersAllowed < MapRegistersNeeded))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

    
        //
        // Allocate storage for our DMA block.
        //
        DmaBlock = (PNDIS_DMA_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_DMA_BLOCK), NDIS_TAG_DMA);
    
        if (DmaBlock == (PNDIS_DMA_BLOCK)NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        // Use this event to tell us when ndisAllocationExecutionRoutine
        // has been called.
        //
        INITIALIZE_EVENT(&DmaBlock->AllocationEvent);
        (PNDIS_MINIPORT_BLOCK)DmaBlock->Miniport = Miniport;
        
        //
        // We save this to call IoFreeAdapterChannel later.
        //
        (PDMA_ADAPTER)DmaBlock->SystemAdapterObject = AdapterObject;
    
        ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
        PnPReferencePackage();
    
        //
        // Now allocate the adapter channel.
        //
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
    
        NtStatus = AdapterObject->DmaOperations->AllocateAdapterChannel(AdapterObject,
                                                                        Miniport->DeviceObject,
                                                                        MapRegistersNeeded,
                                                                        ndisDmaExecutionRoutine,
                                                                        (PVOID)DmaBlock);
    
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        
        PnPDereferencePackage();
    
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));

            FREE_POOL(DmaBlock);
            Status = NDIS_STATUS_RESOURCES;

            break;
        }
    
    
        //
        // ndisDmaExecutionRoutine will set this event
        // when it has been called.
        //
        NtStatus = WAIT_FOR_OBJECT(&DmaBlock->AllocationEvent, 0);
    
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));

            FREE_POOL(DmaBlock);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        RESET_EVENT(&DmaBlock->AllocationEvent);
    
        //
        // We now have the DMA channel allocated, we are done.
        //
        DmaBlock->InProgress = FALSE;
    
        *MiniportDmaHandle = (NDIS_HANDLE)DmaBlock;
        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    if (Status == NDIS_STATUS_SUCCESS)
    {
        Miniport->SystemAdapterObject = AdapterObject;
        ASSERT(Miniport->DmaAdapterRefCount == 0);
        InterlockedIncrement(&Miniport->DmaAdapterRefCount);
    }
    else if (AdapterObject != NULL)
    {
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
        AdapterObject->DmaOperations->PutDmaAdapter(AdapterObject);
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);        
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMRegisterDmaChannel: Miniport %p, Status %lx\n", Miniport, Status));
    
    return Status;
}



VOID
NdisMDeregisterDmaChannel(
    IN  NDIS_HANDLE             MiniportDmaHandle
    )
/*++

Routine Description:
    NdisMDeregisterDmaChannel releases a miniport driver's claim on a DMA channel for its NIC. 

Arguments:
    MiniportDmaHandle: Specifies the handle returned by NdisMRegisterDmaChannel. 


Return Value:
    None.
    
Callers of NdisMDeregisterDmaChannel run at IRQL = PASSIVE_LEVEL. 

--*/
{
    KIRQL           OldIrql;
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)MiniportDmaHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)DmaBlock->Miniport;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterDmaChannel\n"));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    ((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FreeAdapterChannel(DmaBlock->SystemAdapterObject);
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    ndisDereferenceDmaAdapter(Miniport);

    PnPDereferencePackage();

    FREE_POOL(DmaBlock);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterDmaChannel\n"));

}


NDIS_STATUS
NdisMAllocateMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  NDIS_DMA_SIZE           DmaSize,
    IN  ULONG                   BaseMapRegistersNeeded,
    IN  ULONG                   MaximumPhysicalMapping
    )
/*++

Routine Description:
    Allocates map registers for bus mastering devices.

Arguments:

    MiniportAdapterHandle: Handle passed to MiniportInitialize.

    DmaChannel: Specifies the bus-relative DMA channel for an ISA bus-master NIC.
    If the NIC is on another type of I/O bus, this parameter must be zero. 

    Specifies the address size that the NIC uses for DMA operations as one of the following: 
    NDIS_DMA_24BITS or NDIS_DMA_32BITS or NDIS_DMA_64BITS
    
    BaseMapRegistersNeeded: The maximum number of base map registers needed
    by the Miniport at any one time.

    MaximumPhysicalMapping:  Maximum length of a buffer that will have to be mapped.

Return Value:
    Status of the allocation request.
    
Callers of NdisMAllocateMapRegisters run at IRQL = PASSIVE_LEVEL.

--*/

{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;

    //
    // This is needed by HalGetAdapter.
    //
    DEVICE_DESCRIPTION DeviceDescription;

    //
    // Returned by HalGetAdapter.
    //
    ULONG MapRegistersAllowed;

    //
    // Returned by IoGetDmaAdapter.
    //
    PDMA_ADAPTER AdapterObject;

    PALLOCATE_ADAPTER_CHANNEL   allocateAdapterChannel;
    PFREE_MAP_REGISTERS         freeMapRegisters;
    
    //
    // Map registers needed per channel.
    //
    ULONG MapRegistersPerChannel;

    NTSTATUS    NtStatus;
    KIRQL       OldIrql;
    USHORT      i;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    BOOLEAN     AllocationFailed;
    KEVENT      AllocationEvent;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMAllocateMapRegisters: Miniport %p, BaseMapRegistersNeeded %lx\n", Miniport, BaseMapRegistersNeeded));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    ASSERT(Miniport->SystemAdapterObject == NULL);

    do
    {
    
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_MAP_REG_ALLOC))
        {
#if DBG
            DbgPrint("NdisMAllocateMapRegisters failed to verify miniport %p\n", Miniport);
#endif
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        // If the device is a busmaster, we get an adapter
        // object for it.
        // If map registers are needed, we loop, allocating an
        // adapter channel for each map register needed.
        //

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER))
        {

            Miniport->BaseMapRegistersNeeded = (USHORT)BaseMapRegistersNeeded;
            Miniport->MaximumPhysicalMapping = MaximumPhysicalMapping;

            //
            // Allocate storage for holding the appropriate
            // information for each map register.
            //

            Miniport->MapRegisters = NULL;
            if (BaseMapRegistersNeeded > 0)
            {
                Miniport->MapRegisters = (PMAP_REGISTER_ENTRY)
                        ALLOC_FROM_POOL(sizeof(MAP_REGISTER_ENTRY) * BaseMapRegistersNeeded,
                                        NDIS_TAG_MAP_REG);
            
                if (Miniport->MapRegisters == (PMAP_REGISTER_ENTRY)NULL)
                {
                    //
                    // Error out
                    //

                    NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                           NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                           1,
                                           0xFFFFFFFF);

                    Status =  NDIS_STATUS_RESOURCES;
                    break;
                }
            }

            //
            // Use this event to tell us when ndisAllocationExecutionRoutine
            // has been called.
            //

            Miniport->AllocationEvent = &AllocationEvent;
            INITIALIZE_EVENT(&AllocationEvent);

            //
            // Set up the device description; zero it out in case its
            // size changes.
            //

            ZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));

            DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            DeviceDescription.Master = TRUE;
            DeviceDescription.ScatterGather = TRUE;

            DeviceDescription.BusNumber = Miniport->BusNumber;
            DeviceDescription.DmaChannel = DmaChannel;
            DeviceDescription.InterfaceType = Miniport->AdapterType;

            if (DeviceDescription.InterfaceType == NdisInterfaceIsa)
            {
                //
                // For ISA devices, the width is based on the DMA channel:
                // 0-3 == 8 bits, 5-7 == 16 bits. Timing is compatibility
                // mode.
                //

                if (DmaChannel > 4)
                {
                    DeviceDescription.DmaWidth = Width16Bits;
                }
                else
                {
                    DeviceDescription.DmaWidth = Width8Bits;
                }
                DeviceDescription.DmaSpeed = Compatible;

            }
            //1 maybe non-PCI devices can do 64 bit DMA in the future.
            else if (DeviceDescription.InterfaceType == NdisInterfacePci)
            {
                if (DmaSize == NDIS_DMA_32BITS)
                {
                    DeviceDescription.Dma32BitAddresses = TRUE;
                }
                else if (DmaSize == NDIS_DMA_64BITS)
                {
                    DeviceDescription.Dma64BitAddresses = TRUE;
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_64BITS_DMA);
                }
            }

            DeviceDescription.MaximumLength = MaximumPhysicalMapping;

            //
            // Determine how many map registers we need per channel.
            //
            MapRegistersPerChannel = ((MaximumPhysicalMapping - 2) / PAGE_SIZE) + 2;
            
#if DBG
            if (MapRegistersPerChannel > 16)
            {
                DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_WARN,
                    ("NdisMAllocateMapRegisters: Miniport %p, MaximumPhysicalMapping of 0x%lx\nwould require more than 16 MAP registers per channel, the call may fail\n",
                    Miniport, MaximumPhysicalMapping));
                            
            }           
#endif


            NDIS_WARN((Miniport->BaseMapRegistersNeeded * MapRegistersPerChannel > 0x40),
                      Miniport, 
                      NDIS_GFLAG_WARN_LEVEL_0,
                      ("ndisMInitializeAdapter: Miniport %p is asking for too many %ld > 64 map registers.\n",
                       Miniport, Miniport->BaseMapRegistersNeeded * MapRegistersPerChannel
                      ));


            //
            // Get the adapter object.
            //

            AdapterObject =
                            IoGetDmaAdapter(Miniport->PhysicalDeviceObject, &DeviceDescription, &MapRegistersAllowed);

            if ((AdapterObject == NULL) || (MapRegistersAllowed < MapRegistersPerChannel))
            {
                NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                       NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                       1,
                                       0xFFFFFFFF);

                FREE_POOL(Miniport->MapRegisters);
                Miniport->MapRegisters = NULL;
                Status = NDIS_STATUS_RESOURCES;
                
                if (AdapterObject != NULL)
                {
                    RAISE_IRQL_TO_DISPATCH(&OldIrql);
                    ((PDMA_ADAPTER)AdapterObject)->DmaOperations->PutDmaAdapter((PDMA_ADAPTER)AdapterObject);
                    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                }
                break;
            }

            //
            // We save this to call IoFreeMapRegisters later.
            //

            Miniport->SystemAdapterObject = AdapterObject;
            Miniport->SavedSystemAdapterObject = NULL;
            ASSERT(Miniport->DmaAdapterRefCount == 0);
            InterlockedIncrement(&Miniport->DmaAdapterRefCount);
            
            allocateAdapterChannel = *AdapterObject->DmaOperations->AllocateAdapterChannel;
            freeMapRegisters = *AdapterObject->DmaOperations->FreeMapRegisters;

            AllocationFailed = FALSE;

            //
            // Allocate a map register array, then try our private HAL
            // API to allocate a wad of map registers in one fell swoop,
            // otherwise fall back to the old-skewl method
            //
            // NOTE: HalAllocateMapRegisterArray must be called at PASSIVE,
            //       and also does not support "legacy" adapters
            //
            if (DeviceDescription.InterfaceType != NdisInterfaceIsa)
            {
                
                NtStatus =
                    HalAllocateMapRegisters((PVOID)AdapterObject,
                                            MapRegistersPerChannel,
                                            Miniport->BaseMapRegistersNeeded,
                                            Miniport->MapRegisters);
                
                if (!NT_SUCCESS(NtStatus))
                {
                    FREE_POOL(Miniport->MapRegisters);
                    Miniport->MapRegisters = NULL;
                    ndisDereferenceDmaAdapter(Miniport);
                    AllocationFailed = TRUE;
                }

            } 
            else 
            {

                //
                // Now loop, allocating an adapter channel each time, then
                // freeing everything but the map registers.
                //
                for (i=0; i<Miniport->BaseMapRegistersNeeded; i++)
                {
                    Miniport->CurrentMapRegister = i;
                    
                    RAISE_IRQL_TO_DISPATCH(&OldIrql);
                    
                    NtStatus = allocateAdapterChannel(AdapterObject,
                                                      Miniport->DeviceObject,
                                                      MapRegistersPerChannel,
                                                      ndisAllocationExecutionRoutine,
                                                      Miniport);
                    
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                                 ("AllocateAdapterChannel: %lx\n", NtStatus));
                        
                        for (; i != 0; i--)
                        {
                            freeMapRegisters(Miniport->SystemAdapterObject,
                                             Miniport->MapRegisters[i-1].MapRegister,
                                             MapRegistersPerChannel);
                        }
                        
                        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                        
                        NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                               NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                               1,
                                               0xFFFFFFFF);
                        
                        FREE_POOL(Miniport->MapRegisters);
                        Miniport->MapRegisters = NULL;
                        
                        ndisDereferenceDmaAdapter(Miniport);
                        AllocationFailed = TRUE;
                        break;
                    }
                    
                    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                    
                    
                    //
                    // wait indefinitely for allocation routine to be called
                    //
                    NtStatus = WAIT_FOR_OBJECT(&AllocationEvent, 0);
                    
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                                 ("    NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));
                        
                        RAISE_IRQL_TO_DISPATCH(&OldIrql);
                        
                        for (; i != 0; i--)
                        {
                            freeMapRegisters(Miniport->SystemAdapterObject,
                                             Miniport->MapRegisters[i-1].MapRegister,
                                             MapRegistersPerChannel);
                        }
                        
                        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                        
                        NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                               NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                               1,
                                               0xFFFFFFFF);
                        
                        FREE_POOL(Miniport->MapRegisters);
                        Miniport->MapRegisters = NULL;
                        
                        ndisDereferenceDmaAdapter(Miniport);
                        
                        AllocationFailed = TRUE;
                        break;
                    }
                    
                    RESET_EVENT(&AllocationEvent);
                }
            }

            if (AllocationFailed)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }

    } while (FALSE);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMAllocateMapRegisters: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}


VOID
NdisMFreeMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )

/*++

Routine Description:

    Releases allocated map registers

Arguments:

    MiniportAdapterHandle - Handle passed to MiniportInitialize.

Return Value:

    None.

--*/

{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;
    PFREE_MAP_REGISTERS freeMapRegisters;
    KIRQL OldIrql;
    ULONG i;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMFreeMapRegisters: Miniport %p\n", Miniport));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER));
    ASSERT(Miniport->MapRegisters != NULL);
    ASSERT(Miniport->SystemAdapterObject != NULL);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER) &&
        (Miniport->MapRegisters != NULL))
    {
        ULONG MapRegistersPerChannel =
            ((Miniport->MaximumPhysicalMapping - 2) / PAGE_SIZE) + 2;

        freeMapRegisters = *Miniport->SystemAdapterObject->DmaOperations->FreeMapRegisters;

        
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
        for (i = 0; i < Miniport->BaseMapRegistersNeeded; i++)
        {

            freeMapRegisters(Miniport->SystemAdapterObject,
                             Miniport->MapRegisters[i].MapRegister,
                             MapRegistersPerChannel);

        }
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

        //
        // Map registers are allocated from non-paged pool.
        // So this memory can be freed at DISPATCH
        //
        FREE_POOL(Miniport->MapRegisters);
        Miniport->MapRegisters = NULL;
                
        ndisDereferenceDmaAdapter(Miniport);
    }

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMFreeMapRegisters: Miniport %p\n", Miniport));
}


ULONG
NdisMReadDmaCounter(
    IN  NDIS_HANDLE             MiniportDmaHandle
    )
/*++

Routine Description:

    Reads the current value of the dma counter

Arguments:

    MiniportDmaHandle - Handle for the DMA transfer.

Return Value:

    current value of a DMA counter

--*/

{
    return ((PDMA_ADAPTER)((PNDIS_DMA_BLOCK)(MiniportDmaHandle))->SystemAdapterObject)->DmaOperations->ReadDmaCounter(((PNDIS_DMA_BLOCK)(MiniportDmaHandle))->SystemAdapterObject);
}


VOID
ndisBugcheckHandler(
    IN  PNDIS_WRAPPER_CONTEXT   WrapperContext,
    IN  ULONG                   Size
    )
/*++

Routine Description:

    This routine is called when a bugcheck occurs in the system.

Arguments:

    Buffer  -- Ndis wrapper context.

    Size    -- Size of wrapper context

Return Value:

    Void.

--*/
{
    PNDIS_MINIPORT_BLOCK        Miniport;
    
    if (Size == sizeof(NDIS_WRAPPER_CONTEXT))
    {
        Miniport = (PNDIS_MINIPORT_BLOCK)(WrapperContext + 1);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN);

        if (WrapperContext->ShutdownHandler != NULL)
        {
            WrapperContext->ShutdownHandler(WrapperContext->ShutdownContext);
        }
    }
}


VOID
NdisMRegisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  PVOID                   ShutdownContext,
    IN  ADAPTER_SHUTDOWN_HANDLER ShutdownHandler
    )
/*++

Routine Description:

    Deregisters an NDIS adapter.

Arguments:

    MiniportHandle - The miniport.

    ShutdownHandler - The Handler for the Adapter, to be called on shutdown.

Return Value:

    none.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;
    PNDIS_WRAPPER_CONTEXT WrapperContext = Miniport->WrapperContext;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMRegisterAdapterShutdownHandler: Miniport %p\n", Miniport));

    if (WrapperContext->ShutdownHandler == NULL)
    {
        //
        // Store information
        //

        WrapperContext->ShutdownHandler = ShutdownHandler;
        WrapperContext->ShutdownContext = ShutdownContext;

        //
        // Register our shutdown handler for a bugcheck.  (Note that we are
        // already registered for shutdown notification.)
        //

        KeInitializeCallbackRecord(&WrapperContext->BugcheckCallbackRecord);

        KeRegisterBugCheckCallback(&WrapperContext->BugcheckCallbackRecord, // callback record.
                                   ndisBugcheckHandler,                     // callback routine.
                                   WrapperContext,                          // free form buffer.
                                   sizeof(NDIS_WRAPPER_CONTEXT),            // buffer size.
                                   (PUCHAR)"Ndis miniport");                // component id.
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMRegisterAdapterShutdownHandler: Miniport %p\n", Miniport));
}


VOID
NdisMDeregisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:

Arguments:

    MiniportHandle - The miniport.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;
    PNDIS_WRAPPER_CONTEXT WrapperContext = Miniport->WrapperContext;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterAdapterShutdownHandler: Miniport %p\n", Miniport));

    //
    // Clear information
    //

    if (WrapperContext->ShutdownHandler != NULL)
    {
        KeDeregisterBugCheckCallback(&WrapperContext->BugcheckCallbackRecord);
        WrapperContext->ShutdownHandler = NULL;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterAdapterShutdownHandler: Miniport %p\n", Miniport));
}


NDIS_STATUS
NdisMPciAssignResources(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  ULONG                   SlotNumber,
    OUT PNDIS_RESOURCE_LIST *   AssignedResources
    )
/*++

Routine Description:

    This routine uses the Hal to assign a set of resources to a PCI
    device.

Arguments:

    MiniportHandle - The miniport.

    SlotNumber - Slot number of the device.

    AssignedResources - The returned resources.

Return Value:

    Status of the operation

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMPciAssignResources: Miniport %p\n", Miniport));
    
    UNREFERENCED_PARAMETER(SlotNumber);

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisMPciAssignResources: Miniport %p should use NdisMQueryAdapterResources to get resources.\n", Miniport));

    if ((Miniport->BusType != NdisInterfacePci) || (Miniport->AllocatedResources == NULL))
    {
        *AssignedResources = NULL;
        DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==NdisMPciAssignResources: Miniport %p\n", Miniport));
        return NDIS_STATUS_FAILURE;
    }

    *AssignedResources = &Miniport->AllocatedResources->List[0].PartialResourceList;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMPciAssignResources: Miniport %p\n", Miniport));

    return NDIS_STATUS_SUCCESS;
}

VOID
NdisMQueryAdapterResources(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PNDIS_RESOURCE_LIST     ResourceList,
    IN  IN  PUINT               BufferSize
    )
/*++

Routine Description:
    NdisMQueryAdapterResources returns a list of hardware resources for a NIC.
    
Arguments:
    Status: Pointer to a caller-supplied variable in which this function returns the status of the call. 

    WrapperConfigurationContext: Specifies the handle input to MiniportInitialize. 

    ResourceList: Pointer to a caller-allocated buffer in which this function returns a set of hardware resources for the caller's NIC. 

    BufferSize: Pointer to a variable that specifies the size in bytes of the caller-allocated buffer on input and the number of bytes of information returned by this call. 

Return Value:
    None.
    
Callers of NdisMQueryAdapterResources run at IRQL = PASSIVE_LEVEL.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    PNDIS_MINIPORT_BLOCK Miniport;
    ULONG               MemNeeded;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("==>NdisMQueryAdapterResources: WrapperConfigurationContext %p\n", WrapperConfigurationContext));

    DeviceObject = ((PNDIS_WRAPPER_CONFIGURATION_HANDLE)WrapperConfigurationContext)->DeviceObject;
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("NdisMQueryAdapterResources: Miniport %p\n", Miniport));

    if (Miniport->AllocatedResources == NULL)
    {
        *Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        MemNeeded = sizeof(CM_PARTIAL_RESOURCE_LIST) - sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                        + Miniport->AllocatedResources->List[0].PartialResourceList.Count *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        if (*BufferSize < MemNeeded)
        {
            *BufferSize = MemNeeded;
            *Status = NDIS_STATUS_RESOURCES;
        }
        else
        {

            NdisMoveMemory(
                        ResourceList,
                        &Miniport->AllocatedResources->List[0].PartialResourceList,
                        MemNeeded
                        );

            *Status = NDIS_STATUS_SUCCESS;
        }
    }

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("<==NdisMQueryAdapterResources: Miniport %p, Status %lx\n", Miniport, *Status));

    return;

}


NTSTATUS
ndisPnPAddDevice(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    )
/*++

Routine Description:

    The AddDevice entry point is called by the Plug & Play manager
    to inform the driver when a new device instance arrives that this
    driver must control.

Arguments:
    DriverObject: The driver object for the device.
    
    PhysicalDeviceObject: Physical Device Object of the device.

Return Value:
    STATUS_SUCCESS if NDIS code successfully add this device. 
    Otherwise Appropriate error code.

ndisPnPAddDevice is called at IRQL=PASSIVE.


--*/
{
    NTSTATUS                NtStatus, Status;
    PWSTR                   ExportData = NULL;
    UNICODE_STRING          ExportName;
    HANDLE                  Handle = NULL;
    PUINT                   CharacteristicsData = NULL;
    ULONG                   ValueType;
    RTL_QUERY_REGISTRY_TABLE LQueryTable[3];

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPAddDevice: DriverObject %p, PDO %p\n", DriverObject, PhysicalDeviceObject));

    Status = STATUS_UNSUCCESSFUL;

    do
    {
#if NDIS_TEST_REG_FAILURE
        NtStatus = STATUS_UNSUCCESSFUL;
#else
        NtStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                           PLUGPLAY_REGKEY_DRIVER,
                                           GENERIC_READ | MAXIMUM_ALLOWED,
                                           &Handle);

#endif

#if !NDIS_NO_REGISTRY

        if (!NT_SUCCESS(NtStatus))
            break;

        //
        // 1.
        // Switch to the Linkage key below this driver instance key
        //
        LQueryTable[0].QueryRoutine = NULL;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LQueryTable[0].Name = L"Linkage";

        //
        // 2.
        // Read the export and rootdevice keywords
        //
        LQueryTable[1].QueryRoutine = ndisReadParameter;
        LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[1].Name = L"Export";
        LQueryTable[1].EntryContext = (PVOID)&ExportData;
        LQueryTable[1].DefaultType = REG_NONE;

        LQueryTable[2].QueryRoutine = NULL;
        LQueryTable[2].Flags = 0;
        LQueryTable[2].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          NULL,
                                          NULL);

        if (!NT_SUCCESS(NtStatus) || (ExportData == NULL))
            break;

        RtlInitUnicodeString(&ExportName, ExportData);

        //
        // 3.
        // Read the bus-type and characteristics keywords
        //
        LQueryTable[0].QueryRoutine = ndisReadParameter;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[0].Name = L"Characteristics";
        LQueryTable[0].EntryContext = (PVOID)&CharacteristicsData;
        LQueryTable[0].DefaultType = REG_NONE;

        LQueryTable[1].QueryRoutine = NULL;
        LQueryTable[1].Flags = 0;
        LQueryTable[1].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          &ValueType,
                                          NULL);


#else
        ExportData = (PWSTR)ALLOC_FROM_POOL(sizeof(NDIS_DEFAULT_EXPORT_NAME),
                                                        NDIS_TAG_NAME_BUF);
        if (ExportData == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlCopyMemory(ExportData, ndisDefaultExportName, sizeof(NDIS_DEFAULT_EXPORT_NAME));
        RtlInitUnicodeString(&ExportName, ExportData);

#endif
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisPnPAddDevice: Device: "));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,
                &ExportName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("\n"));
                
        Status = ndisAddDevice(DriverObject,
                               &ExportName,
                               PhysicalDeviceObject,
                               (CharacteristicsData != NULL) ? *CharacteristicsData : 0);

    } while (FALSE);

    if (Handle)
        ZwClose(Handle);

    if (ExportData != NULL)
        FREE_POOL(ExportData);

    if (CharacteristicsData != NULL)
        FREE_POOL(CharacteristicsData);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("    ndisPnPAddDevice returning %lx\n", Status));

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPAddDevice: PDO %p\n", PhysicalDeviceObject));

    return Status;
}

NDIS_STATUS
FASTCALL
ndisPnPStartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp     OPTIONAL
    )
/*+++
Routine Description:

    The handler for IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.
    Adapter - a pointer to either AdapterBlock or MiniportBlock

Return Value:
    NDIS_STATUS_SUCCESS if intializing the device was successful

Note: This routine can also be called from NdisImInitializeDeviceInstanceEx in which case
        the Irp woud be NULL.

ndisPnPStartDevice is called at IRQL=PASSIVE.

---*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PCM_RESOURCE_LIST       AllocatedResources, AllocatedResourcesTranslated, pTempResources = NULL;
    NDIS_STATUS             Status;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   MemNeeded = 0;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPStartDevice: DeviceObject\n", DeviceObject));

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisPnPStartDevice: Miniport %p, ", Miniport));
    DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,  Miniport->pAdapterInstanceName);
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO, ("\n"));

    if (Miniport->PnPDeviceState == NdisPnPDeviceStopped)
    {
        //
        // re-initialize the miniport block structure without destroying what
        // we set during AddDevice
        //
        ndisReinitializeMiniportBlock(Miniport);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_RECEIVED_START);
    }

    do
    {
        if (Irp != NULL)
        {
            IrpSp = IoGetCurrentIrpStackLocation (Irp);

            //
            // save allocated resources with miniport/adapter structure
            //
            AllocatedResources = IrpSp->Parameters.StartDevice.AllocatedResources;
            AllocatedResourcesTranslated = IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

            if (AllocatedResources)
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE);

                if (AllocatedResources->List[0].PartialResourceList.Count == 0)
                {
                    MemNeeded = sizeof(CM_RESOURCE_LIST);
                }
                else
                {
                    MemNeeded = sizeof(CM_RESOURCE_LIST)  - sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                                AllocatedResources->List[0].PartialResourceList.Count *
                                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                }
                
                pTempResources = (PCM_RESOURCE_LIST)ALLOC_FROM_POOL(2 * MemNeeded, NDIS_TAG_ALLOCATED_RESOURCES);

                if (pTempResources == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                NdisMoveMemory(pTempResources, AllocatedResources, MemNeeded);
                NdisMoveMemory((PUCHAR)pTempResources + MemNeeded,
                            IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated, MemNeeded);

#if DBG
                if ((ndisDebugLevel == DBG_LEVEL_INFO) &&
                    (ndisDebugSystems & DBG_COMP_PNP))
                {
                    UINT j;
                    PCM_PARTIAL_RESOURCE_LIST pResourceList;

                    DbgPrint("ndisPnPStartDevice: Miniport %p, Non-Translated allocated resources\n", Miniport);

                    pResourceList = &(AllocatedResources->List[0].PartialResourceList);

                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        switch (pResourceList->PartialDescriptors[j].Type)
                        {
                          case CmResourceTypePort:
                            DbgPrint("IO Port: %p, Length: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Port.Start.LowPart,
                                pResourceList->PartialDescriptors[j].u.Port.Length);
                            break;

                          case CmResourceTypeMemory:
                            DbgPrint("Memory: %p, Length: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart,
                                pResourceList->PartialDescriptors[j].u.Memory.Length);
                            break;

                          case CmResourceTypeInterrupt:
                            DbgPrint("Interrupt Level: %lx, Vector: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Interrupt.Level,
                                pResourceList->PartialDescriptors[j].u.Interrupt.Vector);
                            break;

                          case CmResourceTypeDma:
                            DbgPrint("DMA Channel: %lx\n", pResourceList->PartialDescriptors[j].u.Dma.Channel);
                            break;
                        }
                    }

                    DbgPrint("ndisPnPStartDevice: Miniport %p, Translated allocated resources\n", Miniport);

                    pResourceList = &(AllocatedResourcesTranslated->List[0].PartialResourceList);

                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        switch (pResourceList->PartialDescriptors[j].Type)
                        {

                            case CmResourceTypePort:
                                DbgPrint("IO Port: %p, Length: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Port.Start.LowPart,
                                    pResourceList->PartialDescriptors[j].u.Port.Length);
                                break;

                            case CmResourceTypeMemory:
                                DbgPrint("Memory: %p, Length: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart,
                                    pResourceList->PartialDescriptors[j].u.Memory.Length);
                                break;

                            case CmResourceTypeInterrupt:
                                DbgPrint("Interrupt Level: %lx, Vector: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Interrupt.Level,
                                    pResourceList->PartialDescriptors[j].u.Interrupt.Vector);
                                break;

                            case CmResourceTypeDma:
                                DbgPrint("DMA Channel: %lx\n", pResourceList->PartialDescriptors[j].u.Dma.Channel);
                                break;

                        }
                    }
                }
#endif
            } // end of if AllocatedResources != NULL
        }

        Miniport->AllocatedResources = pTempResources;
        Miniport->AllocatedResourcesTranslated = (PCM_RESOURCE_LIST)((PUCHAR)pTempResources + MemNeeded);

        Status = ndisInitializeAdapter(Miniport->DriverHandle,
                                       DeviceObject,
                                       Miniport->pAdapterInstanceName,
                                       Miniport->DeviceContext);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Miniport->PnPDeviceState = NdisPnPDeviceStarted;
            NdisSetEvent(&Miniport->OpenReadyEvent);
            KeQueryTickCount(&Miniport->NdisStats.StartTicks);            
        }
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPnPStartDevice: Miniport %p\n", Miniport));

    return Status;
}


NTSTATUS
ndisQueryReferenceBusInterface(
    IN  PDEVICE_OBJECT              PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE*   pBusInterface
    )
/*++

Routine Description:

    Queries the bus for the standard information interface.

Arguments:

    PnpDeviceObject -
        Contains the next device object on the Pnp stack.

    PhysicalDeviceObject -
        Contains the physical device object which was passed to the FDO during
        the Add Device.

    BusInterface -
        The place in which to return the pointer to the Reference interface.

Return Value:

    Returns STATUS_SUCCESS if the interface was retrieved, else an error.

ndisQueryReferenceBusInterface is called at IRQL = PASSIVE.

--*/
{
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;

    PAGED_CODE();

    *pBusInterface = (PBUS_INTERFACE_REFERENCE)ALLOC_FROM_POOL(sizeof(BUS_INTERFACE_REFERENCE), NDIS_TAG_BUS_INTERFACE);
    if (*pBusInterface == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    INITIALIZE_EVENT(&Event);
    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       PnpDeviceObject,
                                       NULL,
                                       0,
                                       NULL,
                                       &Event,
                                       &IoStatusBlock);
    if (Irp != NULL)
    {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);

        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)&REFERENCE_BUS_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.Size = sizeof(**pBusInterface);
        IrpStackNext->Parameters.QueryInterface.Version = BUS_INTERFACE_REFERENCE_VERSION;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)*pBusInterface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        Status = IoCallDriver(PnpDeviceObject, Irp);
        if (Status == STATUS_PENDING)
        {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            WAIT_FOR_OBJECT(&Event, NULL);
            Status = IoStatusBlock.Status;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
        FREE_POOL(*pBusInterface);
        *pBusInterface = NULL;
    }

    return Status;
}


NTSTATUS
ndisAddDevice(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         pExportName,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    IN  ULONG                   Characteristics
    )
/*++

Routine Description:

    The AddDevice entry point is called by ndisPnPAddDevice to create a new miniport.

Arguments:

    DriverObject: the driver object for the miniport.

    pExportName: a unicode string initialized by reading Linkage\Export fro the miniport from
    the registry.

    PhysicalDeviceObject: Physical Device Object for the miniport.

    Characteristics: the Characteristics of the device read from registry.
    
Return Value:
    NDIS_STTAUS_SUCCESS if NDIS code successfully add the miniport.
    Otherwise an appropriate error code.

    
ndisAddDevice is called at IRQL = PASSIVE.

--*/
{
    PDEVICE_OBJECT          NextDeviceObject = NULL;
    NTSTATUS                NtStatus, Status = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT          DevicePtr = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    PNDIS_M_DRIVER_BLOCK    MiniBlock, TmpMiniBlock;
    LONG                    Size;
    BOOLEAN                 FreeDevice = FALSE;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisAddDevice: PDO %p\n", PhysicalDeviceObject));

    PnPReferencePackage();

    do
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
        ASSERT(MiniBlock != NULL);

        if (MiniBlock != NULL)
        {
            //
            // check to make sure the mini block is on our queue
            //
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

            TmpMiniBlock = ndisMiniDriverList;

            while (TmpMiniBlock)
            {
                if (TmpMiniBlock == MiniBlock)
                    break;
                    
                TmpMiniBlock = TmpMiniBlock->NextDriver;
            }
            
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

            ASSERT(TmpMiniBlock == MiniBlock);
            
            if (TmpMiniBlock != MiniBlock)
            {
#if TRACK_UNLOAD
                DbgPrint("ndisAddDevice: AddDevice called with a MiniBlock that is not on ndisMiniDriverList\n");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            4,
                            (ULONG_PTR)MiniBlock,
                            (ULONG_PTR)DriverObject,
                            (ULONG_PTR)0);


#endif
                break;
            }
        }
        else
        {
            break;
        }

        //
        // create DeviceObject and Miniport/Adapter structure now,
        // we will set a few field here and the rest will be set during
        // processing IRP_MN_START_DEVICE and InitializeAdapter call.
        //
        // Note: We need the device-name field double null terminated.
        //
        Size = sizeof(NDIS_MINIPORT_BLOCK) +
               sizeof(NDIS_WRAPPER_CONTEXT) +
               pExportName->Length + sizeof(WCHAR) + sizeof(WCHAR);

        NtStatus = IoCreateDevice(DriverObject,
                                  Size,
                                  pExportName,
                                  FILE_DEVICE_PHYSICAL_NETCARD,
                                  FILE_DEVICE_SECURE_OPEN,
                                  FALSE,      // exclusive flag
                                  &DevicePtr);


        if(!NT_SUCCESS(NtStatus))
            break;

        DevicePtr->Flags &= ~DO_DEVICE_INITIALIZING;
        DevicePtr->Flags |= DO_DIRECT_IO;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        FreeDevice = TRUE;

        //
        //  Mark the device as being pageable.
        //
        DevicePtr->Flags |= DO_POWER_PAGABLE;

        //
        //  Attach our FDO to the PDO. This routine will return the top most
        //  device that is attached to the PDO or the PDO itself if no other
        //  device objects have attached to it.
        //
        NextDeviceObject = IoAttachDeviceToDeviceStack(DevicePtr, PhysicalDeviceObject);

        if (NextDeviceObject == NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        ZeroMemory(DevicePtr->DeviceExtension, Size);

        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DevicePtr->DeviceExtension + 1);

        Miniport->Signature = (PVOID)MINIPORT_DEVICE_MAGIC_VALUE;
        Miniport->DriverHandle = MiniBlock;
        //
        // initialize OpenReady event in case we get an open request before start IRP
        //
        NdisInitializeEvent(&Miniport->OpenReadyEvent);
        INITIALIZE_SPIN_LOCK(&Miniport->Lock);

        if (Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
            INITIALIZE_SPIN_LOCK(&Miniport->TimerQueueLock);

        Miniport->PrimaryMiniport = Miniport;

        Miniport->PnPDeviceState = NdisPnPDeviceAdded;
        
        Miniport->PhysicalDeviceObject = PhysicalDeviceObject;
        Miniport->DeviceObject = DevicePtr;
        Miniport->NextDeviceObject = NextDeviceObject;

        Miniport->WrapperContext = DevicePtr->DeviceExtension;
        InitializeListHead(&Miniport->PacketList);

        //
        // intialize the reference and set it to 0; we will increment it
        // in ndisMinitializeAdapter
        //
        ndisInitializeULongRef(&Miniport->Ref);
        Miniport->Ref.ReferenceCount = 0;
#ifdef TRACK_MINIPORT_REFCOUNTS
        M_LOG_MINIPORT_SET_REF(Miniport, 0);
#endif
        
        //
        // Read the characteristics. This determines if the device is hidden or not (from device-manager)
        //
        if (Characteristics & 0x08)
        {
            //
            // Bit 0x08 is NCF_HIDDEN
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HIDDEN);
        }

        if (Characteristics & 0x02)
        {
            //
            // Bit 0x02 is NCF_SOFTWARE_ENUMERATED
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SWENUM);
        }

        //
        // MiniportName must follow the MINIPORT_BLOCK.
        //
        ndisSetDeviceNames(pExportName,
                           &Miniport->MiniportName,
                           &Miniport->BaseName,
                           (PUCHAR)Miniport + sizeof(NDIS_MINIPORT_BLOCK));

        NtStatus = ndisCreateAdapterInstanceName(&Miniport->pAdapterInstanceName,
                                                 PhysicalDeviceObject);

        if (!NT_SUCCESS(NtStatus))
        {
            break;
        }

        Miniport->InstanceNumber = (USHORT)InterlockedIncrement((PLONG)&ndisInstanceNumber);

        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisAddDevice: Miniport %p, ", Miniport));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,
                Miniport->pAdapterInstanceName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));

        if (Characteristics & 0x02)
        {
            PBUS_INTERFACE_REFERENCE    BusInterface = NULL;

            Status = ndisQueryReferenceBusInterface(PhysicalDeviceObject, &BusInterface);
            if (NT_SUCCESS(Status))
            {
                Miniport->BusInterface = BusInterface;
            }
            else
            {
                ASSERT(BusInterface == NULL);
                FREE_POOL(Miniport->pAdapterInstanceName);
                break;
            }
        }
        
        //
        // create a security descriptor for the device
        //
        Status = ndisCreateSecurityDescriptor(Miniport->DeviceObject, 
                                              &Miniport->SecurityDescriptor,
                                              TRUE,
                                              FALSE);

        if (!NT_SUCCESS(Status))
        {
            FREE_POOL(Miniport->pAdapterInstanceName);
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Status = STATUS_SUCCESS;

        
        //
        //  Don't want to free up the device object.
        //
        FreeDevice = FALSE;
        
    } while (FALSE);

    if (FreeDevice)
    {
        //
        // if device is created it is also attached
        //
        if (NextDeviceObject)
            IoDetachDevice(NextDeviceObject);

        IoDeleteDevice(DevicePtr);
        DevicePtr = NULL;
        Miniport = NULL;
    }

    if (Miniport && (NT_SUCCESS(Status)))
    {
        //
        // if DevicePtr is not NULL, we do have a valid
        // miniport. queue the miniport on global miniport queue
        //
        ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
        Miniport->NextGlobalMiniport = ndisMiniportList;
        ndisMiniportList = Miniport;
        RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);
    }
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisAddDevice: Miniport %p\n", Miniport));

    return Status;
}


VOID
ndisSetDeviceNames(
    IN  PNDIS_STRING            ExportName,
    OUT PNDIS_STRING            DeviceName,
    OUT PNDIS_STRING            BaseName,
    IN  PUCHAR                  Buffer
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    DeviceName->Buffer = (PWSTR)Buffer;
    DeviceName->Length = ExportName->Length;
    DeviceName->MaximumLength = DeviceName->Length + sizeof(WCHAR);
    RtlUpcaseUnicodeString(DeviceName,
                           ExportName,
                           FALSE);

    //
    // ExportName is in the form of \Device\<AdapterName>
    // Extract BaseName which is the name w/o the "\Device\"
    //
    BaseName->Buffer = DeviceName->Buffer + (ndisDeviceStr.Length/sizeof(WCHAR));
    BaseName->Length = DeviceName->Length - ndisDeviceStr.Length;
    BaseName->MaximumLength = BaseName->Length + sizeof(WCHAR);
}


NTSTATUS
FASTCALL
ndisPnPQueryStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    NTSTATUS             Status;
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    KIRQL                OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPQueryStopDevice: Miniport %p\n", Miniport));

    do
    {
        if (Miniport->PnPCapabilities & NDIS_DEVICE_NOT_STOPPABLE)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // query_stop and stop are not reported to the user mode
        // so we have to protect ourselves against cases that apps
        // may have pending IO against the miniport
        //

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);                    
        if (Miniport->UserModeOpenReferences != 0)
        {
            Status = STATUS_UNSUCCESSFUL;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // for now do the same as query remove
        //
        Status = ndisPnPQueryRemoveDevice(DeviceObject, Irp);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPQueryStopDevice: Miniport %p\n", Miniport));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPCancelStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    NTSTATUS    Status;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPCancelStopDevice\n"));

    //
    // for now do the same as cancel remove
    //
    Status = ndisPnPCancelRemoveDevice(DeviceObject, Irp);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPCancelStopDevice\n"));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    NTSTATUS    Status;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPStopDevice\n"));

    //
    // do the same as remove
    //
    Status = ndisPnPRemoveDevice(DeviceObject, Irp);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPStopDevice\n"));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPQueryRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Irp);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPQueryRemoveDevice: Miniport %p, UserModeOpenReferences %lx\n", Miniport, Miniport->UserModeOpenReferences));

    do
    {
        //
        // If this was the network card used in a remote boot, then we
        // can't remove it.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_NETBOOT_CARD))
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Status = ndisPnPNotifyAllTransports(Miniport,
                                            NetEventQueryRemoveDevice,
                                            NULL,
                                            0);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPQueryRemoveDevice: Miniport %p, Status 0x%x\n", Miniport, Status));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPCancelRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = NDIS_STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Irp);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPCancelRemoveDevice: Miniport %p\n", Miniport));

    Status = ndisPnPNotifyAllTransports(Miniport,
                                        NetEventCancelRemoveDevice,
                                        NULL,
                                        0);


    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPCancelRemoveDevice: Miniport %p\n", Miniport));

    return STATUS_SUCCESS;
}

NTSTATUS
FASTCALL
ndisPnPRemoveDevice(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp     OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = NDIS_STATUS_SUCCESS;
    KIRQL                   OldIrql;
    BOOLEAN                 fAcquiredImMutex = FALSE;
    PKMUTEX                 pIMStartRemoveMutex = NULL;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPRemoveDevice: Miniport %p\n", Miniport));

    UNREFERENCED_PARAMETER(Irp);

    PnPReferencePackage();

    //
    // there are three different cases that we can get a remove request
    // a:   the request is coming from PnP manager in response to a user mode
    //      app. In this case, the remove has been proceeded by a query remove
    //      which we happily failed if there was any legacy protocol bound to
    //      the adapter
    //
    // b.   the request is coming from PnP manager because Starting the device failed
    //      in this case (hopefully) there is no binding at all. in this case it is not
    //      proceeded by query_remove and neet not be. we don't have any protocol bound
    //      to the adapter to worry about
    //
    // c.   or it can come in response to a surprise style removal in which case we are
    //      hosed anyway. sending query_remove to protocols does not do any good
    //

    do
    {
        PNDIS_M_DRIVER_BLOCK    MiniBlock;
        PNDIS_MINIPORT_BLOCK    TmpMiniport;

        //
        // find the miniport on driver queue
        //
        MiniBlock = Miniport->DriverHandle;

        if (MiniBlock == NULL)
            break;

        //
        // Intermediate drivers could be in the middle of initialization through the 
        // NdisIMInitializeDeviceInstance Code path. We need to synchronize
        //
        if (MiniBlock->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
        {
            pIMStartRemoveMutex = &MiniBlock->IMStartRemoveMutex;

            WAIT_FOR_OBJECT(pIMStartRemoveMutex, NULL);

            fAcquiredImMutex = TRUE;
        }

        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        for (TmpMiniport = MiniBlock->MiniportQueue;
             TmpMiniport != NULL;
             TmpMiniport = TmpMiniport->NextMiniport)
        {
            if (TmpMiniport == Miniport)
            {
                break;
            }
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
        if ((TmpMiniport != Miniport) || (Miniport->Ref.Closing == TRUE))
        {
            Miniport->Ref.Closing = TRUE;
            break;
        }

        ndisReferenceDriver(MiniBlock);

        NdisResetEvent(&Miniport->OpenReadyEvent);

        //
        //  Notify WMI of adapter removal.
        //
        if (Miniport->pAdapterInstanceName != NULL)
        {
            PWNODE_SINGLE_INSTANCE  wnode;
            PUCHAR                  ptmp;
            NTSTATUS                NtStatus;

            ndisSetupWmiNode(Miniport,
                             Miniport->pAdapterInstanceName,
                             Miniport->MiniportName.Length + sizeof(USHORT),
                             (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
                             &wnode);

            if (wnode != NULL)
            {
                //
                //  Save the number of elements in the first ULONG.
                //
                ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
                *((PUSHORT)ptmp) = Miniport->MiniportName.Length;

                //
                //  Copy the data after the number of elements.
                //
                RtlCopyMemory(ptmp + sizeof(USHORT),
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);

                //
                //  Indicate the event to WMI. WMI will take care of freeing
                //  the WMI struct back to pool.
                //
                NtStatus = IoWMIWriteEvent(wnode);
                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisPnPRemoveDevice: Failed to indicate adapter removal\n"));

                    FREE_POOL(wnode);
                }
            }
        }

        //
        // this will take care of closing all the bindings
        //
        ndisCloseMiniportBindings(Miniport);

        if (Miniport->pIrpWaitWake)
        {
            if (IoCancelIrp(Miniport->pIrpWaitWake))
            {
                Miniport->pIrpWaitWake = NULL;
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisPnPRemoveDevice: Miniport %p, Successfully canceled wake irp\n", Miniport));

            }
        }

        //
        // get rid of wakeup patterns set on the miniport. we can have
        // leftover patterns if the device failed and we did not get a chance
        // to remove the patterns
        //
        {
            PSINGLE_LIST_ENTRY          Link;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
            
            while (Miniport->PatternList.Next != NULL)
            {
                Link = PopEntryList(&Miniport->PatternList);
                pPatternEntry = CONTAINING_RECORD(Link, NDIS_PACKET_PATTERN_ENTRY, Link);
                //
                //  Free the memory taken by the pattern.
                //
                FREE_POOL(pPatternEntry);
            }                               
        }
        

        //
        // and this one will take care of the rest!
        // we call this function even if the device has already been halted by 
        // ndisPMHaltMiniport. because that functions does not clean up everything.
        // ndisMHaltMiniport will check for PM_HALTED flag and avoid re-doing what PMHalt
        // has already done.
        //
        ndisMHaltMiniport(Miniport);

        //
        // Free the media-request structure, if present
        //
        if (Miniport->MediaRequest != NULL)
        {
            FREE_POOL(Miniport->MediaRequest);
            Miniport->MediaRequest = NULL;
        }

        ndisDereferenceDriver(MiniBlock, FALSE);

        {
            UNICODE_STRING  SymbolicLink;
            NTSTATUS        NtStatus;
            WCHAR           SymLnkBuf[128];

            SymbolicLink.Buffer = SymLnkBuf;
            SymbolicLink.Length = 0;
            SymbolicLink.MaximumLength = sizeof(SymLnkBuf);
            RtlCopyUnicodeString(&SymbolicLink, &ndisDosDevicesStr);

            NtStatus = RtlAppendUnicodeStringToString(&SymbolicLink,
                                           &Miniport->BaseName);
            if (!NT_SUCCESS(NtStatus))
            {
#if DBG
                DbgPrint("ndisPnPRemoveDevice: creating symbolic link name failed for miniport %p, SymbolicLinkName %p, NtStatus %lx\n",
                             Miniport, &SymbolicLink, NtStatus);        
#endif
            }
            else
            {

                NtStatus = IoDeleteSymbolicLink(&SymbolicLink);
                if (!NT_SUCCESS(NtStatus))
                {
#if DBG
                    DbgPrint("ndisPnPRemoveDevice: deleting symbolic link name failed for miniport %p, SymbolicLinkName %p, NtStatus %lx\n",
                             Miniport, &SymbolicLink, NtStatus);        
#endif
                }
            }
            
        }
        
    } while (FALSE);

    if(fAcquiredImMutex  == TRUE)
    {
        RELEASE_MUTEX(pIMStartRemoveMutex);
    }

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPRemoveDevice: Miniport %p\n", Miniport));

    return Status;
}
    
    //1 this function has been the source of many bugs, Redesign.
VOID
FASTCALL
ndisReinitializeMiniportBlock(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PDEVICE_OBJECT          PhysicalDeviceObject, DeviceObject, NextDeviceObject;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    NextGlobalMiniport;
    UNICODE_STRING          BaseName, MiniportName;
    PUNICODE_STRING         InstanceName;
    PNDIS_BIND_PATHS        BindPaths;
    PVOID                   WrapperContext;
    NDIS_HANDLE             DeviceContext;
    ULONG                   PnPCapabilities;
    ULONG                   FlagsToSave = 0;
    ULONG                   PnPFlagsToSave = 0;
    DEVICE_POWER_STATE      CurrentDevicePowerState;
    PVOID                   BusInterface;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    USHORT                  InstanceNumber;
    KIRQL                   OldIrql;
        
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisReinitializeMiniportBlock: Miniport %p\n", Miniport));

    //
    // this part should be protected
    //
    ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);

    PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
    DeviceObject= Miniport->DeviceObject;
    NextDeviceObject = Miniport->NextDeviceObject;
    MiniBlock = Miniport->DriverHandle;
    WrapperContext = Miniport->WrapperContext;
    BaseName = Miniport->BaseName;
    MiniportName = Miniport->MiniportName;
    InstanceName = Miniport->pAdapterInstanceName;
    DeviceContext = Miniport->DeviceContext;
    BindPaths = Miniport->BindPaths;
    PnPCapabilities = Miniport->PnPCapabilities;
    PnPFlagsToSave = Miniport->PnPFlags & (fMINIPORT_RECEIVED_START | 
                                           fMINIPORT_SWENUM | 
                                           fMINIPORT_HIDDEN |
                                           fMINIPORT_HARDWARE_DEVICE |
                                           fMINIPORT_NDIS_WDM_DRIVER |
                                           fMINIPORT_FILTER_IM
                                           );
                                           
    FlagsToSave = Miniport->Flags & fMINIPORT_REQUIRES_MEDIA_POLLING;
    CurrentDevicePowerState = Miniport->CurrentDevicePowerState;
    NextGlobalMiniport = Miniport->NextGlobalMiniport;
    InstanceNumber = Miniport->InstanceNumber;
    BusInterface = Miniport->BusInterface;
    SecurityDescriptor = Miniport->SecurityDescriptor;

    //
    // make sure OpenReadyEvent field and NumUserOpens and NumAdminOpens
    // ref counts are not disturbed.
    //
    ZeroMemory(Miniport, FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent));

    ZeroMemory((PUCHAR)Miniport +
                    FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent) +
                    sizeof(Miniport->OpenReadyEvent),
                    FIELD_OFFSET(NDIS_MINIPORT_BLOCK, NumUserOpens) -
                    FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent) -
                    sizeof(Miniport->OpenReadyEvent)
                    );


    ZeroMemory((PUCHAR)&Miniport->Ref, sizeof(ULONG_REFERENCE));

    //
    // zero out wrapper context as well to get rid of any shared memory allocations
    // leftover from previous initialize
    //
    ZeroMemory(WrapperContext, sizeof(NDIS_WRAPPER_CONTEXT));
    
    //
    // restore what we saved
    //

    Miniport->PnPDeviceState = NdisPnPDeviceAdded;
    Miniport->Signature = (PVOID)MINIPORT_DEVICE_MAGIC_VALUE;
    Miniport->DriverHandle = MiniBlock;
    INITIALIZE_SPIN_LOCK(&Miniport->Lock);
    
    if (Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
        INITIALIZE_SPIN_LOCK(&Miniport->TimerQueueLock);

    Miniport->PhysicalDeviceObject = PhysicalDeviceObject;
    Miniport->DeviceObject = DeviceObject;
    Miniport->NextDeviceObject = NextDeviceObject;
    Miniport->WrapperContext = WrapperContext;
    Miniport->BaseName = BaseName;
    Miniport->MiniportName = MiniportName;
    Miniport->pAdapterInstanceName = InstanceName;
    Miniport->DeviceContext = DeviceContext;
    Miniport->BindPaths = BindPaths;
    Miniport->PnPCapabilities = PnPCapabilities;
    Miniport->Flags = FlagsToSave;
    Miniport->PnPFlags = PnPFlagsToSave;
    Miniport->CurrentDevicePowerState = CurrentDevicePowerState;
    Miniport->NextGlobalMiniport = NextGlobalMiniport;
    Miniport->InstanceNumber = InstanceNumber;
    Miniport->BusInterface = BusInterface;

    Miniport->PrimaryMiniport = Miniport;


    InitializeListHead(&Miniport->PacketList);
    Miniport->FirstPendingPacket = NULL;
    
    if (MiniBlock->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
    }
    
    Miniport->SecurityDescriptor = SecurityDescriptor;
    
    RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReinitializeMiniportBlock: Miniport %p\n", Miniport));
}

EXPORT
VOID
NdisMGetDeviceProperty(
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN OUT PDEVICE_OBJECT * PhysicalDeviceObject    OPTIONAL,
    IN OUT PDEVICE_OBJECT * FunctionalDeviceObject OPTIONAL,
    IN OUT PDEVICE_OBJECT * NextDeviceObject OPTIONAL,
    IN OUT  PCM_RESOURCE_LIST * AllocatedResources OPTIONAL,
    IN OUT  PCM_RESOURCE_LIST * AllocatedResourcesTranslated OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{

    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    //
    // very likely this is a NDIS_WDM driver.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
    {
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NDIS_WDM_DRIVER);
    }

    if (ARGUMENT_PRESENT(PhysicalDeviceObject))
    {
        *PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
    }

    if (ARGUMENT_PRESENT(FunctionalDeviceObject))
    {
        *FunctionalDeviceObject = Miniport->DeviceObject;
    }

    if (ARGUMENT_PRESENT(NextDeviceObject))
    {
        *NextDeviceObject = Miniport->NextDeviceObject;
    }

    if (ARGUMENT_PRESENT(AllocatedResources))
    {
        *AllocatedResources = Miniport->AllocatedResources;
    }
    
    if (ARGUMENT_PRESENT(AllocatedResourcesTranslated))
    {
        *AllocatedResourcesTranslated = Miniport->AllocatedResourcesTranslated;
    }

    return;
}

NTSTATUS
ndisWritePnPCapabilities(
    IN PNDIS_MINIPORT_BLOCK Miniport,
    IN ULONG                PnPCapabilities
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    NTSTATUS            RegistryStatus;
    HANDLE              Handle, RootHandle;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      Root={0, 0, NULL};

    do
    {

#if NDIS_TEST_REG_FAILURE
        RegistryStatus = STATUS_UNSUCCESSFUL;
        RootHandle = NULL;
#else
        RegistryStatus = IoOpenDeviceRegistryKey(Miniport->PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_WRITE | MAXIMUM_ALLOWED,
                                                     &RootHandle);
#endif

        if (!NT_SUCCESS(RegistryStatus))
        {
            break;
        }
        
        InitializeObjectAttributes(&ObjAttr,
                                   &Root,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   RootHandle,
                                   NULL);
                                
        RegistryStatus = ZwOpenKey(&Handle,
                                   GENERIC_READ | MAXIMUM_ALLOWED,
                                   &ObjAttr);
                        
        if (NT_SUCCESS(RegistryStatus))
        {
            RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                                   Handle,
                                                   L"PnPCapabilities",
                                                   REG_DWORD,
                                                   &PnPCapabilities,
                                                   sizeof(ULONG));

            ZwClose(Handle);
        }
            
        ZwClose(RootHandle);
        
    } while (FALSE);

    return RegistryStatus;
    
}

NDIS_STATUS
NdisMRemoveMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:
    Miniports call this routine to signal a device failure.
    in response, ndis will ask PnP to send a REMOVE IRP for this device

Arguments:

    MiniportHandle  -   Miniport

Return Value:

    always successful

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
    IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
    
    return(NDIS_STATUS_SUCCESS);
}


PNDIS_MINIPORT_BLOCK
ndisFindMiniportOnGlobalList(
    IN  PNDIS_STRING                    DeviceName
    )
/*++

Routine Description:

    Find the Miniport with a matching device name on ndisMiniportList.

Arguments:
    
Return Value:
    a pointer to MiniportBlock if found. NULL otherwise
    
--*/
{
    KIRQL                   OldIrql;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STRING             UpcaseDevice;
    PWSTR                   pwch;

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisFindMiniportOnGlobalList: DeviceName %p\n", DeviceName));
            
    
    //
    // First we need to upcase the device-name before checking
    //
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if ((pwch = UpcaseDevice.Buffer) == NULL)
    {
        return NULL;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
    for (Miniport = ndisMiniportList;
         Miniport != NULL;
         Miniport = Miniport->NextGlobalMiniport)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->MiniportName))
        {
            break;
        }
    }
    RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);
    
    PnPDereferencePackage();
    
    FREE_POOL(pwch);

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisFindMiniportOnGlobalList: Miniport %p\n", Miniport));

    return Miniport;
}

ULONG
NdisMGetDmaAlignment(
    IN  NDIS_HANDLE MiniportAdapterHandle
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    ASSERT(Miniport->SystemAdapterObject != NULL);
        
    if (Miniport->SystemAdapterObject)
    {
        return (Miniport->SystemAdapterObject->DmaOperations->GetDmaAlignment(Miniport->SystemAdapterObject));
    }
    else
    {
        return 0;
    }
}


ULONG
NdisGetSharedDataAlignment(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    return KeGetRecommendedSharedDataAlignment();
}

VOID
ndisDereferenceDmaAdapter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

Arguments:

Return Value:
    

--*/
{
    PDMA_ADAPTER        DmaAdapter;
    PPUT_DMA_ADAPTER    putDmaAdapter;
    LONG                DmaAdapterRefCount;
    KIRQL               OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
    DmaAdapterRefCount = InterlockedDecrement(&Miniport->DmaAdapterRefCount);

    ASSERT(DmaAdapterRefCount >= 0);

    if (DmaAdapterRefCount == 0)
    {
        //
        // free the dma adapter
        //
        DmaAdapter = Miniport->SystemAdapterObject;
        ASSERT(DmaAdapter != NULL);
            
        if (DmaAdapter != NULL)
        {
            Miniport->SavedSystemAdapterObject = Miniport->SystemAdapterObject;
            putDmaAdapter = *DmaAdapter->DmaOperations->PutDmaAdapter;
            putDmaAdapter(DmaAdapter);
            Miniport->SystemAdapterObject  = NULL;
        }

        if (Miniport->SGListLookasideList)
        {
            ExDeleteNPagedLookasideList(Miniport->SGListLookasideList);
            FREE_POOL(Miniport->SGListLookasideList);
            Miniport->SGListLookasideList = NULL;
        }
        
        if (Miniport->DmaResourcesReleasedEvent != NULL)
        {
            SET_EVENT(Miniport->DmaResourcesReleasedEvent);
        }
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\dma.c ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

    dma.c

Abstract:

    

Author:

    Jameel Hyder (jameelh) 02-Apr-1998

Environment:

    Kernel mode, FSD

Revision History:

    02-Apr-1998  JameelH Initial version

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DMA

NDIS_STATUS
NdisMInitializeScatterGatherDma(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  BOOLEAN                 Dma64BitAddresses,
    IN  ULONG                   MaximumPhysicalMapping
    )
/*++

Routine Description:

    Allocates adapter channel for bus mastering devices.

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    DEVICE_DESCRIPTION      DeviceDescription;
    ULONG                   MapRegisters = 0, SGMapRegsisters;
    NDIS_STATUS             Status = NDIS_STATUS_NOT_SUPPORTED;
    NTSTATUS                NtStatus;
    ULONG                   ScatterGatherListSize;
    BOOLEAN                 DereferenceDmaAdapter = FALSE;
    BOOLEAN                 FreeSGListLookasideList = FALSE;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMInitializeScatterGatherDma: Miniport %lx, Dma64BitAddresses %lx, MaximumPhysicalMapping 0x%lx\n",
                                                Miniport, Dma64BitAddresses, MaximumPhysicalMapping));

    ASSERT(Miniport->SystemAdapterObject == NULL);

    do
    {
        if (!MINIPORT_TEST_FLAGS(Miniport, fMINIPORT_IS_NDIS_5 | fMINIPORT_BUS_MASTER))
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
        
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_INIT_SG))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));
            
        DeviceDescription.Master = TRUE;
        DeviceDescription.ScatterGather = TRUE;

        DeviceDescription.BusNumber = Miniport->BusNumber;
        DeviceDescription.DmaChannel = 0;
        DeviceDescription.InterfaceType = Miniport->AdapterType;

        if (Dma64BitAddresses)
        {
            DeviceDescription.Dma32BitAddresses = FALSE;
            DeviceDescription.Dma64BitAddresses = TRUE;
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_64BITS_DMA);
        }
        else
        {
            DeviceDescription.Dma32BitAddresses = TRUE;
            DeviceDescription.Dma64BitAddresses = FALSE;
        }

        //1 check for an upper bound on Miniport->       SGMapRegistersNeeded 
        if (((MaximumPhysicalMapping * 2 - 2) / PAGE_SIZE) + 2 < Miniport->SGMapRegistersNeeded)
        {
            DeviceDescription.MaximumLength = (Miniport->SGMapRegistersNeeded - 1) << PAGE_SHIFT;
        }
        else
        {
            DeviceDescription.MaximumLength = MaximumPhysicalMapping*2;
        }

        DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION2;

        if (Miniport->SystemAdapterObject == NULL)
        {

            //
            // Get the adapter object.
            //
            Miniport->SystemAdapterObject = IoGetDmaAdapter(Miniport->PhysicalDeviceObject,
                                            &DeviceDescription,
                                            &MapRegisters);
                                        
        }
        
        if (Miniport->SystemAdapterObject == NULL)
        {
            NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                   NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                   1,
                                   0xFFFFFFFF);
                                   
            DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_ERR, 
                ("NdisMInitializeScatterGatherDma: Miniport %lx, IoGetDmaAdapter failed\n", Miniport));
                
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("NdisMInitializeScatterGatherDma: Miniport %lx, MapRegisters 0x%lx\n", Miniport, MapRegisters));
        
        InterlockedIncrement(&Miniport->DmaAdapterRefCount);

        DereferenceDmaAdapter = TRUE;
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->SendCompleteHandler =  ndisMSendCompleteSG;
        }

        if (Miniport->SGListLookasideList == NULL)
        {
            Miniport->SGListLookasideList = (PNPAGED_LOOKASIDE_LIST)ALLOC_FROM_POOL(sizeof(NPAGED_LOOKASIDE_LIST), NDIS_TAG_DMA);
        }
        
        if (Miniport->SGListLookasideList == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        FreeSGListLookasideList = TRUE;
        
        NtStatus = Miniport->SystemAdapterObject->DmaOperations->CalculateScatterGatherList(
                                                                    Miniport->SystemAdapterObject,
                                                                    NULL,
                                                                    0,
                                                                    MapRegisters * PAGE_SIZE,
                                                                    &ScatterGatherListSize,
                                                                    &SGMapRegsisters);

        ASSERT(NT_SUCCESS(NtStatus));
        ASSERT(SGMapRegsisters == MapRegisters);
        
        if (!NT_SUCCESS(NtStatus))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        Miniport->ScatterGatherListSize = ScatterGatherListSize;
        
        ExInitializeNPagedLookasideList(Miniport->SGListLookasideList,
                                        NULL,
                                        NULL,
                                        0,
                                        ScatterGatherListSize,
                                        NDIS_TAG_DMA,
                                        0);

        Status = NDIS_STATUS_SUCCESS;
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SG_LIST);
        Miniport->InfoFlags |= NDIS_MINIPORT_SG_LIST;
        
        DereferenceDmaAdapter = FALSE;
        FreeSGListLookasideList = FALSE;

    }while (FALSE);


    if (DereferenceDmaAdapter)
    {
        ndisDereferenceDmaAdapter(Miniport);
    }
    
    if (FreeSGListLookasideList && Miniport->SGListLookasideList)
    {
        ExDeleteNPagedLookasideList(Miniport->SGListLookasideList);
        FREE_POOL(Miniport->SGListLookasideList);
        Miniport->SGListLookasideList = NULL;
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO, 
        ("<==NdisMInitializeScatterGatherDma: Miniport %lx, Status %lx\n", Miniport, Status));
    
    return(Status);
}


VOID
FASTCALL
ndisMAllocSGList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    Buffer;
    PVOID           pBufferVa;
    UINT            PacketLength;
    PNDIS_BUFFER    pNdisBuffer = NULL;
    PVOID           SGListBuffer;
    KIRQL           OldIrql;

    NdisQueryPacket(Packet, NULL, NULL, &Buffer, &PacketLength);

    pBufferVa = MmGetMdlVirtualAddress(Buffer);

    SGListBuffer = ExAllocateFromNPagedLookasideList(Miniport->SGListLookasideList);

    //
    //  Callers of GetScatterGatherList must be at dispatch.
    //
    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    
    if (SGListBuffer)
    {
        Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_USES_SG_BUFFER_LIST;
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = SGListBuffer;
            
        Status = Miniport->SystemAdapterObject->DmaOperations->BuildScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGList,
                        Packet,
                        TRUE,
                        SGListBuffer,
                        Miniport->ScatterGatherListSize);
        
        if (!NT_SUCCESS(Status))
        {
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
            ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
        Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGList,
                        Packet,
                        TRUE);

    }    
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    if (!NT_SUCCESS(Status))
    {
        PUCHAR          NewBuffer;
        UINT            BytesCopied;
        
        do
        {
            //
            //  Allocate a buffer for the packet.
            //
            NewBuffer = (PUCHAR)ALLOC_FROM_POOL(PacketLength, NDIS_TAG_DOUBLE_BUFFER_PKT);
            if (NULL == NewBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Allocate an MDL for the buffer
            //
            NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, (PVOID)NewBuffer, PacketLength);
            if (NDIS_STATUS_SUCCESS != Status)
            {    
                break;
            }

            ndisMCopyFromPacketToBuffer(Packet,         // Packet to copy from.
                                        0,              // Offset from beginning of packet.
                                        PacketLength,   // Number of bytes to copy.
                                        NewBuffer,      // The destination buffer.
                                        &BytesCopied);  // The number of bytes copied.

            if (BytesCopied != PacketLength)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            
            Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_DOUBLE_BUFFERED;
            pBufferVa = MmGetMdlVirtualAddress(pNdisBuffer);

            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = pNdisBuffer;

            RAISE_IRQL_TO_DISPATCH(&OldIrql);

            Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                            Miniport->SystemAdapterObject,
                            Miniport->DeviceObject,
                            pNdisBuffer,
                            pBufferVa,
                            PacketLength,
                            ndisMProcessSGList,
                            Packet,
                            TRUE);

            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

        }while (FALSE);
        
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                     ("ndisMAllocSGList: GetScatterGatherList failed %lx\n", Status));

            if (pNdisBuffer)
            {
                NdisFreeBuffer(pNdisBuffer);
            }
            if (NewBuffer)
            {
                FREE_POOL(NewBuffer);
            }

            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                PNDIS_STACK_RESERVED    NSR;

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
                NdisMCoSendComplete(NDIS_STATUS_FAILURE, NSR->VcPtr, Packet);
            }
            else
            {
                ndisMSendCompleteX(Miniport, Packet, NDIS_STATUS_FAILURE);
            }
        }
    }
}


VOID
FASTCALL
ndisMFreeSGList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PSCATTER_GATHER_LIST    pSGL;
    PVOID                   SGListBuffer;

    pSGL = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo);
    ASSERT(pSGL != NULL);
    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);
    Miniport->SystemAdapterObject->DmaOperations->PutScatterGatherList(Miniport->SystemAdapterObject,
                                                                       pSGL,
                                                                       TRUE);

    if (NdisGetPacketFlags(Packet) & NDIS_FLAGS_USES_SG_BUFFER_LIST)
    {
        NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
        SGListBuffer = NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet);
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
        ASSERT(SGListBuffer != NULL);
        ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
    }
    else if (NdisGetPacketFlags(Packet) & NDIS_FLAGS_DOUBLE_BUFFERED)
    {
        PNDIS_BUFFER    DoubleBuffer;
        PVOID           Buffer;

        NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);
        DoubleBuffer = NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet);
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
        ASSERT(DoubleBuffer != NULL);
        Buffer = MmGetMdlVirtualAddress(DoubleBuffer);
        NdisFreeBuffer(DoubleBuffer);
        FREE_POOL(Buffer);        
    }

}

VOID
ndisMProcessSGList(
    IN  PDEVICE_OBJECT          pDO,
    IN  PIRP                    pIrp,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PACKET            Packet = (PNDIS_PACKET)Context;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;

    UNREFERENCED_PARAMETER(pDO);
    UNREFERENCED_PARAMETER(pIrp);
    
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = pSGL;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);

    Open = NSR->Open;
    Miniport = Open->MiniportHandle;

    //
    // Handle Send/SendPacket differently
    //
    MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
    
    
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        VcPtr = NSR->VcPtr;
        (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                        &Packet,
                                        1);
    
    }
    else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
    {
        //
        //  Pass the packet down to the miniport.
        //
        (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                   &Packet,
                                   1);
    }
    else
    {
        ULONG       Flags;
        NDIS_STATUS Status;

        NdisQuerySendFlags(Packet, &Flags);
        Status = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);
    
        if (Status != NDIS_STATUS_PENDING)
        {
            ndisMSendCompleteX(Miniport, Packet, Status);
        }
    }
}


VOID
FASTCALL
ndisMAllocSGListS(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:
    Allocate SG list for packets sent on a serialized miniport


Arguments:

    Miniport
    Packet
Return Value:

    None.

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    Buffer;
    PVOID           pBufferVa;
    UINT            PacketLength;
    PNDIS_BUFFER    pNdisBuffer = NULL;
    PVOID           SGListBuffer;
    KIRQL           OldIrql;

    NdisQueryPacket(Packet, NULL, NULL, &Buffer, &PacketLength);

    pBufferVa = MmGetMdlVirtualAddress(Buffer);

    SGListBuffer = ExAllocateFromNPagedLookasideList(Miniport->SGListLookasideList);

    //
    //  Callers of GetScatterGatherList must be at dispatch.
    //
    RAISE_IRQL_TO_DISPATCH(&OldIrql);


    if (SGListBuffer)
    {
        Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_USES_SG_BUFFER_LIST;
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = SGListBuffer;
            
        Status = Miniport->SystemAdapterObject->DmaOperations->BuildScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGListS,
                        Packet,
                        TRUE,
                        SGListBuffer,
                        Miniport->ScatterGatherListSize);
        
        if (!NT_SUCCESS(Status))
        {
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
            ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
        Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGListS,
                        Packet,
                        TRUE);
    }
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    if (!NT_SUCCESS(Status))
    {
        PUCHAR          NewBuffer;
        UINT            BytesCopied;
        
        //
        // probably the packet was too fragmented and we couldn't allocate enough
        // map registers. try to double buffer the packet.
        //
        do
        {
            //
            //  Allocate a buffer for the packet.
            //
            NewBuffer = (PUCHAR)ALLOC_FROM_POOL(PacketLength, NDIS_TAG_DOUBLE_BUFFER_PKT);
            if (NULL == NewBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Allocate an MDL for the buffer
            //
            NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, (PVOID)NewBuffer, PacketLength);
            if (NDIS_STATUS_SUCCESS != Status)
            {    
                break;
            }

            ndisMCopyFromPacketToBuffer(Packet,         // Packet to copy from.
                                        0,              // Offset from beginning of packet.
                                        PacketLength,   // Number of bytes to copy.
                                        NewBuffer,      // The destination buffer.
                                        &BytesCopied);  // The number of bytes copied.

            if (BytesCopied != PacketLength)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_DOUBLE_BUFFERED;
            pBufferVa = MmGetMdlVirtualAddress(pNdisBuffer);

            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = pNdisBuffer;

            RAISE_IRQL_TO_DISPATCH(&OldIrql);

            Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                            Miniport->SystemAdapterObject,
                            Miniport->DeviceObject,
                            pNdisBuffer,
                            pBufferVa,
                            PacketLength,
                            ndisMProcessSGListS,
                            Packet,
                            TRUE);
            
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);


        }while (FALSE);
        
        if (!NT_SUCCESS(Status))
        {
            PNDIS_STACK_RESERVED    NSR;
            
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                     ("ndisMAllocSGList: GetScatterGatherList failed %lx\n", Status));

            if (pNdisBuffer)
            {
                NdisFreeBuffer(pNdisBuffer);
            }
            if (NewBuffer)
            {
                FREE_POOL(NewBuffer);
            }

            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            //
            // complete the send, don't unlink the packet since it was never 
            // linked to begin with.
            //
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 0, FALSE);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }
    }
}


VOID
ndisMProcessSGListS(
    IN  PDEVICE_OBJECT          pDO,
    IN  PIRP                    pIrp,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PACKET            Packet = (PNDIS_PACKET)Context;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;
    BOOLEAN                 LocalLock;

    UNREFERENCED_PARAMETER(pDO);
    UNREFERENCED_PARAMETER(pIrp);
    
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = pSGL;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);

    Open = NSR->Open;
    Miniport = Open->MiniportHandle;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC (Miniport);

    //
    // queue the packet
    //
    LINK_PACKET_SG(Miniport, Packet, NSR);

    if (Miniport->FirstPendingPacket == NULL)
    {
        Miniport->FirstPendingPacket = Packet;
    }

    //
    //  If we have the local lock and there is no
    //  packet pending, then fire off a send.
    //
    LOCK_MINIPORT(Miniport, LocalLock);

    NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
    if (LocalLock)
    {
        NDISM_PROCESS_DEFERRED(Miniport);
    }
    UNLOCK_MINIPORT(Miniport, LocalLock);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\data.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    data.h

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

--*/

#ifndef _DATA_
#define _DATA_

extern UCHAR                    ndisValidProcessors[];
extern UCHAR                    ndisNumberOfProcessors;
extern UCHAR                    ndisMaximumProcessor;
extern UCHAR                    ndisCurrentProcessor;
extern LONG                     ndisFlags;
extern TDI_REGISTER_CALLBACK    ndisTdiRegisterCallback;
extern TDI_PNP_HANDLER          ndisTdiPnPHandler;
extern BOOLEAN                  ndisSkipProcessorAffinity;
extern BOOLEAN                  ndisMediaTypeCl[NdisMediumMax];
extern GUID                     gGuidLanClass;
extern NDIS_STATUS              ndisLastFailedInitErrorCode;
extern NDIS_STRING              ndisDeviceStr;
extern NDIS_STRING              ndisDosDevicesStr;
#if NDIS_NO_REGISTRY
extern PWSTR                    ndisDefaultExportName;
#endif
extern ULONG                    ndisVerifierLevel;
extern ULONG                    ndisVeriferFailedAllocations;
extern PCALLBACK_OBJECT         ndisPowerStateCallbackObject;
extern PVOID                    ndisPowerStateCallbackHandle;
extern ULONG                    ndisAcOnLine;
extern BOOLEAN                  VerifierSystemSufficientlyBooted;
extern BOOLEAN                  ndisGuidsSecured;

extern LARGE_INTEGER            KeBootTime;
extern LONG                     ndisCancelId;

extern KQUEUE                   ndisWorkerQueue;

#if NDIS_UNLOAD        
extern WORK_QUEUE_ITEM          ndisPoisonPill;
#endif

extern KSPIN_LOCK               ndisGlobalLock;

extern PKG_REF                  ndisPkgs[MAX_PKG];

extern PNDIS_PROTOCOL_BLOCK     ndisProtocolList;
extern LIST_ENTRY               ndisGlobalPacketPoolList;

extern PNDIS_OPEN_BLOCK         ndisGlobalOpenList;

//
//  The following are counters used for debugging
//
extern const NDIS_PHYSICAL_ADDRESS HighestAcceptableMax;
extern ULONG                    ndisDmaAlignment;
extern ULONG                    ndisTimeIncrement;

//
// For tracking memory allocated for shared memory
//
extern ERESOURCE SharedMemoryResource;

extern PNDIS_M_DRIVER_BLOCK     ndisMiniDriverList;
extern PNDIS_MINIPORT_BLOCK     ndisMiniportList;
extern NDIS_MEDIUM  *           ndisMediumArray,
                                ndisMediumBuffer[NdisMediumMax + EXPERIMENTAL_SIZE];
extern UINT                     ndisMediumArraySize, ndisMediumArrayMaxSize;
extern WCHAR                    ndisHexLookUp[];
extern ULONG                    ndisInstanceNumber;
extern UINT                     ndisPacketStackSize;

extern NDIS_GUID                ndisCoSupportedGuids[16];
extern NDIS_GUID                ndisSupportedGuids[36];
extern NDIS_GUID                ndisMediaSupportedGuids[75];
extern NDIS_GUID                ndisStatusSupportedGuids[10];

extern OID_SETINFO_HANDLER      ndisMSetInfoHandlers[];

extern HANDLE                   ndisSystemProcess;
extern PDEVICE_OBJECT           ndisDeviceObject;
extern PDRIVER_OBJECT           ndisDriverObject;
extern PETHREAD                 ndisThreadObject;
extern LARGE_INTEGER            PoolAgingTicks;


#if DBG
extern ULONG                    ndisDebugSystems;
extern LONG                     ndisDebugLevel;
extern ULONG                    ndisDebugLogSize;
extern ULONG                    ndisDebugBreakPoint;
#endif  // DBG

#ifdef TRACK_MOPEN_REFCOUNTS
extern ULONG_PTR                ndisLogfile[NDIS_LOGFILE_SIZE];
extern USHORT                   ndisLogfileIndex;
#endif
#ifdef TRACK_MINIPORT_REFCOUNTS
extern USHORT                   ndisMiniportLogfileIndex;
extern ULONG_PTR                ndisMiniportLogfile[NDIS_MINIPORT_LOGFILE_SIZE];
#endif

#if TRACK_RECEIVED_PACKETS
extern USHORT                   ndisRcvLogfileIndex;
extern ULONG_PTR                ndisRcvLogfile[NDIS_RCV_LOGFILE_SIZE];
#endif

extern KSPIN_LOCK   ndisProtocolListLock;
extern KSPIN_LOCK   ndisMiniDriverListLock;
extern KSPIN_LOCK   ndisMiniportListLock;
extern KSPIN_LOCK   ndisGlobalPacketPoolListLock;
extern KSPIN_LOCK   ndisGlobalOpenListLock;

extern NDIS_STRING  ndisBuildDate;
extern NDIS_STRING  ndisBuildTime;
extern NDIS_STRING  ndisBuiltBy;

extern KMUTEX       ndisPnPMutex;
extern ULONG        ndisPnPMutexOwner;

extern ULONG        ndisChecked;

extern PNDIS_MINIPORT_BLOCK ndisMiniportTrackAlloc;
extern LIST_ENTRY           ndisMiniportTrackAllocList;
extern PNDIS_M_DRIVER_BLOCK ndisDriverTrackAlloc;
extern LIST_ENTRY           ndisDriverTrackAllocList;
extern KSPIN_LOCK           ndisTrackMemLock;

extern PCALLBACK_OBJECT     ndisBindUnbindCallbackObject;
extern PVOID                ndisBindUnbindCallbackRegisterationHandle;
extern LUID                 SeWmiAccessPrivilege;

#if NDIS_LOG_ABORTED_REQUESTS
extern NDIS_REQUEST         ndisAbortedRequests[16];
extern ULONG                ndisAbortedRequestsIndex;
#endif

volatile ULONG              ndisSpin;

extern PSECURITY_DESCRIPTOR ndisSecurityDescriptor;
extern WORK_QUEUE_ITEM LastWorkerThreadWI;

extern CHAR                 AllUsersReadSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
extern CHAR                 AllUsersWriteSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
extern CHAR                 AllUsersReadWriteSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
extern CHAR                 AllUsersNotificationSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
extern CHAR                 AdminsSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
extern PACL                 AllUsersAclRead;
extern PACL                 AllUsersAclWrite;
extern PACL                 AllUsersAclReadWrite;
extern PACL                 AllUsersAclNotification;
extern PACL                 AdminsAcl;

#endif  // _DATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ffilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ffilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Anthony V. Ercolano (Tonye) 03-Aug-1990

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Jameel Hyder (JameelH) Re-organization


--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_FFILTER


#define FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(_F)             \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                             \
{                                                                   \
    if (!((_F)->CombinedPacketFilter & NDIS_PACKET_TYPE_BROADCAST)) \
    {                                                               \
        /*                                                          \
            We should never receive broadcast packets               \
            to someone else unless in p-mode.                       \
        */                                                          \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                    \
                ("Bad driver, indicating broadcast packets when not set to.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                   \
    }                                                               \
}

#define FDDI_CHECK_FOR_INVALID_DIRECTED_INDICATION(_F, _A, _AL)     \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                             \
{                                                                   \
    /*                                                              \
        The result of comparing an element of the address           \
        array and the multicast address.                            \
                                                                    \
            Result < 0 Implies the adapter address is greater.      \
            Result > 0 Implies the address is greater.              \
            Result = 0 Implies that the they are equal.             \
    */                                                              \
    INT Result = 0;                                                 \
    if (FDDI_LENGTH_OF_LONG_ADDRESS == (_AL))                       \
    {                                                               \
        FDDI_COMPARE_NETWORK_ADDRESSES_EQ(                          \
            (_F)->AdapterLongAddress,                               \
            (_A),                                                   \
            FDDI_LENGTH_OF_LONG_ADDRESS,                            \
            &Result);                                               \
    }                                                               \
    else if (FDDI_LENGTH_OF_SHORT_ADDRESS == (_AL))                 \
    {                                                               \
        FDDI_COMPARE_NETWORK_ADDRESSES_EQ(                          \
            (_F)->AdapterShortAddress,                              \
            (_A),                                                   \
            FDDI_LENGTH_OF_SHORT_ADDRESS,                           \
            &Result);                                               \
    }                                                               \
    if (Result != 0)                                                \
    {                                                               \
        /*                                                          \
            We should never receive directed packets                \
            to someone else unless in p-mode.                       \
        */                                                          \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                    \
                ("Bad driver, indicating packets to another station when not in promiscuous mode.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                   \
    }                                                               \
}


BOOLEAN
FddiCreateFilter(
    IN  UINT                    MaximumMulticastLongAddresses,
    IN  UINT                    MaximumMulticastShortAddresses,
    IN  PUCHAR                  AdapterLongAddress,
    IN  PUCHAR                  AdapterShortAddress,
    OUT PFDDI_FILTER *          Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    MaximumMulticastLongAddresses - The maximum number of Long multicast addresses
    that the MAC will support.

    MaximumMulticastShortAddresses - The maximum number of short multicast addresses
    that the MAC will support.

    AdapterLongAddress - the long address of the adapter associated with this filter
    database.

    AdapterShortAddress - the short address of the adapter associated with this filter
    database.

    Filter - A pointer to an FDDI_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PFDDI_FILTER    LocalFilter;
    BOOLEAN         rc = FALSE;

    do
    {
        //
        // Allocate the database and initialize it.
        //
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(FDDI_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(FDDI_FILTER));
            LocalFilter->NumOpens ++;
            FddiReferencePackage();
        
            FDDI_COPY_NETWORK_ADDRESS(LocalFilter->AdapterLongAddress,
                                      AdapterLongAddress,
                                      FDDI_LENGTH_OF_LONG_ADDRESS);
        
            FDDI_COPY_NETWORK_ADDRESS(LocalFilter->AdapterShortAddress,
                                      AdapterShortAddress,
                                      FDDI_LENGTH_OF_SHORT_ADDRESS);
        
            LocalFilter->MaxMulticastLongAddresses = MaximumMulticastLongAddresses;
            LocalFilter->MaxMulticastShortAddresses = MaximumMulticastShortAddresses;
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}

//
// NOTE: THIS CANNOT BE PAGABLE
//
VOID
FddiDeleteFilter(
    IN  PFDDI_FILTER            Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an FDDI_FILTER to be deleted.

Return Value:

    None.

--*/
{

    ASSERT(Filter->OpenList == NULL);

    if (Filter->MCastLongAddressBuf)
    {
        FREE_POOL(Filter->MCastLongAddressBuf);
    }

    ASSERT(Filter->OldMCastLongAddressBuf == NULL);

    if (Filter->MCastShortAddressBuf)
    {
        FREE_POOL(Filter->MCastShortAddressBuf);
    }

    ASSERT(Filter->OldMCastShortAddressBuf == NULL);

    FREE_POOL(Filter);
    FddiDereferencePackage();
}


NDIS_STATUS
FddiDeleteFilterOpenAdapter(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    //1 check to see if we still support FDDI short addresses.

    //
    // Holds the status returned from the packet filter and address
    // deletion routines.  Will be used to return the status to
    // the caller of this routine.
    //
    NDIS_STATUS StatusToReturn;

    //
    // Local variable.
    //
    PFDDI_BINDING_INFO LocalOpen = (PFDDI_BINDING_INFO)NdisFilterHandle;

    //
    //  Set the filter classes to NONE.
    //
    StatusToReturn = XFilterAdjust(Filter,
                                   NdisFilterHandle,
                                   (UINT)0,
                                   FALSE);
    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING))
    {
        NDIS_STATUS StatusToReturn2;

        //
        //  Remove the long multicast addresses.
        //
        StatusToReturn2 = FddiChangeFilterLongAddresses(Filter,
                                                        NdisFilterHandle,
                                                        0,
                                                        NULL,
                                                        FALSE);
        if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
        {
            StatusToReturn = StatusToReturn2;
        }

        if (StatusToReturn2 == NDIS_STATUS_PENDING)
        {
            fddiCompleteChangeFilterLongAddresses(Filter, NDIS_STATUS_SUCCESS);
        }

        if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
            (StatusToReturn == NDIS_STATUS_PENDING))
        {
            StatusToReturn2 = FddiChangeFilterShortAddresses(Filter,
                                                             NdisFilterHandle,
                                                             0,
                                                             NULL,
                                                             FALSE);
            if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
            {
                StatusToReturn = StatusToReturn2;
            }
            
            if (StatusToReturn2 == NDIS_STATUS_PENDING)
            {
                fddiCompleteChangeFilterShortAddresses(Filter, NDIS_STATUS_SUCCESS);
            }

        }
    }

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //
        if (--(LocalOpen->References) == 0)
        {
            //
            // Remove it from the list.
            //
            XRemoveAndFreeBinding(Filter, LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //
            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return(StatusToReturn);
}


NDIS_STATUS
FddiChangeFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  CHAR                    Addresses[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of FDDI_LENGTH_OF_LONG_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PFDDI_BINDING_INFO  Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result = 0;
    UINT                i, j;
    LOCK_STATE          LockState;

    UNREFERENCED_PARAMETER(Set);
    
    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastLongAddressBuf == NULL);
        Binding->OldMCastLongAddressBuf = Binding->MCastLongAddressBuf;
        Binding->OldNumLongAddresses = Binding->NumLongAddresses;
        Binding->MCastLongAddressBuf = NULL;
        Binding->NumLongAddresses = 0;

        ASSERT(Filter->OldMCastLongAddressBuf == NULL);
        Filter->OldMCastLongAddressBuf = Filter->MCastLongAddressBuf;
        Filter->OldNumLongAddresses = Filter->NumLongAddresses;
        Filter->MCastLongAddressBuf = NULL;
        Filter->NumLongAddresses = 0;

        Filter->MCastSet = Binding;

        if (AddressCount != 0)
        {
            Binding->MCastLongAddressBuf = ALLOC_FROM_POOL(FDDI_LENGTH_OF_LONG_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastLongAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                for (j = 0, Result = -1; j < Binding->NumLongAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Binding->MCastLongAddressBuf[j],
                                                  Addresses[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                //
                // This address is already present. Caller supplied duplicate. Skip it.
                //
                if (Result == 0)
                    continue;
    
                Binding->NumLongAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastLongAddressBuf[j+1],
                               Binding->MCastLongAddressBuf[j],
                               (Binding->NumLongAddresses-j-1)*FDDI_LENGTH_OF_LONG_ADDRESS);
                }
            
                MoveMemory(Binding->MCastLongAddressBuf[j],
                           Addresses[i],
                           FDDI_LENGTH_OF_LONG_ADDRESS);
            }
        
            ASSERT(Binding->NumLongAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes
        //
        Filter->MCastLongAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastLongAddresses * FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastLongAddressBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumLongAddresses; i++)
            {
                for (j = 0, Result = -1; j < Filter->NumLongAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Filter->MCastLongAddressBuf[j],
                                                  Binding->MCastLongAddressBuf[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumLongAddresses ++;
                if (Filter->NumLongAddresses > Filter->MaxMulticastLongAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastLongAddressBuf[j+1],
                               Filter->MCastLongAddressBuf[j],
                               (Filter->NumLongAddresses-j-1)*FDDI_LENGTH_OF_LONG_ADDRESS);
                }
            
                MoveMemory(Filter->MCastLongAddressBuf[j],
                           Binding->MCastLongAddressBuf[i],
                           FDDI_LENGTH_OF_LONG_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;

        //
        // After all the hard work, determine if there was indeed a change
        //
        if (Filter->NumLongAddresses == Filter->OldNumLongAddresses)
        {
            for (i = 0; i < Filter->NumLongAddresses; i++)
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastLongAddressBuf[i],
                                                  Filter->OldMCastLongAddressBuf[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (AddressCount == 0)
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastLongAddressBuf);
                Filter->OldMCastLongAddressBuf = NULL;
                Filter->OldNumLongAddresses = 0;
            }
        
            Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastLongAddressBuf);
                Binding->OldMCastLongAddressBuf = NULL;
                Binding->OldNumLongAddresses = 0;
            }
        }
    } while (FALSE);
    
    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        //
        // Operation completed, do post processing.
        //
        fddiCompleteChangeFilterLongAddresses(Filter, Status);
    }

    return(Status);
}


VOID
fddiCompleteChangeFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_STATUS             Status
    )
{
    PFDDI_BINDING_INFO  Binding = Filter->MCastSet;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    Filter->MCastSet = NULL;
    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //
        if (Binding != NULL)
        {
            if (Binding->MCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->MCastLongAddressBuf);
            }
    
            Binding->MCastLongAddressBuf = Binding->OldMCastLongAddressBuf;
            Binding->NumLongAddresses = Binding->OldNumLongAddresses;
            Binding->OldMCastLongAddressBuf = NULL;
            Binding->OldNumLongAddresses = 0;
        }

        if (Filter->MCastLongAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastLongAddressBuf);
        }

        Filter->MCastLongAddressBuf = Filter->OldMCastLongAddressBuf;
        Filter->NumLongAddresses = Filter->OldNumLongAddresses;
        Filter->OldMCastLongAddressBuf = NULL;
        Filter->OldNumLongAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff.
        //
        if (Filter->OldMCastLongAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastLongAddressBuf);
            Filter->OldMCastLongAddressBuf = NULL;
            Filter->OldNumLongAddresses = 0;
        }
    
        if (Binding != NULL)
        {
            if (Binding->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastLongAddressBuf);
                Binding->OldMCastLongAddressBuf = NULL;
                Binding->OldNumLongAddresses = 0;
            }
        }
    }

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FddiChangeFilterShortAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  CHAR                    Addresses[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of FDDI_LENGTH_OF_SHORT_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PFDDI_BINDING_INFO Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;

    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result = 0;
    UINT                i, j;
    LOCK_STATE          LockState;

    UNREFERENCED_PARAMETER(Set);
    
    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastShortAddressBuf == NULL);
        Binding->OldMCastShortAddressBuf = Binding->MCastShortAddressBuf;
        Binding->OldNumShortAddresses = Binding->NumShortAddresses;
        Binding->MCastShortAddressBuf = NULL;
        Binding->NumShortAddresses = 0;

        ASSERT(Filter->OldMCastShortAddressBuf == NULL);
        Filter->OldMCastShortAddressBuf = Filter->MCastShortAddressBuf;
        Filter->OldNumShortAddresses = Filter->NumShortAddresses;
        Filter->MCastShortAddressBuf = NULL;
        Filter->NumShortAddresses = 0;

        Filter->MCastSet = Binding;

        if (Filter->MaxMulticastShortAddresses == 0)
        {
            break;
        }
        
        if (AddressCount != 0)
        {
            Binding->MCastShortAddressBuf = ALLOC_FROM_POOL(FDDI_LENGTH_OF_SHORT_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastShortAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                for (j = 0, Result = -1; j < Binding->NumShortAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Binding->MCastShortAddressBuf[j],
                                                  Addresses[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                if (Result == 0)
                    continue;
    
                Binding->NumShortAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastShortAddressBuf[j+1],
                               Binding->MCastShortAddressBuf[j],
                               (Binding->NumShortAddresses-j-1)*FDDI_LENGTH_OF_SHORT_ADDRESS);
                }
            
                MoveMemory(Binding->MCastShortAddressBuf[j],
                           Addresses[i],
                           FDDI_LENGTH_OF_SHORT_ADDRESS);
            }
        
            ASSERT(Binding->NumShortAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes
        //
        Filter->MCastShortAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastShortAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastShortAddressBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumShortAddresses; i++)
            {
                for (j = 0, Result = -1; j < Filter->NumShortAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Filter->MCastShortAddressBuf[j],
                                                  Binding->MCastShortAddressBuf[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumShortAddresses ++;
                if (Filter->NumShortAddresses > Filter->MaxMulticastShortAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastShortAddressBuf[j+1],
                               Filter->MCastShortAddressBuf[j],
                               (Filter->NumShortAddresses-j-1)*FDDI_LENGTH_OF_SHORT_ADDRESS);
                }
            
                MoveMemory(Filter->MCastShortAddressBuf[j],
                           Binding->MCastShortAddressBuf[i],
                           FDDI_LENGTH_OF_SHORT_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;

        //
        // After all the hard work, determine if there was indeed a change
        //
        if (Filter->NumShortAddresses == Filter->OldNumShortAddresses)
        {
            for (i = 0; i < Filter->NumShortAddresses; i++)
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastShortAddressBuf[i],
                                                  Filter->OldMCastShortAddressBuf[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (AddressCount == 0)
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastShortAddressBuf);
                Filter->OldMCastShortAddressBuf = NULL;
                Filter->OldNumShortAddresses = 0;
            }
        
            Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
                Binding->OldMCastShortAddressBuf = NULL;
                Binding->OldNumShortAddresses = 0;
            }
        }
    } while (FALSE);
    
    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // If the address array has changed, we have to call the
    // action array to inform the adapter of this.
    //
    
    if ((Status != NDIS_STATUS_PENDING) && (Filter->MaxMulticastShortAddresses != 0))
    {
        //
        // Operation completed, do post processing.
        //
        fddiCompleteChangeFilterShortAddresses(Filter, Status);
    }

    return(Status);
}


VOID
fddiCompleteChangeFilterShortAddresses(
    IN   PFDDI_FILTER           Filter,
    IN  NDIS_STATUS             Status
    )
{
    PFDDI_BINDING_INFO  Binding = Filter->MCastSet;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //
        if (Binding != NULL)
        {
            if (Binding->MCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
            }
    
            Binding->MCastShortAddressBuf = Binding->OldMCastShortAddressBuf;
            Binding->NumShortAddresses = Binding->OldNumShortAddresses;
            Binding->OldMCastShortAddressBuf = NULL;
            Binding->OldNumShortAddresses = 0;
        }

        if (Filter->MCastShortAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastShortAddressBuf);
        }

        Filter->MCastShortAddressBuf = Filter->OldMCastShortAddressBuf;
        Filter->NumShortAddresses = Filter->OldNumShortAddresses;
        Filter->OldMCastShortAddressBuf = NULL;
        Filter->OldNumShortAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff. Also mark the fact
        // this miniport supports short addresses
        //
        Filter->SupportsShortAddresses = TRUE;
        if (Filter->OldMCastShortAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastShortAddressBuf);
            Filter->OldMCastShortAddressBuf = NULL;
            Filter->OldNumShortAddresses = 0;
        }
        
        if (Binding != NULL)
        {
            if (Binding->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
                Binding->OldMCastShortAddressBuf = NULL;
                Binding->OldNumShortAddresses = 0;
            }
        }
    }

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


UINT
FddiNumberOfOpenFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to open block.


Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Filter);

    return(((PFDDI_BINDING_INFO)NdisFilterHandle)->NumLongAddresses);
}


UINT
FddiNumberOfOpenFilterShortAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to open block.


Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Filter);
    
    return(((PFDDI_BINDING_INFO)NdisFilterHandle)->NumShortAddresses);
}


VOID
FddiQueryOpenFilterLongAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT CHAR                    AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  BindInfo = (PFDDI_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray >= (FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastLongAddressBuf,
                   FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumLongAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryOpenFilterShortAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT CHAR                    AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  BindInfo = (PFDDI_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    if (SizeOfArray >= (FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastLongAddressBuf,
                   FDDI_LENGTH_OF_SHORT_ADDRESS * BindInfo->NumLongAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumLongAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryGlobalFilterLongAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT CHAR                AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use FDDI_NUMBER_OF_GLOBAL_LONG_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumLongAddresses * FDDI_LENGTH_OF_LONG_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;

        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;

        *NumberOfAddresses = Filter->NumLongAddresses;

        MoveMemory(AddressArray[0],
                   Filter->MCastLongAddressBuf[0],
                   Filter->NumLongAddresses*FDDI_LENGTH_OF_LONG_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryGlobalFilterShortAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT CHAR                AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use FDDI_NUMBER_OF_GLOBAL_SHORT_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumShortAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;

        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;

        *NumberOfAddresses = Filter->NumShortAddresses;

        MoveMemory(AddressArray[0],
                   Filter->MCastShortAddressBuf[0],
                   Filter->NumShortAddresses*FDDI_LENGTH_OF_SHORT_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FASTCALL
ndisMSetFddiMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses, AddrLen;
    BOOLEAN     fCleanup = FALSE;
    BOOLEAN     fShort;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetFddiMulticastList\n"));

    fShort = (Request->DATA.SET_INFORMATION.Oid == OID_FDDI_SHORT_MULTICAST_LIST);

    Request->DATA.SET_INFORMATION.BytesRead = 0;
    Request->DATA.SET_INFORMATION.BytesNeeded = 0;

    //
    //  Verify the media type.
    //
    if (Miniport->MediaType != NdisMediumFddi)
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetFddiMulticastList: Invalid media type\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

        return(Status);
    }

    AddrLen = fShort ? FDDI_LENGTH_OF_SHORT_ADDRESS : FDDI_LENGTH_OF_LONG_ADDRESS;

    //
    //  Verify the information buffer length.
    //
    if ((Request->DATA.SET_INFORMATION.InformationBufferLength % AddrLen) != 0)
    {
        Status = NDIS_STATUS_INVALID_LENGTH;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

        //
        // The data must be a multiple of AddrLen
        //
        return(Status);
    }

    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        // Now call the filter package to set up the addresses.
        //
        Status = fShort ?
                    FddiChangeFilterShortAddresses(
                             Miniport->FddiDB,
                             PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                             Request->DATA.SET_INFORMATION.InformationBufferLength / AddrLen,
                             Request->DATA.SET_INFORMATION.InformationBuffer,
                             TRUE) :
                    FddiChangeFilterLongAddresses(
                             Miniport->FddiDB,
                             PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                             Request->DATA.SET_INFORMATION.InformationBufferLength / AddrLen,
                             Request->DATA.SET_INFORMATION.InformationBuffer,
                             TRUE);
        if (Status == NDIS_STATUS_PENDING)
            fCleanup = TRUE;
    }

    //
    //  If the filter library returned NDIS_STATUS_PENDING then we
    //  need to call down to the miniport driver.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Get the number of multicast addresses and the list
        //  of multicast addresses to send to the miniport driver.
        //
        NumberOfAddresses = fShort ?
            fddiNumberOfShortGlobalAddresses(Miniport->FddiDB) :
            fddiNumberOfLongGlobalAddresses(Miniport->FddiDB);
        
        ASSERT(Miniport->SetMCastBuffer == NULL);
        if (NumberOfAddresses != 0)
        {
            Miniport->SetMCastBuffer = ALLOC_FROM_POOL(NumberOfAddresses * AddrLen,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Miniport->SetMCastBuffer == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
            }
        }

        if (Status != NDIS_STATUS_RESOURCES)
        {
            fShort ?
                FddiQueryGlobalFilterShortAddresses(&Status,
                                                    Miniport->FddiDB,
                                                    NumberOfAddresses * AddrLen,
                                                    &NumberOfAddresses,
                                                    Miniport->SetMCastBuffer) :
                FddiQueryGlobalFilterLongAddresses(&Status,
                                                   Miniport->FddiDB,
                                                   NumberOfAddresses * AddrLen,
                                                   &NumberOfAddresses,
                                                   Miniport->SetMCastBuffer);
    
            //
            //  Call the miniport driver.
            //
            SAVE_REQUEST_BUF(Miniport, Request,
                             Miniport->SetMCastBuffer,
                             NumberOfAddresses * AddrLen);
            MINIPORT_SET_INFO(Miniport,
                              Request,
                              &Status);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    
        if (Miniport->SetMCastBuffer != NULL)
        {
            FREE_POOL(Miniport->SetMCastBuffer);
            Miniport->SetMCastBuffer = NULL;
        }
    
        if (fCleanup)
        {
            fShort ?
                fddiCompleteChangeFilterShortAddresses(Miniport->FddiDB, Status) :
                fddiCompleteChangeFilterLongAddresses(Miniport->FddiDB, Status);
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

    return(Status);
}

VOID
FddiFilterDprIndicateReceive(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  UINT                    AddressLength,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate a packet to
    all bindings.  The packet will be filtered so that only the
    appropriate bindings will receive the packet.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

    MacReceiveContext - A MAC supplied context value that must be
    returned by the protocol if it calls MacTransferData.

    Address - The destination address from the received packet.

    AddressLength - The length of the above address.

    HeaderBuffer - A virtual address of the virtually contiguous
    buffer containing the MAC header of the packet.

    HeaderBufferSize - An unsigned integer indicating the size of
    the header buffer, in bytes.

    LookaheadBuffer - A virtual address of the virtually contiguous
    buffer containing the first LookaheadBufferSize bytes of data
    of the packet.  The packet buffer is valid only within the current
    call to the receive event handler.

    LookaheadBufferSize - An unsigned integer indicating the size of
    the lookahead buffer, in bytes.

    PacketSize - An unsigned integer indicating the size of the received
    packet, in bytes.  This number has nothing to do with the lookahead
    buffer, but indicates how large the arrived packet is so that a
    subsequent MacTransferData request can be made to transfer the entire
    packet as necessary.

Return Value:

    None.

--*/
{
    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType = NDIS_PACKET_TYPE_DIRECTED;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS         StatusOfReceive;

    LOCK_STATE          LockState;

    //
    // Current Open to indicate to.
    //
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;

    //
    // Holds the result of address determinations.
    //
    INT                 ResultOfAddressCheck;

    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        return;     
    }

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    
#if DBG
    Filter->Miniport->cDpcRcvIndications++;
    Filter->Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // If the packet is a runt packet, then only indicate to PROMISCUOUS
    //
    if ((HeaderBufferSize > (2 * AddressLength)) && (PacketSize != 0))
    {
        BOOLEAN fDirected;

        fDirected = FALSE;
        FDDI_IS_SMT(*((PCHAR)HeaderBuffer), &ResultOfAddressCheck);
        if (!ResultOfAddressCheck)
        {
            fDirected = (((UCHAR)Address[0] & 0x01) == 0);
        }

        //
        //  Handle the directed packet case first
        //
        if (fDirected)
        {
            BOOLEAN IsNotOurs;

            DIRECTED_PACKETS_IN(Filter->Miniport);
            DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);

            //
            // If it is a directed packet, then check if the combined packet
            // filter is PROMISCUOUS, if it is check if it is directed towards
            // us. Eliminate the SMT case.
            //
            IsNotOurs = FALSE;  // Assume it is
            if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                NDIS_PACKET_TYPE_ALL_MULTICAST))
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) ?
                                                    Filter->AdapterLongAddress :
                                                    Filter->AdapterShortAddress,
                                                  Address,
                                                  AddressLength,
                                                  &IsNotOurs);
            }

            //
            //  Walk the directed list and indicate up the packets.
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;

                //
                // Ignore if not directed to us or if the binding is not promiscuous
                //
                if (((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_PROMISCUOUS) == 0) &&
                    (IsNotOurs ||
                    ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                {
                        continue;
                }

                //
                // Indicate the packet to the binding.
                //
                ProtocolFilterIndicateReceive(&StatusOfReceive,
                                              LocalOpen->NdisBindingHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookaheadBuffer,
                                              LookaheadBufferSize,
                                              PacketSize,
                                              NdisMediumFddi);

                LocalOpen->ReceivedAPacket = TRUE;
            }

            //
            // Done for uni-cast
            //
            READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
            return;
        }

        //
        // Determine whether the input address is a simple direct,
        // a broadcast, a multicast, or an SMT address.
        //
        FDDI_IS_SMT(*((PCHAR)HeaderBuffer), &ResultOfAddressCheck);
        if (ResultOfAddressCheck)
        {
            AddressType = NDIS_PACKET_TYPE_SMT;
        }
        else
        {
            //
            // First check if it *at least* has the multicast address bit.
            //
            FDDI_IS_MULTICAST(Address, AddressLength, &ResultOfAddressCheck);
            if (ResultOfAddressCheck)
            {
                //
                // It is at least a multicast address.  Check to see if
                // it is a broadcast address.
                //

                FDDI_IS_BROADCAST(Address, AddressLength, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);

                    AddressType = NDIS_PACKET_TYPE_BROADCAST;
                }
                else
                {
                    AddressType = NDIS_PACKET_TYPE_MULTICAST;
                }
            }
        }
    }
    else
    {
        // Runt Packet
        AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
    }

    //
    // At this point we know that the packet is either:
    // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
    // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
    // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
    // - SMT Packet - indicated by AddressType = NDIS_PACKET_TYPE_SMT
    //
    // Walk the broadcast/multicast/SMT list and indicate up the packets.
    //
    // The packet is indicated if it meets the following criteria:
    //
    // if ((Binding is promiscuous) OR
    //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
    //   ((Packet is SMT) AND (Binding is SMT)) OR
    //   ((Packet is multicast) AND
    //    ((Binding is all-multicast) OR
    //      ((Binding is multicast) AND (address in approp. multicast list)))))
    //
    //
    //  Is this a directed packet?
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        UINT    LocalFilter = LocalOpen->PacketFilters;

        //
        //  Get the next open to look at.
        //
        NextOpen = LocalOpen->NextOpen;

        if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||

            ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
             (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||

            ((AddressType == NDIS_PACKET_TYPE_SMT)  &&
             (LocalFilter & NDIS_PACKET_TYPE_SMT))          ||

            ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
             ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                (((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) &&
                 fddiFindMulticastLongAddress(LocalOpen->NumLongAddresses,
                                              LocalOpen->MCastLongAddressBuf,
                                              (PUCHAR)Address)
                ) ||
                ((AddressLength == FDDI_LENGTH_OF_SHORT_ADDRESS) &&
                 fddiFindMulticastShortAddress(LocalOpen->NumShortAddresses,
                                               LocalOpen->MCastShortAddressBuf,
                                               (PUCHAR)Address)
                )
                )
              )
             )
            )
            )
        {
            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMediumFddi);

            LocalOpen->ReceivedAPacket = TRUE;
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
fddiFilterDprIndicateReceivePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings.  The packets will be filtered so that only the
    appropriate bindings will receive the individual packets.
    This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    //
    // The Filter of interest
    //
    PFDDI_FILTER        Filter = Miniport->FddiDB;

    //
    // Current packet being processed
    //
    PPNDIS_PACKET       pPktArray = PacketArray;
    PNDIS_PACKET        Packet;
    PNDIS_PACKET_OOB_DATA pOob;

    //
    // Pointer to the buffer in the ndispacket
    //
    PNDIS_BUFFER        Buffer;

    //
    // Total packet length
    //
    UINT                i, LASize, PacketSize, NumIndicates = 0;

    //
    // Pointer to the 1st segment of the buffer, points to dest address
    //
    PUCHAR              Address, Hdr;

    UINT                AddressLength;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType = NDIS_PACKET_TYPE_DIRECTED;

    LOCK_STATE          LockState;

    //
    //  Decides whether we use the protocol's revpkt handler or fall
    //  back to old rcvindicate handler
    //
    BOOLEAN             fFallBack, fPmode;

    //
    // Current Open to indicate to.
    //
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;
    PNDIS_OPEN_BLOCK    pOpenBlock;
    PNDIS_STACK_RESERVED NSR;

#ifdef TRACK_RECEIVED_PACKETS
    ULONG               OrgPacketStackLocation;
    PETHREAD            CurThread = PsGetCurrentThread();
#endif

    //
    // Holds the result of address determinations.
    //
    INT                 ResultOfAddressCheck;

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);
    
#if DBG
    Miniport->cDpcRcvIndications += NumberOfPackets;
    Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        do
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);
#ifdef TRACK_RECEIVED_PACKETS
            OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif
            PUSH_PACKET_STACK(Packet);
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            ASSERT(NSR->RefCount == 0);
            //1 this does not check for current stack location for non-im drivers
            //1 to be -1 as we do for Ethernet
            if (NSR->RefCount != 0)
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            7,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Packet,
                            (ULONG_PTR)PacketArray);

            }
    
            pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
            NdisGetFirstBufferFromPacket(Packet,
                                         &Buffer,
                                         &Address,
                                         &LASize,
                                         &PacketSize);
            ASSERT(Buffer != NULL);
    
            Hdr = Address++;
    
            //1 drop support for short addresses
            AddressLength = (*Hdr & 0x40) ?
                                    FDDI_LENGTH_OF_LONG_ADDRESS :
                                    FDDI_LENGTH_OF_SHORT_ADDRESS;
            ASSERT(pOob->HeaderSize == (AddressLength * 2 + 1));
    
            //
            // Set context in the packet so that NdisReturnPacket can do the right thing
            //
            NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
            //
            // Set the status here that nobody is holding the packet. This will get
            // overwritten by the real status from the protocol. Pay heed to what
            // the miniport is saying.
            //
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                pOob->Status = NDIS_STATUS_SUCCESS;
                fFallBack = FALSE;
            }
            else
            {
#if DBG
                if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                    MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                            ("Miniport going into D3, not indicating chained receives\n"));
                }
#endif
                fFallBack = TRUE;
            }
    
            //
            // A quick check for Runt packets. These are only indicated to Promiscuous bindings
            //
            if (PacketSize > pOob->HeaderSize)
            {
                BOOLEAN fDirected;
    
                fDirected = FALSE;
                FDDI_IS_SMT(*Address, &ResultOfAddressCheck);
                if (!ResultOfAddressCheck)
                {
                    fDirected = (((UCHAR)Address[0] & 0x01) == 0);
                }
    
                //
                //  Handle the directed packet case first
                //
                if (fDirected)
                {
                    BOOLEAN IsNotOurs;
    
                    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK))
                    {
                        DIRECTED_PACKETS_IN(Miniport);
                        DIRECTED_BYTES_IN(Miniport, PacketSize);
                    }

                    //
                    // If it is a directed packet, then check if the combined packet
                    // filter is PROMISCUOUS, if it is check if it is directed towards
                    // us. Eliminate the SMT case.
                    //
                    IsNotOurs = FALSE;  // Assume it is
                    if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                        NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                        NDIS_PACKET_TYPE_ALL_MULTICAST))
                    {
                        FDDI_COMPARE_NETWORK_ADDRESSES_EQ((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) ?
                                                            Filter->AdapterLongAddress :
                                                            Filter->AdapterShortAddress,
                                                          Address,
                                                          AddressLength,
                                                          &IsNotOurs);
                    }
    
                    //
                    //  We definitely have a directed packet so lets indicate it now.
                    //
                    //  Walk the directed list and indicate up the packets.
                    //
                    for (LocalOpen = Filter->OpenList;
                         LocalOpen != NULL;
                         LocalOpen = NextOpen)
                    {
                        //
                        //  Get the next open to look at.
                        //
                        NextOpen = LocalOpen->NextOpen;
    
                        //
                        // Ignore if not directed to us and if the binding is not promiscuous
                        // Or if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                            TRUE : FALSE;

                        
                        if (!fPmode &&
                            (IsNotOurs || 
                            ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                        {
                                
                            continue;
                        }
    
                        //
                        // Ignore if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                            (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                        {
                            continue;
                        }
    
                        pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                        LocalOpen->ReceivedAPacket = TRUE;
                        NumIndicates ++;
                        
                        IndicateToProtocol(Miniport,
                                           Filter,
                                           pOpenBlock,
                                           Packet,
                                           NSR,
                                           Hdr,
                                           PacketSize,
                                           pOob->HeaderSize,
                                           &fFallBack,
                                           fPmode,
                                           NdisMediumFddi);
                    }
    
                    // Done with this packet
                    break;  // out of do { } while (FALSE);
                }
    
                //
                // Determine whether the input address is a simple direct,
                // a broadcast, a multicast, or an SMT address.
                //
                FDDI_IS_SMT(*Address, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    AddressType = NDIS_PACKET_TYPE_SMT;
                }
                else
                {
                    //
                    // First check if it *at least* has the multicast address bit.
                    //
                    FDDI_IS_MULTICAST(Address, AddressLength, &ResultOfAddressCheck);
                    if (ResultOfAddressCheck)
                    {
                        //
                        // It is at least a multicast address.  Check to see if
                        // it is a broadcast address.
                        //
    
                        FDDI_IS_BROADCAST(Address, AddressLength, &ResultOfAddressCheck);
                        if (ResultOfAddressCheck)
                        {
                            FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);
    
                            AddressType = NDIS_PACKET_TYPE_BROADCAST;
                        }
                        else
                        {
                            AddressType = NDIS_PACKET_TYPE_MULTICAST;
                        }
                    }
                }
            }
            else
            {
                // Runt Packet
                AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
            }
    
            //
            // At this point we know that the packet is either:
            // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
            // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
            // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
            // - SMT Packet - indicated by AddressType = NDIS_PACKET_TYPE_SMT
            //
            // Walk the broadcast/multicast/SMT list and indicate up the packets.
            //
            // The packet is indicated if it meets the following criteria:
            //
            // if ((Binding is promiscuous) OR
            //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
            //   ((Packet is SMT) AND (Binding is SMT)) OR
            //   ((Packet is multicast) AND
            //    ((Binding is all-multicast) OR
            //      ((Binding is multicast) AND (address in approp. multicast list)))))
            //
            //
            //  Is this a directed packet?
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                UINT    LocalFilter;
    
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;
    
                //
                // Ignore if this is a loopback packet and this protocol specifically asked
                // us not to loop it back
                //
                if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                    (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                {
                    continue;
                }
    
                LocalFilter = LocalOpen->PacketFilters;
                if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||
    
                    ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||
    
                    ((AddressType == NDIS_PACKET_TYPE_SMT)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_SMT))          ||
    
                    ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
                     ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
                      ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                        (((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) &&
                         fddiFindMulticastLongAddress(LocalOpen->NumLongAddresses,
                                                      LocalOpen->MCastLongAddressBuf,
                                                      Address)
                        ) ||
                        ((AddressLength == FDDI_LENGTH_OF_SHORT_ADDRESS) &&
                         fddiFindMulticastShortAddress(LocalOpen->NumShortAddresses,
                                                       LocalOpen->MCastShortAddressBuf,
                                                       Address)
                        )
                        )
                      )
                     )
                    )
                    )
                {
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
    
                    fPmode = (LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                TRUE : FALSE;
                    
                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Hdr,
                                       PacketSize,
                                       pOob->HeaderSize,
                                       &fFallBack,
                                       fPmode,
                                       NdisMediumFddi);
                }
            }
        } while (FALSE);

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (LocalOpen = Filter->OpenList;
             LocalOpen != NULL;
             LocalOpen = NextOpen)
        {
            NextOpen = LocalOpen->NextOpen;
    
            if (LocalOpen->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                LocalOpen->ReceivedAPacket = FALSE;
    
                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
FddiFilterDprIndicateReceiveComplete(
    IN  PFDDI_FILTER            Filter
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;
    LOCK_STATE          LockState;

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // We need to aquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //
            LocalOpen->ReceivedAPacket = FALSE;

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


BOOLEAN
FASTCALL
fddiFindMulticastLongAddress(
    IN  UINT                    NumberOfAddresses,
    IN  UCHAR                   AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  UCHAR                   MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    Given an array of multicast addresses search the array for
    a particular multicast address.  It is assumed that the
    address array is already sorted.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    NumberOfAddresses - The number of addresses currently in the
    address array.

    AddressArray - An array of multicast addresses.

    MulticastAddress - The address to search for in the address array.

Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{

    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT Bottom = 0;
    UINT Middle = NumberOfAddresses / 2;
    UINT Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            FDDI_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                           MulticastAddress,
                                           FDDI_LENGTH_OF_LONG_ADDRESS,
                                           &Result);
            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
FASTCALL
fddiFindMulticastShortAddress(
    IN  UINT                    NumberOfAddresses,
    IN  UCHAR                   AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  UCHAR                   MulticastAddress[FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    Given an array of multicast addresses search the array for
    a particular multicast address.  It is assumed that the
    address array is already sorted.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    NumberOfAddresses - The number of addresses currently in the
    address array.

    AddressArray - An array of multicast addresses.

    MulticastAddress - The address to search for in the address array.

Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{
    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT    Bottom = 0;
    UINT    Middle = NumberOfAddresses / 2;
    UINT    Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            FDDI_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                           MulticastAddress,
                                           FDDI_LENGTH_OF_SHORT_ADDRESS,
                                           &Result);
            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
FddiShouldAddressLoopBack(
    IN  PFDDI_FILTER            Filter,
    IN  UCHAR                   Address[],
    IN  UINT                    AddressLength
    )
/*++

Routine Description:

    Do a quick check to see whether the input address should
    loopback.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: THIS ROUTINE DOES NOT CHECK THE SPECIAL CASE OF SOURCE
    EQUALS DESTINATION.

Arguments:

    Filter - Pointer to the filter database.

    Address - A network address to check for loopback.

    AddressLength - Length of the above address in bytes.

Return Value:

    Returns TRUE if the address needs to be loopback.  It
    will return FALSE if there is *no* chance that the address would
    require loopback.

--*/
{
    BOOLEAN fLoopback, fSelfDirected;

    FddiShouldAddressLoopBackMacro(Filter, Address, AddressLength, &fLoopback, &fSelfDirected);
    return(fLoopback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\efilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    efilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Anthony V. Ercolano (Tonye) 03-Aug-1990

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Adam Barr (adamba) 28-Nov-1990

        - Added AddressContexts

    Adam Barr (adamba) 28-May-1991

        - renamed MacXXX to EthXXX, changed filter.c to efilter.c

    10-July-1995        KyleB       Added separate queues for bindings
                                    that receive directed and broadcast
                                    packets.  Also fixed the request code
                                    that requires the filter database.


--*/

#include <precomp.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_EFILTER

#define ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(_F)                  \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    if (!((_F)->CombinedPacketFilter & NDIS_PACKET_TYPE_BROADCAST))     \
    {                                                                   \
        /*                                                              \
            We should never receive directed packets                    \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating broadcast when not set to.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}

#define ETH_CHECK_FOR_INVALID_DIRECTED_INDICATION(_F, _A)               \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    /*                                                                  \
        The result of comparing an element of the address               \
        array and the multicast address.                                \
                                                                        \
        Result < 0 Implies the adapter address is greater.              \
        Result > 0 Implies the address is greater.                      \
        Result = 0 Implies that the they are equal.                     \
    */                                                                  \
    INT Result;                                                         \
                                                                        \
    ETH_COMPARE_NETWORK_ADDRESSES_EQ((_F)->AdapterAddress,(_A),&Result);\
    if (Result != 0)                                                    \
    {                                                                   \
        /*                                                              \
            We should never receive directed packets                    \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating packets to another station when not in promiscuous mode.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}


BOOLEAN
EthCreateFilter(
    IN  UINT                    MaximumMulticastAddresses,
    IN  PUCHAR                  AdapterAddress,
    OUT PETH_FILTER *           Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    MaximumMulticastAddresses - The maximum number of multicast addresses
    that the MAC will support.

    AdapterAddress - the address of the adapter associated with this filter
    database.

    Filter - A pointer to an ETH_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PETH_FILTER LocalFilter;
    BOOLEAN     rc = FALSE;

    do
    {
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(ETH_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(ETH_FILTER));
            EthReferencePackage();
            ETH_COPY_NETWORK_ADDRESS(LocalFilter->AdapterAddress, AdapterAddress);
            LocalFilter->MaxMulticastAddresses = MaximumMulticastAddresses;
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}


//
// NOTE: THIS FUNCTION CANNOT BE PAGEABLE
//
VOID
EthDeleteFilter(
    IN  PETH_FILTER             Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an ETH_FILTER to be deleted.

Return Value:

    None.

--*/
{
    ASSERT(Filter->OpenList == NULL);

    //
    //  Free the memory that was allocated for the current multicast
    //  address list.
    //
    if (Filter->MCastAddressBuf)
    {
        FREE_POOL(Filter->MCastAddressBuf);
    }

    ASSERT(Filter->OldMCastAddressBuf == NULL);

    FREE_POOL(Filter);
    EthDereferencePackage();
}

NDIS_STATUS
EthDeleteFilterOpenAdapter(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    NDIS_STATUS         StatusToReturn;
    PETH_BINDING_INFO   LocalOpen = (PETH_BINDING_INFO)NdisFilterHandle;

    //
    //  Set the packet filter to NONE.
    //
    StatusToReturn = XFilterAdjust(Filter,
                                   NdisFilterHandle,
                                   (UINT)0,
                                   FALSE);
    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING))
    {
        NDIS_STATUS StatusToReturn2;

        //
        //  Clear the multicast addresses.
        //
        StatusToReturn2 = EthChangeFilterAddresses(Filter,
                                                   NdisFilterHandle,
                                                   0,
                                                   NULL,
                                                   FALSE);
        if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
        {
            StatusToReturn = StatusToReturn2;
        }
    }

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //
        if (--(LocalOpen->References) == 0)
        {
            //
            //  Remove the binding from the necessary lists.
            //
            XRemoveAndFreeBinding(Filter, LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //
            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return(StatusToReturn);
}


NDIS_STATUS
EthChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  UCHAR                   Addresses[][ETH_LENGTH_OF_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of ETH_LENGTH_OF_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following status:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PETH_BINDING_INFO   Binding = (PETH_BINDING_INFO)NdisFilterHandle;
    PNDIS_MINIPORT_BLOCK Miniport = Filter->Miniport;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result;
    UINT                i, j;
    LOCK_STATE          LockState;
    UCHAR               (*OldFilterMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS] = NULL;
    UINT                OldFilterNumAddresses = 0;
    
    WRITE_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        if (Filter->MaxMulticastAddresses == 0)
        {
            break;
        }
        
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastAddressBuf == NULL);
        Binding->OldMCastAddressBuf = Binding->MCastAddressBuf;
        Binding->OldNumAddresses = Binding->NumAddresses;
        Binding->MCastAddressBuf = NULL;
        Binding->NumAddresses = 0;

        if (!Set)
        {
            //
            // if we are removing a binding from the filter, since we may be
            // here while the driver is processing the request, save and
            // restore the current "Old" values and keep the filter WRITE lock 
            // all the time till we are done.
            //
            OldFilterMCastAddressBuf = Filter->OldMCastAddressBuf;
            OldFilterNumAddresses = Filter->OldNumAddresses;
        }
        else
        {
            ASSERT(Filter->OldMCastAddressBuf == NULL);
            Filter->MCastSet = Binding;
        }
        
        Filter->OldMCastAddressBuf = Filter->MCastAddressBuf;
        Filter->OldNumAddresses = Filter->NumAddresses;        
        Filter->MCastAddressBuf = NULL;
        Filter->NumAddresses = 0;
        

        //
        // fix the multicast list for the binding
        //
        if (AddressCount != 0)
        {
            Binding->MCastAddressBuf = ALLOC_FROM_POOL(ETH_LENGTH_OF_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                Result = -1;
                for (j = 0; j < Binding->NumAddresses; j++)
                {
                    ETH_COMPARE_NETWORK_ADDRESSES(Binding->MCastAddressBuf[j],
                                                  Addresses[i],
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                //
                // This address is already present. Caller supplied duplicate. Skip it.
                //
                if (Result == 0)
                    continue;
    
                Binding->NumAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastAddressBuf[j+1],
                               Binding->MCastAddressBuf[j],
                               (Binding->NumAddresses-j-1)*ETH_LENGTH_OF_ADDRESS);
                }
            
                MoveMemory(Binding->MCastAddressBuf[j],
                           Addresses[i],
                           ETH_LENGTH_OF_ADDRESS);
            }
        
            ASSERT(Binding->NumAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes or if we are actually deleting addresses instead of
        // adding them
        //
        Filter->MCastAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastAddresses * ETH_LENGTH_OF_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastAddressBuf == NULL)
        {
            if (Binding->MCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->MCastAddressBuf);
                Binding->MCastAddressBuf = NULL;
            }
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumAddresses; i++)
            {
                Result = -1;
                for (j = 0; j < Filter->NumAddresses; j++)
                {
                    ETH_COMPARE_NETWORK_ADDRESSES(Filter->MCastAddressBuf[j],
                                                  Binding->MCastAddressBuf[i],
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumAddresses ++;
                if (Filter->NumAddresses > Filter->MaxMulticastAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastAddressBuf[j+1],
                               Filter->MCastAddressBuf[j],
                               (Filter->NumAddresses-j-1)*ETH_LENGTH_OF_ADDRESS);
                }
            
                MoveMemory(Filter->MCastAddressBuf[j],
                           Binding->MCastAddressBuf[i],
                           ETH_LENGTH_OF_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;


        //
        // After all the hard work, determine if there was indeed a change
        //
        Result = -1;
        
        if (Filter->NumAddresses == Filter->OldNumAddresses)
        {
            for (i = 0; i < Filter->NumAddresses; i++)
            {
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastAddressBuf[i],
                                                 Filter->OldMCastAddressBuf[i],
                                                 &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (Set && (AddressCount == 0))
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastAddressBuf);
                Filter->OldMCastAddressBuf = NULL;
                Filter->OldNumAddresses = 0;
            }
        
            Binding = (PETH_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastAddressBuf);
                Binding->OldMCastAddressBuf = NULL;
                Binding->OldNumAddresses = 0;
            }
        }

    } while (FALSE);

#if ARCNET
    //
    // If the address array has changed, we have to call the
    // action array to inform the adapter of this.
    //
    if (Status == NDIS_STATUS_PENDING)
    {
        Binding = (PETH_BINDING_INFO)NdisFilterHandle;

        if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
            MINIPORT_TEST_FLAG((PNDIS_OPEN_BLOCK)Binding->NdisBindingHandle, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            if (Filter->NumAddresses > 0)
            {
                //
                // Turn on broadcast acceptance.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_ARCNET_BROADCAST_SET);
            }
            else
            {
                //
                // Unset the broadcast filter.
                //
                MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_ARCNET_BROADCAST_SET);
            }

            //
            //  Need to return success here so that we don't call down to the
            //  ARCnet miniport with an invalid OID, i.e. an ethernet one....
            //
            Status = NDIS_STATUS_SUCCESS;
        }

    }
#endif

    if (Filter->MaxMulticastAddresses != 0)
    {
        if (!Set)
        {
            //
            // if this is a request to adjust the multicast list
            // due to an open closing (called from EthDeleteFilterOpenAdapter)
            // then clean up right here while we still have the filter's
            // WRITE lock and restore the "Old" filter values
            //
            if (Status == NDIS_STATUS_PENDING)
                Status = NDIS_STATUS_SUCCESS;
            
            //
            // Operation completed, do post processing.
            //
            ethCompleteChangeFilterAddresses(Filter, Status, Binding, TRUE);
            Filter->OldMCastAddressBuf = OldFilterMCastAddressBuf;
            Filter->OldNumAddresses = OldFilterNumAddresses;
        }
        else if (Status != NDIS_STATUS_PENDING)
        {    
            //
            // Operation completed, do post processing.
            //
            ethCompleteChangeFilterAddresses(Filter, Status, NULL, TRUE);
        }
    }
    
    WRITE_UNLOCK_FILTER(Miniport, Filter, &LockState);

    return(Status);
}


VOID
ethCompleteChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_STATUS             Status,
    IN  PETH_BINDING_INFO       LocalBinding OPTIONAL,
    IN  BOOLEAN                 WriteFilterHeld
    )
/*++

Routine Description:

    Do post processing for the multicast adddress filter change.

Arguments:

    Filter  -   Pointer to the ethernet filter database.
    Status  -   Status of completion
    LocalBinding    - 
        if not NULL, specifies the binding that attempted the
        Multicast address change, otherwise the binding should 
        be picked up from Filter->McaseSet
    WrtiteFilterHeld   
        if set, the filter WRITE lock is already held and we should not
        attempt to take it again.
        
Return Value:

    None.

    called at DPC with miniport's Spinlock held.

--*/
{
    PETH_BINDING_INFO   Binding;
    LOCK_STATE          LockState;

    if (!WriteFilterHeld)
    {
        WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    }
    
    if (LocalBinding)
    {
        Binding = LocalBinding;
    }
    else
    {
        Binding = Filter->MCastSet;
        Filter->MCastSet = NULL;
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //

        if (Binding != NULL)
        {
            if (Binding->MCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->MCastAddressBuf);
            }
    
            Binding->MCastAddressBuf = Binding->OldMCastAddressBuf;
            Binding->NumAddresses = Binding->OldNumAddresses;
            Binding->OldMCastAddressBuf = NULL;
            Binding->OldNumAddresses = 0;
        }

        if (Filter->MCastAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastAddressBuf);
        }

        Filter->MCastAddressBuf = Filter->OldMCastAddressBuf;
        Filter->NumAddresses = Filter->OldNumAddresses;
        Filter->OldMCastAddressBuf = NULL;
        Filter->OldNumAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff.
        //
        if (Filter->OldMCastAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastAddressBuf);
            Filter->OldMCastAddressBuf = NULL;
            Filter->OldNumAddresses = 0;
        }
    
        if (Binding != NULL)
        {
            if (Binding->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastAddressBuf);
                Binding->OldMCastAddressBuf = NULL;
                Binding->OldNumAddresses = 0;
            }
        }
    }
    
    if (!WriteFilterHeld)
    {
        WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
    }
}



UINT
EthNumberOfOpenFilterAddresses(
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    NdisFilterHandle - Pointer to filter local open block.


Return Value:

    

--*/
{
    
    return(((PETH_BINDING_INFO)NdisFilterHandle)->NumAddresses);
}

VOID
EthQueryOpenFilterAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT UCHAR                   AddressArray[][ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PETH_BINDING_INFO   BindInfo = (PETH_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray >= (ETH_LENGTH_OF_ADDRESS * BindInfo->NumAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastAddressBuf,
                   ETH_LENGTH_OF_ADDRESS * BindInfo->NumAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
EthQueryGlobalFilterAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PETH_FILTER             Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT UCHAR               AddressArray[][ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use ETH_NUMBER_OF_GLOBAL_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumAddresses * ETH_LENGTH_OF_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = Filter->NumAddresses;

        MoveMemory(AddressArray,
                   Filter->MCastAddressBuf,
                   Filter->NumAddresses*ETH_LENGTH_OF_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FASTCALL
ndisMSetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

Called at DPC with Miniport's lock held.

--*/
{
    UINT                    NumberOfAddresses;
    NDIS_STATUS             Status;
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    BOOLEAN                 fCleanup = FALSE;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetMulticastList\n"));

    do
    {
        //
        //  If the media type is not Ethernet or Ethernet encapsulated ARCnet
        //  then bail.
        //
#if ARCNET
        if ((Miniport->MediaType != NdisMedium802_3) &&
            !((Miniport->MediaType == NdisMediumArcnet878_2) &&
               MINIPORT_TEST_FLAG(ReqRsvd->Open,
                                  fMINIPORT_OPEN_USING_ETH_ENCAPSULATION)))
#else
        if (Miniport->MediaType != NdisMedium802_3)
#endif
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_NOT_SUPPORTED;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: Invalid media\n"));
            break;
        }
    
        //
        //  Verify the information buffer length that was passed in.
        //
        if ((Request->DATA.SET_INFORMATION.InformationBufferLength % ETH_LENGTH_OF_ADDRESS) != 0)
        {
            //
            // The data must be a multiple of the Ethernet
            // address size.
            //
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_INVALID_LENGTH;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: Invalid length\n"));
    
            break;
        }
        
        if (Request->DATA.SET_INFORMATION.InformationBufferLength/ETH_LENGTH_OF_ADDRESS > Miniport->EthDB->MaxMulticastAddresses)
        {
            //
            // too many multicast addresses
            //
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_MULTICAST_FULL;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: too many addresses\n"));
    
            break;
        }
            
        
        //
        //  If this request is because of an open that is closing then we
        //  have already adjusted the settings and we just need to
        //  make sure that the adapter has the new settings.
        //
        if (MINIPORT_TEST_FLAG(ReqRsvd->Open, fMINIPORT_OPEN_CLOSING))
        {
            //
            //  By setting the Status to NDIS_STATUS_PENDING we will call
            //  down to the miniport's SetInformationHandler below.
            //
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            //
            //  Call the filter library for a normal set operation.
            //
            Status = EthChangeFilterAddresses(Miniport->EthDB,
                                              ReqRsvd->Open->FilterHandle,
                                              Request->DATA.SET_INFORMATION.InformationBufferLength/ETH_LENGTH_OF_ADDRESS,
                                              Request->DATA.SET_INFORMATION.InformationBuffer,
                                              TRUE);
            if (Status == NDIS_STATUS_PENDING)
            {
                fCleanup = TRUE;
            }
        }
    
        //
        //  If the filter library returned pending then we need to
        //  call the miniport driver.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            //
            //  Get a list of all the multicast address that need to be set.
            //
            ASSERT(Miniport->SetMCastBuffer == NULL);
    
            NumberOfAddresses = ethNumberOfGlobalAddresses(Miniport->EthDB);
            if (NumberOfAddresses != 0)
            {
                Miniport->SetMCastBuffer = ALLOC_FROM_POOL(NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                                           NDIS_TAG_FILTER_ADDR);
                if (Miniport->SetMCastBuffer == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                }
            }
    
            if (Status != NDIS_STATUS_RESOURCES)
            {
                EthQueryGlobalFilterAddresses(&Status,
                                              Miniport->EthDB,
                                              NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                              &NumberOfAddresses,
                                              Miniport->SetMCastBuffer);
            
                //
                //  Call the driver with the new multicast list.
                //
                SAVE_REQUEST_BUF(Miniport,
                                 Request,
                                 Miniport->SetMCastBuffer, NumberOfAddresses * ETH_LENGTH_OF_ADDRESS);
                MINIPORT_SET_INFO(Miniport,
                                  Request,
                                  &Status);
                //1 check to see if we should set fCleanup to false.
            }
        }
    
        //
        //  If we succeeded then update the request.
        //
        if (Status != NDIS_STATUS_PENDING)
        {
            RESTORE_REQUEST_BUF(Miniport, Request);
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
            }
            else
            {
                Request->DATA.SET_INFORMATION.BytesRead = 0;
                Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            }
        }
    
        if (Status != NDIS_STATUS_PENDING)
        {
            if (Miniport->SetMCastBuffer != NULL)
            {
                FREE_POOL(Miniport->SetMCastBuffer);
                Miniport->SetMCastBuffer = NULL;
            }
            if (fCleanup)
            {
                ethCompleteChangeFilterAddresses(Miniport->EthDB, Status, NULL, FALSE);
            }
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetMulticastList: 0x%x\n", Status));

    return(Status);
}


VOID
EthFilterDprIndicateReceive(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate a packet to
    all bindings.  The packet will be filtered so that only the
    appropriate bindings will receive the packet.  This is the
    code path for ndis 3.0 miniport drivers.

Arguments:

    Filter - Pointer to the filter database.

    MacReceiveContext - A MAC supplied context value that must be
    returned by the protocol if it calls MacTransferData.

    Address - The destination address from the received packet.

    HeaderBuffer - A virtual address of the virtually contiguous
    buffer containing the MAC header of the packet.

    HeaderBufferSize - An unsigned integer indicating the size of
    the header buffer, in bytes.

    LookaheadBuffer - A virtual address of the virtually contiguous
    buffer containing the first LookaheadBufferSize bytes of data
    of the packet.  The packet buffer is valid only within the current
    call to the receive event handler.

    LookaheadBufferSize - An unsigned integer indicating the size of
    the lookahead buffer, in bytes.

    PacketSize - An unsigned integer indicating the size of the received
    packet, in bytes.  This number has nothing to do with the lookahead
    buffer, but indicates how large the arrived packet is so that a
    subsequent MacTransferData request can be made to transfer the entire
    packet as necessary.

Return Value:

    None.

--*/
{
    //
    // Will hold the type of address that we know we've got.
    //
    UINT            AddressType;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS     StatusOfReceive;

    LOCK_STATE      LockState;

    //
    // Current Open to indicate to.
    //
    PETH_BINDING_INFO LocalOpen;
    PETH_BINDING_INFO NextOpen;

    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        NDIS_WARN(TRUE,
                  Filter->Miniport, 
                  NDIS_GFLAG_WARN_LEVEL_1,
                  ("EthFilterDprIndicateReceive: Miniport %p IndicateReceives with media disconnected\n",
                  Filter->Miniport));

        return;     
    }

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);


#if DBG
    Filter->Miniport->cDpcRcvIndications++;
    Filter->Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // Optimize single open case
    //
    if (Filter->SingleActiveOpen)
    {
        if (((HeaderBufferSize >= 14) && (PacketSize != 0)) ||
            (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS| NDIS_PACKET_TYPE_ALL_LOCAL)))
        {
            if (!ETH_IS_MULTICAST(Address))
            {
                DIRECTED_PACKETS_IN(Filter->Miniport);
                DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);
            }

            LocalOpen = Filter->SingleActiveOpen;

            ASSERT(LocalOpen != NULL);
            if (LocalOpen == NULL)
            {
                READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
                return;
            }

            LocalOpen->ReceivedAPacket = TRUE;

            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMedium802_3);
        }

        READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
        return;
    }

    //
    // If the packet is a runt packet, then only indicate to PROMISCUOUS, ALL_LOCAL
    //
    if ((HeaderBufferSize >= 14) && (PacketSize != 0))
    {
        //
        //  Handle the directed packet case first
        //
        if (!ETH_IS_MULTICAST(Address))
        {
            UINT    IsNotOurs;

            DIRECTED_PACKETS_IN(Filter->Miniport);
            DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);

            //
            // If it is a directed packet, then check if the combined packet
            // filter is PROMISCUOUS, if it is check if it is directed towards
            // us
            //
            IsNotOurs = FALSE;  // Assume it is
            if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS    |
                                                NDIS_PACKET_TYPE_ALL_MULTICAST  |
                                                NDIS_PACKET_TYPE_ALL_LOCAL))
            {
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                 Address,
                                                 &IsNotOurs);
            }

            //
            //  We definitely have a directed packet so lets indicate it now.
            //
            //  Walk the directed list and indicate up the packets.
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;

                //
                // Ignore if not directed to us and if the binding is not promiscuous
                //
                if (((LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) == 0) &&
                    (IsNotOurs ||
                    ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                {
                        continue;
                }


                //
                // Indicate the packet to the binding.
                //
                ProtocolFilterIndicateReceive(&StatusOfReceive,
                                              LocalOpen->NdisBindingHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookaheadBuffer,
                                              LookaheadBufferSize,
                                              PacketSize,
                                              NdisMedium802_3);

                LocalOpen->ReceivedAPacket = TRUE;
            }

            //
            // Done for uni-cast
            //
            READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
            return;
        }

        //
        // It is at least a multicast address.  Check to see if
        // it is a broadcast address.
        //
        if (ETH_IS_BROADCAST(Address))
        {
            ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);

            AddressType = NDIS_PACKET_TYPE_BROADCAST;
        }
        else
        {
            AddressType = NDIS_PACKET_TYPE_MULTICAST;
        }
    }
    else
    {
        // Runt packet
        AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
    }

    //
    // At this point we know that the packet is either:
    // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
    // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
    // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
    //
    // Walk the broadcast/multicast list and indicate up the packets.
    //
    // The packet is indicated if it meets the following criteria:
    //
    // if ((Binding is promiscuous) OR
    //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
    //   ((Packet is multicast) AND
    //    ((Binding is all-multicast) OR
    //     ((Binding is multicast) AND (address in multicast list)))))
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        UINT    LocalFilter = LocalOpen->PacketFilters;

        //
        //  Get the next open to look at.
        //
        NextOpen = LocalOpen->NextOpen;

        if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||

            ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
             (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||

            ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
             ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
               ethFindMulticast(LocalOpen->NumAddresses,
                                LocalOpen->MCastAddressBuf,
                                (PUCHAR)Address)
              )
             )
            )
           )
        {
            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMedium802_3);

            LocalOpen->ReceivedAPacket = TRUE;
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}



VOID
ethFilterDprIndicateReceivePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings.  The packets will be filtered so that only the
    appropriate bindings will receive the individual packets.
    This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    //
    // The Filter of interest
    //
    PETH_FILTER         Filter = Miniport->EthDB;

    //
    // Current packet being processed
    //
    PPNDIS_PACKET       pPktArray = PacketArray;
    PNDIS_PACKET        Packet;
    PNDIS_PACKET_OOB_DATA pOob;

    //
    // Pointer to the buffer in the ndispacket
    //
    PNDIS_BUFFER        Buffer;

    //
    // Pointer to the 1st segment of the buffer, points to dest address
    //
    PUCHAR              Address;

    UINT                i, PacketSize, NumIndicates = 0;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType;

    LOCK_STATE          LockState;

    //
    //  Decides whether we use the protocol's revpkt handler or fall
    //  back to old rcvindicate handler
    //
    BOOLEAN             fFallBack, fPmode;

    //
    // Current Open to indicate to.
    //
    PETH_BINDING_INFO   LocalOpen, NextOpen;
    PNDIS_OPEN_BLOCK    pOpenBlock;

    ULONG               OrgPacketStackLocation;
    
    PNDIS_STACK_RESERVED NSR;

    #ifdef TRACK_RECEIVED_PACKETS
    PETHREAD            CurThread = PsGetCurrentThread();
    // ULONG                   CurThread = KeGetCurrentProcessorNumber();
    #endif

    //
    // if filter is null, the adapter is indicating too early
    //

    ASSERT(Filter != NULL);

    //
    // make the compiler W4 happy
    //
    LockState.OldIrql = DISPATCH_LEVEL;

    ASSERT_MINIPORT_LOCKED(Miniport);

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
    {
        ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);
        READ_LOCK_FILTER_DPC(Miniport, Filter, &LockState);
    }
    else
    {
        READ_LOCK_FILTER(Miniport, Filter, &LockState);
    }

#if DBG
    Miniport->cDpcRcvIndications += NumberOfPackets;
    Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        do
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
            
            if ((OrgPacketStackLocation != -1) && 
                !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");

                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            5,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Packet,
                            (ULONG_PTR)PacketArray);

                
            }

#ifdef TRACK_RECEIVED_PACKETS
            if (OrgPacketStackLocation == -1)
            {
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        1, -1, 0, 0, 
                                        NDIS_GET_PACKET_STATUS(Packet));
            }
            else
            {
                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread, 
                                        2, OrgPacketStackLocation, NSR->RefCount, NSR->XRefCount,
                                        NDIS_GET_PACKET_STATUS(Packet));
            }
#endif            
            
            PUSH_PACKET_STACK(Packet);
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            ASSERT(NSR->RefCount == 0);
            
#ifdef NDIS_TRACK_RETURNED_PACKETS            
            if (NSR->RefCount != 0)
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
                
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            6,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Packet,
                            (ULONG_PTR)PacketArray);


            }
#endif
            pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
//            NdisGetFirstBufferFromPacket(Packet,
//                                         &Buffer,
//                                         &Address,
//                                         &LASize,
//                                         &PacketSize);


            Buffer = Packet->Private.Head;
            ASSERT(Buffer != NULL);
            Address = MmGetSystemAddressForMdl(Buffer);
            PacketSize = MmGetMdlByteCount(Buffer);
            for (Buffer = Buffer->Next;
                 Buffer != NULL;
                 Buffer = Buffer->Next)
            {
                PacketSize += MmGetMdlByteCount(Buffer);
            }

            
  //          ASSERT(Buffer != NULL);
    
            ASSERT(pOob->HeaderSize == 14);
            // ASSERT(PacketSize <= 1514);
    
            //
            // Set context in the packet so that NdisReturnPacket can do the right thing
            //
            NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
            //
            // Set the status here that nobody is holding the packet. This will get
            // overwritten by the real status from the protocol. Pay heed to what
            // the miniport is saying.
            //
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                //
                // set the packet status to success, but only if the packet is
                // coming from the lowest level driver. we don't want to override
                // the status of a packet that we have already set to pending
                // for lowest level serialized driver
                //
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    pOob->Status = NDIS_STATUS_SUCCESS;
                }
                fFallBack = FALSE;
            }
            else
            {
#if DBG
                if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                    MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                            ("Miniport going into D3, not indicating chained receives\n"));
                }
#endif
                fFallBack = TRUE;
            }

#ifdef TRACK_RECEIVED_PACKETS
            (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet) = pOob->Status;
#endif

#if DBG
            //
            // check to see if this is a loopback packet coming from miniport and complain
            // if miniport said it does not do loopback
            //
            
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_VERIFYING) &&
                ((ndisFlags & NDIS_GFLAG_WARNING_LEVEL_MASK) >= NDIS_GFLAG_WARN_LEVEL_1) &&
                (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK) &&
                !(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK)))
            {   
                UINT fIsFromUs;
                
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                 (Address + 6),
                                                 &fIsFromUs);
                if (!fIsFromUs)
                {
                    //
                    // miniport has indicated loopback packets while at the same time
                    // it asked ndis to loopback packets
                    //
                    DbgPrint("Miniport %p looping back packet %p and has NDIS_MAC_OPTION_NO_LOOPBACK flag set.\n",
                            Miniport, Packet);
                            
                    if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
                        DbgBreakPoint();
                }
            }

#endif
    
            //
            // Optimize single open case. Just indicate w/o any validation.
            //
            if (Filter->SingleActiveOpen)
            {
                if ((PacketSize >= 14) ||
                    (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS| NDIS_PACKET_TYPE_ALL_LOCAL)))
                {
                    LocalOpen = Filter->SingleActiveOpen;
                    
                    ASSERT(LocalOpen != NULL);
                    if (LocalOpen == NULL)
                    {
                        break;
                    }
                        
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
        
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                        TRUE : FALSE;
                    if (!ETH_IS_MULTICAST(Address))
                    {
                        DIRECTED_PACKETS_IN(Miniport);
                        DIRECTED_BYTES_IN(Miniport, PacketSize);
                    }

                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Address,
                                       PacketSize,
                                       14,
                                       &fFallBack,
                                       fPmode,
                                       NdisMedium802_3);
                }

                // Done with this packet
                break;  // out of do { } while (FALSE);
            }
    
            //
            // A quick check for Runt packets. These are only indicated to Promiscuous bindings
            //
            if (PacketSize >= 14)
            {
                //
                //  Handle the directed packet case first
                //
                if (!ETH_IS_MULTICAST(Address))
                {
                    UINT    IsNotOurs;
    
                    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK))
                    {
                        DIRECTED_PACKETS_IN(Miniport);
                        DIRECTED_BYTES_IN(Miniport, PacketSize);
                    }

                    //
                    // If it is a directed packet, then check if the combined packet
                    // filter is PROMISCUOUS, if it is check if it is directed towards us
                    //
                    IsNotOurs = FALSE;  // Assume it is
                    if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                        NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                        NDIS_PACKET_TYPE_ALL_MULTICAST))
                    {
                        ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                         Address,
                                                         &IsNotOurs);
                    }
    
                    //
                    //  We definitely have a directed packet so lets indicate it now.
                    //
                    //  Walk the directed list and indicate up the packets.
                    //
                    for (LocalOpen = Filter->OpenList;
                         LocalOpen != NULL;
                         LocalOpen = NextOpen)
                    {
                        //
                        //  Get the next open to look at.
                        //
                        NextOpen = LocalOpen->NextOpen;
    
                        //
                        // Ignore if not directed to us and if the binding is not promiscuous
                        // Or if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                            TRUE : FALSE;

                        
                        if (!fPmode &&
                            (IsNotOurs || 
                            ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                        {
                                
                            continue;
                        }
    
                        if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                            (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                        {
                            continue;
                        }
    

                        pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                        LocalOpen->ReceivedAPacket = TRUE;
                        NumIndicates ++;


    
                        IndicateToProtocol(Miniport,
                                           Filter,
                                           pOpenBlock,
                                           Packet,
                                           NSR,
                                           Address,
                                           PacketSize,
                                           14,
                                           &fFallBack,
                                           fPmode,
                                           NdisMedium802_3);

                    }
    
                    // Done with this packet
                    break;  // out of do { } while (FALSE);
                }
    
                //
                // It is at least a multicast address.  Check to see if
                // it is a broadcast address.
                //
                if (ETH_IS_BROADCAST(Address))
                {
                    ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);
    
                    AddressType = NDIS_PACKET_TYPE_BROADCAST;
                }
                else
                {
                    AddressType = NDIS_PACKET_TYPE_MULTICAST;
                }
            }
            else
            {
                // Runt packet
                AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
            }
    
            //
            // At this point we know that the packet is either:
            // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
            // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
            // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
            //
            // Walk the broadcast/multicast list and indicate up the packets.
            //
            // The packet is indicated if it meets the following criteria:
            //
            // if ((Binding is promiscuous) OR
            //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
            //   ((Packet is multicast) AND
            //    ((Binding is all-multicast) OR
            //     ((Binding is multicast) AND (address in multicast list)))))
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                UINT    LocalFilter;
    
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;
    
                //
                // Ignore if this is a loopback packet and this protocol specifically asked
                // us not to loop it back
                //
                if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                    (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                {
                    continue;
                }
    
                LocalFilter = LocalOpen->PacketFilters;
                if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||
    
                    ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||
    
                    ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
                     ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
                      ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                       ethFindMulticast(LocalOpen->NumAddresses,
                                        LocalOpen->MCastAddressBuf,
                                        (PUCHAR)Address)
                      )
                     )
                    )
                   )
                {
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
    
                    fPmode = (LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                TRUE : FALSE;
                    
                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Address,
                                       PacketSize,
                                       14,
                                       &fFallBack,
                                       fPmode,
                                       NdisMedium802_3);
                }
            }
        } while (FALSE);

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (LocalOpen = Filter->OpenList;
             LocalOpen != NULL;
             LocalOpen = NextOpen)
        {
            NextOpen = LocalOpen->NextOpen;
    
            if (LocalOpen->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                LocalOpen->ReceivedAPacket = FALSE;
    
                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
            }
        }
    }

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
    {
        READ_UNLOCK_FILTER_DPC(Miniport, Filter, &LockState);
    }
    else
    {
        READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
    }
}


VOID
EthFilterDprIndicateReceiveComplete(
    IN  PETH_FILTER             Filter
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{
    PETH_BINDING_INFO LocalOpen, NextOpen;
    LOCK_STATE        LockState;

    ASSERT(Filter != NULL);
    if (Filter == NULL)
    {
        return;
    }
    
    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // We need to aquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //
            LocalOpen->ReceivedAPacket = FALSE;

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}

BOOLEAN
FASTCALL
ethFindMulticast(
    IN  UINT                    NumberOfAddresses,
    IN  UCHAR                   AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  UCHAR                   MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    Check whether the given multicast address is part of the list within a binding
    It is assumed that the address array is already sorted.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    LocalOpen - The binding in question
    MulticastAddress - The address to search for in the address array.


Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{
    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT    Bottom = 0;
    UINT    Middle = NumberOfAddresses / 2;
    UINT    Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            ETH_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                          MulticastAddress,
                                          &Result);

            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
EthShouldAddressLoopBack(
    IN  PETH_FILTER             Filter,
    IN  UCHAR                   Address[ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    Do a quick check to see whether the input address should
    loopback.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: THIS ROUTINE DOES NOT CHECK THE SPECIAL CASE OF SOURCE
    EQUALS DESTINATION.

Arguments:

    Filter - Pointer to the filter database.

    Address - A network address to check for loopback.


Return Value:

    Returns TRUE if the address is *likely* to need loopback.  It
    will return FALSE if there is *no* chance that the address would
    require loopback.

--*/
{
    BOOLEAN fLoopback, fSelfDirected;

    EthShouldAddressLoopBackMacro(Filter, Address, &fLoopback, &fSelfDirected);

    return(fLoopback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\cprotos.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    cprotos.h

Abstract:

    NDIS wrapper function prototypes for common functions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

NTSTATUS
ndisMIrpCompletion(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           Context
    );

#undef NdisMSetAttributes
VOID
NdisMSetAttributes(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_HANDLE                     MiniportAdapterContext,
    IN  BOOLEAN                         BusMaster,
    IN  NDIS_INTERFACE_TYPE             AdapterType
    );

NDIS_STATUS
ndisPnPNotifyAllTransports(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NET_PNP_EVENT_CODE              PnpEvent,
    IN  PVOID                           Buffer,
    IN  ULONG                           BufferLength
    );

NDIS_STATUS
FASTCALL
ndisPnPNotifyBinding(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNET_PNP_EVENT                  NetPnpEvent
    );

PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
ndisCompletionRoutine(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );
    
NTSTATUS
ndisPnPDispatch(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );
    
BOOLEAN
ndisMIsr(
    IN  PKINTERRUPT                     KInterrupt,
    IN  PVOID                           Context
    );

VOID
ndisMDpc(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

VOID
ndisMWakeUpDpcX(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
ndisMPollMediaState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

#undef  NdisMSetTimer
VOID
NdisMSetTimer(
    IN  PNDIS_MINIPORT_TIMER            MiniportTimer,
    IN  UINT                            MillisecondsToDelay
    );

VOID
ndisMDpcX(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

#if NDIS_RECV_SCALE
BOOLEAN
ndisMiniportIsr(
    IN PKINTERRUPT                  KInterrupt,
    IN PVOID                        Context
    );

VOID
ndisMiniportMultipleDpc(
    IN PVOID SystemSpecific1,
    IN PVOID InterruptContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
ndisMiniportDpc(
    IN PVOID SystemSpecific1,
    IN PVOID InterruptContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );
#endif

VOID
ndisMTimerDpcX(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

VOID
ndisMWakeUpDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
ndisMDeferredDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );
    
NDIS_STATUS
NdisCoAssignInstanceName(
    IN  NDIS_HANDLE                     NdisVcHandle,
    IN  PNDIS_STRING                    BaseInstanceName,
    OUT PNDIS_STRING                    pVcInstanceName     OPTIONAL
    );

NDIS_STATUS
ndisMChangeClass(
    IN  UINT                            OldFilterClasses,
    IN  UINT                            NewFilterClasses,
    IN  NDIS_HANDLE                     BindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest,
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
ndisMReset(
    IN  NDIS_HANDLE                     NdisBindingHandle
    );

NDIS_STATUS
ndisMRequest(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );

NDIS_STATUS
ndisMRequestX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );

VOID
FASTCALL
ndisMAbortRequests(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

VOID
FASTCALL
ndisMProcessDeferred(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NDIS_STATUS
ndisMTransferData(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  UINT                            ByteOffset,
    IN  UINT                            BytesToTransfer,
    IN  OUT PNDIS_PACKET                Packet,
    OUT PUINT                           BytesTransferred
    );

#undef NdisMTransferDataComplete
VOID
NdisMTransferDataComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status,
    IN  UINT                            BytesTransferred
    );

VOID
FASTCALL
ndisMDeferredReturnPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

VOID
ndisMDummyIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NTSTATUS
ndisWMIDispatch(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            pirp
    );

NTSTATUS
FASTCALL
ndisWmiDisableEvents(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          Guid
    );

NTSTATUS
FASTCALL
ndisWmiEnableEvents(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          Guid
    );

NTSTATUS
ndisWmiChangeSingleItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_ITEM              wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiChangeSingleInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_INSTANCE          wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiQuerySingleInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_INSTANCE          wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiQueryAllData(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          guid,
    IN  PWNODE_ALL_DATA                 wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisQueryGuidData(
    IN  PUCHAR                          Buffer,
    IN  ULONG                           BufferLength,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock,
    IN  LPGUID                          guid,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisQueryGuidDataSize(
    OUT PULONG                          pBytesNeeded,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock    OPTIONAL,
    IN  LPGUID                          guid
    );

NTSTATUS
ndisWmiGetGuid(
    OUT PNDIS_GUID  *                   ppNdisGuid,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          guid,
    IN  NDIS_STATUS                     status
    );

NTSTATUS
ndisWmiRegister(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG_PTR                       RegistrationType,
    IN  PWMIREGINFO                     wmiRegInfo,
    IN  ULONG                           wmiRegInfoSize,
    IN  PULONG                          pReturnSize
    );

VOID
ndisNotifyWmiBindUnbind(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_PROTOCOL_BLOCK                Protocol,
    BOOLEAN                             fBind
    );

VOID
ndisNotifyDevicePowerStateChange(
    PNDIS_MINIPORT_BLOCK                Miniport,
    NDIS_DEVICE_POWER_STATE             PowerState
    );

NDIS_STATUS
ndisQuerySupportedGuidToOidList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

USHORT
ndisWmiMapOids(
    IN  OUT PNDIS_GUID                  pDst,
    IN  IN  USHORT                      cDst,
    IN      PNDIS_OID                   pOidList,
    IN      USHORT                      cOidList,
    IN      PNDIS_GUID                  ndisSupportedList,
    IN      ULONG                       cSupportedList
    );

NDIS_STATUS
ndisQueryCustomGuids(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    OUT PNDIS_GUID  *                   ppGuidToOid,
    OUT PUSHORT                         pcGuidToOid
    );

NTSTATUS
ndisWmiFindInstanceName(
    IN  PNDIS_CO_VC_PTR_BLOCK   *       ppVcBlock,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWSTR                           pInstanceName,
    IN  USHORT                          cbInstanceName
    );

NDIS_STATUS
ndisQuerySetMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock    OPTIONAL,
    IN  BOOLEAN                         fSet,
    IN  PNDIS_REQUEST                   pRequest,
    IN  PLARGE_INTEGER                  TimeOut     OPTIONAL
    );

NDIS_STATUS
ndisMProcessResetRequested(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PBOOLEAN                        pAddressingReset
    );

#undef NdisMIndicateStatus
VOID
NdisMIndicateStatus(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  NDIS_STATUS                     GeneralStatus,
    IN  PVOID                           StatusBuffer,
    IN  UINT                            StatusBufferSize
    );

#undef NdisMIndicateStatusComplete
VOID
NdisMIndicateStatusComplete(
    IN  NDIS_HANDLE                     MiniportHandle
    );

#undef NdisMResetComplete
VOID
NdisMResetComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

VOID
ndisMResetCompleteStage1(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

VOID
FASTCALL
ndisMResetCompleteStage2(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

//
// WAN Handlers
//
NDIS_STATUS
ndisMWanSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     NdisLinkHandle,
    IN  PNDIS_WAN_PACKET                Packet
    );

#undef NdisMWanIndicateReceive
VOID
NdisMWanIndicateReceive(
    OUT PNDIS_STATUS                    Status,
    IN NDIS_HANDLE                      MiniportAdapterHandle,
    IN NDIS_HANDLE                      NdisLinkContext,
    IN PUCHAR                           Packet,
    IN ULONG                            PacketSize
    );

#undef NdisMWanIndicateReceiveComplete
VOID
NdisMWanIndicateReceiveComplete(
    IN NDIS_HANDLE                      MiniportAdapterHandle,
    IN NDIS_HANDLE                      NdisLinkContext
    );

NDIS_STATUS
ndisMAllocateRequest(
    OUT PNDIS_REQUEST   *               pRequest,
    IN   NDIS_OID                       Oid,
    IN   PVOID                          Buffer      OPTIONAL,
    IN   ULONG                          BufferLength
    );

// VOID
// ndisMFreeInternalRequest(
//  IN  PVOID                           PRequest
//  )
#define ndisMFreeInternalRequest(_pRequest) FREE_POOL(_pRequest)

VOID
ndisMTimerDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
FASTCALL
ndisMAbortPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open OPTIONAL,
    IN  PVOID                           CancelId OPTIONAL
    );

BOOLEAN
FASTCALL
ndisMLoopbackPacketX(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

BOOLEAN
FASTCALL
ndisMIsLoopbackPacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet,
    OUT PNDIS_PACKET    *               LoopbackPacket  OPTIONAL
    );

VOID
ndisMRundownRequests(
    IN  PNDIS_WORK_ITEM                 pWorkItem
    );

VOID
FASTCALL
ndisMDoRequests(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMCopyFromPacketToBuffer(
    IN  PNDIS_PACKET                    Packet,
    IN  UINT                            Offset,
    IN  UINT                            BytesToCopy,
    OUT PUCHAR                          Buffer,
    OUT PUINT                           BytesCopied
    );

VOID
FASTCALL
ndisMAdjustFilters(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PFILTERDBS                      FilterDB
    );

LONG
ndisMDoMiniportOp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  BOOLEAN                         Query,
    IN  ULONG                           Oid,
    IN  PVOID                           Buf,
    IN  LONG                            BufSize,
    IN  LONG                            ErrorCodesToReturn,
    IN  BOOLEAN                         fMandatory
    );

VOID
ndisMOpenAdapter(
    OUT PNDIS_STATUS                    Status,
    IN  PNDIS_OPEN_BLOCK                NewOpenP,
    IN  BOOLEAN                         UsingEncapsulation
    );

VOID
FASTCALL
ndisMSyncQueryInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  PNDIS_REQUEST                   AbortedRequest
    );

#undef NdisMSetInformationComplete
VOID
NdisMSetInformationComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status
    );

#undef NdisMQueryInformationComplete
VOID
NdisMQueryInformationComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status
    );
VOID
FASTCALL
ndisMSyncSetInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  PNDIS_REQUEST                   AbortedRequest
    );

VOID
ndisMRequestSetInformationPost(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    IN  NDIS_STATUS                     Status
    );

BOOLEAN
FASTCALL
ndisMQueueRequest(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

VOID
FASTCALL
ndisMRestoreFilterSettings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open OPTIONAL,
    IN  BOOLEAN                         fReset
    );

NDIS_STATUS
FASTCALL
ndisMSetPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetProtocolOptions(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetCurrentLookahead(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetFunctionalAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetGroupAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetFddiMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetAddWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetRemoveWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
ndisMSetInformation(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryCurrentPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );
    
NDIS_STATUS
FASTCALL
ndisMQueryMediaSupported(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryEthernetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryLongMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryShortMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryMaximumFrameSize(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryMaximumTotalSize(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryNetworkAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryWakeUpPatternList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
ndisMQueryInformation(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMDispatchRequest(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    IN  BOOLEAN                         fQuery
    );

//
// X Filter
//
VOID
FASTCALL
XFilterLockHandler(
    IN  PETH_FILTER                     Filter,
    IN OUT  PLOCK_STATE                 pLockState
    );

VOID
XRemoveAndFreeBinding(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

VOID
XRemoveBindingFromLists(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

NDIS_STATUS
XFilterAdjust(
    IN  PX_FILTER                       Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            FilterClasses,
    IN  BOOLEAN                         Set
    );

VOID
XUndoFilterAdjust(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

BOOLEAN
XNoteFilterOpenAdapter(
    IN  PX_FILTER                       Filter,
    IN  NDIS_HANDLE                     NdisBindingHandle,
    OUT PNDIS_HANDLE                    NdisFilterHandle
    );

//
// EthFilterxxx
//
BOOLEAN
EthCreateFilter(
    IN  UINT                            MaximumMulticastAddresses,
    IN  PUCHAR                          AdapterAddress,
    OUT PETH_FILTER *                   Filter
    );

VOID
EthDeleteFilter(
    IN  PETH_FILTER                     Filter
    );

NDIS_STATUS
EthDeleteFilterOpenAdapter(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
EthChangeFilterAddresses(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  UCHAR                           Addresses[][ETH_LENGTH_OF_ADDRESS],
    IN  BOOLEAN                         Set
    );

BOOLEAN
EthShouldAddressLoopBack(
    IN  PETH_FILTER                     Filter,
    IN  UCHAR                            Address[ETH_LENGTH_OF_ADDRESS]
    );

UINT
EthNumberOfOpenFilterAddresses(
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

VOID
EthQueryGlobalFilterAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PETH_FILTER                     Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT UCHAR                       AddressArray[][ETH_LENGTH_OF_ADDRESS]
    );

VOID
EthQueryOpenFilterAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT UCHAR                       AddressArray[][ETH_LENGTH_OF_ADDRESS]
    );


VOID
EthFilterIndicateReceive(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
EthFilterIndicateReceiveComplete(
    IN  PETH_FILTER                     Filter
    );

BOOLEAN
FASTCALL
ethFindMulticast(
    IN  UINT                            NumberOfAddresses,
    IN  UCHAR                           AddressArray[][ETH_LENGTH_OF_ADDRESS],
    IN  UCHAR                           MulticastAddress[ETH_LENGTH_OF_ADDRESS]
    );

VOID
ethCompleteChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_STATUS             Status,
    IN  PETH_BINDING_INFO       LocalBinding OPTIONAL,
    IN  BOOLEAN                 WriteFilterHeld
    );

VOID
ethFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

VOID
EthFilterDprIndicateReceive(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
EthFilterDprIndicateReceiveComplete(
    IN  PETH_FILTER                     Filter
    );

// UINT
// ethNumberOfGlobalAddresses(
//  IN  PETH_FILTER                     Filter
//  );
#define ethNumberOfGlobalAddresses(_Filter) (_Filter)->NumAddresses

//
// FddiFilterxxxx
//
BOOLEAN
FddiCreateFilter(
    IN  UINT                            MaximumMulticastLongAddresses,
    IN  UINT                            MaximumMulticastShortAddresses,
    IN  PUCHAR                          AdapterLongAddress,
    IN  PUCHAR                          AdapterShortAddress,
    OUT PFDDI_FILTER *                  Filter
    );

VOID
FddiDeleteFilter(
    IN  PFDDI_FILTER                    Filter
    );

NDIS_STATUS
FddiDeleteFilterOpenAdapter(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
FddiChangeFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  CHAR                            Addresses[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
FddiChangeFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  CHAR                            Addresses[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  BOOLEAN                         Set
    );

BOOLEAN
FddiShouldAddressLoopBack(
    IN  PFDDI_FILTER                    Filter,
    IN  UCHAR                           Address[],
    IN  UINT                            LengthOfAddress
    );

UINT
FddiNumberOfOpenFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

UINT
FddiNumberOfOpenFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

VOID
FddiQueryGlobalFilterLongAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    );

VOID
FddiQueryGlobalFilterShortAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
FddiQueryOpenFilterLongAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    );

VOID
FddiQueryOpenFilterShortAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
FddiFilterIndicateReceive(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  UINT                            AddressLength,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
FddiFilterIndicateReceiveComplete(
    IN  PFDDI_FILTER                    Filter
    );

BOOLEAN
FASTCALL
fddiFindMulticastLongAddress(
    IN  UINT                            NumberOfAddresses,
    IN  UCHAR                           AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  UCHAR                           MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    );

BOOLEAN
FASTCALL
fddiFindMulticastShortAddress(
    IN  UINT                            NumberOfAddresses,
    IN  UCHAR                           AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  UCHAR                           MulticastAddress[FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
fddiCompleteChangeFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_STATUS                     Status
    );

VOID
fddiCompleteChangeFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_STATUS                     Status
    );

VOID
FddiFilterDprIndicateReceive(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  UINT                            AddressLength,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
FddiFilterDprIndicateReceiveComplete(
    IN  PFDDI_FILTER                    Filter
    );

VOID
fddiFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

// UINT
// fddiNumberOfShortGlobalAddresses(
//  IN  PFDDI_FILTER                    Filter
//  );
#define fddiNumberOfShortGlobalAddresses(_Filter)   (_Filter)->NumShortAddresses

// UINT
// fddiNumberOfLongGlobalAddresses(
//  IN  PFDDI_FILTER                    Filter
//  );
#define fddiNumberOfLongGlobalAddresses(_Filter)    (_Filter)->NumLongAddresses

//
// TrFilterxxx
//
BOOLEAN
TrCreateFilter(
    IN  PUCHAR                          AdapterAddress,
    OUT PTR_FILTER *                    Filter
    );

VOID
TrDeleteFilter(
    IN  PTR_FILTER                      Filter
    );

NDIS_STATUS
TrDeleteFilterOpenAdapter(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
TrChangeFunctionalAddress(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UCHAR                           FunctionalAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
TrChangeGroupAddress(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UCHAR                           GroupAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                         Set
    );

BOOLEAN
TrShouldAddressLoopBack(
    IN  PTR_FILTER                      Filter,
    IN  UCHAR                           DestinationAddress[TR_LENGTH_OF_ADDRESS],
    IN  UCHAR                           SourceAddress[TR_LENGTH_OF_ADDRESS]
    );

VOID
TrFilterIndicateReceive(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
TrFilterIndicateReceiveComplete(
    IN  PTR_FILTER                      Filter
    );

VOID
trUndoChangeFunctionalAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
trUndoChangeGroupAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
trCompleteChangeGroupAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
TrFilterDprIndicateReceive(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
TrFilterDprIndicateReceiveComplete(
    IN  PTR_FILTER                      Filter
    );

VOID
trFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

//
// ArcFilterxxx
//
#if ARCNET

BOOLEAN
FASTCALL
ndisMArcnetSendLoopback(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMBuildArcnetHeader(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_OPEN_BLOCK                    Open,
    PNDIS_PACKET                        Packet
    );

VOID
ndisMFreeArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet,
    IN  PNDIS_OPEN_BLOCK                Open    
    );

VOID
ArcDeleteFilter(
    IN  PARC_FILTER                     Filter
    );


NDIS_STATUS
ndisMArcTransferData(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  UINT                            ByteOffset,
    IN  UINT                            BytesToTransfer,
    IN  OUT                             PNDIS_PACKET Packet,
    OUT PUINT                           BytesTransferred
    );

VOID
ndisMArcIndicateEthEncapsulatedReceive(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PVOID                           HeaderBuffer,
    IN  PVOID                           DataBuffer,
    IN  UINT                            Length
    );

VOID
arcUndoFilterAdjust(
    IN  PARC_FILTER                     Filter,
    IN  PARC_BINDING_INFO               Binding
    );

NDIS_STATUS
ArcConvertOidListToEthernet(
    IN  PNDIS_OID                       OidList,
    IN  PULONG                          NumberOfOids
    );

NDIS_STATUS
ArcAllocateBuffers(
    IN  PARC_FILTER                     Filter
    );

NDIS_STATUS
ArcAllocatePackets(
    IN  PARC_FILTER                     Filter
    );

VOID
ArcDiscardPacketBuffers(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet
    );

VOID
ArcDestroyPacket(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet
    );

BOOLEAN
ArcConvertToNdisPacket(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet,
    IN  BOOLEAN                         ConvertWholePacket
    );
#endif

//
//  WORK ITEM ROUTINES.
//
VOID
FASTCALL
ndisMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID   *                       WorkItemContext OPTIONAL,
    OUT PVOID   *                       WorkItemHandler OPTIONAL
    );

NDIS_STATUS
FASTCALL
ndisMQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext
    );

NDIS_STATUS
FASTCALL
ndisMQueueNewWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext,
    IN  PVOID                           WorkItemHandler OPTIONAL
    );

VOID
FASTCALL
ndisIMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext
    );

//
//  SEND HANDLERS
//
//
BOOLEAN
FASTCALL
ndisMStartSendPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

BOOLEAN
FASTCALL
ndisMStartSends(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

BOOLEAN
FASTCALL
ndisMStartWanSends(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

#undef NdisMSendResourcesAvailable
VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE                     MiniportAdapterHandle
    );

#undef NdisMSendComplete
VOID
NdisMSendComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status
    );

VOID
ndisMSendCompleteX(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status
    );

#undef NdisMWanSendComplete
VOID
NdisMWanSendComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_WAN_PACKET                Packet,
    IN  NDIS_STATUS                     Status
    );

VOID
ndisMSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

VOID
ndisMSendPacketsX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMSendX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMCoSendPackets(
    IN  NDIS_HANDLE                     NdisVcHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMRejectSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

VOID
ndisMRejectSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   Packets,
    IN  UINT                            NumberOfPackets
    );
    
VOID
FASTCALL
ndisMRestoreOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UCHAR                           Flags                   
    );

VOID
FASTCALL
ndisMSwapOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  UCHAR                           Flags
    );

NTSTATUS
ndisPassIrpDownTheStack(
    IN  PIRP                            pIrp,
    IN  PDEVICE_OBJECT                  pNextDeviceObject
    );

//
// Co-Ndis prototypes
//
VOID
ndisNotifyAfRegistration(
    IN  struct _NDIS_AF_NOTIFY  *       AfNotify
    );

NDIS_STATUS
ndisCreateNotifyQueue(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open            OPTIONAL,
    IN  PCO_ADDRESS_FAMILY              AddressFamily   OPTIONAL,
    IN  PNDIS_AF_NOTIFY         *       AfNotify
    );

BOOLEAN
FASTCALL
ndisReferenceAf(
    IN  PNDIS_CO_AF_BLOCK               AfBlock
    );

VOID
FASTCALL
ndisDereferenceAf(
    IN  PNDIS_CO_AF_BLOCK               AfBlock
    );

BOOLEAN
FASTCALL
ndisReferenceSap(
    IN  PNDIS_CO_SAP_BLOCK              SapBlock
    );

VOID
FASTCALL
ndisDereferenceSap(
    IN  PNDIS_CO_SAP_BLOCK              SapBlock
    );

BOOLEAN
FASTCALL
ndisReferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK           VcPtr
    );

VOID
FASTCALL
ndisDereferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK           VcPtr
    );

VOID
FASTCALL
ndisMCoFreeResources(
    PNDIS_OPEN_BLOCK                    Open
    );

//
//  Fake handlers
//
NDIS_STATUS
ndisMFakeWanSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     NdisLinkHandle,
    IN  PVOID                           Packet
    );

NDIS_STATUS
ndisMFakeSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

VOID
ndisMFakeSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMFakeReset(
    IN  NDIS_HANDLE                     NdisBindingHandle
    );

NDIS_STATUS
ndisMFakeRequest(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );


//
//  POWER MANAGEMENT ROUTINES
//
NTSTATUS
FASTCALL
ndisQueryPowerCapabilities(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMediaDisconnectWorker(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           Context
    );

NTSTATUS
ndisMediaDisconnectComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

VOID
ndisMediaDisconnectTimeout(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           Context,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

NTSTATUS
ndisWaitWakeComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

NTSTATUS
ndisQueryPowerComplete(
    IN PDEVICE_OBJECT                   pdo,
    IN PIRP                             pirp,
    IN PVOID                            Context
    );

NTSTATUS
ndisMPowerPolicy(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  SYSTEM_POWER_STATE              SystemState,
    IN  PDEVICE_POWER_STATE             pDeviceState,
    IN  BOOLEAN                         fIsQuery
    );

NTSTATUS
ndisQueryPower(
    IN  PIRP                            pirp,
    IN  PIO_STACK_LOCATION              pirpSp,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisPmHaltMiniport(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

NDIS_STATUS
ndisPmInitializeMiniport(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

NDIS_STATUS
ndisQuerySetMiniportDeviceState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  DEVICE_POWER_STATE              DeviceState,
    IN  NDIS_OID                        Oid,
    IN  BOOLEAN                         fSet
    );

NTSTATUS
ndisRequestedDevicePowerIrpComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

VOID
ndisDevicePowerOn(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           pContext
    );

NTSTATUS
ndisSetDevicePowerOnComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );

VOID
ndisDevicePowerDown(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           pContext
    );

NTSTATUS
ndisSetDevicePowerDownComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );

NTSTATUS
ndisSetPower(
    IN  PIRP                            pirp,
    IN  PIO_STACK_LOCATION              pirpSp,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
ndisPowerDispatch(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp
    );

BOOLEAN
FASTCALL
ndisQueueOpenOnMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                MiniportOpen
    );

NDIS_STATUS
ndisQueueBindWorkitem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisQueuedCheckAdapterBindings(
    IN  PNDIS_WORK_ITEM                 pWorkItem,
    IN  PVOID                           Context
    );

BOOLEAN
ndisIsMiniportStarted(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\fsbpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    fixed-size block pools.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#pragma once


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//    that represenets a pointer-sized storage location that the pool can
//    use to chain free blocks together.  Most often this will be zero
//    (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//    ExAllocatePoolWithTag.  This allows callers to track
//    memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//    blocks when they are first allocated by the pool.  This allows the
//    caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN  USHORT                      BlockSize,
    IN  USHORT                      FreeBlockLinkOffset,
    IN  ULONG                       Tag,
    IN  NDIS_BLOCK_INITIALIZER      BuildFunction OPTIONAL
    );

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN  HANDLE                      PoolHandle
    );

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN  HANDLE                      PoolHandle
    );

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN  PUCHAR                      Block
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\filter.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    MACRO for protocol filters.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    New functionality
--*/

#ifndef _FILTER_DEFS_
#define _FILTER_DEFS_

#define INDICATED_PACKET(_Miniport) (_Miniport)->IndicatedPacket[CURRENT_PROCESSOR]

//
// Used by the filter packages for indicating receives
//
#define FilterIndicateReceive(Status,                                                   \
                              NdisBindingHandle,                                        \
                              MacReceiveContext,                                        \
                              HeaderBuffer,                                             \
                              HeaderBufferSize,                                         \
                              LookaheadBuffer,                                          \
                              LookaheadBufferSize,                                      \
                              PacketSize)                                               \
{                                                                                       \
    *(Status) =(((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ReceiveHandler)(               \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ProtocolBindingContext,            \
            (MacReceiveContext),                                                        \
            (HeaderBuffer),                                                             \
            (HeaderBufferSize),                                                         \
            (LookaheadBuffer),                                                          \
            (LookaheadBufferSize),                                                      \
            (PacketSize));                                                              \
}


//
// Used by the filter packages for indicating receive completion
//

#define FilterIndicateReceiveComplete(NdisBindingHandle)                                \
{                                                                                       \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ReceiveCompleteHandler)(                  \
        ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ProtocolBindingContext);               \
}


#if TRACK_RECEIVED_PACKETS
#define IndicateToProtocol(_Miniport,                                                   \
                           _Filter,                                                     \
                           _pOpenBlock,                                                 \
                           _Packet,                                                     \
                           _NSR,                                                        \
                           _Hdr,                                                        \
                           _PktSize,                                                    \
                           _HdrSize,                                                    \
                           _fFallBack,                                                  \
                           _Pmode,                                                      \
                           _Medium)                                                     \
{                                                                                       \
    UINT                LookaheadBufferSize;                                            \
    PNDIS_PACKET        pPrevIndicatedPacket;                                           \
                                                                                        \
    /*                                                                                  \
     * We indicate this via the IndicatePacketHandler if all of the following           \
     * conditions are met:                                                              \
     * - The binding is not p-mode or all-local                                         \
     * - The binding specifies a ReceivePacketHandler                                   \
     * - The miniport indicates that it is willing to let go of the packet              \
     * - No binding has already claimed the packet                                      \
     */                                                                                 \
                                                                                        \
    pPrevIndicatedPacket = INDICATED_PACKET(_Miniport);                                 \
    INDICATED_PACKET(_Miniport) = (_Packet);                                            \
                                                                                        \
    /*                                                                                  \
     * Indicate the packet to the binding.                                              \
     */                                                                                 \
    if (*(_fFallBack) ||                                                                \
        ((_pOpenBlock)->ReceivePacketHandler == NULL) ||                                \
        ((_Pmode) && ((_Filter)->SingleActiveOpen == NULL)))                            \
    {                                                                                   \
        NDIS_STATUS _StatusOfReceive;                                                   \
        NDIS_STATUS _OldPacketStatus = NDIS_GET_PACKET_STATUS(_Packet);                 \
        NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_RESOURCES);                         \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                3, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
                                                                                        \
        /*                                                                              \
         * Revert back to old-style indication in this case                             \
         */                                                                             \
        /*                                                                              \
        NdisQueryBuffer((_Packet)->Private.Head, NULL, &LookaheadBufferSize);           \
        */                                                                              \
        LookaheadBufferSize = MDL_SIZE((_Packet)->Private.Head);                        \
        ProtocolFilterIndicateReceive(&_StatusOfReceive,                                \
                                      (_pOpenBlock),                                    \
                                      (_Packet),                                        \
                                      (_Hdr),                                           \
                                      (_HdrSize),                                       \
                                      (_Hdr) + (_HdrSize),                              \
                                      LookaheadBufferSize - (_HdrSize),                 \
                                      (_PktSize) - (_HdrSize),                          \
                                      Medium);                                          \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                4, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        NDIS_SET_PACKET_STATUS(_Packet, _OldPacketStatus);                              \
    }                                                                                   \
    else                                                                                \
    {                                                                                   \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                5, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        (_NSR)->XRefCount += (SHORT)(*(_pOpenBlock)->ReceivePacketHandler)(             \
                            (_pOpenBlock)->ProtocolBindingContext,                      \
                            (_Packet));                                                 \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                6, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        ASSERT((_NSR)->XRefCount >= 0);                                                 \
    }                                                                                   \
                                                                                        \
    /*                                                                                  \
     * Manipulate refcount on the packet with miniport lock held                        \
     * Set the reference count on the packet to what the protocol                       \
     * asked for. See NdisReturnPackets for how this is handled                         \
     * when the packets are returned.                                                   \
     */                                                                                 \
    if ((_NSR)->XRefCount > 0)                                                          \
    {                                                                                   \
        /*                                                                              \
         * Now that a binding has claimed it, make sure others do not get a chance      \
         * except if this protocol promises to behave and not use the protocol rsvd     \
         */                                                                             \
                                                                                        \
        if (!MINIPORT_TEST_FLAG(_pOpenBlock, fMINIPORT_OPEN_NO_PROT_RSVD))              \
        {                                                                               \
            *(_fFallBack) = TRUE;                                                       \
        }                                                                               \
    }                                                                                   \
    INDICATED_PACKET(_Miniport) = pPrevIndicatedPacket;                                 \
}

#else

#define IndicateToProtocol(_Miniport,                                                   \
                           _Filter,                                                     \
                           _pOpenBlock,                                                 \
                           _Packet,                                                     \
                           _NSR,                                                        \
                           _Hdr,                                                        \
                           _PktSize,                                                    \
                           _HdrSize,                                                    \
                           _fFallBack,                                                  \
                           _Pmode,                                                      \
                           _Medium)                                                     \
{                                                                                       \
    UINT                LookaheadBufferSize;                                            \
    PNDIS_PACKET        pPrevIndicatedPacket;                                           \
                                                                                        \
    /*                                                                                  \
     * We indicate this via the IndicatePacketHandler if all of the following           \
     * conditions are met:                                                              \
     * - The binding is not p-mode or all-local                                         \
     * - The binding specifies a ReceivePacketHandler                                   \
     * - The miniport indicates that it is willing to let go of the packet              \
     * - No binding has already claimed the packet                                      \
     */                                                                                 \
                                                                                        \
    pPrevIndicatedPacket = INDICATED_PACKET(_Miniport);                                 \
    INDICATED_PACKET(_Miniport) = (_Packet);                                            \
                                                                                        \
    /*                                                                                  \
     * Indicate the packet to the binding.                                              \
     */                                                                                 \
    if (*(_fFallBack) ||                                                                \
        ((_pOpenBlock)->ReceivePacketHandler == NULL) ||                                \
        ((_Pmode) && ((_Filter)->SingleActiveOpen == NULL)))                            \
    {                                                                                   \
        NDIS_STATUS _StatusOfReceive;                                                   \
        NDIS_STATUS _OldPacketStatus = NDIS_GET_PACKET_STATUS(_Packet);                 \
        NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_RESOURCES);                         \
                                                                                        \
        /*                                                                              \
         * Revert back to old-style indication in this case                             \
         */                                                                             \
        /*                                                                              \
        NdisQueryBuffer((_Packet)->Private.Head, NULL, &LookaheadBufferSize);           \
        */                                                                              \
        LookaheadBufferSize = MDL_SIZE((_Packet)->Private.Head);                        \
        ProtocolFilterIndicateReceive(&_StatusOfReceive,                                \
                                      (_pOpenBlock),                                    \
                                      (_Packet),                                        \
                                      (_Hdr),                                           \
                                      (_HdrSize),                                       \
                                      (_Hdr) + (_HdrSize),                              \
                                      LookaheadBufferSize - (_HdrSize),                 \
                                      (_PktSize) - (_HdrSize),                          \
                                      Medium);                                          \
        NDIS_SET_PACKET_STATUS(_Packet, _OldPacketStatus);                              \
    }                                                                                   \
    else                                                                                \
    {                                                                                   \
        (_NSR)->XRefCount += (SHORT)(*(_pOpenBlock)->ReceivePacketHandler)(             \
                            (_pOpenBlock)->ProtocolBindingContext,                      \
                            (_Packet));                                                 \
        ASSERT((_NSR)->XRefCount >= 0);                                                 \
    }                                                                                   \
                                                                                        \
    /*                                                                                  \
     * Manipulate refcount on the packet with miniport lock held                        \
     * Set the reference count on the packet to what the protocol                       \
     * asked for. See NdisReturnPackets for how this is handled                         \
     * when the packets are returned.                                                   \
     */                                                                                 \
    if ((_NSR)->XRefCount > 0)                                                          \
    {                                                                                   \
        /*                                                                              \
         * Now that a binding has claimed it, make sure others do not get a chance      \
         * except if this protocol promises to behave and not use the protocol rsvd     \
         */                                                                             \
                                                                                        \
        if (!MINIPORT_TEST_FLAG(_pOpenBlock, fMINIPORT_OPEN_NO_PROT_RSVD))              \
        {                                                                               \
            *(_fFallBack) = TRUE;                                                       \
        }                                                                               \
    }                                                                                   \
    INDICATED_PACKET(_Miniport) = pPrevIndicatedPacket;                                 \
}

#endif

#define ProtocolFilterIndicateReceive(_pStatus,                                         \
                                      _OpenB,                                           \
                                      _MacReceiveContext,                               \
                                      _HeaderBuffer,                                    \
                                      _HeaderBufferSize,                                \
                                      _LookaheadBuffer,                                 \
                                      _LookaheadBufferSize,                             \
                                      _PacketSize,                                      \
                                      _Medium)                                          \
    {                                                                                   \
        FilterIndicateReceive(_pStatus,                                                 \
                              (_OpenB),                                                 \
                              _MacReceiveContext,                                       \
                              _HeaderBuffer,                                            \
                              _HeaderBufferSize,                                        \
                              _LookaheadBuffer,                                         \
                              _LookaheadBufferSize,                                     \
                              _PacketSize);                                             \
    }

//
// Loopback macros
//
#define EthShouldAddressLoopBackMacro(_Filter,                                          \
                                      _Address,                                         \
                                      _pfLoopback,                                      \
                                      _pfSelfDirected)                                  \
{                                                                                       \
    UINT CombinedFilters;                                                               \
                                                                                        \
    CombinedFilters = ETH_QUERY_FILTER_CLASSES(_Filter);                                \
                                                                                        \
    *(_pfLoopback) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
                                                                                        \
        /*                                                                              \
         * Check if it *at least* has the multicast address bit.                        \
         */                                                                             \
                                                                                        \
        if (ETH_IS_MULTICAST(_Address))                                                 \
        {                                                                               \
            /*                                                                          \
             * It is at least a multicast address.  Check to see if                     \
             * it is a broadcast address.                                               \
             */                                                                         \
                                                                                        \
            if (ETH_IS_BROADCAST(_Address))                                             \
            {                                                                           \
                if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)                       \
                {                                                                       \
                    *(_pfLoopback) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                if ((CombinedFilters & NDIS_PACKET_TYPE_ALL_MULTICAST) ||               \
                    ((CombinedFilters & NDIS_PACKET_TYPE_MULTICAST) &&                  \
                     ethFindMulticast((_Filter)->NumAddresses,                          \
                                      (_Filter)->MCastAddressBuf,                       \
                                      _Address)))                                       \
                {                                                                       \
                    *(_pfLoopback) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            /*                                                                          \
             * Directed to ourself??                                                    \
             */                                                                         \
                                                                                        \
            if ((*(ULONG UNALIGNED *)&(_Address)[2] ==                                  \
                    *(ULONG UNALIGNED *)&(_Filter)->AdapterAddress[2]) &&               \
                 (*(USHORT UNALIGNED *)&(_Address)[0] ==                                \
                    *(USHORT UNALIGNED *)&(_Filter)->AdapterAddress[0]))                \
            {                                                                           \
                *(_pfLoopback) = TRUE;                                                  \
                *(_pfSelfDirected) = TRUE;                                              \
                break;                                                                  \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    /*                                                                                  \
     * Check if the filter is promiscuous.                                              \
     */                                                                                 \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopback) = TRUE;                                                          \
    }                                                                                   \
}

#define FddiShouldAddressLoopBackMacro( _Filter,                                        \
                                        _Address,                                       \
                                        _AddressLength,                                 \
                                        _pfLoopBack,                                    \
                                        _pfSelfDirected)                                \
{                                                                                       \
    INT ResultOfAddressCheck;                                                           \
                                                                                        \
    UINT CombinedFilters;                                                               \
                                                                                        \
    CombinedFilters = FDDI_QUERY_FILTER_CLASSES(_Filter);                               \
                                                                                        \
    *(_pfLoopBack) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
        /*                                                                              \
         * Check if it *at least* has the multicast address bit.                        \
         */                                                                             \
                                                                                        \
        FDDI_IS_MULTICAST(_Address,                                                     \
                          (_AddressLength),                                             \
                          &ResultOfAddressCheck);                                       \
                                                                                        \
        if (ResultOfAddressCheck)                                                       \
        {                                                                               \
            /*                                                                          \
             * It is at least a multicast address.  Check to see if                     \
             * it is a broadcast address.                                               \
             */                                                                         \
                                                                                        \
            FDDI_IS_BROADCAST(_Address,                                                 \
                              (_AddressLength),                                         \
                              &ResultOfAddressCheck);                                   \
                                                                                        \
            if (ResultOfAddressCheck)                                                   \
            {                                                                           \
                if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)                       \
                {                                                                       \
                    *(_pfLoopBack) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                if ((CombinedFilters & NDIS_PACKET_TYPE_ALL_MULTICAST) ||               \
                    ((CombinedFilters & NDIS_PACKET_TYPE_MULTICAST) &&                  \
                     ((((_AddressLength) == FDDI_LENGTH_OF_LONG_ADDRESS) &&             \
                        fddiFindMulticastLongAddress((_Filter)->NumLongAddresses,       \
                                                    (_Filter)->MCastLongAddressBuf,     \
                                                    _Address)) ||                       \
                      (((_AddressLength) == FDDI_LENGTH_OF_SHORT_ADDRESS) &&            \
                        fddiFindMulticastShortAddress((_Filter)->NumShortAddresses,     \
                                                      (_Filter)->MCastShortAddressBuf,  \
                                                      _Address)))))                     \
                {                                                                       \
                    *(_pfLoopBack) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            /*                                                                          \
             * Directed to ourself?                                                     \
             */                                                                         \
            if ((_AddressLength) == FDDI_LENGTH_OF_LONG_ADDRESS)                        \
            {                                                                           \
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((_Filter)->AdapterLongAddress,        \
                                                _Address,                               \
                                                FDDI_LENGTH_OF_LONG_ADDRESS,            \
                                                &ResultOfAddressCheck                   \
                                                );                                      \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((_Filter)->AdapterShortAddress,       \
                                                _Address,                               \
                                                FDDI_LENGTH_OF_SHORT_ADDRESS,           \
                                                &ResultOfAddressCheck                   \
                                                );                                      \
            }                                                                           \
                                                                                        \
            if (ResultOfAddressCheck == 0)                                              \
            {                                                                           \
                *(_pfLoopBack) = TRUE;                                                  \
                *(_pfSelfDirected) = TRUE;                                              \
                break;                                                                  \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    /*                                                                                  \
     * First check if the filter is promiscuous.                                        \
     */                                                                                 \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopBack) = TRUE;                                                          \
    }                                                                                   \
}

#define TrShouldAddressLoopBackMacro(_Filter,                                           \
                                     _DAddress,                                         \
                                     _SAddress,                                         \
                                     _pfLoopback,                                       \
                                     _pfSelfDirected)                                   \
{                                                                                       \
    /* Holds the result of address determinations. */                                   \
    BOOLEAN ResultOfAddressCheck;                                                       \
                                                                                        \
    BOOLEAN IsSourceRouting;                                                            \
                                                                                        \
    UINT CombinedFilters;                                                               \
                                                                                        \
    ULONG GroupAddress;                                                                 \
                                                                                        \
    *(_pfLoopback) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
        CombinedFilters = TR_QUERY_FILTER_CLASSES(_Filter);                             \
                                                                                        \
        /* Convert the 32 bits of the address to a longword. */                         \
        RetrieveUlong(&GroupAddress, ((_DAddress) + 2));                                \
                                                                                        \
        /* Check if the destination is a preexisting group address */                   \
        TR_IS_GROUP((_DAddress), &ResultOfAddressCheck);                                \
                                                                                        \
        if (ResultOfAddressCheck &&                                                     \
            (GroupAddress == (_Filter)->GroupAddress) &&                                \
            ((_Filter)->GroupReferences != 0))                                          \
        {                                                                               \
            *(_pfLoopback) = TRUE;                                                      \
            break;                                                                      \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            TR_IS_SOURCE_ROUTING((_SAddress), &IsSourceRouting);                        \
                                                                                        \
            if (IsSourceRouting && (CombinedFilters & NDIS_PACKET_TYPE_SOURCE_ROUTING)) \
            {                                                                           \
                *(_pfLoopback) = TRUE;                                                  \
                break;                                                                  \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                /* First check if it *at least* has the functional address bit. */      \
                TR_IS_NOT_DIRECTED((_DAddress), &ResultOfAddressCheck);                 \
                                                                                        \
                if (ResultOfAddressCheck)                                               \
                {                                                                       \
                    /* It is at least a functional address.  Check to see if */         \
                    /* it is a broadcast address. */                                    \
                                                                                        \
                    TR_IS_BROADCAST((_DAddress), &ResultOfAddressCheck);                \
                                                                                        \
                    if (ResultOfAddressCheck)                                           \
                    {                                                                   \
                        if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)               \
                        {                                                               \
                            *(_pfLoopback) = TRUE;                                      \
                            break;                                                      \
                        }                                                               \
                    }                                                                   \
                    else                                                                \
                    {                                                                   \
                        TR_IS_FUNCTIONAL((_DAddress), &ResultOfAddressCheck);           \
                        if (ResultOfAddressCheck)                                       \
                        {                                                               \
                            if (CombinedFilters &                                       \
                                (NDIS_PACKET_TYPE_ALL_FUNCTIONAL |                      \
                                 NDIS_PACKET_TYPE_FUNCTIONAL))                          \
                            {                                                           \
                                ULONG   FunctionalAddress;                              \
                                                                                        \
                                RetrieveUlong(&FunctionalAddress, ((_DAddress) + 2));   \
                                if ((FunctionalAddress &                                \
                                    (_Filter)->CombinedFunctionalAddress))              \
                                {                                                       \
                                    *(_pfLoopback) = TRUE;                              \
                                    break;                                              \
                                }                                                       \
                            }                                                           \
                        }                                                               \
                    }                                                                   \
                }                                                                       \
                else                                                                    \
                {                                                                       \
                    /* See if it is self-directed. */                                   \
                                                                                        \
                    if ((*(ULONG UNALIGNED  *)(_DAddress + 2) ==                        \
                         *(ULONG UNALIGNED  *)(&(_Filter)->AdapterAddress[2])) &&       \
                        (*(USHORT UNALIGNED *)(_DAddress) ==                            \
                         *(USHORT UNALIGNED *)(&(_Filter)->AdapterAddress[0])))         \
                    {                                                                   \
                        *(_pfLoopback) = TRUE;                                          \
                        *(_pfSelfDirected) = TRUE;                                      \
                        break;                                                          \
                    }                                                                   \
                }                                                                       \
                                                                                        \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopback) = TRUE;                                                          \
    }                                                                                   \
}

typedef struct _X_BINDING_INFO  X_BINDING_INFO, *PX_BINDING_INFO;

typedef struct _X_BINDING_INFO
{
    //
    //  The following pointers are used to travers the specific
    //  and total filter lists. They need to be at the first
    //  elements in the structure
    //
    PX_BINDING_INFO             NextOpen;
    PNDIS_OPEN_BLOCK            NdisBindingHandle;
    PVOID                       Reserved;
    UINT                        PacketFilters;
    UINT                        OldPacketFilters;
    ULONG                       References;
    PX_BINDING_INFO             NextInactiveOpen;
    BOOLEAN                     ReceivedAPacket;
    union
    {
        //
        //  Ethernet
        //
        struct
        {
            UCHAR               (*MCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                NumAddresses;

            UCHAR               (*OldMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                OldNumAddresses;
        };
        //
        //  Fddi
        //
        struct
        {
            UCHAR               (*MCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UINT                NumLongAddresses;
            UCHAR               (*MCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                NumShortAddresses;
        
            //
            // Save area while the change is made
            //
            UCHAR               (*OldMCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UINT                OldNumLongAddresses;
            UCHAR               (*OldMCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                OldNumShortAddresses;
        };
        //
        //  Token-Ring
        //
        struct
        {
            TR_FUNCTIONAL_ADDRESS   FunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   OldFunctionalAddress;
            BOOLEAN                 UsingGroupAddress;
            BOOLEAN                 OldUsingGroupAddress;
        };
    };
} X_BINDING_INFO, *PX_BINDING_INFO;

typedef struct _X_FILTER
{
    //
    // The list of bindings are seperated for directed and broadcast/multicast
    // Promiscuous bindings are on both lists
    //
    PX_BINDING_INFO             OpenList;
    NDIS_RW_LOCK                BindListLock;
    PNDIS_MINIPORT_BLOCK        Miniport;
    UINT                        CombinedPacketFilter;
    UINT                        OldCombinedPacketFilter;
    UINT                        NumOpens;
    PX_BINDING_INFO             MCastSet;
    PX_BINDING_INFO             SingleActiveOpen;
    UCHAR                       AdapterAddress[ETH_LENGTH_OF_ADDRESS];
    union
    {
        //
        // Ethernet
        //
        struct
        {
            UCHAR               (*MCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UCHAR               (*OldMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                MaxMulticastAddresses;
            UINT                NumAddresses;
            UINT                OldNumAddresses;
        };
        //
        // Fddi
        //
        struct
        {
#define AdapterLongAddress      AdapterAddress
            UCHAR               AdapterShortAddress[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UCHAR               (*MCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UCHAR               (*MCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UCHAR               (*OldMCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UCHAR               (*OldMCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                MaxMulticastLongAddresses;
            UINT                MaxMulticastShortAddresses;
            UINT                NumLongAddresses;
            UINT                NumShortAddresses;
            UINT                OldNumLongAddresses;
            UINT                OldNumShortAddresses;
            BOOLEAN             SupportsShortAddresses;
        };
        struct
        {
            TR_FUNCTIONAL_ADDRESS   CombinedFunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   GroupAddress;
            UINT                    GroupReferences;
            TR_FUNCTIONAL_ADDRESS   OldCombinedFunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   OldGroupAddress;
            UINT                    OldGroupReferences;
        };
    };
} X_FILTER, *PX_FILTER;


//
//UINT
//ETH_QUERY_FILTER_CLASSES(
//  IN  PETH_FILTER             Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//ETH_QUERY_PACKET_FILTER(
//  IN  PETH_FILTER             Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PETH_BINDING_INFO)(NdisFilterHandle))->PacketFilters)


//
//UINT
//ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(
//  IN  PETH_FILTER             Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(Filter) ((Filter)->NumAddresses)

typedef X_BINDING_INFO  ETH_BINDING_INFO, *PETH_BINDING_INFO;

typedef X_FILTER        ETH_FILTER, *PETH_FILTER;

//
//UINT
//FDDI_QUERY_FILTER_CLASSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//FDDI_QUERY_PACKET_FILTER(
//  IN  PFDDI_FILTER            Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PFDDI_BINDING_INFO)(NdisFilterHandle))->PacketFilters)


//
//UINT
//FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(Filter) ((Filter)->NumLongAddresses)


//
//UINT
//FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(Filter) ((Filter)->NumShortAddresses)

#define FDDI_FILTER_SUPPORTS_SHORT_ADDR(Filter)     (Filter)->SupportsShortAddresses

//
// The binding info is threaded on two lists.  When
// the binding is free it is on a single freelist.
//
// When the binding is being used it is on an index list
// and possibly on seperate broadcast and directed lists.
//
typedef X_BINDING_INFO  FDDI_BINDING_INFO,*PFDDI_BINDING_INFO;

typedef X_FILTER        FDDI_FILTER, *PFDDI_FILTER;

//
//UINT
//TR_QUERY_FILTER_CLASSES(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//TR_QUERY_PACKET_FILTER(
//  IN PTR_FILTER Filter,
//  IN NDIS_HANDLE NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PTR_BINDING_INFO)NdisFilterHandle)->PacketFilters)


//
//UINT
//TR_QUERY_FILTER_ADDRESSES(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled functional address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_ADDRESSES(Filter) ((Filter)->CombinedFunctionalAddress)


//
//UINT
//TR_QUERY_FILTER_GROUP(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled Group address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_Group(Filter) ((Filter)->GroupAddress)
#define TR_QUERY_FILTER_GROUP(Filter) ((Filter)->GroupAddress)

//
//UINT
//TR_QUERY_FILTER_BINDING_ADDRESS(
//  IN PTR_FILTER Filter
//  IN NDIS_HANDLE NdisFilterHandle,
//  )
//
// This macro returns the currently desired functional addresses
// for the specified binding.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_BINDING_ADDRESS(Filter, NdisFilterHandle) \
                    (((PTR_BINDING_INFO)NdisFilterHandle)->FunctionalAddress)

//
//BOOLEAN
//TR_QUERY_FILTER_BINDING_GROUP(
//  IN PTR_FILTER Filter
//  IN NDIS_HANDLE NdisFilterHandle,
//  )
//
// This macro returns TRUE if the specified binding is using the
// current group address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_BINDING_GROUP(Filter, NdisFilterHandle) \
                    (((PTR_BINDING_INFO)NdisFilterHandle)->UsingGroupAddress)


typedef X_BINDING_INFO  TR_BINDING_INFO,*PTR_BINDING_INFO;

typedef X_FILTER        TR_FILTER, *PTR_FILTER;

#endif // _FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\init.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    init.c

Abstract:

    NDIS wrapper functions initializing drivers.

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organized

--*/

#include <precomp.h>
#include <atm.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_INIT

//
// Configuration Requests
//

VOID
NdisOpenConfiguration(
    OUT PNDIS_STATUS                Status,
    OUT PNDIS_HANDLE                ConfigurationHandle,
    IN  NDIS_HANDLE                 WrapperConfigurationContext
    )
/*++

Routine Description:

    This routine is used to open the parameter subkey of the
    adapter registry tree.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Returns a handle which is used in calls to
                            NdisReadConfiguration and NdisCloseConfiguration.

    WrapperConfigurationContext - a handle pointing to an RTL_QUERY_REGISTRY_TABLE
                            that is set up for this driver's parameters.

Return Value:

    None.

--*/
{
    //
    // Handle to be returned
    //
    PNDIS_CONFIGURATION_HANDLE HandleToReturn;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfiguration: WrapperConfigurationContext %p\n", WrapperConfigurationContext));
        
    //
    // Allocate the configuration handle
    //
    HandleToReturn = ALLOC_FROM_POOL(sizeof(NDIS_CONFIGURATION_HANDLE), NDIS_TAG_CONFIG_HANLDE);

    *Status = (HandleToReturn != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;
    
    if (*Status == NDIS_STATUS_SUCCESS)
    {
        HandleToReturn->KeyQueryTable = ((PNDIS_WRAPPER_CONFIGURATION_HANDLE)WrapperConfigurationContext)->ParametersQueryTable;
        HandleToReturn->ParameterList = NULL;
        *ConfigurationHandle = (NDIS_HANDLE)HandleToReturn;
    }
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfiguration: WrapperConfigurationContext %p\n", WrapperConfigurationContext));
}


VOID
NdisOpenConfigurationKeyByName(
    OUT PNDIS_STATUS                Status,
    IN  NDIS_HANDLE                 ConfigurationHandle,
    IN  PNDIS_STRING                KeyName,
    OUT PNDIS_HANDLE                KeyHandle
    )
/*++

Routine Description:

    This routine is used to open a subkey relative to the configuration handle.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle to an already open section of the registry

    KeyName - Name of the subkey to open

    KeyHandle - Placeholder for the handle to the sub-key.

Return Value:

    None.

--*/
{
    //
    // Handle to be returned
    //
    PNDIS_CONFIGURATION_HANDLE          SKHandle, ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PNDIS_WRAPPER_CONFIGURATION_HANDLE  WConfigHandle;
    UNICODE_STRING                      Parent, Child, Sep;
#define PQueryTable                     WConfigHandle->ParametersQueryTable

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfigurationKeyByName: ConfigurationHandle\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    do
    {

        if (*ConfigHandle->KeyQueryTable[3].Name)
        {
            RtlInitUnicodeString(&Parent, ConfigHandle->KeyQueryTable[3].Name);
            RtlInitUnicodeString(&Sep, L"\\");
            Child.MaximumLength = KeyName->Length + Parent.Length + Sep.Length + sizeof(WCHAR);
        }
        else
        {
            Child.MaximumLength = KeyName->Length + sizeof(WCHAR);
        }
        
        Child.Length = 0;

        //
        // Allocate the configuration handle
        //

        SKHandle = ALLOC_FROM_POOL(sizeof(NDIS_CONFIGURATION_HANDLE) +
                                    sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE) +
                                    Child.MaximumLength,
                                    NDIS_TAG_CONFIG_HANLDE);

        *Status = (SKHandle != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            *KeyHandle = (NDIS_HANDLE)NULL;
            break;
        }
        
        WConfigHandle = (PNDIS_WRAPPER_CONFIGURATION_HANDLE)((PUCHAR)SKHandle + sizeof(NDIS_CONFIGURATION_HANDLE));
        Child.Buffer = (PWSTR)((PUCHAR)WConfigHandle + sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        //
        // if there is no parent path, avoid starting the child path with "\\"
        //
        if (*ConfigHandle->KeyQueryTable[3].Name)
        {
            RtlCopyUnicodeString(&Child, &Parent);
            RtlAppendUnicodeStringToString(&Child, &Sep);
        }
        
        RtlAppendUnicodeStringToString(&Child, KeyName);

        SKHandle->KeyQueryTable = WConfigHandle->ParametersQueryTable;


        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // 1.
        // Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;

        //
        // PQueryTable[0].Name and PQueryTable[0].EntryContext
        // are filled in inside ReadConfiguration, in preparation
        // for the callback.
        //
        // PQueryTable[0].Name = KeywordBuffer;
        // PQueryTable[0].EntryContext = ParameterValue;

        //
        // 2.
        // Stop
        //
        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;

        //
        // NOTE: Some fields in ParametersQueryTable[3] are used to store information for later retrieval.
        //
        PQueryTable[3].QueryRoutine = ConfigHandle->KeyQueryTable[3].QueryRoutine;
        PQueryTable[3].Name = Child.Buffer;
        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;
        
        SKHandle->ParameterList = NULL;
        *KeyHandle = (NDIS_HANDLE)SKHandle;
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfigurationKeyByName: ConfigurationHandle\n", ConfigurationHandle));

#undef  PQueryTable
}


VOID
NdisOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS                Status,
    IN  NDIS_HANDLE                 ConfigurationHandle,
    IN  ULONG                       Index,
    OUT PNDIS_STRING                KeyName,
    OUT PNDIS_HANDLE                KeyHandle
    )
/*++

Routine Description:

    This routine is used to open a subkey relative to the configuration handle.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle to an already open section of the registry

    Index - Index of the sub-key to open

    KeyName - Placeholder for the name of subkey being opened

    KeyHandle - Placeholder for the handle to the sub-key.

Return Value:

    None.

--*/
{
    PNDIS_CONFIGURATION_HANDLE          ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    HANDLE                              Handle = NULL, RootHandle = NULL;
    OBJECT_ATTRIBUTES                   ObjAttr;
    UNICODE_STRING                      KeyPath = {0}, Services = {0}, AbsolutePath={0};
    PKEY_BASIC_INFORMATION              InfoBuf = NULL;
    ULONG                               Len;
    PDEVICE_OBJECT                      PhysicalDeviceObject;
    PNDIS_MINIPORT_BLOCK                Miniport;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfigurationKeyByIndex: ConfigurationHandle\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    *KeyHandle = NULL;

    do
    {
        if (ConfigHandle->KeyQueryTable[3].Name != NULL)
        {
            RtlInitUnicodeString(&KeyPath, ConfigHandle->KeyQueryTable[3].Name);
        }
        
        if ((Miniport = (PNDIS_MINIPORT_BLOCK)ConfigHandle->KeyQueryTable[3].QueryRoutine) == NULL)
        {
            //
            // protocols
            //
            
            //
            // Open the current key and lookup the Nth subkey. But first conver the service relative
            // path to absolute since this is what ZwOpenKey expects.
            //
            RtlInitUnicodeString(&Services, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
        }
        else
        {
            //
            // Adapters
            //
            // for adapters, first we have to open the key for PDO
            //
            
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

#if NDIS_TEST_REG_FAILURE
            *Status = STATUS_UNSUCCESSFUL;
#else

            *Status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                              PLUGPLAY_REGKEY_DRIVER,
                                              GENERIC_READ | MAXIMUM_ALLOWED,
                                              &RootHandle);
                                              
#endif

            if (!NT_SUCCESS(*Status))
            {
                break;
            }
        }

        if (KeyPath.Length || Services.Length)
        {
            AbsolutePath.MaximumLength = KeyPath.Length + Services.Length + sizeof(WCHAR);
            AbsolutePath.Buffer = (PWSTR)ALLOC_FROM_POOL(AbsolutePath.MaximumLength, NDIS_TAG_DEFAULT);
            if (AbsolutePath.Buffer == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisMoveMemory(AbsolutePath.Buffer, Services.Buffer, Services.Length);
            AbsolutePath.Length = Services.Length;
            RtlAppendUnicodeStringToString(&AbsolutePath, &KeyPath);
        }
        
        InitializeObjectAttributes(&ObjAttr,
                                   &AbsolutePath,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   RootHandle,
                                   NULL);
                                
        *Status = ZwOpenKey(&Handle,
                            GENERIC_READ | MAXIMUM_ALLOWED,
                            &ObjAttr);
                            
        if (!NT_SUCCESS(*Status))
        {
            Handle = NULL;
            break;
        }
        
        //
        // Allocate memory for the call to ZwEnumerateKey
        //
        Len = sizeof(KEY_BASIC_INFORMATION) + 256;
        InfoBuf = (PKEY_BASIC_INFORMATION)ALLOC_FROM_POOL(Len, NDIS_TAG_DEFAULT);
        if (InfoBuf == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Get the Index(th) key, if it exists
        //
        *Status = ZwEnumerateKey(Handle,
                                 Index,
                                 KeyValueBasicInformation,
                                 InfoBuf,
                                 Len,
                                 &Len);
                                
        if (NT_SUCCESS(*Status))
        {
            //
            // This worked. Now simply pick up the name and do a NdisOpenConfigurationKeyByName on it.
            //
            KeyPath.Length = KeyPath.MaximumLength = (USHORT)InfoBuf->NameLength;
            KeyPath.Buffer = InfoBuf->Name;
            NdisOpenConfigurationKeyByName(Status,
                                           ConfigurationHandle,
                                           &KeyPath,
                                           KeyHandle);
                                        
            if (*Status == NDIS_STATUS_SUCCESS)
            {
                PNDIS_CONFIGURATION_HANDLE      NewHandle = *(PNDIS_CONFIGURATION_HANDLE *)KeyHandle;

                //
                // The path in the new handle has the name of the key. Extract it and return to caller
                //
                RtlInitUnicodeString(KeyName, NewHandle->KeyQueryTable[3].Name);
                KeyName->Buffer = (PWSTR)((PUCHAR)KeyName->Buffer + KeyName->Length - KeyPath.Length);
                KeyName->Length = KeyPath.Length;
                KeyName->MaximumLength = KeyPath.MaximumLength;
            }
        }

    } while (FALSE);

    if (AbsolutePath.Buffer != NULL)
    {
        FREE_POOL(AbsolutePath.Buffer);
    }

    if (InfoBuf != NULL)
    {
        FREE_POOL(InfoBuf);
    }

    if (RootHandle)
        ZwClose (RootHandle);

    if (Handle)
        ZwClose (Handle);


    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfigurationKeyByIndex: ConfigurationHandle\n", ConfigurationHandle));
}


VOID
NdisReadConfiguration(
    OUT PNDIS_STATUS                    Status,
    OUT PNDIS_CONFIGURATION_PARAMETER * ParameterValue,
    IN NDIS_HANDLE                      ConfigurationHandle,
    IN PNDIS_STRING                     Keyword,
    IN NDIS_PARAMETER_TYPE              ParameterType
    )
/*++

Routine Description:

    This routine is used to read the parameter for a configuration
    keyword from the configuration database.

Arguments:

    Status - Returns the status of the request.

    ParameterValue - Returns the value for this keyword.

    ConfigurationHandle - Handle returned by NdisOpenConfiguration. Points
    to the parameter subkey.

    Keyword - The keyword to search for.

    ParameterType - Ignored on NT, specifies the type of the value.

Return Value:

    None.

--*/
{
    NTSTATUS                    RegistryStatus;
    PWSTR                       KeywordBuffer = NULL;
    UINT                        i;
    PNDIS_CONFIGURATION_HANDLE  ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PDEVICE_OBJECT              PhysicalDeviceObject;
    HANDLE                      Handle = NULL;
    PNDIS_MINIPORT_BLOCK        Miniport = NULL;
    PCM_PARTIAL_RESOURCE_LIST   pResourceList;
    UINT                        j;
    ULONG                       ValueData;
    
#define PQueryTable             ConfigHandle->KeyQueryTable

    //
    // There are some built-in parameters which can always be
    // read, even if not present in the registry. This is the
    // number of them.
    //
#define BUILT_IN_COUNT 3

    static NDIS_STRING BuiltInStrings[BUILT_IN_COUNT] =
    {
        NDIS_STRING_CONST ("Environment"),
        NDIS_STRING_CONST ("ProcessorType"),
        NDIS_STRING_CONST ("NdisVersion")
    };

    static NDIS_STRING MiniportNameStr = NDIS_STRING_CONST ("MiniportName");

#define STANDARD_RESOURCE_COUNT 9
    //
    // The names of the standard resource types.
    //
    static NDIS_STRING StandardResourceStrings[STANDARD_RESOURCE_COUNT] =
    {
        NDIS_STRING_CONST ("IoBaseAddress"),
        NDIS_STRING_CONST ("InterruptNumber"),
        NDIS_STRING_CONST ("MemoryMappedBaseAddress"),
        NDIS_STRING_CONST ("DmaChannel"),
        //
        // a few drivers use non-standard keywords, so take care of them for now
        //
        NDIS_STRING_CONST ("IoAddress"),
        NDIS_STRING_CONST ("Interrupt"),
        NDIS_STRING_CONST ("IOBase"),
        NDIS_STRING_CONST ("Irq"),
        NDIS_STRING_CONST ("RamAddress")
    };

    UCHAR StandardResourceTypes[STANDARD_RESOURCE_COUNT]=
    {
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypeMemory,
                        CmResourceTypeDma,
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypeMemory
    };
    
    static NDIS_CONFIGURATION_PARAMETER BuiltInParameters[BUILT_IN_COUNT] =
        { { NdisParameterInteger, NdisEnvironmentWindowsNt },
          { NdisParameterInteger,
#if defined(_M_IX86)
            NdisProcessorX86
#elif defined(_M_MRX000)
            NdisProcessorMips
#elif defined(_ALPHA_)
            NdisProcessorAlpha
#else
            NdisProcessorPpc
#endif
          },
          { NdisParameterInteger, ((NDIS_MAJOR_VERSION << 16) | NDIS_MINOR_VERSION)}
        };
        
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisReadConfiguration\n"));
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("    Keyword: "));
    DBGPRINT_UNICODE(DBG_COMP_REG, DBG_LEVEL_INFO,
            Keyword);
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("\n"));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    
    do
    {
        KeywordBuffer = Keyword->Buffer;

        //
        // assume failure
        //
        RegistryStatus = STATUS_UNSUCCESSFUL;
        
        //
        // First check if this is one of the built-in parameters.
        //
        for (i = 0; i < BUILT_IN_COUNT; i++)
        {
            if (RtlEqualUnicodeString(Keyword, &BuiltInStrings[i], TRUE))
            {
                RegistryStatus = STATUS_SUCCESS;
                *ParameterValue = &BuiltInParameters[i];
                break;
            }
        }
        
        if (NT_SUCCESS(RegistryStatus))
            break;

        if ((Miniport = (PNDIS_MINIPORT_BLOCK)PQueryTable[3].QueryRoutine) != NULL)
        {
            //
            // check to see if driver is asking for miniport name
            //
            if (RtlEqualUnicodeString(Keyword, &MiniportNameStr, TRUE))
            {
                
                RegistryStatus = ndisSaveParameters(MiniportNameStr.Buffer,
                                                    REG_SZ,
                                                    (PVOID)Miniport->MiniportName.Buffer,
                                                    Miniport->MiniportName.Length,
                                                    (PVOID)ConfigHandle,
                                                    (PVOID)ParameterValue);

                break;  
            }
                
            //
            // check to see if this is a resource keyword
            //
            for (i = 0; i < STANDARD_RESOURCE_COUNT; i++)
            {
                if (RtlEqualUnicodeString(Keyword, &StandardResourceStrings[i], TRUE))
                    break;
            }
            
            if (i < STANDARD_RESOURCE_COUNT)
            {

                NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_2,
                    ("NdisReadConfiguration: Miniport %p should use NdisMQueryAdapterResources to get the standard resources.\n", Miniport));
            
                do
                {
                    if (Miniport->AllocatedResources == NULL)
                            break;
                            
                    pResourceList = &(Miniport->AllocatedResources->List[0].PartialResourceList);
                                        
                    //
                    // walk through resource list and find the first one that matches
                    //
                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        if (pResourceList->PartialDescriptors[j].Type == StandardResourceTypes[i])
                        {
                            //
                            // could have used  pResourceList->PartialDescriptors[j].Generic.Start.LowPart for all
                            // cases, but in the future, memory value can be 64 bit
                            //
                        
                            switch (StandardResourceTypes[i])
                            {
                            
                                case CmResourceTypePort:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Port.Start.LowPart;
                                    break;
                                    
                                case CmResourceTypeInterrupt:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Interrupt.Level;
                                    break;
                                
                                case CmResourceTypeMemory:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart;
                                    break;
                                    
                                case CmResourceTypeDma:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Dma.Channel;
                                    break;
                                    
                                default:
                                    ASSERT(FALSE);
                            }
                            
                            //
                            // call SaveParameter ourselves
                            //
                            RegistryStatus = ndisSaveParameters(StandardResourceStrings[i].Buffer,
                                                                REG_DWORD,
                                                                (PVOID)&ValueData,
                                                                sizeof(ULONG),
                                                                (PVOID)ConfigHandle,
                                                                (PVOID)ParameterValue);
                            
                            break;
                        }
                    }
                    
                    if (j >= pResourceList->Count)
                    {
                        RegistryStatus = STATUS_UNSUCCESSFUL;
                    }
                    
                } while (FALSE);
                
                //
                // if keyword was a standard resource keyword, we should break here
                // no matter what the outcome of finding the resource in resource list
                //
                break;
            } // end of if it was a resource keyword
            
        } // end of if NdisReadConfiguration called for a miniport

        //
        // the keyword was not a standard resource or built-in keyword
        // get back to our regular programming...
        //

        //
        // Allocate room for a null-terminated version of the keyword
        //
        KeywordBuffer = (PWSTR)ALLOC_FROM_POOL(Keyword->Length + sizeof(WCHAR), NDIS_TAG_DEFAULT);
        if (KeywordBuffer == NULL)
        {
            RegistryStatus = STATUS_UNSUCCESSFUL;;
            break;
        }
        CopyMemory(KeywordBuffer, Keyword->Buffer, Keyword->Length);

        *(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) = (WCHAR)L'\0';
                
        PQueryTable[1].Name = KeywordBuffer;
        PQueryTable[1].EntryContext = ParameterValue;
        
        if (Miniport != NULL)
        {
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

            //
            // set the subkey
            //
            PQueryTable[0].Name = PQueryTable[3].Name;
                
#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_READ | MAXIMUM_ALLOWED,
                                                     &Handle);
                    
#endif

            if(NT_SUCCESS(RegistryStatus))
            {
                RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                        Handle,
                                                        PQueryTable,
                                                        ConfigHandle,                   // context
                                                        NULL);
            }
        }
        else
        {
            //
            // protocols
            //
            RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                                    PQueryTable[3].Name,
                                                    PQueryTable,
                                                    ConfigHandle,                   // context
                                                    NULL);
        }

        if (NT_SUCCESS(RegistryStatus))
        {
            //
            // if a value is stored in registry as string but the driver is trying
            // to read it as Integer or HexInteger, do the conversion here
            //
            
            if ((*ParameterValue)->ParameterType == NdisParameterString)
            {
                if (ParameterType == NdisParameterInteger)
                {
                    RtlUnicodeStringToInteger(&(*ParameterValue)->ParameterData.StringData,
                                    10, (PULONG)(&(*ParameterValue)->ParameterData.IntegerData));
                    (*ParameterValue)->ParameterType = NdisParameterInteger;
                }
                else if (ParameterType == NdisParameterHexInteger)
                {
                    RtlUnicodeStringToInteger(&(*ParameterValue)->ParameterData.StringData,
                                    16, (PULONG)(&(*ParameterValue)->ParameterData.IntegerData));
                    (*ParameterValue)->ParameterType = NdisParameterHexInteger;
                }
            }
        }

    } while (FALSE);

    if (KeywordBuffer  && (KeywordBuffer != Keyword->Buffer))
    {
        FREE_POOL(KeywordBuffer);   // no longer needed
    }

    if (!NT_SUCCESS(RegistryStatus))
    {
        *Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;
    }

    if (Handle)
        ZwClose(Handle);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisReadConfiguration\n"));
    
#undef  PQueryTable
}


VOID
NdisWriteConfiguration(
    OUT PNDIS_STATUS                Status,
    IN NDIS_HANDLE                  ConfigurationHandle,
    IN PNDIS_STRING                 Keyword,
    PNDIS_CONFIGURATION_PARAMETER   ParameterValue
    )
/*++

Routine Description:

    This routine is used to write a parameter to the configuration database.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle passed to the driver

    Keyword - The keyword to set.

    ParameterValue - Specifies the new value for this keyword.

Return Value:

    None.

--*/
{
    PNDIS_CONFIGURATION_HANDLE NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    NTSTATUS            RegistryStatus;
    PNDIS_MINIPORT_BLOCK Miniport;
    PWSTR               KeywordBuffer;
    BOOLEAN             FreeKwBuf = FALSE;
    PVOID               ValueData = NULL;
    ULONG               ValueLength = 0;
    ULONG               ValueType = REG_DWORD;
    PDEVICE_OBJECT      PhysicalDeviceObject;
    HANDLE              Handle, RootHandle;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      RelativePath;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisWriteConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    *Status = NDIS_STATUS_SUCCESS;
    KeywordBuffer = Keyword->Buffer;
    
    do
    {
        //
        // Get the value data.
        //
        switch (ParameterValue->ParameterType)
        {
          case NdisParameterHexInteger:
          case NdisParameterInteger:
            ValueData = &ParameterValue->ParameterData.IntegerData;
            ValueLength = sizeof(ParameterValue->ParameterData.IntegerData);
            ValueType = REG_DWORD;
            break;

          case NdisParameterString:
            ValueData = ParameterValue->ParameterData.StringData.Buffer;
            ValueLength = ParameterValue->ParameterData.StringData.Length;
            ValueType = REG_SZ;
            break;

          case NdisParameterMultiString:
            ValueData = ParameterValue->ParameterData.StringData.Buffer;
            ValueLength = ParameterValue->ParameterData.StringData.Length;
            ValueType = REG_MULTI_SZ;
            break;

          case NdisParameterBinary:
            ValueData = ParameterValue->ParameterData.BinaryData.Buffer;
            ValueLength = ParameterValue->ParameterData.BinaryData.Length;
            ValueType = REG_BINARY;
            break;

          default:
            *Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if (*Status != NDIS_STATUS_SUCCESS)
            break;

        if (Keyword->MaximumLength <= (Keyword->Length + sizeof(WCHAR)))
        {
            KeywordBuffer = (PWSTR)ALLOC_FROM_POOL(Keyword->Length + sizeof(WCHAR), NDIS_TAG_DEFAULT);
            if (KeywordBuffer == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }
            CopyMemory(KeywordBuffer, Keyword->Buffer, Keyword->Length);
            FreeKwBuf = TRUE;
        }

        *(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) = (WCHAR)L'\0';
        
        if ((Miniport = (PNDIS_MINIPORT_BLOCK)NdisConfigHandle->KeyQueryTable[3].QueryRoutine) != NULL)
        {
            //
            // Adapters
            //
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
            RootHandle = NULL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_WRITE | MAXIMUM_ALLOWED,
                                                     &RootHandle);
                                    
#endif
            if (!NT_SUCCESS(RegistryStatus))
            {
                *Status = NDIS_STATUS_FAILURE;
                break;
            }

            RtlInitUnicodeString(&RelativePath, NdisConfigHandle->KeyQueryTable[3].Name);
            
            InitializeObjectAttributes(&ObjAttr,
                                       &RelativePath,
                                       OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                       RootHandle,
                                       NULL);
                                    
            RegistryStatus = ZwOpenKey(&Handle,
                                       GENERIC_READ | MAXIMUM_ALLOWED,
                                       &ObjAttr);
                            
            if (NT_SUCCESS(RegistryStatus))
            {
                RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                                       Handle,
                                                       KeywordBuffer,
                                                       ValueType,
                                                       ValueData,
                                                       ValueLength);

                ZwClose (Handle);
            }
                
            ZwClose (RootHandle);
        }
        else
        {
            //
            // protocols
            //
            RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES,
                                                   NdisConfigHandle->KeyQueryTable[3].Name,
                                                   KeywordBuffer,
                                                   ValueType,
                                                   ValueData,
                                                   ValueLength);
        }
        
        if (!NT_SUCCESS(RegistryStatus))
        {
            *Status = NDIS_STATUS_FAILURE;
        }

    } while (FALSE);

    if (FreeKwBuf)
    {
        FREE_POOL(KeywordBuffer);   // no longer needed
    }
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisWriteConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisCloseConfiguration(
    IN NDIS_HANDLE                  ConfigurationHandle
    )
/*++

Routine Description:

    This routine is used to close a configuration database opened by
    NdisOpenConfiguration.

Arguments:

    ConfigurationHandle - Handle returned by NdisOpenConfiguration.

Return Value:

    None.

--*/
{
    //
    // Obtain the actual configuration handle structure
    //
    PNDIS_CONFIGURATION_HANDLE  NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisCloseConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // deallocate the parameter nodes
    //
    ParameterNode = NdisConfigHandle->ParameterList;

    while (ParameterNode != NULL)
    {
        NdisConfigHandle->ParameterList = ParameterNode->Next;

        FREE_POOL(ParameterNode);

        ParameterNode = NdisConfigHandle->ParameterList;
    }

    FREE_POOL(ConfigurationHandle);
                
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisCloseConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisReadNetworkAddress(
    OUT PNDIS_STATUS                Status,
    OUT PVOID *                     NetworkAddress,
    OUT PUINT                       NetworkAddressLength,
    IN NDIS_HANDLE                  ConfigurationHandle
    )
/*++

Routine Description:

    This routine is used to read the "NetworkAddress" parameter
    from the configuration database. It reads the value as a
    string separated by hyphens, then converts it to a binary
    array and stores the result.

Arguments:

    Status - Returns the status of the request.

    NetworkAddress - Returns a pointer to the address.

    NetworkAddressLength - Returns the length of the address.

    ConfigurationHandle - Handle returned by NdisOpenConfiguration. Points
    to the parameter subkey.

Return Value:

    None.

--*/
{
    NDIS_STRING                     NetAddrStr = NDIS_STRING_CONST("NetworkAddress");
    PNDIS_CONFIGURATION_PARAMETER   ParameterValue;
    NTSTATUS                        NtStatus = STATUS_UNSUCCESSFUL;
    UCHAR                           ConvertArray[3];
    PWSTR                           CurrentReadLoc;
    PWSTR                           AddressEnd;
    PUCHAR                          CurrentWriteLoc;
    UINT                            TotalBytesRead;
    ULONG                           TempUlong;
    ULONG                           AddressLength;
    PNDIS_MINIPORT_BLOCK            Miniport;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisReadNetworkAddress: ConfigurationHandle %p\n", ConfigurationHandle));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle)->KeyQueryTable[3].QueryRoutine;

    ASSERT(Miniport != NULL);
    ASSERT(Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE);

    if (Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        Miniport->MacOptions |= NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE;
        Miniport->InfoFlags |= NDIS_MINIPORT_SUPPORTS_MAC_ADDRESS_OVERWRITE;
    }
        
    do
    {
        //
        // First read the "NetworkAddress" from the registry
        //
        NdisReadConfiguration(Status, &ParameterValue, ConfigurationHandle, &NetAddrStr, NdisParameterString);

        if ((*Status != NDIS_STATUS_SUCCESS) ||
            (ParameterValue->ParameterType != NdisParameterString))
        {
            *Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  If there is not an address specified then exit now.
        //
        if (0 == ParameterValue->ParameterData.StringData.Length)
        {
            *Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Now convert the address to binary (we do this
        // in-place, since this allows us to use the memory
        // already allocated which is automatically freed
        // by NdisCloseConfiguration).
        //

        ConvertArray[2] = '\0';
        CurrentReadLoc = (PWSTR)ParameterValue->ParameterData.StringData.Buffer;
        CurrentWriteLoc = (PUCHAR)CurrentReadLoc;
        TotalBytesRead = ParameterValue->ParameterData.StringData.Length;
        AddressEnd = CurrentReadLoc + (TotalBytesRead / sizeof(WCHAR));
        AddressLength = 0;

        //1 is address string a multiple of 2 and if not, what are the implications?
        while ((CurrentReadLoc+2) <= AddressEnd)
        {
            //
            // Copy the current two-character value into ConvertArray
            //
            ConvertArray[0] = (UCHAR)(*(CurrentReadLoc++));
            ConvertArray[1] = (UCHAR)(*(CurrentReadLoc++));

            //
            // Convert it to a Ulong and update
            //
            NtStatus = RtlCharToInteger((PCSZ)ConvertArray, 16, &TempUlong);

            if (!NT_SUCCESS(NtStatus))
            {
                *Status = NDIS_STATUS_FAILURE;
                break;
            }

            *(CurrentWriteLoc++) = (UCHAR)TempUlong;
            ++AddressLength;

            //
            // If the next character is a hyphen, skip it.
            //
            if (CurrentReadLoc < AddressEnd)
            {
                if (*CurrentReadLoc == (WCHAR)L'-')
                {
                    ++CurrentReadLoc;
                }
            }
        }

        if (!NT_SUCCESS(NtStatus))
            break;

        *Status = NDIS_STATUS_SUCCESS;
        *NetworkAddress = ParameterValue->ParameterData.StringData.Buffer;
        *NetworkAddressLength = AddressLength;
        if (AddressLength == 0)
        {
            *Status = NDIS_STATUS_FAILURE;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisReadNetworkAddress: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisConvertStringToAtmAddress(
    OUT PNDIS_STATUS            Status,
    IN  PNDIS_STRING            String,
    OUT PATM_ADDRESS            AtmAddress
    )
/*++

Routine Description:


Arguments:

    Status - Returns the status of the request.

    String - String representation of the atm address.

    *   Format defined in Section 5.4,
    *       "Example Master File Format" in ATM95-1532R4 ATM Name System:
    *
    *   AESA format: a string of hexadecimal digits, with '.' characters for punctuation, e.g.
    *
    *       39.246f.00.0e7c9c.0312.0001.0001.000012345678.00
    *
    *   E164 format: A '+' character followed by a string of
    *       decimal digits, with '.' chars for punctuation, e.g.:
    *
    *           +358.400.1234567

    AtmAddress - The converted Atm address is returned here.

Return Value:

    None.

--*/
{
    USHORT          i, j, NumDigits;
    PWSTR           p, q;
    UNICODE_STRING  Us;
    ANSI_STRING     As;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisConvertStringToAtmAddress\n"));

    //
    // Start off by stripping the punctuation characters from the string. We do this in place.
    //
    for (i = NumDigits = 0, j = String->Length/sizeof(WCHAR), p = q = String->Buffer;
         (i < j) && (*p != 0);
         i++, p++)
    {
        if ((*p == ATM_ADDR_BLANK_CHAR) ||
            (*p == ATM_ADDR_PUNCTUATION_CHAR))
        {
            continue;
        }
        *q++ = *p;
        NumDigits ++;
    }

    //
    // Look at the first character to determine if the address is E.164 or NSAP.
    // If the address isn't long enough, we assume that it is native E.164.
    //
    p = String->Buffer;
    if ((*p == ATM_ADDR_E164_START_CHAR) || (NumDigits <= 15))
    {
        if (*p == ATM_ADDR_E164_START_CHAR)
        {
            p ++;
            NumDigits --;
        }
        if ((NumDigits == 0) || (NumDigits > ATM_ADDRESS_LENGTH))
        {
            *Status = NDIS_STATUS_INVALID_LENGTH;
            return;
        }
        AtmAddress->AddressType = ATM_E164;
        AtmAddress->NumberOfDigits = NumDigits;
    }
    else
    {
        if (NumDigits != 2*ATM_ADDRESS_LENGTH)
        {
            *Status = NDIS_STATUS_INVALID_LENGTH;
            return;
        }
        AtmAddress->AddressType = ATM_NSAP;
        AtmAddress->NumberOfDigits = NumDigits/sizeof(WCHAR);
    }

    //
    // Convert the address to Ansi now
    //
    Us.Buffer = p;
    Us.Length = Us.MaximumLength = NumDigits*sizeof(WCHAR);
    As.Buffer = ALLOC_FROM_POOL(NumDigits + 1, NDIS_TAG_CO);
    As.Length = 0;
    As.MaximumLength = NumDigits + 1;
    if (As.Buffer == NULL)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    *Status = NdisUnicodeStringToAnsiString(&As, &Us);
    if (!NT_SUCCESS(*Status))
    {
        FREE_POOL(As.Buffer);
        *Status = NDIS_STATUS_FAILURE;
        return;
    }

    //
    //  Now get the bytes into the destination ATM Address structure.
    //
    if (AtmAddress->AddressType == ATM_E164)
    {
        //
        //  We just need to copy in the digits in ANSI form.
        //
        NdisMoveMemory(AtmAddress->Address, As.Buffer, NumDigits);
    }
    else
    {
        //
        //  This is in NSAP form. We need to pack the hex digits.
        //
        UCHAR           xxString[3];
        ULONG           val;

        xxString[2] = 0;
        for (i = 0; i < ATM_ADDRESS_LENGTH; i++)
        {
            xxString[0] = As.Buffer[i*2];
            xxString[1] = As.Buffer[i*2+1];
            *Status = CHAR_TO_INT((PCSZ)xxString, 16, &val);
            if (!NT_SUCCESS(*Status))
            {
                FREE_POOL(As.Buffer);
                *Status = NDIS_STATUS_FAILURE;
                return;
            }
            AtmAddress->Address[i] = (UCHAR)val;
        }
    }

    FREE_POOL(As.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisConvertStringToAtmAddress\n"));

    *Status = NDIS_STATUS_SUCCESS;
}


NTSTATUS
ndisSaveParameters(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called with the value for a specified parameter. It allocates
    memory to hold the data and copies it over.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value.

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Points to the head of the parameter chain.

    EntryContext - A pointer to

Return Value:

    STATUS_SUCCESS

--*/
{
    NDIS_STATUS Status;

    //
    // Obtain the actual configuration handle structure
    //
    PNDIS_CONFIGURATION_HANDLE NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)Context;

    //
    // Where the user wants a pointer returned to the data.
    //
    PNDIS_CONFIGURATION_PARAMETER *ParameterValue = (PNDIS_CONFIGURATION_PARAMETER *)EntryContext;

    //
    // Use this to link parameters allocated to this open
    //
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;

    //
    // Size of memory to allocate for parameter node
    //
    UINT    Size;

    UNREFERENCED_PARAMETER(ValueName);
    
    //
    // Allocate our parameter node
    //
    Size = sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE);
    if ((ValueType == REG_SZ) || (ValueType == REG_MULTI_SZ) || (ValueType == REG_BINARY))
    {
        Size += ValueLength;
    }
    
    ParameterNode = ALLOC_FROM_POOL(Size, NDIS_TAG_PARAMETER_NODE);

    Status = (ParameterNode != NULL) ? NDIS_STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return (NTSTATUS)Status;
    }

    *ParameterValue = &ParameterNode->Parameter;

    //
    // Map registry datatypes to ndis data types
    //
    if (ValueType == REG_DWORD)
    {
        //
        // The registry says that the data is in a dword boundary.
        //
        (*ParameterValue)->ParameterType = NdisParameterInteger;
        (*ParameterValue)->ParameterData.IntegerData = *((PULONG) ValueData);
    }
    else if ((ValueType == REG_SZ) || (ValueType == REG_MULTI_SZ))
    {
        (*ParameterValue)->ParameterType =
            (ValueType == REG_SZ) ? NdisParameterString : NdisParameterMultiString;

        (*ParameterValue)->ParameterData.StringData.Buffer = (PWSTR)((PUCHAR)ParameterNode + sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE));

        CopyMemory((*ParameterValue)->ParameterData.StringData.Buffer,
                   ValueData,
                   ValueLength);
        (*ParameterValue)->ParameterData.StringData.Length = (USHORT)ValueLength;
        (*ParameterValue)->ParameterData.StringData.MaximumLength = (USHORT)ValueLength;

        //
        // Special fix; if a string ends in a NULL and that is included
        // in the length, remove it.
        //
        if (ValueType == REG_SZ)
        {
            if ((((PUCHAR)ValueData)[ValueLength-1] == 0) &&
                (((PUCHAR)ValueData)[ValueLength-2] == 0))
            {
                (*ParameterValue)->ParameterData.StringData.Length -= 2;
            }
        }
    }
    else if (ValueType == REG_BINARY)
    {
        (*ParameterValue)->ParameterType = NdisParameterBinary;
        (*ParameterValue)->ParameterData.BinaryData.Buffer = ValueData;
        (*ParameterValue)->ParameterData.BinaryData.Length = (USHORT)ValueLength;
        (*ParameterValue)->ParameterData.BinaryData.Buffer = (PWSTR)((PUCHAR)ParameterNode + sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE));
        CopyMemory((*ParameterValue)->ParameterData.BinaryData.Buffer,
                   ValueData,
                   ValueLength);
    }
    else
    {
        FREE_POOL(ParameterNode);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Queue this parameter node
    //
    ParameterNode->Next = NdisConfigHandle->ParameterList;
    NdisConfigHandle->ParameterList = ParameterNode;

    return STATUS_SUCCESS;
}


NTSTATUS
ndisReadParameter(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called with the values for the "Bind" and "Export" multi-strings
    for a given driver. It allocates memory to hold the data and copies
    it over.

Arguments:

    ValueName - The name of the value ("Bind" or "Export" -- ignored).

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Unused.

    EntryContext - A pointer to the pointer that holds the copied data.

Return Value:

    STATUS_SUCCESS

--*/
{
    //1 everwhere this function is called, check for the type and if applicable the range
    //1 make sure anybody using this API, frees the allocated memory,
    PUCHAR * Data = ((PUCHAR *)EntryContext);

    UNREFERENCED_PARAMETER(ValueName);

    //
    // Allocate one DWORD more and zero is out
    //
    *Data = ALLOC_FROM_POOL(ValueLength + sizeof(ULONG), NDIS_TAG_REG_READ_DATA_BUFFER);

    if (*Data == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory(*Data, ValueLength + sizeof(ULONG));
    CopyMemory(*Data, ValueData, ValueLength);

    if (Context)
    {
        *((PULONG)Context) = ValueType;
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\macros.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

#ifndef _MACROS_H
#define _MACROS_H

//1 put some protection in this macro to guard against the cases that we can not 
//1 map the entire mdl because we don't have enough map registers.
#define NdisMStartBufferPhysicalMappingMacro(                                   \
                _MiniportAdapterHandle,                                         \
                _Buffer,                                                        \
                _PhysicalMapRegister,                                           \
                _Write,                                                         \
                _PhysicalAddressArray,                                          \
                _ArraySize)                                                     \
{                                                                               \
    PNDIS_MINIPORT_BLOCK _Miniport = (PNDIS_MINIPORT_BLOCK)(_MiniportAdapterHandle);\
    PMAP_TRANSFER mapTransfer = *_Miniport->SystemAdapterObject->DmaOperations->MapTransfer;\
    PHYSICAL_ADDRESS _LogicalAddress;                                           \
    PUCHAR _VirtualAddress;                                                     \
    ULONG _LengthRemaining;                                                     \
    ULONG _LengthMapped;                                                        \
    UINT _CurrentArrayLocation;                                                 \
                                                                                \
    _VirtualAddress = (PUCHAR)MmGetMdlVirtualAddress(_Buffer);                  \
    _LengthRemaining = MmGetMdlByteCount(_Buffer);                              \
    _CurrentArrayLocation = 0;                                                  \
                                                                                \
    while (_LengthRemaining > 0)                                                \
    {                                                                           \
        _LengthMapped = _LengthRemaining;                                       \
        _LogicalAddress =                                                       \
            mapTransfer(_Miniport->SystemAdapterObject,                         \
                        (_Buffer),                                              \
                        _Miniport->MapRegisters[_PhysicalMapRegister].MapRegister,\
                        _VirtualAddress,                                        \
                        &_LengthMapped,                                         \
                        (_Write));                                              \
        (_PhysicalAddressArray)[_CurrentArrayLocation].PhysicalAddress = _LogicalAddress;\
        (_PhysicalAddressArray)[_CurrentArrayLocation].Length = _LengthMapped;  \
        _LengthRemaining -= _LengthMapped;                                      \
        _VirtualAddress += _LengthMapped;                                       \
        ++_CurrentArrayLocation;                                                \
    }                                                                           \
    _Miniport->MapRegisters[_PhysicalMapRegister].WriteToDevice = (_Write);     \
    *(_ArraySize) = _CurrentArrayLocation;                                      \
}

#define NdisMCompleteBufferPhysicalMappingMacro(_MiniportAdapterHandle,         \
                                                _Buffer,                        \
                                                _PhysicalMapRegister)           \
{                                                                               \
    PNDIS_MINIPORT_BLOCK _Miniport = (PNDIS_MINIPORT_BLOCK)(_MiniportAdapterHandle);\
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *_Miniport->SystemAdapterObject->DmaOperations->FlushAdapterBuffers;\
                                                                                \
    flushAdapterBuffers(_Miniport->SystemAdapterObject,                         \
                        _Buffer,                                                \
                        (_Miniport)->MapRegisters[_PhysicalMapRegister].MapRegister,\
                        MmGetMdlVirtualAddress(_Buffer),                        \
                        MmGetMdlByteCount(_Buffer),                             \
                        (_Miniport)->MapRegisters[_PhysicalMapRegister].WriteToDevice);\
}

#endif  //_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\mac.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    mac.c

Abstract:

    NDIS wrapper functions for full mac drivers

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organized

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MAC

IO_ALLOCATION_ACTION
ndisDmaExecutionRoutine(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PVOID                   MapRegisterBase,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine is an execution routine for AllocateAdapterChannel,
    if is called when an adapter channel allocated by
    NdisAllocateDmaChannel is available.

Arguments:

    DeviceObject - The device object of the adapter.

    Irp - ??.

    MapRegisterBase - The address of the first translation table
        assigned to us.

    Context - A pointer to the NDIS_DMA_BLOCK in question.

Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)Context;

    UNREFERENCED_PARAMETER (Irp);
    UNREFERENCED_PARAMETER (DeviceObject);


    //
    // Save the map register base.
    //

    DmaBlock->MapRegisterBase = MapRegisterBase;

    //
    // This will free the thread that is waiting for this callback.
    //

    SET_EVENT(&DmaBlock->AllocationEvent);

    return KeepObject;
}

IO_ALLOCATION_ACTION
ndisAllocationExecutionRoutine(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PVOID                   MapRegisterBase,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine is the execution routine for AllocateAdapterChannel,
    if is called when the map registers have been assigned.

Arguments:

    DeviceObject - The device object of the adapter.

    Irp - ??.

    MapRegisterBase - The address of the first translation table
        assigned to us.

    Context - A pointer to the Adapter in question.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // Save this translation entry in the correct spot.
    //

    Miniport->MapRegisters[Miniport->CurrentMapRegister].MapRegister = MapRegisterBase;

    //
    // This will free the thread that is waiting for this callback.
    //

    SET_EVENT(Miniport->AllocationEvent);

    return DeallocateObjectKeepRegisters;
}


VOID __cdecl
NdisWriteErrorLogEntry(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  NDIS_ERROR_CODE         ErrorCode,
    IN  ULONG                   NumberOfErrorValues,
    ...
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    NdisAdapterHandle - points to the adapter block.

    ErrorCode - Ndis code mapped to a string.

    NumberOfErrorValues - number of ULONGS to store for the error.

Return Value:

    None.


--*/
{
    va_list ArgumentPointer;

    PIO_ERROR_LOG_PACKET    errorLogEntry;
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    UINT                    i, StringSize;
    PWCH                    baseFileName;
    ULONG                   ulErrorLogSize = 0;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisWriteErrorLogEntry\n"));
            
    if (Miniport == NULL)
    {
        return;
    }

    baseFileName = Miniport->pAdapterInstanceName->Buffer;
    StringSize = Miniport->pAdapterInstanceName->MaximumLength;

    ulErrorLogSize = sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG) + StringSize;

    //
    // If the size is too large , use the MiniportName instead (\Device\{GUID} )
    //
    if (ulErrorLogSize > ERROR_LOG_MAXIMUM_SIZE )
    {
        baseFileName = Miniport->MiniportName.Buffer;
        StringSize = Miniport->MiniportName.MaximumLength;
        
        ulErrorLogSize = sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG) + StringSize;

    }

    if (ulErrorLogSize > ERROR_LOG_MAXIMUM_SIZE )
    {
        return;
    }
    
    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(Miniport->DeviceObject, (UCHAR)ulErrorLogSize);

    if (errorLogEntry != NULL)
    {
        errorLogEntry->ErrorCode = ErrorCode;

        //
        // store the time
        //

        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = 0;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->IoControlCode = 0;

        //
        // Store Data
        //

        errorLogEntry->DumpDataSize = (USHORT)(NumberOfErrorValues * sizeof(ULONG));

        va_start(ArgumentPointer, NumberOfErrorValues);

        for (i = 0; i < NumberOfErrorValues; i++)
        {
            errorLogEntry->DumpData[i] = va_arg(ArgumentPointer, ULONG);
        }

        va_end(ArgumentPointer);


        //
        // Set string information
        //

        if (StringSize != 0)
        {
            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG));


            CopyMemory(((PUCHAR)errorLogEntry) + (sizeof(IO_ERROR_LOG_PACKET) +
                       NumberOfErrorValues * sizeof(ULONG)),
                       baseFileName,
                       StringSize);

        }
        else
        {
            errorLogEntry->NumberOfStrings = 0;
        }

        //
        // write it out
        //

        IoWriteErrorLogEntry(errorLogEntry);
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisWriteErrorLogEntry\n"));
}


VOID
NdisSend(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->SendHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        Packet);
}

VOID
NdisSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->SendPacketsHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        PacketArray,
                        NumberOfPackets);
}

VOID
NdisTransferData(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->TransferDataHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        MacReceiveContext,
                        ByteOffset,
                        BytesToTransfer,
                        Packet,
                        BytesTransferred);
}

VOID
NdisReset(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    )
{
    *Status = NDIS_STATUS_NOT_RESETTABLE;
    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->ResetHandler != NULL)
    {
        *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->ResetHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle);
    }
}

VOID
NdisRequest(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->RequestHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        NdisRequest);
}

BOOLEAN
FASTCALL
ndisReferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisReferenceRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisReferenceRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }
    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
        
        if (RefP->ReferenceCount == 0)
        {
            --(RefP->ReferenceCount);
            rc = FALSE;        
        }
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceRef\n"));

    return(rc);
}


BOOLEAN
FASTCALL
ndisDereferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDereferenceRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDereferenceRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceRef\n"));
            
    return(rc);
}


VOID
FASTCALL
ndisInitializeRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisInitializeRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisInitializeRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisInitializeRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    INITIALIZE_SPIN_LOCK(&RefP->SpinLock);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisInitializeRef\n"));
}


BOOLEAN
FASTCALL
ndisCloseRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisCloseRef\n"));
            
    return(rc);
}


BOOLEAN
FASTCALL
ndisReferenceULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
        
        if (RefP->ReferenceCount == 0)
        {
            --(RefP->ReferenceCount);
            rc = FALSE;        
        }
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceULongRef\n"));

    return(rc);
}


VOID
FASTCALL
ndisReferenceULongRefNoCheck(
    IN  PULONG_REFERENCE                RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    None
--*/

{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceULongRefNoCheck\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    ++(RefP->ReferenceCount);

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceULongRefNoCheck\n"));

}



BOOLEAN
FASTCALL
ndisDereferenceULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceULongRef\n"));
            
    return(rc);
}


VOID
FASTCALL
ndisInitializeULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisInitializeULongRef\n"));
    
    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    INITIALIZE_SPIN_LOCK(&RefP->SpinLock);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisInitializeULongRef\n"));
}


BOOLEAN
FASTCALL
ndisCloseULongRef(
    IN  PULONG_REFERENCE                RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisCloseULongRef\n"));
            
    return(rc);
}


NTSTATUS
ndisCreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handle for IRP_MJ_CREATE IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/

{
    PIO_STACK_LOCATION          IrpSp;
    PNDIS_USER_OPEN_CONTEXT     OpenContext = NULL;
    NTSTATUS                    Status = STATUS_SUCCESS, SecurityStatus;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;
    BOOLEAN                     fRef = FALSE;
    BOOLEAN                     fWait;
    BOOLEAN                     fUserModeRef = FALSE;
    BOOLEAN                     AdminAccessAllowed = FALSE;
    BOOLEAN                     DerefAdminOpenCount = FALSE, DerefUserOpenCount = FALSE; 

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisCreateIrpHandler\n"));

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    if (IrpSp->FileObject == NULL)
    {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return(STATUS_UNSUCCESSFUL);
    }

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));
    }
    
    AdminAccessAllowed = ndisCheckAccess(Irp, 
                                         IrpSp, 
                                         &SecurityStatus, 
                                         Miniport->SecurityDescriptor);

    do
    {

        ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);

        if ((AdminAccessAllowed && (Miniport->NumAdminOpens >= NDIS_MAX_ADMIN_OPEN_HANDLES)) ||
            ((!AdminAccessAllowed) && (Miniport->NumUserOpens >= NDIS_MAX_USER_OPEN_HANDLES)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
            break;
        }
        
        if (AdminAccessAllowed)
        {
            Miniport->NumAdminOpens++;
            DerefAdminOpenCount = TRUE;;
        }
        else
        {
            Miniport->NumUserOpens++;
            DerefUserOpenCount = TRUE;
        }

        RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        

        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | 
                                             fMINIPORT_REJECT_REQUESTS))
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }


        fWait = NdisWaitEvent(&Miniport->OpenReadyEvent, NDIS_USER_OPEN_WAIT_TIME);
        if (fWait)
        {
            fRef = MINIPORT_INCREMENT_REF_CREATE(Miniport, Irp);
        }
            
        if (!fWait || !fRef)
        {
            if (!fWait && (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING) ||
                           !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED)))
            {
                Status = STATUS_DEVICE_POWERED_OFF;
            }
            else
            {
                Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            }
            break;
        }
    
        //
        // Lock down this code since we are about to take a spinlock.
        //
        PnPReferencePackage();

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        if (Miniport->PnPDeviceState == NdisPnPDeviceQueryStopped)
        {
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            PnPDereferencePackage();
            break;
        }
        Miniport->UserModeOpenReferences++;
        fUserModeRef = TRUE;

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        PnPDereferencePackage();
        
        OpenContext = (PNDIS_USER_OPEN_CONTEXT)ALLOC_FROM_POOL(sizeof(NDIS_USER_OPEN_CONTEXT),
                                                               NDIS_TAG_OPEN_CONTEXT);
        if (OpenContext == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            OpenContext->DeviceObject = DeviceObject;
            OpenContext->Miniport = Miniport;
            OpenContext->OidList = NULL;
            OpenContext->AdminAccessAllowed = AdminAccessAllowed;
    
            IrpSp->FileObject->FsContext = OpenContext;
    
            //
            // Checked if we already cached OidList, if so just set it here.
            //
            if (Miniport->OidList != NULL)
            {
                OpenContext->OidList = Miniport->OidList;
                Status = NDIS_STATUS_SUCCESS;
            }

            if (OpenContext->OidList == NULL)
            {
                Status = ndisQueryOidList(OpenContext);
            }
    
            if (Status != NDIS_STATUS_SUCCESS)
            {
                if (NT_SUCCESS(Status))
                {
                    //
                    // Some drivers return some bogus non-zero error
                    //
                    Status = STATUS_UNSUCCESSFUL;
                }

            }
        }
    } while (FALSE);

    if (NT_SUCCESS(Status) && MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
    {
        PBUS_INTERFACE_REFERENCE    BusInterface;

        BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

        ASSERT(BusInterface != NULL);

        if (BusInterface)
        {
            BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        if (DerefAdminOpenCount)
        {
            ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
            Miniport->NumAdminOpens--;            
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        }
        if (DerefUserOpenCount)
        {
            ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
            Miniport->NumUserOpens--;
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        }
        
        if (fUserModeRef)
        {
            PnPReferencePackage();
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            Miniport->UserModeOpenReferences--;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            PnPDereferencePackage();
        }
        
        if (fRef)
        {
            MINIPORT_DECREMENT_REF_CLOSE(Miniport, Irp);
        }

        if (OpenContext)
        {
            FREE_POOL(OpenContext);
        }
        
    }

    Irp->IoStatus.Status = Status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisCreateIrplHandler\n"));

    return Status;
}


NDIS_STATUS
FASTCALL
ndisQueryOidList(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext
    )

/*++

Routine Description:

    This routine will take care of querying the complete OID list for the MAC and filling in
    OpenContext->OidList->OidArray with the ones that are statistics. It blocks when the
    MAC pends and so is synchronous.

    NOTE: We also handle co-ndis miniports here.

Arguments:

    OpenContext - The open context.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    NDIS_REQUEST            Request;
    NDIS_STATUS             Status;
    PNDIS_OID               Buffer;
    ULONG                   BufferLength;

    Status = ndisQueryDeviceOid(OpenContext,
                                &Request,
                                OID_GEN_SUPPORTED_LIST,
                                NULL,
                                0);
    if ((Status != NDIS_STATUS_INVALID_LENGTH) && (Status != NDIS_STATUS_BUFFER_TOO_SHORT))
    {
        return Status;
    }

    //
    // Now we know how much is needed, allocate temp storage...
    //
    BufferLength = Request.DATA.QUERY_INFORMATION.BytesNeeded;
    Buffer = ALLOC_FROM_POOL(BufferLength, NDIS_TAG_DEFAULT);

    if (Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = ndisQueryDeviceOid(OpenContext,
                                &Request,
                                OID_GEN_SUPPORTED_LIST,
                                Buffer,
                                BufferLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Status = ndisSplitStatisticsOids(OpenContext,
                                         Buffer,
                                         BufferLength/sizeof(NDIS_OID));
    }
    
    FREE_POOL(Buffer);

    return Status;
}


NDIS_STATUS
FASTCALL
ndisSplitStatisticsOids(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_OID               OidList,
    IN  ULONG                   NumOids
    )
{
    ULONG   i, j;
    ULONG   StatsOids;

    //
    // Go through the buffer, counting the statistics OIDs.
    // Ignore all the custom oids which match the statistics
    // criteria
    //
    for (i = StatsOids = 0; i < NumOids; i++)
    {
        if (((OidList[i] & 0x00ff0000) == 0x00020000) &&
            ((OidList[i] & 0xff000000) != 0xff000000))
        {
            StatsOids++;
        }
    }

    //
    // Now allocate storage for the stat and non-stat OID arrays.
    //
    OpenContext->OidList = (POID_LIST)ALLOC_FROM_POOL(sizeof(OID_LIST) + ((StatsOids + NumOids)*sizeof(NDIS_OID)),
                                                      NDIS_TAG_OID_ARRAY);
    if (OpenContext->OidList == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    OpenContext->OidList->FullOidCount = NumOids;
    OpenContext->OidList->FullOidArray = (PNDIS_OID)(OpenContext->OidList + 1);
    OpenContext->OidList->StatsOidCount = StatsOids;
    OpenContext->OidList->StatsOidArray = OpenContext->OidList->FullOidArray + NumOids;

    //
    // Now go through the buffer, copying the statistics and non-stat OIDs separately.
    //
    for (i = j = 0; i < NumOids; i++)
    {
        if (((OidList[i] & 0x00ff0000) == 0x00020000) &&
            ((OidList[i] & 0xff000000) != 0xff000000))
        {
            OpenContext->OidList->StatsOidArray[j++] = OidList[i];
        }
        OpenContext->OidList->FullOidArray[i] = OidList[i];
    }

    ASSERT (j == OpenContext->OidList->StatsOidCount);

    //
    // Save it in the miniport
    //
    OpenContext->Miniport->OidList = OpenContext->OidList;

    return NDIS_STATUS_SUCCESS;
}


VOID
ndisCancelLogIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;

    UNREFERENCED_PARAMETER(DeviceObject);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    OpenContext = IrpSp->FileObject->FsContext;
    ASSERT(OpenContext != NULL);
    Miniport = OpenContext->Miniport;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT (Miniport->Log != NULL);
    ASSERT (Miniport->Log->Irp == Irp);

    Miniport->Log->Irp = NULL;
    Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
    Irp->IoStatus.Information = 0;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);
    IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
}


NTSTATUS
ndisDeviceControlIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

    The handle for IRP_MJ_DEVICE_CONTROL IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    NDIS_REQUEST            Request;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    UINT                    OidCount;
    PNDIS_OID               OidArray;
    PUCHAR                  OidBuffer = NULL;
    ULONG                   BytesWritten = 0;
    PUCHAR                  Buffer;
    ULONG                   BufferLength;
    NTSTATUS                Status = STATUS_SUCCESS;
    BOOLEAN                 fWaitComplete = FALSE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDeviceControlIrpHandler\n"));


    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    if (IrpSp->FileObject == NULL)
    {
        return(STATUS_UNSUCCESSFUL);
    }


    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));    
    }
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
    {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_UNSUCCESSFUL;
    }

    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    OpenContext = IrpSp->FileObject->FsContext;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_NDIS_GET_LOG_DATA:

        if (Irp->MdlAddress == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        NdisStatus = Status = ndisMGetLogData(Miniport, Irp);

        if (Status != STATUS_PENDING)
        {
            fWaitComplete = TRUE;
        }
        break;

      //1this actually lets all the OIDs (set and query) to go to 
      //1 miniport's QueryInformationHandler and not only
      //1 stats or query OIDs.
      case IOCTL_NDIS_QUERY_GLOBAL_STATS:

        //
        // check for a minimum length, alignment and valid OIDs
        //
        if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(NDIS_OID)) ||
            ((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer & (sizeof(NDIS_OID)-1))  ||
            !ndisValidOid(OpenContext,
                          *((PULONG)(Irp->AssociatedIrp.SystemBuffer))))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Buffer = (Irp->MdlAddress != NULL) ? MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority) : NULL;
        if ((Irp->MdlAddress != NULL) && (Buffer == NULL))
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // check for alignment on output buffer
        //
        if ((ULONG_PTR)Buffer & (MAX_NATURAL_ALIGNMENT -1))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        //1  we can potentially send a set OID down with requestType = RequestTypeQueryInformation
        NdisStatus = ndisQueryDeviceOid(OpenContext,
                                        &Request,
                                        *((PNDIS_OID)Irp->AssociatedIrp.SystemBuffer),
                                        Buffer,
                                        (Irp->MdlAddress != NULL) ? MDL_SIZE(Irp->MdlAddress) : 0);
        BytesWritten = Request.DATA.QUERY_INFORMATION.BytesWritten;
        Irp->IoStatus.Information = BytesWritten;
        fWaitComplete = TRUE;
        break;

      case IOCTL_NDIS_QUERY_ALL_STATS:

        OidCount = OpenContext->OidList->StatsOidCount;
        OidArray = OpenContext->OidList->StatsOidArray;
        goto common;
        break;

      case IOCTL_NDIS_QUERY_SELECTED_STATS:

        //
        // This is essentially a combination of QUERY_ALL_STATS and QUERY_GLOBAL_STATS.
        // Start off by verifying input parameters.
        //
        if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(NDIS_OID)) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength % sizeof(NDIS_OID)) != 0) ||
            ((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer & (sizeof(NDIS_OID)-1)))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        OidCount = IrpSp->Parameters.DeviceIoControl.InputBufferLength / sizeof(NDIS_OID);
        OidArray = (PNDIS_OID)(Irp->AssociatedIrp.SystemBuffer);

        OidBuffer = (PUCHAR)ALLOC_FROM_POOL(OidCount * sizeof(NDIS_OID), NDIS_TAG_ALLOC_MEM);
        if (OidBuffer == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }
        NdisMoveMemory(OidBuffer, (PUCHAR)OidArray,  OidCount * sizeof(NDIS_OID));

        OidArray = (PNDIS_OID)OidBuffer;
            
      common:
        BufferLength = (Irp->MdlAddress != NULL) ? MDL_SIZE(Irp->MdlAddress) : 0;
        Buffer = (BufferLength != 0) ? (PUCHAR)MDL_ADDRESS_SAFE (Irp->MdlAddress, LowPagePriority) : NULL;
        if (Buffer == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }
        
        if ((ULONG_PTR)Buffer & (MAX_NATURAL_ALIGNMENT-1))
        {
            
            DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                    ("ndisDeviceControlIrpHandler: Misaligned data.\n"));
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        NdisStatus = ndisQueryStatisticsOids(Miniport,
                                             OpenContext,
                                             OidArray,
                                             OidCount,
                                             Buffer,
                                             BufferLength,
                                             &BytesWritten,
                                             FALSE);

        Irp->IoStatus.Information = BytesWritten;
        fWaitComplete = TRUE;
        break;
        
      default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (fWaitComplete)
    {
        if (NdisStatus == NDIS_STATUS_INVALID_LENGTH)
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else if (NdisStatus == NDIS_STATUS_RESOURCES)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else if (NdisStatus == NDIS_STATUS_NOT_SUPPORTED)
        {
            Status = STATUS_SUCCESS;
        }
        else if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (Status != STATUS_PENDING)
    {
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDeviceControlIrpHandler\n"));

    if (OidBuffer)
    {
        FREE_POOL(OidBuffer);
    }
    
    return Status;
}


NDIS_STATUS
FASTCALL
ndisQueryDeviceOid(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_REQUEST           Request,
    IN  NDIS_OID                Oid,
    IN  PVOID                   Buffer,
    IN  UINT                    BufferLength
    )
/*++

Routine Description:


Arguments:


Return Value:

    Status of operation

--*/
{
    NDIS_STATUS             NdisStatus;
    PNDIS_MINIPORT_BLOCK    Miniport;

    do
    {
        Miniport = OpenContext->Miniport;
    
        Request->RequestType = NdisRequestQueryStatistics;
        Request->DATA.QUERY_INFORMATION.Oid = Oid;
        Request->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        Request->DATA.QUERY_INFORMATION.InformationBuffer = Buffer;
        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    
        NdisStatus = ndisQuerySetMiniport(Miniport,
                                          NULL,
                                          FALSE,
                                          Request,
                                          NULL);
    
    } while (FALSE);

    return NdisStatus;
}


BOOLEAN
FASTCALL
ndisValidOid(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  NDIS_OID                Oid
    )
/*++

Routine Description:


Arguments:


Return Value:

    TRUE if OID is valid, FALSE otherwise

--*/
{
    UINT    i;

    //
    // Always allow this range since it is vendor specific
    //
    //1 replace with (Oid & 0xFF000000) == 0xff000000
    //1 this seems unnecessary
    if ((Oid & 0xFF000000) != 0)
        return(TRUE);

    for (i = 0; i < OpenContext->OidList->FullOidCount; i++)
    {
        if (OpenContext->OidList->FullOidArray[i] == Oid)
        {
            break;
        }
    }

    return (i < OpenContext->OidList->FullOidCount);
}


NTSTATUS
ndisCloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handle for IRP_MJ_CLOSE IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/

{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    KIRQL                   OldIrql;

    //1 investigate moving this to CLEAN_UP IRP
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseIrpHandler\n"));
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Null Irp\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));
    }

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    

    OpenContext = IrpSp->FileObject->FsContext;
    IrpSp->FileObject->FsContext = NULL;

    ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
    if (OpenContext->AdminAccessAllowed)
    {
        Miniport->NumAdminOpens--;            
    }
    else
    {
        Miniport->NumUserOpens--;
    }
    RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
    
    FREE_POOL(OpenContext);

    PnPReferencePackage();

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    Miniport->UserModeOpenReferences--;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    MINIPORT_DECREMENT_REF_CLOSE(Miniport, Irp);

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
    {
        PBUS_INTERFACE_REFERENCE    BusInterface;

        BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

        ASSERT(BusInterface != NULL);

        if (BusInterface)
        {
            BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisCloseIrpHandler\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
ndisDummyIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    Default handler. If this is a NDIS device, then we simply succeed. If not and we have a
    custom handler, we pass it on. Else we succeed.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    Always STATUS_SUCCESS.

--*/

{
    PNDIS_DEVICE_LIST       DeviceList;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDummyIrpHandler\n"));


    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    DeviceList = (PNDIS_DEVICE_LIST)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    Miniport = (PNDIS_MINIPORT_BLOCK)DeviceList;

    do
    {
        //
        // This is a miniport
        //
        if (Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
        {
            if (IrpSp->MajorFunction == IRP_MJ_CLEANUP)
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_NOT_SUPPORTED;
            }
            break;
        }
        else if (DeviceList->Signature == (PVOID)CUSTOM_DEVICE_MAGIC_VALUE)
        {
            if (DeviceList->MajorFunctions[IrpSp->MajorFunction] == NULL)
            {
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            else
            {
                return((*DeviceList->MajorFunctions[IrpSp->MajorFunction])(DeviceObject, Irp));
            }
        }
        else
        {
            Status = STATUS_NOT_SUPPORTED;
        }
    } while (FALSE);

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDummyIrpHandler\n"));

    return Status;
}

NDIS_STATUS
ndisQueryStatisticsOids(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_OID               OidArray,
    IN  UINT                    OidCount,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   BufferLength,
    IN  PULONG                  pBytesWritten,
    IN  BOOLEAN                 AlignOutput
    )
{
    NDIS_STATUS     NdisStatus;
    ULONG           CurrentOid;
    NDIS_OID        Oid;
    NDIS_REQUEST    Request;
    ULONG           DataLength;
    ULONG           BufferLengthRemained = BufferLength;
    ULONG           BytesWrittenThisOid = 0;
//    ULONG           BytesWrittenAlignedThisOid = 0;
    ULONG           NdisStatisticsHeaderSize;
    ULONG           BytesWritten = 0;
    PNDIS_STATISTICS_VALUE StatisticsValue;
//    PNDIS_STATISTICS_VALUE_EX StatisticsValueEx;
    PUCHAR          DoubleBuffer = NULL;
    PVOID           SourceBuffer;
    ULONG           SourceLength;
    ULONG           GenericULong;
    TIME            CurrTicks;
    ULONG           InfoFlags = 0;    
    BOOLEAN         fPrv, fInt;
    

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisQueryStatisticsOids\n"));

    *pBytesWritten = 0;    
    NdisStatus = NDIS_STATUS_SUCCESS;

    if (AlignOutput)
    {
        //
        // activate for longhorn
        //
        ASSERT(FALSE);
        return NDIS_STATUS_FAILURE;
        
//        NdisStatisticsHeaderSize = NDIS_STATISTICS_EX_HEADER_SIZE;
//        ZeroMemory(Buffer, BufferLength);
    }
    else
    {
        DoubleBuffer = (PUCHAR)ALLOC_FROM_POOL(BufferLength, NDIS_TAG_ALLOC_MEM);

        if (DoubleBuffer == NULL)
        {
            return NDIS_STATUS_RESOURCES;            
        }
        
        NdisStatisticsHeaderSize = NDIS_STATISTICS_HEADER_SIZE;
    }
    
    for (CurrentOid = 0; CurrentOid < OidCount; CurrentOid++)
    {
        SourceLength = 0;
        SourceBuffer = NULL;

        NdisZeroMemory(&Request, sizeof(NDIS_REQUEST));
        
        //
        // We need room for an NDIS_STATISTICS_VALUE (OID, Length, Data).
        //
        //1 check to see if having room for a ULONG is not good enough.
        if (BufferLengthRemained < (ULONG)(NdisStatisticsHeaderSize + sizeof(ULONG)))
        {
            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        DataLength = BufferLengthRemained - NdisStatisticsHeaderSize;

        //
        // Check if the OID is part of supported list - if not do not 
        // error out but ignore
        //
        Oid = OidArray[CurrentOid];

        //1 choose another name for NDIS_OID_PRIVATE. This is here
        //1 to be backward compatible for those apps that send statistics
        //1 OIDs with 0x80000000 bit set.
        fPrv = ((Oid & NDIS_OID_MASK) == NDIS_OID_PRIVATE);

        if (fPrv)
        {
            Oid &= ~NDIS_OID_PRIVATE;
        }

        //1 find a better way to find out if an OID is internal or not.
        fInt =  (
                 (Oid == OID_GEN_DIRECTED_FRAMES_RCV) ||
                 (Oid == OID_GEN_DIRECTED_FRAMES_XMIT) ||
                 (Oid == OID_GEN_MEDIA_IN_USE) ||
                 (Oid == OID_GEN_PHYSICAL_MEDIUM) ||
                 (Oid == OID_GEN_INIT_TIME_MS) ||
                 (Oid == OID_GEN_RESET_COUNTS) ||
                 (Oid == OID_GEN_MEDIA_SENSE_COUNTS) ||
                 (Oid == OID_GEN_ELAPSED_TIME) ||
                 (Oid == OID_GEN_RESET_VERIFY_PARAMETERS) ||
                 (Oid == OID_GEN_MINIPORT_INFO) ||
                 (Oid == OID_PNP_ENABLE_WAKE_UP));

        if (fInt)
        {
            NdisStatus = NDIS_STATUS_SUCCESS;

            switch (Oid)
            {
              case OID_GEN_DIRECTED_FRAMES_RCV:
                SourceBuffer = &Miniport->NdisStats.DirectedPacketsIn;
                
                if (DataLength >= sizeof(ULONG64))
                {
                    SourceLength = sizeof(ULONG64);
                }
                else
                {
                    SourceLength = sizeof(ULONG);
                }
                break;

              case OID_GEN_DIRECTED_FRAMES_XMIT:
                SourceBuffer = &Miniport->NdisStats.DirectedPacketsOut;

                if (DataLength >= sizeof(ULONG64))
                {
                    SourceLength = sizeof(ULONG64);
                }
                else
                {
                    SourceLength = sizeof(ULONG);
                }
                break;

              case OID_GEN_MEDIA_IN_USE:
                SourceBuffer = &Miniport->MediaType;
                SourceLength = sizeof(ULONG);
                
                break;

              case OID_PNP_ENABLE_WAKE_UP:
                SourceBuffer = &Miniport->WakeUpEnable;
                SourceLength = sizeof(ULONG);
                break;

              case OID_GEN_PHYSICAL_MEDIUM:
                SourceBuffer = &Miniport->PhysicalMediumType;
                SourceLength = sizeof(ULONG);
                break;

              case OID_GEN_INIT_TIME_MS:
                SourceBuffer = &Miniport->InitTimeMs;
                SourceLength = sizeof(ULONG);
                break;

              case OID_GEN_RESET_COUNTS:
                GenericULong = (Miniport->InternalResetCount + Miniport->MiniportResetCount);
                SourceBuffer = &GenericULong;
                SourceLength = sizeof(ULONG);
                break;

              case OID_GEN_MEDIA_SENSE_COUNTS:
                GenericULong = (Miniport->MediaSenseDisconnectCount + (Miniport->MediaSenseConnectCount << 16));
                SourceBuffer = &GenericULong;
                SourceLength = sizeof(ULONG);
                break;

              case OID_GEN_ELAPSED_TIME:
                {

                    KeQueryTickCount(&CurrTicks);
                    CurrTicks.QuadPart -= Miniport->NdisStats.StartTicks.QuadPart;
                    CurrTicks.QuadPart = CurrTicks.QuadPart*KeQueryTimeIncrement()/(10*1000*1000);

                    SourceBuffer = &CurrTicks.LowPart;
                    SourceLength = sizeof(ULONG);
                
                }
                break;

              case OID_GEN_RESET_VERIFY_PARAMETERS:
                MoveMemory((PUCHAR)&ndisFlags, Buffer + NdisStatisticsHeaderSize, sizeof(ULONG));
                SourceBuffer = NULL;
                SourceLength = sizeof(ULONG);
                
                ndisVerifierInitialization();
                //
                // when ndisFlags is set by ndis tester vs. reading it from
                // registry, let it -clear- the verifier flags if necessary
                // ndisVerifierInit takes care of -setting- them if necessary
                //
                if (!(ndisFlags & NDIS_GFLAG_INJECT_ALLOCATION_FAILURE))
                    ndisVerifierLevel &= ~DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    
                if (!(ndisFlags & NDIS_GFLAG_SPECIAL_POOL_ALLOCATION))
                    ndisVerifierLevel &= ~DRIVER_VERIFIER_SPECIAL_POOLING;

                Request.DATA.SET_INFORMATION.BytesRead = sizeof(ULONG);
                break;

              case OID_GEN_MINIPORT_INFO:
                {
                InfoFlags = Miniport->InfoFlags;

                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_64BITS_DMA))
                    InfoFlags |= NDIS_MINIPORT_64BITS_DMA;
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
                    InfoFlags |= NDIS_MINIPORT_IS_CO;
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING))
                    InfoFlags |= NDIS_MINIPORT_REQUIRES_MEDIA_POLLING;
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE))
                    InfoFlags |= NDIS_MINIPORT_SUPPORTS_MEDIA_SENSE;
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED))
                    InfoFlags |= NDIS_MINIPORT_PM_SUPPORTED;
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
                    InfoFlags |= NDIS_MINIPORT_HIDDEN;
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
                    InfoFlags |= NDIS_MINIPORT_SWENUM;
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
                    InfoFlags |= NDIS_MINIPORT_HARDWARE_DEVICE;
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NDIS_WDM_DRIVER))
                    InfoFlags |= NDIS_MINIPORT_WDM_DRIVER;

                if (Miniport->DriverHandle->MiniportCharacteristics.CancelSendPacketsHandler)
                {
                    InfoFlags |= NDIS_MINIPORT_SUPPORTS_CANCEL_SEND_PACKETS;
                }

                SourceBuffer = &InfoFlags;
                SourceLength = sizeof(ULONG);

                break;
                }
              
              default:
                continue;
            }
        }
        else
        {
            //
            // not an "internal" OID
            //
            if (!ndisValidOid(OpenContext, Oid))
            {
                //
                // not a valid OID either
                //
                continue;
            }
                
            //
            // Transform OID based on media-type
            //
            if (Oid == OID_802_3_CURRENT_ADDRESS)
            {
              switch (Miniport->MediaType)
              {
                case NdisMedium802_5:
                  Oid = OID_802_5_CURRENT_ADDRESS;
                  break;
                case NdisMediumFddi:
                  Oid = OID_FDDI_LONG_CURRENT_ADDR;
                  break;
                case NdisMediumAtm:
                  Oid = OID_ATM_HW_CURRENT_ADDRESS;
                  break;
                case NdisMediumWan:
                  Oid = OID_WAN_CURRENT_ADDRESS;
                  break;
#if ARCNET
                case NdisMediumArcnetRaw:
                  Oid = OID_ARCNET_CURRENT_ADDRESS;
                  break;
#endif
              }
            }
            else if (Oid == OID_802_3_PERMANENT_ADDRESS)
            {
              switch (Miniport->MediaType)
              {
                case NdisMedium802_5:
                  Oid = OID_802_5_PERMANENT_ADDRESS;
                  break;
                case NdisMediumFddi:
                  Oid = OID_FDDI_LONG_PERMANENT_ADDR;
                  break;
                case NdisMediumAtm:
                  Oid = OID_ATM_HW_CURRENT_ADDRESS;
                  break;
                case NdisMediumWan:
                  Oid = OID_WAN_PERMANENT_ADDRESS;
                  break;
#if ARCNET
                case NdisMediumArcnetRaw:
                  Oid = OID_ARCNET_PERMANENT_ADDRESS;
                  break;
#endif
              }
            }

            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                //1 eventually we need to find a way to check for the length ourselves

                if (AlignOutput)
                {
                    SourceBuffer = Buffer + NdisStatisticsHeaderSize;
                }
                else
                {
                    SourceBuffer = DoubleBuffer;
                }
                
                
                NdisStatus = ndisQueryDeviceOid(OpenContext,
                                                &Request,
                                                Oid,
                                                SourceBuffer,
                                                BufferLengthRemained - NdisStatisticsHeaderSize);


                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    SourceLength = Request.DATA.QUERY_INFORMATION.BytesWritten;
                }
                else
                {
                    SourceLength = 0;
                }

                if (AlignOutput)
                {
                    SourceBuffer = NULL; // to avoid the copy since the data is already at the right place
                }
            }
            else
            {
                NdisStatus = NDIS_STATUS_ADAPTER_NOT_FOUND;
            }
        }

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            
            if ((SourceLength > 0) && (SourceBuffer != NULL))
            {
                MoveMemory(Buffer + NdisStatisticsHeaderSize, SourceBuffer, SourceLength);
            }
            
            //
            // Advance our pointers.
            //

            BytesWrittenThisOid = SourceLength + NdisStatisticsHeaderSize;
            
            if (AlignOutput)
            {
                //
                // activate for longhorn
                //

                ASSERT(FALSE);
                NdisStatus = NDIS_STATUS_FAILURE;
                break;

                
#if 0                
                //
                // Create the equivalent of an NDIS_STATISTICS_VALUE element for this OID value
                // (the data itself was already written in the right place.
                //
                StatisticsValueEx = (PNDIS_STATISTICS_VALUE_EX)Buffer;
                StatisticsValueEx->Oid = OidArray[CurrentOid];    // Not Oid since we map some
                StatisticsValueEx->DataLength = SourceLength;
                
                BytesWrittenAlignedThisOid = ALIGN_UP_MAX_NATURAL_ALIGNMENT_LENGTH(BytesWrittenThisOid);
                if ((BufferLengthRemained -  BytesWrittenAlignedThisOid) < (ULONG)(NdisStatisticsHeaderSize + sizeof(ULONG)))
                {
                    //
                    // this is the last statistics we can report.
                    // report the Length without any padding
                    //
                    StatisticsValueEx->Length = BytesWrittenThisOid;
                    BufferLengthRemained -= BytesWrittenThisOid;
                    Buffer += BytesWrittenThisOid;
                    BytesWritten += BytesWrittenThisOid;
                }
                else
                {
                    StatisticsValueEx->Length = BytesWrittenAlignedThisOid;
                    BufferLengthRemained -= BytesWrittenAlignedThisOid;
                    Buffer += BytesWrittenAlignedThisOid;
                    BytesWritten += BytesWrittenAlignedThisOid;
                }
#endif                
            }
            else
            {
                //
                // Create the equivalent of an NDIS_STATISTICS_VALUE element for this OID value
                // (the data itself was already written in the right place.
                //
                StatisticsValue = (PNDIS_STATISTICS_VALUE)Buffer;
                StatisticsValue->Oid = OidArray[CurrentOid];    // Not Oid since we map some
                StatisticsValue->DataLength = SourceLength;                
                BufferLengthRemained -= BytesWrittenThisOid;
                Buffer += BytesWrittenThisOid;
                BytesWritten += BytesWrittenThisOid;
            }
        }
        else
        {
            break;
        }
    }

    *pBytesWritten = BytesWritten;

    if (NdisStatus == NDIS_STATUS_NOT_SUPPORTED)
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }
    
    if (DoubleBuffer)
    {
        FREE_POOL(DoubleBuffer);
    }
    
    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisQueryStatisticsOids\n"));
  
    return NdisStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\fsbpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.c

Abstract:

    This file contains the implementation of fixed-size block pool.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#include "precomp.h"
#include <align.h>              // Macros: ROUND_UP_POINTER, POINTER_IS_ALIGNED

#define FSB_SCAVENGE_PERIOD_IN_SECONDS          30
#define FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS    20

#if defined (_WIN64)
#define APPROX_L2_CACHE_LINE_SIZE   128
#define BLOCK_TYPE SLIST_HEADER
#else
#define APPROX_L2_CACHE_LINE_SIZE   64
#define BLOCK_TYPE PVOID
#endif


// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [FSB_POOL_HEADER + FSB_CPU_POOL_HEADER for cpu 0 +
//                                         FSB_CPU_POOL_HEADER for cpu 1 + ...
//                                         FSB_CPU_POOL_HEADER for cpu N]
//

// FSB_POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _FSB_POOL_HEADER
{
// cache-line -----
    struct _FSB_POOL_HEADER_BASE
    {
        ULONG                   Tag;
        USHORT                  CallerBlockSize;    // caller's requested block size
        USHORT                  AlignedBlockSize;   // ALIGN_UP(CallerBlockSize, PVOID)
        USHORT                  BlocksPerPage;
        USHORT                  FreeBlockLinkOffset;
        NDIS_BLOCK_INITIALIZER  BuildFunction;
        PVOID                   Allocation;
        KSPIN_LOCK              Interlock;
    };
    UCHAR Alignment[APPROX_L2_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_POOL_HEADER_BASE) % APPROX_L2_CACHE_LINE_SIZE)];
} FSB_POOL_HEADER, *PFSB_POOL_HEADER;

C_ASSERT(sizeof(FSB_POOL_HEADER) % APPROX_L2_CACHE_LINE_SIZE == 0);


// FSB_CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _FSB_CPU_POOL_HEADER
{
// cache-line -----
    struct _FSB_CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free blocks available.
        //
        LIST_ENTRY              PageList;
    
        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during FsbAllocate when many pages are fully used.
        //
        LIST_ENTRY              UsedPageList;
    
        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // than this.
        //
        LARGE_INTEGER           NextScavengeTick;
    
        // The number of the processor that owns this pool.
        //
        ULONG                   OwnerCpu;
    
        ULONG                   TotalBlocksAllocated;
        ULONG                   TotalBlocksFreed;
        ULONG                   PeakBlocksInUse;
        ULONG                   TotalPagesAllocated;
        ULONG                   TotalPagesFreed;
        ULONG                   PeakPagesInUse;
    };
    UCHAR Alignment[APPROX_L2_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_CPU_POOL_HEADER_BASE) % APPROX_L2_CACHE_LINE_SIZE)];
} FSB_CPU_POOL_HEADER, *PFSB_CPU_POOL_HEADER;

C_ASSERT(sizeof(FSB_CPU_POOL_HEADER) % APPROX_L2_CACHE_LINE_SIZE == 0);



// FSB_PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the blocks on the page.
//
typedef struct _FSB_PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PFSB_CPU_POOL_HEADER    Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY              PageLink;

    // Number of blocks built so far on this page.  Blocks are built on
    // demand.  When this number reaches Pool->BlocksPerPage, all blocks on
    // this page have been built.
    //
    USHORT                  BlocksBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during FsbFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT                  OnUsedPageList;

    // List of free blocks on this page.
    //
    SLIST_HEADER            FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only used once the depth of
    // FreeList is Pool->BlocksPerPage.  (i.e. this time is only used if
    // the page is completely unused.)
    //
    LARGE_INTEGER           LastUsedTick;

} FSB_PAGE_HEADER, *PFSB_PAGE_HEADER;

// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PFSB_POOL_HEADER
PoolFromCpuPool(
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    return (PFSB_POOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}


__inline
VOID
ConvertSecondsToTicks(
    IN  ULONG                   Seconds,
    OUT PLARGE_INTEGER          Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less than 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next block on the specified pool page.
// This can only be called if not all of the blocks have been built yet.
//
PUCHAR
FsbpBuildNextBlock(
    IN  const FSB_POOL_HEADER*  Pool,
    IN  OUT PFSB_PAGE_HEADER    Page
    )
{
    PUCHAR Block;

    ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);
    ASSERT((PAGE_SIZE - sizeof(FSB_PAGE_HEADER)) / Pool->AlignedBlockSize
                == Pool->BlocksPerPage);
    ASSERT(Pool->CallerBlockSize <= Pool->AlignedBlockSize);

    Block = (PUCHAR)(Page + 1) + (Page->BlocksBuilt * Pool->AlignedBlockSize);
    ASSERT(PAGE_ALIGN(Block) == Page);

    if (Pool->BuildFunction) {
        Pool->BuildFunction(Block, Pool->CallerBlockSize);
    }

    Page->BlocksBuilt++;

    return Block;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first block on the new page and return a pointer
// to it.
//
PUCHAR
FsbpAllocateNewPageAndBuildOneBlock(
    IN const FSB_POOL_HEADER*   Pool,
    IN PFSB_CPU_POOL_HEADER     CpuPool
    )
{
    PFSB_PAGE_HEADER Page;
    PUCHAR Block = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, Pool->Tag);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(FSB_PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Block = FsbpBuildNextBlock(Pool, Page);
        ASSERT(Block);
    }

    return Block;
}

// Free the specified pool page back to the system's pool.
//
VOID
FsbpFreePage(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PFSB_PAGE_HEADER Page
    )
{
    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool(Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);
}

// Free the specified pool page list back to the system's pool.
//
VOID
FsbpFreeList(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PLIST_ENTRY Head
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_PAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    BOOLEAN UsedPageList;

    Pool = PoolFromCpuPool(CpuPool);
    UsedPageList = (Head == &CpuPool->UsedPageList);
    
    for (Scan = Head->Flink; Scan != Head; Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(UsedPageList ? Page->OnUsedPageList : !Page->OnUsedPageList);
        
        ASSERT(Page->BlocksBuilt <= Pool->BlocksPerPage);
        ASSERT(Page->BlocksBuilt == ExQueryDepthSList(&Page->FreeList));
        
        // Step to the next link before we free this page.
        //
        Next = Scan->Flink;
        
        RemoveEntryList(Scan);
        FsbpFreePage(CpuPool, Page);
    }
}

// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
FsbpScavengePool(
    IN OUT PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_PAGE_HEADER    Page;
    PLIST_ENTRY         Scan;
    PLIST_ENTRY         Next;
    LARGE_INTEGER       Ticks;
    LARGE_INTEGER       TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(FSB_SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    for (Scan = CpuPool->PageList.Flink;
         Scan != &CpuPool->PageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->BlocksPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            FsbpFreePage(CpuPool, Page);
        }
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their blocks have been freed to the page.  Un-orphan
    // them here.
    //
    for (Scan = CpuPool->UsedPageList.Flink;
         Scan != &CpuPool->UsedPageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
        }
    }
}


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//    that represenets a pointer-sized storage location that the pool can
//    use to chain free blocks together.  Most often this will be zero
//    (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//    ExAllocatePoolWithTag.  This allows callers to track
//    memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//    blocks when they are first allocated by the pool.  This allows the
//    caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN  USHORT                  BlockSize,
    IN  USHORT                  FreeBlockLinkOffset,
    IN  ULONG                   Tag,
    IN  NDIS_BLOCK_INITIALIZER  BuildFunction OPTIONAL
    )
{
    SIZE_T              Size;
    PVOID               Allocation;
    PFSB_POOL_HEADER    Pool = NULL;
    PFSB_CPU_POOL_HEADER CpuPool;
    CCHAR               NumberCpus = KeNumberProcessors;
    CCHAR               i;

    // We are going to ensure that all blocks returned by FsbAllocate are
    // properly aligned (4-byte on x86 and 16-byte on 64-bit), but we also
    // need to make sure that users are giving us a free block link offset
    // that is a multiple of the base alignment, to ensure proper alignment
    // for the free block SLIST operations.
    //
    ASSERT(FreeBlockLinkOffset % sizeof(BLOCK_TYPE) == 0);

    // We need at least a pointer size worth of space to manage free
    // blocks and we don't impose any per-block overhead, so we borrow it
    // from the block itself.
    //
    ASSERT(BlockSize >= FreeBlockLinkOffset + sizeof(BLOCK_TYPE));

    // This implementation shouldn't be used if we are not going to get more
    // than about 8 blocks per page.  Blocks bigger than this should probably
    // be allocated with multiple pages at a time.
    //
    ASSERT(BlockSize < PAGE_SIZE / 8);

    // Compute the size of our pool header allocation.
    // Add padding to ensure that the pool header can begin on a cache line.
    //
    Size = sizeof(FSB_POOL_HEADER) + (sizeof(FSB_CPU_POOL_HEADER) * NumberCpus)
        + (APPROX_L2_CACHE_LINE_SIZE - MEMORY_ALLOCATION_ALIGNMENT);

    // Allocate the pool header.
    //
    Allocation = ExAllocatePoolWithTag(NonPagedPool, Size, ' bsF');

    if (Allocation)
    {
        ASSERT(POINTER_IS_ALIGNED(Allocation, MEMORY_ALLOCATION_ALIGNMENT));
        RtlZeroMemory(Allocation, Size);
        
        Pool = ROUND_UP_POINTER(Allocation, APPROX_L2_CACHE_LINE_SIZE);        

        // Initialize the pool header fields.
        //
        Pool->Tag = Tag;
        Pool->CallerBlockSize = BlockSize;
        Pool->AlignedBlockSize = (USHORT)ALIGN_UP(BlockSize, BLOCK_TYPE);
        Pool->BlocksPerPage = (PAGE_SIZE - sizeof(FSB_PAGE_HEADER))
                                    / Pool->AlignedBlockSize;
        Pool->FreeBlockLinkOffset = FreeBlockLinkOffset;
        Pool->BuildFunction = BuildFunction;
        Pool->Allocation = Allocation;
        KeInitializeSpinLock(&Pool->Interlock);

        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE           PoolHandle
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    CCHAR               NumberCpus = KeNumberProcessors;
    CCHAR               i;

    Pool = (PFSB_POOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        FsbpFreeList(CpuPool, &CpuPool->PageList);
        FsbpFreeList(CpuPool, &CpuPool->UsedPageList);

        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalBlocksAllocated == CpuPool->TotalBlocksFreed);
    }

    ASSERT(Pool ==
           ROUND_UP_POINTER(Pool->Allocation, APPROX_L2_CACHE_LINE_SIZE));
    ExFreePool(Pool->Allocation);
}

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE           PoolHandle
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_PAGE_HEADER    Page;
    PSLIST_ENTRY        BlockLink;
    PUCHAR              Block = NULL;
    KIRQL               OldIrql;
    ULONG               Cpu;
    LARGE_INTEGER       Ticks;

    ASSERT(PoolHandle);

    Pool = (PFSB_POOL_HEADER)PoolHandle;

    // Raise IRQL before saving the processor number since there is chance
    // it could have changed if we saved it while at passive.
    //
    OldIrql = KeRaiseIrqlToDpcLevel();

    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1) + Cpu;

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.  Normally, scavenging
    // should only be performed when we free.  However, for the case when
    // the caller constantly frees on a non-owning processor, we'll
    // take this chance to do the scavenging.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        FsbpScavengePool(CpuPool);
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        BlockLink = ExInterlockedPopEntrySList(&Page->FreeList, &Pool->Interlock);
        if (BlockLink)
        {
            Block = (PUCHAR)BlockLink - Pool->FreeBlockLinkOffset;
        }
        else
        {
            // If there were no blocks on this page's free list, it had better
            // mean we haven't yet built all of the blocks on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);

            Block = FsbpBuildNextBlock(Pool, Page);
            ASSERT(Block);
        }

        // Got a block.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->BlocksBuilt == Pool->BlocksPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;

            ASSERT(Page == CONTAINING_RECORD(PageLink, FSB_PAGE_HEADER, PageLink));
        }

        ASSERT(Block);
        goto GotABlock;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Block = FsbpAllocateNewPageAndBuildOneBlock(Pool, CpuPool);
    }

    // If we are returning an block, update the statistics.
    //
    if (Block)
    {
        ULONG BlocksInUse;
GotABlock:

        CpuPool->TotalBlocksAllocated++;

        BlocksInUse = CpuPool->TotalBlocksAllocated - CpuPool->TotalBlocksFreed;
        if (BlocksInUse > CpuPool->PeakBlocksInUse)
        {
            CpuPool->PeakBlocksInUse = BlocksInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        ((PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset))->Next = NULL;
    }

    KeLowerIrql(OldIrql);

    return Block;
}

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR           Block
    )
{
    PFSB_PAGE_HEADER    Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_POOL_HEADER    Pool;
    LARGE_INTEGER       Ticks;
    LOGICAL             PageIsOnUsedPageList;
    LOGICAL             Scavenge = FALSE;

    ASSERT(Block);

    // Get the address of the page that this block lives on.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Block);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // Note the tick that this page was last used.  If this is the last block
    // to be returned to this page, this sets the minimum time that this page
    // will continue to live unless it gets re-used.
    //
    Page->LastUsedTick.QuadPart = Ticks.QuadPart;

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the block back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement((PLONG)&CpuPool->TotalBlocksFreed);

    // Now return the block to the page's free list.
    //
    ExInterlockedPushEntrySList(
        &Page->FreeList,
        (PSLIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset),
        &Pool->Interlock);

    //
    // Warning: Now that the block is back on the page, one cannot *reliably*
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor and subsequently freed.  This is a
    // particularly rare condition given that MINIMUM_PAGE_LIFETIME_IN_SECONDS
    // is 20s, so we choose to live with it.  The alternative would be to walk
    // the UsedPageList whenever PageIsOnUsedPageList is true, making the
    // FsbFree operation potentially expensive.  We saved off the value of
    // Page->OnUsedPageList before returning the block so we would not risk
    // touching Page to get this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // FsbFree didn't just sneak by) and still has a free block (for
            // instance, an FsbAllocate might sneak in on its owning processor,
            // scavenge the page, and allocate the block we just freed; thereby
            // putting it back on the used-page list), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the block to the free list because FsbAllocate expects
            // blocks to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList &&
                Page->OnUsedPageList &&
                (0 != ExQueryDepthSList(&Page->FreeList)))
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                FsbpScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\mini.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    mini.h

Abstract:

    NDIS miniport wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

#ifndef __MINI_H
#define __MINI_H

//
//  Macros for setting, clearing, and testing bits in the Miniport Flags.
//
#define MINIPORT_SET_FLAG(_M, _F)           ((_M)->Flags |= (_F))
#define MINIPORT_CLEAR_FLAG(_M, _F)         ((_M)->Flags &= ~(_F))
#define MINIPORT_TEST_FLAG(_M, _F)          (((_M)->Flags & (_F)) != 0)
#define MINIPORT_TEST_FLAGS(_M, _F)         (((_M)->Flags & (_F)) == (_F))

/*
#define MINIPORT_SET_FLAG(_M, _F)                                               \
{                                                                               \
    volatile ULONG   _OldFlags = (_M)->Flags;                                   \
    ((_M)->Flags |= (_F));                                                      \
    if (((_M)->Flags ^ _OldFlags) & (~(_F)))                                    \
    {                                                                           \
        DbgPrint("_OldFlags %lx, _M->flags %lx, _F %lx\n", _OldFlags, (_M)->Flags, (_F));   \
        DbgBreakPoint();                                                        \
    }                                                                           \
}

#define MINIPORT_CLEAR_FLAG(_M, _F)                                             \
{                                                                               \
    volatile ULONG   _OldFlags = (_M)->Flags;                                   \
    ((_M)->Flags &= ~(_F));                                                     \
    if (((_M)->Flags ^ _OldFlags) & (~(_F)))                                    \
    {                                                                           \
        DbgPrint("_OldFlags %lx, _M->flags %lx, _F %lx\n", _OldFlags, (_M)->Flags, (_F));   \
        DbgBreakPoint();                                                        \
    }                                                                           \
}
*/


#define MINIPORT_SET_SEND_FLAG(_M, _F)      ((_M)->SendFlags |= (_F))
#define MINIPORT_CLEAR_SEND_FLAG(_M, _F)    ((_M)->SendFlags &= ~(_F))
#define MINIPORT_TEST_SEND_FLAG(_M, _F)     (((_M)->SendFlags & (_F)) != 0)

#define MINIPORT_PNP_SET_FLAG(_M, _F)       ((_M)->PnPFlags |= (_F))
#define MINIPORT_PNP_CLEAR_FLAG(_M, _F)     ((_M)->PnPFlags &= ~(_F))
#define MINIPORT_PNP_TEST_FLAG(_M, _F)      (((_M)->PnPFlags & (_F)) != 0)
#define MINIPORT_PNP_TEST_FLAGS(_M, _F)     (((_M)->PnPFlags & (_F)) == (_F))

#define MINIPORT_VERIFY_SET_FLAG(_M, _F)    ((_M)->DriverVerifyFlags |= (_F))
#define MINIPORT_VERIFY_CLEAR_FLAG(_M, _F)  ((_M)->DriverVerifyFlags &= ~(_F))
#define MINIPORT_VERIFY_TEST_FLAG(_M, _F)   (((_M)->DriverVerifyFlags & (_F)) != 0)
#define MINIPORT_VERIFY_TEST_FLAGS(_M, _F)  (((_M)->DriverVerifyFlags & (_F)) == (_F))

#define OPEN_SET_FLAG(_O, _F)           ((_O)->Flags |= (_F))
#define OPEN_CLEAR_FLAG(_O, _F)         ((_O)->Flags &= ~(_F))
#define OPEN_TEST_FLAG(_O, _F)          (((_O)->Flags & (_F)) != 0)
#define OPEN_TEST_FLAGS(_O, _F)         (((_O)->Flags & (_F)) == (_F))


//
//  Flags for packet information.
//
#define MINIPORT_SET_PACKET_FLAG(_P, _F)    ((_P)->Private.NdisPacketFlags |= (_F))
#define MINIPORT_CLEAR_PACKET_FLAG(_P, _F)  ((_P)->Private.NdisPacketFlags &= ~(_F))
#define MINIPORT_TEST_PACKET_FLAG(_P, _F)   (((_P)->Private.NdisPacketFlags & (_F)) != 0)

//
// Low-bits in the packet flags are reserved by NDIS Wrapper for internal use
//
#if (fPACKET_WRAPPER_RESERVED != 0x3F)
#error (Packet flags overlap)
#endif

#define fPACKET_HAS_TIMED_OUT               0x01
#define fPACKET_IS_LOOPBACK                 0x02
#define fPACKET_SELF_DIRECTED               0x04
#define fPACKET_DONT_COMPLETE               0x08
#define fPACKET_PENDING                     0x10
#define fPACKET_ALREADY_LOOPEDBACK          0x20
#define fPACKET_CLEAR_ITEMS                 0x3F

#define NDIS_STATISTICS_HEADER_SIZE         FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data[0])

//
// Timeout values
//
#define NDIS_MINIPORT_WAKEUP_TIMEOUT        2000    // Wakeup DPC
#define NDIS_MINIPORT_DEFERRED_TIMEOUT      15      // Deferred timer
#define NDIS_MINIPORT_TR_RESET_TIMEOUT      15      // Number of WakeUps per reset attempt
#define NDIS_CFHANG_TIME_SECONDS            2
#define NDISWAN_OPTIONS                     (NDIS_MAC_OPTION_RESERVED | NDIS_MAC_OPTION_NDISWAN)
#define NDIS_MINIPORT_DISCONNECT_TIMEOUT    20      // 20 seconds
#define INTERNAL_INDICATION_SIZE            (UINT)-2
#define INTERNAL_INDICATION_BUFFER          (PVOID)-1

#define NDIS_M_MAX_MULTI_LIST               32

typedef struct _NDIS_PENDING_IM_INSTANCE    NDIS_PENDING_IM_INSTANCE, *PNDIS_PENDING_IM_INSTANCE;

typedef struct _NDIS_PENDING_IM_INSTANCE
{
    PNDIS_PENDING_IM_INSTANCE   Next;
    NDIS_HANDLE                 Context;
    UNICODE_STRING              Name;
} NDIS_PENDING_IM_INSTANCE, *PNDIS_PENDING_IM_INSTANCE;

typedef struct _NDIS_POST_OPEN_PROCESSING
{
    PNDIS_OPEN_BLOCK            Open;
    WORK_QUEUE_ITEM             WorkItem;
} NDIS_POST_OPEN_PROCESSING, *PNDIS_POST_OPEN_PROCESSING;

//
// one of these per Driver
//
struct _NDIS_M_DRIVER_BLOCK
{
    PNDIS_M_DRIVER_BLOCK        NextDriver;
    PNDIS_MINIPORT_BLOCK        MiniportQueue;      // queue of mini-ports for this driver

    PNDIS_WRAPPER_HANDLE        NdisDriverInfo;     // Driver information.
    PNDIS_PROTOCOL_BLOCK        AssociatedProtocol; // For IM drivers
    LIST_ENTRY                  DeviceList;
    PNDIS_PENDING_IM_INSTANCE   PendingDeviceList;
    PDRIVER_UNLOAD              UnloadHandler;
                                                    //  of this NDIS_DRIVER_BLOCK structure
    NDIS51_MINIPORT_CHARACTERISTICS MiniportCharacteristics; // handler addresses

    KEVENT                      MiniportsRemovedEvent;// used to find when all mini-ports are gone.
    REFERENCE                   Ref;                // contains spinlock for MiniportQueue
    USHORT                      Flags;
    KMUTEX                      IMStartRemoveMutex; // Synchronizes call to IMInitDevInstance and PnpRemove
    ULONG                       DriverVersion;
};

#define fMINIBLOCK_INTERMEDIATE_DRIVER          0x0001
#define fMINIBLOCK_VERIFYING                    0x0002
#define fMINIBLOCK_RECEIVED_TERMINATE_WRAPPER   0x0004
#define fMINIBLOCK_IO_UNLOAD                    0x0008
#define fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD     0x0010
#define fMINIBLOCK_UNLOADING                    0x8000

#define ndisMDereferenceOpen(_Open)                                         \
    {                                                                       \
        UINT    _OpenRef;                                                   \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                          \
                ("- Open 0x%x Reference 0x%x\n",                            \
                _Open, (_Open)->References));                               \
                                                                            \
        M_OPEN_DECREMENT_REF_INTERLOCKED(_Open, _OpenRef);                  \
                                                                            \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                          \
                ("==0 Open 0x%x Reference 0x%x\n",                          \
                _Open, _OpenRef));                                          \
                                                                            \
        if (_OpenRef == 0)                                                  \
        {                                                                   \
            ndisMFinishClose(_Open);                                        \
        }                                                                   \
    }

//
// Flags definition for NDIS_OPEN_BLOCK.
//
#define fMINIPORT_OPEN_USING_ETH_ENCAPSULATION  0x00000001
#define fMINIPORT_OPEN_NO_LOOPBACK              0x00000002
#define fMINIPORT_OPEN_PMODE                    0x00000004
#define fMINIPORT_OPEN_NO_PROT_RSVD             0x00000008
#define fMINIPORT_OPEN_PROCESSING               0x00000010
#define fMINIPORT_PACKET_RECEIVED               0x00000080
#define fMINIPORT_STATUS_RECEIVED               0x00000100
#define fMINIPORT_OPEN_CLOSING                  0x00008000
#define fMINIPORT_OPEN_UNBINDING                0x00010000
#define fMINIPORT_OPEN_CALL_MANAGER             0x00020000
#define fMINIPORT_OPEN_CLIENT                   0x00040000
#define fMINIPORT_OPEN_NOTIFY_PROCESSING        0x00080000
#define fMINIPORT_OPEN_CLOSE_COMPLETE           0x00100000
#define fMINIPORT_OPEN_DONT_FREE                0x00200000
#define fMINIPORT_OPEN_NO_BIND_REQUEST          0x00400000



//
// Definitions for NDIS_MINIPORT_BLOCK GeneralFlags.
//
#define fMINIPORT_NORMAL_INTERRUPTS             0x00000001
#define fMINIPORT_IN_INITIALIZE                 0x00000002
#define fMINIPORT_ARCNET_BROADCAST_SET          0x00000004
#define fMINIPORT_BUS_MASTER                    0x00000008
#define fMINIPORT_64BITS_DMA                    0x00000010
#define fMINIPORT_DEREGISTERED_INTERRUPT        0x00000020
#define fMINIPORT_SG_LIST                       0x00000040
#define fMINIPORT_REQUEST_TIMEOUT               0x00000100
#define fMINIPORT_PROCESSING_REQUEST            0x00000400
#define fMINIPORT_IGNORE_PACKET_QUEUE           0x00000800
#define fMINIPORT_IGNORE_REQUEST_QUEUE          0x00001000
#define fMINIPORT_IGNORE_TOKEN_RING_ERRORS      0x00002000
#define fMINIPORT_CHECK_FOR_LOOPBACK            0x00004000
#define fMINIPORT_INTERMEDIATE_DRIVER           0x00008000
#define fMINIPORT_IS_NDIS_5                     0x00010000
#define fMINIPORT_IS_CO                         0x00020000
#define fMINIPORT_DESERIALIZE                   0x00040000
#define fMINIPORT_CALLING_RESET                 0x00080000
#define fMINIPORT_RESET_REQUESTED               0x00100000
#define fMINIPORT_RESET_IN_PROGRESS             0x00200000
#define fMINIPORT_RESOURCES_AVAILABLE           0x00400000
#define fMINIPORT_SEND_LOOPBACK_DIRECTED        0x00800000
#define fMINIPORT_RESTORING_FILTERS             0x01000000
#define fMINIPORT_REQUIRES_MEDIA_POLLING        0x02000000
#define fMINIPORT_SUPPORTS_MEDIA_SENSE          0x04000000
#define fMINIPORT_DOES_NOT_DO_LOOPBACK          0x08000000
#define fMINIPORT_SECONDARY                     0x10000000
#define fMINIPORT_MEDIA_CONNECTED               0x20000000
#define fMINIPORT_NETBOOT_CARD                  0x40000000
#define fMINIPORT_PM_HALTING                    0x80000000

#define MINIPORT_LOCK_ACQUIRED(_Miniport)       ((_Miniport)->LockAcquired & 0x01)

#define MINIPORT_AT_DPC_LEVEL (CURRENT_IRQL == DISPATCH_LEVEL)

#define ASSERT_MINIPORT_LOCKED(_Miniport)           \
    if (!MINIPORT_TEST_FLAG(_Miniport, fMINIPORT_DESERIALIZE))  \
    {                                               \
        ASSERT(MINIPORT_LOCK_ACQUIRED(_Miniport));  \
        ASSERT(MINIPORT_AT_DPC_LEVEL);              \
    }

//
//  Send flags
//
#define fMINIPORT_SEND_PACKET_ARRAY             0x01
#define fMINIPORT_SEND_DO_NOT_MAP_MDLS          0x02

//
//  Flags used in PnPFlags
//
#define fMINIPORT_PM_SUPPORTED                  0x00000001
#define fMINIPORT_NO_SHUTDOWN                   0x00000004
#define fMINIPORT_MEDIA_DISCONNECT_WAIT         0x00000008
#define fMINIPORT_REMOVE_IN_PROGRESS            0x00000010
#define fMINIPORT_DEVICE_POWER_ENABLE           0x00000020
#define fMINIPORT_DEVICE_POWER_WAKE_ENABLE      0x00000040
#define fMINIPORT_DEVICE_FAILED                 0x00000100
#define fMINIPORT_MEDIA_DISCONNECT_CANCELLED    0x00000200
#define fMINIPORT_SEND_WAIT_WAKE                0x00000400
#define fMINIPORT_SYSTEM_SLEEPING               0x00000800
#define fMINIPORT_HIDDEN                        0x00001000
#define fMINIPORT_SWENUM                        0x00002000
#define fMINIPORT_PM_HALTED                     0x00004000
#define fMINIPORT_NO_HALT_ON_SUSPEND            0x00008000
#define fMINIPORT_RECEIVED_START                0x00010000
#define fMINIPORT_REJECT_REQUESTS               0x00020000
#define fMINIPORT_PROCESSING                    0x00040000
#define fMINIPORT_HALTING                       0x00080000
#define fMINIPORT_VERIFYING                     0x00100000
#define fMINIPORT_HARDWARE_DEVICE               0x00200000
#define fMINIPORT_NDIS_WDM_DRIVER               0x00400000
#define fMINIPORT_SHUT_DOWN                     0x00800000
#define fMINIPORT_SHUTTING_DOWN                 0x01000000
#define fMINIPORT_ORPHANED                      0x02000000
#define fMINIPORT_QUEUED_BIND_WORKITEM          0x04000000
#define fMINIPORT_FILTER_IM                     0x08000000
#define fMINIPORT_MEDIA_DISCONNECT_INDICATED    0x10000000
#define fMINIPORT_CANCEL_WAKE_UP_TIMER          0x20000000
#if NDIS_RECV_SCALE
#define fMINIPORT_SUPPORTS_RECEIVE_SCALE        0x40000000
#endif

//
// flags used in DriverVerifyFlags
//

#define fMINIPORT_VERIFY_FAIL_MAP_REG_ALLOC         0x00000001
#define fMINIPORT_VERIFY_FAIL_INTERRUPT_REGISTER    0x00000002
#define fMINIPORT_VERIFY_FAIL_SHARED_MEM_ALLOC      0x00000004
#define fMINIPORT_VERIFY_FAIL_CANCEL_TIMER          0x00000008
#define fMINIPORT_VERIFY_FAIL_MAP_IO_SPACE          0x00000010
#define fMINIPORT_VERIFY_FAIL_REGISTER_IO           0x00000020
#define fMINIPORT_VERIFY_FAIL_READ_CONFIG_SPACE     0x00000040
#define fMINIPORT_VERIFY_FAIL_WRITE_CONFIG_SPACE    0x00000080
#define fMINIPORT_VERIFY_FAIL_INIT_SG               0x00000100

//
// flags used in XState field to show why we have set handlers to fake ones
//
#define fMINIPORT_STATE_RESETTING                   0x01
#define fMINIPORT_STATE_MEDIA_DISCONNECTED          0x02
#define fMINIPORT_STATE_PM_STOPPED                  0x04



//
// The following defines the NDIS usage of the PacketStack->NdisReserved area. It has different semantics
// for send and receive
//
#define NUM_PACKET_STACKS           2           // Default, registry configurable
typedef struct _NDIS_STACK_RESERVED
{
    union
    {
        struct _SEND_STACK_RESERVED
        {
            PNDIS_OPEN_BLOCK            Open;       // Tracks who the packet owner is - only for de-serialized drivers
            PNDIS_CO_VC_PTR_BLOCK       VcPtr;      // For CO miniports, identifies the VC
        };
        struct _RECV_STACK_RESERVED
        {
            union
            {
                PNDIS_MINIPORT_BLOCK    Miniport;   // Identifies the miniport (IM) that indicated the packet
                PNDIS_PACKET            NextPacket; // In the return-packet queue
            };
            union                                   // Keeps track of ref-counts
            {
                struct
                {
                    LONG                RefCount;
                    LONG                XRefCount;
                };
                ULONG                   RefUlong;
            };
        };
        struct _XFER_DATA_STACK_RESERVED
        {
            PNDIS_OPEN_BLOCK    Opens[3];
        };
    };
    
    KSPIN_LOCK                  Lock;

} NDIS_STACK_RESERVED, *PNDIS_STACK_RESERVED;

#define NDIS_STACK_RESERVED_FROM_PACKET(_P, _NSR)                               \
    {                                                                           \
        PNDIS_PACKET_STACK  _Stack;                                             \
                                                                                \
        GET_CURRENT_PACKET_STACK((_P), &_Stack);                                \
        ASSERT(_Stack != NULL);                                                 \
        *(_NSR) = (PNDIS_STACK_RESERVED)(_Stack->NdisReserved);                 \
    }

#define NDIS_XFER_DATA_STACK_RESERVED_FROM_PACKET(_P, _NSR_OPENS)               \
    {                                                                           \
                                                                                \
        GET_CURRENT_XFER_DATA_PACKET_STACK((_P), &_NSR_OPENS);                  \
        ASSERT(_NSR_OPENS != NULL);                                             \
    }

typedef struct _NDIS_LOOPBACK_REF
{
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_PACKET            NextLoopbackPacket;
} NDIS_LB_REF, *PNDIS_LB_REF;

#define PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)  ((PNDIS_LB_REF)((_P)->MiniportReserved))

#define LOOPBACK_OPEN_IN_PACKET(_P)         PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)->Open
#define SET_LOOPBACK_OPEN_IN_PACKET(_P, _O) LOOPBACK_OPEN_IN_PACKET(_P) = (_O)
#define LOOPBACK_LINKAGE(_P)                PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)->NextLoopbackPacket

//
//  PnP Event reserved information for NDIS.
//
typedef struct _NDIS_PNP_EVENT_RESERVED
{
    PKEVENT             pEvent;
    NDIS_STATUS         Status;
    NDIS_HANDLE         Open;
} NDIS_PNP_EVENT_RESERVED, *PNDIS_PNP_EVENT_RESERVED;

#define PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(x)  ((PNDIS_PNP_EVENT_RESERVED)(x)->NdisReserved)

#define NDISM_QUEUE_WORK_ITEM(_M, _WT, _WC)             ndisMQueueWorkItem(_M, _WT, _WC)
#define NDISM_QUEUE_NEW_WORK_ITEM(_M, _WT, _WC, _WH)    ndisMQueueNewWorkItem(_M, _WT, _WC, _WH)
#define NDISM_DEQUEUE_WORK_ITEM(_M, _WT, _pWC)          ndisMDeQueueWorkItem(_M, _WT, _pWC, NULL)
#define NDISM_DEQUEUE_WORK_ITEM_WITH_HANDLER(_M, _WT, _pWC, _pWH)   \
                                                        ndisMDeQueueWorkItem(_M, _WT, _pWC, _pWH)

#define NDISM_PROCESS_DEFERRED(_M)                      ndisMProcessDeferred(_M)

#define MINIPORT_ENABLE_INTERRUPT(_M_)                                              \
{                                                                                   \
    if ((_M_)->EnableInterruptHandler != NULL)                                      \
    {                                                                               \
        ((_M_)->EnableInterruptHandler)((_M_)->MiniportAdapterContext);             \
    }                                                                               \
}

#define MINIPORT_SYNC_ENABLE_INTERRUPT(_M_)                                         \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->EnableInterruptHandler != NULL))                                    \
    {                                                                               \
        SYNC_WITH_ISR(((_M_))->Interrupt->InterruptObject,                          \
                      ((_M_)->EnableInterruptHandler),                              \
                      (_M_)->MiniportAdapterContext);                               \
    }                                                                               \
}

#define MINIPORT_DISABLE_INTERRUPT(_M_)                                             \
{                                                                                   \
    ASSERT((_M_)->DisableInterruptHandler != NULL);                                 \
    ((_M_)->DriverHandle->MiniportCharacteristics.DisableInterruptHandler)(         \
                (_M_)->MiniportAdapterContext);                                     \
}

#define MINIPORT_SYNC_DISABLE_INTERRUPT(_M_)                                        \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->DisableInterruptHandler != NULL))                                   \
    {                                                                               \
        SYNC_WITH_ISR(((_M_))->Interrupt->InterruptObject,                          \
                      ((_M_)->DisableInterruptHandler),                             \
                      (_M_)->MiniportAdapterContext);                               \
    }                                                                               \
}

#define MINIPORT_ENABLE_INTERRUPT_EX(_M_, _I_)                                      \
{                                                                                   \
    if ((_M_)->EnableInterruptHandler != NULL)                                      \
    {                                                                               \
        ((_M_)->EnableInterruptHandler)((_I_)->Reserved);                           \
    }                                                                               \
}

#define MINIPORT_SYNC_ENABLE_INTERRUPT_EX(_M_, _I_)                                 \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->EnableInterruptHandler != NULL))                                    \
    {                                                                               \
        SYNC_WITH_ISR(((_I_))->InterruptObject,                                     \
                      ((_M_)->EnableInterruptHandler),                              \
                      (_I_)->Reserved);                                             \
    }                                                                               \
}

#define MINIPORT_DISABLE_INTERRUPT_EX(_M_, _I_)                                     \
{                                                                                   \
    ASSERT((_M_)->DisableInterruptHandler != NULL);                                 \
    ((_M_)->DriverHandle->MiniportCharacteristics.DisableInterruptHandler)(         \
                      (_I_)->Reserved);                                             \
}

#define MINIPORT_SYNC_DISABLE_INTERRUPT_EX(_M_, _I_)                                \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->DisableInterruptHandler != NULL))                                   \
    {                                                                               \
        SYNC_WITH_ISR(((_I_))->InterruptObject,                                     \
                      ((_M_)->DisableInterruptHandler),                             \
                      (_I_)->Reserved);                                             \
    }                                                                               \
}



#define CHECK_FOR_NORMAL_INTERRUPTS(_M_)                                            \
    if (((_M_)->Interrupt != NULL) &&                                               \
        !(_M_)->Interrupt->IsrRequested &&                                          \
        !(_M_)->Interrupt->SharedInterrupt)                                         \
    {                                                                               \
        (_M_)->Flags |= fMINIPORT_NORMAL_INTERRUPTS;                                \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        (_M_)->Flags &= ~fMINIPORT_NORMAL_INTERRUPTS;                               \
    }


#define WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus, _pRSize)    \
{                                                                                   \
    if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))                                    \
    {                                                                               \
        *(_pStatus) = STATUS_BUFFER_TOO_SMALL;                                      \
        *(_pRSize) = sizeof(ULONG);                                                 \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        (_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);                 \
        (_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;                        \
        ((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);                    \
        *(_pRSize) = sizeof(WNODE_TOO_SMALL);                                       \
        *(_pStatus) = STATUS_SUCCESS;                                               \
    }                                                                               \
}


#define MAP_NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                       \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}



#define EXPERIMENTAL_SIZE               4
#define VC_IDENTIFIER                   L':'
#define VC_IDENTIFIER_STRING            L":"
#define VC_ID_INDEX                     5
#define VC_INSTANCE_ID_SIZE             (sizeof(WCHAR) * 24)    // "XXXX:YYYYYYYYYYYYYYYY "
#define NIBBLE_MASK                     0x0F

#define fNDIS_GUID_EVENT_ENABLED        0x80000000
#define fNDIS_GUID_NOT_SETTABLE         0x40000000
#define fNDIS_GUID_NDIS_ONLY            0x20000000
#define fNDIS_GUID_CO_NDIS              0x10000000

#define NDIS_GUID_SET_FLAG(m, f)        ((m)->Flags |= (f))
#define NDIS_GUID_CLEAR_FLAG(m, f)      ((m)->Flags &= ~(f))
#define NDIS_GUID_TEST_FLAG(m, f)       (((m)->Flags & (f)) != 0)

typedef struct _AsyncWorkItem
{
    WORK_QUEUE_ITEM         ExWorkItem;
    PNDIS_MINIPORT_BLOCK    Miniport;
    ULONG                   Length;
    BOOLEAN                 Cached;
    PVOID                   VAddr;
    PVOID                   Context;
    NDIS_PHYSICAL_ADDRESS   PhyAddr;
} ASYNC_WORKITEM, *PASYNC_WORKITEM;


//
//  Macro for the deferred send handler.
//
#define NDISM_START_SENDS(_M)               (_M)->DeferredSendHandler((_M))

#define NDISM_DEFER_PROCESS_DEFERRED(_M)    QUEUE_DPC(&(_M)->DeferredDpc)

//
// A list of registered address families are maintained here.
//
typedef struct _NDIS_AF_LIST
{
    struct _NDIS_AF_LIST    *   NextAf;     // For this miniport Head at NDIS_MINIPORT_BLOCK

    PNDIS_OPEN_BLOCK            Open;       // Back pointer to the open-block

    CO_ADDRESS_FAMILY           AddressFamily;

    NDIS_CALL_MANAGER_CHARACTERISTICS   CmChars;
} NDIS_AF_LIST, *PNDIS_AF_LIST;

typedef struct  _NDIS_AF_NOTIFY
{
    struct _NDIS_AF_NOTIFY *    Next;
    WORK_QUEUE_ITEM             WorkItem;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_OPEN_BLOCK            Open;
    CO_ADDRESS_FAMILY           AddressFamily;
} NDIS_AF_NOTIFY, *PNDIS_AF_NOTIFY;


typedef struct _POWER_WORK_ITEM
{
    //
    // NDIS_WORK_ITEM needs to be the first element here !!!
    //
    NDIS_WORK_ITEM  WorkItem;
    PIRP            pIrp;
} POWER_WORK_ITEM, *PPOWER_WORK_ITEM;


typedef
NDIS_STATUS
(FASTCALL *SET_INFO_HANDLER)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    );

typedef struct _OID_SETINFO_HANDLER
{
    NDIS_OID                    Oid;
    SET_INFO_HANDLER            SetInfoHandler;
} OID_SETINFO_HANDLER, *POID_SETINFO_HANDLER;


#define READ_LOCK                       0
#define WRITE_LOCK_STATE_UNKNOWN        1
#define LOCK_STATE_ALREADY_ACQUIRED     2
#define READ_LOCK_STATE_FREE            3
#define WRITE_LOCK_STATE_FREE           4
#define LOCK_STATE_UNKNOWN              (USHORT)-1

typedef
VOID
(FASTCALL *LOCK_HANDLER)(
    IN  PVOID                   Filter,
    IN OUT  PLOCK_STATE         pLockState
    );

#define READ_LOCK_FILTER(_Miniport, _Filter, _pLockState)   NDIS_READ_LOCK(&(_Filter)->BindListLock, _pLockState);
#define READ_UNLOCK_FILTER(_Miniport, _Filter, _pLockState) NDIS_READ_LOCK_STATE_FREE(&(_Filter)->BindListLock, _pLockState)

#define READ_LOCK_FILTER_DPC(_Miniport, _Filter, _pLockState)   NDIS_READ_LOCK_DPC(&(_Filter)->BindListLock, _pLockState);
#define READ_UNLOCK_FILTER_DPC(_Miniport, _Filter, _pLockState) NDIS_READ_LOCK_STATE_FREE_DPC(&(_Filter)->BindListLock, _pLockState)



#define WRITE_LOCK_FILTER(_Miniport, _Filter, _pLockState)  \
    {                                                       \
        LOCK_HANDLER LockHandler =                          \
                (LOCK_HANDLER)((_Miniport)->LockHandler);   \
                                                            \
        (_pLockState)->LockState = WRITE_LOCK_STATE_UNKNOWN;\
        (*LockHandler)(_Filter, _pLockState);               \
    }

#define WRITE_UNLOCK_FILTER(_Miniport, _Filter, _pLockState) UNLOCK_FILTER(_Miniport, _Filter, _pLockState)

#define UNLOCK_FILTER(_Miniport, _Filter, _pLockState)      \
    {                                                       \
        LOCK_HANDLER LockHandler =                          \
                (LOCK_HANDLER)((_Miniport)->LockHandler);   \
                                                            \
        (*LockHandler)(_Filter, _pLockState);               \
    }

#define M_OPEN_INCREMENT_REF_INTERLOCKED(_O)                \
{                                                           \
    UINT MOpen_RefCount;                                    \
    MOpen_RefCount = (ULONG)InterlockedIncrement(&(_O)->References);\
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_INCREMENT_M_OPEN_REFCOUNT,\
                               __LINE__,                    \
                               MODULE_NUMBER,               \
                               (_O),                        \
                               MOpen_RefCount);             \
}



#define M_OPEN_DECREMENT_REF_INTERLOCKED(_O, _OR)                   \
{                                                                   \
    _OR = (ULONG)InterlockedDecrement(&(_O)->References);              \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_DECREMENT_M_OPEN_REFCOUNT,       \
                               __LINE__,                            \
                               MODULE_NUMBER,                       \
                               _O,                                  \
                               _OR);                                \
}


#define OPEN_INCREMENT_AF_NOTIFICATION(_O)                                      \
{                                                                               \
    UINT MOpen_AfRefCount;                                                      \
    MOpen_AfRefCount = (ULONG)InterlockedIncrement(&(_O)->PendingAfNotifications); \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_INCREMENT_OPEN_AF_NOTIFICATION,              \
                               __LINE__,                                        \
                               MODULE_NUMBER,                                   \
                               (_O),                                            \
                               MOpen_AfRefCount);                               \
}

#define OPEN_DECREMENT_AF_NOTIFICATION(_O, _OR)                                 \
{                                                                               \
    _OR = (ULONG)InterlockedDecrement(&(_O)->PendingAfNotifications);              \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_DECREMENT_OPEN_AF_NOTIFICATION,              \
                               __LINE__,                                        \
                               MODULE_NUMBER,                                   \
                               _O,                                              \
                               _OR);                                            \
}


#ifdef TRACK_MINIPORT_REFCOUNTS
#define MINIPORT_INCREMENT_REF(_M)  ndisReferenceMiniportAndLog(_M, __LINE__, MODULE_NUMBER)
#define MINIPORT_INCREMENT_REF_NO_CHECK(_M)  ndisReferenceMiniportAndLogNoCheck(_M, __LINE__, MODULE_NUMBER)
#define MINIPORT_INCREMENT_REF_CREATE(_M, _IRP) ndisReferenceMiniportAndLogCreate(_M, __LINE__, MODULE_NUMBER, _IRP)
#else
#define MINIPORT_INCREMENT_REF(_M)  ndisReferenceMiniport(_M)
#define MINIPORT_INCREMENT_REF_NO_CHECK(_M)  ndisReferenceMiniportNoCheck(_M)
#define MINIPORT_INCREMENT_REF_CREATE(_M, _IRP) ndisReferenceMiniport(_M)
#endif


#define MINIPORT_DECREMENT_REF(_M)                          \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceMiniport(_M);                        \
    }
    
#define MINIPORT_DECREMENT_REF_CLOSE(_M, _IRP)              \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceMiniport(_M);                        \
    }

#define MINIPORT_DECREMENT_REF_NO_CLEAN_UP(_M)              \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceULongRef(&(_M)->Ref);                     \
    }
    
#ifdef TRACK_MINIPORT_MPMODE_OPENS
#define NDIS_CHECK_PMODE_OPEN_REF(_M)                       \
{                                                           \
    PNDIS_OPEN_BLOCK    _pOpen = (_M)->OpenQueue;           \
    UINT                _NumPmodeOpens = 0;                 \
    while(_pOpen)                                           \
    {                                                       \
        if (_pOpen->Flags & fMINIPORT_OPEN_PMODE)           \
            _NumPmodeOpens++;                               \
        _pOpen = _pOpen->MiniportNextOpen;                  \
    }                                                       \
    ASSERT((_M)->PmodeOpens == _NumPmodeOpens);             \
    (_M)->PmodeOpens = (UCHAR)_NumPmodeOpens;               \
}
#else
#define NDIS_CHECK_PMODE_OPEN_REF(_M)
#endif

//
// if PmodeOpens > 0 and NumOpens > 1, then check to see if we should 
// loop back the packet.
//
// we should also should loopback the packet if the protocol did not
// explicitly asked for the packet not to be looped back and we either have a miniport
// that has indicated that it does not do loopback itself or it is in all_local
// mode.
//


#define NDIS_CHECK_FOR_LOOPBACK(_M, _P)                                     \
    ((MINIPORT_TEST_FLAG(_M, fMINIPORT_CHECK_FOR_LOOPBACK))            ||   \
     (((NdisGetPacketFlags(_P) & NDIS_FLAGS_DONT_LOOPBACK) == 0)  &&        \
      (MINIPORT_TEST_FLAG(_M, fMINIPORT_DOES_NOT_DO_LOOPBACK |              \
                              fMINIPORT_SEND_LOOPBACK_DIRECTED)             \
      )                                                                     \
     )                                                                      \
    )



//
// obselete API. shouldn't show up in ndis.h
//
EXPORT
NDIS_STATUS
NdisQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
);

EXPORT
VOID
NdisImmediateReadPortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    );

EXPORT
VOID
NdisImmediateReadPortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUSHORT Data
    );

EXPORT
VOID
NdisImmediateReadPortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PULONG Data
    );

EXPORT
VOID
NdisImmediateWritePortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    );

EXPORT
VOID
NdisImmediateWritePortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    );

EXPORT
VOID
NdisImmediateWritePortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    );

EXPORT
VOID
NdisImmediateReadSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    );

EXPORT
VOID
NdisImmediateWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisImmediateReadPciSlotInformation(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisImmediateWritePciSlotInformation(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

#define ALIGN_8_LENGTH(_length) (((ULONG)(_length) + 7) & ~7)
#define ALIGN_8_TYPE(_type) ((sizeof(_type) + 7) & ~7)

#define ALIGN_UP_MAX_NATURAL_ALIGNMENT_LENGTH(_length) (((ULONG)(_length) + (MAX_NATURAL_ALIGNMENT - 1)) & ~(MAX_NATURAL_ALIGNMENT - 1))

#endif // __MINI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\initpnp.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    initpnp.c

Abstract:

    NDIS wrapper functions initializing drivers.

Author:

    Jameel Hyder (jameelh) 11-Aug-1995

Environment:

    Kernel mode, FSD

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_INITPNP

NDIS_STATUS
ndisInitializeConfiguration(
    OUT PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PUNICODE_STRING                     pExportName OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#define PQueryTable pConfigurationHandle->ParametersQueryTable
#define LQueryTable pConfigurationHandle->ParametersQueryTable

    NDIS_STATUS                     NdisStatus;
    PWSTR                           Export = NULL;
    NTSTATUS                        RegistryStatus;
    PNDIS_CONFIGURATION_PARAMETER   ReturnedValue;
    NDIS_CONFIGURATION_HANDLE       CnfgHandle;
    NDIS_STRING                     BusNumberStr = NDIS_STRING_CONST("BusNumber");
    NDIS_STRING                     SlotNumberStr = NDIS_STRING_CONST("SlotNumber");
    NDIS_STRING                     BusTypeStr = NDIS_STRING_CONST("BusType");
    NDIS_STRING                     PnPCapsStr = NDIS_STRING_CONST("PnPCapabilities");
    NDIS_STRING                     RemoteBootStr = NDIS_STRING_CONST("RemoteBootCard");
    NDIS_STRING                     PollMediaConnectivityStr = NDIS_STRING_CONST("RequiresMediaStatePoll");
    NDIS_STRING                     NdisDriverVerifyFlagsStr = NDIS_STRING_CONST("NdisDriverVerifyFlags");
    NDIS_STRING                     SGMapRegistersNeededStr = NDIS_STRING_CONST("SGMapRegistersNeeded");
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF    
    NDIS_STRING                     MediaDisconnectTimeOutStr = NDIS_STRING_CONST("MediaDisconnectToSleepTimeOut");
    ULONG                           MediaDisconnectTimeOut = (ULONG)-1;
#endif
    HANDLE                          Handle;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    NDIS_INTERFACE_TYPE             BusType = Isa;
    UINT                            BusNumber = 0;
    ULONG                           ResultLength;
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;
    GUID                            BusTypeGuid;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisInitializeConfiguration: Miniport %p\n", Miniport));
        
    CnfgHandle.ParameterList = NULL;
    
    do
    {
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

        if (Miniport->BindPaths == NULL)
        {
            NdisStatus = ndisReadBindPaths(Miniport, LQueryTable);
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        if (pExportName != NULL)
        {
            //
            // get a handle to "driver" section for PDO
            //
#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
            Handle = NULL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_READ | MAXIMUM_ALLOWED,
                                                     &Handle);
#endif

#if !NDIS_NO_REGISTRY
            if (!NT_SUCCESS(RegistryStatus))
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }
            
            //
            // Set up LQueryTable to do the following:
            //
        
            //
            // 1. Switch to the Linkage key below this driver instance key
            //
            LQueryTable[0].QueryRoutine = NULL;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
            LQueryTable[0].Name = L"Linkage";
        
            //
            // 2. Call ndisReadParameter for "Export" (as a single multi-string)
            //    which will allocate storage and save the data in Export.
            //
            LQueryTable[1].QueryRoutine = ndisReadParameter;
            LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[1].Name = L"Export";
            LQueryTable[1].EntryContext = (PVOID)&Export;
            LQueryTable[1].DefaultType = REG_NONE;
        
            //
            // 3. Stop
            //
            LQueryTable[2].QueryRoutine = NULL;
            LQueryTable[2].Flags = 0;
            LQueryTable[2].Name = NULL;
            
            RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                    Handle,
                                                    LQueryTable,
                                                    (PVOID)NULL,      // no context needed
                                                    NULL);

            ZwClose(Handle);
                
            if (!NT_SUCCESS(RegistryStatus))
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                        ("ndisInitializeConfiguration: Could not read Bind/Export for %Z: %lx\n",
                        &Miniport->BaseName,
                        RegistryStatus));

                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }
#else
            if (NT_SUCCESS(RegistryStatus))
            {
            
                //
                // Set up LQueryTable to do the following:
                //
            
                //
                // 1. Switch to the Linkage key below this driver instance key
                //
                LQueryTable[0].QueryRoutine = NULL;
                LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
                LQueryTable[0].Name = L"Linkage";
            
                //
                // 2. Call ndisReadParameter for "Export" (as a single multi-string)
                //    which will allocate storage and save the data in Export.
                //
                LQueryTable[1].QueryRoutine = ndisReadParameter;
                LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                LQueryTable[1].Name = L"Export";
                LQueryTable[1].EntryContext = (PVOID)&Export;
                LQueryTable[1].DefaultType = REG_NONE;
            
                //
                // 3. Stop
                //
                LQueryTable[2].QueryRoutine = NULL;
                LQueryTable[2].Flags = 0;
                LQueryTable[2].Name = NULL;
                
                RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                        Handle,
                                                        LQueryTable,
                                                        (PVOID)NULL,      // no context needed
                                                        NULL);

                ZwClose(Handle);
                    
                if (!NT_SUCCESS(RegistryStatus))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("ndisInitializeConfiguration: Could not read Bind/Export for %Z: %lx\n",
                            &Miniport->BaseName,
                            RegistryStatus));

                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
                }
            }
            else
            {
                //
                // we have to allocate space for default export name because the
                // caller will attempt to free it
                //

                Export = (PWSTR)ALLOC_FROM_POOL(sizeof(NDIS_DEFAULT_EXPORT_NAME),
                                                                NDIS_TAG_NAME_BUF);
                if (Export == NULL)
                {
                    NdisStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory(Export, ndisDefaultExportName, sizeof(NDIS_DEFAULT_EXPORT_NAME));
                
            
            }
#endif
            RtlInitUnicodeString(pExportName, Export);
        }   
        //
        // NdisReadConfiguration assumes that ParametersQueryTable[3].Name is
        // a key below the services key where the Parameters should be read,
        // for layered drivers we store the last piece of Configuration
        // Path there, leading to the desired effect.
        //
        // I.e, ConfigurationPath == "...\Services\Driver".
        //
        
        //
        // 1) Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // The following fields are filled in during NdisReadConfiguration
        //
        // PQueryTable[1].Name = KeywordBuffer;
        // PQueryTable[1].EntryContext = ParameterValue;
        
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;
    
        //
        // 2. Stop
        //
        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;
    
        //
        // NOTE: Some fields in ParametersQueryTable[3 & 4] are used to
        // store information for later retrieval.
        // Save Adapter/Miniport block here. Later on, Adapter's PDO
        // will be used to open the appropiate registry key
        //
        (PVOID)PQueryTable[3].QueryRoutine = (PVOID)Miniport;
        PQueryTable[3].Name = L"";
        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;
            
        
        // Now read bustype/busnumber for this adapter and save it
        CnfgHandle.KeyQueryTable = PQueryTable;

        RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                             DevicePropertyBusTypeGuid,
                                             sizeof(GUID),
                                             (PVOID)&BusTypeGuid,
                                             &ResultLength);
        
        //
        // try to get the -real- bus type by first querying the bustype guid
        // if we couldn't get the guid, try to get a legacy bustype. because
        // some bus drivers like pcmcia do not report the real bus type, we 
        // have to query the bus type guid first.
        // 

        if (NT_SUCCESS(RegistryStatus))
        {
            if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_INTERNAL, sizeof(GUID)))
                BusType = Internal;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_PCMCIA, sizeof(GUID)))
                BusType = PCMCIABus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID)))
                BusType = PCIBus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_ISAPNP, sizeof(GUID)))
                BusType = PNPISABus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_EISA, sizeof(GUID)))
            {
                BusType = Eisa;
                ASSERT(BusType != Eisa);
            }
            else
                BusType = Isa;
        }
        
        if (BusType == Isa)
        {
            //
            // either the call to get BusTypeGuid failed or the returned guid
            // does not match any that we know of
            //
            RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                                 DevicePropertyLegacyBusType,
                                                 sizeof(UINT),
                                                 (PVOID)&BusType,
                                                 &ResultLength);
        }

        
        if (!NT_SUCCESS(RegistryStatus) 
            || (BusType == Isa)
            || (BusType == PCMCIABus))
        {

            if (NT_SUCCESS(RegistryStatus))
            {
                ASSERT(BusType != Isa);
            }
            
            //
            // if the call was unsuccessful or BusType is ISA or PCMCIABus
            // read BusType from registry
            //
            NdisReadConfiguration(&NdisStatus,
                                  &ReturnedValue,
                                  &CnfgHandle,
                                  &BusTypeStr,
                                  NdisParameterInteger);
                                  
            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                BusType = (NDIS_INTERFACE_TYPE)(ReturnedValue->ParameterData.IntegerData);
            }
        }
        
        if ((BusType == PCIBus) ||
            (BusType == PCMCIABus))
        {               
            ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
            NdisStatus = ndisQueryBusInterface(Miniport);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                ASSERT(FALSE);
                break;
            }
        }

        if ((BusType == Eisa) ||
            (BusType == MicroChannel))
        {
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED; 
            break;
        }

        Miniport->BusType = BusType;
        
        //
        // Read PnP capabilities. By default the WOL feature should be disabled
        // 
        //
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &PnPCapsStr,
                              NdisParameterInteger);
    
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->PnPCapabilities = ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->PnPCapabilities =  NDIS_DEVICE_DISABLE_WAKE_UP;
                                                               
        }


        //
        // try to get the bus number from PnP and if it fails
        // try reading it from registry
        //
        RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                             DevicePropertyBusNumber,
                                             sizeof(UINT),
                                             (PVOID)&BusNumber,
                                             &ResultLength);
                                
        if (!NT_SUCCESS(RegistryStatus))
        {
            //
            // if the call was unsuccessful
            // Read Bus Number from registry
            //
            NdisReadConfiguration(&NdisStatus,
                                  &ReturnedValue,
                                  &CnfgHandle,
                                  &BusNumberStr,
                                  NdisParameterInteger);
        
            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                BusNumber = ReturnedValue->ParameterData.IntegerData;
            }
        }
        
        Miniport->BusNumber = BusNumber;
        
        //
        // Read Slot Number
        //
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &SlotNumberStr,
                              NdisParameterInteger);
    
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->SlotNumber = ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->SlotNumber = (ULONG)-1;
        }

        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &RemoteBootStr,
                              NdisParameterHexInteger);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            if (ReturnedValue->ParameterData.IntegerData != 0)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_NETBOOT_CARD);
                Miniport->InfoFlags |= NDIS_MINIPORT_NETBOOT_CARD;
            }
        }

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
        //1  for .NET this is not supported, it should be ifdef'ed out
        //
        // read the value for media disconnect timer, set to 20 seconds if not present
        // default=disable pm when cable is disconnected
        //
        MediaDisconnectTimeOut = (ULONG)-1;
        
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &MediaDisconnectTimeOutStr,
                              NdisParameterHexInteger);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            MediaDisconnectTimeOut = ReturnedValue->ParameterData.IntegerData;
            if (MediaDisconnectTimeOut == 0)
            {
                MediaDisconnectTimeOut = 1;
            }
        }
        
        Miniport->MediaDisconnectTimeOut = (USHORT)MediaDisconnectTimeOut;
        
        if (MediaDisconnectTimeOut == (ULONG)(-1))
        {
            Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT;
        }
#else
        Miniport->MediaDisconnectTimeOut = (USHORT)-1;
        Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT;
#endif

        //1 this (media polling) is not needed any more.
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &PollMediaConnectivityStr,
                              NdisParameterInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            //
            // This miniport wants Ndis to poll it regularly for media connectivity. 
            // Default value is FALSE for this flag. This flag will be cleared if miniport
            // can indicate media status or does not support media query
            //
            if (ReturnedValue->ParameterData.IntegerData == 1)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            }
        }

        //1 check for range
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &SGMapRegistersNeededStr,
                              NdisParameterInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->SGMapRegistersNeeded = (USHORT)ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->SGMapRegistersNeeded = NDIS_MAXIMUM_SCATTER_GATHER_SEGMENTS;
        }

        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &NdisDriverVerifyFlagsStr,
                              NdisParameterHexInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->DriverVerifyFlags = ReturnedValue->ParameterData.IntegerData;
        }


        PQueryTable[3].DefaultData = NULL;
        PQueryTable[3].Flags = 0;

        NdisStatus = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    //
    // free NDIS_CONFIGURATION_PARAMETER_QUEUE nodes hanging from CnfgHandle
    //
    ParameterNode = CnfgHandle.ParameterList;

    while (ParameterNode != NULL)
    {
        CnfgHandle.ParameterList = ParameterNode->Next;

        FREE_POOL(ParameterNode);

        ParameterNode = CnfgHandle.ParameterList;
    }

#undef  PQueryTable
#undef  LQueryTable

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisInitializeConfiguration: Miniport %p\n", Miniport));

    return(NdisStatus);
}


NTSTATUS
ndisReadBindPaths(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PRTL_QUERY_REGISTRY_TABLE   LQueryTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS                NtStatus;
    HANDLE                  Handle = NULL;
    PWSTR                   pPath, p, BindPathData = NULL;
    UINT                    i, Len, NumComponents;
    BOOLEAN                 FreeBindPathData = FALSE;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReadBindPaths: Miniport %p\n", Miniport));

    do
    {
#if NDIS_TEST_REG_FAILURE
        NtStatus = STATUS_UNSUCCESSFUL;
#else

        NtStatus = IoOpenDeviceRegistryKey(Miniport->PhysicalDeviceObject,
                                           PLUGPLAY_REGKEY_DRIVER,
                                           GENERIC_READ | MAXIMUM_ALLOWED,
                                           &Handle);
#endif

#if !NDIS_NO_REGISTRY

        if (!NT_SUCCESS(NtStatus))
            break;

        //
        // 1.
        // Switch to the Linkage key below this driver instance key
        //
        LQueryTable[0].QueryRoutine = NULL;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LQueryTable[0].Name = L"Linkage";

        //
        // 2.
        // Read the RootDevice keywords
        //
        LQueryTable[1].QueryRoutine = ndisReadParameter;
        LQueryTable[1].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[1].Name = L"RootDevice";
        LQueryTable[1].EntryContext = (PVOID)&BindPathData;
        LQueryTable[1].DefaultType = REG_NONE;

        LQueryTable[2].QueryRoutine = NULL;
        LQueryTable[2].Flags = 0;
        LQueryTable[2].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          NULL,
                                          NULL);
        ZwClose(Handle);

        if (!NT_SUCCESS(NtStatus))
        {
            break;
        }

#else
        if (NT_SUCCESS(NtStatus))
        {
            //
            // 1.
            // Switch to the Linkage key below this driver instance key
            //
            LQueryTable[0].QueryRoutine = NULL;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
            LQueryTable[0].Name = L"Linkage";

            //
            // 2.
            // Read the RootDevice keywords
            //
            LQueryTable[1].QueryRoutine = ndisReadParameter;
            LQueryTable[1].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[1].Name = L"RootDevice";
            LQueryTable[1].EntryContext = (PVOID)&BindPathData;
            LQueryTable[1].DefaultType = REG_NONE;

            LQueryTable[2].QueryRoutine = NULL;
            LQueryTable[2].Flags = 0;
            LQueryTable[2].Name = NULL;

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                              Handle,
                                              LQueryTable,
                                              NULL,
                                              NULL);
            ZwClose(Handle);

            if (!NT_SUCCESS(NtStatus))
                break;
        }
        else
        {
            NtStatus = STATUS_SUCCESS;
        }
#endif
        //
        // BindPath is a MULTI-SZ which starts at the top of the filter chain
        // and goes down to the miniport. It is of the form
        //
        // {FN} {FN-1} ... {F1} {Adapter}
        //
        // Where spaces are actually nulls and each of {Fn} is a filter instance.
        //
        if (BindPathData == NULL)
        {
            BindPathData = Miniport->BaseName.Buffer;
        }
        else
        {
            FreeBindPathData = TRUE;
        }

        //
        // Split bindpath into individual components. Start by determining how much
        // space we need.
        //
        Len = sizeof(NDIS_BIND_PATHS);
        for (pPath = BindPathData, NumComponents = 0; *pPath != 0; NOTHING)
        {
            NDIS_STRING us;

            RtlInitUnicodeString(&us, pPath);
            NumComponents++;
            Len += sizeof(NDIS_STRING) + us.Length + ndisDeviceStr.Length + sizeof(WCHAR);
            (PUCHAR)pPath += (us.Length + sizeof(WCHAR));
        }

        //
        // Allocate space for bindpaths. We have NumComponents paths
        // which consume Len bytes of space. We could be re-initialzing
        // so free any previous buffer allcoated for this.
        //
        if (Miniport->BindPaths != NULL)
        {
            FREE_POOL(Miniport->BindPaths);
        }
        Miniport->BindPaths = (PNDIS_BIND_PATHS)ALLOC_FROM_POOL(Len,
                                                                NDIS_TAG_NAME_BUF);
        if (Miniport->BindPaths == NULL)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ZeroMemory(Miniport->BindPaths, Len);
        Miniport->BindPaths->Number = NumComponents;

        if (NumComponents > 1)
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_FILTER_IM);
            Miniport->InfoFlags |= NDIS_MINIPORT_FILTER_IM;
        }

        //
        // Create an array in reverse order of device-names in the filter path.
        //
        p = (PWSTR)((PUCHAR)Miniport->BindPaths +
                            sizeof(NDIS_BIND_PATHS) +
                            NumComponents*sizeof(NDIS_STRING));

        for (pPath = BindPathData, i = (NumComponents-1);
             *pPath != 0;
             i --)
        {
            NDIS_STRING Str, SubStr, *Bp;

            RtlInitUnicodeString(&Str, pPath);
            (PUCHAR)pPath += (Str.Length + sizeof(WCHAR));

            Bp = &Miniport->BindPaths->Paths[i];
            Bp->Buffer = p;
            Bp->Length = 0;
            Bp->MaximumLength = Str.Length + ndisDeviceStr.Length + sizeof(WCHAR);

            SubStr.Buffer = (PWSTR)((PUCHAR)p + ndisDeviceStr.Length);
            SubStr.MaximumLength = Str.Length + sizeof(WCHAR);
            SubStr.Length = 0;
            RtlCopyUnicodeString(Bp, &ndisDeviceStr);

            RtlUpcaseUnicodeString(&SubStr,
                                   &Str,
                                   FALSE);
            Bp->Length += SubStr.Length;
            (PUCHAR)p += Bp->MaximumLength;
        }
    } while (FALSE);

    if (FreeBindPathData)
        FREE_POOL(BindPathData);
                        ;
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReadBindPaths: Miniport %p\n", Miniport));

    return NtStatus;
}


NTSTATUS
ndisCreateAdapterInstanceName(
    OUT PUNICODE_STRING *       pAdapterInstanceName,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    )
{
    NTSTATUS                        NtStatus, SlotQueryStatus;
    DEVICE_REGISTRY_PROPERTY        Property;
    PWCHAR                          pValueInfo = NULL;
    ULONG                           ResultLength = 0;
    PUNICODE_STRING                 AdapterInstanceName = NULL;
    ULONG                           SlotNumber;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisCreateAdapterInstanceName: PDO %p\n", PhysicalDeviceObject));

    do
    {        
        //1 add comments and check to see if the DevicePropertyFriendlyName should always be there.
        *pAdapterInstanceName = NULL;
        Property = DevicePropertyFriendlyName;
        NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                       Property,
                                       0,
                                       NULL,
                                       &ResultLength);

        if ((NtStatus != STATUS_BUFFER_TOO_SMALL) && !NT_SUCCESS(NtStatus))
        {
            Property = DevicePropertyDeviceDescription;
            NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                           Property,
                                           0,
                                           NULL,
                                           &ResultLength);
            if ((NtStatus != STATUS_BUFFER_TOO_SMALL) && !NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisCreateAdapterInstanceName: PDO %p, Failed to query the adapter description\n", PhysicalDeviceObject));

                break;
            }
        }
        


        //
        //  Allocate space to hold the partial value information.
        //
        pValueInfo = ALLOC_FROM_POOL(ResultLength, NDIS_TAG_DEFAULT);
        if (NULL == pValueInfo)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to allocate storage for the adapter description\n", PhysicalDeviceObject));

            break;
        }

        RtlZeroMemory(pValueInfo, ResultLength);

        NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                        Property,
                                        ResultLength,
                                        pValueInfo,
                                        &ResultLength);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to query the adapter description\n", PhysicalDeviceObject));
            break;
        }
        
        //
        //  Determine the size of the instance name buffer. This is a UNICODE_STRING
        //  and it's associated buffer.
        //
        ResultLength += sizeof(UNICODE_STRING);

        //
        //  Allocate the buffer.
        //
        AdapterInstanceName = ALLOC_FROM_POOL(ResultLength, NDIS_TAG_NAME_BUF);
        if (NULL == AdapterInstanceName)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to allocate storage for the adapter instance name\n", PhysicalDeviceObject));
            break;
        }

        //
        //  Initialize the buffer.
        //
        RtlZeroMemory(AdapterInstanceName, ResultLength);

        //
        //  Initialize the UNICODE_STRING for the instance name.
        //
        AdapterInstanceName->Buffer = (PWSTR)((PUCHAR)AdapterInstanceName + sizeof(UNICODE_STRING));
        AdapterInstanceName->Length = 0;
        AdapterInstanceName->MaximumLength = (USHORT)(ResultLength - sizeof(UNICODE_STRING));

        RtlAppendUnicodeToString(AdapterInstanceName, pValueInfo);
    
        DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisCreateAdapterInstanceName: %ws\n", AdapterInstanceName->Buffer));


        //
        //  Return the instance name.
        //
        *pAdapterInstanceName = AdapterInstanceName;

        //1 this should be in checked builds only.
        //
        // get the slot number
        //
        Property = DevicePropertyUINumber;
        SlotQueryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                       Property,
                                       sizeof (ULONG),
                                       &SlotNumber,
                                       &ResultLength);
        if (NT_SUCCESS(SlotQueryStatus))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisCreateAdapterInstanceName: %ws, Slot Number: %ld\n", 
                  AdapterInstanceName->Buffer, 
                  SlotNumber));
        }
        else
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisCreateAdapterInstanceName: couldn't get SlotNumber for %ws\n", 
                  AdapterInstanceName->Buffer));
        }


    } while (FALSE);

    if (NULL != pValueInfo)
        FREE_POOL(pValueInfo);

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisCreateAdapterInstanceName: PDO %p, Status 0x%x\n", PhysicalDeviceObject, NtStatus));

    return(NtStatus);
}

NDIS_STATUS
ndisInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK    pMiniBlock,
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PUNICODE_STRING         InstanceName,
    IN  NDIS_HANDLE             DeviceContext   OPTIONAL
    )
{
    NDIS_WRAPPER_CONFIGURATION_HANDLE   ConfigurationHandle;
    NDIS_STATUS                         NdisStatus;
    UNICODE_STRING                      ExportName;
    PNDIS_MINIPORT_BLOCK                Miniport= (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    TIME                                TS, TE, TD;
    
#define PQueryTable ConfigurationHandle.ParametersQueryTable
#define Db          ConfigurationHandle.Db

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisInitializeAdapter: Miniport/Adapter %p\n", Miniport));

    do
    {
        ZeroMemory(&ConfigurationHandle, sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        ExportName.Buffer = NULL;

        //
        //  Build the configuration handle.
        //
        NdisStatus = ndisInitializeConfiguration(&ConfigurationHandle,
                                                 Miniport,
                                                 &ExportName);
                        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // OK, Now lock down all the filter packages.  If a MAC or
        // Miniport driver uses any of these, then the filter package
        // will reference itself, to keep the image in memory.
        //
#if ARCNET
        ArcReferencePackage();
#endif
        EthReferencePackage();
        FddiReferencePackage();
        TrReferencePackage();
        MiniportReferencePackage();
        CoReferencePackage();

        ConfigurationHandle.DeviceObject = DeviceObject;
        ConfigurationHandle.DriverBaseName = InstanceName;

        KeQuerySystemTime(&TS);

        //
        //  Save the Driver Object with the configuration handle.
        //
        ConfigurationHandle.DriverObject = pMiniBlock->NdisDriverInfo->DriverObject;
        NdisStatus = ndisMInitializeAdapter(pMiniBlock,
                                            &ConfigurationHandle,
                                            &ExportName,
                                            DeviceContext);
                                    
        KeQuerySystemTime(&TE);
        TD.QuadPart = TE.QuadPart - TS.QuadPart;
        TD.QuadPart /= 10000;       // Convert to ms
        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)(ConfigurationHandle.DeviceObject->DeviceExtension) + 1);
        Miniport->InitTimeMs = TD.LowPart;

        if (ndisFlags & NDIS_GFLAG_INIT_TIME)
        {
            DbgPrint("NDIS: Init time (%Z) %ld ms\n", Miniport->pAdapterInstanceName, Miniport->InitTimeMs);
        }

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            ndisCloseULongRef(&Miniport->Ref);
        }

        //
        // OK, Now dereference all the filter packages.  If a MAC or
        // Miniport driver uses any of these, then the filter package
        // will reference itself, to keep the image in memory.
        //
#if ARCNET
        ArcDereferencePackage();
#endif
        EthDereferencePackage();
        FddiDereferencePackage();
        TrDereferencePackage();
        MiniportDereferencePackage();
        CoDereferencePackage();

    } while (FALSE);

    if (ExportName.Buffer)
        FREE_POOL(ExportName.Buffer);

    //
    // free "Bind" data
    //
    if (PQueryTable[3].EntryContext != NULL)
        FREE_POOL(PQueryTable[3].EntryContext);
    
#undef  PQueryTable
#undef  Db

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisInitializeAdapter: Miniport/Adapter %p\n", Miniport));

    return(NdisStatus);
}


VOID
FASTCALL
ndisCheckAdapterBindings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol    OPTIONAL
    )
/*+++

Routine Description:

    This function, reads the registry to get all the protocols that are supposed 
    to bind to this adapter and for each protocol, calls ndisInitializeBinding

Arguments:

    Adapter     Pointer to ndis Adpater or Miniport block
    Protocol    Optionally if a protocol is specified, initiate binding to only
                that protocol
    
Return Value:
    None

---*/
{
    RTL_QUERY_REGISTRY_TABLE    LinkQueryTable[3];
    NTSTATUS                    RegistryStatus;
    PWSTR                       UpperBind = NULL;
    HANDLE                      Handle;
    PDEVICE_OBJECT              PhysicalDeviceObject;
    UNICODE_STRING              Us;
    PWSTR                       CurProtocolName;
    PNDIS_PROTOCOL_BLOCK        CurProtocol, NextProtocol;
    KIRQL                       OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("==>ndisCheckAdapterBindings: Miniport %p, Protocol %p\n", Miniport, Protocol));


    do
    {        
        //
        // get a handle to driver section in registry
        //
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY))
        {
            //
            // Skip bind notifications for a secondary miniport
            //
            break;
        }

#if NDIS_TEST_REG_FAILURE
        RegistryStatus = STATUS_UNSUCCESSFUL;
        Handle = NULL;
#else

        RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                 PLUGPLAY_REGKEY_DRIVER,
                                                 GENERIC_READ | MAXIMUM_ALLOWED,
                                                 &Handle);
                                                 
#endif

#if NDIS_NO_REGISTRY
        if (!NT_SUCCESS(RegistryStatus))
        {
            if (ARGUMENT_PRESENT(Protocol))
            {
                ndisInitializeBinding(Miniport, Protocol);
                break;
            }
            else
            {
                ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
                for (CurProtocol = ndisProtocolList;
                     CurProtocol != NULL;
                     CurProtocol = NextProtocol)
                {
                    if (ndisReferenceProtocol(CurProtocol))
                    {

                        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
                        ndisInitializeBinding(Miniport, CurProtocol);
                        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
                        NextProtocol = CurProtocol->NextProtocol;
                        ndisDereferenceProtocol(CurProtocol, TRUE);
                    }
                    else
                    {
                        NextProtocol = CurProtocol->NextProtocol;
                    }
                }
                RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
             }
            
            break;
        }
#else
        if (!NT_SUCCESS(RegistryStatus))
        {
            break;
        }
#endif
        //
        // Set up LinkQueryTable to do the following:
        //

        //
        // 1) Switch to the Linkage key below the xports registry key
        //

        LinkQueryTable[0].QueryRoutine = NULL;
        LinkQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LinkQueryTable[0].Name = L"Linkage";

        //
        // 2) Call ndisReadParameter for "UpperBind" (as a single multi-string),
        // which will allocate storage and save the data in UpperBind.
        //

        LinkQueryTable[1].QueryRoutine = ndisReadParameter;
        LinkQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        LinkQueryTable[1].Name = L"UpperBind";
        LinkQueryTable[1].EntryContext = (PVOID)&UpperBind;
        LinkQueryTable[1].DefaultType = REG_NONE;

        //
        // 3) Stop
        //

        LinkQueryTable[2].QueryRoutine = NULL;
        LinkQueryTable[2].Flags = 0;
        LinkQueryTable[2].Name = NULL;

        RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                Handle,
                                                LinkQueryTable,
                                                (PVOID)NULL,      // no context needed
                                                NULL);
        ZwClose(Handle);
        
        if (NT_SUCCESS(RegistryStatus))
        {
            for (CurProtocolName = UpperBind;
                 *CurProtocolName != 0;
                 CurProtocolName = (PWCHAR)((PUCHAR)CurProtocolName + Us.MaximumLength))
            {
                RtlInitUnicodeString (&Us, CurProtocolName);
    
                if (ARGUMENT_PRESENT(Protocol))
                {
                    if (RtlEqualUnicodeString(&Us, &Protocol->ProtocolCharacteristics.Name, TRUE))
                    {
                        ndisInitializeBinding(Miniport, Protocol);
                        break;
                    }
                }
                else
                {
                    CurProtocol = NULL;
                    
                    if (ndisReferenceProtocolByName(&Us, &CurProtocol, FALSE) == NDIS_STATUS_SUCCESS)
                    {
                        ndisInitializeBinding(Miniport, CurProtocol);
                        ndisDereferenceProtocol(CurProtocol, FALSE);
                    }
                }
            }
        }
        
        //
        // Handle proxy and rca filters.
        //
        
        if ((Miniport != NULL) &&
            !ndisMediaTypeCl[Miniport->MediaType] &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            BOOLEAN bCanMiniportBindtoAllCoProtocol = FALSE;
            if (ARGUMENT_PRESENT(Protocol))
            {

                //
                // Only create the binding between the bind_all_Co protocol if the miniport
                // does not veto it
                //
                bCanMiniportBindtoAllCoProtocol  =  \
                    ((Protocol->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_BIND_ALL_CO) && 
                     (!(Miniport->MiniportAttributes & NDIS_ATTRIBUTE_DO_NOT_BIND_TO_ALL_CO )));
                     
                if (bCanMiniportBindtoAllCoProtocol) 
                {
                    ndisInitializeBinding(Miniport, Protocol);
                }
            }
            else
            {
                ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
                for (CurProtocol = ndisProtocolList;
                     CurProtocol != NULL;
                     CurProtocol = NextProtocol)
                {
                    bCanMiniportBindtoAllCoProtocol  =  \
                    ((CurProtocol ->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_BIND_ALL_CO) && 
                     (!(Miniport->MiniportAttributes & NDIS_ATTRIBUTE_DO_NOT_BIND_TO_ALL_CO )));

                    
                    if (bCanMiniportBindtoAllCoProtocol && 
                        ndisReferenceProtocol(CurProtocol))
                    {
                        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
                        ndisInitializeBinding(Miniport, CurProtocol);
                        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
                        NextProtocol = CurProtocol->NextProtocol;
                        ndisDereferenceProtocol(CurProtocol, TRUE);
                    }
                    else
                    {
                        NextProtocol = CurProtocol->NextProtocol;
                    }
                    
                }
                RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
             }
        }
    } while (FALSE);                    

    if (UpperBind != NULL)
        FREE_POOL(UpperBind);
        
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("<==ndisCheckAdapterBindings: Miniport %p, Protocol %p\n", Miniport, Protocol));
}

BOOLEAN
FASTCALL
ndisProtocolAlreadyBound(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    )
{
    PNDIS_OPEN_BLOCK    pOpen;
    BOOLEAN             rc = FALSE;
    KIRQL               OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisProtocolAlreadyBound: Protocol %p, Miniport %p\n", Protocol, Miniport));
            
    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    for (pOpen = Protocol->OpenQueue;
         pOpen != NULL;
         pOpen = pOpen->ProtocolNextOpen)
    {
        if (pOpen->MiniportHandle == Miniport)
        {
            rc = TRUE;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisProtocolAlreadyBound: Protocol %p, Miniport %p\n", Protocol, Miniport));
            
    return rc;
}


NDIS_STATUS
NdisIMInitializeDeviceInstance(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance
    )
/*++

Routine Description:

    Initialize an instance of a miniport device.

Arguments:

    DriverHandle -  Handle returned by NdisMRegisterLayeredMiniport.
                    It is a pointer to NDIS_M_DRIVER_BLOCK.
    DeviceInstance -Points to the instance of the driver that must now
                    be initialized.

Return Value:


--*/
{
    NDIS_STATUS Status;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));
            
    Status = NdisIMInitializeDeviceInstanceEx(DriverHandle, DeviceInstance, NULL);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));
            
    return Status;
}


NDIS_STATUS
NdisIMInitializeDeviceInstanceEx(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance,
    IN  NDIS_HANDLE     DeviceContext
    )
/*++

Routine Description:

    Initialize an instance of a miniport device. Incarnation of NdisIMInitializeDeviceInstance.

Arguments:

    DriverHandle    Handle returned by NdisMRegisterLayeredMiniport.
                    It is a pointer to NDIS_M_DRIVER_BLOCK.
    DeviceInstance  Points to the instance of the driver that must now
                    be initialized.
    DeviceContext   Context to associate with the device. Retrieved via NdisIMGetDeviceContext.

Return Value:


--*/
{
    NDIS_STATUS                     Status;
    PNDIS_M_DRIVER_BLOCK            MiniBlock = (PNDIS_M_DRIVER_BLOCK)DriverHandle;
    PNDIS_MINIPORT_BLOCK            Miniport;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMInitializeDeviceInstanceEx: Driver %p, Instance %p, Context %p\n",
                    DriverHandle, DeviceInstance, DeviceContext));

    PnPReferencePackage();
    
    WAIT_FOR_OBJECT(&MiniBlock->IMStartRemoveMutex, NULL);
    
    do
    {
        Miniport = ndisFindMiniportOnGlobalList(DeviceInstance);
        //1 we need some protection so miniport does not go away. (Should ref the miniport)
        
        if (Miniport != NULL)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_RECEIVED_START) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        ("NdisIMInitializeDeviceInstanceEx: we have already received START_IRP for Miniport %p\n",
                        Miniport));

                //
                // check to make sure the miniport has not been initialized already
                // i.e. we are not getting duplicate NdisIMInitializeDeviceInstance 
                // a device that has already been initialized
                //
                
                if (ndisIsMiniportStarted(Miniport))
                {
                    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("NdisIMInitializeDeviceInstanceEx: we have already initialized this device. Miniport %p\n",
                            Miniport));
                            
                    Status = NDIS_STATUS_NOT_ACCEPTED;
                    break;
                }
                
                Status = ndisIMInitializeDeviceInstance(Miniport,
                                                        DeviceContext,
                                                        FALSE);
                                
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    //
                    // since we have already succeeded the START_IRP, signal PnP to remove this device
                    // by tagging the device as failed and requesting a QUERY_PNP_DEVICE_STATE IRP
                    //
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
                    IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
                }

                break;
            }
        }

        //
        // device is not started or not added yet.
        //
        Status = ndisIMQueueDeviceInstance(DriverHandle,
                                   DeviceInstance,
                                   DeviceContext);

    } while (FALSE);

    RELEASE_MUTEX(&MiniBlock->IMStartRemoveMutex);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==NdisIMInitializeDeviceInstanceEx: Driver %p, Instance %p, Context %p, Status %lx\n",
                DriverHandle, DeviceInstance, DeviceContext, Status));


    return Status;
}

NDIS_STATUS
ndisIMInitializeDeviceInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_HANDLE             DeviceContext,
    IN  BOOLEAN                 fStartIrp
    )
/*++

Routine Description:

    This routine is called when we have received NdisIMInitializeDeviceInstance
    -AND- START IRP for an IM miniport.
    Initialize an instance of a miniport device.

Arguments:

    Miniport        Handle to NDIS_MINIPORT_BLOCK
    
    DeviceContext   Context to associate with the device. Retrieved via NdisIMGetDeviceContext.

    fStartIrp       flag to signal if we are in the context of handling START IRP
    
Return Value:


--*/
{
    NDIS_STATUS         Status;
    NTSTATUS            NtStatus;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisIMInitializeDeviceInstance: Miniport %p, Context %p, fStartIrp %lx\n", Miniport, DeviceContext, fStartIrp));
    

    //
    // it is quite possible we are dealing with a miniport block that has been "used"
    // several times. inother words, it has been started and DeviceInitialized, then
    // Device-De-Initialized and then has received a few query_stop and cancel_stop.
    // in this case the miniport block has to be cleaned up. otherwise, ndisPnPStartDevice
    // is not going to detect that miniport block needs re-initalization
    //
    ndisReinitializeMiniportBlock(Miniport);
    

    Miniport->DeviceContext = DeviceContext;
    
    Status = ndisPnPStartDevice(Miniport->DeviceObject, NULL);          // no Irp

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // if we are in the context of start IRP, queue a workitem to initialize
        // the bindings on this adapter to avoid the delay
        //
        if (!fStartIrp)
        {
            //
            //  Now set the device class association so that people can reference this.
            //
            NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);

            if (NT_SUCCESS(NtStatus))
            {
                //
                // Do protocol notifications
                //
                ndisCheckAdapterBindings(Miniport, NULL);
            }
            else
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisCheckAdapterBindings: IoSetDeviceInterfaceState failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
                Status = NDIS_STATUS_FAILURE;
                
            }
        }
        else
        {
            Status = ndisQueueBindWorkitem(Miniport);
        }
    }
    else
    {
        //
        // ndisPnPStartDevice can return an internal Error Code if the call 
        // to ndisMInitializeAdapter fails. convert this to NDIS_STATUS
        //
        Status = NDIS_STATUS_FAILURE;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisIMInitializeDeviceInstance: Miniport %p, Context %p, Status %lx\n", Miniport, DeviceContext, Status));

    return Status;
}

NDIS_STATUS
ndisIMQueueDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  PNDIS_STRING            DeviceInstance,
    IN  NDIS_HANDLE             DeviceContext
    )
{
    NDIS_STATUS                     Status = NDIS_STATUS_SUCCESS;
    PNDIS_PENDING_IM_INSTANCE       NewImInstance, pTemp;
    KIRQL                           OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("==>ndisIMQueueDeviceInstance: Driver %p, Instance %p, Context %p\n",
                MiniBlock, DeviceInstance, DeviceContext));

    do
    {
        //
        // Queue the device name for which we have received an InitializeDeviceInstance
        // from an IM driver. Check for duplicates.
        //
        NewImInstance = (PNDIS_PENDING_IM_INSTANCE)ALLOC_FROM_POOL(sizeof(NDIS_PENDING_IM_INSTANCE) + 
                                                                       DeviceInstance->Length + 
                                                                       sizeof(WCHAR), 
                                                                   NDIS_TAG_IM_DEVICE_INSTANCE);
        if (NULL == NewImInstance)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NewImInstance->Context = DeviceContext;
        NewImInstance->Name.MaximumLength = DeviceInstance->Length + sizeof(WCHAR);
        NewImInstance->Name.Length = 0;
        NewImInstance->Name.Buffer = (PWSTR)((PUCHAR)NewImInstance + sizeof(NDIS_PENDING_IM_INSTANCE));
        
        RtlUpcaseUnicodeString(&NewImInstance->Name,
                               DeviceInstance,
                               FALSE);
        
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        for (pTemp = MiniBlock->PendingDeviceList;
             pTemp != NULL;
             pTemp = pTemp->Next)
        {
            if (NDIS_EQUAL_UNICODE_STRING(&NewImInstance->Name,
                                          &pTemp->Name))
            {
                FREE_POOL(NewImInstance);
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
            }
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            NewImInstance->Next = MiniBlock->PendingDeviceList;
            MiniBlock->PendingDeviceList = NewImInstance;
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==ndisIMQueueDeviceInstance: Driver %p, Instance %p, Context %p, Status %lx\n",
                MiniBlock, DeviceInstance, DeviceContext, Status));

    return Status;
}


BOOLEAN
ndisIMCheckDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  PUNICODE_STRING         DeviceInstanceName,
    OUT PNDIS_HANDLE            DeviceContext   OPTIONAL
    )
{
    PNDIS_PENDING_IM_INSTANCE       pDI, *ppDI;
    PNDIS_PROTOCOL_BLOCK            Protocol = MiniBlock->AssociatedProtocol;
    KIRQL                           OldIrql;
    BOOLEAN                         rc = FALSE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("==>ndisIMCheckDeviceInstance: Driver %p, DeviceInstanceName %p\n",
                MiniBlock, DeviceInstanceName));

    PnPReferencePackage();
                    
    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    for (ppDI = &MiniBlock->PendingDeviceList;
         (pDI = *ppDI) != NULL;
         ppDI = &pDI->Next)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&pDI->Name,
                                      DeviceInstanceName))
        {
            if (ARGUMENT_PRESENT(DeviceContext))
            {
                *DeviceContext =  pDI->Context;
            }
            *ppDI = pDI->Next;
            FREE_POOL(pDI);
            rc = TRUE;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==ndisIMCheckDeviceInstance: Driver %p, Name %p, Context %p\n",
                MiniBlock, DeviceInstanceName, DeviceContext));
                    
    if (!rc && ARGUMENT_PRESENT(DeviceContext))
    {
        //
        // Send a reconfig notification to the protocol associated with this IM
        // so it can re-initialize any device(s) it wants to
        //
        if (((Protocol = MiniBlock->AssociatedProtocol) != NULL) &&
            (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL))
        {
            //
            // We got a start device for an IM. Make sure its protocol
            // half has all the requisite bindings. This can happen
            // if an IM is disconnected and reconnected, for example.
            // Also give it a NULL reconfig event. ATMLANE uses that
            //

            NET_PNP_EVENT           NetPnpEvent;
            KEVENT                  Event;
            NDIS_STATUS             Status;

            NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
            INITIALIZE_EVENT(&Event);
            NetPnpEvent.NetEvent = NetEventReconfigure;
            PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent)->pEvent = &Event;

            WAIT_FOR_PROTO_MUTEX(Protocol);

            Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(NULL, &NetPnpEvent);

            if (NDIS_STATUS_PENDING == Status)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
            }
    
            RELEASE_PROT_MUTEX(Protocol);
        }
    }

    return rc;
}

NDIS_STATUS
NdisIMCancelInitializeDeviceInstance(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance
    )
{
    NDIS_STATUS         Status;
    UNICODE_STRING      UpcaseDevice;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMCancelInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));

    //
    // change to upper case
    //

    UpcaseDevice.Length = DeviceInstance->Length;
    UpcaseDevice.MaximumLength = DeviceInstance->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    Status = RtlUpcaseUnicodeString(&UpcaseDevice, (PUNICODE_STRING)DeviceInstance, FALSE);
    ASSERT (NT_SUCCESS(Status));
            

    Status = (ndisIMCheckDeviceInstance((PNDIS_M_DRIVER_BLOCK)DriverHandle,
                                        &UpcaseDevice,
                                        NULL) == TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMCancelInitializeDeviceInstance: Driver %p, DeviceInstance %p, Status %lx\n",
                DriverHandle, DeviceInstance, Status));

    FREE_POOL(UpcaseDevice.Buffer);
    
    return Status;
}

NDIS_HANDLE
NdisIMGetDeviceContext(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMGetDeviceContext: Miniport %p\n", Miniport));

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMGetDeviceContext: Miniport %p\n", Miniport));
            
    return(Miniport->DeviceContext);
}


NDIS_HANDLE
NdisIMGetBindingContext(
    IN  NDIS_HANDLE             ProtocolBindingContext
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)ProtocolBindingContext;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMGetBindingContext: Open %p\n", Open));
            
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMGetBindingContext: Open %p\n", Open));
            
    return(Miniport->DeviceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\miniport.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS miniport wrapper functions

Author:

    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MINIPORT

NTSTATUS
ndisCompletionRoutine(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Pointer to an EVENT.

Return Value:

--*/
{
    PPOWER_QUERY    pQuery = Context;

    UNREFERENCED_PARAMETER(pdo);

    pQuery->Status = pirp->IoStatus.Status;
    SET_EVENT(&pQuery->Event);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NDIS_STATUS
ndisMInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK                pMiniBlock,
    IN  PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PUNICODE_STRING                     pExportName,
    IN  NDIS_HANDLE                         DeviceContext   OPTIONAL
    )
{
    FILTERDBS                   FilterDB = {0};
    PDEVICE_OBJECT              pTmpDevice = NULL;
    NTSTATUS                    NtStatus;
    LONG                        ErrorCode = 1;
    PNDIS_MINIPORT_BLOCK        Miniport = NULL;
    UNICODE_STRING              SymbolicLink;
    NDIS_STATUS                 MiniportInitializeStatus = NDIS_STATUS_SUCCESS;
    NDIS_STATUS                 OpenErrorStatus;
    NDIS_STATUS                 NdisStatus;
    NDIS_POWER_PROFILE          PowerProfile;
    ULONG                       GenericUlong = 0;
    PVOID                       DataBuffer, ArcnetDataBuffer;
    PNDIS_MINIPORT_WORK_ITEM    WorkItem;
    GUID                        guidLanClass = GUID_NDIS_LAN_CLASS;
    UINT                        SelectedMediumIndex;
    WCHAR                       SymLnkBuf[128];
    ULONG                       MaximumShortAddresses = 0;
    ULONG                       MaximumLongAddresses = 0;
    KIRQL                       OldIrql;
    BOOLEAN                     DerefDriver = FALSE, DerefMiniport = FALSE;
    BOOLEAN                     Dequeue = FALSE, ExtendedError = FALSE, HaltMiniport = FALSE;
    BOOLEAN                     ClearDeviceClassAssociation = FALSE, WmiDeregister = FALSE;
    BOOLEAN                     FreeDmaAdapter = FALSE;
    BOOLEAN                     FreeMediaQueryRequest = FALSE;
    BOOLEAN                     FreeFilters = FALSE;
    UCHAR                       CurrentLongAddress[6];
    UCHAR                       CurrentShortAddress[2];
    UCHAR                       i;
    BOOLEAN                     fRc;
#if ARCNET
    BOOLEAN                     FreeArcBuf = FALSE;
#endif
    BOOLEAN                     DeleteSymbolicLink = FALSE;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMInitializeAdapter\n"));


    do
    {
        ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

        MiniportReferencePackage();

        //
        // Initialize device.
        //
        if (!ndisReferenceDriver((PNDIS_M_DRIVER_BLOCK)pMiniBlock))
        {
            //
            // The driver is closing.
            //
            break;
        }

        DerefDriver = TRUE;

        pTmpDevice = pConfigurationHandle->DeviceObject;

        //
        // Initialize the Miniport adapter block in the device object extension
        //
        // *** NDIS_WRAPPER_CONTEXT has a higher alignment requirement than
        //   NDIS_MINIPORT_BLOCK, so we put it first in the extension.
        //

        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pTmpDevice->DeviceExtension + 1);

        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("ndisMInitializeAdapter: Miniport %p, ", Miniport));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,  Miniport->pAdapterInstanceName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));


        //
        // Create symbolic link for the device
        //
        SymbolicLink.Buffer = SymLnkBuf;
        SymbolicLink.Length = 0;
        SymbolicLink.MaximumLength = sizeof(SymLnkBuf);
        RtlCopyUnicodeString(&SymbolicLink, &ndisDosDevicesStr);

        NtStatus = RtlAppendUnicodeStringToString(&SymbolicLink, &Miniport->BaseName);

        if (!NT_SUCCESS(NtStatus))
        {
            //
            // not enough room on SymbolicLink for miniport's name
            //
            break;
        }

        NtStatus = IoCreateSymbolicLink(&SymbolicLink, pExportName);

        if (!NT_SUCCESS(NtStatus))
        {
#if DBG
            DbgPrint("ndisMInitializeAdapter: IoCreateSymbolicLink failed for Miniport %p, SymbolicLinkName %p, DeviceName %p, Status %lx\n",
                     Miniport, &SymbolicLink, pExportName, NtStatus);
#endif            
            if (NtStatus == STATUS_OBJECT_NAME_COLLISION)
            {
                DeleteSymbolicLink = TRUE;
            }
            else
            {
                DeleteSymbolicLink = FALSE;
            }
        }
        else
        {
            DeleteSymbolicLink = TRUE;
        }

        Miniport->DeviceContext = DeviceContext;

        Miniport->AssignedProcessor = ndisValidProcessors[ndisCurrentProcessor];
        
        ndisCurrentProcessor --;
        if (ndisCurrentProcessor > ndisMaximumProcessor)
        {
            ndisCurrentProcessor = ndisMaximumProcessor;
        }
        
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE);

        //
        //  Initialize the handlers for the simplex case with the RcvPkt handler set to null-filter case
        //
        Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        Miniport->SavedPacketIndicateHandler = ndisMDummyIndicatePacket;

        Miniport->EthRxIndicateHandler = EthFilterDprIndicateReceive;
        Miniport->FddiRxIndicateHandler = FddiFilterDprIndicateReceive;
        Miniport->TrRxIndicateHandler = TrFilterDprIndicateReceive;

        Miniport->EthRxCompleteHandler = EthFilterDprIndicateReceiveComplete;
        Miniport->FddiRxCompleteHandler = FddiFilterDprIndicateReceiveComplete;
        Miniport->TrRxCompleteHandler = TrFilterDprIndicateReceiveComplete;
        Miniport->SendCompleteHandler =  NdisMSendComplete;
        Miniport->TDCompleteHandler = NdisMTransferDataComplete;
        Miniport->ResetCompleteHandler = NdisMResetComplete;
        Miniport->StatusHandler = NdisMIndicateStatus;
        Miniport->StatusCompleteHandler = NdisMIndicateStatusComplete;
        Miniport->SendResourcesHandler = NdisMSendResourcesAvailable;
        Miniport->QueryCompleteHandler = NdisMQueryInformationComplete;
        Miniport->SetCompleteHandler = NdisMSetInformationComplete;

        Miniport->WanSendCompleteHandler = NdisMWanSendComplete;
        Miniport->WanRcvHandler = NdisMWanIndicateReceive;
        Miniport->WanRcvCompleteHandler = NdisMWanIndicateReceiveComplete;

        //
        // And optimize Dpc/Isr stuff
        //
        Miniport->HandleInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.HandleInterruptHandler;
        Miniport->DisableInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.DisableInterruptHandler;
        Miniport->EnableInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.EnableInterruptHandler;
        Miniport->DeferredSendHandler = ndisMStartSends;

        //
        //  Initialize the list for VC instance names
        //
        InitializeListHead(&Miniport->WmiEnabledVcs);

        //
        //  Set some flags describing the miniport.
        //
        if (pMiniBlock->MiniportCharacteristics.MajorNdisVersion >= 4)
        {
            //
            //  Does this miniport indicate packets?
            //
            if (pMiniBlock->MiniportCharacteristics.ReturnPacketHandler)
            {
                Miniport->InfoFlags |= NDIS_MINIPORT_INDICATES_PACKETS;
            }

            //
            //  Can this miniport handle multiple sends?
            //
            if (pMiniBlock->MiniportCharacteristics.SendPacketsHandler)
            {
                MINIPORT_SET_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY);
                Miniport->DeferredSendHandler = ndisMStartSendPackets;
                Miniport->WSendPacketsHandler = pMiniBlock->MiniportCharacteristics.SendPacketsHandler;
                Miniport->InfoFlags |= NDIS_MINIPORT_SENDS_PACKET_ARRAY;
            }

            if (pMiniBlock->MiniportCharacteristics.MajorNdisVersion == 5)
            {
                //
                //  This is an NDIS 5.0 miniport.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_IS_NDIS_5);
                Miniport->InfoFlags |= NDIS_MINIPORT_IS_NDIS_5;
                
                if (pMiniBlock->MiniportCharacteristics.CoSendPacketsHandler != NULL)
                {
                    //
                    //  This is a connection-oriented miniport.
                    //
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_IS_CO);
                }
            }
        }

        //
        // the refernce is already initalized, so just increment it here
        // we do reference the miniport instead of intializing it
        // to avoid setting the reference count to 1 if miniport has already
        // been refrenced by receiving some power IRPs
        //
        MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);
        DerefMiniport = TRUE;
        
        Miniport->CFHangTicks = 1;  // Default

        //
        //  Initialize a pool of work items to start with.
        //
        for (i = 0; i < NUMBER_OF_SINGLE_WORK_ITEMS; i++)
        {
            WorkItem = &Miniport->WorkItemBuffer[i];
            NdisZeroMemory(WorkItem, sizeof(NDIS_MINIPORT_WORK_ITEM));

            //
            //  Place the work item on the free queue.
            //
            PushEntryList(&Miniport->SingleWorkItems[i], &WorkItem->Link);
        }
 
        //
        //  Enqueue the miniport on the driver block.
        //
        if (!ndisQueueMiniportOnDriver(Miniport, pMiniBlock))
        {
            //
            // The Driver is closing, undo what we have done.
            //
            break;
        }
        Dequeue = TRUE;

        //
        //  Initialize the deferred dpc
        //
        INITIALIZE_DPC(&Miniport->DeferredDpc, ndisMDeferredDpc, Miniport);

        Miniport->LockHandler = (PVOID)XFilterLockHandler;

        //
        //  the miniport's current device state is unspecified.
        //

        if (Miniport->CurrentDevicePowerState == PowerDeviceUnspecified)
        {
            Miniport->CurrentDevicePowerState = PowerDeviceD0;
        }
        ndisQueryPowerCapabilities(Miniport);

        //
        // Call adapter callback. The current value for "Export"
        // is what we tell him to name this device.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IN_INITIALIZE | fMINIPORT_MEDIA_CONNECTED);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        if (pMiniBlock->Flags & fMINIBLOCK_VERIFYING)
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_VERIFYING);
            if ((ndisDriverTrackAlloc != NULL) &&
                (ndisMiniportTrackAlloc == NULL))
            {
                ndisMiniportTrackAlloc = Miniport;
            }
            else
            {
                //
                // tracking memory alocation is allowed
                // for one miniport only. otherwise null out the
                // global ndisDriverTrackAlloc to avoid confusion
                // memory allocations will continue to get tracked
                // but the result will not be as useful
                //
                ndisMiniportTrackAlloc = NULL;
            }
        }

        Miniport->MacOptions = 0;
        
        MiniportInitializeStatus = (pMiniBlock->MiniportCharacteristics.InitializeHandler)(
                                    &OpenErrorStatus,
                                    &SelectedMediumIndex,
                                    ndisMediumArray,
                                    ndisMediumArraySize/sizeof(NDIS_MEDIUM),
                                    (NDIS_HANDLE)(Miniport),
                                    (NDIS_HANDLE)pConfigurationHandle);
        
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisMInitializeAdapter: Miniport %p, InitializeHandler returned %lx\n", Miniport,
                            MiniportInitializeStatus));

        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);

        //
        // Free the slot information buffer
        //
        if (pConfigurationHandle->ParametersQueryTable[3].DefaultData != NULL)
        {
            FREE_POOL(pConfigurationHandle->ParametersQueryTable[3].DefaultData);
        }
        
        if (MiniportInitializeStatus == NDIS_STATUS_SUCCESS)
        {
            HaltMiniport = TRUE;

            CHECK_FOR_NORMAL_INTERRUPTS(Miniport);

            //
            // set up the shutdown handlers for 5.1 miniports
            //
            if (pMiniBlock->MiniportCharacteristics.AdapterShutdownHandler != NULL)
            {
                NdisMRegisterAdapterShutdownHandler(
                                        (NDIS_HANDLE)Miniport,
                                        (PVOID)(Miniport->MiniportAdapterContext),
                                        (ADAPTER_SHUTDOWN_HANDLER)(pMiniBlock->MiniportCharacteristics.AdapterShutdownHandler));
            }

#if DBG
            //
            // if the driver verifier is on for the miniport, check to see if it registered an
            // AdapterShutdownHandler and complain if it did not
            //

            NDIS_WARN((((PNDIS_WRAPPER_CONTEXT)Miniport->WrapperContext)->ShutdownHandler == NULL) &&
                      (Miniport->Interrupt != NULL) && 
                      (Miniport->BusType != PNPISABus), 
                      Miniport, NDIS_GFLAG_WARN_LEVEL_0,
                      ("ndisMInitializeAdapter: Miniport %p did not register a Shutdown handler.\n", Miniport));


            //
            // complain if this is a hardware based device and the driver is asking Ndis to ignore
            // stuck send packets or requests
            //
            NDIS_WARN(MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE) &&
                MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_REQUEST_QUEUE | fMINIPORT_IGNORE_PACKET_QUEUE),
                Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                ("ndisMInitializeAdapter: -Hardware Based- Miniport %p improperly sets NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT or NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT attributes.\n", Miniport));

#endif  


            ASSERT(SelectedMediumIndex < (ndisMediumArraySize/sizeof(NDIS_MEDIUM)));

            Miniport->MediaType = ndisMediumArray[SelectedMediumIndex];

            if (Miniport->MediaType != NdisMedium802_5)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS);
            }

            if (NdisMediumWan == Miniport->MediaType)
            {
                if ((pMiniBlock->MiniportCharacteristics.MajorNdisVersion > 4) &&
                    (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO)))
                {
                    //
                    // if a NDISWAN miniport driver version > 4, it has to be co-ndis
                    //
                    ErrorCode = 0x20;
                    ExtendedError = TRUE;
                    break;
                }
                
                if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
                {
                    Miniport->DeferredSendHandler = ndisMStartWanSends;
                }
            }

            //
            // get and save the vendor driver version if we don't have it already
            //
            if (pMiniBlock->DriverVersion == 0)
            {
                ndisMDoMiniportOp(Miniport,
                                  TRUE,
                                  OID_GEN_VENDOR_DRIVER_VERSION,
                                  &pMiniBlock->DriverVersion,
                                  sizeof(ULONG),
                                  0x0,
                                  TRUE);
            }

            //
            // Set Maximumlookahead to 0 as default. For lan media query the real
            // stuff.
            //
            if (Miniport->MediaType >= 0)
            {
                if ((Miniport->MediaType >= NdisMediumMax) || 
                    ((NdisMediumWan != Miniport->MediaType) && ndisMediaTypeCl[Miniport->MediaType]))
                {
                    //
                    // Query maximum lookahead
                    //
                    ErrorCode = ndisMDoMiniportOp(Miniport,
                                                 TRUE,
                                                 OID_GEN_MAXIMUM_LOOKAHEAD,
                                                 &GenericUlong,
                                                 sizeof(GenericUlong),
                                                 0x1,
                                                 TRUE);
                    if (ErrorCode != 0)
                    {
                        //
                        // for known media types that we submit this query it should succeed.
                        // allow experimental ones to fail it.
                        //
                        if (Miniport->MediaType < NdisMediumMax)
                        {
                            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                                    ("ndisMInitializeAdapter: Error querying the OID_GEN_MAXIMUM_LOOKAHEAD\n"));
                            break;
                        }
                        else
                        {
                            ErrorCode = 0;
                            GenericUlong = 0;
                        }
                             
                    }
                }
            }

            //
            // Now adjust based on media type
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 14) < GenericUlong) ?
                                              NDIS_M_MAX_LOOKAHEAD - 14 : GenericUlong;
                break;

              case NdisMedium802_5:

                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 32) < GenericUlong) ?
                                              (NDIS_M_MAX_LOOKAHEAD - 32) : GenericUlong;
                break;

              case NdisMediumFddi:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 16) < GenericUlong) ?
                                              (NDIS_M_MAX_LOOKAHEAD - 16) : GenericUlong;
                break;

#if ARCNET
              case NdisMediumArcnet878_2:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 50) < GenericUlong) ?
                                              NDIS_M_MAX_LOOKAHEAD - 50 : GenericUlong;

                //
                //  Assume we will succeed with the lookahead allocation.
                //
                ExtendedError = FALSE;

                //
                //  allocate a lookahead buffer for arcnet.
                //
                Miniport->ArcBuf = ALLOC_FROM_POOL(sizeof(NDIS_ARC_BUF), NDIS_TAG_LA_BUF);
                if (Miniport->ArcBuf != NULL)
                {
                    FreeArcBuf = TRUE;
                    
                    NdisZeroMemory(Miniport->ArcBuf, sizeof(NDIS_ARC_BUF));

                    Miniport->ArcBuf->ArcnetLookaheadBuffer = ALLOC_FROM_POOL(NDIS_M_MAX_LOOKAHEAD, NDIS_TAG_LA_BUF);

                    if (Miniport->ArcBuf->ArcnetLookaheadBuffer == NULL)
                    {
                        ExtendedError = TRUE;
                    }
                    else
                    {
                        NdisZeroMemory(Miniport->ArcBuf->ArcnetLookaheadBuffer,
                                       Miniport->MaximumLookahead);
                    }
                }
                else
                {
                    ExtendedError = TRUE;
                }

                break;
#endif

              case NdisMediumWan:
                Miniport->MaximumLookahead = NDIS_M_MAX_LOOKAHEAD - 14;
                break;

              case NdisMediumIrda:
              case NdisMediumWirelessWan:
              case NdisMediumLocalTalk:
                Miniport->MaximumLookahead = GenericUlong;
                //
                // fall through
                //
              default:
                if (Miniport->MediaType >= NdisMediumMax)
                    Miniport->MaximumLookahead = GenericUlong;
                break;
            }

            //
            //  Was there an error?
            //
            if (ExtendedError)
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                        ("    Extended error when processing OID_GEN_MAXIMUM_LOOOKAHEAD\n"));

                ErrorCode = 1;
                break;
            }

            //
            // For lan media query the real
            // stuff.  We also need to call this for wan drivers.
            //
            if (((Miniport->MediaType >= 0) &&
                 (Miniport->MediaType < NdisMediumMax) &&
                 ndisMediaTypeCl[Miniport->MediaType]) ||
                (NdisMediumWan == Miniport->MediaType))
            {
                //
                // Query mac options
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                             TRUE,
                                             OID_GEN_MAC_OPTIONS,
                                             &GenericUlong,
                                             sizeof(GenericUlong),
                                             0x3,
                                             TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_GEN_MAC_OPTIONS\n"));

                    break;
                }

                //
                // NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE bit in MacOption
                // is set by Ndis when/if the driver calls NdisReadNetworkAddress
                // so make sure we don't override this
                //
                Miniport->MacOptions |= (UINT)GenericUlong;

                if (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK)
                {
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_DOES_NOT_DO_LOOPBACK);
                }

                //
                // complain if this is a hardware based device and wants to do loopback itself
                //
                NDIS_WARN(MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE) &&
                    !(Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK),
                    Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                    ("ndisMInitializeAdapter: -Hardware Based- Miniport %p says it does loopback.\n", Miniport));

                
                if ((Miniport->MacOptions & NDISWAN_OPTIONS) == NDISWAN_OPTIONS)
                {
                    Miniport->MaximumLookahead = NDIS_M_MAX_LOOKAHEAD - 14;
                }
            }

            //
            // Query media-connect state. By default, it is connected. Avoid doing
            // this for NDISWAN miniports which are identified in the following
            // convoluted way
            // only do it for the media that needs to be polled to indicate the correct
            // status. for the rest assume it is connected and let the miniport to
            // indicate otherwise. this way miniports can pend this OID till they find
            // their media connect status (which can take up to a few seconds) without
            // affecting the initialization time
            //            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING) &&
                (NdisMediumWan != Miniport->MediaType) &&
                ndisMediaTypeCl[Miniport->MediaType] &&
                ((Miniport->MacOptions & NDISWAN_OPTIONS) != NDISWAN_OPTIONS) &&
                (pMiniBlock->AssociatedProtocol == NULL) &&
                ndisMDoMiniportOp(Miniport,
                                  TRUE,
                                  OID_GEN_MEDIA_CONNECT_STATUS,
                                  &GenericUlong,
                                  sizeof(GenericUlong),
                                  0,
                                  TRUE) == 0)
            {
                PNDIS_REQUEST       Request;

                if (GenericUlong == NdisMediaStateConnected)
                {
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
                }
                else
                {
                    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
                }

                //
                // Allocate a request structure to do media queries
                //
                Request = (PNDIS_REQUEST)ALLOC_FROM_POOL(sizeof(NDIS_REQUEST) + sizeof(ULONG),
                                                                        NDIS_TAG_Q_REQ);

                if (Request == NULL)
                {
                    ErrorCode = 0x01;
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("ndisMInitializeAdapter: Error querying the OID_GEN_MAXIMUM_LOOKAHEAD\n"));
                    break;
                }

                FreeMediaQueryRequest = TRUE;

                Miniport->MediaRequest = Request;
                ZeroMemory(Request, sizeof(NDIS_REQUEST) + sizeof(ULONG));
                INITIALIZE_EVENT(&(PNDIS_COREQ_RESERVED_FROM_REQUEST(Request)->Event));

                Request->RequestType = NdisRequestQueryInformation;

                //
                //  Copy the buffer that was passed to us into the new buffer.
                //
                Request->DATA.QUERY_INFORMATION.Oid = OID_GEN_MEDIA_CONNECT_STATUS;
                Request->DATA.QUERY_INFORMATION.InformationBuffer = Request + 1;
                Request->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(ULONG);
                Miniport->InfoFlags |= NDIS_MINIPORT_SUPPORTS_MEDIA_QUERY;
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags = REQST_COMPLETED;
                Miniport->CheckForHangSeconds = NDIS_CFHANG_TIME_SECONDS;
            }
            else
            {
                //
                // Since we are not polling for media-state, set the tick to 1 and adjust
                // timer value back to what we need. 
                // Clear the Requires Media Polling flag as ndis cannot query the adapter for connectivity
                //
                Miniport->CheckForHangSeconds = Miniport->CFHangTicks*NDIS_CFHANG_TIME_SECONDS;
                Miniport->CFHangTicks = 1;
                MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            }

            Miniport->CFHangCurrentTick = Miniport->CFHangTicks;

            if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
            {
                //
                //  If this miniport supports SendPacketsHandler then we need to query
                //  the maximum number of packets that the miniport supports in a single
                //  call.
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                             TRUE,
                                             OID_GEN_MAXIMUM_SEND_PACKETS,
                                             &GenericUlong,
                                             sizeof(GenericUlong),
                                             0x2,
                                             TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("Error querying OID_GEN_MAXIMUM_SEND_PACKETS\n"));
                    //
                    // Don't error out. If the miniport did not respond to this, it does
                    // not limit it, so we use what makes sense to us which is SEND_PACKET_ARRAY
                    //
                }
    
                Miniport->MaxSendPackets = SEND_PACKET_ARRAY;
                if (GenericUlong < SEND_PACKET_ARRAY)
                {
                    Miniport->MaxSendPackets = (USHORT)GenericUlong;
                }
            }

            //
            // Query the miniport so we can create the right filter package as appropriate
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:

                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_3_MAXIMUM_LIST_SIZE,
                                              &MaximumLongAddresses,
                                              sizeof(GenericUlong),
                                              0x7,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    ExtendedError = TRUE;
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_3_MAXIMUM_LIST_SIZE\n"));

                    break;
                }

                Miniport->MaximumLongAddresses = MaximumLongAddresses;

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_3_CURRENT_ADDRESS,
                                              &CurrentLongAddress[0],
                                              sizeof(CurrentLongAddress),
                                              0x9,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_3_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                    break;
                }

                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisMInitializeAdapter: Miniport %p, Ethernet Address %02X %02X %02X %02X %02X %02X\n",
                    Miniport,
                    CurrentLongAddress[0],
                    CurrentLongAddress[1],
                    CurrentLongAddress[2],
                    CurrentLongAddress[3],
                    CurrentLongAddress[4],
                    CurrentLongAddress[5]));


                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_GEN_PHYSICAL_MEDIUM,
                                              &GenericUlong,
                                              sizeof(GenericUlong),
                                              0xa,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    //
                    // It is okay for a miniport to not support OID_GEN_PHYSICAL_MEDIUM,
                    // so we let this go.
                    //
                    ErrorCode = 0;
                    break;
                }

                Miniport->PhysicalMediumType = GenericUlong;

                ndisMNotifyMachineName(Miniport, NULL);

                break;

              case NdisMedium802_5:
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_5_CURRENT_ADDRESS,
                                              &CurrentLongAddress[0],
                                              sizeof(CurrentLongAddress),
                                              0xB,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_5_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                }

                break;

              case NdisMediumFddi:
                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_LONG_MAX_LIST_SIZE,
                                              &MaximumLongAddresses,
                                              sizeof(GenericUlong),
                                              0xD,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_LONG_MAX_LIST_SIZE\n"));

                    ExtendedError = TRUE;
                    break;
                }

                Miniport->MaximumLongAddresses = MaximumLongAddresses;

                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_SHORT_MAX_LIST_SIZE,
                                              &MaximumShortAddresses,
                                              sizeof(MaximumShortAddresses),
                                              0xF,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_SHORT_MAX_LIST_SIZE\n"));

                    ExtendedError = TRUE;
                    break;
                }

                Miniport->MaximumShortAddresses = MaximumShortAddresses;

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_LONG_CURRENT_ADDR,
                                              &CurrentLongAddress[0],
                                              sizeof(CurrentLongAddress),
                                              0x11,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_LONG_CURRENT_ADDR\n"));

                    ExtendedError = TRUE;
                    break;
                }

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_SHORT_CURRENT_ADDR,
                                              &CurrentShortAddress[0],
                                              sizeof(CurrentShortAddress),
                                              0x13,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_SHORT_CURRENT_ADDR\n"));

                    ExtendedError = TRUE;
                    break;
                }
                break;

#if ARCNET
              case NdisMediumArcnet878_2:

                //
                // In case of an encapsulated ethernet binding, we need
                // to return the maximum number of multicast addresses
                // possible.
                //

                Miniport->MaximumLongAddresses = NDIS_M_MAX_MULTI_LIST;

                //
                // Allocate Buffer pools
                //
                NdisAllocateBufferPool(&NdisStatus,
                                       &Miniport->ArcBuf->ArcnetBufferPool,
                                       ARC_SEND_BUFFERS);


                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    //
                    // make sure this is initialized so we can clean up properly
                    //
                    Miniport->ArcBuf->ArcnetBuffers[0].Buffer = NULL;
                    
                    ArcnetDataBuffer = ALLOC_FROM_POOL(ARC_HEADER_SIZE * ARC_SEND_BUFFERS, NDIS_TAG_ARC_SEND_BUFFERS);
                    if (ArcnetDataBuffer == NULL)
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                                ("    Failed to allocate memory for arcnet data buffers\n"));

                        ErrorCode = 0x18;
                        ExtendedError = TRUE;
                    }
                    else
                    {
                        ZeroMemory(ArcnetDataBuffer, ARC_HEADER_SIZE * ARC_SEND_BUFFERS);

                        DataBuffer = ArcnetDataBuffer;
                        
                        for (i = 0; i < ARC_SEND_BUFFERS; i++)
                        {
                            PARC_BUFFER_LIST    Buffer = &Miniport->ArcBuf->ArcnetBuffers[i];

                            Buffer->BytesLeft = Buffer->Size = ARC_HEADER_SIZE;
                            Buffer->Buffer = DataBuffer;
                            Buffer->Next = NULL;    // This implies that it is free

                            DataBuffer = (((PUCHAR)DataBuffer) + ARC_HEADER_SIZE);
                        }
                        Miniport->ArcBuf->NumFree = ARC_SEND_BUFFERS;

                        //
                        // Get current address
                        //
                        ErrorCode = ndisMDoMiniportOp(Miniport,
                                                      TRUE,
                                                      OID_ARCNET_CURRENT_ADDRESS,
                                                      &CurrentLongAddress[5],   // address = 00-00-00-00-00-XX
                                                      1,
                                                      0x15,
                                                      TRUE);
                        if (ErrorCode != 0)
                        {
                            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                                    ("    Error querying OID_ARCNET_CURRENT_ADDRESS\n"));

                            ExtendedError = TRUE;
                        }
                        else
                        {
                            Miniport->ArcnetAddress = CurrentLongAddress[5];
                        }
                    }
                }
                else
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Failed to allocate buffer pool for arcnet\n"));

                    ErrorCode = 0x16;
                    ExtendedError = TRUE;
                }

                break;
#endif

              case NdisMediumWan:
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_WAN_CURRENT_ADDRESS,
                                              &CurrentLongAddress[0],
                                              sizeof(CurrentLongAddress),
                                              0x17,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_WAN_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                    break;
                }

              default:
                ErrorCode = 0;
                break;
            }

            if (ErrorCode != 0)
            {
                break;
            }

            //
            // Now create the filter package, as appropriate. Note that CurrentLongAddress etc.
            // are still valid from the abover switch statement
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:

                fRc = EthCreateFilter(MaximumLongAddresses,
                                      CurrentLongAddress,
                                      &FilterDB.EthDB);

                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Ethernet filter database\n"));

                    ErrorCode = 0x9;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.EthDB->Miniport = Miniport;
                break;

              case NdisMedium802_5:
                fRc = TrCreateFilter(CurrentLongAddress,
                                     &FilterDB.TrDB);
                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Token Ring filter database\n"));

                    ErrorCode = 0xC;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.TrDB->Miniport = Miniport;
                break;

              case NdisMediumFddi:
                fRc = FddiCreateFilter(MaximumLongAddresses,
                                       MaximumShortAddresses,
                                       CurrentLongAddress,
                                       CurrentShortAddress,
                                       &FilterDB.FddiDB);
                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the FDDI filter database\n"));

                    ErrorCode = 0x15;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.FddiDB->Miniport = Miniport;
                break;

#if ARCNET
              case NdisMediumArcnet878_2:
                if (!ArcCreateFilter(Miniport,
                                     CurrentLongAddress[5],
                                     &FilterDB.ArcDB))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Arcnet filter database\n"));

                    ErrorCode = 0x1B;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.ArcDB->Miniport = Miniport;

                //
                // Zero all but the last one.
                //
                CurrentLongAddress[0] = 0;
                CurrentLongAddress[1] = 0;
                CurrentLongAddress[2] = 0;
                CurrentLongAddress[3] = 0;
                CurrentLongAddress[4] = 0;

                if (!EthCreateFilter(32,
                                     CurrentLongAddress,
                                     &FilterDB.EthDB))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Arcnet filter database for encapsulated ethernet\n"));

                    ErrorCode = 0x1C;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.EthDB->Miniport = Miniport;
                break;
#endif
              default:
                fRc = nullCreateFilter(&FilterDB.NullDB);

                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the NULL filter database\n"));

                    ErrorCode = 0x1E;
                    ExtendedError = TRUE;
                    break;
                }

                FilterDB.NullDB->Miniport = Miniport;
                break;
            }

            FreeFilters = TRUE;

            //
            //  If we successfully create the adapter instance name then we
            //  register with WMI.
            //
            //
            //  let 'em know we can handle WMI requests from IRP_MJ_SYSTEM_CONTROL.
            //
            NtStatus = IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_REGISTER);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT((DBG_COMP_INIT | DBG_COMP_WMI), DBG_LEVEL_WARN,
                    ("    ndisMInitializeAdapter: Failed to register for WMI support\n"));
                ErrorCode = 0x1F;
                ExtendedError = TRUE;
            }
            else
            {
                WmiDeregister = TRUE;
            }
            
            //
            //  Do we need to log an error?
            //
            if (ExtendedError)
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                        ("    Extended error while initializing the miniport\n"));

                NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                        NDIS_ERROR_CODE_DRIVER_FAILURE,
                                        2,
                                        0xFF00FF00,
                                        ErrorCode);
                break;
            }

            //
            // force a IRP_MN_QUERY_PNP_DEVICE_STATE PnP Irp so we can set the
            // PNP_DEVICE_DONT_DISPLAY_IN_UI bit
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
            {
                IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
            }

            NtStatus = STATUS_SUCCESS;

            //
            //  Determine PnP/PM capabilities for this adapter.
            //  But only if the bus drive says it supports PM
            //  except when dealing with IM drivers!
            //
            if ((MINIPORT_PNP_TEST_FLAG(Miniport, (fMINIPORT_PM_SUPPORTED | fMINIPORT_NO_HALT_ON_SUSPEND)) ||
                (Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)) &&
                (Miniport->MediaType >= 0)            &&
                (Miniport->MediaType < NdisMediumMax))
            {
                //
                //  Query the miniport for it's pnp capabilities.
                //  If it doesn't support any then it won't handle this
                //  OID.
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_PNP_CAPABILITIES,
                                              &Miniport->PMCapabilities,
                                              sizeof(Miniport->PMCapabilities),
                                              0x19,
                                              FALSE);

                //
                // reserved flags that miniports are not suposed to write to
                // zero it out just in case they do
                //
                Miniport->PMCapabilities.Flags = 0;

                if (0 == ErrorCode)
                {
                    SYSTEM_POWER_STATE SystemState;
                    DEVICE_POWER_STATE DeviceState;
                    BOOLEAN WakeupCapable = TRUE;

                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
                    if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp == NdisDeviceStateUnspecified) &&
                        (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp == NdisDeviceStateUnspecified) &&
                        (Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp == NdisDeviceStateUnspecified))
#else
                    if ((Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp == NdisDeviceStateUnspecified) &&
                        (Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp == NdisDeviceStateUnspecified))
#endif
                    {
                        WakeupCapable = FALSE;
                    }
                    else
                    {
                        if (Miniport->DeviceCaps.SystemWake <= PowerSystemWorking)
                        {
                            WakeupCapable = FALSE;
                        }
                        else
                        {
                            for (SystemState = PowerSystemSleeping1;
                                 SystemState <= Miniport->DeviceCaps.SystemWake;
                                 SystemState++)
                            {
                                DeviceState = Miniport->DeviceCaps.DeviceState[SystemState];

                                if ((DeviceState != PowerDeviceUnspecified) &&
                                    ((DeviceState <= Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp) ||
                                     (DeviceState <= Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp)))
                                {
                                    //
                                    // check for device state to make sure the device can go to this state
                                    // any device should be able to go to D0 or D3, so only check for D1 and D2
                                    //

                                    if (((DeviceState == PowerDeviceD1) && !Miniport->DeviceCaps.DeviceD1) ||
                                        ((DeviceState == PowerDeviceD2) && !Miniport->DeviceCaps.DeviceD2))
                                    {
                                        //
                                        // we can't do WOL from this system state. check the next one
                                        //
                                        continue;
                                    }
                                    else
                                    {
                                    
                                        //
                                        // there is at least one system state from which the device can do
                                        // WOL.
                                        //
                                        break;
                                    }
                                }

                            }

                            if (SystemState > Miniport->DeviceCaps.SystemWake)
                            {
                                WakeupCapable = FALSE;
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO, ("ndisMInitializeAdapter: WOL not possible on this miniport: %p \n", Miniport));
                            }
                        }
                    }

                    if (!WakeupCapable)
                    {
                        //
                        // set SystemWake to PowerSystemWorking so everybody knows we can not do 
                        // WOL on this machine but we may be able to put the device to sleep
                        // when it is disconnected for some time.
                        // note that at this point we already know the SystemWake is != PowerSystemUnspecified
                        //
                        Miniport->DeviceCaps.SystemWake = PowerSystemWorking;
                    }

                    if (!(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_PM))
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp != NdisDeviceStateUnspecified) &&
                            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
                        {

                            //
                            //  If the miniport is capable of wake-up for a link change
                            //  then we need to allocate a timer for timeout.
                            //
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_LINK_CHANGE;
                        }
#endif

                        if (!(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_UP) && 
                            WakeupCapable)
                        {
                            if ((Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp != NdisDeviceStateUnspecified) &&
                                !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH))
                            {
                                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);

                                //
                                // NDIS_DEVICE_WAKE_UP_ENABLE bit is used by tcp/ip to decide whether or not to set a timer
                                // to renew DHCP address. set this flag only if packet matching is enabled
                                //
                                Miniport->PMCapabilities.Flags |= (NDIS_DEVICE_WAKE_UP_ENABLE | NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE);
                            }
                            
                            //
                            // no protocol is going to set the magic packet wake up method. so ndis
                            // does it itself (unless specified otherwise in registry)
                            //
                            if ((Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                                !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                            {
                                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                                Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                                Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                            }
                            
                        }
                    }


                    IF_DBG(DBG_COMP_PM, DBG_LEVEL_INFO)
                    {
                        DbgPrint("ndisMInitializeAdapter: Driver says Miniport %p supports PM\n", Miniport);
                        DbgPrint("\tMinMagicPacketWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp);
                        DbgPrint("\tMinPatternWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp);
                        DbgPrint("\tMinLinkChangeWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp);
                    }
                }
                else
                {
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);
                }

                ErrorCode = 0;
            }

#if NDIS_RECV_SCALE

            //
            // get the receive scale capabilities of the device
            //
            ErrorCode = ndisMDoMiniportOp(Miniport,
                              TRUE,
                              OID_GEN_RECEIVE_SCALE_CAPABILITIES,
                              &Miniport->RecvScaleCapabilities,
                              sizeof(Miniport->RecvScaleCapabilities),
                              0x20,
                              FALSE);
            
            if (ErrorCode == 0)
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_RECEIVE_SCALE);
            }
#endif


#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
            
            //
            // we initialize this timer anyway, just in case user enables "media disconnect sleep" at run-time
            // when -setting- the timer however, we will check to make sure the media disconnect feature is enabled
            //
            //1 should be removed since we do not support going to low power state on media disconnect
            NdisInitializeTimer(&Miniport->MediaDisconnectTimer, ndisMediaDisconnectTimeout, Miniport);
#endif

            ErrorCode = 1;

            //
            //  Register the device class.
            //
            NtStatus = IoRegisterDeviceInterface(Miniport->PhysicalDeviceObject,
                                                 &guidLanClass,
                                                 &Miniport->BaseName,
                                                 &Miniport->SymbolicLinkName);

            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("    ndisMInitializeAdapter: IoRegisterDeviceClassAssociation failed\n"));

                break;
            }

            //
            // setting this flag obviously is not necessary because we are going
            // to clear it right away. but leave it here just in case we end up
            // doing something that can fail the initialization -after- this.
            //
            ClearDeviceClassAssociation = TRUE;
            

            //
            // Finally mark the device as *NOT* initializing. This is to let
            // layered miniports initialize their device instance *OUTSIDE*
            // of their driver entry. If this flag is on, then NdisOpenAdapter
            // to this device will not work. This is also true of subsequent
            // instances of a driver initializing outside of its DriverEntry
            // as a result of a PnP event.
            //
            Miniport->DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            //
            // Start wake up timer
            //
            
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER);
            
            NdisSetTimer(&Miniport->WakeUpDpcTimer, Miniport->CheckForHangSeconds*1000);
            //
            //  Notify WMI of adapter arrival.
            //
            {

                PWNODE_SINGLE_INSTANCE  wnode;
                PUCHAR                  ptmp;
                
                ndisSetupWmiNode(Miniport,
                                 Miniport->pAdapterInstanceName,
                                 Miniport->MiniportName.Length + sizeof(USHORT),
                                 (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
                                 &wnode);

                if (wnode != NULL)
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
                    *((PUSHORT)ptmp) = Miniport->MiniportName.Length;

                    //
                    //  Copy the data after the number of elements.
                    //
                    RtlCopyMemory(ptmp + sizeof(USHORT),
                                  Miniport->MiniportName.Buffer,
                                  Miniport->MiniportName.Length);

                    //
                    //  Indicate the event to WMI. WMI will take care of freeing
                    //  the WMI struct back to pool.
                    //
                    NtStatus = IoWMIWriteEvent(wnode);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("ndisMInitializeAdapter: Failed to indicate adapter arrival\n"));

                        FREE_POOL(wnode);
                    }
                }
            }

            //
            // let the adapter know about the current power source
            //
            PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? 
                            NdisPowerProfileAcOnLine : 
                            NdisPowerProfileBattery;

            ndisNotifyMiniports(Miniport,
                                NdisDevicePnPEventPowerProfileChanged,
                                &PowerProfile,
                                sizeof(NDIS_POWER_PROFILE));

            ndisMAdjustFilters(Miniport, &FilterDB);

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                Miniport->SendPacketsHandler = ndisMSendPacketsX;
            }
            else
            {
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
                {
                    Miniport->SendPacketsHandler = ndisMSendPacketsSG;
                    
                    if (pMiniBlock->MiniportCharacteristics.SendPacketsHandler)
                    {
                        Miniport->DeferredSendHandler = ndisMStartSendPacketsSG;
                    }
                    else
                    {
                        Miniport->DeferredSendHandler = ndisMStartSendsSG;
                    }
                }
                else
                {
                    Miniport->SendPacketsHandler = ndisMSendPackets;
                }            
            }

            ndisMSetIndicatePacketHandler(Miniport);

            //
            // we don't need (and shouldn't) do the following line. if at this moment the
            // media is disconnected, we will end up with having the saved handler as dummy one
            //
            // Miniport->SavedPacketIndicateHandler = Miniport->PacketIndicateHandler;

            //
            // Set to not cleanup
            //

            ErrorCode = 0;
            HaltMiniport = FALSE;
            DerefDriver = DerefMiniport = Dequeue = FALSE;
            FreeMediaQueryRequest = FALSE;
            FreeFilters = FALSE;
#if ARCNET
            FreeArcBuf = FALSE;
#endif

            ClearDeviceClassAssociation = FALSE;
            DeleteSymbolicLink = FALSE;
            WmiDeregister = FALSE;


        }
        else
        {
            //
            // miniport failed to initialize
            //
            NdisMDeregisterAdapterShutdownHandler(Miniport);
            
            ndisLastFailedInitErrorCode = ErrorCode = MiniportInitializeStatus;
            ASSERT(Miniport->Interrupt == NULL);
            ASSERT(Miniport->TimerQueue == NULL);
            ASSERT(Miniport->MapRegisters == NULL);

            if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
            {
                if (Miniport->Interrupt != NULL)
                {
                    BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
                    KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                                0xB,
                                (ULONG_PTR)Miniport,
                                (ULONG_PTR)Miniport->Interrupt,
                                0);
                }
                else
                {
                    BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
                    KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                                0xC,
                                (ULONG_PTR)Miniport,
                                (ULONG_PTR)Miniport->TimerQueue,
                                0);
                }
            }

            //
            // if initialization fails, we should check to see
            // if we need to put the DMA adapter
            //
            FreeDmaAdapter = TRUE;

        }
    } while (FALSE);


    //
    //  Perform any necessary cleanup.
    //
    //
    if (WmiDeregister)
    {
        //
        //  Deregister with WMI
        //
        IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_DEREGISTER);
    }

    if (HaltMiniport)
    {
        (Miniport->DriverHandle->MiniportCharacteristics.HaltHandler)(Miniport->MiniportAdapterContext);

        //
        // if we end up halting the adapter, we may need to
        // "put" DMA adapter object
        //
        FreeDmaAdapter = TRUE;
        ASSERT(Miniport->TimerQueue == NULL);
        ASSERT (Miniport->Interrupt == NULL);
        ASSERT(Miniport->MapRegisters == NULL);
        if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
        {
            if (Miniport->Interrupt != NULL)
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0xD,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Miniport->Interrupt,
                            0);
            }
            else
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0xE,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Miniport->TimerQueue,
                            0);
            }
        }
        
        if (FreeFilters)
        {

            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:
                if (FilterDB.EthDB)
                    EthDeleteFilter(FilterDB.EthDB);
                Miniport->EthDB = NULL;
                break;
                
              case NdisMedium802_5:
                if (FilterDB.TrDB)
                    TrDeleteFilter(FilterDB.TrDB);
                Miniport->TrDB = NULL;
                break;
                
              case NdisMediumFddi:
                if (FilterDB.FddiDB)
                    FddiDeleteFilter(FilterDB.FddiDB);
                Miniport->FddiDB = NULL;
                break;
#if ARCNET
              case NdisMediumArcnet878_2:
                if (FilterDB.ArcDB)
                    ArcDeleteFilter(FilterDB.ArcDB);
                if (FilterDB.EthDB)
                    EthDeleteFilter(FilterDB.EthDB);
                Miniport->ArcDB = NULL;
                Miniport->EthDB = NULL;
                break;
#endif
              default:
                if (FilterDB.NullDB)
                    nullDeleteFilter(FilterDB.NullDB);
                Miniport->NullDB = NULL;
                break;
                
            }
        }

        if (FreeMediaQueryRequest)
        {
            FREE_POOL(Miniport->MediaRequest);
        }


        if (ClearDeviceClassAssociation)
        {
            IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
        }

#if ARCNET
        if (FreeArcBuf)
        {
            if (Miniport->ArcBuf->ArcnetLookaheadBuffer)
            {
                FREE_POOL(Miniport->ArcBuf->ArcnetLookaheadBuffer);
            }
            if (Miniport->ArcBuf->ArcnetBufferPool)
            {
                NdisFreeBufferPool(Miniport->ArcBuf->ArcnetBufferPool);
            }
            
            if (Miniport->ArcBuf->ArcnetBuffers[0].Buffer)
            {
                FREE_POOL(Miniport->ArcBuf->ArcnetBuffers[0].Buffer);
                Miniport->ArcBuf->ArcnetBuffers[0].Buffer = NULL;
            }

            FREE_POOL(Miniport->ArcBuf);
        }
        
#endif
        
    }

    if (FreeDmaAdapter)
    {
        KEVENT  DmaResourcesReleasedEvent;
            
        //
        // if the adapter uses SG DMA, we have to dereference the DMA adapter
        // to get it freed
        //
        if ((MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST)) &&
            (Miniport->SystemAdapterObject != NULL))
        {
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisMInitializeAdapter: releasing DMA adapter for failed Miniport %p\n", Miniport));
            ndisDereferenceDmaAdapter(Miniport);
        }

        INITIALIZE_EVENT(&DmaResourcesReleasedEvent);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        Miniport->DmaResourcesReleasedEvent = &DmaResourcesReleasedEvent;
        
        if (Miniport->SystemAdapterObject != NULL)
        {
            LARGE_INTEGER TimeoutValue;

            TimeoutValue.QuadPart = Int32x32To64(30000, -10000); // Make it 30 second

            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            
            if (!NT_SUCCESS(WAIT_FOR_OBJECT(&DmaResourcesReleasedEvent, &TimeoutValue)))
            {
                BAD_MINIPORT(Miniport, "Miniport is going away without releasing all DMA resources.");
            }
            
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }

        Miniport->DmaResourcesReleasedEvent = NULL;

    }



    if (Dequeue)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Dequeueing the miniport from the driver block.\n"));

        ndisDeQueueMiniportOnDriver(Miniport, pMiniBlock);
    }


    if (DeleteSymbolicLink)
    {
        NtStatus = IoDeleteSymbolicLink(&SymbolicLink);
        if (!NT_SUCCESS(NtStatus))
        {
#if DBG
            DbgPrint("ndisMInitializeAdapter: deleting symbolic link name failed for miniport %p, SymbolicLinkName %p, NtStatus %lx\n",
                     Miniport, &SymbolicLink, NtStatus);
#endif

        }
    }
    
    if (DerefMiniport)
    {
        //
        // remove the ref count on the miniport without doing any clean up.
        // Clean up is done during processing REMOVE IRP.
        //
        MINIPORT_DECREMENT_REF_NO_CLEAN_UP(Miniport);
    }

    if (DerefDriver)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Dereferencing the miniport block.\n"));

        ndisDereferenceDriver(pMiniBlock, FALSE);
    }

    if (ErrorCode != 0)
    {
        MiniportDereferencePackage();
    }

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisMInitializeAdapter: Miniport %p, Status %lx\n", Miniport, ErrorCode));

    return ErrorCode;
}


VOID
ndisMOpenAdapter(
    OUT PNDIS_STATUS            Status,
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  BOOLEAN                 UsingEncapsulation
    )
/*++

Routine Description:

    This routine handles opening a miniport directly from NdisOpenAdapter()

    NOTE: called with Miniport spin lock held.
    NOTE: for serialized drivers called with local lock held

Arguments:

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_PROTOCOL_BLOCK    Protocol = Open->ProtocolHandle;
    PNDIS_MAC_BLOCK         FakeMac;
    BOOLEAN                 FilterOpen;
    BOOLEAN                 DerefMini = FALSE, DeQueueFromMiniport = FALSE, DeQueueFromProtocol = FALSE;
    BOOLEAN                 FakeMacAllocated = FALSE;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisMOpenAdapter: Protocol %p, Miniport %p, Open %p\n",
                        Protocol,
                        Miniport,
                        Open));

    ASSERT_MINIPORT_LOCKED(Miniport);

    do
    {
        if (!MINIPORT_INCREMENT_REF(Miniport))
        {
            //
            // The adapter is closing.
            //
            *Status = NDIS_STATUS_CLOSING;
            break;
        }
        DerefMini = TRUE;

        //
        //  Initialize the open block.
        //
        FakeMac = (PNDIS_MAC_BLOCK)Miniport->FakeMac;
        if (FakeMac == NULL)
        {
            //
            //  Allocate a fake MAC block for the characteristics.
            //
            FakeMac = (PNDIS_MAC_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_MAC_BLOCK), NDIS_TAG_FAKE_MAC);
            if (FakeMac == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Initialize the fake mac block.
            //
            ZeroMemory(FakeMac, sizeof(NDIS_MAC_BLOCK));
            Miniport->FakeMac = (PVOID)FakeMac;
            FakeMacAllocated = TRUE;
        }
        
        Open->MacHandle = (PVOID)FakeMac;
        Open->MiniportAdapterContext = Miniport->MiniportAdapterContext;
        Open->CurrentLookahead = (USHORT)Miniport->CurrentLookahead;

        INITIALIZE_SPIN_LOCK(&Open->SpinLock);
 
        DBGPRINT_RAW(DBG_COMP_OPENREF, DBG_LEVEL_INFO, ("    =1 0x%x\n", Open));

        Open->References = 1;

        //
        // Add an extra ref-count for connection-oriented miniports
        // This is removed after the protocol is notified of open-afs
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
            (Protocol->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL))
        {
            Open->References ++;
        }


        if (UsingEncapsulation)
        {
            OPEN_SET_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION);
        }

        //
        //  Save the handlers with the open block.
        //
        Open->WSendHandler = Miniport->DriverHandle->MiniportCharacteristics.SendHandler;
        Open->WSendPacketsHandler = Miniport->WSendPacketsHandler;
        Open->WTransferDataHandler = Miniport->DriverHandle->MiniportCharacteristics.TransferDataHandler;
        Open->SendCompleteHandler = Protocol->ProtocolCharacteristics.SendCompleteHandler;
        Open->TransferDataCompleteHandler = Protocol->ProtocolCharacteristics.TransferDataCompleteHandler;
        Open->ReceiveHandler = Protocol->ProtocolCharacteristics.ReceiveHandler;
        Open->ReceiveCompleteHandler = Protocol->ProtocolCharacteristics.ReceiveCompleteHandler;
        Open->StatusHandler = Protocol->ProtocolCharacteristics.StatusHandler;
        Open->StatusCompleteHandler = Protocol->ProtocolCharacteristics.StatusCompleteHandler;
        Open->ResetCompleteHandler = Protocol->ProtocolCharacteristics.ResetCompleteHandler;
        Open->RequestCompleteHandler = Protocol->ProtocolCharacteristics.RequestCompleteHandler;
        Open->ResetHandler = ndisMReset;
        Open->ReceivePacketHandler = Protocol->ProtocolCharacteristics.ReceivePacketHandler;
        Open->RequestHandler = ndisMRequest;
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Open->RequestHandler = ndisMRequestX;
        }

        //
        // for backward compatibility with macros that use this field
        //
        Open->BindingHandle = (NDIS_HANDLE)Open;

        //
        //  for even more speed...
        //
#if ARCNET
        if (NdisMediumArcnet878_2 == Miniport->MediaType)
        {
            Open->TransferDataHandler = ndisMArcTransferData;
        }
        else
#endif
        {
            Open->TransferDataHandler = ndisMTransferData;
        }

        //
        //  Set the send handler in the open block.
        //
        switch (Miniport->MediaType)
        {
#if ARCNET
            case NdisMediumArcnet878_2:
                Open->SendHandler = ndisMSend;
                break;
#endif
            case NdisMediumWan:
                if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
                {
                    Open->SendHandler = (SEND_HANDLER)ndisMWanSend;
                }
                break;

            default:
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
                {
                    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
                            ("    Using ndisMSendX/ndisMSendPacketsX\n"));
                    Open->SendHandler = ndisMSendX;
                }
                else
                {
                    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
                            ("    Using ndisMSend/ndisMSendPackets\n"));
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
                    {
                        Open->SendHandler = ndisMSendSG;
                    }
                    else
                    {
                        Open->SendHandler = ndisMSend;
                    }
                }
                break;
        }

        //
        //  Set up the send packets handler.
        //
        Open->SendPacketsHandler = Miniport->SendPacketsHandler;

        //
        //  For WAN miniports, the send handler is different.
        //
        if ((NdisMediumWan == Miniport->MediaType) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
        {
            Open->WanSendHandler = ndisMWanSend;
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // NDIS 5.0 miniport extensions
            //
            Open->MiniportCoRequestHandler = Miniport->DriverHandle->MiniportCharacteristics.CoRequestHandler;
            Open->MiniportCoCreateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoCreateVcHandler;

            //
            // initialize Lists
            //
            InitializeListHead(&Open->ActiveVcHead);
            InitializeListHead(&Open->InactiveVcHead);

            //
            // the convential send function is not available for CO miniports
            // since this send function does not specify the Vc to send upon
            // However for components which want to use this let them.
            //
            if ((Open->SendHandler == NULL) && (Open->SendPacketsHandler == NULL))
            {
                Open->SendHandler = ndisMRejectSend;
                Open->SendPacketsHandler = ndisMRejectSendPackets;
            }
        }

        Open->CancelSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CancelSendPacketsHandler;

        (PVOID)Miniport->SavedSendHandler = (PVOID)Open->SendHandler;
        Miniport->SavedSendPacketsHandler = Open->SendPacketsHandler;
        Miniport->SavedCancelSendPacketsHandler = Open->CancelSendPacketsHandler;
        
        //
        // insert the open on miniport and protocol queue
        //
        if (ndisQueueOpenOnMiniport(Miniport, Open))
        {
            DeQueueFromMiniport = TRUE;
        }
        else
        {
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }


        if (ndisQueueOpenOnProtocol(Open, Protocol))
        {
            DeQueueFromProtocol = TRUE;
        }
        else
        {
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }


        //
        // Insert the open into the filter package
        //
        switch (Miniport->MediaType)
        {
#if ARCNET
          case NdisMediumArcnet878_2:
            if (!UsingEncapsulation)
            {
                FilterOpen = ArcNoteFilterOpenAdapter(Miniport->ArcDB,
                                                      Open,
                                                      &Open->FilterHandle);
                break;
            }
#endif
            //
            // If we're using ethernet encapsulation then
            // we simply fall through to the ethernet stuff.
            //
            
          case NdisMedium802_3:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->EthDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          case NdisMedium802_5:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->TrDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          case NdisMediumFddi:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->FddiDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          default:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->NullDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
        }

        //
        //  Check for an open filter failure.
        //
        if (!FilterOpen)
        {
            //
            // Something went wrong, clean up and exit.
            //
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }

        if (FakeMacAllocated)
        {
            FakeMac->MacCharacteristics.TransferDataHandler = ndisMTransferData;
            FakeMac->MacCharacteristics.ResetHandler = ndisMReset;
            FakeMac->MacCharacteristics.RequestHandler = Open->RequestHandler;
            FakeMac->MacCharacteristics.SendHandler = Open->SendHandler;
        }

        *Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  Cleanup failure case
    //
    if (*Status != NDIS_STATUS_SUCCESS)
    {
        if (DeQueueFromMiniport)
        {
            ndisDeQueueOpenOnMiniport(Open, Miniport);
        }

        if (DeQueueFromProtocol)
        {
            ndisDeQueueOpenOnProtocol(Open, Protocol);
        }
        
        if (DerefMini)
        {
            MINIPORT_DECREMENT_REF(Miniport);
        }
        
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisMOpenAdapter: Protocol %p, Miniport %p, Open %p, Status %lx\n",
                        Protocol,
                        Miniport,
                        Open,
                        Status));
}

BOOLEAN
NdisIMSwitchToMiniport(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    OUT PNDIS_HANDLE            SwitchHandle
    )
/*++

Routine Description:

    This routine will attempt to synchronously grab the miniport's (specified
    by MiniportAdapterHandle) spin-lock and local lock.  If it succeeds
    it will return TRUE, otherwise it will return FALSE.

Arguments:

    MiniportAdapterHandle   -   Pointer to the NDIS_MINIPORT_BLOCK whose
                                context we should nail down.
    SwitchHandle            -   Pointer to storage for the current irql.
                                This is returned to the caller as a handle,
                                need-to-know basis baby.

Return Value:

    TRUE if we obtain both locks, FALSE otherwise.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    *((PKIRQL)SwitchHandle) = OldIrql;

    //
    //  Did we already acquire the lock with this thread?
    //
    if (CURRENT_THREAD == Miniport->MiniportThread)
    {
        //
        //  We've already acquired the lock...
        //
        ASSERT_MINIPORT_LOCKED(Miniport);

        *SwitchHandle = (NDIS_HANDLE)-1;
        LocalLock = TRUE;
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
        LOCK_MINIPORT(Miniport, LocalLock);
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    return LocalLock;
}

VOID
NdisIMRevertBack(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             SwitchHandle
    )
/*++

Routine Description:

    This routine will undo what NdisMLockMiniport did.  It will release the
    local lock and free the spin lock.

Arguments:

    MiniportAdapterHandle   -   Pointer to the NDIS_MINIPORT_BLOCK whose
                                context we are releasing.
    SwitchHandle            -   This is the original irql from the NdisMLockMiniport
                                call.

Return Value:

--*/
{
    KIRQL                   Irql = *((KIRQL*)&SwitchHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    //
    //  Before we unlock the miniport's context we need to pick up any
    //  stray workitems for this miniport that may have been generated by
    //  the caller.
    //
    NDISM_PROCESS_DEFERRED(Miniport);

    if ((NDIS_HANDLE)-1 != SwitchHandle)
    {
        UNLOCK_MINIPORT(Miniport, TRUE);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, Irql);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }
}

NDIS_STATUS
NdisIMQueueMiniportCallback(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  W_MINIPORT_CALLBACK     CallbackRoutine,
    IN  PVOID                   CallbackContext
    )
/*++

Routine Description:

    This routine will attempt to acquire the specified MiniportAdapterHandle's
    miniport lock and local lock and call the callback routine with the context
    information.  If it cannot do so then it will queue a workitem to do it
    later.

Arguments:

    MiniportAdapterHandle   -   PNDIS_MINIPORT_BLOCK of the miniport whose
                                context we are attempting to acquire.
    CallbackRoutine         -   Pointer to the routine that we are to call.
    CallbackContext         -   Context information for the callback routine.

Return Value:

    NDIS_STATUS_SUCCESS -   If we were able to do this synchronously.
    NDIS_STATUS_PENDING -   If it will be called at a later time.
    NDIS_STATUS_RESOURCES - If the work item could not be queue'd.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    //
    //  Did we already acuqire the lock with this thread?
    //
    if (CURRENT_THREAD == Miniport->MiniportThread)
    {
        //
        //  We've already acquired the lock...
        //
        ASSERT_MINIPORT_LOCKED(Miniport);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        LocalLock = TRUE;
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        LOCK_MINIPORT(Miniport, LocalLock);
    }

    if (LocalLock)
    {
        //
        //  Call the callback routine.
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (*CallbackRoutine)(Miniport->MiniportAdapterContext, CallbackContext);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        NDISM_PROCESS_DEFERRED(Miniport);

        UNLOCK_MINIPORT(Miniport, LocalLock);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        //
        //  Queue the work item to do this later.
        //
        Status = NDISM_QUEUE_NEW_WORK_ITEM(Miniport,
                                           NdisWorkItemMiniportCallback,
                                           CallbackContext,
                                           (PVOID)CallbackRoutine);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);


        Status = (NDIS_STATUS_SUCCESS == Status) ? NDIS_STATUS_PENDING : NDIS_STATUS_RESOURCES;
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    return Status;
}

VOID
FASTCALL
ndisMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    OUT PVOID       *           WorkItemContext OPTIONAL,
    OUT PVOID       *           WorkItemHandler OPTIONAL
    )
/*++

Routine Description:

    This routine will dequeue a workitem of the given type and return any context
    information that is associated with it.


Arguments:

    Miniport            -   Pointer to the miniport block.
    WorkItemType        -   Type of workitem to dequeue.
    WorkItemContext     -   Pointer to storage space for context information.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY          Link;
    PNDIS_MINIPORT_WORK_ITEM    WorkItem;

    //
    //  Grab the first workitem of the given type.
    //
    Link = PopEntryList(&Miniport->WorkQueue[WorkItemType]);
    if (Link != NULL)
    {
        //
        //  Get a pointer to the context information.
        //
        WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);

        if (WorkItemContext != NULL)
        {
            *WorkItemContext = WorkItem->WorkItemContext;
        }

        if (ARGUMENT_PRESENT(WorkItemHandler))
        {
            ASSERT(WorkItemType == NdisWorkItemMiniportCallback);
            *WorkItemHandler = *(PVOID *)(WorkItem + 1);
        }

        switch (WorkItemType)
        {
            //
            // Enumerate these if any work-item types are added and they are *not*
            // single work-item types
            //
            case NdisWorkItemMiniportCallback:
                FREE_POOL(WorkItem);
                break;

            case NdisWorkItemResetInProgress:
                PushEntryList(&Miniport->SingleWorkItems[NdisWorkItemResetRequested], Link);
                break;

            case NdisWorkItemResetRequested:
                WorkItem->WorkItemType = NdisWorkItemResetInProgress;
                PushEntryList(&Miniport->WorkQueue[NdisWorkItemResetInProgress], Link);
                break;

            default:
                PushEntryList(&Miniport->SingleWorkItems[WorkItemType], Link);
                break;
        }
    }
}

NDIS_STATUS
FASTCALL
ndisMQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             Status;
    PSINGLE_LIST_ENTRY      Link;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMQueueWorkItem\n"));

    Link = PopEntryList(&Miniport->SingleWorkItems[WorkItemType]);
    if (NULL != Link)
    {
        WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);
        WorkItem->WorkItemType = WorkItemType;
        WorkItem->WorkItemContext = WorkItemContext;
        PushEntryList(&Miniport->WorkQueue[WorkItemType], Link);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    //  If this is an intermediate driver then we may have to fire a timer
    //  so the work item gets processed.
    //
    if (((Miniport->Flags & (fMINIPORT_INTERMEDIATE_DRIVER | fMINIPORT_DESERIALIZE)) == fMINIPORT_INTERMEDIATE_DRIVER) &&
        (NDIS_STATUS_SUCCESS == Status))
    {
        NDISM_DEFER_PROCESS_DEFERRED(Miniport);
    }
    else if ((MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) ||
             MINIPORT_PNP_TEST_FLAG (Miniport, fMINIPORT_PM_HALTED)) &&
             (WorkItemType == NdisWorkItemRequest))
    {
        ndisMDoRequests(Miniport);
    }

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
            ("<==ndisMQueueWorkItem\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueueNewWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext,
    IN  PVOID                   WorkItemHandler OPTIONAL
    )
/*++

Routine Description:

    This routine will queue a workitem in the work queue even if there
    are already work items queue for it.

Arguments:

    Miniport    -   Miniport block to queue the workitem to.
    WorkItem    -   Workitem to place on the queue.

Return Value:

--*/
{
    NDIS_STATUS         Status;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMQueueNewWorkItem\n"));

    //
    // this is really to verify the WorkItemType is NdisWorkItemMiniportCallback
    //
    ASSERT((WorkItemType < NUMBER_OF_WORK_ITEM_TYPES) &&
           (WorkItemType >= NUMBER_OF_SINGLE_WORK_ITEMS));

    do
    {
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("Allocate a workitem from the pool.\n"));

        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_MINIPORT_WORK_ITEM) + (ARGUMENT_PRESENT(WorkItemHandler) ? sizeof(PVOID) : 0),
                                    NDIS_TAG_WORK_ITEM);
        if (NULL == WorkItem)
        {
            DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_FATAL,
                    ("Failed to allocate a workitem from the pool!\n"));
            DBGBREAK(DBG_COMP_WORK_ITEM, DBG_LEVEL_FATAL);

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        WorkItem->WorkItemType = WorkItemType;
        WorkItem->WorkItemContext = WorkItemContext;
        if (ARGUMENT_PRESENT(WorkItemHandler))
        {
            ASSERT(WorkItemType == NdisWorkItemMiniportCallback);
            *(PVOID *)(WorkItem + 1) = WorkItemHandler;
        }

        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem 0x%x\n", WorkItem));
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem Type 0x%x\n", WorkItemType));
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem Context 0x%x\n", WorkItemContext));

        PushEntryList(&Miniport->WorkQueue[WorkItemType], &WorkItem->Link);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this is an intermediate driver (but not a co-ndis or a 
    //  deserialized driver) then we may have to fire a timer
    //  so the work item gets processed.
    //
    if (((Miniport->Flags & (fMINIPORT_INTERMEDIATE_DRIVER | fMINIPORT_DESERIALIZE)) == fMINIPORT_INTERMEDIATE_DRIVER) &&
        (NDIS_STATUS_SUCCESS == Status))
    {
        NDISM_DEFER_PROCESS_DEFERRED(Miniport);
    }

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMQueueNewWorkItem\n"));

    return(Status);
}


VOID
FASTCALL
ndisMProcessDeferred(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Processes all outstanding operations.

    CALLED WITH THE LOCK HELD!!

Arguments:

    Miniport - Miniport to send to.

Return Value:

    None.

--*/
{
    NDIS_STATUS         Status;
    BOOLEAN             ProcessWorkItems;
    BOOLEAN             AddressingReset = FALSE;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMProcessDeferred\n"));

    //
    //  DO NOT CHANGE THE ORDER THAT THE WORKITEMS ARE PROCESSED!!!!!
    //
    do
    {
        ProcessWorkItems = FALSE;

        //
        //  Are there any sends to process?
        //
        if ((Miniport->WorkQueue[NdisWorkItemSend].Next != NULL) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_REQUESTED | 
                                           fMINIPORT_RESET_IN_PROGRESS | 
                                           fMINIPORT_PM_HALTING)))
        {
            //
            //  Process the sends.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
            NDISM_START_SENDS(Miniport);
            ProcessWorkItems = TRUE;
        }

        //
        //  Is there a reset currently in progress?
        //
        if (Miniport->WorkQueue[NdisWorkItemResetInProgress].Next != NULL)
        {
            if (Miniport->WorkQueue[NdisWorkItemRequest].Next != NULL)
            {
                //
                //  We have requests to process that set up the packet
                //  filters.
                //
                NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
                ndisMDoRequests(Miniport);
            }
            break;
        }

        if (Miniport->WorkQueue[NdisWorkItemReturnPackets].Next != NULL)
        {
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemReturnPackets, NULL);
            ndisMDeferredReturnPackets(Miniport);
        }

        //
        //  If the adapter is halting then get out of here.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING))

        {
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("    Miniport is halting\n"));
            break;
        }

        //
        //  If a miniport wants a call back do it now...
        //
        if (Miniport->WorkQueue[NdisWorkItemMiniportCallback].Next != NULL)
        {
            W_MINIPORT_CALLBACK CallbackRoutine = NULL;
            PVOID               CallbackContext;

            //
            //  Get the callback routine and the context information for it.
            //
            NDISM_DEQUEUE_WORK_ITEM_WITH_HANDLER(Miniport,
                                                 NdisWorkItemMiniportCallback,
                                                 &CallbackContext,
                                                 (PVOID *)&CallbackRoutine);

            if (CallbackRoutine != NULL)
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

                //
                //  Call the intermediate drivers callback routine.
                //
                (*CallbackRoutine)(Miniport->MiniportAdapterContext, CallbackContext);

                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }

            ProcessWorkItems = TRUE;
        }

        //
        //  Was there a reset requested?
        //
        if (Miniport->WorkQueue[NdisWorkItemResetRequested].Next != NULL)
        {
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("    Reset requested\n"));

            //
            //  We need to release the work item lock to
            //  indicate the status to the bindings
            //  and to call down to the miniport driver.
            //
            Status = ndisMProcessResetRequested(Miniport, &AddressingReset);

            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("    Reset is pending\n"));
                //
                //  The reset is still in progress so we need to stop
                //  processing workitems and wait for the completion.
                //
                break;
            }
            else
            {
                //
                //  Do step1 of the reset complete.
                //
                ndisMResetCompleteStage1(Miniport,
                                         Status,
                                         AddressingReset);
                if (Miniport->WorkQueue[NdisWorkItemRequest].Next == NULL)
                {
                    //
                    // somehow we did not queue a workitem due to address reset flag
                    //
                    AddressingReset = FALSE;
                }

                if (!AddressingReset || (Status != NDIS_STATUS_SUCCESS))
                {
                    //
                    //  If there is no addressing reset to be done or
                    //  the reset failed in some way then we tell the
                    //  bindings now.
                    //
                    ndisMResetCompleteStage2(Miniport);
                }
                else
                {
                    //
                    //  We MUST complete the filter requests within
                    //  the reset in progress workitem. Mainly because
                    //  we don't want to do any sends at this time.
                    //
                    ProcessWorkItems = TRUE;
                    continue;
                }
            }
        }

        //
        //  Process any requests?
        //
        if (Miniport->WorkQueue[NdisWorkItemRequest].Next != NULL)
        {
            //
            //  Process the requests.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
            ndisMDoRequests(Miniport);
            ProcessWorkItems = TRUE;
        }

        if (Miniport->WorkQueue[NdisWorkItemSend].Next != NULL)
        {
            //
            //  Process the sends.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
            NDISM_START_SENDS(Miniport);
            ProcessWorkItems = TRUE;
        }
    } while (ProcessWorkItems);

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMProcessDeferred\n"));
}


VOID
NdisMIndicateStatus(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:

    This function indicates a new status of the media/mini-port.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    GeneralStatus - The status to indicate.

    StatusBuffer - Additional information.

    StatusBufferSize - Length of the buffer.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open, NextOpen;
    NDIS_STATUS             Status;
    BOOLEAN                 fSwap = FALSE;
    BOOLEAN                 fInternal = FALSE;
    PNDIS_GUID              pNdisGuid = NULL;
    NTSTATUS                NtStatus;
    BOOLEAN                 fMediaConnectStateIndication = FALSE;
    KIRQL                   OldIrql;
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
    BOOLEAN                 fTimerCancelled;
#endif
    

    if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
    {
        fMediaConnectStateIndication = TRUE;
        //
        // Internal indications are media-sense indications. These are detected by
        // a StatusBufferSize of -2 and StatusBuffer of -1.
        //
        fInternal = ((StatusBufferSize == INTERNAL_INDICATION_SIZE) && (StatusBuffer == INTERNAL_INDICATION_BUFFER));
        if (fInternal)
        {
            StatusBufferSize = 0;
            StatusBuffer = NULL;
        }
    }

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // for internal requests the miniport SpinLock is already taken
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);


    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_FILTER_IM) &&
        fMediaConnectStateIndication)
    {
        //
        // if this is a media conenct/disconnect event from an IM filter
        // driver, skip wmi event
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        //
        //  Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, NULL, GeneralStatus);
    }

    if (pNdisGuid &&
        NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED))
    {
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   DataBlockSize = 0;
        PUCHAR                  ptmp;

        //
        //  If the data item is an array then we need to add in the number of
        //  elements.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = StatusBufferSize;
        }

        //
        // in case of media connect/disconnect status indication, include the
        // NIC's name in the WMI event
        //
        if (fMediaConnectStateIndication)
        {
            DataBlockSize += Miniport->MiniportName.Length + sizeof(WCHAR);
        }
        
        ndisSetupWmiNode(Miniport,
                         Miniport->pAdapterInstanceName,
                         DataBlockSize,
                         (PVOID)&pNdisGuid->Guid,
                         &wnode);

        if (NULL != wnode)
        {   
            //
            //  Increment ptmp to the start of the data block.
            //
            ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  If the status is an array but there is no data then complete it with no
                //  data and a 0 length
                //
                if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
                {
                    *((PULONG)ptmp) = 0;
                    ptmp += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;

                    //
                    //  Copy the data after the number of elements.
                    //
                    RtlCopyMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
                    ptmp += sizeof(ULONG) + StatusBufferSize;
                }
            }
            else
            {
                if ((NULL != StatusBuffer) && (0 != StatusBufferSize))
                {
                    //
                    //  Do we indicate any data up?
                    //
                    if ((pNdisGuid->Size != 0) && (pNdisGuid->Size != -1))
                    {
                        //
                        //  Copy the data into the buffer.
                        //
                        RtlCopyMemory(ptmp, StatusBuffer, StatusBufferSize);
                        ptmp += StatusBufferSize;
                    }
                }
            }

            if (fMediaConnectStateIndication)
            {
                //
                // for media connect/disconnect status, 
                // add the name of the adapter
                //
                RtlCopyMemory(ptmp,
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);
                    
            }


            //
            //  Indicate the event to WMI. WMI will take care of freeing
            //  the WMI struct back to pool.
            //
            NtStatus = IoWMIWriteEvent(wnode);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("    ndisMIndicateStatus: Unable to indicate the WMI event.\n"));

                FREE_POOL(wnode);
            }
        }
    }

    //
    //  Process the status code that was indicated.
    //
    switch (GeneralStatus)
    {
      case NDIS_STATUS_RING_STATUS:
        if (StatusBufferSize == sizeof(NDIS_STATUS))
        {
            Status = *((PNDIS_STATUS)StatusBuffer);

            if (Status & (NDIS_RING_LOBE_WIRE_FAULT |
                          NDIS_RING_HARD_ERROR |
                          NDIS_RING_SIGNAL_LOSS))
            {
                Miniport->TrResetRing = NDIS_MINIPORT_TR_RESET_TIMEOUT;
            }
            else
            {
                Miniport->TrResetRing = 0;
            }
        }
        break;

      case NDIS_STATUS_MEDIA_DISCONNECT:
        Miniport->MediaSenseDisconnectCount ++;

        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("NdisMIndicateStatus: NDIS_STATUS_MEDIA_DISCONNECT, Miniport %p, Flags: %lx, PnpFlags %lx, DevicePowerState %lx\n",
                Miniport,
                Miniport->Flags,
                Miniport->PnPFlags,
                Miniport->CurrentDevicePowerState));
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            fSwap = TRUE;
        }
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        if (!fInternal)
        {
            //
            // miniport can do media sense and indicate status
            //
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);
    
            //
            //  Is this a PM enabled miniport? And is dynamic power policy
            //  enabled for the miniport?
            //
            
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
            if (fSwap &&
                MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
                (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
                (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
            {
                //
                //  Are we already waiting for the disconnect timer to fire?
                //
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
                {
                    //
                    //  Mark the miniport as disconnecting and fire off the
                    //  timer.
                    //
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);

                    NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
                }
            }
#endif

        }
        
        break;

      case NDIS_STATUS_MEDIA_CONNECT:
        Miniport->MediaSenseConnectCount ++;
      
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("NdisMIndicateStatus: NDIS_STATUS_MEDIA_CONNECT, Miniport %p, Flags: %lx, PnpFlags %lx, DevicePowerState %lx\n",
                Miniport,
                Miniport->Flags,
                Miniport->PnPFlags,
                Miniport->CurrentDevicePowerState));
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            fSwap = TRUE;
        }
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        if (!fInternal)
        {
            //
            // miniport can do media sense and can indicate that status to Ndis. Do not poll
            //
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
            //
            // if media disconnect timer was set, cancel the timer
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                //
                //  Clear the disconnect wait bit and cancel the timer.
                //  IF the timer routine hasn't grabed the lock then we are ok.
                //
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

                NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
            }
#endif

        }

        break;
        
      default:
        break;
    }

    for (Open = Miniport->OpenQueue;
         (Open != NULL);
         Open = NextOpen)
    {
        //
        // in the case of NDISWAN, could be waiting foe a LINE_DOWN status
        // indication before it closes the adapter. so we only check for 
        // fMINIPORT_OPEN_CLOSING flag and make sure that the Open does not
        // go away while we are indicating the status by referencing the Open
        //
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            NextOpen = Open->MiniportNextOpen;
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            continue;
        }

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
        
        if (Open->StatusHandler != NULL)
        {
            Open->Flags |= fMINIPORT_STATUS_RECEIVED;
            
            if ((NDIS_STATUS_WAN_LINE_UP == GeneralStatus) ||
                (NDIS_STATUS_WAN_LINE_DOWN == GeneralStatus))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            }
            else
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }

            //
            // Call Protocol to indicate status
            //
            (Open->StatusHandler)(Open->ProtocolBindingContext,
                                    GeneralStatus,
                                    StatusBuffer,
                                    StatusBufferSize);

            if ((NDIS_STATUS_WAN_LINE_UP == GeneralStatus) ||
                (NDIS_STATUS_WAN_LINE_DOWN == GeneralStatus))
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            }
            else
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
        
        NextOpen = Open->MiniportNextOpen;

        ndisMDereferenceOpen(Open);
    }



    //
    // If we got a connect/disconnect, swap open handlers
    //
    if (fSwap)
    {
        if (NDIS_STATUS_MEDIA_CONNECT == GeneralStatus)
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED);
            ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_MEDIA_DISCONNECTED);
            Miniport->PacketIndicateHandler = Miniport->SavedPacketIndicateHandler;
        }
        else
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED);
            ndisMSwapOpenHandlers(Miniport, 
                                  NDIS_STATUS_NO_CABLE,
                                  fMINIPORT_STATE_MEDIA_DISCONNECTED);
            Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        }
        
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

VOID
NdisMIndicateStatusComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open, NextOpen;
    KIRQL                OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT_MINIPORT_LOCKED(Miniport);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = NextOpen)
    {
        if (OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | 
                                      fMINIPORT_OPEN_UNBINDING)))
        {
            NextOpen = Open->MiniportNextOpen;
            continue;
        }

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        
        if ((NULL != Open->StatusCompleteHandler) &&
            (Open->Flags & fMINIPORT_STATUS_RECEIVED))
        {
            //
            // Call Protocol to indicate status
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

            (Open->StatusCompleteHandler)(Open->ProtocolBindingContext);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }
        //1 this is not going to work if miniport driver does a complete for 
        //1 multiple status indications. need to use a ref count.
        Open->Flags &= ~fMINIPORT_STATUS_RECEIVED;
        
        NextOpen = Open->MiniportNextOpen;

        ndisMDereferenceOpen(Open);      
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}


VOID
NdisMWanIndicateReceive(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisLinkContext,
    IN  PUCHAR                  Packet,
    IN  ULONG                   PacketSize
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open;
    KIRQL                OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to indicate packet
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        *Status = (Open->ProtocolHandle->ProtocolCharacteristics.WanReceiveHandler)(
                                         NdisLinkContext,
                                         Packet,
                                         PacketSize);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

VOID
NdisMWanIndicateReceiveComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisLinkContext
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open;
    KIRQL                OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to indicate status
        //

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->ReceiveCompleteHandler)(NdisLinkContext);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

PNDIS_PACKET
NdisGetReceivedPacket(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacContext
    )
{
    PNDIS_OPEN_BLOCK        OpenBlock = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_PACKET            Packet = NULL;
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif

    Miniport = OpenBlock->MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisGetReceivedPacket - Miniort %p, Context %p\n",
            Miniport, MacContext));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // The following tests whether we came here via a IndicatePacket or IndicateRecieve
    //
    if ((INDICATED_PACKET(Miniport) == (PNDIS_PACKET)MacContext) &&
        (MacContext != NULL))
    {
        Packet = NDIS_GET_ORIGINAL_PACKET((PNDIS_PACKET)MacContext);

#ifdef TRACK_RECEIVED_PACKETS
        {
            PNDIS_STACK_RESERVED    NSR;
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                    0xA, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
        }
#endif
        
    }

    return Packet;
}


VOID
NdisReturnPackets(
    IN  PNDIS_PACKET *          PacketsToReturn,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    Decrement the refcount for the packet and return back to the miniport if 0.
    We take the Miniport lock here and hence are protected against other receives.

Arguments:

    PacketsToReturn - Pointer to the set of packets to return to the miniport
    NumberOfPackets - self descriptive

Return Value:

    None.

--*/
{
    UINT                    i;
    KIRQL                   OldIrql;
    
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
#endif

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    for (i = 0; i < NumberOfPackets; i++)
    {
        PNDIS_MINIPORT_BLOCK    Miniport;
        PNDIS_STACK_RESERVED    NSR;
        W_RETURN_PACKET_HANDLER Handler;
        PNDIS_PACKET            Packet;
        ULONG                   RefCount;
        BOOLEAN                 LocalLock = FALSE;

        Packet = PacketsToReturn[i];
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        ASSERT (Packet != NULL);

        Miniport = NSR->Miniport;
        ASSERT (Miniport != NULL);


        NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                0xB, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
                        
        ADJUST_PACKET_REFCOUNT(NSR, &RefCount);

        if (RefCount == 0)
        {
            NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                    0xC, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));

            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                LOCK_MINIPORT(Miniport, LocalLock);
            }
             
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) || LocalLock)
            {

#ifdef NDIS_TRACK_RETURNED_PACKETS
                if (NSR->RefCount != 0)
                {
                    DbgPrint("Packet %p is being returned back to the miniport"
                              "but the ref count is not zero.\n", Packet);
                    DbgBreakPoint();

                }
                    
                if (Packet->Private.Head == NULL)
                {
                    DbgPrint("Packet %p is being returned back to the miniport with NULL Head.\n", Packet);
                    DbgBreakPoint();
                }
        
#endif

            
                //
                //  Return the packet to the miniport
                //
                Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;
                NSR->Miniport = NULL;
                POP_PACKET_STACK(Packet);
                
#ifdef NDIS_TRACK_RETURNED_PACKETS
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    ULONG    SL;
                    if ((SL = CURR_STACK_LOCATION(Packet)) != -1)
                    {
                        DbgPrint("Packet %p is being returned back to the non-IM miniport"
                                 " with stack location %lx.\n", Packet, SL);
                        DbgBreakPoint();
                    }

                }
#endif

#ifdef TRACK_RECEIVED_PACKETS
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) &&
                    (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES))
                {
                    NDIS_STATUS OStatus = (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet);

                    if (OStatus != NDIS_STATUS_RESOURCES)
                    {
                        DbgPrint("Packet %p is being returned back to the non-deserialized miniport"
                                 " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", Packet, OStatus);
                        DbgBreakPoint();
                    }

                }
#endif
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        0xD, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));

                (*Handler)(Miniport->MiniportAdapterContext, Packet);
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    InterlockedDecrement((PLONG)&Miniport->IndicatedPacketsCount);
                }
             }
            else
            {
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        0xE, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
                //
                //  Miniport is busy so we need to queue this for later.
                //
                NSR->NextPacket = Miniport->ReturnPacketsQueue;
                Miniport->ReturnPacketsQueue = Packet;

                NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemReturnPackets, NULL);
            }

            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                UNLOCK_MINIPORT(Miniport, LocalLock);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
}

VOID
FASTCALL
ndisMDeferredReturnPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:
    ndisMDeferredReturnPackets is the deferred routine for returning the packets
    to serialized miniports.

Arguments:
    Miniport: a pointer to miniport block

Return Value:

    None.

    called with miniport's lock held.

--*/
{
    PNDIS_PACKET            Packet, NextPacket;
    PNDIS_STACK_RESERVED    NSR;
    W_RETURN_PACKET_HANDLER Handler;
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
#endif


    ASSERT_MINIPORT_LOCKED(Miniport);
    ASSERT(!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE));
        
    Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;

    for (Packet = Miniport->ReturnPacketsQueue;
         Packet != NULL;
         Packet = NextPacket)
    {
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NextPacket = NSR->NextPacket;
        NSR->Miniport = NULL;

        POP_PACKET_STACK(Packet);


#ifdef NDIS_TRACK_RETURNED_PACKETS
        {
            ULONG    SL;
            if ((SL = CURR_STACK_LOCATION(Packet)) != -1)
            {
                DbgPrint("Packet %p is being returned back to the non-IM miniport"
                         " with stack location %lx.\n", Packet, SL);
                DbgBreakPoint();
            }

        }
#endif

#ifdef TRACK_RECEIVED_PACKETS
        if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES)
        {
            NDIS_STATUS OStatus = (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet);

            if (OStatus != NDIS_STATUS_RESOURCES)
            {
                DbgPrint("Packet %p is being returned back to the non-deserialized miniport"
                         " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", Packet, OStatus);
                DbgBreakPoint();
            }

        }
#endif

        NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                0xF, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));


        (*Handler)(Miniport->MiniportAdapterContext, Packet);
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
        {
            InterlockedDecrement((PLONG)&Miniport->IndicatedPacketsCount);
        }

     }

    Miniport->ReturnPacketsQueue = NULL;
}


VOID
FASTCALL
ndisMAbortRequests(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    this routine will abort any pending requets.

Arguments:

Return Value:

Note:
    called at DPC with Miniport's lock held.

--*/
{
    PNDIS_REQUEST       Request;
    PNDIS_REQUEST       NextRequest;

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMAbortRequests\n"));

    //
    //  Clear the request timeout flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);

    //
    //  Dequeue any request work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);

    Request = Miniport->PendingRequest;
    Miniport->PendingRequest = NULL;

    //
    //  Go through the pending request queue and clear it out.
    //
    for (NOTHING; Request != NULL; Request = NextRequest)
    {
        //
        //  Get a pointer to the next request before we kill the
        //  current one.
        //

#if NDIS_LOG_ABORTED_REQUESTS
        ndisAbortedRequests[ndisAbortedRequestsIndex++] = *Request;
        if (ndisAbortedRequestsIndex == 16)
            ndisAbortedRequestsIndex = 0;
#endif
        NextRequest = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next;
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next = NULL;

        //
        //  Make this request the request in progress.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST);

        if (Request->RequestType == NdisRequestSetInformation)
        {
            ndisMSyncSetInformationComplete(Miniport, NDIS_STATUS_REQUEST_ABORTED, Request);
        }
        else
        {
            ndisMSyncQueryInformationComplete(Miniport, NDIS_STATUS_REQUEST_ABORTED, Request);
        }
    }

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMAbortRequests\n"));
}

VOID
FASTCALL
ndisMAbortPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        pOpen OPTIONAL,
    IN  PVOID                   CancelId OPTIONAL
    )

/*++

Routine Description:

    Aborts all outstanding packets on a mini-port.

    CALLED WITH THE LOCK HELD!!

Arguments:

    Miniport - Miniport to abort.

Return Value:

    None.

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    PNDIS_PACKET        OldFirstPendingPacket, NewFirstPendingPacket;
    LIST_ENTRY          SubmittedPackets;
    PLIST_ENTRY         List;
    PNDIS_PACKET        Packet;
    LIST_ENTRY          AbortedPackets;
    PNDIS_STACK_RESERVED    NSR;
    BOOLEAN             LookForFirstPendingPacket = FALSE;
    
    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMAbortPackets\n"));

    if (CancelId == NULL)
    {
        ASSERT_MINIPORT_LOCKED(Miniport);
    }

    //
    //  Dequeue any send work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

    OldFirstPendingPacket = Miniport->FirstPendingPacket;
    NewFirstPendingPacket = NULL;
    
    InitializeListHead(&SubmittedPackets);
    InitializeListHead(&AbortedPackets);
    
    if (CancelId)
        LookForFirstPendingPacket = TRUE;
    
    //
    // Clear out the packet queues.
    //
    Miniport->FirstPendingPacket = NULL;

    //
    //  Go through the list of packets and return them to the bindings
    //
    while (!IsListEmpty(&Miniport->PacketList))
    {

        List = RemoveHeadList(&Miniport->PacketList);
        Packet = CONTAINING_RECORD(List, NDIS_PACKET, WrapperReserved);

        if (LookForFirstPendingPacket)
        {
            if (Packet != OldFirstPendingPacket)
            {
                InsertTailList(&SubmittedPackets, List);
                continue;
            }
            else
            {
                //
                // we passed and saved the packets already submitted 
                // to the miniport
                //
                LookForFirstPendingPacket = FALSE;
            }
        }

        //
        //  Get the open that the packet came from.
        //
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

        if (CancelId)
        {
            if ((Open != pOpen) || (CancelId != NDIS_GET_PACKET_CANCEL_ID(Packet)))
            {
                if (NewFirstPendingPacket == NULL)
                {
                    //
                    // we found the first pending packet that we are going
                    // to put back after we are done
                    //
                    NewFirstPendingPacket = Packet;
                }
                //
                // put the packet back on the submitted queue
                //
                InsertTailList(&SubmittedPackets, List);
                continue;
            }
        }

        //
        // get rid of packet
        //

#if ARCNET
        //
        // Now free the arcnet header.
        //
        if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
            MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))

        {
            ndisMFreeArcnetHeader(Miniport, Packet, Open);
        }
#endif

        InsertTailList(&AbortedPackets, List);        
    }


    //
    // restore the Miniport->PacketList before aborting the packets that
    // should be aborted. Becuase while aborting the packets, we have to 
    // let go of spinlock and if we get more packets to send, they should 
    // be queued behind the existing ones queued on Miniport->PacketList.
    //
    if (CancelId)
    {
        //
        // we may have some packets that we should put back on miniport
        //
        while (!IsListEmpty(&SubmittedPackets))
        {
            List = RemoveHeadList(&SubmittedPackets);
            InsertTailList(&Miniport->PacketList, List);
        }
    }
    Miniport->FirstPendingPacket = NewFirstPendingPacket;

    //
    // now return all aborted packets to the protocols
    //
    while (!IsListEmpty(&AbortedPackets))
    {        
        List = RemoveHeadList(&AbortedPackets);
        Packet = CONTAINING_RECORD(List, NDIS_PACKET, WrapperReserved);
        
        //
        //  Get the open that the packet came from.
        //
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        Open = NSR->Open;
        
        //
        // Set this to mark that the packet is complete
        //
        NSR->Open = MAGIC_OPEN_I(7);
        POP_PACKET_STACK(Packet);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
            (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
        {
            ndisMFreeSGList(Miniport, Packet);
        }
        
        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
        
        (Open->SendCompleteHandler)(Open->ProtocolBindingContext,
                                    Packet,
                                    NDIS_STATUS_REQUEST_ABORTED);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        ndisMDereferenceOpen(Open);        
        
    }

    
    if (!CancelId)
    {
        //
        // only reset this flag if we are aborting -all- the packets
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE);
    }

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMAbortPackets\n"));
}

NDIS_STATUS
ndisMProcessResetRequested(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    OUT PBOOLEAN                pAddressingReset
    )
/*++

Routine Description:

Arguments:

Return Value:

Note: called at DPC with miniport spinlock held

--*/
{
    NDIS_STATUS         Status;

    do
    {

        //
        //  Dequeue the reset requested work item. this dequeuing will automatically
        //  queue the reset in progress work item.
        //
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetRequested, NULL);

        //
        // if adapter is getting halted, fail the reset request
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING))
        {            
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);
            Status = NDIS_STATUS_NOT_RESETTABLE;
            break;
        }

        //
        //  Set the reset in progress bit so that the send path can see it.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);

        ndisMSwapOpenHandlers(Miniport,
                              NDIS_STATUS_RESET_IN_PROGRESS, 
                              fMINIPORT_STATE_RESETTING);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        NdisMIndicateStatus(Miniport, NDIS_STATUS_RESET_START, NULL, 0);
        NdisMIndicateStatusComplete(Miniport);

        DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
            ("    Calling miniport reset\n"));

        //
        //  Call the miniport's reset handler.
        //
        Status = (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)(pAddressingReset,
                                                                                Miniport->MiniportAdapterContext);
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }while (FALSE);
    
    return(Status);
}


NDIS_STATUS
ndisMReset(
    IN  NDIS_HANDLE     NdisBindingHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 FreeLock;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>ndisMReset\n"));

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        FreeLock = TRUE;

        //
        // if adapter is getting halted, fail the reset request
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING))
        {            
            Status = NDIS_STATUS_NOT_RESETTABLE;
            break;
        }


        Status = NDIS_STATUS_RESET_IN_PROGRESS;

        //
        //  Is there already a reset in progress?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
            {
                break;
            }
        }
        else
        {
            if (NDISM_QUEUE_WORK_ITEM(Miniport,
                                      NdisWorkItemResetRequested,
                                      NdisBindingHandle) != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        Status = NDIS_STATUS_NOT_RESETTABLE;
        if (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler != NULL)
        {
            //
            //  Update the open's references.
            //
            M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
            Miniport->ResetOpen = Open;

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                BOOLEAN AddressingReset = FALSE;

                //
                //  Set the reset in progress flag.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_CALLING_RESET);
                
                ndisMSwapOpenHandlers(Miniport, 
                                      NDIS_STATUS_RESET_IN_PROGRESS, 
                                      fMINIPORT_STATE_RESETTING);

                //
                // wait for all the requests to come back.
                // note: this is not the same as waiting for all requests to complete
                // we just make sure the original request call has come back
                //
                do
                {
                    if (Miniport->RequestCount == 0)
                    {
                        break;
                    }
                    else
                    {
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                        NDIS_INTERNAL_STALL(50);
                        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    }
                } while (TRUE);

                //
                // ok, we got the permission to reset the adapter
                // make sure it was not turned off while we were waiting
                //
                if (Miniport->CurrentDevicePowerState !=  PowerDeviceD0)
                {
                    Miniport->ResetOpen = NULL;
                    //
                    // undo the call to ndisMSwapOpenHandlers, leaving the active handlers 
                    // the fake one.
                    //
                    Miniport->XState &= ~fMINIPORT_STATE_RESETTING;
                    Miniport->FakeStatus = NDIS_STATUS_NOT_SUPPORTED;
                    
                    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_CALLING_RESET);
                    Status = NDIS_STATUS_NOT_SUPPORTED;
                    ndisMDereferenceOpen(Open);
                    break;
                }

                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                FreeLock = FALSE;

                NdisMIndicateStatus(Miniport, NDIS_STATUS_RESET_START, NULL, 0);
                NdisMIndicateStatusComplete(Miniport);

                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                            ("Calling miniport reset\n"));

                //
                //  Call the miniport's reset handler at DPC
                //
                RAISE_IRQL_TO_DISPATCH(&OldIrql);

                Status = (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)(
                                          &AddressingReset,
                                          Miniport->MiniportAdapterContext);

                LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                
                if (NDIS_STATUS_PENDING != Status)
                {
                    NdisMResetComplete(Miniport, Status, AddressingReset);
                    Status = NDIS_STATUS_PENDING;
                }
                
            }
            else
            {
                BOOLEAN LocalLock;

                //
                //  Set the reset requested flag.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);

                //
                //  Grab the local lock.
                //
                LOCK_MINIPORT(Miniport, LocalLock);
                if (LocalLock)
                {
                    //
                    // If we did not lock down the miniport, then some other routine will
                    // do this processing for us.   Otherwise we need to do this processing.
                    //
                    NDISM_PROCESS_DEFERRED(Miniport);
                }

                UNLOCK_MINIPORT(Miniport, LocalLock);
                Status = NDIS_STATUS_PENDING;
            }
        }
    } while (FALSE);

    if (FreeLock)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
                ("<==ndisReset\n"));

    return(Status);
}


VOID
NdisMResetComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    )
/*++

Routine Description:

    This function indicates the completion of a reset.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the reset.

    AddressingReset - Do we have to submit a request to reload the address
    information.    This includes packet filter, and multicast/functional addresses.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>NdisMResetComplete\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);


    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
    {
        BAD_MINIPORT(Miniport, "Completing reset when one is not pending");
        KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                    0xF,
                    (ULONG_PTR)Miniport,
                    (ULONG_PTR)Status,
                    (ULONG_PTR)AddressingReset);
    }

    //
    //  Code that is common for synchronous and async resets.
    //
    ndisMResetCompleteStage1(Miniport, Status, AddressingReset);

    if (Miniport->WorkQueue[NdisWorkItemRequest].Next == NULL)
    {
        //
        // somehow we did not queue a workitem due to address reset flag
        //
        AddressingReset = FALSE;
    }

    if (!AddressingReset || (Status != NDIS_STATUS_SUCCESS))
    {
        //
        //  If there is no addressing reset to be done or
        //  the reset failed in some way then we tell the
        //  bindings now.
        //
        ndisMResetCompleteStage2(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("<==NdisMResetComplete\n"));
}

VOID
ndisMResetCompleteStage1(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    )
/*++

Routine Description:

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    
    if (NDIS_STATUS_NOT_RESETTABLE != Status)
    {
        //
        // Destroy all outstanding packets and requests.
        //
        ndisMAbortPackets(Miniport, NULL, NULL);

        ndisMAbortRequests(Miniport);

        //
        // we can clear this flag now and not any sooner. otherwise we may end up sending
        // a request down on another thread and aborting it ourselves
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CALLING_RESET);
        
        //
        // Check if we are going to have to reset theadapter again.
        // This happens when we are doing the reset because of a ring failure.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS))
        {
            if (Miniport->TrResetRing == 1)
            {
                if (Status == NDIS_STATUS_SUCCESS)
                {
                    Miniport->TrResetRing = 0;
                }
                else
                {
                    Miniport->TrResetRing = NDIS_MINIPORT_TR_RESET_TIMEOUT;
                }
            }
        }

        //
        //  If we need to reset the miniports filter settings then
        //  queue the necessary requests & work items.
        //
        if (AddressingReset && (Status == NDIS_STATUS_SUCCESS) &&
            ((Miniport->EthDB != NULL)  ||
             (Miniport->TrDB != NULL)   ||
#if ARCNET
             (Miniport->ArcDB != NULL)  ||
#endif
             (Miniport->FddiDB != NULL)))
        {
            ndisMRestoreFilterSettings(Miniport, NULL, TRUE);
        }
    } 
    else
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CALLING_RESET);
    }

    //
    //  Save the reset status as it is now.
    //
    Miniport->ResetStatus = Status;
}


VOID
FASTCALL
ndisMResetCompleteStage2(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    PNDIS_OPEN_BLOCK Open = NULL;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        Open = Miniport->ResetOpen;
        Miniport->ResetOpen = NULL;
    }
    else
    {
        ASSERT(Miniport->WorkQueue[NdisWorkItemResetInProgress].Next != NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetInProgress, &Open);
    }

    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS);

    ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_RESETTING);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    NdisMIndicateStatus(Miniport,
                        NDIS_STATUS_RESET_END,
                        &Miniport->ResetStatus,
                        sizeof(Miniport->ResetStatus));

    NdisMIndicateStatusComplete(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    //
    //  If a protocol initiated the reset then notify it of the completion.
    //
    if (NULL != Open)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->ResetCompleteHandler)(Open->ProtocolBindingContext, Miniport->ResetStatus);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMDereferenceOpen(Open);
    }

    //
    // if halt is waiting for this reset to complete, let it know we are done.
    //
    if (Miniport->ResetCompletedEvent)
        SET_EVENT(Miniport->ResetCompletedEvent);

}


//
//  The following routines are called in place of the original send, request,
//
NDIS_STATUS
ndisMFakeWanSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PVOID                   Packet
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle;
    NDIS_STATUS             Status;

    UNREFERENCED_PARAMETER(NdisLinkHandle);
    UNREFERENCED_PARAMETER(Packet);
    
    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeWanSend\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : Miniport->FakeStatus;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeWanSend\n"));

    return(Status);
}

NDIS_STATUS
ndisMFakeSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle;
    NDIS_STATUS             Status;

    UNREFERENCED_PARAMETER(Packet);

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeSend\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : Miniport->FakeStatus;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeSend\n"));

    return(Status);
}

VOID
ndisMFakeSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    UINT                    c;


    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeSendPackets\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : 
                                 ((Miniport->MediaType == NdisMediumArcnet878_2) ? 
                                  NDIS_STATUS_FAILURE : Miniport->FakeStatus);

    for (c = 0; c < NumberOfPackets; c++)
    {
        //
        //  For send packets we need to call the completion handler....
        //
        PNDIS_PACKET pPacket = PacketArray[c];

        MINIPORT_CLEAR_PACKET_FLAG(pPacket, fPACKET_CLEAR_ITEMS);

        (Open->SendCompleteHandler)(Open->ProtocolBindingContext, pPacket, Status);
    }

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeSendPackets\n"));
}


NDIS_STATUS
ndisMFakeReset(
    IN  NDIS_HANDLE             NdisBindingHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>ndisMFakeReset\n"));

    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

    }
    else
    {
        Status = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle->FakeStatus;
    }

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("<==ndisMFakeReset\n"));

    return(Status);
}

NDIS_STATUS
ndisMFakeRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;

    UNREFERENCED_PARAMETER(NdisRequest);

    //1 why do we have to check for NdisBindingHandle->MiniportHandle ?
    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

    }
    else
    {
        Status = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle->FakeStatus;
    }

    return(Status);
}


VOID
FASTCALL
ndisMRestoreOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UCHAR                   Flags                   
    )
/*++

Routine Description:

    This routine will restore the original open handlers to fake handlers so
    that protocol requests will be processed normally. this routine will check to 
    make sure that it can restore the handlers to the original ones because there
    may be more than one reasons to use the fake handlers

Arguments:

    Miniport    -   Pointer to the miniport block.
    Flags           Flags to -clear-

Return Value:
    None

Notes:
    Called with Miniport SpinLock held.

--*/
{
    PNDIS_OPEN_BLOCK    Open;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMRestoreOpenHandlers: Miniport %p, Current fake status %lx, Flags %lx\n",
            Miniport,
            Miniport->FakeStatus,
            (ULONG)Flags));

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);
    
    do
    {
        //
        // check to make sure we can restore the handlers
        //
        Miniport->XState &= ~Flags;

        if (Miniport->XState)
        {
            //
            //
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisMRestoreOpenHandlers: Keeping the fake handlers on Miniport %p, State flags %lx\n", 
                                    Miniport, Miniport->XState));

            //
            // if the only reason we are here is because media is disconnected 
            // make sure we put back the request handler
            //
            if ((Miniport->XState & fMINIPORT_STATE_MEDIA_DISCONNECTED) == fMINIPORT_STATE_MEDIA_DISCONNECTED)
            {
                for (Open = Miniport->OpenQueue;
                     Open != NULL;
                     Open = Open->MiniportNextOpen)
                {
                    
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
                    {
                        Open->RequestHandler = ndisMRequestX;
                    }
                    else
                    {
                        Open->RequestHandler = ndisMRequest;
                    }
                }
            }
            break;
        }
                
        for (Open = Miniport->OpenQueue;
             Open != NULL;
             Open = Open->MiniportNextOpen)
        {
            //
            //  Restore the handlers.
            //
            Open->SendHandler = (SEND_HANDLER)Miniport->SavedSendHandler;
            Open->SendPacketsHandler = (SEND_PACKETS_HANDLER)Miniport->SavedSendPacketsHandler;
            Open->CancelSendPacketsHandler = (W_CANCEL_SEND_PACKETS_HANDLER)Miniport->SavedCancelSendPacketsHandler;
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                Open->RequestHandler = ndisMRequestX;
            }
            else
            {
                Open->RequestHandler = ndisMRequest;
            }
            
            Open->ResetHandler = ndisMReset;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisMRestoreOpenHandlers: Miniport %p\n", Miniport));
    
    return;

}


VOID
FASTCALL
ndisMSwapOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  UCHAR                   Flags
    )
/*++

Routine Description:

    This routine will swap the miniport handlers to fake handlers so that
    protocol requests will be failed cleanly.

Arguments:

    Miniport    -   Pointer to the miniport block.

Return Value:
    None

Notes: Called with miniport SpinLock held

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMSwapOpenHandlers: Miniport %p, FakeStatus %lx, Flags %lx\n",
                Miniport,
                Status,
                (ULONG)Flags));

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    Miniport->XState |= Flags;

    //
    //  Save the status that should be returned whenever someone
    //  calls one of the routines below.
    //
    Miniport->FakeStatus = Status;

    //
    //  Swap the handlers for each open queued to the miniport.
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {

        //  
        //  Swap the send handler.
        //
        if ((NdisMediumWan == Miniport->MediaType) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
        {
            (PVOID)Open->SendHandler = (PVOID)ndisMFakeWanSend;
        }
        else
        {
            Open->SendHandler = ndisMFakeSend;
        }

        //
        //  Swap the send packets handler.
        //
        Open->SendPacketsHandler = ndisMFakeSendPackets;

        //
        //  Swap the reset handler.
        //
        Open->ResetHandler = ndisMFakeReset;

        //
        //  Swap the request handler, but not for media-sense case
        //
        if (NDIS_STATUS_NO_CABLE != Status)
        {
            Open->RequestHandler = ndisMFakeRequest;
        }

        //
        // set the cancel send packets ahndler to null
        //
        Open->CancelSendPacketsHandler = NULL;

        //
        // swap the indicate packet handler
        //
        
    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisMSwapOpenHandlers: Miniport %p\n", Miniport));
}


VOID
NdisMSetAttributes(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  BOOLEAN                 BusMaster,
    IN  NDIS_INTERFACE_TYPE     AdapterType
    )
/*++

Routine Description:

    This function sets specific information about an adapter.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    MiniportAdapterContext - Context to pass to all Miniport driver functions.

    BusMaster - TRUE if a bus mastering adapter.

Return Value:

    None.


--*/
{
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetAttributes: Miniport %p\n", MiniportAdapterHandle));

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         MiniportAdapterContext,
                         0,
                         BusMaster ? NDIS_ATTRIBUTE_BUS_MASTER : 0,
                         AdapterType);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMSetAttributes: Miniport %p\n", MiniportAdapterHandle));
}

VOID
NdisMSetAttributesEx(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  UINT                    CheckForHangTimeInSeconds OPTIONAL,
    IN  ULONG                   AttributeFlags,
    IN  NDIS_INTERFACE_TYPE     AdapterType  OPTIONAL
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetAttributesEx: Miniport %p\n", Miniport));

    Miniport->MiniportAdapterContext = MiniportAdapterContext;
    Miniport->MiniportAttributes = AttributeFlags;
    
    //
    //  In the case of a first time initialization this will fail out since there
    //  will not be any opens.  In the case of a second time initialization (power up)
    //  we need to fix up the existing open block's adapter contexts.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        Open->MiniportAdapterContext = MiniportAdapterContext;
    }
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    Miniport->AdapterType = AdapterType;

    //
    // Set the new timeout value in ticks. Each tick is NDIS_CFHANG_TIME_SECONDS long.
    //
    if (CheckForHangTimeInSeconds != 0)
    {
        if (CheckForHangTimeInSeconds < NDIS_CFHANG_TIME_SECONDS)
        {
            CheckForHangTimeInSeconds = NDIS_CFHANG_TIME_SECONDS;
        }
        Miniport->CFHangTicks = (USHORT)(CheckForHangTimeInSeconds/NDIS_CFHANG_TIME_SECONDS);
    }

    //
    // this is used by NDIS test to report the characteristics of the miniport
    //
    Miniport->InfoFlags |= NDIS_MINIPORT_USE_NEW_BITS;
    
    //
    // Is this a bus master.
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_BUS_MASTER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_BUS_MASTER);
        Miniport->InfoFlags |= NDIS_MINIPORT_BUS_MASTER;
    }

    //
    // Should we ignore the packet queues?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_PACKET_QUEUE);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_PACKET_QUEUE;
    }

    //
    // Should we ignore the request queues?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_REQUEST_QUEUE);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_REQUEST_QUEUE;
    }

    //
    // Should we ignore token ring errors?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_TOKEN_RING_ERRORS;
    }

    //
    // Is this an intermediate miniport?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
        Miniport->InfoFlags |= NDIS_MINIPORT_INTERMEDIATE_DRIVER;
    }

    //
    // does the device wants us not to halt it on suspend?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND)
    {
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND);
        Miniport->InfoFlags |= NDIS_MINIPORT_NO_HALT_ON_SUSPEND;
    }

    //
    // fMINIPORT_IS_CO flag is set on miniports -before- initializing the miniport based
    // on existence of some handlers in driver characteristics
    // allow the driver to override this. do this -before- the test for deserialization.
    // if these drivers are deserialized, they have to make it explicit.
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_NOT_CO_NDIS)
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IS_CO);
    }
    
    if (((AttributeFlags & NDIS_ATTRIBUTE_DESERIALIZE) ||
         MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO)))
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_DESERIALIZE);
        Miniport->InfoFlags |= NDIS_MINIPORT_DESERIALIZE;
        
        NdisInitializeTimer(&Miniport->WakeUpDpcTimer,
                            ndisMWakeUpDpcX,
                            Miniport);


        //
        // Reset handlers to the de-serialized ones
        //

        Miniport->SendCompleteHandler = ndisMSendCompleteX;
    }
    else
    {
        NdisInitializeTimer(&Miniport->WakeUpDpcTimer,
                            ndisMWakeUpDpc,
                            Miniport);
    }
    

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        CoReferencePackage();
    }

    if ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion > 5) ||
        ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion == 5) &&
         (Miniport->DriverHandle->MiniportCharacteristics.MinorNdisVersion >= 1)) ||
        (AttributeFlags & NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS))
    {
        MINIPORT_SET_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS);
        Miniport->InfoFlags |= NDIS_MINIPORT_USES_SAFE_BUFFER_APIS;
    }

    if (AttributeFlags & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK)
    {
        Miniport->InfoFlags |= NDIS_MINIPORT_SURPRISE_REMOVE_OK;
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMSetAttributesEx: Miniport %p\n", Miniport));
}

NDIS_STATUS
NdisMSetMiniportSecondary(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_HANDLE             PrimaryMiniportHandle
    )
/*++

Routine Description:

    This associates a miniport with another marking current miniport as secondary
    with the link to primary. The secondary has no bindings and opens blocked.

Arguments:

    MiniportHandle        - Miniport block for this miniport
    PrimaryMiniportHandle - Miniport block for the primary miniport

Return Value:

    NDIS_STATUS_SUCCESS or NDIS_STATUS_NOT_SUPPORTED

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport, PrimaryMiniport;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetMiniportSecondary: Miniport %p, PrimaryMiniport %p\n",
                MiniportHandle, PrimaryMiniportHandle));

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    ASSERT(Miniport != NULL);

    PrimaryMiniport = (PNDIS_MINIPORT_BLOCK)PrimaryMiniportHandle;
    ASSERT(PrimaryMiniport != NULL);

    if ((Miniport->DriverHandle != PrimaryMiniport->DriverHandle)   ||
        (Miniport->PrimaryMiniport != Miniport))
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;
    }
    else
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SECONDARY);
        ndisCloseMiniportBindings(Miniport);

        Miniport->PrimaryMiniport = PrimaryMiniport;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMSetMiniportSecondary: Miniport %p, PrimaryMiniport %p\n",
                MiniportHandle, PrimaryMiniportHandle));

    return Status;
}


NDIS_STATUS
NdisMPromoteMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:

    This promotes a secondary miniport to a primary.

Arguments:

    MiniportHandle        - Miniport block for this miniport

Return Value:

    NDIS_STATUS_SUCCESS or NDIS_STATUS_FAILURE

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_WORK_ITEM         WorkItem;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PNDIS_MINIPORT_BLOCK    OldPrimaryMiniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    KIRQL                   OldIrql;


    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMPromoteMiniport: Miniport %p\n", MiniportHandle));

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    ASSERT(Miniport != NULL);

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY) ||
            (Miniport->PrimaryMiniport == Miniport) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS))
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }

        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (WorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }

        OldPrimaryMiniport = Miniport->PrimaryMiniport;
        NdisInitializeWorkItem(WorkItem, ndisQueuedCheckAdapterBindings, Miniport);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SECONDARY);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);
        MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // Make all miniports belonging to this cluster point
        // to this new primary (including this primary itself).
        //
        
        MiniBlock = Miniport->DriverHandle;
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        {
            PNDIS_MINIPORT_BLOCK    TmpMiniport = NULL;

            for (TmpMiniport = MiniBlock->MiniportQueue;
                 TmpMiniport != NULL;
                 TmpMiniport = TmpMiniport->NextMiniport)
            {
                if (TmpMiniport->PrimaryMiniport == OldPrimaryMiniport)
                {
                    //
                    // TmpMiniport was a secondary of the old primary
                    // Lets make it point to the new Primary (this miniport)
                    //
                    TmpMiniport->PrimaryMiniport = Miniport;
                }
            }
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

        //
        // Queue a work-item to notify protocols and make sure the miniport does not go
        // away while we are waiting
        //
        NdisScheduleWorkItem(WorkItem);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMPromoteMiniport: Miniport %p\n", MiniportHandle));

    return Status;
}

NDIS_STATUS
ndisQueueBindWorkitem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:
    This routine queues a workitem to handle initiating the bindings
    between a miniport and the protocols.
    
Arguments:
    Miniport
    
Return Value:
    NDIS_STATUS_SUCCESS if the workitem is successfully queued.

--*/

{
    PNDIS_WORK_ITEM WorkItem;
    NDIS_STATUS     Status;
    KIRQL           OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisQueueBindWorkitem: Miniport %p\n", Miniport));

    do
    {
        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_WORK_ITEM), NDIS_TAG_WORK_ITEM);

        if (WorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        PnPReferencePackage();
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS))
        {
            //
            // miniport is halting or halted. abort
            //
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }
        else
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);

            MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            
            WorkItem->Routine = (NDIS_PROC)ndisQueuedCheckAdapterBindings;
            WorkItem->Context = (PVOID)Miniport;

            INITIALIZE_WORK_ITEM((PWORK_QUEUE_ITEM)WorkItem->WrapperReserved,
                                 ndisWorkItemHandler,
                                 WorkItem);

            XQUEUE_WORK_ITEM((PWORK_QUEUE_ITEM)WorkItem->WrapperReserved, 
                              CriticalWorkQueue);                                    
            
            Status = NDIS_STATUS_SUCCESS;
        }
    
        PnPDereferencePackage();
        
    }while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisQueueBindWorkitem: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}

VOID
ndisQueuedCheckAdapterBindings(
    IN  PNDIS_WORK_ITEM     pWorkItem,
    IN  PVOID               Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    NTSTATUS                NtStatus;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisQueuedCheckAdapterBindings: Miniport %p\n", Miniport));

    PnPReferencePackage();
    
    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS) ||
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY)           ||
            ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
            (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
            (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved)))
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);
            
            if (Miniport->QueuedBindingCompletedEvent)
            {
                SET_EVENT(Miniport->QueuedBindingCompletedEvent);
            }
            
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);


            ndisCheckAdapterBindings(Miniport, NULL);
            
            //
            // Set the device class association so that people can reference this.
            //
            NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);

            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisQueuedCheckAdapterBindings: IoSetDeviceInterfaceState failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
            }
            
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);

            if (Miniport->QueuedBindingCompletedEvent)
            {
                SET_EVENT(Miniport->QueuedBindingCompletedEvent);
            }
            
        }
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }while (FALSE);

    PnPDereferencePackage();


    MINIPORT_DECREMENT_REF(Miniport);

    FREE_POOL(pWorkItem);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisQueuedCheckAdapterBindings: Miniport %p\n", Miniport));
}


BOOLEAN
ndisIsMiniportStarted(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    )
/*++

Routine Description:

    this routine checks to make sure the miniport has been initialized by walking
    the miniport queue on the driver
    returns TRUE is the Miniport has been started, otherwise returns FALSE

Arguments:

    Miniport    -   Miniport

Return Value:

    TRUE if started, FALSE otherwise

--*/
{
    //1 make sure that everywhere we call this, the miniport is valid.
    //1 i.e. make sure we do not rely on this routine to check for us if a 
    //1 miniport structure is valid or not.

    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    TmpMiniport = NULL;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisIsMiniportStarted: Miniport %p\n", Miniport));

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
    for (TmpMiniport = ndisMiniportList;
         TmpMiniport != NULL;
         TmpMiniport = TmpMiniport->NextGlobalMiniport)
    {
        if (TmpMiniport == Miniport)
        {
            break;
        }
    }

    if (TmpMiniport)
    {
        TmpMiniport = NULL;
        
        //
        // find the miniport on driver queue
        //
        MiniBlock = Miniport->DriverHandle;

        if (MiniBlock)
        {

            ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

            for (TmpMiniport = MiniBlock->MiniportQueue;
                 TmpMiniport != NULL;
                 TmpMiniport = TmpMiniport->NextMiniport)
            {
                if (TmpMiniport == Miniport)
                {
                    break;
                }
            }

            RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
        }

    }

    RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);


    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisIsMiniportStarted: Miniport %p, Started %lx\n", Miniport, (TmpMiniport == Miniport)));

    return (TmpMiniport == Miniport);
}

BOOLEAN
FASTCALL
ndisQueueOpenOnMiniport(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PNDIS_OPEN_BLOCK            Open
    )

/*++

Routine Description:

    inserts an open block to the list of opens for a Miniport.

Arguments:

    OpenP - The open block to be queued.
    Miniport - The Miniport block to queue it on.

    NOTE: called with miniport lock held. for serialized miniports, the local lock is held as well

Return Value:

    None.

--*/
{
    BOOLEAN rc;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
        ("==>ndisQueueOpenOnMiniport: Miniport %p, Open %p\n", Miniport, Open));

    //
    // we can not reference the package here because this routine can
    // be claled at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    
    if ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
        (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
        (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved))
    {
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisQueueOpenOnMiniport: failing open because the miniport is not started, Miniport %p, Open %p\n", Miniport, Open));
        rc = FALSE;
    }
    else
    {
        Open->MiniportNextOpen = Miniport->OpenQueue;
        Miniport->OpenQueue = Open;
        Miniport->NumOpens++;
        ndisUpdateCheckForLoopbackFlag(Miniport);
        rc = TRUE;
    }
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
        ("<==ndisQueueOpenOnMiniport: Miniport %p, Open %p, rc %lx\n", Miniport, Open, rc));

    return rc;
}

/*++

VOID
ndisMSetIndicatePacketHandler(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

this function sets the Miniport's indicate packet handler during 
initial initialization 

--*/

VOID
ndisMSetIndicatePacketHandler(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    KIRQL   OldIrql;
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    //
    // set the PacketIndicateHandler and SavedPacketIndicateHandler
    // 
    switch(Miniport->MediaType)
    {
      case NdisMedium802_3:
        Miniport->SavedPacketIndicateHandler =  ethFilterDprIndicateReceivePacket;
        break;

      case NdisMedium802_5:
        Miniport->SavedPacketIndicateHandler =  trFilterDprIndicateReceivePacket;
        break;

      case NdisMediumFddi:
        Miniport->SavedPacketIndicateHandler =  fddiFilterDprIndicateReceivePacket;
        break;

#if ARCNET
      case NdisMediumArcnet878_2:
        Miniport->SavedPacketIndicateHandler =  ethFilterDprIndicateReceivePacket;
        Miniport->SendPacketsHandler = ndisMFakeSendPackets;
        break;
#endif

      case NdisMediumWan:
        break;

      case NdisMediumIrda:
      case NdisMediumWirelessWan:
      case NdisMediumLocalTalk:
        //
        // fall through
        //
      default:
        Miniport->SavedPacketIndicateHandler = ndisMIndicatePacket;
        break;
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        Miniport->PacketIndicateHandler = Miniport->SavedPacketIndicateHandler;
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

BOOLEAN
ndisReferenceOpenByHandle(
    PNDIS_OPEN_BLOCK    Open,
    BOOLEAN             fRef
    )

{
    KIRQL               OldIrql;
    PNDIS_OPEN_BLOCK    *ppOpen;
    BOOLEAN             rc = FALSE;

    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);

    for (ppOpen = &ndisGlobalOpenList; *ppOpen != NULL; ppOpen = &(*ppOpen)->NextGlobalOpen)
    {
        if (*ppOpen == Open)
        {
            ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock)

            if (fRef)
            {
                if ((!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING)) &&
                    (Open->References != 0))
                {
                    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
                    rc = TRUE;
                }
            }
            else
            {
                rc = TRUE;
            }
            
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);

    return rc;
}

BOOLEAN
ndisRemoveOpenFromGlobalList(
    IN  PNDIS_OPEN_BLOCK    Open
    )
{
    PNDIS_OPEN_BLOCK    *ppOpen;
    KIRQL               OldIrql;
    BOOLEAN             rc = FALSE;
    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
    
    for (ppOpen = &ndisGlobalOpenList; *ppOpen != NULL; ppOpen = &(*ppOpen)->NextGlobalOpen)
    {
        if (*ppOpen == Open)
        {
            *ppOpen = Open->NextGlobalOpen;
            rc = TRUE;
            break;
        }
    }
    
    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);

    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndisdbg.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndisdbg.h

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jul-14  Kyle Brandon    Added debug supported for conditional breaks.
--*/
#ifndef __DEBUG_H
#define __DEBUG_H

//
//  Define module numbers.
//
#define  MODULE_NDIS            0x00010000
#define  MODULE_DATA            0x00020000
#define  MODULE_INIT            0x00030000
#define  MODULE_INITPNP         0x00040000
#define  MODULE_COMMON          0x00050000
#define  MODULE_CONFIG          0x00060000
#define  MODULE_CONFIGM         0x00070000
#define  MODULE_BUS             0x00080000
#define  MODULE_TIMER           0x00090000
#define  MODULE_TIMERM          0x000A0000
#define  MODULE_MINIPORT        0x000B0000
#define  MODULE_REQUESTM        0x000C0000
#define  MODULE_MINISUB         0x000D0000
#define  MODULE_MAC             0x000E0000
#define  MODULE_PROTOCOL        0x000F0000
#define  MODULE_EFILTER         0x00100000
#define  MODULE_TFILTER         0x00110000
#define  MODULE_FFILTER         0x00120000
#define  MODULE_AFILTER         0x00130000
#define  MODULE_NFILTER         0x00140000
#define  MODULE_DEBUG           0x00150000
#define  MODULE_MININT          0x00160000
#define  MODULE_SENDM           0x00170000
#define  MODULE_NDIS_CO         0x00180000
#define  MODULE_NDIS_PNP        0x00190000
#define  MODULE_POWER           0x001A0000
#define  MODULE_WMI             0x001B0000
#define  MODULE_DMA             0x001C0000
#define  MODULE_CDATA           0x001D0000
#define  MODULE_VERIFY          0x001E0000


#define DBG_LEVEL_INFO          0x00000000
#define DBG_LEVEL_LOG           0x00000800
#define DBG_LEVEL_WARN          0x00001000
#define DBG_LEVEL_ERR           0x00002000
#define DBG_LEVEL_FATAL         0x00003000

#define DBG_COMP_INIT           0x00000001
#define DBG_COMP_CONFIG         0x00000002
#define DBG_COMP_SEND           0x00000004
#define DBG_COMP_RECV           0x00000008
#define DBG_COMP_PROTOCOL       0x00000010
#define DBG_COMP_BIND           0x00000020
#define DBG_COMP_BUSINFO        0x00000040
#define DBG_COMP_REG            0x00000080
#define DBG_COMP_MEMORY         0x00000100
#define DBG_COMP_FILTER         0x00000200
#define DBG_COMP_REQUEST        0x00000400
#define DBG_COMP_WORK_ITEM      0x00000800
#define DBG_COMP_PNP            0x00001000
#define DBG_COMP_PM             0x00002000
#define DBG_COMP_OPENREF        0x00004000
#define DBG_COMP_LOCKS          0x00008000
#define DBG_COMP_RESET          0x00010000
#define DBG_COMP_WMI            0x00020000
#define DBG_COMP_CO             0x00040000
#define DBG_COMP_REF            0x00080000
#define DBG_COMP_ALL            0xFFFFFFFF

#if DBG

#if defined(MEMPRINT)
#include "memprint.h"                           // DavidTr's memprint program at ntos\srv
#endif  // MEMPRINT

VOID
ndisDbgPrintUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

#define DBGPRINT(Component, Level, Fmt)                                     \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            DbgPrint("***NDIS*** (%x, %d) ",                                \
                    MODULE_NUMBER >> 16, __LINE__);                         \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }
        
#define DBGPRINT_RAW(Component, Level, Fmt)                                 \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }

#define DBGPRINT_UNICODE(Component, Level, UString)                         \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            ndisDbgPrintUnicodeString(UString);                             \
        }                                                                   \
    }

#define DBGBREAK(Component, Level)                                          \
    {                                                                       \
        if ((Level >= ndisDebugLevel) && ((ndisDebugSystems & Component) == Component)) \
        {                                                                   \
            DbgPrint("***NDIS*** DbgBreak @ %x, %d\n",                      \
                        MODULE_NUMBER, __LINE__);                           \
            DbgBreakPoint();                                                \
        }                                                                   \
    }

#define IF_DBG(Component, Level)    if ((Level >= ndisDebugLevel) && ((ndisDebugSystems & Component) == Component))

#define DbgIsNonPaged(_Address)     (MmIsNonPagedSystemAddressValid((PVOID)(_Address)))

#define DbgIsNull(_Ptr)  ( ((PVOID)(_Ptr)) == NULL )

#else

#define DBGPRINT(Component, Level, Fmt)
#define DBGPRINT_RAW(Component, Level, Fmt)
#define DBGPRINT_UNICODE(Component, Level, UString)
#define DBGBREAK(Component, Level)

#define DbgIsNonPaged(_Address) TRUE
#define DbgIsNull(_Ptr)         FALSE

#define IF_DBG(Component, Level)    if (FALSE)

#define ndisDbgPrintUnicodeString(UnicodeString)

#endif  // DBG

#ifdef TRACK_MOPEN_REFCOUNTS
//
// Declarations for ndis' logfile. 
// The purpose of the logfile is to log events 
// relating to the increments and decrements of an mopen's
// refcounts.
//

//
// The Ndis Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_LOGFILE_SIZE 0x10000

//
// NdisLogfile Events
//

#define NDIS_INCREMENT_M_OPEN_REFCOUNT              0x0101
#define NDIS_DECREMENT_M_OPEN_REFCOUNT              0x0102

#define NDIS_INCREMENT_OPEN_AF_NOTIFICATION         0xAF01
#define NDIS_DECREMENT_OPEN_AF_NOTIFICATION         0xAF02

/*
VOID 
NDIS_APPEND_MOPEN_LOGFILE(
    IN  USHORT EventCode,
    IN  USHORT LineNumber,
    IN  UINT   ModuleNumber,
    IN  UINT   Arg1,
    IN  UINT   Arg2
    );

*/
#define NDIS_APPEND_MOPEN_LOGFILE( _Ev, _L, _M, _A1, _A2)                       \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)(_Ev);                     \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)((_M) | (_L));             \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)_A1;                       \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)_A2;


#else  // TRACK_MOPEN_REFCOUNTS
 
#define NDIS_APPEND_MOPEN_LOGFILE( _Ev, _L, _M, _A1, _A2)

#endif // TRACK_MOPEN_REFCOUNTS

#ifdef TRACK_MINIPORT_REFCOUNTS
//
// Declarations for ndis' logfile. 
// The purpose of the logfile is to log events 
// relating to the increments and decrements of a miniport's
// refcounts.
//

//
// The Ndis Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_MINIPORT_LOGFILE_SIZE 0x10000

//
// NdisLogfile Events
//
#define NDIS_INCREMENT_MINIPORT_REFCOUNT                0x0101
#define NDIS_DECREMENT_MINIPORT_REFCOUNT                0x0102
#define NDIS_SET_MINIPORT_REFCOUNT                      0x0103

/*
VOID 
NDIS_APPEND_MINIPORT_LOGFILE( USHORT EventCode,
                                USHORT LineNumber,
                                UINT    ModuleNumber,
                                UINT    Arg1,
                                UINT    Arg2 );

*/

#define NDIS_APPEND_MINIPORT_LOGFILE( _Ev, _L, _Mo, _Mi, _R)                            \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (ULONG_PTR)(_Ev);             \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (ULONG_PTR)((_Mo) | (_L));    \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (ULONG_PTR)(_Mi);             \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (ULONG_PTR)(_R);


#define M_LOG_MINIPORT_INCREMENT_REF(_Mi, _L, _Mo)                          \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_INCREMENT_MINIPORT_REFCOUNT,              \
                               _L,                                          \
                               _Mo,                                         \
                               (_Mi),                                       \
                               (_Mi)->Ref.ReferenceCount);

#define M_LOG_MINIPORT_INCREMENT_REF_CREATE(_Mi, _L, _Mo)                   \
NDIS_APPEND_MINIPORT_LOGFILE(IoGetCurrentProcess(),                         \
                               _L,                                          \
                               _Mo,                                         \
                               (_Mi),                                       \
                               (_Mi)->Ref.ReferenceCount);

#define M_LOG_MINIPORT_DECREMENT_REF(_Mi, _R)                               \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_DECREMENT_MINIPORT_REFCOUNT,              \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));
                               
#define M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_Mi, _R)                         \
NDIS_APPEND_MINIPORT_LOGFILE(IoGetCurrentProcess(),                         \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));

#define M_LOG_MINIPORT_SET_REF(_Mi, _R)                                     \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_SET_MINIPORT_REFCOUNT,                    \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));
                               
#else  // TRACK_MINIPORT_REFCOUNTS
 
#define M_LOG_MINIPORT_INCREMENT_REF(_Mi, _L, _Mo)
#define M_LOG_MINIPORT_INCREMENT_REF_CREATE(_Mi, _L, _Mo)
#define M_LOG_MINIPORT_DECREMENT_REF(_M, _R)
#define M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_Mi, _R)
#define M_LOG_MINIPORT_SET_REF(_M, _R)

#endif // TRACK_MINIPORT_REFCOUNTS


#ifdef TRACK_RECEIVED_PACKETS

//
// The Ndis Received Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_RCV_LOGFILE_SIZE 0x10000


/*
VOID 
NDIS_APPEND_RCV_LOGFILE(PVOID   Packet,
                        PVOID   Miniport,
                        PVOID   CurrentThread,
                        ULONG   Code,
                        ULONG   StackLocation,
                        ULONG   Ref,
                        ULONG   XRef,
                        ULONG   Status
                        );

*/

#define NDIS_APPEND_RCV_LOGFILE(_PACKET, _MINIPORT, _THREAD, _CODE, _SP, _REF, _XREF, _STATUS)      \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_PACKET);                                    \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_MINIPORT);                                  \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_THREAD);                                    \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_CODE<<24)|((_SP&0xff)<<16)|((_REF&0xf)<<12)|(_XREF<<8)|(_STATUS&0xff));
        

//        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_Mo) | (_L));                                              \
//        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_SP<<24)|((_REF&0xff)<<16)|(_XREF<<8)|(_Status&0xff));


#else  // TRACK_MINIPORT_REFCOUNTS

#define NDIS_APPEND_RCV_LOGFILE( _P, _L, _Mo, _SP, _REF, _XREF, _Status, _Arg1)

#endif // TRACK_RECEIVED_PACKETS

#define DBG_LEVEL_INFO          0x00000000
#define DBG_LEVEL_LOG           0x00000800
#define DBG_LEVEL_WARN          0x00001000
#define DBG_LEVEL_ERR           0x00002000
#define DBG_LEVEL_FATAL         0x00003000

#endif  //  __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\minisub.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS wrapper functions

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MINISUB

VOID
NdisAllocateSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    INITIALIZE_SPIN_LOCK(&SpinLock->SpinLock);
}

VOID
NdisFreeSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    UNREFERENCED_PARAMETER(SpinLock);
}

VOID
NdisAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_ACQUIRE_SPIN_LOCK(SpinLock, &SpinLock->OldIrql);
}

VOID
NdisReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_RELEASE_SPIN_LOCK(SpinLock, SpinLock->OldIrql);
}

VOID
NdisDprAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_ACQUIRE_SPIN_LOCK_DPC(SpinLock);
    SpinLock->OldIrql = DISPATCH_LEVEL;
}

VOID
NdisDprReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_RELEASE_SPIN_LOCK_DPC(SpinLock);
}

#undef NdisFreeBuffer
VOID
NdisFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    )
{
    IoFreeMdl(Buffer);
}

#undef NdisQueryBuffer
VOID
NdisQueryBuffer(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length
    )
{
    if (ARGUMENT_PRESENT(VirtualAddress))
    {
        *VirtualAddress = MDL_ADDRESS(Buffer);
    }
    *Length = MDL_SIZE(Buffer);
}


VOID
NdisQueryBufferSafe(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length,
    IN  MM_PAGE_PRIORITY        Priority
    )
{
    if (ARGUMENT_PRESENT(VirtualAddress))
    {
        *VirtualAddress = MDL_ADDRESS_SAFE(Buffer, Priority);
    }
    *Length = MDL_SIZE(Buffer);
}

VOID
NdisQueryBufferOffset(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   Offset,
    OUT PUINT                   Length
    )
{
    *Offset = MDL_OFFSET(Buffer);
    *Length = MDL_SIZE(Buffer);
}

VOID
NdisGetFirstBufferFromPacket(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength
    )
{
    PNDIS_BUFFER    pBuf;

    pBuf = Packet->Private.Head;
    *FirstBuffer = pBuf;
    if (pBuf)
    {
        *FirstBufferVA =    MmGetSystemAddressForMdl(pBuf);
        *FirstBufferLength = *TotalBufferLength = MmGetMdlByteCount(pBuf);
        for (pBuf = pBuf->Next;
             pBuf != NULL;
             pBuf = pBuf->Next)
        {
            *TotalBufferLength += MmGetMdlByteCount(pBuf);
        }
    }
    else
    {
        *FirstBufferVA = 0;
        *FirstBufferLength = 0;
        *TotalBufferLength = 0;
    }
}

//
// safe version of NdisGetFirstBufferFromPacket
// if the memory described by the first buffer can not be mapped
// this function will return NULL for FirstBuferVA
//
VOID
NdisGetFirstBufferFromPacketSafe(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength,
    IN  MM_PAGE_PRIORITY        Priority
    )
{
    PNDIS_BUFFER    pBuf;

    pBuf = Packet->Private.Head;
    *FirstBuffer = pBuf;
    if (pBuf)
    {
        *FirstBufferVA =    MmGetSystemAddressForMdlSafe(pBuf, Priority);
        *FirstBufferLength = *TotalBufferLength = MmGetMdlByteCount(pBuf);
        for (pBuf = pBuf->Next;
             pBuf != NULL;
             pBuf = pBuf->Next)
        {
            *TotalBufferLength += MmGetMdlByteCount(pBuf);
        }
    }
    else
    {
        *FirstBufferVA = 0;
        *FirstBufferLength = 0;
        *TotalBufferLength = 0;
    }

}

ULONG
NdisBufferLength(
    IN  PNDIS_BUFFER            Buffer
    )
{
    return (MmGetMdlByteCount(Buffer));
}

PVOID
NdisBufferVirtualAddress(
    IN  PNDIS_BUFFER            Buffer
    )
{
    return (MDL_ADDRESS_SAFE(Buffer, HighPagePriority));
}

ULONG
NDIS_BUFFER_TO_SPAN_PAGES(
    IN  PNDIS_BUFFER                Buffer
    )
{
    if (MDL_SIZE(Buffer) == 0)
    {
        return 1;
    }
    return ADDRESS_AND_SIZE_TO_SPAN_PAGES(MDL_VA(Buffer), MDL_SIZE(Buffer));
}

VOID
NdisGetBufferPhysicalArraySize(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   ArraySize
    )
{
    if (MDL_SIZE(Buffer) == 0)
    {
        *ArraySize = 1;
    }
    else
    {
        *ArraySize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MDL_VA(Buffer), MDL_SIZE(Buffer));
    }
}

NDIS_STATUS
NdisAnsiStringToUnicodeString(
    IN  OUT PUNICODE_STRING     DestinationString,
    IN      PANSI_STRING        SourceString
    )
{
    NDIS_STATUS Status;

    Status = RtlAnsiStringToUnicodeString(DestinationString,
                                          SourceString,
                                          FALSE);
    return Status;
}

NDIS_STATUS
NdisUnicodeStringToAnsiString(
    IN  OUT PANSI_STRING        DestinationString,
    IN      PUNICODE_STRING     SourceString
    )
{
    NDIS_STATUS Status;

    Status = RtlUnicodeStringToAnsiString(DestinationString,
                                          SourceString,
                                          FALSE);
    return Status;
}


NDIS_STATUS
NdisUpcaseUnicodeString(
    OUT PUNICODE_STRING         DestinationString,
    IN  PUNICODE_STRING         SourceString
    )
{
    return(RtlUpcaseUnicodeString(DestinationString, SourceString, FALSE));
}

VOID
NdisMStartBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister,
    IN  BOOLEAN                 WriteToDevice,
    OUT PNDIS_PHYSICAL_ADDRESS_UNIT PhysicalAddressArray,
    OUT PUINT                   ArraySize
    )
{
    NdisMStartBufferPhysicalMappingMacro(MiniportAdapterHandle,
                                         Buffer,
                                         PhysicalMapRegister,
                                         WriteToDevice,
                                         PhysicalAddressArray,
                                         ArraySize);
}

VOID
NdisMCompleteBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister
    )
{
    NdisMCompleteBufferPhysicalMappingMacro(MiniportAdapterHandle,
                                            Buffer,
                                            PhysicalMapRegister);
}

#undef NdisInterlockedIncrement
LONG
NdisInterlockedIncrement(
    IN  PLONG                  Addend
    )
{
    return(InterlockedIncrement(Addend));
}

#undef NdisInterlockedDecrement
LONG
NdisInterlockedDecrement(
    IN  PLONG                  Addend
    )
{
    return(InterlockedDecrement(Addend));
}

#undef NdisInterlockedAddUlong
ULONG
NdisInterlockedAddUlong(
    IN  PULONG                  Addend,
    IN  ULONG                   Increment,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedAddUlong(Addend,Increment, &SpinLock->SpinLock));

}

#undef NdisInterlockedInsertHeadList
PLIST_ENTRY
NdisInterlockedInsertHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{

    return(ExInterlockedInsertHeadList(ListHead,ListEntry,&SpinLock->SpinLock));

}

#undef NdisInterlockedInsertTailList
PLIST_ENTRY
NdisInterlockedInsertTailList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedInsertTailList(ListHead,ListEntry,&SpinLock->SpinLock));
}

#undef NdisInterlockedRemoveHeadList
PLIST_ENTRY
NdisInterlockedRemoveHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedRemoveHeadList(ListHead, &SpinLock->SpinLock));
}

#undef NdisInterlockedPushEntryList
PSINGLE_LIST_ENTRY
NdisInterlockedPushEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PSINGLE_LIST_ENTRY      ListEntry,
    IN  PNDIS_SPIN_LOCK         Lock
    )
{
    return(ExInterlockedPushEntryList(ListHead, ListEntry, &Lock->SpinLock));
}

#undef NdisInterlockedPopEntryList
PSINGLE_LIST_ENTRY
NdisInterlockedPopEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PNDIS_SPIN_LOCK         Lock
    )
{
    return(ExInterlockedPopEntryList(ListHead, &Lock->SpinLock));
}


//
// Logging support for miniports
//
NDIS_STATUS
NdisMCreateLog(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    Size,
    OUT PNDIS_HANDLE            LogHandle
    )
{
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_LOG                   Log = NULL;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if (Miniport->Log != NULL)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        Log = ALLOC_FROM_POOL(sizeof(NDIS_LOG) + Size, NDIS_TAG_DBG_LOG);
        if (Log != NULL)
        {
            Status = NDIS_STATUS_SUCCESS;
            Miniport->Log = Log;
            INITIALIZE_SPIN_LOCK(&Log->LogLock);
            Log->Miniport = Miniport;
            Log->Irp = NULL;
            Log->TotalSize = Size;
            Log->CurrentSize = 0;
            Log->InPtr = 0;
            Log->OutPtr = 0;
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    *LogHandle = Log;

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}


VOID
NdisMCloseLog(
    IN   NDIS_HANDLE            LogHandle
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    Miniport = Log->Miniport;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    Miniport->Log = NULL;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    FREE_POOL(Log);
}


NDIS_STATUS
NdisMWriteLogData(
    IN   NDIS_HANDLE            LogHandle,
    IN   PVOID                  LogBuffer,
    IN   UINT                   LogBufferSize
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;
    UINT                        AmtToCopy;

    //1 should we limit drivers to how much they can log?
    IoAcquireCancelSpinLock(&OldIrql);

    ACQUIRE_SPIN_LOCK_DPC(&Log->LogLock);

    if (LogBufferSize <= Log->TotalSize)
    {
        if (LogBufferSize <= (Log->TotalSize - Log->InPtr))
        {
            //
            // Can copy the entire buffer
            //
            CopyMemory(Log->LogBuf+Log->InPtr, LogBuffer, LogBufferSize);
        }
        else
        {
            //
            // We are going to wrap around. Copy it in two chunks.
            //
            AmtToCopy = Log->TotalSize - Log->InPtr;
            CopyMemory(Log->LogBuf+Log->InPtr,
                       LogBuffer,
                       AmtToCopy);
            CopyMemory(Log->LogBuf + 0,
                       (PUCHAR)LogBuffer+AmtToCopy,
                       LogBufferSize - AmtToCopy);
        }

        //
        // Update the current size
        //
        Log->CurrentSize += LogBufferSize;
        if (Log->CurrentSize > Log->TotalSize)
            Log->CurrentSize = Log->TotalSize;

        //
        // Update the InPtr and possibly the outptr
        //
        Log->InPtr += LogBufferSize;
        if (Log->InPtr >= Log->TotalSize)
        {
            Log->InPtr -= Log->TotalSize;
        }

        if (Log->CurrentSize == Log->TotalSize)
        {
            Log->OutPtr = Log->InPtr;
        }

        //
        // Check if there is a pending Irp to complete
        //
        if (Log->Irp != NULL)
        {
            PIRP    Irp = Log->Irp;
            PUCHAR  Buffer;

            Log->Irp = NULL;

            //
            // If the InPtr is lagging the OutPtr. then we can simply
            // copy the data over in one shot.
            //
            AmtToCopy = MDL_SIZE(Irp->MdlAddress);
            if (AmtToCopy > Log->CurrentSize)
                AmtToCopy = Log->CurrentSize;
            if ((Log->TotalSize - Log->OutPtr) >= AmtToCopy)
            {
                Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

                if (Buffer != NULL)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               AmtToCopy);
                }
                else Status = NDIS_STATUS_RESOURCES;
            }
            else
            {
                Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

                if (Buffer != NULL)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               Log->TotalSize-Log->OutPtr);
                    CopyMemory(Buffer+Log->TotalSize-Log->OutPtr,
                               Log->LogBuf,
                               AmtToCopy - (Log->TotalSize-Log->OutPtr));
                }
                else Status = NDIS_STATUS_RESOURCES;
            }
            Log->CurrentSize -= AmtToCopy;
            Log->OutPtr += AmtToCopy;
            if (Log->OutPtr >= Log->TotalSize)
                Log->OutPtr -= Log->TotalSize;
            Irp->IoStatus.Information = AmtToCopy;
            //1 can we do this without IoAcquireCancelSpinLock?
            IoSetCancelRoutine(Irp, NULL);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        }
    }
    else
    {
        Status = NDIS_STATUS_BUFFER_OVERFLOW;
    }

    RELEASE_SPIN_LOCK_DPC(&Log->LogLock);

    IoReleaseCancelSpinLock(OldIrql);

    return Status;
}

NDIS_STATUS
FASTCALL
ndisMGetLogData(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PIRP                    Irp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    KIRQL       OldIrql;
    PNDIS_LOG   Log;
    UINT        AmtToCopy;

    IoAcquireCancelSpinLock(&OldIrql);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    if ((Log = Miniport->Log) != NULL)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Log->LogLock);

        if (Log->CurrentSize != 0)
        {
            PUCHAR  Buffer;

            //
            // If the InPtr is lagging the OutPtr. then we can simply
            // copy the data over in one shot.
            //
            AmtToCopy = MDL_SIZE(Irp->MdlAddress);
            if (AmtToCopy > Log->CurrentSize)
                AmtToCopy = Log->CurrentSize;
            Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

            if (Buffer != NULL)
            {
                if ((Log->TotalSize - Log->OutPtr) >= AmtToCopy)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               AmtToCopy);
                }
                else
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               Log->TotalSize-Log->OutPtr);
                    CopyMemory(Buffer+Log->TotalSize-Log->OutPtr,
                               Log->LogBuf,
                               AmtToCopy - (Log->TotalSize-Log->OutPtr));
                }
                Log->CurrentSize -= AmtToCopy;
                Log->OutPtr += AmtToCopy;
                if (Log->OutPtr >= Log->TotalSize)
                    Log->OutPtr -= Log->TotalSize;
                Irp->IoStatus.Information = AmtToCopy;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (Log->Irp != NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            IoSetCancelRoutine(Irp, ndisCancelLogIrp);
            Log->Irp = Irp;
            Status = STATUS_PENDING;
        }

        RELEASE_SPIN_LOCK_DPC(&Log->LogLock);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    IoReleaseCancelSpinLock(OldIrql);

    return Status;
}


VOID
NdisMFlushLog(
    IN   NDIS_HANDLE                LogHandle
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    KIRQL                       OldIrql;

    ACQUIRE_SPIN_LOCK(&Log->LogLock, &OldIrql);
    Log->InPtr = 0;
    Log->OutPtr = 0;
    Log->CurrentSize = 0;
    RELEASE_SPIN_LOCK(&Log->LogLock, OldIrql);
}

NDIS_STATUS
NdisMQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisAdapterHandle
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;

    DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("==>NdisMQueryAdapterInstanceName\n"));

    //
    //  If we failed to create the adapter instance name then fail this call.
    //
    if (NULL != Miniport->pAdapterInstanceName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = Miniport->pAdapterInstanceName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;
    
            NtStatus = RtlAppendUnicodeStringToString(
                            pAdapterInstanceName, 
                            Miniport->pAdapterInstanceName);
            if (NT_SUCCESS(NtStatus))
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {    
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {    
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("<==NdisMQueryAdapterInstanceName: 0x%x\n", Status));

    return(Status);
}


EXPORT
VOID
NdisInitializeReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock
    )
{
    NdisZeroMemory(Lock, sizeof(NDIS_RW_LOCK));
}


VOID
NdisAcquireReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  BOOLEAN                 fWrite,
    IN  PLOCK_STATE             LockState
    )
{
    if (fWrite)
    {
        LockState->LockState = WRITE_LOCK_STATE_UNKNOWN;
        {
            UINT    i, refcount;
            ULONG   Prc;

            /*
             * This means we need to attempt to acquire the lock,
             * if we do not already own it.
             * Set the state accordingly.
             */
            if ((Lock)->Context == CURRENT_THREAD)
            {
                (LockState)->LockState = LOCK_STATE_ALREADY_ACQUIRED;
            }
            else
            {
                ACQUIRE_SPIN_LOCK(&(Lock)->SpinLock, &(LockState)->OldIrql);

                Prc = KeGetCurrentProcessorNumber();
                refcount = (Lock)->RefCount[Prc].RefCount;
                (Lock)->RefCount[Prc].RefCount = 0;

                /* wait for all readers to exit */
                for (i=0; i < ndisNumberOfProcessors; i++)
                {
                    volatile UINT   *_p = &(Lock)->RefCount[i].RefCount;

                    while (*_p != 0)
                        NDIS_INTERNAL_STALL(50);
                }

                (Lock)->RefCount[Prc].RefCount = refcount;
                (Lock)->Context = CURRENT_THREAD;
                (LockState)->LockState = WRITE_LOCK_STATE_FREE;
            }
        }
    }
    else
    {
        LockState->LockState = READ_LOCK;
        {                                                                       
            LONG    refcount;                                                   
            ULONG   Prc;                                                        
                                                                                
            RAISE_IRQL_TO_DISPATCH(&(LockState)->OldIrql);                           
                                                                                
            /* go ahead and bump up the ref count IF no writes are underway */  
            Prc = CURRENT_PROCESSOR;                                            
            refcount = InterlockedIncrement((PLONG)&Lock->RefCount[Prc].RefCount);                          
                                                                                
            /* Test if spin lock is held, i.e., write is underway   */          
            /* if (KeTestSpinLock(&(_L)->SpinLock) == TRUE)         */          
            /* This processor already is holding the lock, just     */          
            /* allow him to take it again or else we run into a     */          
            /* dead-lock situation with the writer                  */          
            if (TEST_SPIN_LOCK((Lock)->SpinLock) &&                               
                (refcount == 1) &&                                              
                ((Lock)->Context != CURRENT_THREAD))                              
            {                                                                   
                (Lock)->RefCount[Prc].RefCount--;                                 
                ACQUIRE_SPIN_LOCK_DPC(&(Lock)->SpinLock);                         
                (Lock)->RefCount[Prc].RefCount++;                                 
                RELEASE_SPIN_LOCK_DPC(&(Lock)->SpinLock);                         
            }                                                                   
            (LockState)->LockState = READ_LOCK_STATE_FREE;                           
        }
    }
}


VOID
NdisReleaseReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  PLOCK_STATE             LockState
    )
{
    xLockHandler(Lock, LockState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndispwr.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndispwr.c

Abstract:

    This module contains the code to process power managment IRPs that are
    sent under the IRP_MJ_POWER major code.

Author:

    Kyle Brandon    (KyleB)
    Alireza Dabagh  (alid)

Environment:

    Kernel mode

Revision History:

    02/11/97    KyleB           Created

--*/

#include <precomp.h>
#pragma hdrstop

#define MODULE_NUMBER   MODULE_POWER


NTSTATUS
FASTCALL
ndisQueryPowerCapabilities(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_QUERY_CAPABILITIES by querying the
    next device object and saving information from that request.

Arguments:

    pIrp        -   Pointer to the IRP.
    pIrpSp      -   Pointer to the stack parameters for the IRP.
    pAdapter        -   Pointer to the device.

Return Value:

--*/
{
    PIRP                            pirp;
    PIO_STACK_LOCATION              pirpSpN;
    NTSTATUS                        Status = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES            pDeviceCaps;
    DEVICE_CAPABILITIES             deviceCaps;
    POWER_QUERY                     pQuery;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPowerCapabilities: Miniport %p\n", Miniport));

    do
    {
        //
        // default = no PM support
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);

        //
        // if the Next device object is NULL, Don't bother, just flag the Miniport
        // as not supporting PM.
        // this can happen for IM devices under Memphis
        //
        if (Miniport->NextDeviceObject == NULL)
        {
            break;
        }
        
        //
        //  Send the IRP_MN_QUERY_CAPABILITIES to pdo.
        //
        pirp = IoAllocateIrp((CCHAR)(Miniport->NextDeviceObject->StackSize + 1),
                             FALSE);
        if (NULL == pirp)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPowerCapabilities: Miniport %p, Failed to allocate an irp for IRP_MN_QUERY_CAPABILITIES\n", Miniport));

            NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                   NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                   0);
                                   
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        NdisZeroMemory(&deviceCaps, sizeof(deviceCaps));
        deviceCaps.Size = sizeof(DEVICE_CAPABILITIES);
        deviceCaps.Version = 1;

        //
        // should initalize deviceCaps.Address and deviceCaps.UINumber here as well
        //
        deviceCaps.Address = (ULONG)-1;
        deviceCaps.UINumber= (ULONG)-1;
        
        //
        //  Get the stack pointer.
        //
        pirpSpN = IoGetNextIrpStackLocation(pirp);
        ASSERT(pirpSpN != NULL);
        NdisZeroMemory(pirpSpN, sizeof(IO_STACK_LOCATION ) );
        
        //
        //  Set the default device state to full on.
        //
        pirpSpN->MajorFunction = IRP_MJ_PNP;
        pirpSpN->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        pirpSpN->Parameters.DeviceCapabilities.Capabilities = &deviceCaps;
        pirp->IoStatus.Status  = STATUS_NOT_SUPPORTED;
        
        //
        //  Setup the I/O completion routine to be called.
        //
        INITIALIZE_EVENT(&pQuery.Event);
        IoSetCompletionRoutine(pirp,
                               ndisCompletionRoutine,
                               &pQuery,
                               TRUE,
                               TRUE,
                               TRUE);


        //
        //  Call the next driver.
        //
        Status = IoCallDriver(Miniport->NextDeviceObject, pirp);
        if (STATUS_PENDING == Status)
        {
            Status = WAIT_FOR_OBJECT(&pQuery.Event, NULL);
            ASSERT(NT_SUCCESS(Status));
        }

        //
        //  If the lower device object successfully completed the request
        //  then we save that information.
        //
        if (NT_SUCCESS(pQuery.Status))
        {
            
            //
            //  Get the pointer to the device capabilities as returned by
            //  the parent PDO.
            //
            pDeviceCaps = &deviceCaps;
        
            //
            // save the entire device caps received from bus driver/ACPI
            //
            NdisMoveMemory(
                &Miniport->DeviceCaps,
                pDeviceCaps,
                sizeof(DEVICE_CAPABILITIES));


            if ((pDeviceCaps->DeviceWake != PowerDeviceUnspecified) &&
                (pDeviceCaps->SystemWake != PowerSystemUnspecified))
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);
            }

            IF_DBG(DBG_COMP_PM, DBG_LEVEL_INFO)
            {
                UINT i;
                DbgPrint("ndisQueryPowerCapabilities: Miniport %p, Bus PM capabilities\n", Miniport);
                DbgPrint("\tDeviceD1:\t\t%ld\n", (pDeviceCaps->DeviceD1 == 0) ? 0 : 1);
                DbgPrint("\tDeviceD2:\t\t%ld\n", (pDeviceCaps->DeviceD2 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD0:\t\t%ld\n", (pDeviceCaps->WakeFromD0 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD1:\t\t%ld\n", (pDeviceCaps->WakeFromD1 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD2:\t\t%ld\n", (pDeviceCaps->WakeFromD2 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD3:\t\t%ld\n\n", (pDeviceCaps->WakeFromD3 == 0) ? 0 : 1);
                
                DbgPrint("\tSystemState\t\tDeviceState\n");

                if (pDeviceCaps->DeviceState[0] ==  PowerDeviceUnspecified)
                    DbgPrint("\tPowerSystemUnspecified\tPowerDeviceUnspecified\n");
                else
                    DbgPrint("\tPowerSystemUnspecified\t\tD%ld\n", pDeviceCaps->DeviceState[0] - 1);

                for (i = 1; i < PowerSystemMaximum; i++)
                {
                    if (pDeviceCaps->DeviceState[i]==  PowerDeviceUnspecified)
                        DbgPrint("\tS%ld\t\t\tPowerDeviceUnspecified\n",i-1);
                    else
                        DbgPrint("\tS%ld\t\t\tD%ld\n",i-1, pDeviceCaps->DeviceState[i] - 1);

                }

                if (pDeviceCaps->SystemWake == PowerSystemUnspecified)
                    DbgPrint("\t\tSystemWake: PowerSystemUnspecified\n");
                else
                    DbgPrint("\t\tSystemWake: S%ld\n", pDeviceCaps->SystemWake - 1);


                if (pDeviceCaps->DeviceWake == PowerDeviceUnspecified)
                    DbgPrint("\t\tDeviceWake: PowerDeviceUnspecified\n");
                else
                    DbgPrint("\t\tDeviceWake: D%ld\n", pDeviceCaps->DeviceWake - 1);

            }
        }
        else
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,("ndisQueryPowerCapabilities: Miniport %p, Bus driver failed IRP_MN_QUERY_CAPABILITIES\n", Miniport));
        }

        //
        //  The irp is no longer needed.
        //
        IoFreeIrp(pirp);
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPowerCapabilities: Miniport %p, Status 0x%x\n", Miniport, Status));

    return(Status);
}

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
//1 dead code for .NET
NTSTATUS
ndisMediaDisconnectComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:


Arguments:

    pdo         -   Pointer to the DEVICE_OBJECT for the miniport.
    pirp        -   Pointer to the device set power state IRP that we created.
    Context     -   Pointer to the miniport block

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    NTSTATUS                Status = STATUS_MORE_PROCESSING_REQUIRED;
    KIRQL                   OldIrql;

    UNREFERENCED_PARAMETER(pdo);
    UNREFERENCED_PARAMETER(MinorFunction);
    UNREFERENCED_PARAMETER(IoStatus);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMediaDisconnectComplete: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  double check that we didn't get a link up while we were doing all this.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMediaDisconnectComplete: Miniport %p, disconnect complete\n", Miniport));

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    else
    {

        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // if system is not going to sleep, wake up the device
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMediaDisconnectComplete: Miniport %p, disconnect was cancelled. Power back up the miniport\n", Miniport));

            //
            //  Wake it back up
            //
            PowerState.DeviceState = PowerDeviceD0;
            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       NULL,
                                       NULL,
                                       NULL);
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMediaDisconnectComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//1 dead code for .NET
VOID
ndisMediaDisconnectWorker(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    POWER_STATE             PowerState;
    NTSTATUS                Status;
    NDIS_STATUS             NdisStatus;
    ULONG                   WakeEnable;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("==>ndisMediaDisconnectWorker: Miniport %p\n", Miniport));

    //
    //  Determine the minimum device state we can go to and still get a link enabled.
    //
    if (Miniport->DeviceCaps.DeviceWake < Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp)
    {
        PowerState.DeviceState = Miniport->DeviceCaps.DeviceWake;
    }
    else
    {
        PowerState.DeviceState = Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp;
    }


    
    //
    // enable the appropriate wakeup method. this includes link change,
    // pattern match and/or magic packet.
    // if LINK_CHANGE method is disabled, we should not even get here
    //
    //
    // Miniport->WakeUpEnable is the wakeup methods enabled from protocol (and ndis point of view)
    // with this qfe, when the user turns wol off from UI, the methods going down are not
    // the methods set by protocol/ndis
    //
    
    WakeEnable = Miniport->WakeUpEnable;

    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
    {
        WakeEnable &= ~NDIS_PNP_WAKE_UP_PATTERN_MATCH;
    }

    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
    {
        WakeEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
    }
                 
    NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                 WakeEnable,
                                                 OID_PNP_ENABLE_WAKE_UP,
                                                 TRUE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        
            
        //
        //  We need to request a device state irp.
        //
        Miniport->WaitWakeSystemState = Miniport->DeviceCaps.SystemWake;
        Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                   IRP_MN_SET_POWER,
                                   PowerState,
                                   ndisMediaDisconnectComplete,
                                   Miniport,
                                   NULL);

    }
    
    FREE_POOL(pWorkItem);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMediaDisconnectWorker: Miniport %p\n", Miniport));
}

//1 dead code for .NET
VOID
ndisMediaDisconnectTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    //  Fire off a workitem to take care of this at passive level.
    //
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    PPOWER_WORK_ITEM        pWorkItem;

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMediaDisconnectTimeout: Miniport %p\n", Miniport));

    
    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMediaDisconnectTimeout: Miniport %p, media disconnect was cancelled\n", Miniport));
            break;
        }
        
        //
        //  Clear the disconnect wait flag.
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem != NULL)
        {
            //
            //  Initialize the ndis work item to power on.
            //
            NdisInitializeWorkItem(&pWorkItem->WorkItem,
                                   (NDIS_PROC)ndisMediaDisconnectWorker,
                                   Miniport);
        
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
            
            //
            //  Schedule the workitem to fire.
            //
            NdisScheduleWorkItem(&pWorkItem->WorkItem);
        }
    } while (FALSE);
    
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMediaDisconnectTimeout: Miniport %p\n", Miniport));
}
#endif

NTSTATUS
ndisWaitWakeComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    PIRP                    pirp;
    NTSTATUS                Status = IoStatus->Status;
    POWER_STATE             DevicePowerState;
    KIRQL                   OldIrql;

    UNREFERENCED_PARAMETER(pdo);
    UNREFERENCED_PARAMETER(MinorFunction);
    UNREFERENCED_PARAMETER(PowerState);

    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisWaitWakeComplete: Miniport %p, pIrp %p, Status %lx\n", 
                    Miniport, Miniport->pIrpWaitWake, Status));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    pirp = Miniport->pIrpWaitWake;
    Miniport->pIrpWaitWake = NULL;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    if (pirp != NULL)
    {

        //
        //  If this completion routine was called because a wake-up occured at the device level
        //  then we need to initiate a device irp to start up the nic.  If it was completed 
        //  due to a cancellation then we skip this since it was cancelled due to a device irp
        //  being sent to wake-up the device.
        //
        
        if (Status == STATUS_SUCCESS)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisWaitWakeComplete: Miniport %p, Wake irp was complete due to wake event\n", Miniport));

            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisWaitWakeComplete: Miniport %p, Powering up the Miniport\n", Miniport));
                //
                //  We need to request a set power to power up the device.
                //
                DevicePowerState.DeviceState = PowerDeviceD0;
                Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                           IRP_MN_SET_POWER,
                                           DevicePowerState,
                                           NULL,
                                           NULL,
                                           NULL);
            }
            else
            {
                //
                // it is also possible that the device woke up the whole system (WOL) in which case we
                // will get a system power IRP eventually and we don't need to request a power IRP.
                //
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisWaitWakeComplete: Miniport %p woke up the system.\n", Miniport));
                
            }
        }
        else
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisWaitWakeComplete: Miniport %p, WAIT_WAKE irp failed or cancelled. Status %lx\n",
                    Miniport, Status));

        }

    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisWaitWakeComplete: Miniport %p\n", Miniport));
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisQueryPowerComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object
    pirp    -   Pointer to the query power irp
    Context -   Pointer to the miniport.

Return Value:

--*/
{
    NTSTATUS    Status = pirp->IoStatus.Status;

    UNREFERENCED_PARAMETER(pdo);
#if !DBG
    UNREFERENCED_PARAMETER(Context);
#endif

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPowerComplete: Miniport %p, Bus driver returned %lx for QueryPower\n",
            Context, pirp->IoStatus.Status));
        
#ifdef TRACE_PM_PROBLEMS
    if (!NT_SUCCESS(pirp->IoStatus.Status))
    {
        DbgPrint("ndisQueryPowerComplete: Miniport %p, Bus Driver returned %lx for QueryPower.\n",
            Context, pirp->IoStatus.Status);
    }
#endif

    PoStartNextPowerIrp(pirp);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPowerComplete: Miniport %p\n", Context));

    return(Status);
}

NTSTATUS
ndisQueryPower(
    IN  PIRP                    pirp,
    IN  PIO_STACK_LOCATION      pirpSp,
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_QUERY_POWER for a miniport driver.

Arguments:

    pirp        -   Pointer to the IRP.
    pirpSp      -   Pointer to the IRPs current stack location.
    Adapter     -   Pointer to the adapter.

Return Value:

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    DEVICE_POWER_STATE      DeviceState = PowerDeviceUnspecified;
    NDIS_STATUS             NdisStatus;
    PIO_STACK_LOCATION      pirpSpN;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPower: Miniport %p\n", Miniport));

    do
    {
        //
        //  We only handle system power states sent as a query.
        //
        if (pirpSp->Parameters.Power.Type != SystemPowerState)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, Not a system state! Type: 0x%x. State: 0x%x\n",
                    Miniport, pirpSp->Parameters.Power.Type, pirpSp->Parameters.Power.State));
    
            Status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        //  Determine if the system state is appropriate and what device state we
        //  should go to.
        //
        Status = ndisMPowerPolicy(Miniport,
                                  pirpSp->Parameters.Power.State.SystemState,
                                  &DeviceState,
                                  TRUE);

        

        if (!ndisIsMiniportStarted(Miniport) ||
            (Miniport->PnPDeviceState != NdisPnPDeviceStarted) ||
            (STATUS_DEVICE_POWERED_OFF == Status))
        {       
            pirp->IoStatus.Status = STATUS_SUCCESS;
    
            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            return(STATUS_SUCCESS);
        }

        //
        //  If we didn't succeed then fail the query power.
        //
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, Unable to go to system state 0x%x\n",
                    Miniport, pirpSp->Parameters.Power.State.SystemState));

            break;
        }

        //
        //  Notify the transports with the query power PnP event.
        //
        NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                NetEventQueryPower,
                                                &DeviceState,
                                                sizeof(DeviceState));
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisQueryPower: Miniport %p, ndisPnPNotifyAllTransports failed\n", Miniport));

            Status = NdisStatus;
            break;
        }

        //
        //  Notify the miniport...
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
        {
            
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         DeviceState,
                                                         OID_PNP_QUERY_POWER,
                                                         FALSE);

            if (NDIS_STATUS_SUCCESS != NdisStatus)
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisQueryPower: Miniport %p, failed query power\n", Miniport));
                    
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

    } while (FALSE);

    if (!NT_SUCCESS(Status))
    {
        pirp->IoStatus.Status = Status;
        PoStartNextPowerIrp(pirp);
        IoCompleteRequest(pirp, 0);
    }
    else
    {
        //
        //  Pass this irp down the stack.
        //
        pirpSpN = IoGetNextIrpStackLocation(pirp);
        pirpSpN->MajorFunction = IRP_MJ_POWER;
        pirpSpN->MinorFunction = IRP_MN_QUERY_POWER;

        pirpSpN->Parameters.Power.SystemContext = pirpSp->Parameters.Power.SystemContext;
        pirpSpN->Parameters.Power.Type = DevicePowerState;
        pirpSpN->Parameters.Power.State.DeviceState = DeviceState;

        IoSetCompletionRoutine(
            pirp,
            ndisQueryPowerComplete,
            Miniport,
            TRUE,
            TRUE,
            TRUE);

        IoMarkIrpPending(pirp);
        PoCallDriver(Miniport->NextDeviceObject, pirp);
        Status = STATUS_PENDING;

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, PoCallDriver to NextDeviceObject returned %lx\n", Miniport, Status));

    }

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPower: Miniport %p\n", Miniport));

    return(Status);
}

VOID
FASTCALL
ndisPmHaltMiniport(
    IN PNDIS_MINIPORT_BLOCK Miniport
    )
/*++

Routine Description:

    This will stop the miniport from functioning...

Arguments:

    Miniport - pointer to the mini-port to halt

Return Value:

    None.

--*/

{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPmHaltMiniport: Miniport \n", Miniport));

    PnPReferencePackage();

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    NdisResetEvent(&Miniport->OpenReadyEvent);

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
    {
        ASSERT(FALSE);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        return;
    }
    //
    //  Mark this miniport as halting.
    //
    MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_HALTED);

    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    ndisMCommonHaltMiniport(Miniport);

    NdisMDeregisterAdapterShutdownHandler(Miniport);

    Miniport->MiniportAdapterContext = NULL;

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPmHaltMiniport: Miniport %p\n", Miniport));
}

NDIS_STATUS
ndisPmInitializeMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will re-initialize a miniport that has been halted due to
    a PM low power transition.

Arguments:

    Miniport    -   Pointer to the miniport block to re-initialize.

Return Value:

--*/
{
    PNDIS_M_DRIVER_BLOCK                pMiniBlock = Miniport->DriverHandle;
    NDIS_WRAPPER_CONFIGURATION_HANDLE   ConfigurationHandle;
    NDIS_STATUS                         Status;
    NDIS_STATUS                         OpenErrorStatus;
    UINT                                SelectedMediumIndex;
    ULONG                               Flags;
    KIRQL                               OldIrql;
    UCHAR                               SendFlags;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPmInitializeMiniport: Miniport %p\n", Miniport));
    
    do
    {
        if ((Miniport->DmaAdapterRefCount == 1) &&
            (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST)))
        {
            Miniport->DmaResourcesReleasedEvent = NULL;
            ndisDereferenceDmaAdapter(Miniport);
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SG_LIST);
        }
        
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_PM_HALTING |
                                      fMINIPORT_DEREGISTERED_INTERRUPT |
                                      fMINIPORT_RESET_REQUESTED |
                                      fMINIPORT_RESET_IN_PROGRESS);
                                      
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);

        Flags = Miniport->Flags;
        SendFlags = Miniport->SendFlags;

        //
        //  Clean up any workitems that might have been queue'd
        //
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemMiniportCallback, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetRequested, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetInProgress, NULL);
        InitializeListHead(&Miniport->PacketList);

        //
        //  Initialize the configuration handle for use during the initialization.
        //
        ConfigurationHandle.DriverObject = Miniport->DriverHandle->NdisDriverInfo->DriverObject;
        ConfigurationHandle.DeviceObject = Miniport->DeviceObject;
        ConfigurationHandle.DriverBaseName = &Miniport->BaseName;

        ASSERT(KeGetCurrentIrql() == 0);
        Status = ndisInitializeConfiguration((PNDIS_WRAPPER_CONFIGURATION_HANDLE)&ConfigurationHandle,
                                             Miniport,
                                             NULL);
        ASSERT(KeGetCurrentIrql() == 0);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisPmInitializeMiniport: Miniport %p, ndisInitializeConfiguration failed, Status: 0x%x\n", Miniport, Status));
            break;
        }
    
        //
        // Call adapter callback. The current value for "Export"
        // is what we tell him to name this device.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        Miniport->CurrentDevicePowerState = PowerDeviceD0;
    
        Status = (pMiniBlock->MiniportCharacteristics.InitializeHandler)(
                    &OpenErrorStatus,
                    &SelectedMediumIndex,
                    ndisMediumArray,
                    ndisMediumArraySize / sizeof(NDIS_MEDIUM),
                    (NDIS_HANDLE)Miniport,
                    (NDIS_HANDLE)&ConfigurationHandle);
    
        ASSERT(KeGetCurrentIrql() == 0);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisPmInitializeMiniport: Miniport %p, MiniportInitialize handler failed, Status 0x%x\n", Miniport, Status));
    
            break;
        }
        
        ASSERT (Miniport->MediaType == ndisMediumArray[SelectedMediumIndex]);
        
        //
        // Restore saved settings. make sure we don't overwrite the 
        // fMINIPORT_SG_LIST flag set during initialization.
        //
        Flags |= (Miniport->Flags & fMINIPORT_SG_LIST);
        Miniport->Flags = Flags;
        Miniport->SendFlags = SendFlags;
        
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_HALTED | fMINIPORT_REJECT_REQUESTS);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);
        CHECK_FOR_NORMAL_INTERRUPTS(Miniport);

        //
        //  Clear the flag preventing the miniport's shutdown handler from being
        //  called if needed.
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN);

        //
        // if device does not need polling for connect status then assume it is connected
        // as we always do when we intialize a miniport. if it does require media polling
        // leave the media status as it was before suspend. it will be updated on the very first
        // wakeup DPC.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING))
        {
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            //
            // set the ReceivePacket handler
            //
            ndisMSetIndicatePacketHandler(Miniport);
        }

        BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);

        //
        //  Restore the filter information.
        //
        ndisMRestoreFilterSettings(Miniport, NULL, FALSE);

        //
        //  Make sure the filter settings get updated.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }

        UNLOCK_MINIPORT_L(Miniport);

        //
        //  Start up the wake up timer.
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisPmInitializeMiniport: Miniport %p, startup the wake-up DPC timer\n", Miniport));


        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER);
        
        NdisSetTimer(&Miniport->WakeUpDpcTimer, Miniport->CheckForHangSeconds*1000);    

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        ASSERT(KeGetCurrentIrql() == 0);


        if (Miniport->MediaType == NdisMedium802_3)
        {
            ndisMNotifyMachineName(Miniport, NULL);
        }

        //
        // Register with WMI.
        //
        Status = IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_REGISTER);

        if (!NT_SUCCESS(Status))
        {
            //
            //  This should NOT keep the adapter from initializing but we should log the error.
            //
            DBGPRINT_RAW((DBG_COMP_INIT | DBG_COMP_WMI), DBG_LEVEL_WARN,
                ("ndisPmInitializeMiniport: Miniport %p, Failed to register for WMI support\n", Miniport));
        }

        Status = NDIS_STATUS_SUCCESS;
        
        KeQueryTickCount(&Miniport->NdisStats.StartTicks);
        
    } while (FALSE);

    if (NDIS_STATUS_SUCCESS != Status)
    {
        NdisMDeregisterAdapterShutdownHandler(Miniport);
        
        ndisLastFailedInitErrorCode =  Status;
        ASSERT(Miniport->Interrupt == NULL);
        ASSERT(Miniport->TimerQueue == NULL);
        ASSERT(Miniport->MapRegisters == NULL);

        if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
        {
            if (Miniport->Interrupt != NULL)
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0x10,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Miniport->Interrupt,
                            0);
            }
            else
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0x11,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Miniport->TimerQueue,
                            0);
            }
        }
    
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_HALTED);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        
    }

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPmInitializeMiniport: Miniport %p\n", Miniport));

    return(Status);
}

NDIS_STATUS
ndisQuerySetMiniportDeviceState(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  NDIS_OID                Oid,
    IN  BOOLEAN                 fSet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             NdisStatus;
    NDIS_REQUEST            PowerReq;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    ULONG                   State;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("==>ndisQuerySetMiniportDeviceState: Miniport %p\n", Miniport));

    //
    //  Setup the miniport's internal request for a set power OID.
    //
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(&PowerReq);
    INITIALIZE_EVENT(&CoReqRsvd->Event);

    PowerReq.DATA.SET_INFORMATION.InformationBuffer = &State;
    PowerReq.DATA.SET_INFORMATION.InformationBufferLength = sizeof(State);

    PowerReq.RequestType = fSet ? NdisRequestSetInformation : NdisRequestQueryInformation;

    PowerReq.DATA.SET_INFORMATION.Oid = Oid;
    PowerReq.DATA.SET_INFORMATION.InformationBuffer = &DeviceState;
    PowerReq.DATA.SET_INFORMATION.InformationBufferLength = sizeof(DeviceState);

    NdisStatus = ndisQuerySetMiniport(Miniport,
                                      NULL,
                                      fSet,
                                      &PowerReq,
                                      NULL);

#ifdef TRACE_PM_PROBLEMS
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DbgPrint("ndisQuerySetMiniportDeviceState: Miniport %p, (Name: %p) failed Oid %lx, Set = %lx with error %lx\n",
                        Miniport,
                        Miniport->pAdapterInstanceName,
                        Oid,
                        fSet,
                        NdisStatus);
    }
#endif

                    
    //
    //  Miniport can't fail the set power request.
    //
    if (fSet)
    {
        ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);
    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisQuerySetMiniportDeviceState: Miniport %p, Status %lx\n", Miniport, NdisStatus));

    return(NdisStatus);
}


NTSTATUS
ndisRequestedDevicePowerIrpComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:
    This is the callback routine for completion of a -device- power IRP
    that NDIS requested while handling a system power IRP. We will call
    PoStartNextPowerIrp and complete the system IRP or send it down to 
    the next driver depending on the status code of our -device- power
    IRP.

Arguments:

    pdo         -   Pointer to the physical DEVICE_OBJECT for the miniport.
    Context     -   Pointer to the system set power state sent by the OS.

Return Value:

--*/
{
    PIRP                    pirpSystem = Context;
    PIO_STACK_LOCATION      pirpSp;
    PNDIS_MINIPORT_BLOCK    Miniport;

#if !DBG
    UNREFERENCED_PARAMETER(pdo);
#endif
    UNREFERENCED_PARAMETER(MinorFunction);
    UNREFERENCED_PARAMETER(PowerState);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisRequestedDevicePowerIrpComplete: DeviceObject %p\n", pdo));

    //
    //  Save the status code with the original IRP.
    //
    pirpSystem->IoStatus = *IoStatus;

    //
    //  did everything go well?
    //
    if (NT_SUCCESS(IoStatus->Status))
    {
        //
        //  Get current stack pointer.
        //
        pirpSp = IoGetCurrentIrpStackLocation(pirpSystem);

        ASSERT(SystemPowerState == pirpSp->Parameters.Power.Type);
        
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisRequestedDevicePowerIrpComplete: DeviceObject %p, Going to system power state %lx\n",
                pdo, pirpSp->Parameters.Power.State));

        //
        //  Notify the system that we are in the appropriate power state.
        //
        PoSetPowerState(pirpSp->DeviceObject,SystemPowerState, pirpSp->Parameters.Power.State);
        
        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pirpSp->DeviceObject->DeviceExtension + 1);

        PoStartNextPowerIrp(pirpSystem);

        //
        // now send down the System power IRP
        //
        IoCopyCurrentIrpStackLocationToNext(pirpSystem);
        PoCallDriver(Miniport->NextDeviceObject, pirpSystem);
    }
    else
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
            ("ndisRequestedDevicePowerIrpComplete: DeviceObject %p, IRP_MN_SET_POWER failed!\n", pdo));
            
        PoStartNextPowerIrp(pirpSystem);
        IoCompleteRequest(pirpSystem, 0);

    }


    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisRequestedDevicePowerIrpComplete: DeviceObject %p\n", pdo));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisSetSystemPowerOnComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  PIRP                pirp,
    IN  PVOID               Context
    )
/*++

Routine Description:

    Completion routine for S0 irp. This routine requests a D0 irp to be sent down the stack.

Arguments:

    pdo         -   Pointer to the DEVICE_OBJECT for the miniport.
    pirp        -   Pointer to the S0 irp sent by the power manager.
    Context     -   Pointer to the miniport context

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    PNDIS_MINIPORT_BLOCK    Miniport = Context;
    POWER_STATE PowerState;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetSystemPowerOnComplete: DeviceObject %p\n", pdo));

    //
    //  did everything go well?
    //
    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        //
        //  Request the D irp now.
        //
        PowerState.DeviceState = PowerDeviceD0;
        PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                          IRP_MN_SET_POWER,
                          PowerState,
                          NULL,
                          NULL,
                          NULL);
        
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisSetSystemPowerOnComplete: DeviceObject %p, Going to system power state %lx\n",
                pdo, PowerState));

        //
        //  Notify the system that we are in the appropriate power state.
        //
        PoSetPowerState(pdo ,SystemPowerState, pirpSp->Parameters.Power.State);
    }

    PoStartNextPowerIrp(pirp);

    return(STATUS_SUCCESS);
}

VOID
ndisDevicePowerOn(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    NDIS_STATUS             NdisStatus;
    PIRP                    pirp;
    PIO_STACK_LOCATION      pirpSp;
    NTSTATUS                NtStatus;
    NDIS_POWER_PROFILE      PowerProfile;
    BOOLEAN                 fNotifyProtocols = FALSE;
    BOOLEAN                 fStartMediaDisconnectTimer = FALSE;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisDevicePowerOn: Miniport %p\n", Miniport));
        
    PnPReferencePackage();
    
    pirp = pWorkItem->pIrp;
    pirpSp = IoGetCurrentIrpStackLocation(pirp);
    DeviceState = pirpSp->Parameters.Power.State.DeviceState;

#ifdef TRACE_PM_PROBLEMS
    if (!NT_SUCCESS(pirp->IoStatus.Status))
    {
        DbgPrint("ndisDevicePowerOn: Miniport %p, Bus Driver returned %lx for Powering up the Miniport.\n",
                    Miniport, pirp->IoStatus.Status);
    }
#endif

    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerOn: Miniport %p, Bus driver succeeded power up\n", Miniport));

        //
        //  If the device is not in D0 then we need to wake up the miniport and
        //  restore the handlers.
        //
        if (Miniport->CurrentDevicePowerState != PowerDeviceD0)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisDevicePowerOn: Miniport %p, Power up the Miniport\n", Miniport));

            //
            //  What type of miniport was this?
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
            {
                //
                //  Set the miniport's device state.
                //
                NdisStatus = ndisQuerySetMiniportDeviceState(Miniport, 
                                                             DeviceState,
                                                             OID_PNP_SET_POWER,
                                                             TRUE);
                ASSERT(KeGetCurrentIrql() == 0);

                if (NdisStatus == NDIS_STATUS_SUCCESS)
                    Miniport->CurrentDevicePowerState = DeviceState;


                //
                // Start wake up timer
                //
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER);
                
                NdisSetTimer(&Miniport->WakeUpDpcTimer, Miniport->CheckForHangSeconds*1000);
                
            }
            else
            {
                ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

                if (((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0) &&
                    (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED)))
                {                    
                    NdisStatus = ndisPmInitializeMiniport(Miniport);
                    ASSERT(KeGetCurrentIrql() == 0);
                }
                else
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;               
                }
            }

            if (NDIS_STATUS_SUCCESS == NdisStatus)
            {
                if (ndisIsMiniportStarted(Miniport))
                {
                    NdisSetEvent(&Miniport->OpenReadyEvent);
                    //
                    //  Restore the handlers.
                    //
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    
                    ASSERT(KeGetCurrentIrql() == 0);

                    ASSERT(Miniport->SymbolicLinkName.Buffer != NULL);
                    
                    if (Miniport->SymbolicLinkName.Buffer != NULL)
                    {
                        NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);
                    }
                    else
                    {
                        NtStatus = STATUS_UNSUCCESSFUL;
                    }
                    
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("ndisDevicePowerOn: IoRegisterDeviceClassAssociation failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
                    }

                    fNotifyProtocols = TRUE;
                    fStartMediaDisconnectTimer = TRUE;

                    //
                    // let the adapter know about the current power source
                    //
                    PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? 
                                    NdisPowerProfileAcOnLine : 
                                    NdisPowerProfileBattery;

                    ndisNotifyMiniports(Miniport,
                                        NdisDevicePnPEventPowerProfileChanged,
                                        &PowerProfile,
                                        sizeof(NDIS_POWER_PROFILE));

                }
                
                //
                //  Save the new power state the device is in.
                //
                Miniport->CurrentDevicePowerState = DeviceState;
            
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisDevicePowerOn: Miniport %p, Going to device state 0x%x\n", Miniport, DeviceState));
            
                //
                //  Notify the system that we are in the new device state.
                //
                PowerState.DeviceState = DeviceState;
                PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                    ("ndisDevicePowerOn: Miniport %p, Power on failed by device driver for the Miniport, Error %lx!\n",
                        Miniport, NdisStatus));
                    
#ifdef TRACE_PM_PROBLEMS
                DbgPrint("ndisDevicePowerOn: Miniport %p, Device Driver failed powering up Miniport with Error %lx.\n",
                        Miniport,
                        NdisStatus);
#endif
                pirp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            //
            // device is already in D0. we are here because of a cancel of QueryPower
            //
            if (ndisIsMiniportStarted(Miniport) && 
                (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
            {
                //
                // even if the current state of the device is D0, we 
                // need to notify the protocol. because we could be getting
                // this IRP as a cancel to a query IRP -or- the device
                // never lost its D0 state, but the sytem went to sleep
                // and woke up!
                //
                NdisSetEvent(&Miniport->OpenReadyEvent);

                //
                //  Restore the handlers.
                //
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                fNotifyProtocols = TRUE;
                fStartMediaDisconnectTimer = FALSE;

            }
    
        }
    }

    NtStatus = pirp->IoStatus.Status;
    PoStartNextPowerIrp(pirp);
    IoCompleteRequest(pirp, 0);

    //
    // notify the protocols here after completing the power IRP
    // to avoid deadlocks when protocols block on a request that can only
    // complete when the other power IRPs go through
    //
    
    //
    //  Handle the case where the device was not able to power up.
    //
    if (!NT_SUCCESS(NtStatus))
    {
    
#ifdef TRACE_PM_PROBLEMS
        DbgPrint("ndisDevicePowerOn: Miniport %p, Bus or Device failed powering up the Miniport with Error %lx.\n",
                Miniport,
                NtStatus);
#endif

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisDevicePowerOn: Miniport %p, Power on failed by bus or device driver for Miniport with Error %lx!\n",
                Miniport, NtStatus));

        //
        //  Mark the miniport as having failed so that we remove it correctly.
        //
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
        
        //
        //  We need to tell pnp that the device state has changed.
        //
        IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
        ASSERT(KeGetCurrentIrql() == 0);
    }


    if (fNotifyProtocols)
    {
        //
        // for some protocols we may have closed the binding
        //
        ndisCheckAdapterBindings(Miniport, NULL);
        
        //
        //  Notify the transports.
        //
        ndisPnPNotifyAllTransports(Miniport,
                                   NetEventSetPower,
                                   &DeviceState,
                                   sizeof(DeviceState));
        
        ndisNotifyDevicePowerStateChange(Miniport, DeviceState);

        //
        // if media state has changed from disconnect to connect
        // and the last indicated status was disconnect,
        // we should notify the protcols (and Ndis) that the media is
        // connected
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED) && 
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        
            NdisMIndicateStatus(Miniport,
                    NDIS_STATUS_MEDIA_CONNECT,
                    INTERNAL_INDICATION_BUFFER,
                    INTERNAL_INDICATION_SIZE);
            NdisMIndicateStatusComplete(Miniport);

            UNLOCK_MINIPORT_L(Miniport);
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }

        //
        // check the media status and if it is disconnected, start the timer
        //
        //1 dead code for .NET
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED) &&
            fStartMediaDisconnectTimer)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
                (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
                (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
            {
                //
                //  Are we already waiting for the disconnect timer to fire?
                //
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
                {
                    //
                    //  Mark the miniport as disconnecting and fire off the
                    //  timer.
                    //
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);

                    NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
                }
            }
        }
#endif 
    }

    ASSERT(KeGetCurrentIrql() == 0);

    MINIPORT_DECREMENT_REF(Miniport);

    FREE_POOL(pWorkItem);
    
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisDevicePowerOn: Miniport %p\n", Miniport));
}


NTSTATUS
ndisSetDevicePowerOnComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           pContext
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Not used

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    PPOWER_WORK_ITEM        pWorkItem;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    PIO_STACK_LOCATION      pirpSp;

    UNREFERENCED_PARAMETER(pdo);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetDevicePowerOnComplete: Miniport %p, Irp %p, Status %lx\n",
            Miniport, pirp, pirp->IoStatus.Status));

    do
    {
        if (Miniport->PnPDeviceState != NdisPnPDeviceStarted)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisSetDevicePowerOnComplete: Miniport %p is not started yet.\n", Miniport));
                
            pirpSp = IoGetCurrentIrpStackLocation(pirp);
            DeviceState = pirpSp->Parameters.Power.State.DeviceState;
                
            //
            //  Notify the system that we are in the new device state.
            //
            Miniport->CurrentDevicePowerState = DeviceState;
            PowerState.DeviceState = DeviceState;
            PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
                
            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }
        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem == NULL)
        {
            pirp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }

        //
        //  Initialize the ndis work item to power on.
        //
        NdisInitializeWorkItem(&pWorkItem->WorkItem,
                               (NDIS_PROC)ndisDevicePowerOn,
                               Miniport);
        pWorkItem->pIrp = pirp;

        //
        // this reference and corresponding dereference in ndisDevicePowerOn is done
        // to ensure ndis does not return back from REMOVE IRP while we are waiting
        // for ndisDevicePowerOn to fire.
        //
        MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);

        //
        //  Schedule the workitem to fire.
        //
        INITIALIZE_WORK_ITEM((PWORK_QUEUE_ITEM)(&pWorkItem->WorkItem.WrapperReserved),
                             ndisWorkItemHandler,
                             &pWorkItem->WorkItem);
        XQUEUE_WORK_ITEM((PWORK_QUEUE_ITEM)(&pWorkItem->WorkItem.WrapperReserved), DelayedWorkQueue);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetDevicePowerOnComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


VOID
ndisDevicePowerDown(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    NDIS_STATUS             NdisStatus;
    PIRP                    pirp;
    PIO_STACK_LOCATION      pirpSp;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisDevicePowerDown: Miniport %p\n", Miniport));

    PnPReferencePackage();

    pirp = pWorkItem->pIrp;
    pirpSp = IoGetCurrentIrpStackLocation(pirp);
    DeviceState = pirpSp->Parameters.Power.State.DeviceState;

    //
    //  If the complete status is successful then we need to continue with
    //  wakeing the stack.
    //
    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerDown: Miniport %p, going to device state 0x%x\n", Miniport, DeviceState));

        //
        //  Build a power state.
        //
        PowerState.DeviceState = DeviceState;

        //
        //  Save the current device state with the miniport block.
        //
        Miniport->CurrentDevicePowerState = DeviceState;

        //
        //  Let the system know about the devices new power state.
        //
        PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
    }
    else if (ndisIsMiniportStarted(Miniport) && 
            (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
            ("ndisDevicePowerDown: Miniport %p, Bus driver failed to power down the Miniport\n", Miniport));
            
#ifdef TRACE_PM_PROBLEMS
            DbgPrint("ndisDevicePowerDown: Miniport %p, Bus Driver returned %lx for Powering Down the Miniport\n",
                Miniport, pirp->IoStatus.Status);
#endif

        //
        //  We need to go back to the current device state.
        //
        PowerState.DeviceState = Miniport->CurrentDevicePowerState;

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerDown: Miniport %p, going to device power state 0x%x\n", Miniport, Miniport->CurrentDevicePowerState));

        //
        //  What type of miniport was this?
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
        {
            //
            //  Set the miniport's device state.
            //
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         PowerState.DeviceState,
                                                         OID_PNP_SET_POWER,
                                                         TRUE);
        }
        else
        {
            NdisStatus = ndisPmInitializeMiniport(Miniport);
        }

        //
        //  Is the miniport initialized?
        //
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisDevicePowerDown: Miniport %p, failed to power down but we are not able to reinitialize it.\n", Miniport));

            //
            //  Mark the miniport as having failed so that we remove it correctly.
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);

            //
            //  The bus driver failed the power off and we can't power the miniport back on.
            //  we invalidate the device state so that it will get removed.
            //
            IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);

            pirp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            //
            //  Restore the handlers.
            //
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);


            ndisNotifyDevicePowerStateChange(Miniport, PowerState.DeviceState);
            
            //
            //  Notify the transports.
            //
            NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                    NetEventSetPower,
                                                    &PowerState.DeviceState,
                                                    sizeof(PowerState.DeviceState));
            ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);
        }
    }

    PoStartNextPowerIrp(pirp);
    IoCompleteRequest(pirp, 0);

    FREE_POOL(pWorkItem);

    ASSERT(KeGetCurrentIrql() == 0);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisDevicePowerDown: Miniport %p\n", Miniport));
}

NTSTATUS
ndisSetDevicePowerDownComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           pContext
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Not used

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    PPOWER_WORK_ITEM        pWorkItem;
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
    BOOLEAN                 fTimerCancelled;
#endif

    UNREFERENCED_PARAMETER(pdo);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetDevicePowerDownComplete: Miniport %p, Irp %p, Status %lx\n",
            Miniport, pirp, pirp->IoStatus.Status));

#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
    //
    // cancel any pending media disconnect timers
    //
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
    {
        //
        //  Clear the disconnect wait bit and cancel the timer.
        //  IF the timer routine hasn't grabed the lock then we are ok.
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisSetDevicePowerDownComplete: Miniport %p, cancelling media disconnect timer\n",Miniport));
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

        NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
    }
#endif

    do
    {
        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem == NULL)
        {
            pirp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }

        NdisInitializeWorkItem(&pWorkItem->WorkItem,
                               (NDIS_PROC)ndisDevicePowerDown,
                               Miniport);
        pWorkItem->pIrp = pirp;

        //
        //  Schedule the workitem to fire.
        //
        NdisScheduleWorkItem(&pWorkItem->WorkItem);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetDevicePowerDownComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisSetPower(
    IN  PIRP                    pirp,
    IN  PIO_STACK_LOCATION      pirpSp,
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_SET_POWER for a miniport driver.

Arguments:

    pirp        -   Pointer to the IRP.
    pirpSp      -   Pointer to the IRPs current stack location.
    Miniport    -   Pointer to the Miniport

Return Value:

--*/
{
    POWER_STATE             PowerState;
    DEVICE_POWER_STATE      DeviceState;
    SYSTEM_POWER_STATE      SystemState;
    NDIS_DEVICE_POWER_STATE NdisDeviceState;
    NTSTATUS                Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION      pirpSpN;
    IO_STATUS_BLOCK         IoStatus;
    NDIS_STATUS             NdisStatus;
    PIRP                    pIrpWaitWake;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetPower: Miniport %p, Irp %p\n", Miniport, pirp));

    PnPReferencePackage();
    
    switch (pirpSp->Parameters.Power.Type)
    {
        case SystemPowerState:

            SystemState = pirpSp->Parameters.Power.State.SystemState;
            Miniport->WaitWakeSystemState = SystemState;
            
            //
            // if system is shutting down, call the shutdown handler
            // for miniport and be done with it
            //

            if (SystemState >= PowerSystemShutdown)
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisSetPower: Miniport %p, SystemState %lx\n", Miniport, SystemState));

                if ((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0)
                {
                    ndisMShutdownMiniport(Miniport);
                }

                pirp->IoStatus.Status = STATUS_SUCCESS;
                PoStartNextPowerIrp(pirp);
                IoSkipCurrentIrpStackLocation(pirp);
                Status = PoCallDriver(Miniport->NextDeviceObject, pirp);
                break;
            }
            else
            {
                //
                // Get the device state for the system state. Note that this will
                // set the fMINIPORT_SYSTEM_SLEEPING flag if we are going to 
                // SystemState > PowerSystemWorking
                //
                Status = ndisMPowerPolicy(Miniport, SystemState, &DeviceState, FALSE);

                //
                //  Is the device already powered off?
                //
                if (STATUS_DEVICE_POWERED_OFF == Status)
                {
                    pirp->IoStatus.Status = STATUS_SUCCESS;
            
                    PoStartNextPowerIrp(pirp);
                    IoCompleteRequest(pirp, 0);
                    Status = STATUS_SUCCESS;
                    break;
                }

                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisSetPower: Miniport %p, SystemPowerState[0x%x] DevicePowerState[0x%x]\n", 
                            Miniport, SystemState, DeviceState));

                PowerState.DeviceState = DeviceState;

                if (SystemState > PowerSystemWorking)
                {
                    NdisResetEvent(&Miniport->OpenReadyEvent);

                    //
                    // if system is going to sleep mode, then notify protocols and
                    // request a WAIT_WAKE IRP
                    //
                    
                    //
                    //  Notify the transports of the impending state transition.
                    //  There is nothing we can do if transports fail this
                    //  Note: for all practical purposes there is no need to map
                    //  SytemState to device state here
                    //

                    if (SystemState > PowerSystemSleeping3)
                        NdisDeviceState = PowerSystemSleeping3;
                    else
                        NdisDeviceState = SystemState;

                    ndisNotifyDevicePowerStateChange(Miniport, NdisDeviceState);
                    
                    NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                            NetEventSetPower,
                                                            &NdisDeviceState,
                                                            sizeof(SystemState));


                    //
                    // protocols can't fail going to a sleeping state
                    //
                    ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);

                    MiniportReferencePackage();
        
                    //
                    //  Swap the handlers.
                    //
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    
                    ndisMSwapOpenHandlers(Miniport,
                                          NDIS_STATUS_ADAPTER_NOT_READY,
                                          fMINIPORT_STATE_PM_STOPPED);
                    
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    MiniportDereferencePackage();
                    
                    //
                    //  What type of miniport was this?
                    //
                    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
                    {

                        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                        if (Miniport->pIrpWaitWake != NULL)
                        {
                            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                        }
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                        //
                        //  Is wake-up enabled?
                        //
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE))
                        {
                            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                        
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, Creating a wake irp for the device\n", Miniport));

                            //
                            // reuquest a power irp for wake notification
                            //
                            PowerState.SystemState = Miniport->WaitWakeSystemState;
                            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                                       IRP_MN_WAIT_WAKE,
                                                       PowerState,
                                                       ndisWaitWakeComplete,
                                                       Miniport,
                                                       &Miniport->pIrpWaitWake);
                                        
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, WaiteWakeIrp %p\n",
                                Miniport, Miniport->pIrpWaitWake));
                        }
                    }
                }
                else
                {
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    pIrpWaitWake = Miniport->pIrpWaitWake;
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    
                    //
                    // if we are transitioning to PowerSystemWorking or just asserting
                    // it to cancel a query power, we will notify the protocols when
                    // we get the device power IRP
                    //

                    //
                    //  If there is a wait-wake irp outstanding then we need to cancel it.
                    //
                    if (pIrpWaitWake)
                    {
                        if (IoCancelIrp(pIrpWaitWake))
                        {
                            Miniport->pIrpWaitWake = NULL;
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, Successfully canceled wake irp\n", Miniport));
                        }
                    }

                    //
                    // Send the S0 irp down the stack first. When it completes, send the D0 irp. This
                    // allows the power manager to resume faster while the slow network initialization
                    // takes place in the background.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);
                    IoSetCompletionRoutine(pirp,
                                           ndisSetSystemPowerOnComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);
                    IoMarkIrpPending(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;
                }
            }
            
            //
            // no matter what was the outcome of trying to set a WAIT_WAKE IRP
            // we still have to set the device state appropiately
            // 
            PowerState.DeviceState = DeviceState;
            
            //
            //  Save the device object with the system irp to use in the
            //  completion routine.
            //
            pirpSpN = IoGetNextIrpStackLocation(pirp);
            pirpSpN->DeviceObject = Miniport->DeviceObject;
            IoMarkIrpPending(pirp);

            //
            //  Let the completion routine take care of everything.
            //
            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       ndisRequestedDevicePowerIrpComplete,
                                       pirp,
                                       NULL);
            if (STATUS_PENDING != Status)
            {
                IoStatus.Status = Status;
                IoStatus.Information = 0;

                ndisRequestedDevicePowerIrpComplete(Miniport->PhysicalDeviceObject,
                                                    IRP_MN_SET_POWER,
                                                    PowerState,
                                                    pirp,
                                                    &IoStatus);
            }
            Status = STATUS_PENDING;
            break;

        case DevicePowerState:

            //
            //  Get the device state.
            //
            DeviceState = pirpSp->Parameters.Power.State.DeviceState;

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisSetPower: Miniport %p, DeviceState[0x%x]\n", Miniport, DeviceState));

            //
            //  What state is the device going to?
            //
            switch (DeviceState)
            {
                case PowerDeviceD0:
                    //
                    //  We need to pass this IRP down to the pdo so that
                    //  it can power on.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);

                    IoSetCompletionRoutine(pirp,
                                           ndisSetDevicePowerOnComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                        ("ndisSetPower: Miniport %p, Power up the bus driver.\n", Miniport));

                    //
                    //  Mark the IRP as pending and send it down the stack.
                    //
                    IoMarkIrpPending(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:

                    if (ndisIsMiniportStarted(Miniport) && 
                        (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
                    {
                        //
                        // if the device state setting is not the result of going to
                        // a sleeping system state, (such as media disconnect case)
                        // then notify protocols, etc.
                        //

                        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                        {
                            NdisResetEvent(&Miniport->OpenReadyEvent);
                    
                            ndisNotifyDevicePowerStateChange(Miniport, DeviceState);
                            //
                            //  Notify the transports of the impending state transition.
                            //
                            NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                                    NetEventSetPower,
                                                                    &DeviceState,
                                                                    sizeof(DeviceState));
                    
                            ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);

                            //
                            //  Swap the handlers.
                            //
                            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                            
                            ndisMSwapOpenHandlers(Miniport,
                                                  NDIS_STATUS_ADAPTER_NOT_READY,
                                                  fMINIPORT_STATE_PM_STOPPED);
                            
                            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                        }
                            
                        //
                        //  What type of miniport was this?
                        //
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
                        {
                            BOOLEAN Canceled;
                            
                            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                            {
                                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                                if (Miniport->pIrpWaitWake != NULL)
                                {
                                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                                }
                                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                                //
                                //  Is wake-up enabled?
                                //
                                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE))
                                {
                                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                                
                                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                        ("ndisSetPower: Miniport %p, Creating a wake irp for the device\n", Miniport));

                                    //
                                    // reuquest a power irp for wake notification
                                    //
                                    PowerState.SystemState = Miniport->WaitWakeSystemState;
                                    
                                    Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                                               IRP_MN_WAIT_WAKE,
                                                               PowerState,
                                                               ndisWaitWakeComplete,
                                                               Miniport,
                                                               &Miniport->pIrpWaitWake);
                                                
                                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                        ("ndisSetPower: Miniport %p, WaiteWakeIrp %p\n",
                                            Miniport, Miniport->pIrpWaitWake));
                                }
                            }

                            //
                            // disable the interface
                            //
                            if (Miniport->SymbolicLinkName.Buffer != NULL)
                            {
                                IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
                            }
                            
                            //
                            //  Set the miniport device state.
                            //
                            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                                         DeviceState,
                                                                         OID_PNP_SET_POWER,
                                                                         TRUE);
                            if (NDIS_STATUS_SUCCESS != NdisStatus)
                            {
                                //1 we are not allowed to fail a set power
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                                    ("ndisSetPower: Miniport %p, Failed to power the device down\n", Miniport));
                                
                                if (Miniport->SymbolicLinkName.Buffer != NULL)
                                {
                                    IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);
                                }
                
                                pirp->IoStatus.Status = NdisStatus;
                        
                                PoStartNextPowerIrp(pirp);
                                IoCompleteRequest(pirp, 0);
                                Status = NdisStatus;
                                break;
                            }
                            
                            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER))
                            {
                                KEVENT          RequestsCompletedEvent;

                                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER);
                                                                
                                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                                
                                NdisCancelTimer(&Miniport->WakeUpDpcTimer, &Canceled);
                                
                                if (!Canceled)
                                {
                                    INITIALIZE_EVENT(&RequestsCompletedEvent);
                                    Miniport->WakeUpTimerEvent = &RequestsCompletedEvent;
                                }
                                
                                if (Miniport->WakeUpTimerEvent)
                                {
                                    WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
                                }
                                Miniport->WakeUpTimerEvent = NULL;
                            }
                            else
                            {
                                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                            }

                        }
                        else
                        {
                            if ((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0)
                            {
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                    ("ndisSetPower: Miniport %p, Halt the miniport\n", Miniport));

                                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED))
                                {
                                    //
                                    //  Halt the legacy miniport.
                                    //
                                    ndisPmHaltMiniport(Miniport);
                                }
                            }
                        }
                    }
                    
                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                        ("ndisSetPower: Miniport %p, Notify the bus driver of the low power state\n", Miniport));

                    //
                    //  We need to pass this IRP down to the pdo so that
                    //  it can power down.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);

                    IoSetCompletionRoutine(pirp,
                                           ndisSetDevicePowerDownComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    IoMarkIrpPending(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;
            }

            //
            //  Done with processing the device set power state.
            //
            break;
    }
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetPower: Miniport %p, Status %lx\n", Miniport, Status));

    return(Status);
}


NTSTATUS
ndisPowerDispatch(
    IN  PDEVICE_OBJECT          pDeviceObject,
    IN  PIRP                    pirp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp;
    NTSTATUS                Status;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PDEVICE_OBJECT          NextDeviceObject;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPowerDispatch: DeviceObject %p, Irp %p\n", pDeviceObject, pirp));

    PnPReferencePackage();

    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pDeviceObject->DeviceExtension + 1);
    
    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisPowerDispatch: DeviceObject %p, Irp %p, Device extension is not a miniport.\n", pDeviceObject, pirp));
        //
        //  Fail the invalid request.
        //
        pirp->IoStatus.Status = Status = STATUS_INVALID_DEVICE_REQUEST;
        PoStartNextPowerIrp(pirp);
        IoCompleteRequest(pirp, 0);
        goto Done;
    }
    
    //
    //  Get a pointer to the next DeviceObject.
    //
    NextDeviceObject = Miniport->NextDeviceObject;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("ndisPowerDispatch: Miniport %p\n", Miniport));

    //
    //  Get the stack parameters for this IRP.
    //
    pirpSp = IoGetCurrentIrpStackLocation(pirp);

    switch (pirpSp->MinorFunction)
    {
        //
        // power management stuff
        //
        case IRP_MN_POWER_SEQUENCE:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_POWER_SEQUENCE\n", Miniport));
            
            //
            //  Generic routine that will pass the IRP to the next device
            //  object in the layer that wants to process it.
            //
            IoCopyCurrentIrpStackLocationToNext(pirp);
            Status = ndisPassIrpDownTheStack(pirp, NextDeviceObject);
            pirp->IoStatus.Status = Status;
            IoCompleteRequest(pirp, 0);
            break;

        case IRP_MN_WAIT_WAKE:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_WAIT_WAKE\n", Miniport));

            //
            //  Fill in the wake information.
            //
            pirpSp->Parameters.WaitWake.PowerState = Miniport->WaitWakeSystemState;
            IoCopyCurrentIrpStackLocationToNext(pirp);
            Status = PoCallDriver(NextDeviceObject, pirp);
            break;

        case IRP_MN_QUERY_POWER:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_QUERY_POWER\n", Miniport));

            Status = ndisQueryPower(pirp, pirpSp, Miniport);
            break;

        case IRP_MN_SET_POWER:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_SET_POWER\n", Miniport));

            Status = ndisSetPower(pirp, pirpSp, Miniport);
            break;

        default:
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing minor function: %lx\n",
                Miniport, pirpSp->MinorFunction));

            //
            // send the IRP down
            //
            PoStartNextPowerIrp(pirp);
            IoSkipCurrentIrpStackLocation(pirp);
            Status = PoCallDriver(NextDeviceObject, pirp);
            break;          
    }

Done:
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPowerDispatch: Miniport %p, Status 0x%x\n", Miniport, Status));

    return(Status);
}


NTSTATUS
FASTCALL
ndisMShutdownMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    The "shutdown handler" for the SHUTDOWN Irp.  Will call the Ndis
    shutdown routine, if one is registered.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    Always STATUS_SUCCESS.

--*/

{
    PDEVICE_OBJECT          DeviceObject = Miniport->DeviceObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext =  (PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisMShutdownMiniport: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  Mark the miniport as halting and NOT using normal interrupts.
    //
    MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN);
    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if ((WrapperContext->ShutdownHandler != NULL) &&
        (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN) == 0))
    {
        //
        // Call the shutdown routine.
        //
        if (WrapperContext->ShutdownHandler != NULL)
        {
            WrapperContext->ShutdownHandler(WrapperContext->ShutdownContext);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUT_DOWN);
        }
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisMShutdownMiniport: Miniport %p\n", Miniport));

    return STATUS_SUCCESS;
}


NTSTATUS
ndisMPowerPolicy(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  SYSTEM_POWER_STATE      SystemState,
    IN  PDEVICE_POWER_STATE     pDeviceState,
    IN  BOOLEAN                 fIsQuery
    )
/*++

Routine Description:

    This routine will determine if the miniport should go to the given device state.

Arguments:      

    Miniport    -   Pointer to the miniport block
    SystemState -   State the system wants to go to.

Return Value:

--*/
{
    DEVICE_POWER_STATE              DeviceStateForSystemState, MinDeviceWakeup = PowerDeviceUnspecified;
    NTSTATUS                        Status = STATUS_SUCCESS;
    DEVICE_POWER_STATE              NewDeviceState = PowerDeviceD3;
    PNDIS_PM_WAKE_UP_CAPABILITIES   pWakeCaps;
    NDIS_STATUS                     NdisStatus;
    ULONG                           WakeEnable;
    PIRP                            pIrpWaitWake;
    KIRQL                           OldIrql;
    BOOLEAN                         fDone = FALSE;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMPowerPolicy: Miniport %p, SystemState %lx\n", Miniport, SystemState));


    if (SystemState >= PowerSystemShutdown)
    {
        //
        // if this is a shutdown request, set device to D3 and return
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, shutting down\n", Miniport));

        *pDeviceState = PowerDeviceD3;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }
    
    //
    //  If the system wants to transition to working then we are going to D0. 
    //
    if (SystemState == PowerSystemWorking)
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, Wakeing up the device\n", Miniport));
            
        if (!fIsQuery)
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING);
        }

        *pDeviceState = PowerDeviceD0;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }
    
    if (!fIsQuery)
    {
        //
        // tag the miniport so when we get the device power IRP, we
        // know we have already been here, taken care of protocols, etc.
        //
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING);
    }
    
    //
    //  if this is a legacy miniport or power-disabled miniport then throw it in D3
    //  do the same thing for IM miniports that have not been initialized yet 
    //
    if ((!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE)) ||
        (!(ndisIsMiniportStarted(Miniport) && (Miniport->PnPDeviceState == NdisPnPDeviceStarted))))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, Place legacy or PM disabled device in D3\n", Miniport));

        *pDeviceState = PowerDeviceD3;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }

    //
    //  First check for the case where the netcard is already asleep due to a 
    //  media disconnect.
    //
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    pIrpWaitWake = Miniport->pIrpWaitWake;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->CurrentDevicePowerState > PowerDeviceD0)
    {

        if (pIrpWaitWake != NULL)
        {
            ///
            //  Miniport is in a lower power state than D0 and there is a wake irp pending in
            //  the bus driver. This is a pretty good indication that the cable was pulled.
            //  We are not going to enable any wake-up method seeing as the cable has been disconnect.
            //  but if the user does not want to wakeup the machine as a result of a cable
            // reconnect, cancel any pending wait-wake IRP
            ///

            if (!fIsQuery && ((!MINIPORT_PNP_TEST_FLAG (Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE)) ||
                             (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT)))
            {
                if (IoCancelIrp(pIrpWaitWake))
                {
                    Miniport->pIrpWaitWake = NULL;
                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                        ("ndisMPowerPolicy: Miniport %p, Successfully canceled media connect wake irp\n", Miniport));
                }
            }
        }
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_DEVICE_POWERED_OFF);
    }

    do
    {
        //
        //  Is system wake-up enabled in the policy?
        //  if wake-up is not enabled then we simply power off.
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, Device power wake is not enabled (%u)\n",
                    Miniport, MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE)));

            break;
        }


        //
        //  This is the -lightest- state the device can go to for the requested
        //  system state. 
        //
        DeviceStateForSystemState = Miniport->DeviceCaps.DeviceState[SystemState];

        //
        //  Check to see if we are going below SystemSleeping3
        //
        //
        //
        // if we are going to S4 or deeper and device can not wake up the system from that state
        // just do it
        //
        if ((SystemState >= PowerSystemHibernate) && 
            ((SystemState > Miniport->DeviceCaps.SystemWake) || (DeviceStateForSystemState > Miniport->DeviceCaps.DeviceWake)))
        {

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, System is either entering hibernate or shutting down.\n", Miniport));

            //
            //  We succeed this call.
            //
            break;
        } 

        //
        //  Get a nice pointer to the wake-up capabilities.
        //
        pWakeCaps = &Miniport->PMCapabilities.WakeUpCapabilities;

        if ((NDIS_PNP_WAKE_UP_MAGIC_PACKET == (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_MAGIC_PACKET)) &&
            (PowerDeviceUnspecified != pWakeCaps->MinMagicPacketWakeUp))
        {
            MinDeviceWakeup = pWakeCaps->MinMagicPacketWakeUp;
        }

        if ((NDIS_PNP_WAKE_UP_PATTERN_MATCH == (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_PATTERN_MATCH)) &&
            (PowerDeviceUnspecified != pWakeCaps->MinPatternWakeUp))
        {
            if ((MinDeviceWakeup == PowerDeviceUnspecified) || 
                (MinDeviceWakeup > pWakeCaps->MinPatternWakeUp)) 
            {
                    MinDeviceWakeup = pWakeCaps->MinPatternWakeUp;
            }
        }

        //
        // if both MagicPacket and pattern match are NOT enabled (or the system can't do either)
        // then we may as well go to D3.
        //
        if (MinDeviceWakeup == PowerDeviceUnspecified)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, MagicPacket and pattern match are not enabled.\n", Miniport));

            break;
        }

        //
        // from this point on, we try to go to power state that we can wake up the system from
        //

        //
        // make sure we don't go too deep
        //

        if (MinDeviceWakeup > Miniport->DeviceCaps.DeviceWake)
        {
            MinDeviceWakeup = Miniport->DeviceCaps.DeviceWake;
        }
        
        //
        //  If the system state requested is lower than the minimum required to wake up the system 
        //  or the corresponding device state is deeper than the lowest device state to wake 
        //  up the system then we
        //  fail this call. Note that we also set the device state to D3. Since
        //  we are not going to be able to support wake-up then we power off.
        //  The query power will look at the failure code and return that to the
        //  system. The set power will ignore the failure code and set the device
        //  into D3.
        //
        if ((SystemState > Miniport->DeviceCaps.SystemWake) ||
            (DeviceStateForSystemState > MinDeviceWakeup) ||
            (DeviceStateForSystemState == PowerDeviceUnspecified))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, Requested system state is lower than the minimum wake-up system state\n", Miniport));

            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // starting from DeviceWake and up to DeviceState[SystemState], find a
        // suitable device state
        //
        switch (MinDeviceWakeup)
        {
          case PowerDeviceD3:
            if (Miniport->DeviceCaps.WakeFromD3)
            {
                NewDeviceState =  PowerDeviceD3;
                break;
            }
          case PowerDeviceD2:
            if (Miniport->DeviceCaps.DeviceD2 && Miniport->DeviceCaps.WakeFromD2)
            {
              NewDeviceState =  PowerDeviceD2;
              break;
            }
          case PowerDeviceD1:
            if (Miniport->DeviceCaps.DeviceD1 && Miniport->DeviceCaps.WakeFromD1)
            {
              NewDeviceState =  PowerDeviceD1;
              break;
            }
          case PowerDeviceD0:
            if (Miniport->DeviceCaps.WakeFromD0)
            {
              NewDeviceState =  PowerDeviceD0;
              break;
            }
          default:
            Status = STATUS_UNSUCCESSFUL;
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, couldn't find any wake-able DeviceState 0x%x\n", Miniport));
            break;

        }


        //
        // ok, we started with deepest state (based on what device said can do)
        // and went up. make sure we didn't go too far up. i.e. the statem state
        // we are going to can maintain the device in desired power state
        //
        if ((Status == NDIS_STATUS_SUCCESS) &&
            (DeviceStateForSystemState > NewDeviceState))
        {
            Status = STATUS_UNSUCCESSFUL;
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, couldn't find any wake-able DeviceState 0x%x\n", Miniport));
        
        }

        //
        //  If this is for the set power then we need to enable wake-up on the miniport.
        //
        if (!fIsQuery)
        {
            //
            //  We need to send a request to the miniport to enable the correct wake-up types NOT 
            //  including the link change.
            //
            WakeEnable = Miniport->WakeUpEnable & ~NDIS_PNP_WAKE_UP_LINK_CHANGE;
            
            if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
            {
                WakeEnable &= ~NDIS_PNP_WAKE_UP_PATTERN_MATCH;
            }

            if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
            {
                WakeEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
            }
    
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         WakeEnable,
                                                         OID_PNP_ENABLE_WAKE_UP,
                                                         TRUE);

            if (NDIS_STATUS_SUCCESS == NdisStatus)
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                    ("ndisMPowerPolicy: Miniport %p, Unable to enable the following wake-up methods 0x%x\n", Miniport, WakeEnable));
    
                //
                //  Since we can't enable the wake methods we may as well go to D3.
                //
                NewDeviceState = PowerDeviceD3;
                break;
            }
        }

        //
        //  Save the device state that we should go to.
        //
        *pDeviceState = NewDeviceState;
    
        fDone = TRUE;
        
    } while (FALSE);

    if (fDone)
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, SystemState 0x%x, DeviceState 0x%x\n", Miniport, SystemState, *pDeviceState));
    
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
    
        return(Status);
    }

    //
    //  If this is not a query then we need to cancel wake-up on the miniport.
    //
    if (!fIsQuery && MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: