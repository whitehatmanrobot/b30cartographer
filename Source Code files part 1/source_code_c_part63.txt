2001.
//
//  File:       CName.h
//
//  Contents:   definition of CConfigName
//                              
//----------------------------------------------------------------------------

#if !defined(AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"

#define MAX_USERNAME    20
#define INVALID_ACCOUNT_NAME_CHARS         L"\"/\\[]:|<>+=;,?,*"
/////////////////////////////////////////////////////////////////////////////
// CConfigName dialog

class CConfigName : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult * pResult);
//   virtual void SetInitialValue(DWORD_PTR dw) { };

	CConfigName(UINT nTemplateID);   // standard constructor
   virtual ~CConfigName ();

// Dialog Data
	//{{AFX_DATA(CConfigName)
	enum { IDD = IDD_CONFIG_NAME };
	CString	m_strName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigName)
	virtual BOOL OnApply();
	afx_msg void OnConfigure();
	virtual BOOL OnInitDialog();
   virtual BOOL OnKillActive();
	afx_msg void OnChangeName();
    virtual void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   BOOL m_bNoBlanks;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNAME_H__7F9B3B39_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cnumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cnumber.cpp
//
//  Contents:   implementation of CConfigNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CNumber.h"
#include "util.h"

#include "ANumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigNumber dialog
CConfigNumber::CConfigNumber(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_cMinutes(0), 
m_nLow(0), 
m_nHigh(999), 
m_nSave(0)

{
    //{{AFX_DATA_INIT(CConfigNumber)
    m_strUnits = _T("");
    m_strValue = _T("");
    m_strStatic = _T("");
    m_strError = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a181HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigNumber::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigNumber)
    DDX_Control(pDX, IDC_SPIN, m_SpinValue);
    DDX_Text(pDX, IDC_UNITS, m_strUnits);
    DDX_Text(pDX, IDC_VALUE, m_strValue);
    DDX_Text(pDX, IDC_HEADER,m_strStatic);
    DDX_Text(pDX, IDC_RANGEERROR,m_strError);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigNumber, CAttribute)
    //{{AFX_MSG_MAP(CConfigNumber)
//    ON_EN_KILLFOCUS(IDC_VALUE, OnKillFocus)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN, OnDeltaposSpin)
    ON_EN_UPDATE(IDC_VALUE, OnUpdateValue)
    ON_BN_CLICKED(IDC_CONFIGURE,OnConfigure)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigNumber message handlers

void CConfigNumber::OnDeltaposSpin( NMHDR* pNMHDR, LRESULT* pResult )
{
    NM_UPDOWN FAR *pnmud;
    pnmud = (NM_UPDOWN FAR *)pNMHDR;

    SetModified(TRUE);
    if ( pnmud ) {

        //
        // get current value
        //
        long lVal = CurrentEditValue();

        if (SCE_FOREVER_VALUE == lVal) {
           if (pnmud->iDelta > 0) {
              if (m_cMinutes & DW_VALUE_OFF) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           } else {
              lVal = m_nLow;
           }
        } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
           if (pnmud->iDelta < 0) {
              if (m_cMinutes & DW_VALUE_FOREVER) {
                 lVal = SCE_FOREVER_VALUE;
              } else {
                 lVal = m_nLow;
              }
           } else {
              lVal = m_nHigh;
           }
        } else {
           lVal -= (LONG)(m_iAccRate*pnmud->iDelta);

           if ( lVal > m_nHigh ) {
               // if it is overflow, go back to low
               if ( m_cMinutes & DW_VALUE_OFF ) {
                  lVal = SCE_KERBEROS_OFF_VALUE;

               } else if (m_cMinutes & DW_VALUE_FOREVER) {
                  lVal = SCE_FOREVER_VALUE;
               } else {
                  lVal = m_nLow;
               }
           } else if ( (lVal < m_nLow) &&
                ((lVal != SCE_KERBEROS_OFF_VALUE) || !(m_cMinutes & DW_VALUE_OFF)) &&
                ((lVal != SCE_FOREVER_VALUE) || !(m_cMinutes & DW_VALUE_FOREVER))) {
               // if it is underflow, go back to high
              if ( (m_cMinutes & DW_VALUE_FOREVER) && (lVal != SCE_FOREVER_VALUE)) {
                 lVal = SCE_FOREVER_VALUE;
              } else if ((m_cMinutes & DW_VALUE_OFF) && (lVal != SCE_KERBEROS_OFF_VALUE)) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           }


           if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
               // zero is not allowed
               if ( m_nLow > 0 ) {
                   lVal = m_nLow;
               } else {
                   lVal = 1;
               }
           }
        }

        SetValueToEdit(lVal);
    }

    *pResult = 0;
}

void CConfigNumber::OnKillFocus()
{
   LONG lVal = CurrentEditValue();

   SetValueToEdit(lVal);

}

void CConfigNumber::SetValueToEdit(LONG lVal)
{
    CString strNew;

    SetModified(TRUE);

    if ( m_iStaticId )
        m_strStatic.LoadString(m_iStaticId);
    else
        m_strStatic = _T("");

    if ( 0 == lVal ) {
        strNew.Format(TEXT("%d"),lVal);

        if ( m_cMinutes & DW_VALUE_NEVER &&
                  m_iNeverId > 0 ) {
            // change to never
            m_strStatic.LoadString(m_iNeverId);
        }

    } else if ( SCE_FOREVER_VALUE == lVal ) {

        strNew.LoadString(IDS_FOREVER);
        if ( m_iNeverId ) {
            m_strStatic.LoadString(m_iNeverId);
        }

    } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
       strNew.LoadString(IDS_OFF);
       if ( m_iNeverId ) {
           m_strStatic.LoadString(m_iNeverId);
       }
    } else {
        strNew.Format(TEXT("%d"),lVal);
    }
    m_nSave = lVal;

     SetDlgItemText(IDC_VALUE,strNew);
     SetDlgItemText(IDC_HEADER,m_strStatic);
}

LONG CConfigNumber::CurrentEditValue()
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;

   int length = m_strValue.GetLength(); 
   while( lVal < length && m_strValue.GetAt(lVal) == L'0' ) //Raid #463904, Yang Gao, 9/6/2001.
   {
      lVal++;
   }
   if( lVal > 0 && lVal < length )
   {
      m_strValue.Delete(0, lVal);
      SetDlgItemText(IDC_VALUE, m_strValue);
   }

   uiVal = GetDlgItemInt(IDC_VALUE,&bTrans,TRUE);
   lVal = uiVal;
   if ( !bTrans ) {
      CString str;
      if (m_cMinutes & DW_VALUE_FOREVER) {
         str.LoadString(IDS_FOREVER);
         if (str == m_strValue) {
            return SCE_FOREVER_VALUE;
         }
      }
      lVal = _ttol((LPCTSTR)m_strValue);
      if ( lVal == 0 ) {
         // nonnumeric
         lVal = (LONG) m_nSave;
         return lVal;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      // for log max size, make it multiples of m_iAccRate
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      // if it is overflow, go back to low
      if ( m_cMinutes & DW_VALUE_FOREVER ) {
         lVal = SCE_FOREVER_VALUE;
      } else if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      if ( m_nLow > 0 ) {
         lVal = m_nLow;
      } else {
         lVal = 1;
      }
   }

   return lVal;
}

void CConfigNumber::OnConfigure()
{
   UpdateData(TRUE);

   CAttribute::OnConfigure();

   CWnd* cwnd = GetDlgItem(IDOK);
   if(cwnd)
   {
       if(!m_bConfigure) 
           cwnd->EnableWindow(TRUE);
       else 
           OnUpdateValue();
   }
}



BOOL CConfigNumber::OnInitDialog()
{
    CAttribute::OnInitDialog();
    AddUserControl(IDC_VALUE);
    AddUserControl(IDC_SPIN);
    AddUserControl(IDC_UNITS);

    UpdateData(TRUE);

    OnConfigure();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bSet = FALSE;
      LONG_PTR dw = 0;
      CString strForever;
      CString strOff;

      UpdateData(TRUE);
      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else
         dw = CurrentEditValue();

      CEditTemplate *petSave = m_pData->GetBaseProfile();

      //Raid #715992, yanggao, 10/17/2002.
      //for compitability with template that has SCE_FOREVER_VALUE value.
      if( SCE_NO_VALUE == dw && SCE_FOREVER_VALUE == m_pData->GetBase() 
               && IDS_KERBEROS_RENEWAL == m_pData->GetID() )
      {
         dw = SCE_FOREVER_VALUE;
      }
      //
      // Check dependecies for this item.
      //
      if( IDS_KERBEROS_RENEWAL != m_pData->GetID() )
      {
         if(DDWarn.CheckDependencies((DWORD)dw) == ERROR_MORE_DATA )
         {
            //
            // If it fails and the user presses cancel then we will exit and do nothing.
            //
            CThemeContextActivator activator;
            if( DDWarn.DoModal() != IDOK)
               return FALSE;

            //
            // If the user presses autoset then we set the item and update the result panes.
            //
            for(int i = 0; i < DDWarn.GetFailedCount(); i++)
            {
               PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
               if(pItem && pItem->pResult )
               {
                  pItem->pResult->SetBase( pItem->dwSuggested );
                  SetProfileInfo(
                     pItem->pResult->GetID(),
                     pItem->dwSuggested,
                     pItem->pResult->GetBaseProfile());

                  pItem->pResult->Update(m_pSnapin, FALSE);
               }
            }
         }
      }
      //
      // Update this items profile.
      //
      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());
      m_pData->Update(m_pSnapin, false);

      if( m_bConfigure ) //Raid #460370, Yang Gao, 8/22/2001
      {
         LPTSTR pszAlloc = NULL; //Raid #402030
         m_pData->GetBaseNoUnit(pszAlloc);
         if(pszAlloc)
         {
            SetDlgItemText(IDC_VALUE,pszAlloc);
            delete [] pszAlloc;
         }
      }

   }

   return CAttribute::OnApply();
}

void CConfigNumber::Initialize(CResult * pResult)
{
   LONG_PTR dw=0;

   CAttribute::Initialize(pResult);
   m_strUnits = pResult->GetUnits();
   DDWarn.InitializeDependencies(m_pSnapin,pResult);

   m_cMinutes = DW_VALUE_NOZERO;
   m_nLow = 0;
   m_nHigh = 999;
   m_nSave = 0;
   m_iNeverId = 0;
   m_iAccRate = 1;
   m_iStaticId = 0;
   m_fZero = FALSE; //Raid 482866, Yanggao, 10/25/2001, make sure zero is a useful value.

   BOOL fZerocompatible = FALSE;
   CEditTemplate *pTemplate = pResult->GetBaseProfile();
    switch (pResult->GetID())
        {
    // below no zero value
    case IDS_LOCK_DURATION:
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_nHigh = 99999;
        m_iStaticId = IDS_DURATION;
        m_iNeverId = IDS_LOCKOUT_FOREVER;
        break;
    case IDS_MIN_PAS_AGE:
        m_cMinutes = DW_VALUE_NEVER;
        m_iNeverId = IDS_CHANGE_IMMEDIATELY;
        m_iStaticId = IDS_PASSWORD_CHANGE;
        m_nHigh = 998;
        break;
    case IDS_MAX_PAS_AGE:
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_iStaticId = IDS_PASSWORD_EXPIRE;
        m_iNeverId = IDS_PASSWORD_FOREVER;
        break;
        // below zero value means differently
    case IDS_LOCK_COUNT:
        m_cMinutes = DW_VALUE_NEVER;
        m_iNeverId = IDS_NO_LOCKOUT;
        m_iStaticId = IDS_LOCKOUT_AFTER;
        break;
    case IDS_MIN_PAS_LEN:
        m_cMinutes = DW_VALUE_NEVER;
        m_nHigh = 14;
        m_iNeverId = IDS_PERMIT_BLANK;
        m_iStaticId = IDS_PASSWORD_LEN;
        break;
    case IDS_PAS_UNIQUENESS:
        m_cMinutes = DW_VALUE_NEVER;
        m_nHigh = 24;
        m_iNeverId = IDS_NO_HISTORY;
        m_iStaticId = IDS_PASSWORD_REMEMBER;
        break;
        // below there is no zero values
    case IDS_LOCK_RESET_COUNT:
        m_nLow = 1;
        m_nHigh = 99999;
        m_iStaticId = IDS_RESET_COUNT; //Raid #489966, yanggao, new static string.
        break;
    case IDS_SYS_LOG_MAX:
    case IDS_SEC_LOG_MAX:
    case IDS_APP_LOG_MAX:
        m_nLow = 64;
        m_nHigh = 4194240;
        m_iAccRate = 64;
        // no static text
        break;
    case IDS_SYS_LOG_DAYS:
    case IDS_SEC_LOG_DAYS:
    case IDS_APP_LOG_DAYS:
        m_nHigh = 365;
        m_nLow = 1;
        m_iStaticId = IDS_OVERWRITE_EVENT;
        break;
    case IDS_KERBEROS_MAX_AGE:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       m_nHigh = 99999;
       m_fZero = TRUE; //Raid 482866, Yanggao
       break;
    case IDS_KERBEROS_RENEWAL:
       m_cMinutes = DW_VALUE_FOREVER;
       m_iStaticId = IDS_TICKET_RENEWAL_EXPIRE;
       m_iNeverId = IDS_TICKET_RENEWAL_FOREVER;
       m_nHigh = 99999;
       m_fZero = TRUE; //Raid 482866, Yanggao
       break;
    case IDS_KERBEROS_MAX_SERVICE:
       m_nLow = 10;
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       m_nHigh = 99999;
       m_fZero = TRUE; //Raid 482866, Yanggao
       break;
    case IDS_KERBEROS_MAX_CLOCK:
       m_cMinutes = DW_VALUE_NOZERO;
       m_iStaticId = IDS_MAX_TOLERANCE;
       m_iNeverId = IDS_NO_MAX_TOLERANCE;
       m_nHigh = 99999;
       m_nLow = 1; //Raid #678207,yanggao,9/5/2002
       fZerocompatible = TRUE;
       break;
   }

   if ((m_cMinutes & DW_VALUE_NOZERO) && (0 == m_nLow)) {
      m_nLow = 1;
   }

   m_strStatic = _T("");
   dw = pResult->GetBase();
   //Raid #715992, yanggao, 10/17/2002.
   //for compitability with template that has SCE_FOREVER_VALUE value.
   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw || 
       (IDS_KERBEROS_RENEWAL == pResult->GetID() && SCE_FOREVER_VALUE == dw) )
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      SetInitialValue (dw);
      //In order to handle existing template files with IDS_KERBEROS_MAX_CLOCK being set to "0",
      //UI will display them as what they are only.
      if( fZerocompatible && 0 == (DWORD)dw )
      {
         m_strValue.Format(TEXT("%d"),dw);
         m_nSave = dw;
      }
   }

}

void CConfigNumber::SetInitialValue(DWORD_PTR dw)
{
   //
   // Don't overwrite an already set value.
   //
   if (!m_strValue.IsEmpty()) 
   {
      return;
   }

   //Raid 665368, yanggao, 8/9/2002.
   if (SCE_FOREVER_VALUE == (DWORD)dw) {
      // forever value
      m_strValue.LoadString(IDS_FOREVER);
      if ( (m_cMinutes & DW_VALUE_FOREVER) &&
           m_iNeverId > 0 ) {
         m_strStatic.LoadString(m_iNeverId);
      }
      m_nSave = SCE_FOREVER_VALUE;
   } else if (SCE_KERBEROS_OFF_VALUE == (DWORD)dw) {
      // off value
      m_strValue.LoadString(IDS_OFF);
      if ( (m_cMinutes & DW_VALUE_OFF) &&
           m_iNeverId > 0 ) {
         m_strStatic.LoadString(m_iNeverId);
      }
      m_nSave = SCE_KERBEROS_OFF_VALUE;
   } else {
      if (  0 == (DWORD)dw && (m_cMinutes & DW_VALUE_NOZERO) ) {
         // no zero vallue is allowed
         if ( m_nLow > 0 ) {
            dw = m_nLow;
         } else {
            dw = 1;
         }
      }

      //Raid #652193
      //If this reg value is a string, it should be converted to number because this is a number dialog.
      RESULT_TYPES resultType = m_pData->GetType();
      if( ITEM_PROF_REGVALUE == resultType || ITEM_REGVALUE == resultType || ITEM_LOCALPOL_REGVALUE == resultType )
      {
         PSCE_REGISTRY_VALUE_INFO regThis = (PSCE_REGISTRY_VALUE_INFO)m_pData->GetBase();
         if( regThis && (regThis->ValueType == REG_MULTI_SZ || regThis->ValueType == REG_SZ ||
             regThis->ValueType == REG_EXPAND_SZ) )
         {
            dw =  (DWORD)StrToLong((LPWSTR)dw);
         }
      }
      m_strValue.Format(TEXT("%d"),dw);
      m_nSave = dw;

      if ( 0 == (DWORD)dw && (m_cMinutes & DW_VALUE_NEVER) &&
           m_iNeverId > 0 ) 
      {
         // zero means different values
         m_strStatic.LoadString(m_iNeverId);
      } 
      else if ( m_iStaticId > 0 )
      {
         if( IDS_KERBEROS_RENEWAL == m_pData->GetID() && 0 == dw && m_iNeverId > 0 ) //Raid #730485, 12/18/2002.
         {
            m_strStatic.LoadString(m_iNeverId);
         }
         else
         {
            m_strStatic.LoadString(m_iStaticId);
         }
      }
   }
}

void CConfigNumber::OnUpdateValue()
{
    DWORD dwRes = 0;
    UpdateData(TRUE);
    SetModified(TRUE);

    CString sNum;
    CEdit *pEdit = (CEdit *)GetDlgItem(IDC_VALUE);
    CWnd  *pOK  = GetDlgItem(IDOK);

    DWORD dwValue = _ttoi(m_strValue);


    //
    // Don't do anything if the string is equal to predefined strings.
    //
    sNum.LoadString(IDS_FOREVER);

    if (m_strValue.IsEmpty()) {
       if (pOK) {
          pOK->EnableWindow(FALSE);
       }
    } else if(m_strValue == sNum){
        if(pOK && !QueryReadOnly()){
            pOK->EnableWindow(TRUE);
        }
    } else {

      if((LONG)dwValue < m_nLow){
         //
         // Disable the OK button.
         //
         if( pOK ){
            pOK->EnableWindow(FALSE);
         }

         if(pEdit){
            //
            // We will only force a select if edit text length >=
            //  minimum text length
            //
            sNum.Format(TEXT("%d"), m_nLow);
            dwValue = m_nLow;
            if(sNum.GetLength() < m_strValue.GetLength()){
               pEdit->SetSel(0, -1);
            }
         }
      } else if( (LONG)dwValue > m_nHigh ) {
         if(!QueryReadOnly() && pOK){
            pOK->EnableWindow(TRUE);
         }
         if(pEdit){
            if(m_cMinutes & DW_VALUE_FOREVER){
               sNum.LoadString(IDS_FOREVER);
               dwValue = 0;
            } else {
               sNum.Format(TEXT("%d"), m_nHigh);
               dwValue = m_nHigh;
            }
            m_strValue = sNum;
            UpdateData(FALSE);
            pEdit->SetSel(0, -1);
         }
      } else if(!QueryReadOnly() && pOK){
         //
         // Enable the OK button.
         //
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
      }
   }
    //
    // Load the description for this string.
    //
   if ((dwValue <= 0) && (m_iNeverId != 0)) {
      m_strStatic.LoadString(m_iNeverId);
   } else {
      m_strStatic.LoadString(m_iStaticId);
   }
   GetDlgItem(IDC_HEADER)->SetWindowText(m_strStatic);
}

BOOL CConfigNumber::OnKillActive()
{
    UINT uiVal = 0;
    LONG lVal = 0;
    BOOL bTrans = FALSE;
    CString strRange;
    int lMin = m_nLow;

    UpdateData(TRUE);

    if (!m_bConfigure)
    {
        return TRUE;
    }

    if ((m_cMinutes & DW_VALUE_NOZERO) &&
        !(m_cMinutes & DW_VALUE_FOREVER) &&
        lMin == 0)
    {
        lMin = 1;
    }

    CString strFormat;
    strFormat.LoadString(IDS_RANGE);
    strRange.Format(strFormat,lMin,m_nHigh);

    int length = m_strValue.GetLength(); 
    while( lVal < length && m_strValue.GetAt(lVal) == L'0' ) //Raid #463904, Yang Gao, 9/6/2001.
    {
       lVal++;
    }
    if( lVal > 0 && lVal < length )
    {
       m_strValue.Delete(0, lVal);
       SetDlgItemText(IDC_VALUE, m_strValue);
    }

    uiVal = GetDlgItemInt(IDC_VALUE, &bTrans, TRUE);
    lVal = uiVal;
    if (!bTrans) //invalid numeric string, Raid #529933, yanggao
    {
        CString str;
        if (m_cMinutes & DW_VALUE_FOREVER)
        {
            str.LoadString(IDS_FOREVER);
            if (str == m_strValue)
            {
                return TRUE;
            }
        }
        
        // nonnumeric
        lVal = (LONG) m_nSave;
        if( m_fZero ) //Raid 482866, Yanggao, 10/25/2001
        {
            strFormat.LoadString(IDS_ADDITIONAL_RANGE);
            strRange.Format(strFormat,lMin,m_nHigh);
            m_strError = strRange;
        }
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    if (m_iAccRate > 1 && lVal > 0)
    {
        // for log max size, make it multiples of m_iAccRate
        int nCount = lVal % m_iAccRate;
        if ( nCount > 0 )
        {
            lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
        }
    }

    if (lVal > m_nHigh)
    {
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    if ((lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE))
    {
        // if it is underflow, go back to high
        if (m_cMinutes & DW_VALUE_OFF)
        {
            lVal = SCE_KERBEROS_OFF_VALUE;
        }
        else if (m_cMinutes & DW_VALUE_FOREVER)
        {
            lVal = SCE_FOREVER_VALUE;
        }
        else
        {
            // Leave alone and let the OnKillActive catch it
        }
    }

    if ((lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE))
    {
        // if it is underflow, go back to high
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    if (0 == lVal && (m_cMinutes & DW_VALUE_NOZERO))
    {
        // zero is not allowed
        m_strError = strRange;
        UpdateData(FALSE);
        return FALSE;
    }

    return CAttribute::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cnumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CNumber.h
//
//  Contents:   definition of CConfigNumber
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "attr.h"
#include "ddwarn.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigNumber dialog

class CConfigNumber : public CAttribute
{
// Construction
public:
    CConfigNumber(UINT nTemplateID);   // standard constructor


// Dialog Data
    //{{AFX_DATA(CConfigNumber)
    enum { IDD = IDD_CONFIG_NUMBER };
    CSpinButtonCtrl m_SpinValue;
    CString m_strUnits;
    CString m_strValue;
    CString m_strStatic;
    CString m_strError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigNumber)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    int m_cMinutes;
    long m_nLow;
    long m_nHigh;
    bool m_fZero;
    DWORD_PTR m_nSave;
    int m_iNeverId;
    int m_iAccRate;
    int m_iStaticId;
    CDlgDependencyWarn DDWarn;

    // Generated message map functions
    //{{AFX_MSG(CConfigNumber)
    afx_msg void OnKillFocus();
    afx_msg void OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnConfigure();
    virtual BOOL OnInitDialog();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
	afx_msg void OnUpdateValue();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    virtual void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    LONG CurrentEditValue();
    void SetValueToEdit(LONG lVal);
    void SetZeroValueFlag(bool bVal) { m_fZero = bVal; };
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNUMBER_H__7F9B3B37_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CObject.h
//
//  Contents:   definition of CConfigObject
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigObject dialog

class CConfigObject : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    CConfigObject(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigObject)
	enum { IDD = IDD_CONFIG_OBJECT };
	int		m_radConfigPrevent;
	int		m_radInheritOverwrite;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigObject)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnTemplateSecurity();
	afx_msg void OnConfig();
	afx_msg void OnPrevent();
    afx_msg void OnOverwriteInherit();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
   virtual void EnableUserControls( BOOL bEnable );
private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

    HWND m_hwndSecurity;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cobject.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cobject.cpp
//
//  Contents:   implementation of CConfigObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include "servperm.h"
#include "CObject.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigObject dialog


CConfigObject::CConfigObject(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_pfnCreateDsPage(NULL), 
m_pSI(NULL), 
m_pNewSD(NULL), 
m_NewSeInfo(0), 
m_hwndSecurity(NULL)

{

    //{{AFX_DATA_INIT(CConfigObject)
        m_radConfigPrevent = 0;
        m_radInheritOverwrite = 0;
        //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a197HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigObject::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigObject)
        DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
        DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigObject, CAttribute)
    //{{AFX_MSG_MAP(CConfigObject)
    ON_BN_CLICKED(IDC_SECURITY, OnTemplateSecurity)
        ON_BN_CLICKED(IDC_CONFIG, OnConfig)
        ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
        ON_BN_CLICKED(IDC_OVERWRITE, OnOverwriteInherit)
        ON_BN_CLICKED(IDC_INHERIT, OnOverwriteInherit)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigObject message handlers

BOOL CConfigObject::OnApply()
{
   if ( !m_bReadOnly )
   {
       DWORD dw = 0;
       int status = 0;

       UpdateData(TRUE);
       PEDITTEMPLATE pTemp = m_pData->GetBaseProfile();

       switch (m_radConfigPrevent) 
       {
          case 0:
             // config
             switch(m_radInheritOverwrite) 
             {
                case 0:
                   // inherit
                   dw = SCE_STATUS_CHECK;
                   break;

                case 1:
                   // overwrite
                   dw = SCE_STATUS_OVERWRITE;
                   break;

                default:
                   break;
             }
             break;

          case 1:
             // prevent
             dw = SCE_STATUS_IGNORE;
             break;

          default:
             break;
       }

       PSCE_OBJECT_SECURITY pObjSec=(PSCE_OBJECT_SECURITY)(m_pData->GetID());

       if ( NULL == pObjSec ) 
       {
           //
           // this branch is impossible
           //
           if ( m_pNewSD != NULL ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           //
           // an existing object
           //
           pObjSec->Status = (BYTE)dw;

           if ( m_pNewSD != NULL ) 
           {
               if ( pObjSec->pSecurityDescriptor != m_pNewSD &&
                    pObjSec->pSecurityDescriptor != NULL ) 
               {
                   LocalFree(pObjSec->pSecurityDescriptor);
               }
               pObjSec->pSecurityDescriptor = m_pNewSD;
               m_pNewSD = NULL;

               pObjSec->SeInfo = m_NewSeInfo;
           }
           m_pData->SetStatus(dw);
       }
       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;

       if ( m_pSI ) 
       {
           m_pSI->Release();
           m_pSI = NULL;
       }
       m_pfnCreateDsPage=NULL;
   }

    return CAttribute::OnApply();
}

void CConfigObject::OnCancel()
{
    if ( m_pNewSD ) {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CAttribute::OnCancel();
}

void CConfigObject::OnTemplateSecurity()
{
    SE_OBJECT_TYPE SeType;

    if (IsWindow(m_hwndSecurity)) {
       ::BringWindowToTop(m_hwndSecurity);
       return;
    }

    switch(m_pData->GetType()) {
    case ITEM_PROF_REGSD:
       SeType = SE_REGISTRY_KEY;
       break;
    case ITEM_PROF_FILESD:
        SeType = SE_FILE_OBJECT;
       break;
    default:
       ASSERT(FALSE);
       return;
    }

    INT_PTR nRet;

    if ( SE_DS_OBJECT == SeType ) {

        if ( !m_pfnCreateDsPage ) {
            if (!g_hDsSecDll)
                g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

            if ( g_hDsSecDll) {
                m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                               "DSCreateISecurityInfoObject");
            }
        }

        if ( m_pfnCreateDsPage ) {
            nRet= MyCreateDsSecurityPage(&m_pSI, m_pfnCreateDsPage,
                                         &m_pNewSD, &m_NewSeInfo,
                                        (LPCTSTR)(m_pData->GetAttr()),
                                        QueryReadOnly() ? SECURITY_PAGE_READ_ONLY : SECURITY_PAGE,
                                        m_hwndParent);
        } else
            nRet = -1;

    } else {
        BOOL bContainer;
        if ( SE_FILE_OBJECT == SeType ) {
            if ( m_pData->GetID() ) {
               bContainer = ((PSCE_OBJECT_SECURITY)(m_pData->GetID()))->IsContainer;
            } else {
               bContainer = FALSE;
            }
        } else {
           bContainer = TRUE;
        }
        m_hwndSecurity = (HWND) MyCreateSecurityPage2(bContainer,
                                               &m_pNewSD,
                                               &m_NewSeInfo,
                                               (LPCTSTR)(m_pData->GetAttr()),
                                               SeType,
                                               QueryReadOnly() ? SECURITY_PAGE_READ_ONLY : SECURITY_PAGE,
                                               GetSafeHwnd(),
                                               FALSE);  // not modeless
    }

    if (NULL == m_hwndSecurity ) {
/*
        BUG 147098 applies here - don't display message if this was canceled
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);
*/
    }

}

void CConfigObject::Initialize(CResult * pData)
{
   CAttribute::Initialize(pData);

   if ( m_pSI ) {
       m_pSI->Release();
       m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   m_pNewSD = NULL;
   m_NewSeInfo = 0;

//   if (SCE_NO_VALUE == pData->GetBase()) {
   if ( pData->GetID() ) {

      PSCE_OBJECT_SECURITY pObject = (PSCE_OBJECT_SECURITY)(pData->GetID());

      switch (pObject-> Status) {
         case SCE_STATUS_IGNORE:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_OVERWRITE:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 1;
            break;
         case SCE_STATUS_CHECK:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_NO_AUTO_INHERIT:
         default:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
      }

      if ( pObject->pSecurityDescriptor ) {

           MyMakeSelfRelativeSD(pObject->pSecurityDescriptor,
                                &m_pNewSD);
      }
      m_NewSeInfo = pObject->SeInfo;

   }
}



BOOL CConfigObject::OnInitDialog()
{
    CAttribute::OnInitDialog();

    UpdateData(FALSE);
    AddUserControl(IDC_OVERWRITE);
    AddUserControl(IDC_PREVENT);
    AddUserControl(IDC_INHERIT);
    AddUserControl(IDC_SECURITY);
    AddUserControl(IDC_CONFIG);

    OnConfigure();

    if (ITEM_PROF_REGSD == m_pData->GetType()) {
       CString str;
       str.LoadString(IDS_REGISTRY_CONFIGURE);
       SetDlgItemText(IDC_CONFIG,str);
       str.LoadString(IDS_REGISTRY_APPLY);
       SetDlgItemText(IDC_OVERWRITE,str);
       str.LoadString(IDS_REGISTRY_INHERIT);
       SetDlgItemText(IDC_INHERIT,str);
       str.LoadString(IDS_REGISTRY_PREVENT);
       SetDlgItemText(IDC_PREVENT,str);
    }
    if (QueryReadOnly()) {
       CString str;
       str.LoadString(IDS_VIEW_SECURITY);
       SetDlgItemText(IDC_SECURITY,str);
    }
    if (m_bConfigure) {
       if (0 == m_radConfigPrevent) {
          OnConfig();
       } else {
          OnPrevent();
       }
    }
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigObject::OnConfig()
{
   CWnd *pRadio = 0;

   int privValue = m_radConfigPrevent; //Raid #478746, Yanggao, 10/10/2001
   UpdateData(); 
   if (m_bConfigure && !QueryReadOnly()) 
   {
      pRadio = GetDlgItem(IDC_INHERIT);
      pRadio->EnableWindow(TRUE);
      pRadio = GetDlgItem(IDC_OVERWRITE);
      pRadio->EnableWindow(TRUE);
      pRadio = GetDlgItem(IDC_SECURITY); //Raid #467312, Yang Gao
      if( pRadio )
         pRadio->EnableWindow(TRUE);
      if(m_radConfigPrevent != privValue) //Raid #478746, Yanggao, 10/10/2001
      {
         SetModified(TRUE);
      }
   }
}

void CConfigObject::OnPrevent()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(FALSE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(FALSE);
   pRadio = GetDlgItem(IDC_SECURITY); //Raid #467312, Yang Gao
   if( pRadio )
      pRadio->EnableWindow(FALSE); 

   int privValue = m_radConfigPrevent; //Raid #478746, Yanggao, 10/10/2001
   UpdateData(); 
   if(m_radConfigPrevent != privValue)
   {
      SetModified(TRUE);
   }

}

void CConfigObject::OnOverwriteInherit() //Raid #478746, Yanggao, 10/10/2001
{
   int privValue = m_radInheritOverwrite;
   UpdateData(); 
   if(m_radInheritOverwrite != privValue)
   {
      SetModified(TRUE);
   }

}

void
CConfigObject::EnableUserControls( BOOL bEnable ) {
   CAttribute::EnableUserControls(bEnable);
   //
   // IDC_SECURITY needs to be available even in read only
   // mode so that the security page can be viewed.
   //
   // The page itself will be read only if necessary
   //
   if (QueryReadOnly() && bEnable) {
      CWnd *wnd = GetDlgItem(IDC_SECURITY);
      if (wnd) {
         wnd->EnableWindow(TRUE);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\command.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       command.cpp
//
//  Contents:   implementation of CComponentDataImpl
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wrapper.h"
#include "snapmgr.h"
#include "asgncnfg.h"
#include "util.h"
#include <io.h>
#include <Dlgs.h>

static BOOL RecursiveCreateDirectory(
    IN LPCTSTR pszDir
    )
{
    DWORD   dwAttr;
    DWORD   dwErr;
    LPCTSTR psz;
    DWORD   cch;
    WCHAR   wch;
    LPTSTR  pszParent = NULL;
    BOOL    fResult = FALSE;

    dwAttr = GetFileAttributes(pszDir);

    if (0xFFFFFFFF != dwAttr)
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
            fResult = TRUE;
        goto CommonReturn;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        return FALSE;

    //This is a safe usage. pszDir is a full path.
    if (CreateDirectory(pszDir, NULL))  // lpSecurityAttributes
    {
        fResult = TRUE;
        goto CommonReturn;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto CommonReturn;

    // Peal off the last path name component
    cch = _tcslen(pszDir);
    psz = pszDir + cch;

    while (TEXT('\\') != *psz)
    {
        if (psz == pszDir)
            // Path didn't have a \.
            goto CommonReturn;
        psz--;
    }

    cch = (DWORD)(psz - pszDir);
    if (0 == cch)
        // Detected leading \Path
       goto CommonReturn;

    // Check for leading \\ or x:\.
    wch = *(psz - 1);
    if ((1 == cch && TEXT('\\') == wch) || (2 == cch && TEXT(':') == wch))
        goto CommonReturn;

    if (NULL == (pszParent = (LPWSTR) LocalAlloc(0, (cch + 1) * sizeof(WCHAR))))
        goto CommonReturn;
    //This may not be a safe usage, using TCHAR instead of WCHAR. Consider fix.
    memcpy(pszParent, pszDir, cch * sizeof(TCHAR));
    pszParent[cch] = TEXT('\0');

    //This is a safe usage, pszParent is a full path.
    if (!RecursiveCreateDirectory(pszParent))
        goto CommonReturn;
    if (!CreateDirectory(pszDir, NULL))                // lpSecurityAttributes
    {
        dwErr = GetLastError();
        goto CommonReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (pszParent != NULL)
        LocalFree(pszParent);
    return fResult;
}

//+------------------------------------------------------------------------------------
// CComponentDataImpl::GetWorkingDir
//
// Gets the default or last set directory used for the uIDDir.
// Some defaults defined by this function are.
//
// %windir%\security\database    - ANALYSIS
// %windir%\security\Templates   - Default profile location.
//
// Arguments:  [uIDDir]    - The ID of the working directory to set or retrieve.
//             [pStr]      - Either the source or the return value.   When the
//                            function returns this value will be set to a directory
//                            location.
//
//             [bSet]      - TRUE if [pStr] is to be set as the new working directory.
//             [bFile]     - [pStr] contains a file name.
//
// Returns:    TRUE        - If the function succees.
//             FALSE       - if something went wrong.
//             We don't really need to much granularity because this is not a critical
//             function.
//+------------------------------------------------------------------------------------
BOOL
CComponentDataImpl::GetWorkingDir(
   GWD_TYPES uIDDir,
   LPTSTR *pStr,
   BOOL bSet,
   BOOL bFile
   )
{
   BOOL fRet = FALSE;

   if(!pStr)
   {
      return FALSE;
   }

   LPTSTR szLocationValue = NULL;
   switch(uIDDir)
   {
      case GWD_CONFIGURE_LOG:
         szLocationValue = CONFIGURE_LOG_LOCATIONS_KEY;
         break;
      case GWD_ANALYSIS_LOG:
         szLocationValue = ANALYSIS_LOG_LOCATIONS_KEY;
         break;
      case GWD_OPEN_DATABASE:
         szLocationValue = OPEN_DATABASE_LOCATIONS_KEY;
         break;
      case GWD_IMPORT_TEMPLATE:
         szLocationValue = IMPORT_TEMPLATE_LOCATIONS_KEY;
         break;
      case GWD_EXPORT_TEMPLATE:
         szLocationValue = IMPORT_TEMPLATE_LOCATIONS_KEY; //104152, yanggao, 3/21/2001
         break;
   }


   LPTSTR pszPath = NULL;
   int i = 0;

   if( bSet )
   {
      if(!pStr || !(*pStr))
         return FALSE;

      i = lstrlen( *pStr );
      if(bFile)
      {
         //
         // Remove the file from the end of the string.
         //
         while(i && (*pStr)[i] != '\\')
            i--;
      }

      //
      // Create space for the new path and copy what we want.
      //
      pszPath = (LPTSTR)LocalAlloc( 0, (i + 1) * sizeof(TCHAR));
      if(!pszPath)
         return FALSE;
      //This is a safe usage.
      memcpy(pszPath, *pStr, (i * sizeof(TCHAR)));
      pszPath[i] = 0;

      MyRegSetValue(HKEY_CURRENT_USER,
                    DEFAULT_LOCATIONS_KEY,
                    szLocationValue,
                    (BYTE*)pszPath,
                    (i+1)*sizeof(TCHAR),
                    REG_SZ);

      LocalFree(pszPath);
      return TRUE;
   }

   DWORD dwType = REG_SZ;
   if (MyRegQueryValue(HKEY_CURRENT_USER,
                   DEFAULT_LOCATIONS_KEY,
                   szLocationValue,
                   (PVOID*)&pszPath,
                   &dwType) == ERROR_SUCCESS)
   {
      *pStr = pszPath;
      return TRUE;
   }

   CString  sAppend;
   DWORD    dwRet;
   pszPath = NULL;

   switch ( uIDDir )
   {
      case GWD_CONFIGURE_LOG:
      case GWD_ANALYSIS_LOG:
         sAppend.LoadString(IDS_LOGFILE_DEFAULT);
         // fall through
      case GWD_OPEN_DATABASE:
         //
         // Used for open DB.
         //
         if (sAppend.IsEmpty())
         {
            sAppend.LoadString( IDS_DB_DEFAULT );
         } // else fell through


         //
         // Default directory for analysis.
         //
         pszPath = (LPTSTR)LocalAlloc( 0, (MAX_PATH +  sAppend.GetLength() + 1) * sizeof(TCHAR));
         if (pszPath == NULL)
            return FALSE;

         if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, pszPath)))
         {
            //This is a safe usage, yanggao.
            lstrcpy( &(pszPath[lstrlen(pszPath)]), sAppend );

            //
            // Check to see if the directory does not exist, it may need
            // to be created if this is the first time this user has
            // opened a database.
            //
            TCHAR szTempFile[MAX_PATH];
            CString str;

			   str.LoadString(IDS_TEMP_FILENAME);
			   if (!GetTempFileName(pszPath,str,0,szTempFile)) //This is not a safe usage. Raid #555912, yanggao.
            {
               if ((GetLastError() == ERROR_DIRECTORY) && (RecursiveCreateDirectory(pszPath)))
               {
                  fRet = TRUE;
               }
               else
               {
                  LocalFree(pszPath);
                  fRet = FALSE;
               }
            }
            else
            {
               DeleteFile(szTempFile);
               fRet = TRUE;
            }
         }
         else
         {
            LocalFree(pszPath);
            pszPath = NULL;
         }
         break;

      case GWD_IMPORT_TEMPLATE:
      case GWD_EXPORT_TEMPLATE:

         sAppend.LoadString( IDS_DEFAULT_TEMPLATE_DIR );

         //
         // Default directory for analysis.
         //
         dwRet = GetSystemWindowsDirectory( NULL, 0);
         if (dwRet)
         {
            pszPath = (LPTSTR)LocalAlloc( 0, (dwRet +  sAppend.GetLength() + 1) * sizeof(TCHAR));
            if (!pszPath)
               return FALSE;

            GetSystemWindowsDirectory( pszPath, dwRet + 1);
            //This is a safe usage, yanggao.
            lstrcpy( &(pszPath[lstrlen(pszPath)]), sAppend );

            i = lstrlen(pszPath);

            //
            // Make sure the user can write to this directory:
            //
            TCHAR szTempFile[MAX_PATH];
            HANDLE hTempFile=NULL;
			CString str;

			str.LoadString(IDS_TEMP_FILENAME);
            szTempFile[0] = L'\0';
            if (GetTempFileName(pszPath,str,0,szTempFile)) //This is not a safe usage. Raid #555912, yanggao.
            {
               hTempFile = ExpandAndCreateFile(szTempFile,
                                               GENERIC_READ|GENERIC_WRITE,
                                               0,
                                               NULL,
                                               CREATE_NEW,
                                               FILE_ATTRIBUTE_TEMPORARY,
                                               NULL);
            }
            if (hTempFile)
            {
               //
               // We have write access to this directory
               //
               ::CloseHandle(hTempFile);
               DeleteFile(szTempFile);
               fRet = TRUE;
            }
            else
            {
               //
               // We don't have write access to this directory.  Find another
               // or we can't get a temp file name
               //
               LPTSTR szPath;
               LPITEMIDLIST pidl;
               LPMALLOC pMalloc;

               //
               // For some reason this won't compile with SHGetFolderPath()
               // Therefore go the long way around and deal with the pidl.
               //
               if (NOERROR == SHGetSpecialFolderLocation(m_hwndParent,CSIDL_PERSONAL,&pidl))
               {
                  if (SHGetPathFromIDList(pidl,szTempFile))
                  {
                     szPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szTempFile)+ 1) * sizeof(TCHAR));
                     if (szPath)
                     {
                        //
                        // If we can't create a new path then use the old one so the user
                        // at least has a starting place to browse from
                        //
                        //This is a safe usage.
                        lstrcpy(szPath,szTempFile);
                        LocalFree(pszPath);
                        pszPath = szPath;
                        fRet = TRUE;
                     }
                  }
                  if (SUCCEEDED(SHGetMalloc(&pMalloc)))
                  {
                     pMalloc->Free(pidl);
                     pMalloc->Release();
                  }
               }
               //
               // If we can't write here the user will have to browse for something
               //
            }
         }
         break;
   }

   *pStr = pszPath;
   return fRet;
}

UINT_PTR CALLBACK OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
{

    if ( WM_NOTIFY == uiMsg )
    {
        OFNOTIFY* pOFNotify = (OFNOTIFY*) lParam;
        if ( pOFNotify && CDN_FILEOK == pOFNotify->hdr.code )
        {
            //
            // Don't accept filenames with DBCS characters that are greater then 255 in them
            //
            CString strErr;
            CString strtemp;
            long templen = wcslen(pOFNotify->lpOFN->lpstrDefExt) + 2;//Raid #533603, yanggao, 4/17/2002.
            strtemp = pOFNotify->lpOFN->lpstrFile;
            strErr = pOFNotify->lpOFN->lpstrDefExt;
            if( L"\\."+ strErr == strtemp.Right(templen) || L"/."+strErr == strtemp.Right(templen) )
            {
                strErr.FormatMessage(IDS_INVALID_DBNAME, pOFNotify->lpOFN->lpstrFile, pOFNotify->lpOFN->lpstrDefExt);
                AppMessageBox(NULL,strErr,NULL,MB_ICONSTOP|MB_OK);
                SetFocus(GetDlgItem(GetParent(hdlg), cmb13));
                ::SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
                return 1;
            }
            templen = wcslen(pOFNotify->lpOFN->lpstrFile); //Raid #401060
            if( templen >= MAX_PATH || (templen-strtemp.ReverseFind(L'.'))-1 != wcslen(pOFNotify->lpOFN->lpstrDefExt) )
            {
                //This is a safe usage.
                strErr.FormatMessage(IDS_DB_NAME_SPACE_NOT_ENOUGH, pOFNotify->lpOFN->lpstrFile);
                strtemp.LoadString(IDS_PATH_TOO_LONG);
                strErr = strErr + L"\n" + strtemp;
                AppMessageBox(NULL,strErr,NULL,MB_ICONSTOP|MB_OK);
                SetFocus(GetDlgItem(GetParent(hdlg), cmb13)); //Raid #502393.
                ::SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
                return 1;
            }
            templen = templen - wcslen(pOFNotify->lpOFN->lpstrDefExt);
            if( _wcsicmp(pOFNotify->lpOFN->lpstrFile+templen, pOFNotify->lpOFN->lpstrDefExt) != 0 )
            {
                //This is a safe usage.
                strErr.FormatMessage(IDS_DB_NAME_SPACE_NOT_ENOUGH, pOFNotify->lpOFN->lpstrFile);
                strtemp.LoadString(IDS_ERR_FILE_EXTENSION); //Raid #567739, yanggao, 4/4/2002.
                strErr = strErr + L"\n" + strtemp;
                AppMessageBox(NULL,strErr,NULL,MB_ICONSTOP|MB_OK);
                SetFocus(GetDlgItem(GetParent(hdlg), cmb13)); //Raid #502393.
                ::SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
                return 1;
            }
            
            //Raid #263854, 4/3/2001
            BOOL ferr = TRUE;
            // This is a safe usage. yanggao
            if(WideCharToMultiByte(CP_ACP, 0, pOFNotify->lpOFN->lpstrFile,
                                    -1, NULL, 0, NULL, &ferr))
            {
                return 0;
            }

            strErr.LoadString(IDS_NO_DBCS);
            strErr += L"\r\n\r\n";
            strErr += pOFNotify->lpOFN->lpstrFile;
            AppMessageBox(NULL,strErr,NULL,MB_ICONSTOP|MB_OK);

            ::SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);

            return 1;
        }
    }
    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnOpenDataBase()
//
//  Synopsis:   Picks a new database for SAV to work on
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnOpenDataBase()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDir;

   strDefExtension.LoadString(IDS_DEFAULT_DB_EXTENSION);
   strFilter.LoadString(IDS_DB_FILTER);

   strOfnTitle.LoadString(IDS_OPEN_DB_OFN_TITLE);

   LPTSTR pszDir = NULL;
   //
   // Build a working directory for this object,
   //
   if (GetWorkingDir( GWD_OPEN_DATABASE, &pszDir ) )
   {
      strDir = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }

   WCHAR           szFile[MAX_PATH];
   ::ZeroMemory (szFile, MAX_PATH * sizeof(WCHAR));
   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = m_hwndParent;
    //HINSTANCE     hInstance;

    // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
    // MFC delimits with '|' not '\0'
   LPTSTR pch = szFilter;
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH; //Raid #567739, yanggao, 4/4/2002.
    ofn.lpstrInitialDir = (PCWSTR) strDir;
    ofn.lpstrTitle = strOfnTitle;
    ofn.Flags = OFN_HIDEREADONLY|    // Don't show the read only prompt
                OFN_SHAREAWARE|
                OFN_NOREADONLYRETURN|
                OFN_EXPLORER |        // Explorer style dialog;
                OFN_DONTADDTORECENT|
                OFN_ENABLEHOOK;
    ofn.lpstrDefExt = (PCWSTR) strDefExtension;
    ofn.lpfnHook = OFNHookProc;

   if ( GetOpenFileName (&ofn) )
   {
      //
      // Set the working directory of the database.
      //
      pszDir = szFile;
      GetWorkingDir( GWD_OPEN_DATABASE, &pszDir, TRUE, TRUE );
     if( IsSystemDatabase( ofn.lpstrFile /*fo.GetPathName()*/) )
     {
         AfxMessageBox( IDS_CANT_OPEN_SYSTEM_DB, MB_OK);
         return S_FALSE;
     }
     SadName = ofn.lpstrFile; //fo.GetPathName();
     SetErroredLogFile(NULL);
      //
      // If new database doesn't exist then ask for a configuration to import
      //

     DWORD dwAttr = GetFileAttributes(SadName);

     if (0xFFFFFFFF == dwAttr)
     {
         SCESTATUS sceStatus = SCESTATUS_SUCCESS;
         //
         // New database, so assign a configuration
         //
         if( OnAssignConfiguration( &sceStatus ) == S_FALSE)
         {
                     //
            // If the user decides to cancel the import of a configuration, then,
            // we need to unload the sad information and display the correct
            // error message.  Set the sad errored to PROFILE_NOT_FOUND so error,
            // is correct. There is no need to call LoadSadinfo.
            //
            UnloadSadInfo();
            if( sceStatus != SCESTATUS_SUCCESS )
               SadErrored = sceStatus;
            else
               SadErrored = SCESTATUS_PROFILE_NOT_FOUND;
            if(m_AnalFolder)
            {
               m_pConsole->SelectScopeItem(m_AnalFolder->GetScopeItem()->ID);
            }

            SadName.Empty(); //Raid #459576, Yang Gao, 8/29/2001
            
            return S_OK;
         }
     }

      //
      // Invalidiate currently open database
      //
      RefreshSadInfo();
      return S_OK;
   }
   else
   {
       DWORD dwErr = CommDlgExtendedError();
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnNewDataBase()
//
//  Synopsis:   Picks a new database for SAV to work on
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnNewDatabase()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CWnd cwndParent;

   strDefExtension.LoadString(IDS_DEFAULT_DB_EXTENSION);
   strFilter.LoadString(IDS_DB_FILTER);
   strOfnTitle.LoadString(IDS_NEW_DB_OFN_TITLE);

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters

   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = SadName.GetBuffer(MAX_PATH);
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetOpenFileName(&ofn))
   {
      PVOID pHandle = NULL;

      SadName.ReleaseBuffer();
      //
      // If new database doesn't exist then ask for a configuration to import
      //
      DWORD dwAttr = GetFileAttributes(SadName);

      if (0xFFFFFFFF == dwAttr)
      {
         //
         // New database, so assign a configuration
         //
         SCESTATUS sceStatus;
         OnAssignConfiguration(&sceStatus);
      }

      //
      // Invalidiate currently open database
      //
      SetErroredLogFile(NULL);
      RefreshSadInfo();
      return S_OK;
   }

   return S_FALSE;
}


//+--------------------------------------------------------------------------
//
//  Method:     OnAssignConfiguration()
//
//  Synopsis:   Assigns a configuration template to SAV's currently selected
//              database
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnAssignConfiguration( SCESTATUS *pSceStatus )
{

   //
   //Currently pSceStatus is only used for passing back the error
   //when user presses cancel on select template diaglog.


   //
   // Find the desired new database
   //
   CString strDefExtension;         // Default extension
   CString strCurFile;
   CString strFilter;               // Extension filter
   CString strOfnTitle;
   CWnd cwndParent;
   BOOL bIncremental;
   SCESTATUS status;
   HKEY hKey;                       // HKEY of TemplateUsed.
   DWORD dwBufSize = 0;             // Size of szTemplateUsed in bytes
   DWORD dwType    = 0;             // Type of registry item, return by query
   DWORD dwStatus;

   *pSceStatus = 0;

   //
   // Display a warning and give a chance to cancel
   // if they try to configure a non-system database
   //
   if (IsSystemDatabase(SadName))
   {
      BOOL bImportAnyway;

      bImportAnyway = AfxMessageBox(IDS_IMPORT_WARNING,MB_OKCANCEL);
      if (IDCANCEL == bImportAnyway)
      {
         return S_FALSE;
      }
   }


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_ASSIGN_CONFIG_OFN_TITLE);

   //
   // Get the last directory used by templates.
   //
   LPTSTR pszDir = NULL;
   if(strCurFile.IsEmpty())
   {
      if (GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
      {
         strCurFile = pszDir;
         LocalFree(pszDir);
         pszDir = NULL;
      }
   }
   strCurFile += TEXT("\\*.");
   strCurFile += strDefExtension;

   cwndParent.Attach(m_hwndParent);
   CAssignConfiguration ac(TRUE,        // File Open, not file save
                  strDefExtension,      // Default Extension
                  strCurFile,           // Initial File Name == current DB
                  OFN_HIDEREADONLY|     // Don't show the read only prompt
                  OFN_EXPLORER|         // Explorer style dialog
                  OFN_ENABLETEMPLATE|   // custom template
                  OFN_SHAREAWARE|       // We're not going to need exclusive
                  OFN_DONTADDTORECENT|
                  OFN_FILEMUSTEXIST,    // The Template must exist for us to assign it. Raid #535787, yanggao.
                  strFilter,            // Filter for allowed extensions
                  &cwndParent);         // Dialog's Parent window

   cwndParent.Detach();

   ac.m_ofn.lpstrTitle = strOfnTitle.GetBuffer(1);
   ac.m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ASSIGN_CONFIG_CHECK);
   if (IDOK == ac.DoModal())
   {
      CThemeContextActivator activator;
      strCurFile = ac.GetPathName();
      bIncremental = ac.m_bIncremental;

      //
      // Set the working dir to this file.
      //
      pszDir = strCurFile.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE);
      strCurFile.ReleaseBuffer();
      CWaitCursor wc;

      //
      // Unload the sad info before we choose to do an import.
      //
      UnloadSadInfo();
      status = AssignTemplate(
                    strCurFile.IsEmpty() ? NULL:(LPCTSTR)strCurFile,
                    SadName,
                    bIncremental
                    );

      if (SCESTATUS_SUCCESS != status)
      {
         CString strErr;

         MyFormatResMessage(status,IDS_IMPORT_FAILED,NULL,strErr);
         AfxMessageBox(strErr);

         //
         // We don't know if the database is still OK to read so open it anyways.
         //
         LoadSadInfo(TRUE);
         if( SCESTATUS_SPECIAL_ACCOUNT == SadErrored )//Raid #589139, DCR, yanggao, 4/12/2002.
            *pSceStatus = SadErrored;
         return S_FALSE;
      }

      //remove RefreshSadInfo() because we can't do it two times. The second call will delete the file
      //created by first call. Raid#668551, yanggao. 8/26/2002
      return S_OK;
   }
   *pSceStatus = SCESTATUS_NO_TEMPLATE_GIVEN;
    return S_FALSE;

}

//+--------------------------------------------------------------------------
//
//  Method:     OnSecureWizard()
//
//  Synopsis:   Launch the secure wizard (registered)
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnSecureWizard()
{

    HRESULT hr=S_FALSE;
    PWSTR pstrWizardName=NULL;

    if ( GetSecureWizardName(&pstrWizardName, NULL) )
    {

        PROCESS_INFORMATION ProcInfo;
        STARTUPINFO StartInfo;
        BOOL fOk;


        RtlZeroMemory(&StartInfo,sizeof(StartInfo));
        StartInfo.cb = sizeof(StartInfo);
        StartInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartInfo.wShowWindow = (WORD)SW_SHOWNORMAL;
        //This is a safe usage if pstrWizardName is a full path for security wizard.
        fOk = CreateProcess(pstrWizardName, NULL,
                       NULL, NULL, FALSE,
                       0,
                       NULL,
                       NULL,
                       &StartInfo,
                       &ProcInfo
                       );

        if ( fOk )
        {
            ::CloseHandle(ProcInfo.hProcess);
            ::CloseHandle(ProcInfo.hThread);

            hr = S_OK;
        }

        LocalFree(pstrWizardName);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnSaveConfiguration()
//
//  Synopsis:   Saves the assigned computer template to an INF file
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnSaveConfiguration()
{
   //
   // Find the desired new database
   //
   CString strDefExtension;
   CString strFilter;
   CWnd cwndParent;
   CString strDefName;
   CString strName;
   SCESTATUS status = SCESTATUS_SUCCESS;
   CString strOfnTitle;

   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_EXPORT_CONFIG_OFN_TITLE);

   //
   // Get the working directory for INF files.
   //
   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT|OFN_ENABLEHOOK;
   ofn.lpstrTitle = strOfnTitle;
   ofn.lpfnHook = OFNHookProc; //Raid #567750, yanggao.

   if (GetSaveFileName(&ofn))
   {
      strDefName.ReleaseBuffer();
      strName = ofn.lpstrFile;

      //
      // Set the working directory for inf files.
      //
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      //
      // Generate new inf file
      //

      status = SceCopyBaseProfile(GetSadHandle(),
                                  SCE_ENGINE_SCP,
                                  (LPTSTR)(LPCTSTR)strName,
                                  AREA_ALL,
                                  NULL );
      if (SCESTATUS_SUCCESS != status)
      {
         CString str;
         CString strErr;

         MyFormatMessage( status, NULL, NULL, strErr); //Raid #621091, yanggao
         AfxFormatString2(str,IDS_EXPORT_FAILED,strName,strErr);
         AfxMessageBox(str);
         return S_FALSE;
      }

      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnExportPolicy()
//
//  Synopsis:   This function exports either the effective or local table
//              from the system security database to a file.
//
//              The function asks the user for a file through the CFileOpen
//              class, then writes out the contents of either the effective
//              or local policy table in the system database.
//
//  Arguments:  [bEffective]  - Either to export the effect or local table.
//
//  Returns:    S_OK    - if everything went well.
//              S_FALSE - something failed.
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnExportPolicy( BOOL bEffective )
{
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDefName;
   CString strName;
   DWORD dwErr = 0;
   BOOL bCopySuccess = FALSE;
   //Raid #604879, yanggao, 4/24/2002
   PEDITTEMPLATE pTemplateInfo = NULL;
   AREA_INFORMATION area = AREA_SECURITY_POLICY|AREA_PRIVILEGES;
   if( m_Mode == SCE_MODE_LOCAL_COMPUTER )
   {
      strName = GT_LOCAL_POLICY;
      if (!SadHandle || ERROR_SUCCESS != SadErrored ) 
      {
         LoadSadInfo(FALSE);
         if( !SadHandle || ERROR_SUCCESS != SadErrored )
            return S_FALSE;
      }
      pTemplateInfo = GetTemplate(strName,area,&dwErr);
      if( !pTemplateInfo )
      {
         return S_FALSE;
      }
   }

   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_EXPORT_POLICY_OFN_TITLE);

   //
   // Get the working directory for locations.
   //
   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   // Translate filter into commdlg format (lots of \0)
   LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
   // MFC delimits with '|' not '\0'
   while ((pch = _tcschr(pch, '|')) != NULL)
      *pch++ = '\0';
    // do not call ReleaseBuffer() since the string contains '\0' characters


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT;
   ofn.lpstrTitle = strOfnTitle;

   if (GetSaveFileName(&ofn))
   {
      strDefName.ReleaseBuffer();
      strName = ofn.lpstrFile;

      //
      // Set the working directory for locations.
      //
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_EXPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();

      //
      // Make sure we can make the file.
      //
      dwErr = FileCreateError( strName, 0 ); //Raid #prefast
      if(dwErr == IDNO)
      {
         return S_FALSE;
      }

      //
      // Generate the template
      //

      SCESTATUS sceStatus;
      CWaitCursor wc;
      //Raid #604879, yanggao, 4/24/2002
      sceStatus = SceWriteSecurityProfileInfo(strName.GetBuffer(0),
                                              area,
                                              pTemplateInfo->pTemplate,
                                              NULL);
      strName.ReleaseBuffer();

      if(sceStatus != SCESTATUS_SUCCESS)
      {
         //
         // Display the error message
         //
         DWORD dwError = SceStatusToDosError( sceStatus );
         CString strErr;
         MyFormatMessage( sceStatus, NULL, NULL, strErr );
         strErr += strName;

         AfxMessageBox( strErr, MB_ICONEXCLAMATION | MB_OK );
         return S_FALSE;

      }
      return S_OK;
   }

   return S_FALSE;
}


//+--------------------------------------------------------------------------------------------
// CComponentDataImpl::OnImportPolicy
//
// Import policy opens a file open dialog box in which the user is allowed to choose
// a security configuration INF file to import into security policy.
//
//
// Arguments:  [pDataObject]  - The data object associated with the folder calling
//                              this function.
// Returns:    S_OK           - Import was successful.
//             S_FALSE        - Something went wrong.
//---------------------------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnImportPolicy(LPDATAOBJECT pDataObject)
{
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CWnd cwndParent;
   CString strDefName;
   CString strName;


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_IMPORT_POLICY_OFN_TITLE);


   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;

   cwndParent.Attach(m_hwndParent);
   CAssignConfiguration fo(TRUE,                // File open
                  strDefExtension,     // Default Extension
                  strDefName,          // Initial File Name == current DB
                  OFN_HIDEREADONLY|    // Don't show the read only prompt
                  OFN_SHAREAWARE|
                  OFN_EXPLORER|        // Explorer style dialog
                  OFN_ENABLETEMPLATE|   // custom template
                  OFN_DONTADDTORECENT|
                  OFN_PATHMUSTEXIST,    // The Template must exist for us to assign it.
                  strFilter,           // Filter for allowed extensions
                  &cwndParent);        // Dialog's Parent window
   cwndParent.Detach();

   fo.m_ofn.lpstrTitle = strOfnTitle.GetBuffer(1);
   fo.m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ASSIGN_CONFIG_CHECK);

   CThemeContextActivator activator;
   if (IDOK == fo.DoModal()) 
   {
      PVOID pHandle = NULL;
      BOOL bIncremental = fo.m_bIncremental;

      strName = fo.GetPathName();
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      CWaitCursor wc;

      CEditTemplate *pet = NULL; //Raid #Prefast

      //
      // pet will be freed in m_Templates in DeleteTemplate
      //
      pet = GetTemplate(strName,AREA_ALL);

      CString strErr;
      CString strSCE;
      int ret=0;

      if ( pet == NULL ) 
      {
          //
          // this is an invalid template or something is wrong reading the data out
          //

          strSCE.LoadString(IDS_EXTENSION_NAME);
          strErr.Format(IDS_IMPORT_POLICY_INVALID,strName);
          m_pConsole->MessageBox(strErr,strSCE,MB_OK,&ret);

          return S_FALSE;

      } 
      else 
      {
         // Bug 437891, Yang Gao, 7/20/2001
         // Create a new template there if there isn't one already
         //
         PSCE_PROFILE_INFO spi = NULL;
         if( CreateNewProfile(m_szSingleTemplateName,&spi) ) 
         {
             if ( ( bIncremental &&
                   (SCESTATUS_SUCCESS != SceAppendSecurityProfileInfo(m_szSingleTemplateName,
                                          AREA_ALL,
                                          pet->pTemplate,
                                          NULL))) ||
                   (!bIncremental && !CopyFile(strName,m_szSingleTemplateName,FALSE) ) ) //This is a safe usage.
             {
                //
                // Import Failed
                //
                strSCE.LoadString(IDS_EXTENSION_NAME);
                strErr.Format(IDS_IMPORT_POLICY_FAIL,strName);
                m_pConsole->MessageBox(strErr,strSCE,MB_OK,&ret);

                DeleteTemplate(strName);

                return S_FALSE;
             }
             if ( this->m_pNotifier && pet->QueryPolicy() ) //Raid #522006, 2/28/2002, yanggao
             {
                this->m_pNotifier->RefreshPolicy();
             }
         }
         else
         {
             //
             // Import Failed
             //
             strSCE.LoadString(IDS_EXTENSION_NAME);
             strErr.Format(IDS_IMPORT_POLICY_FAIL,strName);
             m_pConsole->MessageBox(strErr,strSCE,MB_OK,&ret);
             DeleteTemplate(strName);
             return S_FALSE;
         }

         DeleteTemplate(strName);

      }

      DeleteTemplate(m_szSingleTemplateName);

      //
      // Update the window.
      //
      pet = GetTemplate(m_szSingleTemplateName);
      if(pet)
      {
         DWORD dwErr = pet->RefreshTemplate();
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            return S_FALSE;
         }
      }
      RefreshAllFolders();
      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------------------------
// CComponentDataImpl::OnImportLocalPolicy
//
// Import policy opens a file open dialog box in which the user is allowed to choose
// a security configuration INF file to import into local policy.
//
// The function asks for the file name then calls SceConfigureSystem() with the
// SCE_NO_CONFIG option.  This imports the specifide file into the local policy
// database.
//
// After the database is updated, we refresh the local policy template held in memory.
//
// Arguments:  [pDataObject]  - The data object associated with the folder calling
//                              this function.
// Returns:    S_OK           - Import was successful.
//             S_FALSE        - Something went wrong.
//---------------------------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnImportLocalPolicy(LPDATAOBJECT pDataObject)
{
   CString strDefExtension;
   CString strFilter;
   CString strOfnTitle;
   CString strDefName;
   CString strName;
   DWORD dwErr = 0;
   SCESTATUS sceStatus = SCESTATUS_SUCCESS;
   CString strErr;
   CString strY;


   strDefExtension.LoadString(IDS_PROFILE_DEF_EXT);
   strFilter.LoadString(IDS_PROFILE_FILTER);
   strOfnTitle.LoadString(IDS_IMPORT_POLICY_OFN_TITLE);

   // Translate filter into commdlg format (lots of \0)
    LPTSTR szFilter = strFilter.GetBuffer(0); // modify the buffer in place
   LPTSTR pch = szFilter;
    // MFC delimits with '|' not '\0'
    while ((pch = _tcschr(pch, TEXT('|'))) != NULL)
        *pch++ = TEXT('\0');
    // do not call ReleaseBuffer() since the string contains '\0' characters

   LPTSTR pszDir = NULL;
   if( GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir ) )
   {
      strDefName = pszDir;
      LocalFree(pszDir);
      pszDir = NULL;
   }
   strDefName += TEXT("\\*.");
   strDefName += strDefExtension;


   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = strDefName.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strDefExtension,
   ofn.hwndOwner = m_hwndParent;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_SHAREAWARE |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT|
               OFN_FILEMUSTEXIST; //Raid #535787, yanggao, 4/18/2002.
   ofn.lpstrTitle = strOfnTitle;

   if (GetOpenFileName(&ofn))
   {
      PVOID pHandle = NULL;

      strName = ofn.lpstrFile;
      pszDir = strName.GetBuffer(0);
      GetWorkingDir( GWD_IMPORT_TEMPLATE, &pszDir, TRUE, TRUE );
      strName.ReleaseBuffer();
      CWaitCursor wc;

      CEditTemplate *pet;
      //Get error info
      //Raid #502571, 12/18/2001, yanggao
      pet = GetTemplate(strName,AREA_SECURITY_POLICY|AREA_PRIVILEGES, &dwErr);
      if (!pet)
      {
         strErr.LoadString(dwErr);
         AppMessageBox(NULL, strErr, NULL, MB_ICONSTOP|MB_OK);
         return S_FALSE;
      }

      //
      // We're going to alter this one so make sure it doesn't save out
      //
      pet->SetNoSave(TRUE);

      //
      // Remove entries that are set by domain policy since they'll be overwritten
      // anyway and we don't allow setting things that'll be overwritten.
      //
      RemovePolicyEntries(pet);

      //
      // 120502 - SceUpdateSecurityProfile doesn't work with SCE_STRUCT_INF,
      //          but the AREA_SECURITY_POLICY and AREA_PRIVILEGES sections are
      //          compatable so we can call it SCE_ENGINE_SYSTEM, which will work.
      //
      SCETYPE origType = pet->pTemplate->Type;
      pet->pTemplate->Type = SCE_ENGINE_SYSTEM;

      sceStatus = SceUpdateSecurityProfile(NULL,
                                        AREA_SECURITY_POLICY|AREA_PRIVILEGES,
                                        pet->pTemplate,
                                        SCE_UPDATE_SYSTEM
                                        );
      //
      // Set the type back so the engine knows how to delete it properly
      //
      pet->pTemplate->Type = origType;

      if (SCESTATUS_SUCCESS != sceStatus)
      {
         goto ret_error;
      }
      //
      // Update the window.
      //
      pet = GetTemplate(GT_LOCAL_POLICY);
      if(pet)
      {
         dwErr = pet->RefreshTemplate(); //Raid #prefast
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            return S_FALSE;
         }
      }
      RefreshAllFolders();
      return S_OK;
   }

   strDefName.ReleaseBuffer();
   return S_FALSE;
ret_error:
   strDefName.ReleaseBuffer();
   MyFormatMessage( sceStatus, NULL, NULL, strErr);
   strErr += strName;
   strErr += L"\n";
   strErr += strY;
   AfxMessageBox( strErr, MB_OK);
   return S_FALSE;

}


HRESULT
CComponentDataImpl::OnAnalyze()
{
   PEDITTEMPLATE pet;

   //
   // If the computer template has been changed then save it before
   // we can inspect against it
   //
   pet = GetTemplate(GT_COMPUTER_TEMPLATE);
   if (pet && pet->IsDirty())
   {
      pet->Save();
   }

   m_pUIThread->PostThreadMessage(SCEM_ANALYZE_PROFILE,(WPARAM)(LPCTSTR)SadName,(LPARAM)this);
   return S_OK;
}

BOOL
CComponentDataImpl::RemovePolicyEntries(PEDITTEMPLATE pet)
{
   PEDITTEMPLATE petPol = GetTemplate(GT_EFFECTIVE_POLICY);

   if (!petPol)
   {
      return FALSE;
   }

#define CD(X) if (petPol->pTemplate->X != SCE_NO_VALUE) { pet->pTemplate->X = SCE_NO_VALUE; };

   CD(MinimumPasswordAge);
   CD(MaximumPasswordAge);
   CD(MinimumPasswordLength);
   CD(PasswordComplexity);
   CD(PasswordHistorySize);
   CD(LockoutBadCount);
   CD(ResetLockoutCount);
   CD(LockoutDuration);
   CD(RequireLogonToChangePassword);
   CD(ForceLogoffWhenHourExpire);
   CD(EnableAdminAccount);
   CD(EnableGuestAccount);

   // These members aren't declared in NT4
   CD(ClearTextPassword);
   CD(AuditDSAccess);
   CD(AuditAccountLogon);
   CD(LSAAnonymousNameLookup);

   CD(MaximumLogSize[0]);
   CD(MaximumLogSize[1]);
   CD(MaximumLogSize[2]);
   CD(AuditLogRetentionPeriod[0]);
   CD(AuditLogRetentionPeriod[1]);
   CD(AuditLogRetentionPeriod[2]);
   CD(RetentionDays[0]);
   CD(RetentionDays[1]);
   CD(RetentionDays[2]);
   CD(RestrictGuestAccess[0]);
   CD(RestrictGuestAccess[1]);
   CD(RestrictGuestAccess[2]);
   CD(AuditSystemEvents);
   CD(AuditLogonEvents);
   CD(AuditObjectAccess);
   CD(AuditPrivilegeUse);
   CD(AuditPolicyChange);
   CD(AuditAccountManage);
   CD(AuditProcessTracking);

   //
   // These two are strings rather than DWORDs
   //
   if (petPol->pTemplate->NewAdministratorName && pet->pTemplate->NewAdministratorName)
   {
      LocalFree(pet->pTemplate->NewAdministratorName);
      pet->pTemplate->NewAdministratorName = NULL;
   }
   if (petPol->pTemplate->NewGuestName && pet->pTemplate->NewGuestName)
   {
      LocalFree(pet->pTemplate->NewGuestName);
      pet->pTemplate->NewGuestName = NULL;
   }

#undef CD

   //
   // Clear privileges set in PetPol out of pet
   //

   SCE_PRIVILEGE_ASSIGNMENT *ppaPet = pet->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
   SCE_PRIVILEGE_ASSIGNMENT *ppaPol = petPol->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;

   SCE_PRIVILEGE_ASSIGNMENT *ppaLast = NULL;
   for(SCE_PRIVILEGE_ASSIGNMENT *ppa = ppaPol; ppa != NULL ; ppa = ppa->Next)
   {
      for (SCE_PRIVILEGE_ASSIGNMENT *ppa2 = ppaPet;
           ppa2 != NULL;
           ppaLast = ppa2, ppa2 = ppa2->Next) {
         if (0 == lstrcmpi(ppa->Name,ppa2->Name))
         {
            if (ppaLast)
            {
               ppaLast->Next = ppa2->Next;
            }
            else
            {
               //  Front of list
               ppaPet = ppa2->Next;
            }
            ppa2->Next = NULL;
            SceFreeMemory(ppa2,SCE_STRUCT_PRIVILEGE);
            ppa2 = ppaLast;
            //
            // Found it, so don't bother checking the rest
            //
            break;
         }
      }
   }

   //
   // Clear reg values set in PetPol out of pet
   //
   SCE_REGISTRY_VALUE_INFO *rvPet = pet->pTemplate->aRegValues;
   SCE_REGISTRY_VALUE_INFO *rvPol = petPol->pTemplate->aRegValues;
   for(DWORD i=0;i< petPol->pTemplate->RegValueCount;i++)
   {
      for (DWORD j=0;j<pet->pTemplate->RegValueCount;j++)
      {
         if (0 == lstrcmpi(rvPol[i].FullValueName,rvPet[j].FullValueName))
         {
            // Match.  Delete Value from pet
            if (rvPet[j].Value)
            {
               LocalFree(rvPet[j].Value);
               rvPet[j].Value = NULL;
            }
            //
            // Found it, so don't bother checking rest
            //
            break;
         }
      }
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cookie.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _SERVICE_H
#define _SERVICE_H

#include "hidwnd.h"
#include "precdisp.h"

// Forward declarations
class CSnapin;
class CResult;

#define RESULT_GROUP_INFO_BASE            1
#define RESULT_GROUP_INFO_SETTING         2
#define RESULT_GROUP_INFO_STATUS          4

// Internal structure used for cookies
struct FOLDER_DATA {
   UINT        ResID;
   UINT        DescID;

   FOLDER_TYPES    type;
};

typedef CList<CResult *, CResult *> CResultItemList;
class CFolder {
   //    friend class CSnapin;
   //    friend class CComponentDataImpl;
public:
   // UNINITIALIZED is an invalid memory address and is a good cookie initializer
   CFolder()
   {
      m_cookie = UNINITIALIZED;
      m_enumed = FALSE;
      m_pScopeItem = NULL;
      m_type = NONE;
      m_pszName = NULL;
      m_pszDesc = NULL;
      m_infName = NULL;
      m_dwMode = 0;
      m_ModeBits = 0;
      m_pData = NULL;
      m_iRefCount = 0;
      m_dwState = state_Unknown;
      m_ViewUpdate = FALSE;
     SetState(state_Unknown, state_Unknown);
      m_fShowViewMenu = FALSE;
   };

   virtual ~CFolder();

   // Interface
public:
   BOOL IsEnumerated() 
   { 
      return  m_enumed;
   };
   void Set(BOOL state) 
   { 
      m_enumed = state;
   };
   void SetCookie(MMC_COOKIE cookie) 
   { 
      m_cookie = cookie;
   }
   BOOL SetDesc(LPCTSTR szDesc);

   FOLDER_TYPES GetType() 
   { 
      ASSERT(m_type != NONE); 
      return m_type;
   };
   LPOLESTR GetName() 
   { 
      return m_pszName;
   };
   LPOLESTR GetDesc() 
   { 
      return m_pszDesc;
   };
   LPOLESTR GetInfFile() 
   { 
      return m_infName;
   }

   DWORD GetDisplayName(CString &str, int iCol );

   void SetInfFile(LPOLESTR sz) 
   { 
      if (!m_infName) 
      { 
         m_infName = sz; 
      } 
   }
   BOOL operator == (const CFolder& rhs) const 
   { 
      return rhs.m_cookie == m_cookie;
   };
   BOOL operator == (long cookie) const 
   { 
      return cookie == m_cookie;
   };
   LPSCOPEDATAITEM GetScopeItem() 
   { 
      return m_pScopeItem;
   }
   BOOL SetMode(DWORD dwMode);
   DWORD GetMode() 
   { 
      return m_dwMode;
   }
   DWORD GetModeBits() 
   { 
      return m_ModeBits;
   }
   DWORD AddModeBits(DWORD dwMB) 
   { 
		return m_ModeBits |= dwMB; 
   }
   PVOID GetData() 
   { 
      return m_pData; 
   }
   void SetData(PVOID pData) 
   { 
      m_pData = pData; 
   }
   void SetShowViewMenu(BOOL flag)
   {
      m_fShowViewMenu = flag;
   }
   const BOOL GetShowViewMenu()
   {
      return m_fShowViewMenu;
   }

   // Implementation
   //private:
   HRESULT Create(LPCTSTR szName, LPCTSTR szDesc, LPCTSTR infName, int nImage,
               int nOpenImage, FOLDER_TYPES type, BOOL bHasChildren, DWORD dwMode,
               PVOID pData);

   DWORD GetState()
   { 
      return m_dwState; 
   };

   void SetState(
      DWORD dwState,
      DWORD dwMask = 0xFFFFFFFF)
   { 
      m_dwState = (dwState | (m_dwState & dwMask)); 
   };
public:
   //
   // Functions for objects.
   //
   BOOL SetDesc( DWORD dwStatus, DWORD dwNumChildren );
   BOOL GetObjectInfo( DWORD *pdwStatus, DWORD *pdwNumChildren );


public:
   //
   // Result item member functions.
   //
    DWORD GetResultItemHandle(                // Gets this folder result item handle
        HANDLE *handle);
    DWORD ReleaseResultItemHandle(            // Releases memory associated with the handle.
        HANDLE &handle);

    DWORD GetResultItem(                      // Returns the result item with the given permission
        HANDLE handle,
        POSITION &pos,
        CResult **pResult);

    DWORD AddResultItem(                      // Adds a Result item to the list
        HANDLE handle,
        CResult *pItem);

   DWORD RemoveResultItem(                   // Removes a Result item
      HANDLE handle,
      CResult *pItem);

   int GetResultListCount()                // Returns the number of result items in the list
   { 
      return (int)m_resultItemList.GetCount(); 
   };

   POSITION GetResultItemPosition(              // Returns the POSITION of the result item.
        HANDLE handle,
        CResult *pResult);

    void RemoveAllResultItems();

public:
	BOOL GetViewUpdate() const;
	void SetViewUpdate(BOOL fUpdate);
   //
   // flags
   enum CFolderEnums {
      state_InvalidTemplate = 0x0001,
      state_Unknown         = 0x0002,
      state_beingRemoved    = 0x0004
   };
   // Attributes
protected:
   int m_iRefCount;
   CResultItemList m_resultItemList;

private:
   LPSCOPEDATAITEM m_pScopeItem;
   MMC_COOKIE      m_cookie;
   BOOL            m_enumed;
   FOLDER_TYPES    m_type;
   LPOLESTR        m_pszName;
   LPOLESTR        m_pszDesc;
   LPOLESTR        m_infName;
   DWORD           m_dwMode;
   DWORD           m_ModeBits;
   PVOID           m_pData;
   BOOL            m_ViewUpdate;
   DWORD       m_dwState;
   BOOL            m_fShowViewMenu;
};

typedef struct _tag_SCECOLUMNINFO
{
    LPCTSTR pszText;
    BOOL   bDelete;

}SCECOLUMNINFO, *PSCECOLUMNINFO;


#define RRFCREATE_COPY      1
#define RRFCREATE_DELETE    2
#define RRFCREATE_NORMAL    3


// Linked result items.  Must be at least 4 for Analysis Groups at present
   #define MAX_ITEM_ID_INDEX 4
   #define NUM_GROUP_SIBLINGS 2
class CResult
{
   //    friend class CSnapin;
   //    friend class CComponentDataImpl;

public:
   // UNINITIALIZED is an invalid memory address and is a good cookie initializer
   CResult()
   {
      m_szAttr = NULL;
      m_dwBase = 0;
      m_dwSetting = 0;
      m_type = ITEM_OTHER;
      m_status = SCE_STATUS_NOT_CONFIGURED;
      m_cookie = UNINITIALIZED;
      m_szUnits = NULL;
      m_nID = NULL;
      m_profBase = NULL;
      /*m_pDataObj = NULL;*/
      m_pNotify = NULL;
      m_pRegChoices = NULL;
      m_pRegFlags = NULL;
      m_pvecPrecedenceDisplays = NULL;
      m_iRefCount = 1;
      m_pSnapin = NULL; //Raid #479626, Yanggao
      m_hID = 0;

      for (int i=0;i<NUM_GROUP_SIBLINGS;i++) {
         m_siblingCookies[i] = 0;
      }
   };

   void Empty()
   {
      PREGCHOICE p = NULL;
      while(m_pRegChoices) 
      {
         p = m_pRegChoices->pNext;
         LocalFree(m_pRegChoices);
         m_pRegChoices = p;
      }
      PREGFLAGS f = NULL;
      while(m_pRegFlags) 
      {
         f = m_pRegFlags->pNext;
         LocalFree(m_pRegFlags);
         m_pRegFlags = f;
      }

      if ( m_szAttr )
      {
         delete [] m_szAttr;
         m_szAttr = NULL;
      }

      if (ITEM_GROUP != m_type) 
      {
         if( m_szUnits )
         {
            LocalFree(m_szUnits);
            m_szUnits = NULL;
         }
      }

      if (m_pvecPrecedenceDisplays) 
      {
         for(vector<PPRECEDENCEDISPLAY>::iterator i = m_pvecPrecedenceDisplays->begin();
                 i != m_pvecPrecedenceDisplays->end();
                 ++i ) 
         {
            delete *i;
         }
         delete m_pvecPrecedenceDisplays;
         m_pvecPrecedenceDisplays = NULL;
      }
   }

   int AddRef() 
   { 
      return ++m_iRefCount; 
   }
   int Release() 
   { 
      if (--m_iRefCount == 0)
      {
         delete this;
         return 0;
      }
      return m_iRefCount;
   };

   virtual ~CResult();

   // Interface
public:
   CString m_strInfFile; //only used for property page result item.
   void SetSnapin(CSnapin* pSnapin) {m_pSnapin = pSnapin;};
   void GetBaseNoUnit(LPTSTR& sz) { TranslateSettingToString(m_dwBase, NULL, m_type,&sz);};
   CSnapin* GetSnapin();
   DWORD_PTR GetProfileDefault();
   DWORD_PTR GetRegDefault();
   LPCTSTR GetAttrPretty();
   void Update(CSnapin *pSnapin, BOOL bEntirePane = FALSE);
   void SetRelativeCookies(MMC_COOKIE cookie1, MMC_COOKIE cookie2) { m_siblingCookies[0] = cookie1; m_siblingCookies[1] = cookie2;};
   MMC_COOKIE GetCookie() { return m_cookie;}
   RESULT_TYPES GetType() { return m_type;};
   LPTSTR GetAttr() { return m_szAttr;};
   LONG_PTR GetBase() { return m_dwBase;}
   LONG_PTR GetSetting() { return m_dwSetting;}
   void GetSetting(LPTSTR& sz) { TranslateSettingToString(m_dwSetting, m_szUnits, m_type,&sz);}
   void GetBase(LPTSTR& sz) { TranslateSettingToString(m_dwBase, m_szUnits, m_type,&sz);}
   BOOL operator == (LPTSTR attr) const { return lstrcmp(m_szAttr, attr) == 0;};
   void SetUnits(LPCTSTR sz);
   LPTSTR GetUnits() { return m_szUnits;}
   void SetBase(LONG_PTR base) { m_dwBase = base;}
   void SetSetting(LONG_PTR base) { m_dwSetting = base;}
   LONG_PTR GetID() { return m_nID;}
   void SetID(LONG_PTR nID) { m_nID = nID;}
   void SetStatus(int status) { m_status = status;}
   int GetStatus() { return m_status;}
   void SetRegChoices(PREGCHOICE RegChoices) { m_pRegChoices = RegChoices;}
   PREGCHOICE GetRegChoices() { return m_pRegChoices;}
   void SetRegFlags(PREGFLAGS RegFlags) { m_pRegFlags = RegFlags;}
   PREGFLAGS GetRegFlags() { return m_pRegFlags;}
   void SetBaseProfile(PEDITTEMPLATE prof) { m_profBase = prof;}
   PEDITTEMPLATE GetBaseProfile() { return m_profBase;}
   long GethID() { return m_hID;};

   vector<PPRECEDENCEDISPLAY>* GetPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetPolicyPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetGroupPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetPrivilegePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetFilePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetRegistryPrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetServicePrecedenceDisplays();
   vector<PPRECEDENCEDISPLAY>* GetRegValuePrecedenceDisplays();

    DWORD
    GetDisplayName(
        CFolder *pFolder,
        CString &str,
        int iCol
        );

   // Implementation
   HRESULT Create(LPCTSTR szAttr, LONG_PTR lBase, LONG_PTR lSetting,
               RESULT_TYPES type, int status, MMC_COOKIE cookie,
               LPCTSTR szUnits, LONG_PTR nID,PEDITTEMPLATE pBase,
               LPDATAOBJECT pDataObj,LPNOTIFY pNotify,CSnapin *pSnapin, long hID);

    LPCTSTR GetSourceGPOString();
protected:
   void
   TranslateSettingToString(  LONG_PTR setting, LPCTSTR unit, RESULT_TYPES type,
                              LPTSTR *pTmpstr
                              );
   DWORD
   GetStatusErrorString( CString *pStr );


   // Attributes
private:
   //LPRESULTDATA m_pResultPane;
   DWORD m_dwArea;
   LPTSTR    m_szAttr;
   LONG_PTR m_dwBase;
   LONG_PTR m_dwSetting;
   LPTSTR m_szUnits;
   RESULT_TYPES m_type;
   int         m_status;
   MMC_COOKIE  m_cookie;
   MMC_COOKIE m_siblingCookies[NUM_GROUP_SIBLINGS];
   LONG_PTR        m_nID;
   PEDITTEMPLATE m_profBase;
   LPNOTIFY m_pNotify;
   PREGCHOICE m_pRegChoices;
   PREGFLAGS m_pRegFlags;
   CSnapin *m_pSnapin;
   vector<PPRECEDENCEDISPLAY>* m_pvecPrecedenceDisplays;
   int m_iRefCount;
   long m_hID; //Raid #510407, 2/25/2002, yanggao
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cookie.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       cookie.cpp
//
//  Contents:   Functions for handling SCE cookies for the scope and
//              result panes
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "wrapper.h"
#include <sceattch.h>
#include "precdisp.h"
#include "util.h"
#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CFolder::~CFolder() 
{
   if (m_pScopeItem) 
   {
      delete m_pScopeItem;
      m_pScopeItem = NULL;
   }
   CoTaskMemFree(m_pszName);
   CoTaskMemFree(m_pszDesc);

   
   while (!m_resultItemList.IsEmpty () )
   {
      CResult* pResult = m_resultItemList.RemoveHead ();
      if ( pResult )
         pResult->Release ();
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     SetDesc
//
//  Synopsis:   Sets the description of the folder
//
//  Arguments:  [szDesc] - [in] the new description of the folder
//
//  Returns:    TRUE if successfull, FALSE otherwise
//
//  Modifies:   m_pszDesc
//
//  History:
//
//---------------------------------------------------------------------------
BOOL CFolder::SetDesc(LPCTSTR szDesc)
{
   UINT     uiByteLen = 0;
   LPOLESTR psz = 0;

   if (szDesc != NULL) 
   {
      uiByteLen = (lstrlen(szDesc) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
      {
         //This may not be a safe usage. psz is OLECHAR. Consider fix.
         lstrcpy(psz, szDesc);
         CoTaskMemFree(m_pszDesc);
         m_pszDesc = psz;
      } 
      else
         return FALSE;
      
   } 
   else
      return FALSE;
   
   return TRUE;
}
// --------------------------------------------------------------------------
//  Method:     SetViewUpdate
//
//  Synopsis:   Sets and gets update flag of this folder
//
//  History: Raid #258237, 4/12/2001
//
//---------------------------------------------------------------------------
void CFolder::SetViewUpdate(BOOL fUpdate)
{
    m_ViewUpdate = fUpdate;
}

BOOL CFolder::GetViewUpdate() const
{
    return m_ViewUpdate;
}
//+--------------------------------------------------------------------------
//
//  Method:     SetMode
//
//  Synopsis:   Sets the SCE Mode that this folder is operating under and
//              calculates the "Mode Bits" appropriate for that mode
//
//  Arguments:  [dwMode]  - The mode to set
//
//  Returns:    TRUE if the mode is valid, FALSE otherwise
//
//  Modifies:   m_dwMode
//              m_ModeBits
//
//  History:    20-Jan-1998   Robcap     created
//
//---------------------------------------------------------------------------
BOOL CFolder::SetMode(DWORD dwMode) 
{
   //
   // Make sure this is a legitimate mode
   //
   switch (dwMode) 
   {
      case SCE_MODE_RSOP_COMPUTER:
      case SCE_MODE_RSOP_USER:
      case SCE_MODE_LOCALSEC:
      case SCE_MODE_COMPUTER_MANAGEMENT:
      case SCE_MODE_DC_MANAGEMENT:
      case SCE_MODE_LOCAL_USER:
      case SCE_MODE_LOCAL_COMPUTER:
      case SCE_MODE_REMOTE_USER:
      case SCE_MODE_REMOTE_COMPUTER:
      case SCE_MODE_DOMAIN_USER:
      case SCE_MODE_DOMAIN_COMPUTER:
      case SCE_MODE_OU_USER:
      case SCE_MODE_OU_COMPUTER:
      case SCE_MODE_EDITOR:
      case SCE_MODE_VIEWER:
      case SCE_MODE_DOMAIN_COMPUTER_ERROR:
         m_dwMode = dwMode;
         break;
      default:
         return FALSE;
         break;
   }

   //
   // Calculate the mode bits for this mode
   //
   m_ModeBits = 0;
   //
   // Directory Services not avalible in NT4
   //
   if ((dwMode == SCE_MODE_DOMAIN_COMPUTER) ||
       (dwMode == SCE_MODE_DC_MANAGEMENT)) 
   {
      m_ModeBits |= MB_DS_OBJECTS_SECTION;
   }
   if ((dwMode == SCE_MODE_OU_USER) ||
       (dwMode == SCE_MODE_DOMAIN_USER) ||
       (dwMode == SCE_MODE_REMOTE_COMPUTER) ||
       (dwMode == SCE_MODE_REMOTE_USER) ||
       (dwMode == SCE_MODE_RSOP_USER) ||
       (dwMode == SCE_MODE_DOMAIN_COMPUTER_ERROR) ||
       (dwMode == SCE_MODE_LOCAL_USER)) 
   {
      m_ModeBits |= MB_NO_NATIVE_NODES |
                    MB_NO_TEMPLATE_VERBS |
                    MB_WRITE_THROUGH;
   }
   if ((dwMode == SCE_MODE_OU_COMPUTER) ||
       (dwMode == SCE_MODE_DOMAIN_COMPUTER) ) 
   {
      m_ModeBits |= MB_SINGLE_TEMPLATE_ONLY |
                    MB_NO_TEMPLATE_VERBS |
                    MB_GROUP_POLICY |
                    MB_WRITE_THROUGH;
   }
   if (dwMode == SCE_MODE_RSOP_COMPUTER) 
   {
      m_ModeBits |= MB_SINGLE_TEMPLATE_ONLY |
                    MB_NO_TEMPLATE_VERBS |
                    MB_WRITE_THROUGH;
   }

   if (dwMode == SCE_MODE_RSOP_COMPUTER ||
       dwMode == SCE_MODE_RSOP_USER) 
   {
      m_ModeBits |= MB_READ_ONLY |
                    MB_RSOP;
   }

   if (SCE_MODE_LOCAL_COMPUTER == dwMode) 
   {
        m_ModeBits |= MB_LOCAL_POLICY |
                      MB_LOCALSEC |
                      MB_NO_TEMPLATE_VERBS |
                      MB_SINGLE_TEMPLATE_ONLY |
                      MB_WRITE_THROUGH;

        if (!IsAdmin()) {
           m_ModeBits |= MB_READ_ONLY;
        }

      if (IsDomainController()) 
      {
          m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   }

   if ( dwMode == SCE_MODE_EDITOR ) 
   {
      m_ModeBits |= MB_TEMPLATE_EDITOR;
      m_ModeBits |= MB_DS_OBJECTS_SECTION;

   } 
   else if ( dwMode == SCE_MODE_VIEWER ) 
   {
      m_ModeBits |= MB_ANALYSIS_VIEWER;
      if (IsDomainController()) 
	   {
         m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   } 
   else if (dwMode == SCE_MODE_LOCALSEC) 
   {
      m_ModeBits |= MB_LOCALSEC;
      if (!IsAdmin()) 
      {
         m_ModeBits |= MB_READ_ONLY;
      }
      if (IsDomainController()) 
	   {
         m_ModeBits |= MB_DS_OBJECTS_SECTION;
      }
   }

   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     Create
//
//  Synopsis:   Initialize a CFolder Object
//
//
//  Arguments:  [szName]       - The folder's display name
//              [szDesc]       - The folder's discription
//              [infName]      - The inf file associated with the folder (optional)
//              [nImage]       - The folder's closed icon index
//              [nOpenImage]   - the folder's open icon index
//              [type]         - The folder' type
//              [bHasChildren] - True if the folder has children folders
//              [dwMode]       - The Mode the folder operates under
//              [pData]        - Extra data to associate with the folder
//
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CFolder::Create(LPCTSTR szName,           // Name
                LPCTSTR szDesc,           // Description
                LPCTSTR infName,          // inf file name
                int nImage,               // closed icon index
                int nOpenImage,           // open icon index
                FOLDER_TYPES type,        // folder type
                BOOL bHasChildren,        // has children
                DWORD dwMode,             // mode
                PVOID pData)              // data
{
   UINT uiByteLen = 0;
   LPOLESTR psz = 0;
   HRESULT hr = S_OK;

   //Validate m_pScopeItem is NULL.
   ASSERT(m_pScopeItem == NULL); // Calling create twice on this item? Bogus Assert, yanggao.

   CString str;
   //
   // Two-stage construction
   //
   m_pScopeItem = new SCOPEDATAITEM;
   if (!m_pScopeItem)
      return E_OUTOFMEMORY;
   
   ZeroMemory(m_pScopeItem,sizeof(SCOPEDATAITEM)); //Raid #668270, yanggao, 8/9/2002
   //
   // Set folder type
   //
   m_type = type;

   //
   // Add node name
   //
   if (szName != NULL || szDesc != NULL ) 
   {
      m_pScopeItem->mask = SDI_STR;
      //
      // Displayname is a callback (unsigned short*)(-1)
      m_pScopeItem->displayname = MMC_CALLBACK;
   }

   if ( szName != NULL ) 
   {
      uiByteLen = (lstrlen(szName) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL)
         //This may not be a safe usage. psz is OLECHAR. Consider fix.
         lstrcpy(psz, szName);
      else
         hr = E_OUTOFMEMORY;

      CoTaskMemFree(m_pszName);
      m_pszName = psz;
   }

   if (szDesc != NULL) 
   {
      uiByteLen = (lstrlen(szDesc) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
         //This may not be a safe usage. psz is OLECHAR. Consider fix.
         lstrcpy(psz, szDesc);
      else
         hr = E_OUTOFMEMORY;
      
      CoTaskMemFree(m_pszDesc);
      m_pszDesc = psz;
   }


   if (infName != NULL) 
   {
      uiByteLen = (lstrlen(infName) + 1) * sizeof(OLECHAR);
      psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

      if (psz != NULL) 
         //This may not be a safe usage. psz is OLECHAR. Consider fix.
         lstrcpy(psz, infName);
      else
         hr = E_OUTOFMEMORY;
      
      CoTaskMemFree(m_infName);
      m_infName = psz;
   }

   //
   // Add close image
   //
   m_pScopeItem->mask |= SDI_IMAGE;  // no close image for now
   //    m_pScopeItem->nImage = (int)MMC_CALLBACK;

   m_pScopeItem->nImage = nImage;

   //
   // Add open image
   //
   if (nOpenImage != -1) 
   {
      m_pScopeItem->mask |= SDI_OPENIMAGE;
      m_pScopeItem->nOpenImage = nOpenImage;
   }

   //
   // Add button to node if the folder has children
   //
   if (bHasChildren == TRUE) 
   {
      m_pScopeItem->mask |= SDI_CHILDREN;
      //
      // The number of children doesn't make any difference now,
      // so pick 1 until the node is expanded and the true value
      // is known
      //
      m_pScopeItem->cChildren = 1;
   }

   //
   // Set the SCE Mode and calculate the mode bits
   //
   if (dwMode)
      SetMode(dwMode);
   
   m_pData = pData;

   return hr;
}


//+------------------------------------------------------------------------------------------------
// CFolder::SetDesc
//
// Translate dwStatus and dwNumChildren to a string and sets m_szDesc
//
// Argumens:   [dwStats]         - Object status.
//             [dwNumChildren]   - Number of children for the object.
//
// Returns: TRUE  - If successful
//          FALSE - If no more memory is available (or dwStatus is greater then 999)
//-------------------------------------------------------------------------------------------------
BOOL CFolder::SetDesc( DWORD dwStatus, DWORD dwNumChildren )
{
   if(dwStatus > 999)
      return FALSE;

   TCHAR szText[256];
   //This is a safe usage.
   swprintf(szText, L"%03d%d", dwStatus, dwNumChildren);

   SetDesc(szText);

   return TRUE;
}



//+------------------------------------------------------------------------------------------------
// CFolder::GetObjectInfo
//
// Translate m_szDesc into dwStatus and dwNumChildren
//
// Argumens:   [pdwStats]         - Object status.
//             [pdwNumChildren]   - Number of children for the object.
//
// Returns: TRUE  - If successful
//          FALSE - m_szDesc is NULL
//-------------------------------------------------------------------------------------------------
BOOL CFolder::GetObjectInfo( DWORD *pdwStatus, DWORD *pdwNumChildren )
{
   if(!m_pszDesc)
      return FALSE;
   
   if( lstrlen(m_pszDesc) < 4)
      return FALSE;

   if(pdwStatus )
      *pdwStatus = (m_pszDesc[0]-L'0')*100 + (m_pszDesc[1]-L'0')*10+ (m_pszDesc[2]-L'0');

   if(pdwNumChildren)
      *pdwNumChildren = _wtol( m_pszDesc + 3 );

   return TRUE;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItemHandle()

Synopisi:   This function must be called to retreive a valid handle to this folders result items.
         The handle must be freed by a call to ReleaseResultItemHandle().  If these two functions
         are not called in conjunction.  The behavior fo the result items will be strange.

Arguments:  [handle] - [out]  The handle value to use for any other functions that require a
                     handle.

Returns: ERROR_SUCCESS           - A valid result item was returned
         ERROR_INVALID_PARAMETER    - [handle] is NULL
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::GetResultItemHandle(
    HANDLE *handle)
{
    if(!handle)
        return ERROR_INVALID_PARAMETER;
   
    m_iRefCount++;
    *handle = (HANDLE)&m_resultItemList;
    return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItem()

Synopisi:   Returns the result item pointed to by position and sets [pos] to the next item.

Arguments:  [handle] - [in] A valid handle returns by GetResultItemHandle()
         [pos]    - [in|out] The position of the result.  If this value is NULL, the first result
                     item in the list is returned.
         [pResult]   - [out] A pointer to a result item pointer

Returns: ERROR_SUCCESS           - A result item was found for the position.
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or [pResult] is NULL
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::GetResultItem(
    HANDLE handle,
    POSITION &pos,
    CResult **pResult)
{
   if(!handle || handle != (HANDLE)&m_resultItemList || !pResult)
      return ERROR_INVALID_PARAMETER;

   if(!pos)
   {
      pos = m_resultItemList.GetHeadPosition();

      if(!pos)
      {
         *pResult = NULL;
         return ERROR_SUCCESS;
      }
   }

   *pResult = m_resultItemList.GetNext(pos);
   return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     GetResultItemPosition()

Synopisi:   Returns the position of the result item in the result item list for this folder item.

Arguments:  [handle] - A valid handle returns by GetResultItemHandle()
         [pResult]   - The retult item position to return.

Returns: NULL     - Invalid handle or the result item is not part of this folder.
         POSITION    - A valid position value that can be used in other calls that require the
                     position of the result item.
--------------------------------------------------------------------------------------------------*/
POSITION CFolder::GetResultItemPosition(
    HANDLE handle,
    CResult *pResult)
{
    if(handle != (HANDLE)&m_resultItemList)
        return NULL;
    

    POSITION  pos = m_resultItemList.GetHeadPosition();
    while(pos)
    {
        if(pResult == m_resultItemList.GetNext(pos))
            break;
    }

    return pos;
}

/*--------------------------------------------------------------------------------------------------
Method:     RemoveAllResultItems()

Synopisi:   Removes all result items from the list.  This call sets the ref count to 0 so it could
         be a very damaging call.
--------------------------------------------------------------------------------------------------*/
void CFolder::RemoveAllResultItems()
{
    //
    // Very Very dangerous call.
    //
    m_iRefCount = 1;
    HANDLE handle = (HANDLE)&m_resultItemList;
    ReleaseResultItemHandle (handle);
}

DWORD CFolder::GetDisplayName( CString &str, int iCol )
{
    int npos;
    DWORD dwRet = ERROR_INVALID_PARAMETER;

    if(!iCol)
    {
        str = GetName();
        dwRet = ERROR_SUCCESS;
    }

    switch(m_type)
    {
    case PROFILE:
    case REG_OBJECTS:
        if(!iCol)
        {
            npos = str.ReverseFind(L'\\');
            str = GetName() + npos + 1;
            dwRet = ERROR_SUCCESS;
        }
        break;
    case FILE_OBJECTS:
        if (0 == iCol) 
        {
           npos = str.ReverseFind(L'\\');
           if (str.GetLength() > npos + 1) 
           {
              str=GetName() + npos + 1;
           }
           dwRet = ERROR_SUCCESS;
        }


        break;
    case STATIC:
        if(iCol == 2)
        {
            str = GetDesc();
            dwRet = ERROR_SUCCESS;
        }
        break;

    }

    if(dwRet != ERROR_SUCCESS)
    {
        if( ((m_type >= ANALYSIS && m_type <=AREA_FILESTORE_ANALYSIS) ||
             (m_type >= LOCALPOL_ACCOUNT && m_type <= LOCALPOL_LAST))
             && iCol == 1)
        {
            str = GetDesc();
            dwRet = ERROR_SUCCESS;
        } 
        else if(iCol <= 3 && GetDesc() != NULL) 
        {
            LPTSTR szDesc = GetDesc();
            switch(iCol)
            {
            case 1:
                // first 3 digits of m_pszDesc
                dwRet = 0;
                GetObjectInfo( &dwRet, NULL );

                ObjectStatusToString(dwRet, &str);
                dwRet = ERROR_SUCCESS;
                break;

            case 2:
                // first 2 digits of m_pszDesc
                dwRet = 0;
                GetObjectInfo( &dwRet, NULL );

                dwRet &= (~SCE_STATUS_PERMISSION_MISMATCH | 0x0F);
                ObjectStatusToString(dwRet, &str);
                dwRet = ERROR_SUCCESS;
                break;

             case 3:
                str = szDesc+3;
                dwRet = ERROR_SUCCESS;
                break;

             default:
                break;
            }
        }
    }

    return dwRet;
}

/*--------------------------------------------------------------------------------------------------
Method:     AddResultItem()

Synopisi:   Adds a result item to the list.

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().
         [pResult]   - [in] The result item to add.


Returns: ERROR_SUCCESS           - The result item was added.
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or pResult is NULL.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::AddResultItem(
    HANDLE handle,
    CResult *pResult)
{
    if(!pResult || handle != (HANDLE)&m_resultItemList)
        return ERROR_INVALID_PARAMETER;

    m_resultItemList.AddHead(pResult);
    return ERROR_SUCCESS;
}

/*--------------------------------------------------------------------------------------------------
Method:     RemoveResultItem()

Synopisi:   Removes a result item from the list..

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().
         [pResult]   - [in] The result item to remove.


Returns: ERROR_SUCCESS           - The item was removed
         ERROR_INVALID_PARAMETER    - [handle] is invalid, or pResult is NULL.
         ERROR_RESOURCE_NOT_FOUND   - The result item does not exist withen this folder.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::RemoveResultItem (
   HANDLE handle,
   CResult *pItem)
{
   if(!pItem || handle != (HANDLE)&m_resultItemList)
      return ERROR_INVALID_PARAMETER;
   

   POSITION posCur;
   POSITION pos = m_resultItemList.GetHeadPosition();
   while(pos)
   {
      posCur = pos;
      if ( m_resultItemList.GetNext(pos) == pItem )
      {
         m_resultItemList.RemoveAt(posCur);
         return ERROR_SUCCESS;
      }
   }

   return ERROR_RESOURCE_NOT_FOUND;
}

/*--------------------------------------------------------------------------------------------------
Method:     ReleaseResultItemHandle()

Synopisi:   Release associated data with the handle.  If the ref count goes to zero then
         all result items are removed from the list.

Arguments:  [handle] - [in] A handle returned by GetResultItemHandle().

Returns: ERROR_SUCCESS           - The function succeded
         ERROR_INVALID_PARAMETER    - [handle] is invalid.
--------------------------------------------------------------------------------------------------*/
DWORD CFolder::ReleaseResultItemHandle(
    HANDLE &handle)
{
   if(handle != (HANDLE)&m_resultItemList)
      return ERROR_INVALID_PARAMETER;

   if( !m_iRefCount )
      return ERROR_SUCCESS;

   m_iRefCount--;

   if(!m_iRefCount)
   {
      while (!m_resultItemList.IsEmpty () )
      {
         CResult* pResult = m_resultItemList.RemoveHead ();
         if ( pResult )
            pResult->Release ();
      }
   }

    handle = NULL;
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CResult
//

//+--------------------------------------------------------------------------
//
//  Method:     Create
//
//  Synopsis:   Initialize a CResult Object
//
//
//  Arguments:  [szAttr]    - The result item's display name
//              [dwBase]    - The item's template setting
//              [dwSetting] - The item's last inspected setting
//              [type]      - The type of the item's setting
//              [status]    - The matched status of the item
//              [cookie]    - The MMC cookie for this item
//              [szUnits]   - The units this item's setting is measured in
//              [nID]       - An identifier for the item, dependant on the type
//              [pBaseInfo] - The template object this item belongs to
//              [pDataObj]  - The data object of the scope pane this item belongs to
//              [pNotify]   - Object to pass notifications through
//  History:
//
//---------------------------------------------------------------------------
HRESULT CResult::Create(LPCTSTR szAttr,           // attribute's display name
                LONG_PTR dwBase,          // template setting
                LONG_PTR dwSetting,       // last inspected setting
                RESULT_TYPES type,        // type of the item's setting
                int status,               // matched status of the item
                MMC_COOKIE cookie,        // the MMC cookie for this item
                LPCTSTR szUnits,          // units the setting is measured in
                LONG_PTR nID,             // An identifier for the item, dependant on the type
                PEDITTEMPLATE pBaseInfo,  // The template object this item belongs to
                LPDATAOBJECT pDataObj,    // The data object of the scope pane this item belongs to
                LPNOTIFY   pNotify,       // Notification object
                CSnapin *pSnapin,         // Snapin window which owns this object
                long hID)                 // Identify this item, Raid #510407, 2/25/2002, yanggao
{
   HRESULT hr = S_OK;

   m_hID = hID; 
   m_type = type;
   m_status = status;
   m_cookie = cookie;
   m_dwBase = dwBase;
   m_dwSetting = dwSetting;
   m_nID = nID;
   m_profBase = pBaseInfo;
   //m_pDataObj = pDataObj;
   m_pNotify = pNotify;

   if( !m_pSnapin ) //Raid #479626, Yanggao
   {
      m_pSnapin = pSnapin;
      if( m_pSnapin )
      {
         m_pSnapin->AddRef();
      }
   }

   UINT     uiByteLen = 0;
   LPTSTR   psz = 0;

   if ( szAttr != NULL ) 
   {
      uiByteLen = (lstrlen(szAttr) + 1);
      psz = new TCHAR[uiByteLen];

      if (psz != NULL) 
      {
         //This is a safe usage.
         lstrcpy(psz, szAttr);
      } 
      else 
      {
         hr = E_OUTOFMEMORY;
      }

      if (m_szAttr)
      {
          delete [] m_szAttr;
      }
      m_szAttr = psz;
   }

   if ( szUnits != NULL ) 
   {
       SetUnits( szUnits );
       if(!m_szUnits){
           hr = E_OUTOFMEMORY;
       }
   }

   return hr;
}


CResult::~CResult() //Raid #479626, Yanggao
{
   if( m_pSnapin )
   {
       m_pSnapin->Release();
       m_pSnapin = NULL;
   }

   Empty();
}

void CResult::SetUnits(
    LPCTSTR sz)
{
   if (ITEM_GROUP == GetType()) 
   {
      //
      // we shouldn't be storing this in a string storage
      // This isn't actually a string and shouldn't be copied.  Yuck.
      //
      m_szUnits = (LPTSTR)sz;
   } 
   else 
   {
      if(m_szUnits)
      {
         LocalFree(m_szUnits);
      }
      m_szUnits = NULL;
      if(sz)
      {
         int iLen = lstrlen(sz);
         m_szUnits = (LPTSTR) LocalAlloc(0, (iLen + 1) * sizeof(TCHAR));

         if(!m_szUnits)
            return;
         //This is a safe usage.
         lstrcpy(m_szUnits, sz);
      }
   }
}




//+--------------------------------------------------------------------------
//
//  Method:     Update
//
//  Synopsis:   Updates a changed result item and broadcasts
//              that change appropriately
//
//  History:
//
//---------------------------------------------------------------------------
void CResult::Update(CSnapin *pSnapin, BOOL bEntirePane)
{
   LPARAM hint = 0;

   //
   // Set the appropriate template section as needing to be saved
   //
   if (m_profBase) 
   {
      //
      // m_profBase will only be set for Configuation templates.
      // It will not be set for Analysis items
      //
      if (m_cookie && ((CFolder *)m_cookie)->GetType() < AREA_POLICY_ANALYSIS ) 
      {
         switch ( ((CFolder *)m_cookie)->GetType()) 
         {
            case POLICY_ACCOUNT:
            case POLICY_LOCAL:
            case POLICY_EVENTLOG:
            case POLICY_PASSWORD:
            case POLICY_KERBEROS:
            case POLICY_LOCKOUT:
            case POLICY_AUDIT:
            case POLICY_OTHER:
            case POLICY_LOG:
               m_profBase->SetDirty(AREA_SECURITY_POLICY);
               break;
            case AREA_PRIVILEGE:
               m_profBase->SetDirty(AREA_PRIVILEGES);
               break;
            case AREA_GROUPS:
               m_profBase->SetDirty(AREA_GROUP_MEMBERSHIP);
               break;
            case AREA_SERVICE:
               m_profBase->SetDirty(AREA_SYSTEM_SERVICE);
               break;
            case AREA_REGISTRY:
               m_profBase->SetDirty(AREA_REGISTRY_SECURITY);
               break;
            case AREA_FILESTORE:
               m_profBase->SetDirty(AREA_FILE_SECURITY);
               break;
         }
      }
   }

   //
   // Query the snap in data.
   //
   LPDATAOBJECT pDataObj;
   if( pSnapin->QueryDataObject( m_cookie, CCT_RESULT, &pDataObj ) != S_OK){
      return;
   }


   if(!m_pNotify){
      return;
   }

   //
   // Update all views.
   //
   if(bEntirePane)
   {
      if(!pSnapin->GetSelectedFolder())
      {
          return;
      }
      if( pDataObj && m_pNotify ) //Raid #357968, #354861, 4/25/2001
      {
          LPNOTIFY pNotify = m_pNotify;
          pSnapin->GetSelectedFolder()->RemoveAllResultItems();
          pNotify->UpdateAllViews(
              pDataObj,
              (LPARAM)pSnapin->GetSelectedFolder(),
              UAV_RESULTITEM_UPDATEALL
              );
      }
   } 
   else
   {
      if (pDataObj && m_pNotify)
      {
          m_pNotify->UpdateAllViews(
              pDataObj,
              NULL,
              pSnapin->GetSelectedFolder(),
              this,
              UAV_RESULTITEM_UPDATE
              );
          pDataObj->Release(); 
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    GetAttrPretty
//
//  Synopsis:  Get the Attribute's display name as it should be displayed
//             in the result pane
//
//  History:
//
//---------------------------------------------------------------------------
LPCTSTR CResult::GetAttrPretty()
{
   return GetAttr();
}

//+--------------------------------------------------------------------------
//
//  Method:     CResult::GetStatusErrorString
//
//  Synopsis:   This function caclulates the error status string to display
//              for the CResult item.  In LPO mode it always returns
//              IDS_NOT_DEFINED, and for MB_TEMPLATE_EDITOR mode it always
//              Loads IDS_NOT_CONFIGURED
//
//  Arguments:  [pStr]    - [Optional] CString object to load resource with.
//
//  Returns:    The resource ID to load. else zero if the error is not
//              defined.
//
//  History:    a-mthoge 11/17/1998
//
//---------------------------------------------------------------------------
DWORD CResult::GetStatusErrorString( CString *pStr )
{
   DWORD nRes = 0;
   if( m_cookie )
   {
      if( ((CFolder *)m_cookie)->GetModeBits() & MB_LOCALSEC )
      {
         if (GetType() ==ITEM_LOCALPOL_REGVALUE) 
         {
            nRes = IDS_NOT_DEFINED;
         } 
         else 
         {
            nRes = IDS_NOT_APPLICABLE;
         }
      } 
      else if ( ((CFolder *)m_cookie)->GetModeBits() & MB_RSOP ) 
      {
         nRes = IDS_NO_POLICY;
      } 
      else if (((CFolder *)m_cookie)->GetModeBits() & MB_ANALYSIS_VIEWER) 
      {
         nRes = IDS_NOT_ANALYZED;
      } 
      else if( ((CFolder *)m_cookie)->GetModeBits() & (MB_TEMPLATE_EDITOR | MB_SINGLE_TEMPLATE_ONLY) )
      {
         nRes = IDS_NOT_CONFIGURED;
      }
   }

   if(!nRes)
   {
      nRes = GetStatus();
      if(!nRes)
      {
         nRes = GetStatus();
      }
      nRes = ObjectStatusToString( nRes, pStr );
   } 
   else if(pStr)
   {
      pStr->LoadString( nRes );
   }
   return nRes;
}

LPCTSTR CResult::GetSourceGPOString()
{
//   ASSERT(pFolder->GetModeBits() & RSOP);

   vector<PPRECEDENCEDISPLAY>* vppd = GetPrecedenceDisplays();
   if (vppd && !vppd->empty()) 
   {
      PPRECEDENCEDISPLAY ppd = vppd->front();
      return ppd->m_szGPO;
   }
   return NULL;
}

//+--------------------------------------------------------------------------
//
//  Method:     CResult::GetDisplayName
//
//  Synopsis:   Gets the display name for the result item.
//
//  Arguments:  [pFolder]    - [Optional] If this parameter is NULL, m_Cookie
//                             is used as the CFolder object.
//              [str]        - [out] On exit this function will contain the
//                             string to display.
//              [iCol]       - [in] The column you want to retrieve the string
//                             for.
//
//  Returns:    ERROR_SUCCESS    - [str] is a valid string for the column.
//
//  History:    a-mthoge 11/17/1998
//
//---------------------------------------------------------------------------
DWORD
CResult::GetDisplayName(
                       CFolder *pFolder,
                       CString &str,
                       int iCol
                       )
{
   DWORD dwRet = ERROR_INVALID_PARAMETER;

   //
   // If pFolder is not passed in then use the cookie as the CFolder
   // object.
   //
   if ( pFolder )
   {
// bogus assertion?
//         ASSERT(pFolder != (CFolder *)GetCookie());
   } else {
      pFolder = (CFolder *)GetCookie();
   }

   LPTSTR pszAlloc = NULL;
   int npos = 0;
   if (iCol == 0) {
      //
      // First column strings.
      //
      str = GetAttr();

      if (pFolder &&
          (pFolder->GetType() < AREA_POLICY || pFolder->GetType() > REG_OBJECTS) ) {
         //
         // SCE Object strings
         //
         npos = str.ReverseFind(L'\\');
      } else {
         npos = 0;
      }

      //
      // All other strings.
      //
      if ( npos > 0 ) {
         str = GetAttr() + npos + 1;
      }
      return ERROR_SUCCESS;
   }

   if ( pFolder ) {
      //
      // Items that are defined by the folder type.
      //
      if ((pFolder->GetType() == AREA_REGISTRY ||
           pFolder->GetType() == AREA_FILESTORE) &&
          ((pFolder->GetModeBits() & MB_RSOP) == MB_RSOP) &&
          iCol == 1) 
      {
         str = GetSourceGPOString();
         return ERROR_SUCCESS;
      }

      switch (pFolder->GetType()) {
      case AREA_REGISTRY:
      case AREA_FILESTORE:
         //
         // profile objects area
         //
         switch (GetStatus()) {
         case SCE_STATUS_IGNORE:
            str.LoadString(IDS_OBJECT_IGNORE);
            break;
         case SCE_STATUS_OVERWRITE:
            str.LoadString(IDS_OBJECT_OVERWRITE);
            break;
         }
         dwRet = ERROR_SUCCESS;
         break;
      }
      if ( pFolder->GetType() >= AREA_REGISTRY_ANALYSIS && pFolder->GetType() < AREA_LOCALPOL ) {
         switch ( iCol ) {
         case 1:
            // permission status
            dwRet = GetStatus() & (~SCE_STATUS_AUDIT_MISMATCH | 0x0F);
            ObjectStatusToString(dwRet, &str);
            break;
         case 2:
            // auditing status
            dwRet = GetStatus() & (~SCE_STATUS_PERMISSION_MISMATCH | 0x0F);
            ObjectStatusToString(dwRet, &str);
            break;
         default:
            str = TEXT("0");
            break;
         }
         dwRet = ERROR_SUCCESS;
      }

      if (dwRet == ERROR_SUCCESS) {
         return dwRet;
      }
   }

   //
   // Items determined by result type.
   //
   switch ( GetType () ) {
   case ITEM_PROF_GROUP:
      if ( GetID() ) {
         //
         // Group member ship strings.
         //
         PSCE_GROUP_MEMBERSHIP pgm;
         pgm = (PSCE_GROUP_MEMBERSHIP)( GetID() );
         if ( iCol == 1) {
            //
            // Members string.
            //
            ConvertNameListToString(pgm->pMembers, &pszAlloc);
         } else if (iCol == 2){
            //
            // Members of string.
            //
            ConvertNameListToString(pgm->pMemberOf, &pszAlloc);
         } else if (iCol == 3) {
            ASSERT(m_pSnapin->GetModeBits() & MB_RSOP); //bogus assertion
            str = GetSourceGPOString();
         } else {
            ASSERT(0 && "Illegal column");
         }
         if (pszAlloc) {
            str = pszAlloc;
            delete [] pszAlloc;
         }
      }
      dwRet = ERROR_SUCCESS;
      break;
   case ITEM_GROUP:
      if ( GetID() ) {
         PSCE_GROUP_MEMBERSHIP pgm;
         pgm = (PSCE_GROUP_MEMBERSHIP)(GetID());

         if (iCol == 1) {
            TranslateSettingToString(
                                    GetGroupStatus( pgm->Status, STATUS_GROUP_MEMBERS ),
                                    NULL,
                                    GetType(),
                                    &pszAlloc
                                    );
         } else if (iCol == 2) {

            TranslateSettingToString(
                                    GetGroupStatus(pgm->Status, STATUS_GROUP_MEMBEROF),
                                    NULL,
                                    GetType(),
                                    &pszAlloc
                                    );
         } else {
            ASSERT(0 && "Illegal column");
         }
         //
         // Test to see if the result item already has a string, if it does then
         // we will delete the old string.
         //
         if (pszAlloc) {
            str = pszAlloc;
            delete [] pszAlloc;
         }
      }
      dwRet = ERROR_SUCCESS;
      break;
   case ITEM_PROF_REGVALUE:
      if (iCol == 2 && (m_pSnapin->GetModeBits() & MB_RSOP) == MB_RSOP) {
         str = GetSourceGPOString();
         break;
      }
   case ITEM_REGVALUE:
   case ITEM_LOCALPOL_REGVALUE:
      {
         PSCE_REGISTRY_VALUE_INFO prv = NULL;

         if (iCol == 1) {
            prv = (PSCE_REGISTRY_VALUE_INFO)(GetBase());
         } else if (iCol == 2) {
            prv = (PSCE_REGISTRY_VALUE_INFO)(GetSetting());
         } else {
            ASSERT(0 && "Illegal column");
         }

         if ( prv ) {
            if ( iCol > 1 && !(prv->Value)) {
               //
               // Determine status fron analysis.
               //
               GetStatusErrorString( &str );
               dwRet = ERROR_SUCCESS;
               break;
            }

            //
            // Determine string by the item value.
            //
            if ( dwRet != ERROR_SUCCESS ) {
               pszAlloc = NULL;
               switch ( GetID() ) {
               case SCE_REG_DISPLAY_NUMBER:
                  if ( prv->Value ) {
                     TranslateSettingToString(
                                             _wtol(prv->Value),
                                             GetUnits(),
                                             ITEM_DW,
                                             &pszAlloc
                                             );
                  }
                  break;
               case SCE_REG_DISPLAY_CHOICE:
                  if ( prv->Value ) {
                     TranslateSettingToString(_wtol(prv->Value),
                                              NULL,
                                              ITEM_REGCHOICE,
                                              &pszAlloc);
                  }
                  break;
               case SCE_REG_DISPLAY_FLAGS:
                  if ( prv->Value ) {
                     TranslateSettingToString(_wtol(prv->Value),
                                              NULL,
                                              ITEM_REGFLAGS,
                                              &pszAlloc);
                     if( pszAlloc == NULL ) //Raid #286697, 4/4/2001
                     {
                         str.LoadString(IDS_NO_MIN);  
                         dwRet = ERROR_SUCCESS;
                     }
                  }
                  break;

               case SCE_REG_DISPLAY_MULTISZ:
               case SCE_REG_DISPLAY_STRING:
                  if (prv && prv->Value) {
                     str = prv->Value;
                     dwRet = ERROR_SUCCESS;
                  }
                  break;
               default: // boolean
                  if ( prv->Value ) {
                     long val;
                     val = _wtol(prv->Value);
                     TranslateSettingToString( val,
                                               NULL,
                                               ITEM_BOOL,
                                               &pszAlloc
                                             );
                  }
                  break;

               }
            }

            if (dwRet != ERROR_SUCCESS) {
               if ( pszAlloc ) {
                  str = pszAlloc;
                  delete [] pszAlloc;
               } else {
                  GetStatusErrorString(&str);
               }
            }
         }
         dwRet = ERROR_SUCCESS;
      }
      break;
   }

   if (dwRet != ERROR_SUCCESS) {
      //
      // Other areas.
      //
      if (iCol == 1) {
         if( GetBase() == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)){
            if( m_pSnapin->GetModeBits() & MB_LOCALSEC){
               str.LoadString(IDS_NOT_APPLICABLE);
            } else {
               str.LoadString(IDS_NOT_CONFIGURED);
            }
         } else {
            //for compitability with template that has SCE_FOREVER_VALUE value.
            if ( IDS_KERBEROS_RENEWAL == m_nID && SCE_FOREVER_VALUE == GetBase() )
            {
               str.LoadString(IDS_NOT_CONFIGURED);
            }
            else
            {
               //
               // Edit template
               //
               GetBase(pszAlloc);
            }
         }
      } else if (iCol == 2) {
         if ((m_pSnapin->GetModeBits() & MB_RSOP) == MB_RSOP) {
            //
            // RSOP Mode
            //
            str = GetSourceGPOString();
         } else {
            //
            // Analysis Template.
            //
            GetSetting(pszAlloc);
         }

      } else {
         ASSERT(0 && "Illegal column");
      }

      if (pszAlloc) {
         str = pszAlloc;
         delete [] pszAlloc;
      }
      dwRet = ERROR_SUCCESS;
   }

   return dwRet;
}


//+--------------------------------------------------------------------------
//
//  Function:   TranslateSettingToString
//
//  Synopsis:   Convert a result pane setting into a string
//
//  Arguments:  [setting]  - [in] The value to be converted
//              [unit]     - [in, optiona] The string for the units to use
//              [type]     - [in] The type of the setting to be converted
//              [LPTSTR]   - [in|out] the address to store the string at
//
//  Returns:   *[LPTSTR]   - the translated string
//
//---------------------------------------------------------------------------
void CResult::TranslateSettingToString(LONG_PTR setting,
                                  LPCTSTR unit,
                                  RESULT_TYPES type,
                                  LPTSTR* pTmpstr)
{
   DWORD nRes = 0;

   if (!pTmpstr) 
   {
      ASSERT(pTmpstr);
      return;
   }

   *pTmpstr = NULL;

   switch ( (DWORD)setting ) //Raid 665368, yanggao, 8/9/2002.
   {
   case SCE_KERBEROS_OFF_VALUE:
      nRes = IDS_OFF;
      break;

   case SCE_FOREVER_VALUE:
      nRes = IDS_FOREVER;
      break;

   case SCE_ERROR_VALUE:
      nRes = IDS_ERROR_VALUE;
      break;

   case SCE_NO_VALUE:
      nRes = GetStatusErrorString( NULL );
      break;

   case SCE_NOT_ANALYZED_VALUE:
      nRes = GetStatusErrorString( NULL );
      break;

    default:
      switch ( type ) 
      {
         case ITEM_SZ:
         case ITEM_PROF_SZ:
         case ITEM_LOCALPOL_SZ:
            if (setting && setting != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)) 
            {
               *pTmpstr = new TCHAR[lstrlen((LPTSTR)setting)+1];
               if (*pTmpstr)
                  //This may not be a safe usage. pTmpstr is LPTSTR. Consider fix.
                  wcscpy(*pTmpstr,(LPTSTR)setting);
            } 
            else
               nRes = GetStatusErrorString(NULL);
            break;

         case ITEM_PROF_BOOL:
         case ITEM_LOCALPOL_BOOL:
         case ITEM_BOOL:
            if ( setting )
               nRes = IDS_ENABLED;
            else
               nRes = IDS_DISABLED;
            break;

         case ITEM_PROF_BON:
         case ITEM_LOCALPOL_BON:
         case ITEM_BON:
            if ( setting )
               nRes = IDS_ON;
            else
               nRes = IDS_OFF;
            break;

         case ITEM_PROF_B2ON:
         case ITEM_LOCALPOL_B2ON:
         case ITEM_B2ON: 
         {
            CString strAudit;
            CString strFailure;
            if ( setting & AUDIT_SUCCESS )
               strAudit.LoadString(IDS_SUCCESS);

            if ( setting & AUDIT_FAILURE ) 
            {
               if (setting & AUDIT_SUCCESS) 
                  strAudit += TEXT(", ");
               
               strFailure.LoadString(IDS_FAILURE);
               strAudit += strFailure;
            }
            if (strAudit.IsEmpty())
               strAudit.LoadString(IDS_DO_NOT_AUDIT);

            *pTmpstr = new TCHAR [ strAudit.GetLength()+1 ];
            if (*pTmpstr)
               //This may not be a safe usage. pTmpstr is LPTSTR. Consider fix.
               wcscpy(*pTmpstr, (LPCTSTR) strAudit);
         }
         break;

         case ITEM_PROF_RET:
         case ITEM_LOCALPOL_RET:
         case ITEM_RET: 
            switch(setting) 
            {
               case SCE_RETAIN_BY_DAYS:
                  nRes = IDS_BY_DAYS;
                  break;

               case SCE_RETAIN_AS_NEEDED:
                  nRes = IDS_AS_NEEDED;
                  break;

               case SCE_RETAIN_MANUALLY:
                  nRes = IDS_MANUALLY;
                  break;

               default:
                  break;
            }
            break;

         case ITEM_PROF_REGCHOICE:
         case ITEM_REGCHOICE: 
         {
            PREGCHOICE pRegChoice = m_pRegChoices;
            while(pRegChoice) 
            {
               if (pRegChoice->dwValue == (DWORD)setting) 
               {
                  if( pRegChoice->szName == NULL ) //Raid #553113, yanggao
                  {
                     *pTmpstr = NULL;
                     break;
                  }
                  *pTmpstr = new TCHAR[lstrlen(pRegChoice->szName)+1];
                  if (*pTmpstr)
                     //This is not a safe usage. Need to validate pRegChoice->szName.
                     wcscpy(*pTmpstr, (LPCTSTR) pRegChoice->szName);
                  break;
               }
               pRegChoice = pRegChoice->pNext;
            }
            break;
         }

         case ITEM_REGFLAGS: 
         {
            TCHAR *pStr = NULL;
            PREGFLAGS pRegFlags = m_pRegFlags;
            while(pRegFlags) 
            {
               if ((pRegFlags->dwValue & (DWORD) setting) == pRegFlags->dwValue) 
               {
                  pStr = *pTmpstr;
                  if( pRegFlags->szName ) //Raid #553113, yanggao
                  {
                     *pTmpstr = new TCHAR[(pStr?lstrlen(pStr):0)+lstrlen(pRegFlags->szName)+2];
                     if (*pTmpstr) 
                     {
                        if (pStr) 
                        {
                           //This is not a safe usage. Need to validate pRegFlags->szName.
                           lstrcpy(*pTmpstr, (LPCTSTR) pStr);
                           lstrcat(*pTmpstr,L",");
                           lstrcat(*pTmpstr, pRegFlags->szName);
                        } 
                        else
                           //This is not a safe usage. Need to validate pRegFlags->szName.
                           lstrcpy(*pTmpstr, pRegFlags->szName);
                     }
                  }
                  else
                  {
                     *pTmpstr = NULL;
                  }
                  if (pStr)
                     delete [] pStr;
               }
               pRegFlags = pRegFlags->pNext;
            }
            break;
         }

         case ITEM_PROF_GROUP:
         case ITEM_PROF_PRIVS: 
            //Raid #483744, yanggao, reverse RSOP user right assignments order.
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
            {
               if( ITEM_PROF_PRIVS == type && (m_pSnapin->GetModeBits() & MB_RSOP) == MB_RSOP )
               {
                  ConvertNameListToString((PSCE_NAME_LIST) setting,pTmpstr,TRUE);
               }
               else
               {
                  ConvertNameListToString((PSCE_NAME_LIST) setting,pTmpstr);
               }
            }
            break;

         case ITEM_LOCALPOL_PRIVS:
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
               ConvertNameListToString(((PSCE_PRIVILEGE_ASSIGNMENT) setting)->AssignedTo,pTmpstr);
            break;

         case ITEM_PRIVS:
            if (NULL != setting && (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != setting )
               ConvertNameListToString(((PSCE_PRIVILEGE_ASSIGNMENT) setting)->AssignedTo,pTmpstr);
            else
               nRes = GetStatusErrorString(NULL);
            break;

         case ITEM_GROUP:
            //nRes = GetStatusErrorString(NULL);
            nRes = ObjectStatusToString((DWORD) setting, NULL);

            if ( setting == MY__SCE_MEMBEROF_NOT_APPLICABLE )
                nRes = IDS_NOT_APPLICABLE;
            break;

         case ITEM_PROF_DW:
         case ITEM_LOCALPOL_DW:
         case ITEM_DW:
            nRes = 0;
            if ( unit ) 
            {
               *pTmpstr = new TCHAR[wcslen(unit)+20];
               if (*pTmpstr)
                  //This is a safe usage.
                  swprintf(*pTmpstr, L"%d %s", setting, unit);
            } 
            else 
            {
               *pTmpstr = new TCHAR[20];
               if (*pTmpstr)
                  //This is a safe usage.
                  swprintf(*pTmpstr, L"%d", setting);
            }
            break;

         default:
            *pTmpstr = NULL;
            break;
      }
      break;
   }
   if (nRes) 
   {
      CString strRes;
      if (strRes.LoadString(nRes)) 
      {
         *pTmpstr = new TCHAR[strRes.GetLength()+1];
         if (*pTmpstr)
            //This may not be a safe usage. pTmpstr is PTSTR. Consider fix.
            wcscpy(*pTmpstr, (LPCTSTR) strRes);
         else 
         {
            //
            // Couldn't allocate string so display will be blank.
            //
         }
      } 
      else 
      {
         //
         // Couldn't load string so display will be blank.
         //
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Function:  GetProfileDefault()
//
//  Synopsis:  Find the default values for undefined policies
//
//  Returns:   The value to assign as the default value for the policy.
//
//             SCE_NO_VALUE is returned on error.
//
//+--------------------------------------------------------------------------
DWORD_PTR
CResult::GetProfileDefault() {
   PEDITTEMPLATE pet = NULL;
   SCE_PROFILE_INFO *pspi = NULL;

   if (!m_pSnapin) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }
   pet = m_pSnapin->GetTemplate(GT_DEFAULT_TEMPLATE);
   if (pet && pet->pTemplate) {
      pspi = pet->pTemplate;
   }

   if( ITEM_PROF_SERV == m_type ) //Raid #485374, yanggao, 11/2/2001
   {
      if( _wcsicmp(pspi->pServices->ServiceName, L"PlaceHolder") == 0 )
      {
         return (DWORD_PTR)pspi->pServices;
      }
      else
      {
         return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
      }
   }

#define PROFILE_DEFAULT(X,Y) ((pspi && (pspi->X != SCE_NO_VALUE)) ? pspi->X : Y)
#define PROFILE_KERB_DEFAULT(X,Y) ((pspi && pspi->pKerberosInfo && (pspi->pKerberosInfo->X != SCE_NO_VALUE)) ? pspi->pKerberosInfo->X : Y)
   switch (m_nID) {
      // L"Maximum passage age", L"Days"
      case IDS_MAX_PAS_AGE:
         return PROFILE_DEFAULT(MaximumPasswordAge,42);

      // L"Minimum passage age", L"Days"
      case IDS_MIN_PAS_AGE:
         return PROFILE_DEFAULT(MinimumPasswordAge,0);

      // L"Minimum passage length", L"Characters"
      case IDS_MIN_PAS_LEN:
         return PROFILE_DEFAULT(MinimumPasswordLength,0);

      // L"Password history size", L"Passwords"
      case IDS_PAS_UNIQUENESS:
         return PROFILE_DEFAULT(PasswordHistorySize,0);

      // L"Password complexity", L""
      case IDS_PAS_COMPLEX:
         return PROFILE_DEFAULT(PasswordComplexity,0);

      // L"Clear Text Password", L""
      case IDS_CLEAR_PASSWORD:
         return PROFILE_DEFAULT(ClearTextPassword,0);

      // L"Require logon to change password", L""
      case IDS_REQ_LOGON:
         return PROFILE_DEFAULT(RequireLogonToChangePassword,0);

      case IDS_KERBEROS_MAX_SERVICE:
            return PROFILE_KERB_DEFAULT(MaxServiceAge,600);

      case IDS_KERBEROS_MAX_CLOCK:
            return PROFILE_KERB_DEFAULT(MaxClockSkew,5);

      case IDS_KERBEROS_RENEWAL:
            return PROFILE_KERB_DEFAULT(MaxRenewAge,10);

      case IDS_KERBEROS_MAX_AGE:
            return PROFILE_KERB_DEFAULT(MaxTicketAge,7);

      case IDS_KERBEROS_VALIDATE_CLIENT:
            return PROFILE_KERB_DEFAULT(TicketValidateClient,1);

      // L"Account lockout count", L"Attempts"
      case IDS_LOCK_COUNT:
         return PROFILE_DEFAULT(LockoutBadCount,0);

      // L"Reset lockout count after", L"Minutes"
      case IDS_LOCK_RESET_COUNT:
         return PROFILE_DEFAULT(ResetLockoutCount,30);

      // L"Lockout duration", L"Minutes"
      case IDS_LOCK_DURATION:
         return PROFILE_DEFAULT(LockoutDuration,30);

      // L"Event Auditing Mode",
      case IDS_EVENT_ON:
         return 0;

      // L"Audit system events"
      case IDS_SYSTEM_EVENT:
         return PROFILE_DEFAULT(AuditSystemEvents,0);

      // L"Audit logon events"
      case IDS_LOGON_EVENT:
         return PROFILE_DEFAULT(AuditLogonEvents,0);

      // L"Audit Object Access"
      case IDS_OBJECT_ACCESS:
         return PROFILE_DEFAULT(AuditObjectAccess,0);

      // L"Audit Privilege Use"
      case IDS_PRIVILEGE_USE:
         return PROFILE_DEFAULT(AuditPrivilegeUse,0);

      // L"Audit policy change"
      case IDS_POLICY_CHANGE:
         return PROFILE_DEFAULT(AuditPolicyChange,0);

      // L"Audit Account Manage"
      case IDS_ACCOUNT_MANAGE:
         return PROFILE_DEFAULT(AuditAccountManage,0);

      // L"Audit process tracking"
      case IDS_PROCESS_TRACK:
         return PROFILE_DEFAULT(AuditProcessTracking,0);
      // L"Audit directory service access"
      case IDS_DIRECTORY_ACCESS:
         return PROFILE_DEFAULT(AuditDSAccess,0);

      // L"Audit Account Logon"
      case IDS_ACCOUNT_LOGON:
         return PROFILE_DEFAULT(AuditAccountLogon,0);

         // L"Network access: Allow anonymous SID/Name translation"
   case IDS_LSA_ANON_LOOKUP:
       return PROFILE_DEFAULT(LSAAnonymousNameLookup,0);

      // L"Force logoff when logon hour expire", L""
      case IDS_FORCE_LOGOFF:
         return PROFILE_DEFAULT(ForceLogoffWhenHourExpire,0);

      // L"Accounts: Administrator account status"
      case IDS_ENABLE_ADMIN:
         return PROFILE_DEFAULT(EnableAdminAccount,1);

      // L"Accounts: Guest account status"
      case IDS_ENABLE_GUEST:
         return PROFILE_DEFAULT(EnableGuestAccount,0);

      // L"... Log Maximum Size", L"KBytes"
      case IDS_SYS_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
      case IDS_SEC_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
      case IDS_APP_LOG_MAX:
         return PROFILE_DEFAULT(MaximumLogSize[0],512);
         return 512;

      // L"... Log Retention Method",
      case IDS_SYS_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
      case IDS_SEC_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
      case IDS_APP_LOG_RET:
         return PROFILE_DEFAULT(AuditLogRetentionPeriod[0],1);
         return 1;

      // L"... Log Retention days", "days"
      case IDS_SYS_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);
      case IDS_SEC_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);
      case IDS_APP_LOG_DAYS:
         return PROFILE_DEFAULT(RetentionDays[0],7);

      // L"RestrictGuestAccess", L""
      case IDS_SYS_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
      case IDS_SEC_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
      case IDS_APP_LOG_GUEST:
         return PROFILE_DEFAULT(RestrictGuestAccess[0],1);
   }

   return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
}


//+--------------------------------------------------------------------------
//
//  Function:  GetRegDefault()
//
//  Synopsis:  Find the default values for undefined policies
//
//  Returns:   The value to assign as the default value for the policy.
//
//             SCE_NO_VALUE is returned on error.
//
//+--------------------------------------------------------------------------
DWORD_PTR
CResult::GetRegDefault() {
   SCE_PROFILE_INFO *pspi = NULL;
   LPTSTR szValue = NULL;
   DWORD_PTR dwValue = SCE_NO_VALUE;

   if (!m_pSnapin) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }

   PEDITTEMPLATE pet = m_pSnapin->GetTemplate(GT_DEFAULT_TEMPLATE);
   if (!pet || !pet->pTemplate) {
      return (DWORD_PTR)ULongToPtr(SCE_NO_VALUE);
   }

   if (pet && pet->pTemplate) {
      pspi = pet->pTemplate;
   }

   PSCE_REGISTRY_VALUE_INFO regArrayThis = (PSCE_REGISTRY_VALUE_INFO)m_dwBase;
   if (pspi != NULL) 
   {
      PSCE_REGISTRY_VALUE_INFO regArray = pspi->aRegValues;
      DWORD nCount = pspi->RegValueCount;

      for(DWORD i=0;i<nCount;i++) 
      {
         if (0 == lstrcmpi(regArray[i].FullValueName,
                           regArrayThis->FullValueName)) 
         {
            szValue = regArray[i].Value;
            break;
         }
      }
   }

   switch (regArrayThis->ValueType) 
   {
      //Raid #652193, using REG value type instead of display type.
      case REG_MULTI_SZ: //Raid #413311, 6/11/2001, Yanggao
      case REG_SZ:
      case REG_EXPAND_SZ:
         if (szValue) 
         {
            dwValue =  (DWORD_PTR)szValue;  //Raid #367756, 4/13/2001
         }
         else
         {
            dwValue = 0;
         }
         break;
      case REG_BINARY:
      case REG_DWORD:
         if (szValue) 
         {
            dwValue =  (DWORD)StrToLong(szValue);
         }
         if (dwValue == SCE_NO_VALUE) 
         {
            dwValue = 1;
         }
         break;
      default:
         if (szValue) 
         {
            dwValue =  (DWORD)StrToLong(szValue); //Raid #413311, 6/11/2001, Yanggao
         }
         //Some security option in group policy is not defined. Their property pages should not display
         //any item checked. It confuses user and creates inconsistence.
         break;
   }

   return dwValue;
}
//+--------------------------------------------------------------------------
//
//  Function:  GetSnapin()
//
//  Synopsis:  Find current snapin of result item.
//
//  Returns:   Pointer of snapin
//
//+--------------------------------------------------------------------------
CSnapin* CResult::GetSnapin()
{
   return m_pSnapin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cprivs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CConfigPrivs.h
//
//  Contents:   definition of CConfigRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"
#include "cookie.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs dialog

class CConfigPrivs : public CAttribute {
// Construction
public:
	CConfigPrivs(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigPrivs)
	enum { IDD = IDD_CONFIG_PRIVS };
	CListBox	m_lbGrant;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	CButton	m_btnTitle;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigPrivs)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigPrivs)
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	virtual BOOL OnApply();
    virtual void OnCancel();
	virtual BOOL OnInitDialog();
   afx_msg void OnConfigure();
   afx_msg void OnSelChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   virtual PSCE_PRIVILEGE_ASSIGNMENT GetPrivData();
   virtual void SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa);

   virtual void SetInitialValue(DWORD_PTR dw);

    BOOL m_fDirty;
private:
    BOOL m_bOriginalConfigure;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CPRIVS_H__3C25C0A7_F23B_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cret.cpp
//
//  Contents:   implementation of CConfigRet
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "CRet.h"
#include "util.h"
#include "DDWarn.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog


CConfigRet::CConfigRet(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigRet)
    m_strAttrName = _T("");
    m_StartIds = IDS_AS_NEEDED;
    m_rabRetention = -1;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a190HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigRet::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigRet)
//    DDX_Text(pDX, IDC_ATTRIBUTE_NAME, m_strAttrName);
    DDX_Radio(pDX, IDC_RETENTION, m_rabRetention);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigRet, CAttribute)
    //{{AFX_MSG_MAP(CConfigRet)
    ON_BN_CLICKED(IDC_RETENTION, OnRetention)
    ON_BN_CLICKED(IDC_RADIO2, OnRetention)
    ON_BN_CLICKED(IDC_RADIO3, OnRetention)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigRet message handlers

BOOL CConfigRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;

      UpdateData(TRUE);


      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;
         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;
         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;
         }
      }

      CEditTemplate *petSave = m_pData->GetBaseProfile();

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw) == ERROR_MORE_DATA )
      {
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               SetProfileInfo(
                  pItem->pResult->GetID(),
                  pItem->dwSuggested,
                  pItem->pResult->GetBaseProfile()
                  );

               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      //
      // Update this items profile.
      //
      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());


      m_pData->Update(m_pSnapin, false);
   }

   return CAttribute::OnApply();
}

BOOL CConfigRet::OnInitDialog()
{

   CAttribute::OnInitDialog();

   AddUserControl(IDC_RETENTION);
   AddUserControl(IDC_RADIO2);
   AddUserControl(IDC_RADIO3);
   EnableUserControls(m_bConfigure);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigRet::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   DDWarn.InitializeDependencies(m_pSnapin,pResult);

   m_StartIds = IDS_AS_NEEDED;

   LONG_PTR dw = pResult->GetBase();
   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      SetInitialValue((DWORD_PTR)dw);
   }
}

void CConfigRet::SetInitialValue(DWORD_PTR dw) 
{
   if (-1 == m_rabRetention &&
       SCE_NO_VALUE != dw) 
   {
      switch (dw) 
      {
         case SCE_RETAIN_BY_DAYS:
            m_rabRetention = RADIO_RETAIN_BY_DAYS;
            break;
         case SCE_RETAIN_AS_NEEDED:
            m_rabRetention = RADIO_RETAIN_AS_NEEDED;
            break;
         case SCE_RETAIN_MANUALLY:
            m_rabRetention = RADIO_RETAIN_MANUALLY;
            break;
      }
   }
}

void CConfigRet::OnRetention()
{
   int prevValue = m_rabRetention; //Raid #504749, 12/18/2001, yanggao, enable "apply".
   UpdateData(); 
   if(m_rabRetention != prevValue)
   {
      SetModified(TRUE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cret.h
//
//  Contents:   definition of CConfigRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "ddwarn.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog

class CConfigRet : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    CConfigRet(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigRet)
	enum { IDD = IDD_CONFIG_RET };
    CString m_strAttrName;
	int		m_rabRetention;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigRet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRet)
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
	afx_msg void OnRetention();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CDlgDependencyWarn DDWarn;

public:
    UINT m_StartIds;
};

#define RADIO_RETAIN_BY_DAYS 0
#define RADIO_RETAIN_AS_NEEDED 1
#define RADIO_RETAIN_MANUALLY 2

#define SCE_RETAIN_BY_DAYS 1
#define SCE_RETAIN_AS_NEEDED 0
#define SCE_RETAIN_MANUALLY 2

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CRET_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\copyutil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       copyutil.cpp
//
//  Contents:   Utility routines for copying SCE sections to the clipboard
//
//  HISTORY:    10-Nov-97          robcap           Created
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "snapmgr.h"
#include "wrapper.h"
#include "util.h"
#include <secedit.h>


//+--------------------------------------------------------------------------
//
//  Method:     GetFolderCopyPasteInfo
//
//  Synopsis:   Finds the SCE area and clipboard format that correspond
//              to the folder type given in [Folder]
//
//  Arguments:  [Folder] - the folder type to find the area and cf for
//              [*Area]  - output only
//              [*cf]    - output only
//
//  Returns:    *[Area]  - the SCE area that corresponds to [Folder]
//              *[cf]    - the clipboard format that corresponds to [Folder]
//
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::GetFolderCopyPasteInfo(FOLDER_TYPES Folder,     // In
                                           AREA_INFORMATION *Area,  // Out
                                           UINT *cf) {              // Out

   switch (Folder) {
      case POLICY_ACCOUNT:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
         *Area = AREA_SECURITY_POLICY;
         *cf = cfSceAccountArea;
         break;

      case POLICY_LOCAL:
      case POLICY_OTHER:
      case AREA_PRIVILEGE:
         *Area = AREA_SECURITY_POLICY | AREA_PRIVILEGES;
         *cf = cfSceLocalArea;
         break;

      case POLICY_EVENTLOG:
      case POLICY_LOG:
         *Area = AREA_SECURITY_POLICY;
         *cf = cfSceEventLogArea;
         break;

      case AREA_GROUPS:
         *Area = AREA_GROUP_MEMBERSHIP;
         *cf = cfSceGroupsArea;
         break;
      case AREA_SERVICE:
         *Area = AREA_SYSTEM_SERVICE;
         *cf = cfSceServiceArea;
         break;
      case AREA_REGISTRY:
         *Area = AREA_REGISTRY_SECURITY;
         *cf = cfSceRegistryArea;
         break;
      case AREA_FILESTORE:
         *Area = AREA_FILE_SECURITY;
         *cf = cfSceFileArea;
         break;
      default:
         return FALSE;
   }

   return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Method:     OnCopyArea
//
//  Synopsis:   Copy a folder to the clipboard
//
//  Arguments:  [szTemplate] - the name of the template file to copy from
//              [ft]         - the type of folder to copy
//
//  Returns:    HRESULT
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnCopyArea(LPCTSTR szTemplate,FOLDER_TYPES ft) {
   HRESULT hr;
   SCESTATUS status;
   PEDITTEMPLATE pTemp;
   CString strPath,strFile;
   LPTSTR szPath,szFile;

   DWORD dw;
   CFile pFile;
   HANDLE hBuf,hSecBuf;
   PVOID pBuf,pSecBuf;
   PSCE_ERROR_LOG_INFO ErrLog;
   AREA_INFORMATION Area;
   UINT cf;

   hr = S_OK;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CWaitCursor wc;
   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );


   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return E_FAIL;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
      strFile.ReleaseBuffer();
      return E_FAIL;
   }

   strFile.ReleaseBuffer();

   //
   // Get the template that we're trying to copy
   //
   pTemp = GetTemplate(szTemplate);
   if (!pTemp) {
      return E_FAIL;
   }

   if (!GetFolderCopyPasteInfo(ft,&Area,&cf)) {
      return E_FAIL;
   }

   status = SceWriteSecurityProfileInfo(szFile,
                                        Area,
                                        pTemp->pTemplate,
                                        NULL);
   if (SCESTATUS_SUCCESS == status) {

      if (!pFile.Open(szFile,CFile::modeRead)) {
         return E_FAIL;
      }
      dw = pFile.GetLength();
      hBuf = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,dw);
      if (!hBuf) {
         return E_OUTOFMEMORY;
      }
      //Raid #488205, yanggao, 11/15/2001
      //After SetClipboardData is called, the system owns the object identified by the hMem parameter.
      //The application can read the data, but must not free the handle or leave it locked until the CloseClipboard function is called.
      hSecBuf = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,dw);
      if (!hSecBuf) {
         GlobalFree(hBuf); //Free both hBuf and hSecBuf when failed. Raid #551257. yanggao, 3/6/02.
         return E_OUTOFMEMORY;
      }  
      pBuf = GlobalLock(hBuf);
      if (!pBuf) {
          GlobalFree(hBuf);
          GlobalFree(hSecBuf);
          return E_FAIL;
      }
      pSecBuf = GlobalLock(hSecBuf);
      if (!pSecBuf) {
          GlobalUnlock(hBuf);
          GlobalFree(hBuf);
          GlobalFree(hSecBuf);
          return E_FAIL;
      }
      pFile.Read(pBuf,dw);
      memcpy(pSecBuf, pBuf, dw);
      GlobalUnlock(hBuf);
      GlobalUnlock(hSecBuf);

      if (OpenClipboard(NULL)) {
         EmptyClipboard();
         //
         // Add the data to the clipboard in CF_TEXT format, so it
         // can be pasted to Notepad
         //
         SetClipboardData(CF_TEXT,hSecBuf);
         //
         // Add the data to the clipboard in our custom format, so
         // we can read it back in on paste
         //
         SetClipboardData(cf,hBuf);

         CloseClipboard();
      } else {
         hr = E_FAIL;
      }

      pFile.Close();
      pFile.Remove(szFile);
   } else {
      return E_FAIL;
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnPasteArea
//
//  Synopsis:   Paste an area from the clipboard
//
//  Arguments:  [szTemplate] - the name of the template file to paste from
//              [ft]         - the type of folder to paste
//
//  Returns:    HRESULT
//
//  History:    10-Nov-1997      RobCap   created
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::OnPasteArea(LPCTSTR szTemplate,FOLDER_TYPES ft) {
   SCESTATUS status;
   PEDITTEMPLATE pTemp;
   PSCE_PROFILE_INFO spi;
   CString strPath;
   CString strFile;
   LPTSTR szPath,szFile;
   AREA_INFORMATION Area;
   UINT cf;
   int k;

   DWORD dw;
   CFile *pFile;
   CFile pFileOut;

   PVOID pBuf;
   PVOID pHandle;

   HRESULT hr = S_OK;

   COleDataObject DataObject;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CWaitCursor wc;

   //
   // Find the SCE Area and clipboard format for ft
   //
   if (!GetFolderCopyPasteInfo(ft,&Area,&cf)) {
      return E_FAIL;
   }

   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );


   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return E_FAIL;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
       strFile.ReleaseBuffer();
       return E_FAIL;
   }
   strFile.ReleaseBuffer();

   //
   // Get the template we're pasting into
   //
   pTemp = GetTemplate(szTemplate);
   if (!pTemp) {
      return E_FAIL;
   }

   //
   // Attach the data object to the clipboard; we don't need
   // to worry about releasing it since that will be done in
   // DataObject's destructor
   //
   if (!DataObject.AttachClipboard()) {
      return E_FAIL;
   }

   if (!DataObject.IsDataAvailable((CLIPFORMAT)cf)) {
      return E_FAIL;
   }

   pFile = DataObject.GetFileData((CLIPFORMAT)cf);

   if (pFile) {
      //
      // Write the data from the clipboard to a temporary file
      //
      if ( pFileOut.Open(szFile,CFile::modeWrite) ) {
         dw = pFile->GetLength();
         pBuf = new BYTE [dw];
         if (NULL != pBuf) {
            pFile->Read(pBuf,dw);
            pFileOut.Write(pBuf,dw);
         } else {
            hr = E_FAIL;
         }
         pFileOut.Close();
      }
      pFile->Close();
   } else {
      return E_FAIL;
   }

   if (S_OK == hr) {
      //
      // Have the engine open the temporary file as a template
      //
      if (EngineOpenProfile(szFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
         delete []pBuf; //Raid #prefast
         return E_FAIL;
      }


      //
      // Load the temporary template area into our scratch SCE_PROFILE_INFO
      //

      //
      // SceGetSecurityProfileInfo will allocate an SCE_PROFILE_INFO struct
      // if a pointer to a NULL one is passed in
      //
      spi = NULL;
      status = SceGetSecurityProfileInfo(pHandle,
                                         SCE_ENGINE_SCP,
                                         Area,
                                         &spi,
                                         NULL);
      SceCloseProfile(&pHandle);
      pHandle = NULL;

      if (SCESTATUS_SUCCESS == status) {

         PSCE_REGISTRY_VALUE_INFO    pRegValues;
         //
         // The load succeeded, so free the appropriate old area and copy the
         // new version from the scratch SCE_PROFILE_INFO
         //
         switch(ft) {
         case POLICY_ACCOUNT:
            pTemp->pTemplate->MinimumPasswordAge = spi->MinimumPasswordAge;
            pTemp->pTemplate->MaximumPasswordAge = spi->MaximumPasswordAge;
            pTemp->pTemplate->PasswordComplexity = spi->PasswordComplexity;
            pTemp->pTemplate->ClearTextPassword  = spi->ClearTextPassword;
            pTemp->pTemplate->PasswordHistorySize = spi->PasswordHistorySize;
            pTemp->pTemplate->RequireLogonToChangePassword = spi->RequireLogonToChangePassword;
            pTemp->pTemplate->MinimumPasswordLength = spi->MinimumPasswordLength;
            pTemp->pTemplate->LockoutBadCount = spi->LockoutBadCount;
            pTemp->pTemplate->ResetLockoutCount = spi->ResetLockoutCount;
            pTemp->pTemplate->LockoutDuration = spi->LockoutDuration;
            if (spi->pKerberosInfo) {
               if (!pTemp->pTemplate->pKerberosInfo) {
                  pTemp->pTemplate->pKerberosInfo = (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR,sizeof(SCE_KERBEROS_TICKET_INFO));
               }
               if (pTemp->pTemplate->pKerberosInfo) {
                   pTemp->pTemplate->pKerberosInfo->MaxTicketAge = spi->pKerberosInfo->MaxTicketAge;
                   pTemp->pTemplate->pKerberosInfo->MaxServiceAge = spi->pKerberosInfo->MaxServiceAge;
                   pTemp->pTemplate->pKerberosInfo->MaxClockSkew = spi->pKerberosInfo->MaxClockSkew;
                   pTemp->pTemplate->pKerberosInfo->MaxRenewAge = spi->pKerberosInfo->MaxRenewAge;
                   pTemp->pTemplate->pKerberosInfo->TicketValidateClient = spi->pKerberosInfo->TicketValidateClient;
               }
            } else if (pTemp->pTemplate->pKerberosInfo) {
               LocalFree(pTemp->pTemplate->pKerberosInfo);
               pTemp->pTemplate->pKerberosInfo = NULL;
            }
            break;

         case POLICY_LOCAL:
            pTemp->pTemplate->AuditAccountManage = spi->AuditAccountManage;
            pTemp->pTemplate->AuditLogonEvents = spi->AuditLogonEvents;
            pTemp->pTemplate->AuditObjectAccess = spi->AuditObjectAccess;
            pTemp->pTemplate->AuditPolicyChange = spi->AuditPolicyChange;
            pTemp->pTemplate->AuditPrivilegeUse = spi->AuditPrivilegeUse;
            pTemp->pTemplate->AuditProcessTracking = spi->AuditProcessTracking;
            pTemp->pTemplate->AuditSystemEvents = spi->AuditSystemEvents;
            pTemp->pTemplate->AuditDSAccess = spi->AuditDSAccess;
            pTemp->pTemplate->AuditAccountLogon = spi->AuditAccountLogon;
            pTemp->pTemplate->LSAAnonymousNameLookup = spi->LSAAnonymousNameLookup;


            pTemp->pTemplate->ForceLogoffWhenHourExpire = spi->ForceLogoffWhenHourExpire;
            pTemp->pTemplate->EnableAdminAccount = spi->EnableAdminAccount;
            pTemp->pTemplate->EnableGuestAccount = spi->EnableGuestAccount;
            pTemp->pTemplate->NewAdministratorName = spi->NewAdministratorName;
            pTemp->pTemplate->NewGuestName = spi->NewGuestName;
            spi->NewAdministratorName = NULL;
            spi->NewGuestName = NULL;

            //
            // copy reg value section too
            //
            dw = pTemp->pTemplate->RegValueCount;
            pRegValues = pTemp->pTemplate->aRegValues;

            pTemp->pTemplate->RegValueCount = spi->RegValueCount;
            pTemp->pTemplate->aRegValues = spi->aRegValues;

            spi->RegValueCount = dw;
            spi->aRegValues = pRegValues;

            SceRegEnumAllValues(
                &(pTemp->pTemplate->RegValueCount),
                &(pTemp->pTemplate->aRegValues)
                );
            //
            // copy user rights
            //
            SceFreeMemory(pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo,SCE_STRUCT_PRIVILEGE);
            pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo = spi->OtherInfo.scp.u.pPrivilegeAssignedTo;
            spi->OtherInfo.scp.u.pPrivilegeAssignedTo = NULL;
            break;

         case POLICY_PASSWORD:
            pTemp->pTemplate->MinimumPasswordAge = spi->MinimumPasswordAge;
            pTemp->pTemplate->MaximumPasswordAge = spi->MaximumPasswordAge;
            pTemp->pTemplate->PasswordComplexity = spi->PasswordComplexity;
            pTemp->pTemplate->ClearTextPassword  = spi->ClearTextPassword;

            pTemp->pTemplate->PasswordHistorySize = spi->PasswordHistorySize;
            pTemp->pTemplate->RequireLogonToChangePassword = spi->RequireLogonToChangePassword;
            pTemp->pTemplate->MinimumPasswordLength = spi->MinimumPasswordLength;
            break;

         case POLICY_LOCKOUT:
            pTemp->pTemplate->LockoutBadCount = spi->LockoutBadCount;
            pTemp->pTemplate->ResetLockoutCount = spi->ResetLockoutCount;
            pTemp->pTemplate->LockoutDuration = spi->LockoutDuration;
            break;

         case POLICY_KERBEROS:
             pTemp->pTemplate->pKerberosInfo->MaxTicketAge = spi->pKerberosInfo->MaxTicketAge;
             pTemp->pTemplate->pKerberosInfo->MaxServiceAge = spi->pKerberosInfo->MaxServiceAge;
             pTemp->pTemplate->pKerberosInfo->MaxClockSkew = spi->pKerberosInfo->MaxClockSkew;
             pTemp->pTemplate->pKerberosInfo->MaxRenewAge = spi->pKerberosInfo->MaxRenewAge;
             pTemp->pTemplate->pKerberosInfo->TicketValidateClient = spi->pKerberosInfo->TicketValidateClient;
            break;

         case POLICY_AUDIT:
            pTemp->pTemplate->AuditAccountManage = spi->AuditAccountManage;
            pTemp->pTemplate->AuditLogonEvents = spi->AuditLogonEvents;
            pTemp->pTemplate->AuditObjectAccess = spi->AuditObjectAccess;
            pTemp->pTemplate->AuditPolicyChange = spi->AuditPolicyChange;
            pTemp->pTemplate->AuditPrivilegeUse = spi->AuditPrivilegeUse;
            pTemp->pTemplate->AuditProcessTracking = spi->AuditProcessTracking;
            pTemp->pTemplate->AuditSystemEvents = spi->AuditSystemEvents;
            pTemp->pTemplate->AuditDSAccess = spi->AuditDSAccess;
            pTemp->pTemplate->AuditAccountLogon = spi->AuditAccountLogon;
            break;

         case POLICY_OTHER:
            pTemp->pTemplate->ForceLogoffWhenHourExpire = spi->ForceLogoffWhenHourExpire;
            pTemp->pTemplate->EnableGuestAccount = spi->EnableGuestAccount;
            pTemp->pTemplate->EnableAdminAccount = spi->EnableAdminAccount;
            pTemp->pTemplate->LSAAnonymousNameLookup = spi->LSAAnonymousNameLookup;
            pTemp->pTemplate->NewAdministratorName = spi->NewAdministratorName;
            pTemp->pTemplate->NewGuestName = spi->NewGuestName;
            spi->NewAdministratorName = NULL;
            spi->NewGuestName = NULL;

            //
            // copy reg value section too
            //
            dw = pTemp->pTemplate->RegValueCount;
            pRegValues = pTemp->pTemplate->aRegValues;

            pTemp->pTemplate->RegValueCount = spi->RegValueCount;
            pTemp->pTemplate->aRegValues = spi->aRegValues;

            spi->RegValueCount = dw;
            spi->aRegValues = pRegValues;

            SceRegEnumAllValues(
                &(pTemp->pTemplate->RegValueCount),
                &(pTemp->pTemplate->aRegValues)
                );

            break;

         case AREA_PRIVILEGE:
            SceFreeMemory(pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo,SCE_STRUCT_PRIVILEGE);
            pTemp->pTemplate->OtherInfo.scp.u.pPrivilegeAssignedTo = spi->OtherInfo.scp.u.pPrivilegeAssignedTo;
            spi->OtherInfo.scp.u.pPrivilegeAssignedTo = NULL;
            break;

         case POLICY_EVENTLOG:
         case POLICY_LOG:
            for(k=0;k<3;k++) {
               pTemp->pTemplate->MaximumLogSize[k] = spi->MaximumLogSize[k];
               pTemp->pTemplate->AuditLogRetentionPeriod[k] = spi->AuditLogRetentionPeriod[k];
               pTemp->pTemplate->RetentionDays[k] = spi->RetentionDays[k];
               pTemp->pTemplate->RestrictGuestAccess[k] = spi->RestrictGuestAccess[k];
            }
            break;

         case AREA_GROUPS:
            SceFreeMemory(pTemp->pTemplate->pGroupMembership,SCE_STRUCT_GROUP);
            pTemp->pTemplate->pGroupMembership = spi->pGroupMembership;
            spi->pGroupMembership = NULL;
            break;

         case AREA_SERVICE:
            SceFreeMemory(pTemp->pTemplate->pServices,SCE_STRUCT_SERVICES);
            pTemp->pTemplate->pServices = spi->pServices;
            spi->pServices = NULL;
            break;
         case AREA_REGISTRY:
            SceFreeMemory(pTemp->pTemplate->pRegistryKeys.pAllNodes,SCE_STRUCT_OBJECT_ARRAY);
            pTemp->pTemplate->pRegistryKeys = spi->pRegistryKeys;
            spi->pRegistryKeys.pAllNodes = NULL;
            break;
         case AREA_FILESTORE:
            SceFreeMemory(pTemp->pTemplate->pFiles.pAllNodes,SCE_STRUCT_OBJECT_ARRAY);
            pTemp->pTemplate->pFiles = spi->pFiles;
            spi->pFiles.pAllNodes = NULL;
            break;
         default:
            break;
         }
      }
      SceFreeProfileMemory(spi);
      pTemp->SetDirty(Area);

      RefreshAllFolders();
   } else {
      //
      // Don't do anything special, just be sure to clean up below....
      //
   }


   //
   // Delete the temporary file
   //
   pFileOut.Remove(szFile);
   if (pBuf) {
      delete []pBuf; //Raid #prefast
   }
   if (pFile) {
      delete pFile;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cservice.cpp
//
//  Contents:   implementation of CConfigService
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "Cservice.h"
#include "util.h"
#include "servperm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigService dialog


CConfigService::CConfigService(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
m_hwndSecurity(NULL), 
m_pNewSD(NULL), 
m_NewSeInfo(0)

{
    //{{AFX_DATA_INIT(CConfigService)
    m_nStartupRadio = -1;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a195HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigService::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigService)
    DDX_Radio(pDX, IDC_ENABLED, m_nStartupRadio);
    DDX_Control(pDX, IDC_BASESD, m_bPermission);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigService, CAttribute)
    //{{AFX_MSG_MAP(CConfigService)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_BN_CLICKED(IDC_BASESD, OnChangeSecurity)
	ON_BN_CLICKED(IDC_DISABLED, OnDisabled)
	ON_BN_CLICKED(IDC_IGNORE, OnIgnore)
	ON_BN_CLICKED(IDC_ENABLED, OnEnabled)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigService message handlers

BOOL CConfigService::OnApply()
{
   if ( !m_bReadOnly )
   {
       DWORD dw = 0;
       int status = 0;

       UpdateData(TRUE);
       PEDITTEMPLATE pTemp = m_pData->GetBaseProfile();

       if (!m_bConfigure ) 
       {
           if ( m_pData->GetBase() != 0 ) 
           {
               if ( pTemp != NULL && pTemp->pTemplate != NULL ) 
               {
                   //
                   // look for the address stored in m_pData->GetBase()
                   // if found it, delete it.
                   //
                   PSCE_SERVICES pServParent, pService;

                   for ( pService=pTemp->pTemplate->pServices, pServParent=NULL;
                         pService != NULL; pServParent=pService, pService=pService->Next ) 
                   {
                       if (pService == (PSCE_SERVICES)m_pData->GetBase() ) 
                       {
                           //
                           // a configured service becomes not configured
                           //
                           if ( pServParent == NULL ) 
                           {
                               // the first service
                               pTemp->pTemplate->pServices = pService->Next;

                           } 
                           else
                               pServParent->Next = pService->Next;

                           pService->Next = NULL;
                           break;
                       }
                   }
                   m_pData->SetBase(NULL); //Raid #378271, 4/27/2001
               } 
               else
               {
                   // should never happen
                  //
                  // free the service node
                  //
                  SceFreeMemory((PVOID)(m_pData->GetBase()), SCE_STRUCT_SERVICES);
                  m_pData->SetBase(0);
               }
           }
           if ( m_pNewSD ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           switch(m_nStartupRadio) 
           {
           case 0:
               // Automatic
               dw = SCE_STARTUP_AUTOMATIC;
               break;

           case 1:
               // Manual
               dw = SCE_STARTUP_MANUAL;
               break;

           case 2:
               // DISABLED
               dw = SCE_STARTUP_DISABLED;
               break;
           default: //Raid #470209, Yang Gao.
               //When it is configured it must have one of above values
               CString msg;
               msg.LoadString(IDS_ERROR_NO_START_MODE);
               AfxMessageBox(msg, MB_OK|MB_ICONEXCLAMATION); //Raid #495010, yanggao
               return FALSE;
           }

           PSCE_SERVICES pNode=(PSCE_SERVICES)(m_pData->GetBase());

           if ( NULL == pNode ) 
           {
               //
               // a node is changed from not configured to configured
               //
               pNode = CreateServiceNode(m_pData->GetUnits(),
                                           m_pData->GetAttr(),
                                           dw,
                                           m_pNewSD,
                                           m_NewSeInfo);
               if ( pNode != NULL ) 
               {
                   //
                   // add to the service list
                   //
                   pNode->Next = pTemp->pTemplate->pServices;
                   pTemp->pTemplate->pServices = pNode;

                   m_pData->SetBase((LONG_PTR)pNode);

                   m_pNewSD = NULL;
               } 
               else 
               {
                   //
                   // no memory, error out
                   //
                   if ( m_pNewSD ) 
                   {
                       LocalFree(m_pNewSD);
                       m_pNewSD = NULL;
                   }
               }
           } 
           else 
           {
               //
               // an existing service
               //
               pNode->Startup = (BYTE)dw;

               if ( m_pNewSD != NULL ) 
               {
                   if ( pNode->General.pSecurityDescriptor != m_pNewSD &&
                        pNode->General.pSecurityDescriptor != NULL ) 
                   {
                       LocalFree(pNode->General.pSecurityDescriptor);
                   }
                   pNode->General.pSecurityDescriptor = m_pNewSD;
                   m_pNewSD = NULL;

                   pNode->SeInfo = m_NewSeInfo;
               }
           }
       }

       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;
   }

   return CAttribute::OnApply();
}

void CConfigService::OnCancel()
{
    if ( m_pNewSD ) 
    {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;

    m_bConfigure = m_bOriginalConfigure;

    CAttribute::OnCancel();
}

BOOL CConfigService::OnInitDialog()
{
    CAttribute::OnInitDialog();

    m_bOriginalConfigure = m_bConfigure;

    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    AddUserControl(IDC_IGNORE);
    AddUserControl(IDC_BASESD);

    if (QueryReadOnly()) 
	{
       CString str;
       str.LoadString(IDS_VIEW_SECURITY);

		if ( GetDlgItem(IDC_SECURITY) )
			SetDlgItemText(IDC_SECURITY,str);
		else if ( GetDlgItem(IDC_BASESD) )
			SetDlgItemText(IDC_BASESD,str);
    }

    OnConfigure();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigService::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   PSCE_SERVICES pService;

   pService = (PSCE_SERVICES)(pResult->GetBase());
   if ( NULL == pService ) {
       m_bConfigure = FALSE;
       pService = (PSCE_SERVICES)(pResult->GetSetting());
   }

   m_pNewSD = NULL;
   m_NewSeInfo = 0;

   if ( pService != NULL ) {
       switch ( pService->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_nStartupRadio = 0;
           break;
       case SCE_STARTUP_MANUAL:
           m_nStartupRadio = 1;
           break;
       case SCE_STARTUP_DISABLED: // disabled
           m_nStartupRadio = 2;
           break;
       default: // not defined //Raid #470209, Yang Gao
           m_nStartupRadio = -1;
           break;
       }
       //
       // initialize SD and SeInfo
       //
       if ( pService->General.pSecurityDescriptor ) {

            MyMakeSelfRelativeSD(pService->General.pSecurityDescriptor,
                                 &m_pNewSD);
       }
       m_NewSeInfo = pService->SeInfo;
   }

}


PSCE_SERVICES
CreateServiceNode(LPTSTR ServiceName,
                  LPTSTR DisplayName,
                  DWORD Startup,
                  PSECURITY_DESCRIPTOR pSD,
                  SECURITY_INFORMATION SeInfo)
{

    if ( NULL == ServiceName ) {
        return NULL;
    }

    PSCE_SERVICES pTemp;

    pTemp = (PSCE_SERVICES)LocalAlloc(0,sizeof(SCE_SERVICES));

    if ( pTemp != NULL ) {
        pTemp->ServiceName = (LPTSTR)LocalAlloc(0, (wcslen(ServiceName)+1)*sizeof(TCHAR));

        if ( pTemp->ServiceName != NULL ) {

            if ( DisplayName != NULL ) {
                pTemp->DisplayName = (LPTSTR)LocalAlloc(0, (wcslen(DisplayName)+1)*sizeof(TCHAR));

                if ( pTemp->DisplayName != NULL ) {
                    //This may not be a safe usage. pTemp->DisplayName is PWSTR, Consider fix.
                    wcscpy(pTemp->DisplayName, DisplayName);
                } else {
                    // no memory to allocate
                    LocalFree(pTemp->ServiceName);
                    LocalFree(pTemp);
                    return NULL;
                }
            } else
                pTemp->DisplayName = NULL;
            //This may not be a safe usage. pTemp->ServiceName is PWSTR, Consider fix.
            wcscpy(pTemp->ServiceName, ServiceName);

            pTemp->Status = 0;
            pTemp->Startup = (BYTE)Startup;

            pTemp->General.pSecurityDescriptor = pSD;
            pTemp->SeInfo = SeInfo;

            pTemp->Next = NULL;

            return pTemp;

        } else {
            // no memory to allocate
            LocalFree(pTemp);
            return NULL;
        }
    }

    return NULL;
}

void CConfigService::OnConfigure()
{
   CAttribute::OnConfigure();
   if( -1 == m_nStartupRadio && m_bConfigure ) //Raid #485374, Yanggao, 11/2/2001
   {
      PSCE_SERVICES pService = (PSCE_SERVICES)m_pData->GetProfileDefault();
      if( SCE_NO_VALUE != (DWORD)PtrToUlong((PVOID)pService) )
      {
         switch ( pService->Startup )
         {
            case SCE_STARTUP_AUTOMATIC:
                m_nStartupRadio = 0;
                break;
            case SCE_STARTUP_MANUAL:
                m_nStartupRadio = 1;
                break;
            case SCE_STARTUP_DISABLED:
                m_nStartupRadio = 2;
                break;
            default:
                m_nStartupRadio = -1;
                break;
         }
         UpdateData(FALSE);
      }
   }
}

void CConfigService::OnChangeSecurity()
{
    if (IsWindow(m_hwndSecurity)) 
    {
       ::BringWindowToTop(m_hwndSecurity);
       return;
    }

    PSECURITY_DESCRIPTOR m_pOldSD = m_pNewSD; //Raid #358244, 4/5/2001
    SECURITY_INFORMATION m_OldSeInfo = m_NewSeInfo;
    if (!m_pNewSD) 
    {
       GetDefaultServiceSecurity(&m_pNewSD,&m_NewSeInfo);
    }

    INT_PTR nRet = MyCreateSecurityPage2(FALSE,
            &m_pNewSD,
            &m_NewSeInfo,
            (LPCTSTR)(m_pData->GetAttr()),
            SE_SERVICE,
            QueryReadOnly() ? SECURITY_PAGE_RO_NP : SECURITY_PAGE_NO_PROTECT,
            GetSafeHwnd(),
            FALSE);    // not modeless

    if ( -1 == nRet ) 
    {
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);
        if( m_pNewSD != m_pOldSD && m_pNewSD ) //Raid #358244, 4/5/2001
        {
            LocalFree(m_pNewSD);
        }
        m_pNewSD = m_pOldSD;
        m_NewSeInfo = m_OldSeInfo;
    }

    if( 0 == nRet ) //Raid #358244, 4/5/2001
    {
        if( m_pNewSD != m_pOldSD && m_pNewSD ) 
        {
            LocalFree(m_pNewSD);
        }
        m_pNewSD = m_pOldSD;
        m_NewSeInfo = m_OldSeInfo;
    }
    SetModified(TRUE);
}

void CConfigService::OnDisabled() 
{
    int prevValue = m_nStartupRadio; //Raid #490995, Yanggao
    UpdateData(); 
    if(m_nStartupRadio != prevValue)
    {
	    SetModified(TRUE);
    }
}

void CConfigService::OnIgnore() 
{
    int prevValue = m_nStartupRadio; //Raid #490995, Yanggao
    UpdateData(); 
    if(m_nStartupRadio != prevValue)
    {
	    SetModified(TRUE);
    }
}

void CConfigService::OnEnabled() 
{
    int prevValue = m_nStartupRadio; //Raid #490995, Yanggao
    UpdateData(); 
    if(m_nStartupRadio != prevValue)
    {
	    SetModified(TRUE);
    }
}

void 
CConfigService::EnableUserControls( BOOL bEnable ) {
   CAttribute::EnableUserControls(bEnable);
   //
   // IDC_SECURITY needs to be available even in read only
   // mode so that the security page can be viewed.
   //
   // The page itself will be read only if necessary
   //
   if (QueryReadOnly() && bEnable) 
   {
      CWnd* pWnd = GetDlgItem(IDC_SECURITY);
      if (pWnd) 
	  {
         pWnd->EnableWindow(TRUE);
      }
	  else 
	  {
		  pWnd = GetDlgItem(IDC_BASESD);
		  if (pWnd) 
		  {
			 pWnd->EnableWindow(TRUE);
		  }
	  }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cprivs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cprivs.cpp
//
//  Contents:   implementation of CConfigPrivs
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CPrivs.h"
#include "GetUser.h"
#include "AddGrp.h"

#include "snapmgr.h"

#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

BOOL
WseceditGetNameForSpecialSids(
    OUT PWSTR   *ppszEveryone OPTIONAL,
    OUT PWSTR   *ppszAuthUsers OPTIONAL,
    OUT PWSTR   *ppszAdmins OPTIONAL,
    OUT PWSTR   *ppszAdministrator OPTIONAL
    );

PSID
WseceditpGetAccountDomainSid(
    );

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs dialog
/////////////////////////////////////////////////////////////////////////////

CConfigPrivs::CConfigPrivs(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD),
m_fDirty(false)

{
    //{{AFX_DATA_INIT(CConfigPrivs)
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a106HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigPrivs::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_GRANTLIST, m_lbGrant);
    DDX_Control(pDX, IDC_REMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_ADD, m_btnAdd);
    DDX_Control(pDX, IDC_TITLE, m_btnTitle);
}


BEGIN_MESSAGE_MAP(CConfigPrivs, CAttribute)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_LBN_SELCHANGE(IDC_GRANTLIST, OnSelChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigPrivs message handlers
/////////////////////////////////////////////////////////////////////////////

void CConfigPrivs::OnAdd()
{
   CSCEAddGroup gu(this);
   PSCE_NAME_LIST pName = 0;

   if( IDD_CONFIG_PRIVS == m_uTemplateResID ) //Raid #404989
   {
       gu.m_fCheckName = FALSE;
   }
   gu.m_dwFlags = SCE_SHOW_USERS | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL | SCE_SHOW_WELLKNOWN | SCE_SHOW_BUILTIN;
   if( IDD_DOMAIN_PRIVS == m_uTemplateResID ) //Raid #477428, Yanggao
   {
       gu.m_dwFlags = gu.m_dwFlags | SCE_SHOW_COMPUTER;
   }
   gu.SetModeBits(m_pSnapin->GetModeBits());

   CString str;
   str.LoadString( IDS_ADD_USERGROUP );
   gu.m_sTitle.Format( IDS_ADD_TITLE, str );
   gu.m_sDescription.LoadString( IDS_ADD_USERGROUP );

   CThemeContextActivator activator;
   if (gu.DoModal() ==IDOK ) {
      pName = gu.GetUsers();
      UINT cstrMax = 0;  //Raid #271219
      LPWSTR pstrMax = NULL;
      UINT cstr = 0;
      while(pName)
      {
         if (LB_ERR == m_lbGrant.FindStringExact(-1,pName->Name))
         {
            if( LB_ERR == m_lbGrant.AddString(pName->Name) )
            {
                return;
            }
            m_fDirty = true;
            
            cstr = wcslen(pName->Name);
            if( cstr > cstrMax )
            {
              cstrMax = cstr;
              pstrMax = pName->Name;
            }
         }
         pName = pName->Next;
      }
      SetModified(TRUE);

      CDC* pCDC = m_lbGrant.GetDC();
      CSize strsize = pCDC->GetOutputTextExtent(pstrMax);
      m_lbGrant.ReleaseDC(pCDC);
      RECT winsize;
      m_lbGrant.GetWindowRect(&winsize); 
      if( strsize.cx > winsize.right-winsize.left )
      {
         m_lbGrant.SetHorizontalExtent(strsize.cx);
      }
   }
}

void CConfigPrivs::OnRemove()
{
    int cbItems;
   int *pnItems;

   cbItems = m_lbGrant.GetSelCount();
   pnItems = new int [cbItems];

   if ( pnItems ) {

       m_lbGrant.GetSelItems(cbItems,pnItems);

       if (cbItems) {
          m_fDirty = true;
                  SetModified(TRUE);
       }

       while(cbItems--) {
          m_lbGrant.DeleteString(pnItems[cbItems]);
       }

       delete[] pnItems;
       
       CWnd* pwnd = GetDlgItem(IDC_REMOVE); //Raid #466634, Yang Gao
       if( pwnd )
       {
          CWnd* pPrev = pwnd->GetWindow(GW_HWNDPREV); //Raid #482112, yanggao, 10/20/2001
          if(pPrev)
          {
             this->GotoDlgCtrl(pPrev); 
             pwnd->EnableWindow(FALSE);
          }
       }
   }
}

void CConfigPrivs::OnConfigure()
{
   CAttribute::OnConfigure();

   if (m_bConfigure == m_bOriginalConfigure) {
      m_fDirty = false;
   } else {
      m_fDirty = true;
   }

   //Raid #466634, Yang Gao
   CWnd* pwnd = GetDlgItem(IDC_REMOVE);
   if( pwnd )
   {
      if( m_lbGrant.GetCount() == 0 || m_lbGrant.GetSelCount() == 0 ) //Raid #475690, 476535, Yanggao
      {
         pwnd->EnableWindow(FALSE);
      }
   }
}

BOOL CConfigPrivs::OnApply()
{
   if ( !m_bReadOnly )
   {
      PSCE_PRIVILEGE_ASSIGNMENT ppa = 0;
      PSCE_NAME_LIST pNames = 0;
      CString strItem;
      int cItems = 0;
      int i = 0;

      UpdateData(TRUE);

      if(!m_bConfigure)
      {
          PSCE_PRIVILEGE_ASSIGNMENT pDelete;

          pDelete = GetPrivData();

          //
          // Remove the item from the template

          if( pDelete && pDelete != (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) )
          {
               m_pData->SetID((LONG_PTR)NULL);
               if (m_pData->GetSetting()) //Raid #390777
               {
                   m_pData->SetSetting((LONG_PTR)ULongToPtr(SCE_NO_VALUE));
               }
               m_pData->SetUnits((LPTSTR)pDelete->Name);
               m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
               m_pData->SetBase((LONG_PTR)ULongToPtr(SCE_NO_VALUE));

               m_pData->GetBaseProfile()->UpdatePrivilegeAssignedTo(
                           TRUE,        // Delete the profile.
                           &pDelete);
                           m_pData->GetBaseProfile()->SetDirty(AREA_PRIVILEGES);
               m_pData->Update(m_pSnapin);
          }
      }
      else if (m_fDirty)
      {

          ppa = GetPrivData();

          PWSTR    pszPrivName = m_pData->GetUnits();

          if ( ppa ) {
              //
              // to handle configured privilege case where Units is NULL
              //
              pszPrivName = ppa->Name;
          }

          int      cSpecialItems = m_lbGrant.GetCount();
          DWORD    dwIds = 0;
          CString  strDenyItem;

          //
          // simulate SCE engine behavior to special case certain privileges/rights
          //

          if ( pszPrivName )
           {
               //Prefast warning 400: Yields unexpected result in non-English locale. 
               //Comments: It is always English locale.
               if ( _wcsicmp(pszPrivName, SE_INTERACTIVE_LOGON_NAME) == 0 )
               {
                   if ( cSpecialItems == 0 ) {
                       //
                       // logon locally right cannot be assigned to no one
                       //
                       dwIds = IDS_PRIV_WARNING_LOCAL_LOGON;

                   } else {

                       PWSTR pszAdmins = NULL;

                       //
                       // get the administrators group name
                       // logon locally right must be assigned to the administrator group
                       //
                       if ( WseceditGetNameForSpecialSids(NULL,
                                                          NULL,
                                                          &pszAdmins,
                                                          NULL) )
                       {
                           for (i=0;i<cSpecialItems;i++)
                           {
                               m_lbGrant.GetText(i,strDenyItem);
                               if ( (lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdmins)) == 0 )
                               {
                                   break;
                               }
                           }

                           if ( i >= cSpecialItems ) {
                               //
                               // cannot find administrators
                               //
                               dwIds = IDS_PRIV_WARNING_LOCAL_LOGON;
                           }

                           LocalFree(pszAdmins);

                       }

                       else
                       {
                           dwIds = IDS_PRIV_WARNING_ACCOUNT_TRANSLATION;
                       }

                   }
               }
               //Prefast warning 400: Yields unexpected result in non-English locale. 
               //Comments: It is always English locale.
               else if (_wcsicmp(pszPrivName, SE_DENY_INTERACTIVE_LOGON_NAME) == 0 ) 
               {
                   PWSTR pszEveryone = NULL;
                   PWSTR pszAuthUsers = NULL;
                   PWSTR pszAdmins = NULL;
                   PWSTR pszAdministrator=NULL;

                   //
                   // deny logon locally right cannot be assigned to any of the following
                   //  everyone, authenticated users, administrators, administrator
                   //
                   if ( WseceditGetNameForSpecialSids(&pszEveryone,
                                                      &pszAuthUsers,
                                                      &pszAdmins,
                                                      &pszAdministrator) )
                   {

                       //
                       // make sure this check covers the free text administrator account as well
                       //
                       PWSTR pTemp = wcschr(pszAdministrator, L'\\');

                       if ( pTemp ) {
                           pTemp++;
                       }

                       for (i=0;i<cSpecialItems;i++)
                       {
                           m_lbGrant.GetText(i,strDenyItem);
                           if ( lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszEveryone) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAuthUsers) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdmins) == 0 ||
                                lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pszAdministrator) == 0 ||
                                (pTemp && lstrcmpi((LPTSTR)(LPCTSTR)strDenyItem, pTemp) == 0 ) )
                           {
                               dwIds = IDS_PRIV_WARNING_DENYLOCAL_LOGON;
                               break;
                           }
                       }

                       LocalFree(pszEveryone);
                       LocalFree(pszAuthUsers);
                       LocalFree(pszAdmins);
                       LocalFree(pszAdministrator);
                   }

                   else
                   {
                       dwIds = IDS_PRIV_WARNING_ACCOUNT_TRANSLATION;
                   }
               }

               if (dwIds == IDS_PRIV_WARNING_LOCAL_LOGON ||
                   dwIds == IDS_PRIV_WARNING_DENYLOCAL_LOGON ||
                   dwIds == IDS_PRIV_WARNING_ACCOUNT_TRANSLATION )
               {

                   //
                   // if any of the items fail the check, display the warning
                   // or popup a warning message box
                   //
                   CString strWarning;
                   strWarning.LoadString(dwIds);

                   CWnd *pWarn = GetDlgItem(IDC_WARNING);
                   if (pWarn)
                   {
                       pWarn->SetWindowText(strWarning);
                       pWarn->ShowWindow(SW_SHOW);
                       pWarn = GetDlgItem(IDC_WARNING_ICON);
                       if (pWarn)
                           pWarn->ShowWindow(SW_SHOW);
                       pWarn = GetDlgItem(IDC_ADD); //Raid 498449, yanggao
                       if( pWarn )
                       {
                           this->GotoDlgCtrl(pWarn);
                       }
                   }
                   else
                   {
                       //
                       // Dialog box not available in some modes such as Local Policy
                       //

                       AfxMessageBox(strWarning);
                   }

                   return FALSE;
               }
               CWnd *pWarn = GetDlgItem(IDC_WARNING); //Raid #621124, Yanggao
               if (pWarn)
               {
                  pWarn->ShowWindow(SW_HIDE);
               }
               pWarn = GetDlgItem(IDC_WARNING_ICON);
               if (pWarn)
               {
                  pWarn->ShowWindow(SW_HIDE);
               }
           }

           if ( ppa == NULL && m_pData->GetUnits() )
           {
               if ( m_pData->GetBaseProfile()->UpdatePrivilegeAssignedTo(
                                                                        FALSE,
                                                                        &ppa,
                                                                        m_pData->GetUnits()
                                                                        ) == ERROR_SUCCESS)
               {
                   m_pData->GetBaseProfile()->SetDirty(AREA_PRIVILEGES);
                   SetPrivData(ppa);
               }
           }

           if ( ppa )
           {
               PSCE_NAME_LIST pNewList=NULL;

               cItems = m_lbGrant.GetCount();
               HRESULT hr=S_OK;


               if (cItems != LB_ERR && m_bConfigure)
               {
                   for (i=0;i<cItems;i++)
                   {
                       m_lbGrant.GetText(i,strItem);
                       if ( SceAddToNameList(&pNewList, (LPTSTR)(LPCTSTR)strItem, strItem.GetLength()) != SCESTATUS_SUCCESS)
                       {
                           hr = E_FAIL;
                           break;
                       }
                   }
               }
               else
                   hr = E_FAIL;

               if ( SUCCEEDED(hr) )
               {
                   SceFreeMemory(ppa->AssignedTo,SCE_STRUCT_NAME_LIST);
                   ppa->AssignedTo = pNewList;

                   SetPrivData(ppa);
                   m_pData->Update(m_pSnapin);
                   m_fDirty = false;
               }
               else
               {
                   //
                   // free the new list, failed due to memory problem
                   //
                   if ( pNewList ) {
                       SceFreeMemory(pNewList,SCE_STRUCT_NAME_LIST);
                   }
               }
           }
       }
   }

   return CAttribute::OnApply();
}

void CConfigPrivs::OnCancel()
{
   m_bConfigure = m_bOriginalConfigure;
   CAttribute::OnCancel();
}

PSCE_PRIVILEGE_ASSIGNMENT
CConfigPrivs::GetPrivData() {
   ASSERT(m_pData);
   if (m_pData) {
      return (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetID();
   }
   return NULL;
}

void
CConfigPrivs::SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa) {
   ASSERT(m_pData);
   if (m_pData) {
      m_pData->SetID((LONG_PTR)ppa);
      if (ppa) {
         m_pData->SetBase((LONG_PTR)ppa->AssignedTo);
      } else {
         m_pData->SetBase(NULL);
      }
   }
}

BOOL CConfigPrivs::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PSCE_PRIVILEGE_ASSIGNMENT ppa;
   PSCE_NAME_LIST pNames;

   UpdateData(FALSE);

   ::SetMapMode(::GetDC(m_lbGrant.m_hWnd), MM_TEXT);
   
   ppa = GetPrivData();

   if ( ppa ) {

       pNames = ppa->AssignedTo;
       UINT cstrMax = 0; //Raid #271219
       LPWSTR pstrMax = NULL;
       UINT cstr = 0;
       while(pNames)
       {
          m_lbGrant.AddString(pNames->Name);
          cstr = wcslen(pNames->Name);
          if( cstr > cstrMax )
          {
              cstrMax = cstr;
              pstrMax = pNames->Name;
          }
          pNames = pNames->Next;
       }

       CDC* pCDC = m_lbGrant.GetDC();
       CSize strsize = pCDC->GetOutputTextExtent(pstrMax);
       m_lbGrant.ReleaseDC(pCDC);
       RECT winsize;
       m_lbGrant.GetWindowRect(&winsize); 
       if( strsize.cx > winsize.right-winsize.left )
       {
          m_lbGrant.SetHorizontalExtent(strsize.cx);
       }
       
       m_bConfigure = TRUE;
   } else if(m_pData->GetBase() == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)){
      m_bConfigure = FALSE;
   }

   if (m_pData->GetSetting())
   {
      CWnd *pWarn = GetDlgItem(IDC_WARNING);
      if (pWarn)
      {
         CString strWarning;
         strWarning.LoadString(IDS_PRIV_WARNING);
         pWarn->SetWindowText(strWarning);
         pWarn->ShowWindow(SW_SHOW);

         pWarn = GetDlgItem(IDC_WARNING_ICON);
         if (pWarn)
         {
            pWarn->ShowWindow(SW_SHOW);
         }
      }
   }


   m_bOriginalConfigure = m_bConfigure;

   //
   // Update the user controls depending on the setting.
   //
   AddUserControl(IDC_GRANTLIST);
   AddUserControl(IDC_ADD);
   AddUserControl(IDC_REMOVE);

   m_btnTitle.SetWindowText(m_pData->GetAttrPretty());
   UpdateData(FALSE);
   EnableUserControls(m_bConfigure);

   GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE); //Raid #471511, Yanggao.

   // The listbox should always be enabled so that its contents may be viewed
   // Raid# 697665 "Local Computer Policy on a DC:Allow logon locally 
   // properties page list box scroll bar is disabled preventing viewing of all users"
   // bryanwal
   m_lbGrant.EnableWindow (TRUE);

   return TRUE;

    // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigPrivs::SetInitialValue(DWORD_PTR dw)
{

}

BOOL
WseceditGetNameForSpecialSids(
    OUT PWSTR   *ppszEveryone OPTIONAL,
    OUT PWSTR   *ppszAuthUsers OPTIONAL,
    OUT PWSTR   *ppszAdmins OPTIONAL,
    OUT PWSTR   *ppszAdministrator OPTIONAL
    )
/*++
Routine Description:

    This routine returns the localized account name for the Everyone and the Auth User SIDs

Arguments:

    ppszEveryone     -   ptr to fill in (should be freed outside)

    ppszAuthUsers    -   ptr to fill in (should be freed outside)

    ppszAdmins       -   ptr to fill in for Administrators

    ppszAdministrator -  ptr to fill in for local administrator account

Return value:

    TRUE if succeeded else FALSE

-- */

{
    //
    // buffers for the SIDs
    //
    SID     Sid;
    DWORD   dwSize = sizeof(SID);
    PSID    pSid=NULL;

    BOOL    bError = TRUE;

    //
    // variables for sid lookup
    //
    SID_NAME_USE   tmp;
    DWORD dwSizeDom;
    PWSTR   dummyBuf = NULL;

    if ( ppszEveryone ) {

        //
        // create the SID for "everyone"
        //
        if ( CreateWellKnownSid(
                               WinWorldSid,
                               NULL,
                               &Sid,
                               &dwSize)) {

            //
            // get the required size of the account name and domain buffer
            //
            dwSize = 0;
            dwSizeDom = 0;

            LookupAccountSid(
                            NULL,
                            &Sid,
                            NULL,
                            &dwSize,
                            NULL,
                            &dwSizeDom,
                            &tmp
                            );

            *ppszEveryone = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
            dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

            if ( *ppszEveryone && dummyBuf ) {

                //
                // lookup the SID to get the account name - domain name is ignored
                //
                if ( LookupAccountSid(
                                     NULL,
                                     &Sid,
                                     *ppszEveryone,
                                     &dwSize,
                                     dummyBuf,
                                     &dwSizeDom,
                                     &tmp
                                     ) ) {
                    bError = FALSE;
                }
            }
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {
            LocalFree(*ppszEveryone);
            *ppszEveryone = NULL;
            return FALSE;
        }
    }

    //
    // "Authenticated Users"
    //

    if ( ppszAuthUsers ) {

        dwSize = sizeof(SID);
        bError = TRUE;

        //
        // create the SID for "authenticated users"
        //
        if ( CreateWellKnownSid(
                               WinAuthenticatedUserSid,
                               NULL,
                               &Sid,
                               &dwSize)) {

            //
            // get the required size of account name and domain buffers
            //
            dwSize = 0;
            dwSizeDom = 0;

            LookupAccountSid(
                            NULL,
                            &Sid,
                            NULL,
                            &dwSize,
                            NULL,
                            &dwSizeDom,
                            &tmp
                            );

            *ppszAuthUsers = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
            dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

            if ( *ppszAuthUsers && dummyBuf ) {

                //
                // lookup the SID to get account name - domain name is ignored
                //
                if ( LookupAccountSid(
                                     NULL,
                                     &Sid,
                                     *ppszAuthUsers,
                                     &dwSize,
                                     dummyBuf,
                                     &dwSizeDom,
                                     &tmp
                                     ) ) {
                    bError = FALSE;
                }
            }
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {

            LocalFree(*ppszAuthUsers);
            *ppszAuthUsers = NULL;

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }
    }

    //
    // administrators group
    //

    if ( ppszAdmins ) {

        dwSize = 0;
        bError = TRUE;

        //
        // get the size for the well known SID of administrators group
        //
        CreateWellKnownSid(
                   WinBuiltinAdministratorsSid,
                   NULL,
                   pSid,
                   &dwSize);

        if ( dwSize > 0 ) {

            //
            // alocate buffer and create the well known SID
            // cannot use the SID buffer because Admins SID has more than
            // one subauthority
            //
            pSid = (PSID)LocalAlloc(LPTR, dwSize);

            if ( pSid &&

                 CreateWellKnownSid(
                           WinBuiltinAdministratorsSid,
                           NULL,
                           pSid,
                           &dwSize) ) {

                dwSize = 0;
                dwSizeDom = 0;

                //
                // get the size for account name and domain buffers
                //
                LookupAccountSid(
                                NULL,
                                pSid,
                                NULL,
                                &dwSize,
                                NULL,
                                &dwSizeDom,
                                &tmp
                                );

                *ppszAdmins = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
                dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

                if ( *ppszAdmins && dummyBuf ) {

                    //
                    // look up the name, domain name (BUILTIN) is ignored
                    //
                    if ( LookupAccountSid(
                                         NULL,
                                         pSid,
                                         *ppszAdmins,
                                         &dwSize,
                                         dummyBuf,
                                         &dwSizeDom,
                                         &tmp
                                         ) ) {
                        bError = FALSE;
                    }
                }
            }

            LocalFree(pSid);
            pSid = NULL;
        }

        LocalFree(dummyBuf);
        dummyBuf = NULL;

        if (bError) {

            //
            // anything fail will free all buffers and return FALSE
            //

            LocalFree(*ppszAdmins);
            *ppszAdmins = NULL;

            if ( ppszAuthUsers ) {

                LocalFree(*ppszAuthUsers);
                *ppszAuthUsers = NULL;
            }

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }
    }

    //
    // the administrator user account
    //
    if ( ppszAdministrator ) {

        dwSize = 0;
        bError = TRUE;

        PWSTR dummy2=NULL;

        //
        // Get Account domain SID first
        //
        PSID pDomSid = WseceditpGetAccountDomainSid();

        if ( pDomSid ) {

            //
            // get the size for the administrator account (local account domain is used)
            //
            CreateWellKnownSid(
                       WinAccountAdministratorSid,
                       pDomSid,
                       pSid,
                       &dwSize);

            if ( dwSize > 0 ) {

                //
                // cannot use the SID buffer because administrator account SID
                // has more than one subauthority
                //
                pSid = (PSID)LocalAlloc(LPTR, dwSize);

                if ( pSid &&
                     CreateWellKnownSid(
                               WinAccountAdministratorSid,
                               pDomSid,
                               pSid,
                               &dwSize) ) {

                    //
                    // get size for the account name and domain buffer
                    //
                    dwSize = 0;
                    dwSizeDom = 0;

                    LookupAccountSid(
                                    NULL,
                                    pSid,
                                    NULL,
                                    &dwSize,
                                    NULL,
                                    &dwSizeDom,
                                    &tmp
                                    );

                    dummy2 = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSize + 1) * sizeof(WCHAR)));
                    dummyBuf = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((dwSizeDom + 1) * sizeof(WCHAR)));

                    if ( dummy2 && dummyBuf ) {

                        //
                        // lookup the account name and domain name
                        //
                        if ( LookupAccountSid(
                                             NULL,
                                             pSid,
                                             dummy2,
                                             &dwSize,
                                             dummyBuf,
                                             &dwSizeDom,
                                             &tmp
                                             ) ) {

                            *ppszAdministrator = (PWSTR)LocalAlloc(LPTR, (dwSize+dwSizeDom+2)*sizeof(WCHAR));

                            if ( *ppszAdministrator ) {

                                //
                                // the name to return is a fully qualified name such as Domain\Administrator
                                //
                                // This is a safe usage.
                                wcscpy(*ppszAdministrator, dummyBuf);
                                wcscat(*ppszAdministrator, L"\\");
                                wcscat(*ppszAdministrator, dummy2);

                                bError = FALSE;
                            }
                        }
                    }
                }

                LocalFree(pSid);
                pSid = NULL;
            }

            LocalFree(dummyBuf);
            dummyBuf = NULL;

            LocalFree(dummy2);
            dummy2 = NULL;

            LocalFree(pDomSid);
        }

        if (bError) {

            //
            // anything fail will free all buffers and return FALSE
            //
            LocalFree(*ppszAdministrator);
            *ppszAdministrator = NULL;

            if ( ppszAdmins ) {

                LocalFree(*ppszAdmins);
                *ppszAdmins = NULL;
            }

            if ( ppszAuthUsers ) {

                LocalFree(*ppszAuthUsers);
                *ppszAuthUsers = NULL;
            }

            if ( ppszEveryone ) {
                LocalFree(*ppszEveryone);
                *ppszEveryone = NULL;
            }
            return FALSE;
        }

    }

    return TRUE;

}

PSID
WseceditpGetAccountDomainSid(
    )
{

    NTSTATUS Status;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;

    PSID DomainSid=NULL;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            (PLSA_OBJECT_ATTRIBUTES)&PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)&PolicyAccountDomainInfo );

        if ( NT_SUCCESS(Status) ) {

            DWORD Len = GetLengthSid(PolicyAccountDomainInfo->DomainSid);

            DomainSid = (PSID)LocalAlloc(LPTR, Len );

            if ( DomainSid ) {

                //This is not a safe usage. Status should be STATUS_SUCCESS for LsaQueryInformationPolicy and LsaOpenPolicy.
                //Status should be nonzero for CopySid. Raid #552428.
                Status = CopySid( Len, DomainSid, PolicyAccountDomainInfo->DomainSid );

                if ( !NT_SUCCESS(Status) ) {
                    LocalFree(DomainSid);
                    DomainSid = NULL;
                }
            }

            LsaFreeMemory(PolicyAccountDomainInfo);

        }

        LsaClose( PolicyHandle );

    }

    return(DomainSid);
}


void CConfigPrivs::OnSelChange() //Raid #466634, Yang Gao
{
   CWnd* pwnd = this->GetDlgItem(IDC_REMOVE);
   if( pwnd )
   {
       if( m_lbGrant.GetSelCount() == 0 //Raid #476305, yanggao, for multi select listbox.
			|| QueryReadOnly () )		// Raid# 697665 bryanwal. Listbox must enable to 
										// view all items, but clicking it shouldn't enable
										// "Remove"
       {
           if( pwnd->IsWindowEnabled() )
               pwnd->EnableWindow(FALSE);
       }
       else
       {
           if( !pwnd->IsWindowEnabled() )
               pwnd->EnableWindow(TRUE);
       }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       dataobj.cpp
//
//  Contents:   Implementation of data object class
//
//  History:
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "DataObj.h"
#include <sceattch.h>

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
UINT CDataObject::m_cfNodeType               = RegisterClipboardFormat(CCF_NODETYPE);
UINT CDataObject::m_cfNodeTypeString         = RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CDataObject::m_cfNodeID                 = RegisterClipboardFormat(CCF_NODEID2);

UINT CDataObject::m_cfDisplayName            = RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CDataObject::m_cfSnapinClassID          = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
UINT CDataObject::m_cfInternal               = RegisterClipboardFormat(SNAPIN_INTERNAL);

UINT CDataObject::m_cfSceSvcAttachment       = RegisterClipboardFormat(CCF_SCESVC_ATTACHMENT);
UINT CDataObject::m_cfSceSvcAttachmentData   = RegisterClipboardFormat(CCF_SCESVC_ATTACHMENT_DATA);
UINT CDataObject::m_cfModeType               = RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
UINT CDataObject::m_cfGPTUnknown             = RegisterClipboardFormat(CCF_SCE_GPT_UNKNOWN);
UINT CDataObject::m_cfRSOPUnknown            = RegisterClipboardFormat(CCF_SCE_RSOP_UNKNOWN);
UINT CDataObject::m_cfMultiSelect            = ::RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the requested data
//
//  History:
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetDataHere(LPFORMATETC lpFormatetc,  // In
                         LPSTGMEDIUM lpMedium)     // In
{
   HRESULT hr = DV_E_CLIPFORMAT;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpFormatetc)
      return E_INVALIDARG;
   
   //
   // Based on the CLIPFORMAT, write data to the stream
   //
   const CLIPFORMAT cf = lpFormatetc->cfFormat;

   if (cf == m_cfNodeType)
      hr = CreateNodeTypeData(lpMedium);
   else if (cf == m_cfNodeTypeString)
      hr = CreateNodeTypeStringData(lpMedium);
   else if (cf == m_cfDisplayName)
      hr = CreateDisplayName(lpMedium);
   else if (cf == m_cfSnapinClassID)
      hr = CreateSnapinClassID(lpMedium);
   else if (cf == m_cfInternal)
      hr = CreateInternal(lpMedium);
   else if (cf == m_cfSceSvcAttachment)
      hr = CreateSvcAttachment(lpMedium);
   else if (cf == m_cfSceSvcAttachmentData)
      hr = CreateSvcAttachmentData(lpMedium);
   else if (cf == m_cfModeType)
      hr = CreateModeType(lpMedium);
   else if (cf == m_cfGPTUnknown)
      hr = CreateGPTUnknown(lpMedium);
   else if (cf == m_cfRSOPUnknown)
      hr = CreateRSOPUnknown(lpMedium);

   return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetData
//
//  Synopsis:   Support for mutli select is added.  First return the mutli
//              select GUID information if that is what we are being called for.
//              The else if copies the actual mutli-select information.
//
//              The function will only copy the mutli select information if
//              the FORMATEETC.cfFormat == CDataObject::m_cfInternal and
//              FORMATETC.tymed == TYMED_HGLOBAL.
//
//  History:    1-14-1999 - a-mthoge
//
//---------------------------------------------------------------------------
STDMETHODIMP
CDataObject::GetData(LPFORMATETC lpFormatetcIn,
                     LPSTGMEDIUM lpMedium)
{
   HRESULT hRet = S_OK;

   if (NULL == lpFormatetcIn ||
       NULL == lpMedium) 
   {
      return E_POINTER;
   }

   if(lpFormatetcIn->cfFormat == m_cfMultiSelect &&
      lpFormatetcIn->tymed    == TYMED_HGLOBAL &&
      m_nInternalArray )
   {
      //
      // Need to create a SSMCObjectTypes structure and return this
      // to MMC for mutli select.
      //
      // we only support result items created by SCE.
      //
      lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(DWORD) + sizeof(GUID) );
      if(!lpMedium->hGlobal)
         return E_FAIL;

      //
      // Set count and GUID to 1.
      //
      SMMCObjectTypes *pTypes = (SMMCObjectTypes *)GlobalLock(lpMedium->hGlobal);
      pTypes->count = 1;
      //This is a safe usage. yanggao.
      memcpy( &(pTypes->guid), &m_internal.m_clsid, sizeof(GUID));

      GlobalUnlock(lpMedium->hGlobal);
      return S_OK;
   } 
   else if(lpFormatetcIn->cfFormat == m_cfInternal &&
      lpFormatetcIn->tymed    == TYMED_HGLOBAL &&
      m_nInternalArray )
   {
      //
      // Copy the contents of the mutli select to STGMEDIUM
      //
      lpMedium->hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(INTERNAL) * (m_nInternalArray + 1));
      if(!lpMedium->hGlobal)
         return E_FAIL;

      //
      // The first element in the array is set to
      // MMC_MUTLI_SELECT_COOKIE and the type is set the count of items after the
      // first structure.
      //
      INTERNAL *pInternal = (INTERNAL *)GlobalLock( lpMedium->hGlobal );

      pInternal->m_cookie = (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE;
      pInternal->m_type   = (DATA_OBJECT_TYPES)m_nInternalArray;

      //
      // Copy the rest of the INTERNAL structures to this array.
      //
      pInternal++;
      //This is a safe usage.
      memcpy(pInternal, m_pInternalArray, sizeof(INTERNAL) * m_nInternalArray);
   } 
   else if (lpFormatetcIn->cfFormat == m_cfNodeID &&
              lpFormatetcIn->tymed    == TYMED_HGLOBAL ) 
   {
      return CreateNodeId(lpMedium);
   }
   return hRet;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:
//
//---------------------------------------------------------------------------
STDMETHODIMP
CDataObject::EnumFormatEtc(DWORD dwDirection,
                           LPENUMFORMATETC*
                           ppEnumFormatEtc)
{
   return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [lpMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::Create(const void* pBuffer,
                    int len,
                    LPSTGMEDIUM lpMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (lpMedium->tymed == TYMED_HGLOBAL) 
   {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream;
      hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

      if (SUCCEEDED(hr)) 
      {
         //
         // Write to the stream the number of bytes
         //
         ULONG written;
         hr = lpStream->Write(pBuffer, len, &written);

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with our node type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
   const GUID *pNodeType;
   //
   // Create the node type object in GUID format
   //

    switch (m_internal.m_foldertype) 
    {
     case LOCALPOL:
        pNodeType = &cNodetypeSceTemplate;
        break;
     
     case PROFILE:
        if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) ||
             ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) ) 
        {
           pNodeType = &cNodetypeSceTemplate;
        } 
        else 
        {
           // other areas aren't extensible on this node
           // return our generic node type
           pNodeType = &cSCENodeType;
        }
        break;

     case AREA_SERVICE_ANALYSIS:
        pNodeType = &cNodetypeSceAnalysisServices;
        break;

     case AREA_SERVICE:
        pNodeType = &cNodetypeSceTemplateServices;
        break;

     default:
        if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
            pNodeType = &cNodeType;
        else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
           pNodeType = &cRSOPNodeType;
        else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
            pNodeType = &cSAVNodeType;
        else
            pNodeType = &cSCENodeType;
        break;
    }

   return Create(reinterpret_cast<const void*>(pNodeType), sizeof(GUID), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeStringData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the string representation
//              of our node type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
   //
   // Create the node type object in GUID string format
   //
   LPCTSTR pszNodeType;

    switch (m_internal.m_foldertype) 
    {
     case AREA_SERVICE_ANALYSIS:
        pszNodeType = lstruuidNodetypeSceAnalysisServices;
        break;

     case AREA_SERVICE:
        pszNodeType = lstruuidNodetypeSceTemplateServices;
        break;

     case LOCALPOL:
        pszNodeType = lstruuidNodetypeSceTemplate;
        break;

     case PROFILE:
       if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
          pszNodeType = lstruuidNodetypeSceTemplate;
       else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
          pszNodeType = lstruuidNodetypeSceTemplate;
       else 
       {
          // other snapin types do not allow extensions on this level
          // return our generic node type
          pszNodeType = cszSCENodeType;
       }
       break;

     default:
         if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
             pszNodeType = cszNodeType;
         else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
            pszNodeType = cszRSOPNodeType;
         else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
             pszNodeType = cszSAVNodeType;
         else
             pszNodeType = cszSCENodeType;
        break;
    }

   return Create(pszNodeType, ((wcslen(pszNodeType)+1) * sizeof(WCHAR)), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeID
//
//  Synopsis:   Create an hGlobal in [lpMedium] with our node ID
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CDataObject::CreateNodeId(LPSTGMEDIUM lpMedium)
{
   SNodeID2 *nodeID = NULL;
   BYTE *id = NULL;
   DWORD dwIDSize = 0;
   DWORD dwIDNameSize = 0;
   LPTSTR szNodeName = NULL;
   CFolder *pFolder = NULL;
   LPTSTR szMedium = NULL;
   //
   // Create the node type object in GUID format
   //


   switch (m_internal.m_foldertype) 
   {
      case LOCATIONS:
      case PROFILE:
      case REG_OBJECTS:
      case FILE_OBJECTS:
         //
         // There can be many nodes of these types and they will be
         // locked to the system so just use the display name
         //
         if (m_internal.m_cookie) 
         {
            pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
            szNodeName = pFolder->GetName();
            if( szNodeName == NULL) //Raid 553113, yanggao
               return E_FAIL;
            dwIDNameSize = (lstrlen(szNodeName)+1)*sizeof(TCHAR);
            dwIDSize = sizeof(SNodeID2)+dwIDNameSize;
            lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE,dwIDSize);
            if(!lpMedium->hGlobal)
               return STG_E_MEDIUMFULL;
            
            nodeID = (SNodeID2 *)GlobalLock(lpMedium->hGlobal);
            //This is not a safe usage. Need to GlobalUnlock lpMedium->hGlobal, validate szNodeName. Raid 553113. yanggao.
            if( nodeID )
            {
               nodeID->dwFlags = 0;
               nodeID->cBytes = dwIDNameSize;
               memcpy(nodeID->id,szNodeName,dwIDNameSize);
               GlobalUnlock(lpMedium->hGlobal);
            }
            else
            {
               GlobalFree(lpMedium->hGlobal);
               return STG_E_MEDIUMFULL;
            }
         } 
         else
            return E_FAIL;
         break;

      default:
         //
         // Everything else is unique: there's one and only one node
         // of the type per snapin.
         //
         dwIDSize = sizeof(FOLDER_TYPES)+sizeof(SNodeID2);
         lpMedium->hGlobal = GlobalAlloc(GMEM_SHARE,dwIDSize);
         if(!lpMedium->hGlobal)
            return STG_E_MEDIUMFULL;
         
         nodeID = (SNodeID2 *)GlobalLock(lpMedium->hGlobal);
         nodeID->dwFlags = 0;
         nodeID->cBytes = sizeof(FOLDER_TYPES);
         //This is a safe usage. yanggao.
         memcpy(nodeID->id,&(m_internal.m_foldertype),sizeof(FOLDER_TYPES));
         GlobalUnlock(lpMedium->hGlobal);
         break;
   }
   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateNodeTypeData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's display name,
//              which will differ depending on where it's being viewed from
//              as reported by the mode bits
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
   //
   // This is the display named used in the scope pane and snap-in manager
   //

   //
   // Load the name from resource
   // Note - if this is not provided, the console will used the snap-in name
   //

   CString szDispName;

   if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SAVSnapin) )
      szDispName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_SCESnapin) )
      szDispName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_LSSnapin) )
      szDispName.LoadString(IDS_LOCAL_SECURITY_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_Snapin) )
      szDispName.LoadString(IDS_EXTENSION_NAME);
   else if ( ::IsEqualGUID(m_internal.m_clsid, CLSID_RSOPSnapin) )
      szDispName.LoadString(IDS_EXTENSION_NAME);
   else
      szDispName.LoadString(IDS_NODENAME);

/*  // can't depend on m_ModeBits because it's not set yet
   if (m_ModeBits & MB_ANALYSIS_VIEWER) {
      szDispName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
   } else if (m_ModeBits & MB_TEMPLATE_EDITOR) {
      szDispName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
   } else if ( (m_ModeBits & MB_NO_NATIVE_NODES) ||
              (m_ModeBits & MB_SINGLE_TEMPLATE_ONLY) ) {
      szDispName.LoadString(IDS_EXTENSION_NAME);
   } else {
      szDispName.LoadString(IDS_NODENAME);
   }
*/
   return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSnapinClassID
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's class ID
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSnapinClassID(LPSTGMEDIUM lpMedium)
{
   //
   // Create the snapin classid in CLSID format
   //
   return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateInternal
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with SCE's internal data type
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
   return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::AddInternal
//
//  Synopsis:   Adds an INTERNAL object to the array of internal objects.
//
//  History:    1-14-1999  a-mthoge
//
//---------------------------------------------------------------------------
void CDataObject::AddInternal( MMC_COOKIE cookie, DATA_OBJECT_TYPES  type)
{
   //
   // Allocate memory for one more internal array.
   INTERNAL *hNew = (INTERNAL *)LocalAlloc( 0, sizeof(INTERNAL) * (m_nInternalArray + 1) );
   if(!hNew)
      return;
   
   m_nInternalArray++;

   //
   // Copy other internal array information.
   //
   if( m_pInternalArray )
   {
      //This is a safe usage.
      memcpy(hNew, m_pInternalArray, sizeof(INTERNAL) * (m_nInternalArray - 1) );
      LocalFree( m_pInternalArray );
   }

   //
   // Set the new internal array members.
   //
   hNew[ m_nInternalArray - 1].m_cookie = cookie;
   hNew[ m_nInternalArray - 1].m_type   = type;

   //
   // Set the CObjectData internal array pointer.
   //
   m_pInternalArray = hNew;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSvcAttachment
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the name of the inf
//              template a service attachment should modify or with an empty
//              string for the inf-templateless analysis section
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSvcAttachment(LPSTGMEDIUM lpMedium)
{
   LPCTSTR sz = 0;

   if ((AREA_SERVICE == m_internal.m_foldertype) ||
       (AREA_SERVICE_ANALYSIS == m_internal.m_foldertype)) 
   {
      CFolder *pFolder = reinterpret_cast<CFolder *>(m_internal.m_cookie);
      if (pFolder) 
      {
         sz = pFolder->GetInfFile();
         if (sz) 
            return Create(sz,(lstrlen(sz)+1)*sizeof(TCHAR),lpMedium);
         else
            return E_FAIL;
      } 
      else
         return E_FAIL;
   }

   //
   // This shouldn't be asked for except in the SERVICE areas
   //
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateSvcAttachmentData
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to the
//              ISceSvcAttachmentData interface that an attachment should use
//              to communicate with SCE
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateSvcAttachmentData(LPSTGMEDIUM lpMedium)
{
   if ((AREA_SERVICE == m_internal.m_foldertype) ||
       (AREA_SERVICE_ANALYSIS == m_internal.m_foldertype)) 
   {
      return Create(&m_pSceSvcAttachmentData,sizeof(m_pSceSvcAttachmentData),lpMedium);
   }

   //
   // This shouldn't be asked for except in the SERVICE areas
   //
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateModeType
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with the Mode that SCE was
//              started in
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateModeType(LPSTGMEDIUM lpMedium)
{
   DWORD mode = m_Mode;
   if (mode == SCE_MODE_DOMAIN_COMPUTER_ERROR)
      mode = SCE_MODE_DOMAIN_COMPUTER;
   
   return Create(&mode,sizeof(DWORD),lpMedium);
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateGPTUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to GPT's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateGPTUnknown(LPSTGMEDIUM lpMedium)
{
   LPUNKNOWN pUnk = 0;

   if (!m_pGPTInfo) 
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   HRESULT hr = m_pGPTInfo->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&pUnk));
   if (SUCCEEDED(hr))
      return Create(&pUnk,sizeof(pUnk),lpMedium);
   else
      return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateRSOPUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to RSOP's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CDataObject::CreateRSOPUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = E_FAIL;
   LPUNKNOWN pUnk = NULL;

   if (!m_pRSOPInfo) 
   {
      //
      // If we don't have a pointer to a RSOP interface then we must not
      // be in a mode where we're extending RSOP and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pRSOPInfo->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&pUnk));
   if (SUCCEEDED(hr))
      return Create(&pUnk,sizeof(pUnk),lpMedium);
   else
      return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cservice.h
//
//  Contents:   definition of CConfigService
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

PSCE_SERVICES
CreateServiceNode(LPTSTR ServiceName,
                  LPTSTR DisplayName,
                  DWORD Startup,
                  PSECURITY_DESCRIPTOR pSD,
                  SECURITY_INFORMATION SeInfo);

/////////////////////////////////////////////////////////////////////////////
// CConfigService dialog

class CConfigService : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    virtual void SetInitialValue(DWORD_PTR dw) {};
    CConfigService(UINT nTemplateID);   // standard constructor


// Dialog Data
    //{{AFX_DATA(CConfigService)
    enum { IDD = IDD_CONFIG_SERVICE };
    int     m_nStartupRadio;
    CButton m_bPermission;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigService)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigService)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfigure();
    afx_msg void OnChangeSecurity();
	afx_msg void OnDisabled();
	afx_msg void OnIgnore();
	afx_msg void OnEnabled();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
   virtual void EnableUserControls( BOOL bEnable );

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    HWND m_hwndSecurity;
    BOOL m_bOriginalConfigure;   

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\ddwarn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ddwarn.h
//
//  Contents:   definition of CDlgDependencyWarn
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_)
#define AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn dialog
//
// DPCHECK_OPERATOR tells how to compare the values.
//
enum DPCHECK_OPERATOR
{
   DPCHECK_CONFIGURED   = 1,     // The dependent item must be configured.
                                 // A default value must be specifide for the suggested item.
   DPCHECK_NOTCONFIGURED,        // The dependent item must be not configured,
                                 // (only valid if the item itsel if not configured).
   DPCHECK_LESSEQUAL,            // The dependent item must be less than or equal.
   DPCHECK_LESS,                 // The dependent item must be less than.
   DPCHECK_GREATEREQUAL,         // The dependent item must be greater than or eqaul.
   DPCHECK_GREATER,              // The dependent item must be greater.
                                 
                                 //The next two case are special cases for retention Method
   
   DPCHECK_RETENTION_METHOD_CONFIGURED,       // The dependent item must be configured
   DPCHECK_RETENTION_METHOD_NOTCONFIGURED,    // The dependent item must not be configured
                                 
                                       //The next two case are special cases for Retain *** Log for
   DPCHECK_RETAIN_FOR_CONFIGURED,      //The dependent item must be configured
   DPCHECK_RETAIN_FOR_NOTCONFIGURED,   //The dependent item must not be configured
};

//
// Flags for Depenecy checking.
//                                 value is set to the items value.
// DPCHECK_VALIDFOR_NC           - The test is valid for not configured [uDepends] items,
//                                 by default checks are not valid for not configured items.
// DPCHECK_FOREVER               - The item can be configured for FOREVER
// DPCHECK_NEVER                 - Treat configured to never (0) as not configured
// DPCHECK_INVERSE               - Conversion is done by devision not multiplication.
//                                 seconds - days would be an inverse where
//
#define DPCHECK_VALIDFOR_NC      0x10000000
#define DPCHECK_FOREVER          0x20000000
#define DPCHECK_INVERSE          0x40000000
#define DPCHECK_NEVER            0x80000000

//
// Used for creating a dependency list.  For it to work correctly you must
// create the list so that
// uID               - is a valid ID for the result item you are checking
// uDepends          - is a valid ID for a result item in the same Folder.
// uDependencyCount  - is the total dependencies for this item.
// uDefault          - Only used if uOpFlags has DPCHECK_CONFIGURED
// uOpFlags          - The test you want to perform and any other special flags.
//                     The low order word is the operation to perform.
//                     The high order word is used for special flags.
//
typedef struct _tag_DEPENDENCYLIST
{
   UINT uID;                     // The ID we are checking
   UINT uDepends;                // The ID of the dependent item.
   UINT uDependencyCount;        // The number of sequential dependencies.
   UINT uDefault;                // The default value to use if there are no good values.
   UINT uConversion;             // Conversion number.  The dependent values are converted
                                 // items value.
   UINT uOpFlags;                // What kind of check to perfrom and other flags.
} DEPENDENCYLIST, *PDEPENDENCYLIST;


//
// Min max information for the dependency checks.
//
typedef struct _tag_DEPENDENCYMINMAX
{
   UINT uID;                     // The ID of the item.
   UINT uMin;                    // Minimum value.
   UINT uMax;                    // Maximum value.
   UINT uInc;                    // Increment value.
} DEPENDENCYMINMAX, *PDEPENDENCYMINMAX;

//
// This structure will be created by the Dependency check, The caller can
// enumerate through the dialog failed list to see which items failed.
// The [dwSuggested] member will be set to the value that should be set for the
// [pResult] item.
// GetFailedCount()     - Returns number of items that failed the dependency check
// GetFailedInfo(int i) - Returns a pointer to this structure.
//
typedef struct _tag_DEPENDENCYFAILED
{
   const DEPENDENCYLIST *pList;  // The attributes of the item
   CResult *pResult;             // The CResult associated with this item.
   LONG_PTR dwSuggested;         // The suggested setting for this value.

}DEPENDENCYFAILED, *PDEPENDENCYFAILED;


///////////////////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn Class declaration.
// Usage:   First call CheckDendencies with some valid values.  If CheckDendencies returns
// ERROR_MORE_DATA, then [m_aFailedList] has failed items.  If you want to display the
// information to the user you can call DoModal() for the dialog box.  DoModal will return
// IDOK if the user presses 'Auto set' or IDCANCEL if the user presses Cancel.  You
// can then enumerate through the failed list through a for loop with the count of
// dependecies returned by GetFailedCount(), then get each failed item by calling
// GetFailedInfo() which returns a PDEPENDENCYFAILED item.
//
class CDlgDependencyWarn : public CHelpDialog
{
// Construction
public:
   CDlgDependencyWarn(CWnd* pParent = NULL);    // standard constructor
   virtual ~CDlgDependencyWarn();                       // Destructor

   DWORD
   InitializeDependencies(
      CSnapin *pSnapin,    // The snapin who owns the CResult item.
      CResult *pResult,    // The CResult item we are checking
      PDEPENDENCYLIST pList = NULL,
      int iCount = 0
   );

   DWORD
   CheckDependencies(
      DWORD dwValue        // The value we are checking.
      );

   CResult *
   GetResultItem(
      CResult *pBase,      // Need this to find the CFolder container
      UINT uID             // The ID to search for.
      );

   const PDEPENDENCYFAILED
   GetFailedInfo(int i)    // Get a specifide failed dependcies.
      { return m_aFailedList[i]; };
   int
   GetFailedCount()        //
      { return (int)m_aFailedList.GetSize(); };

   BOOL
   GetResultItemString(
      CString &str,
      int iCol,
      CResult *pResult,
      LONG_PTR dwValue  =  NULL
      );
// Dialog Data
   //{{AFX_DATA(CDlgDependencyWarn)
   enum { IDD = IDD_WARNING_DIALOG };
      // NOTE: the ClassWizard will add data members here
   //}}AFX_DATA



// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CDlgDependencyWarn)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CDlgDependencyWarn)
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   WTL::CImageList m_imgList;
   CTypedPtrArray< CPtrArray, PDEPENDENCYFAILED> m_aFailedList;
   CTypedPtrArray< CPtrArray, CResult *> m_aDependsList;
   LONG_PTR m_dwValue;
   CResult *m_pResult;
   CSnapin *m_pSnapin;
   PDEPENDENCYLIST m_pList;
   int m_iCount;

public:
   static DEPENDENCYMINMAX m_aMinMaxInfo[];
   static const DEPENDENCYMINMAX *LookupMinMaxInfo(UINT uID);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DDWARN_H__A405CAFD_800F_11D2_812B_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


#include "stdafx.h"  // Added by ClassView
class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
   COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() { m_pSceSvcAttachmentData = NULL;
                    m_ModeBits = 0;
                    m_Mode = 0;
                    m_nInternalArray = 0;
                    m_pInternalArray = NULL;

                    m_pGPTInfo = NULL;
                    m_pRSOPInfo = NULL;
                  };
    virtual ~CDataObject(){
                    if( m_pInternalArray ){
                       GlobalFree(m_pInternalArray );
                    }
                  };

// Clipboard formats that are required by the console
public:
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;
    static UINT    m_cfDisplayName;
    static UINT    m_cfSnapinClassID;
    static UINT    m_cfInternal;
    static UINT    m_cfSceSvcAttachment;
    static UINT    m_cfSceSvcAttachmentData;
    static UINT    m_cfModeType;
    static UINT    m_cfGPTUnknown;
    static UINT    m_cfRSOPUnknown;
    static UINT    m_cfMultiSelect;
    static UINT    m_cfNodeID;

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
   void SetModeBits(DWORD mode) 
   { 
	   m_ModeBits = mode; 
   }
   void SetMode(DWORD mode) { m_Mode = mode; }
   void SetType(DATA_OBJECT_TYPES type) // Step 3
   { 
      ASSERT(m_internal.m_type == CCT_UNINITIALIZED); //Bogus Assert, yanggao.
      m_internal.m_type = type; 
   }

   void SetFolderType(FOLDER_TYPES foldertype) 
   { 
      m_internal.m_foldertype = foldertype; 
   }
   void SetCookie(MMC_COOKIE cookie) 
   { 
      m_internal.m_cookie = cookie; 
   } // Step 3
   void SetClsid(const CLSID& clsid) 
   { 
      m_internal.m_clsid = clsid; 
   }
   void SetSceSvcAttachmentData(LPSCESVCATTACHMENTDATA pData) 
   { 
      m_pSceSvcAttachmentData = pData; 
   }
   void AddInternal( MMC_COOKIE cookie, DATA_OBJECT_TYPES  type);

   void SetGPTInfo(LPGPEINFORMATION pGPTInfo) 
   { 
      m_pGPTInfo = pGPTInfo; 
   }
   void SetRSOPInfo(LPRSOPINFORMATION pRSOPInfo) 
   { 
      m_pRSOPInfo = pRSOPInfo; 
   }

private:
   HRESULT CreateSvcAttachmentData(LPSTGMEDIUM lpMedium);
   HRESULT CreateSvcAttachment(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeId(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
   HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
   HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
   HRESULT CreateSnapinClassID(LPSTGMEDIUM lpMedium);
   HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3
   HRESULT CreateModeType(LPSTGMEDIUM lpMedium);
   HRESULT CreateGPTUnknown(LPSTGMEDIUM lpMedium);
   HRESULT CreateRSOPUnknown(LPSTGMEDIUM lpMedium);

   HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
   INTERNAL m_internal;    // Step 3
   INTERNAL *m_pInternalArray;
   int m_nInternalArray;

   LPSCESVCATTACHMENTDATA m_pSceSvcAttachmentData;
   DWORD m_ModeBits;
   DWORD m_Mode;
   LPGPEINFORMATION m_pGPTInfo;
   LPRSOPINFORMATION m_pRSOPInfo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\defaults.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       defaults.h
//
//----------------------------------------------------------------------------
#ifndef __SECMGR_DEFAULTS__
#define __SECMGR_DEFAULTS__

#define RNH_AUTODISCONNECT_NAME  L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\AutoDisconnect"
#define RNH_AUTODISCONNECT_LOW   1
#define RNH_AUTODISCONNECT_HIGH  99999
#define RNH_AUTODISCONNECT_FLAGS DW_VALUE_FOREVER | DW_VALUE_NOZERO
#define RNH_AUTODISCONNECT_SPECIAL_STRING IDS_RNH_AUTODISCONNECT_SPECIAL
#define RNH_AUTODISCONNECT_STATIC_STRING IDS_RNH_AUTODISCONNECT_STATIC

#define RNH_CACHED_LOGONS_NAME L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CachedLogonsCount"
#define RNH_CACHED_LOGONS_LOW 0
#define RNH_CACHED_LOGONS_HIGH 50
#define RNH_CACHED_LOGONS_FLAGS DW_VALUE_NEVER
#define RNH_CACHED_LOGONS_SPECIAL_STRING IDS_RNH_CACHED_LOGONS_SPECIAL
#define RNH_CACHED_LOGONS_STATIC_STRING IDS_RNH_CACHED_LOGONS_STATIC

#define RNH_PASSWORD_WARNINGS_NAME L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PasswordExpiryWarning"
#define RNH_PASSWORD_WARNINGS_LOW 0
#define RNH_PASSWORD_WARNINGS_HIGH 999
#define RNH_PASSWORD_WARNINGS_FLAGS 0
#define RNH_PASSWORD_WARNINGS_SPECIAL_STRING 0
#define RNH_PASSWORD_WARNINGS_STATIC_STRING IDS_RNH_PASSWORD_WARNINGS_STATIC

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\dattrs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       dattrs.h
//
//  Contents:   definition of CDomainRet, CDomainAudit, CDomainEnable, 
//              CDomainChoice, CDomainRegFlags, CDomainGroup, CDomainName,
//              CDomainNumber, CDomainObject, CDomainPrivs, CDomainService,
//              CDomainRegNumber, CDomainRegString, CDomainRegEnable
//                              
//----------------------------------------------------------------------------
#if !defined DATTRS_H
#define DATTRS_H

#include "cret.h"
#include "cchoice.h"
#include "cflags.h"
#include "cgroup.h"
#include "cnumber.h"
#include "cname.h"
#include "cobject.h"
#include "cprivs.h"
#include "cservice.h"
#include "Caudit.h"
#include "cenable.h"
#include "regvldlg.h"


/*
 * CDomain* dialogs are copies of the CConfig* dialogs
 * except with a different dialog resource.
 *
 * Inherit all behaviour except for the resource
 */


class CDomainRet : public CConfigRet
{
public:
   enum { IDD =IDD_DOMAIN_RET };
   CDomainRet() : 
   CConfigRet(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainAudit : public CConfigAudit
{
public:
   enum { IDD =IDD_DOMAIN_AUDIT };
   CDomainAudit() : 
   CConfigAudit(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainEnable : public CConfigEnable
{
public:
   enum { IDD =IDD_DOMAIN_ENABLE };
   CDomainEnable() : 
   CConfigEnable(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainChoice : public CConfigChoice
{
public:
   enum { IDD =IDD_DOMAIN_REGCHOICES };
   CDomainChoice() : CConfigChoice(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegFlags : public CConfigRegFlags
{
public:
   enum { IDD =IDD_DOMAIN_REGFLAGS };
   CDomainRegFlags() : CConfigRegFlags(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainGroup : public CConfigGroup
{
public:
   enum { IDD =IDD_DOMAIN_MEMBERSHIP };
   CDomainGroup() : CConfigGroup(IDD)
   {
       m_uTemplateResID = IDD;
   }

   virtual BOOL OnInitDialog()
   {
      CConfigGroup::OnInitDialog ();

      if ( m_bReadOnly )
      {
         GetDlgItem (IDC_ADD_MEMBER)->EnableWindow (FALSE);
         GetDlgItem (IDC_REMOVE_MEMBER)->EnableWindow (FALSE);
         GetDlgItem (IDC_ADD_MEMBEROF)->EnableWindow (FALSE);
         GetDlgItem (IDC_REMOVE_MEMBEROF)->EnableWindow (FALSE);
      }

      return TRUE;
   }
};

class CDomainName : public CConfigName
{
public:
   enum { IDD =IDD_DOMAIN_NAME };
   CDomainName() : CConfigName(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual ~CDomainName ()
   {
   }
};

class CDomainNumber : public CConfigNumber
{
public:
   enum { IDD =IDD_DOMAIN_NUMBER };
   CDomainNumber() : CConfigNumber(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainObject : public CConfigObject
{
public:
   enum { IDD =IDD_DOMAIN_OBJECT };
   CDomainObject() : CConfigObject(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainPrivs : public CConfigPrivs
{
public:
   enum { IDD =IDD_DOMAIN_PRIVS };
   CDomainPrivs() : CConfigPrivs(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainService : public CConfigService
{
public:
   enum { IDD =IDD_DOMAIN_SERVICE };
   CDomainService() : CConfigService(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegNumber : public CConfigRegNumber
{
public:
   enum { IDD =IDD_DOMAIN_NUMBER };
   CDomainRegNumber() : CConfigRegNumber(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegString : public CConfigRegString
{
public:
   enum { IDD =IDD_DOMAIN_NAME };
   CDomainRegString(UINT nTemplateID) : //Raid #381309, 4/31/2001
        CConfigRegString(nTemplateID ? nTemplateID : IDD)
   {
       m_uTemplateResID = IDD;
   }
};

class CDomainRegEnable : public CConfigRegEnable
{
public:
   enum { IDD =IDD_DOMAIN_ENABLE };
   CDomainRegEnable() : 
   CConfigRegEnable(IDD)
   {
       m_uTemplateResID = IDD;
   }
};

#endif // DATTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\ddwarn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ddwarn.cpp
//
//  Contents:   implementation of CDlgDependencyWarn
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "snapmgr.h"
#include "cookie.h"
#include "DDWarn.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn dialog

CDlgDependencyWarn::CDlgDependencyWarn(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a238HelpIDs, IDD, pParent)
{
   m_pResult = NULL;
   m_dwValue = SCE_NO_VALUE;
   //{{AFX_DATA_INIT(CDlgDependencyWarn)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

CDlgDependencyWarn::~CDlgDependencyWarn()
{
   for(int iCheck = 0; iCheck < m_aFailedList.GetSize(); iCheck++){
      if(m_aFailedList[iCheck]){
         LocalFree(m_aFailedList[iCheck]);
      }
   }
   m_aFailedList.RemoveAll();

   for(int iCheck = 0; iCheck < m_aDependsList.GetSize(); iCheck++){
      if(m_aDependsList[iCheck]){
         m_aDependsList[iCheck]->Release();
      }
   }
   m_aDependsList.RemoveAll();
}

void CDlgDependencyWarn::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgDependencyWarn)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}

//////////////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn::m_aMinMaxInfo
// Min max info for items.
//////////////////////////////////////////////////////////////////////////////////////
DEPENDENCYMINMAX CDlgDependencyWarn::m_aMinMaxInfo [] =
{
   // ID                   // Min value   // Max Value   // Increment by //Flags
   { IDS_LOCK_DURATION,    1,              99999,        1},
   { IDS_MIN_PAS_AGE,      0,              998,          1},
   { IDS_MAX_PAS_AGE,      0,              999,          1},
   { IDS_LOCK_COUNT,       0,              999,          1},
   { IDS_MIN_PAS_LEN,      0,              14,           1},
   { IDS_PAS_UNIQUENESS,   0,              24,           1},
   { IDS_LOCK_RESET_COUNT, 1,              99999,        1},
   { IDS_SYS_LOG_MAX,      64,             4194240,      64},
   { IDS_SEC_LOG_MAX,      64,             4194240,      64},
   { IDS_APP_LOG_MAX,      64,             4194240,      64},
   { IDS_SYS_LOG_DAYS,     1,              365,          1},
   { IDS_SEC_LOG_DAYS,     1,              365,          1},
   { IDS_APP_LOG_DAYS,     1,              365,          1},
   { IDS_KERBEROS_MAX_AGE, 1,              99999,        1},
   { IDS_KERBEROS_RENEWAL, 1,              99999,        1},
   { IDS_KERBEROS_MAX_SERVICE, 10,         99999,        1},
   { IDS_KERBEROS_MAX_CLOCK, 0,            99999,        1}
};

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::GetMinMaxInfo
//
// Returns the row which contains the [uID]
//
// Arguments:  [uID] - The ID to search for.
//
// Returns:    A row pointer or NULL if the ID is not contained in the table.
//-------------------------------------------------------------------------------------
const DEPENDENCYMINMAX *
CDlgDependencyWarn::LookupMinMaxInfo(UINT uID)
{
   int nSize = sizeof(m_aMinMaxInfo)/sizeof(DEPENDENCYMINMAX);
   for(int i = 0; i < nSize; i++){
      if(m_aMinMaxInfo[i].uID == uID){
         return &(m_aMinMaxInfo[i]);
      }
   }
   return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////
// The dependency list.
// The ID defines what we are checking.
// The Dependent IDS are the items the item is dependent on.
// Count       -  The number of dependencies.
// Default     -  The default value for the item if no other values can be used.
//                This is only used if the Item must be configured and it is not.
// Conversion  -  What units the item must be converted to before performing the check.
// Operator    -
//////////////////////////////////////////////////////////////////////////////////////
DEPENDENCYLIST g_aDList [] =
{
      // ID                // Depend ID         //Count/Default/Conversion  //Check type
   //
   // Password reset count <= password Lock duratio, and Password lock count must be
   // configured.
   //
   { IDS_LOCK_RESET_COUNT, IDS_LOCK_DURATION,         4, 30, 1,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_CONFIGURED|DPCHECK_NEVER },
   { 0,                    IDS_LOCK_DURATION,         0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_LOCK_COUNT,            0, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},

   //
   // Password lock duration, Reset count must be <=, and if this item is not configured,
   // then Reset Count is also not configured.
   //
   { IDS_LOCK_DURATION,    IDS_LOCK_RESET_COUNT,      4, 30, 1,             DPCHECK_LESSEQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 5, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_LOCK_COUNT,            0, 5, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},

   //
   // Password Lock count.  If this item is configured then both Lock count and reset
   // should be configured.  If it is not configured or 0 then the above items can not
   // configured.
   //
   { IDS_LOCK_COUNT,       IDS_LOCK_DURATION,         4, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 0, 1,              DPCHECK_NOTCONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_DURATION,         0, 30,1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},
   { 0,                    IDS_LOCK_RESET_COUNT,      0, 30,1,              DPCHECK_CONFIGURED|DPCHECK_NEVER},

   //
   // Kerberos Max ticket age is dependent on all three things being set.
   //
   { IDS_KERBEROS_MAX_AGE, IDS_KERBEROS_RENEWAL,      4, 7, 24,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_FOREVER | DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 10, 60,            DPCHECK_LESSEQUAL |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE | DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Kerberos renewel is dependent on all three things being set.
   //
   { IDS_KERBEROS_RENEWAL, IDS_KERBEROS_MAX_AGE,      4, 0, 24,             DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 0, 1440,           DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_AGE,      0, 7, 24,             DPCHECK_LESSEQUAL | DPCHECK_VALIDFOR_NC |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE },
   { 0,                    IDS_KERBEROS_MAX_SERVICE,  0, 10, 1440,          DPCHECK_LESSEQUAL | DPCHECK_VALIDFOR_NC |
                                                                            DPCHECK_FOREVER | DPCHECK_INVERSE },

   //
   // Kerberose max service age is dependent on all three being set.
   //
   { IDS_KERBEROS_MAX_SERVICE, IDS_KERBEROS_MAX_AGE,  4, 7, 60,             DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 10, 1440,          DPCHECK_GREATEREQUAL |
                                                                            DPCHECK_VALIDFOR_NC },
   { 0,                    IDS_KERBEROS_RENEWAL,      0, 0, 1,              DPCHECK_NOTCONFIGURED},
   { 0,                    IDS_KERBEROS_MAX_AGE,      0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Password min age is dependent on password max age being set.
   //
   { IDS_MIN_PAS_AGE,      IDS_MAX_PAS_AGE,           2, 30, 1,             DPCHECK_GREATER | DPCHECK_FOREVER |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_MAX_PAS_AGE,           0, 0, 1,              DPCHECK_NOTCONFIGURED},

   //
   // Password max age is dependent on password min age being set.
   //
   { IDS_MAX_PAS_AGE,      IDS_MIN_PAS_AGE,           2, 30, 1,             DPCHECK_LESS | DPCHECK_FOREVER |
                                                                            DPCHECK_VALIDFOR_NC},
   { 0,                    IDS_MIN_PAS_AGE,           0, 0, 1,              DPCHECK_NOTCONFIGURED},
   //
   //"Retention method for application log" is dependent on
   //"Retain Application Log for
   //
   { IDS_APP_LOG_RET,      IDS_APP_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_APP_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },
   { IDS_SEC_LOG_RET,      IDS_SEC_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_SEC_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },
   { IDS_SYS_LOG_RET,      IDS_SYS_LOG_DAYS,          2, 7, 1,              DPCHECK_RETENTION_METHOD_CONFIGURED },
   { 0,                    IDS_SYS_LOG_DAYS,          0, 0, 1,              DPCHECK_RETENTION_METHOD_NOTCONFIGURED },

   //
   //"Retain Application Log for is dependent on
   //"Retention method for application log"
   //
   { IDS_APP_LOG_DAYS,     IDS_APP_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_APP_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED },
   { IDS_SEC_LOG_DAYS,     IDS_SEC_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_SEC_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED },
   { IDS_SYS_LOG_DAYS,     IDS_SYS_LOG_RET,          2, SCE_RETAIN_BY_DAYS, 1, DPCHECK_RETAIN_FOR_CONFIGURED },
   { 0,                    IDS_SYS_LOG_RET,          0, 0, 1,                  DPCHECK_RETAIN_FOR_NOTCONFIGURED }

};


//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::InitializeDependancies
//
// Initialize the dependancies check.  This needs to be done immediately when the
// property sheet whose dependancies we'll want to check is created because it
// ensures that all of the result items who this attribute is dependant on stick
// around.
//
// Arguments   [pSnapin]   - The snapin which is associated with the CREsult item.
//             [pResult]   - The result item we are checking.
//             [pList]     - An alternate dependancy list to use
//             [iCount]    - The size of the alternate dependancy list
// Returns:
//    ERROR_SUCCESS           - Everything initialized properly
//    ERROR_INVALID_PARAMETER - Either [pSnapin] or [pResult] is NULL.
//-------------------------------------------------------------------------------------
DWORD
CDlgDependencyWarn::InitializeDependencies(
   CSnapin *pSnapin,    // The snapin who owns the CResult item.
   CResult *pResult,    // The CResult item we are checking
   PDEPENDENCYLIST pList,// The Dependency list check.
   int iCount           // The count of dependencies in the list.
   )
{
   if( !pSnapin || !pResult){
      return ERROR_INVALID_PARAMETER;
   }
   m_pResult = pResult;
   m_pSnapin = pSnapin;

   //
   // If no dependency list is passed in then set it to the default one.
   //
   if(!pList){
      pList = g_aDList;
      iCount = sizeof(g_aDList)/sizeof(DEPENDENCYLIST);
   }

   //
   // Find the item in the table.
   //
   for(int i = 0; i < iCount; i++){
      if( pList[i].uID == (UINT)pResult->GetID() ){
         break;
      }
      i += (pList[i].uDependencyCount - 1);
   }


   //
   // No dependencies for this item
   //
   if( i >= iCount){
      m_pList = NULL;
      m_iCount = 0;
      return ERROR_SUCCESS;
   }

   //
   // Count of dependencies for the item.
   //
   m_iCount = pList[i].uDependencyCount;
   m_pList = &(pList[i]);

   CResult *pDepends = NULL;

   //
   // Check each dependency.
   //
   pList = m_pList;
   for(int iCheck = 0;
       iCheck < m_iCount;
       iCheck++, pList++){
      pDepends = GetResultItem( pResult, pList->uDepends );
      if(pDepends){
         //
         // We're going to need this dependant item later
         //
         pDepends->AddRef();
         m_aDependsList.Add( pDepends );
      }
   }

   return ERROR_SUCCESS;

}

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::CheckDendencies
//
// This function is used to see if all the dependencies for the result value
// are met.  If a check fails then the function returns ERROR_MORE_DATA and
// the calling procedure can optionally display more information through the dialog
// box.  The function also creates suggested values that would meet the
// dependencies as specifide in the dependency table.
//
// Arguments:
//             [dwValue]   - The new value.
// Returns:
//    ERROR_SUCCESS           - The value is fine or there is no record in the table.
//    ERROR_MORE_DATA         - At least of of the dependency checks failed.
//    ERROR_NOT_READY         - InitializeDependencies hasn't yet been called
//-------------------------------------------------------------------------------------

DWORD
CDlgDependencyWarn::CheckDependencies(
   DWORD dwValue       // The value we are checking.
   )
{
   if( !m_pSnapin || !m_pResult) {
      return ERROR_NOT_READY;
   }

   if (!m_pList) {
      //
      // No Dependancies
      //
      return ERROR_SUCCESS;
   }

   //
   // Save this information for later use, just in case the dialog box is displayed.
   //
   m_dwValue = dwValue;

   //
   // Free up the dependency array, as it is no longer valid when this function
   // starts.
   //
   CResult *pDepends = NULL;
   for(int iCheck = 0; iCheck < m_aFailedList.GetSize(); iCheck++){
      if(m_aFailedList[iCheck]){
         LocalFree(m_aFailedList[iCheck]);
      }
   }
   m_aFailedList.RemoveAll();


   //
   // Check each dependency.
   //
   PDEPENDENCYLIST pList = m_pList;
   for(int iCheck = 0; iCheck < m_aDependsList.GetSize(); iCheck++,pList++){
      ASSERT(pList->uConversion != 0); //Check the expression. Raid #550912, yanggao.

      pDepends = m_aDependsList[iCheck];
      if(pDepends){
         //
         // perform check.
         //
         BOOL bFailed = FALSE;
         DWORD dwCheck = 0;
         DWORD dwItem  = 0;
         LONG_PTR dwSuggest = 0;
         BOOL bNever = 0;
         BOOL bSourceConfigured;
         BOOL bDependConfigured;

         switch( 0x0000FFFF & pList->uOpFlags ){
         case DPCHECK_CONFIGURED:
            //Rule:if the source is configured, depend must be configured

            //
            // The depent item must be configured.  Failure accurs only if the items
            // value is some error value of SCE.
            //
            dwSuggest = (LONG_PTR)pList->uDefault;

            bNever = pList->uOpFlags & DPCHECK_NEVER;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue) {
               // this item is not configured
               bSourceConfigured = FALSE;
            }
            else if( 0 == dwValue && bNever ){
               bSourceConfigured = FALSE;
            }
            else{
               bSourceConfigured = true;
            }


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck) {
            // the dependant item is not configured
               bDependConfigured = false;
            } else if ( 0 == dwCheck && bNever ) {
            // the dependant item is not configured if bNever is true
               bDependConfigured = false;
            }
            else{
               bDependConfigured = true;
            }


            bFailed = bSourceConfigured ? !bDependConfigured : false;



            break;

         case DPCHECK_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;

            bNever = pList->uOpFlags & DPCHECK_NEVER;
            dwCheck = (DWORD) pDepends->GetBase();

                        //check if source is configured
            if (SCE_NO_VALUE == dwValue ) {
               // this item is not configured
               bSourceConfigured = FALSE;
            }
            else if( 0 == dwValue && bNever ){
               bSourceConfigured = FALSE;
            }
            else{
               bSourceConfigured = true;
            }


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck ) {
            // the dependant item is not configured
               bDependConfigured = false;
            } else if ( 0 == dwCheck && bNever ) {
            // the dependant item is not configured if bNever is true
               bDependConfigured = false;
            }
            else{
               bDependConfigured = true;
            }

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         //This case statement is Specially for retention method case
         case DPCHECK_RETENTION_METHOD_CONFIGURED:
            //Here is the rule for DPCHECK_RETENTION_METHOD_CONFIGURED and DPCHECK_RETENTION_METHOD_NOTCONFIGURED
            //If and Only if "Overwrite Event by days" is checked
            //Retain **** Log for is configured
            //Rule:if the source is configured, depend must be configured

            dwSuggest = (LONG_PTR)pList->uDefault;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if ( SCE_RETAIN_BY_DAYS == dwValue )
               bSourceConfigured = true;
            else
               bSourceConfigured = false;


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck)
               bDependConfigured = false;
            else
               bDependConfigured = true;


            bFailed = bSourceConfigured ? !bDependConfigured : false;

            break;

         case DPCHECK_RETENTION_METHOD_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_RETAIN_BY_DAYS == dwValue )
               bSourceConfigured = true;
            else
               bSourceConfigured = false;


            //check if depend is configured
            if (SCE_NO_VALUE == dwCheck || SCE_ERROR_VALUE == dwCheck)
               bDependConfigured = false;
            else
               bDependConfigured = true;

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         //This case statement is Specially for Retain *** Log For case
         case DPCHECK_RETAIN_FOR_CONFIGURED:
            //Here is the rule for DPCHECK_RETAIN_FOR_CONFIGURED and DPCHECK_RETAIN_FOR_NOTCONFIGURED
            //If "Retain **** Log for" is configured
            //then "Overwrite Event by days" is checked

            dwSuggest = (LONG_PTR)pList->uDefault;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue)
               bSourceConfigured = false;
            else
               bSourceConfigured = true;

            //check if depend is configured
            if (SCE_RETAIN_BY_DAYS == dwCheck )
               bDependConfigured = true;
            else
               bDependConfigured = false;

            bFailed = bSourceConfigured ? !bDependConfigured : false;

            break;

         case DPCHECK_RETAIN_FOR_NOTCONFIGURED:
            //Rule: if source is not configured, depend should not be
            //configured

            dwSuggest = (LONG_PTR)SCE_NO_VALUE;
            dwCheck = (DWORD) pDepends->GetBase();

            //check if source is configured
            if (SCE_NO_VALUE == dwValue || SCE_ERROR_VALUE == dwValue)
               bSourceConfigured = false;
            else
               bSourceConfigured = true;

            //check if depend is configured
            if (SCE_RETAIN_BY_DAYS == dwCheck )
               bDependConfigured = true;
            else
               bDependConfigured = false;

            bFailed = bSourceConfigured ? false : bDependConfigured;

            break;

         default:
            //
            // convert the values as needed.  If the check value is NOT Configured,
            // Then we don't have anything to do, unless the item must be configured
            // for the value to be correct.  This is specifide by DPCHECK_VALIDFOR_NC
            // being set.  At this point, if the depend item is not configured then
            // we will set the check item to the default value.  We will allow the
            // check to be performed, (mostly because we need to get the suggested value.
            //
            dwItem = dwValue;

            dwCheck = (DWORD)pDepends->GetBase();
            if( (!(pList->uOpFlags & DPCHECK_VALIDFOR_NC)
                && dwCheck == SCE_NO_VALUE) || dwItem == SCE_NO_VALUE ){
               //
               // The dependent item is not configured and DPCHECK_VALIDFOR_NC is
               // not set, nothing to do.
               continue;
            } else if(dwCheck == SCE_NO_VALUE){

               //
               // Set the suggested value to the default specifide in the table.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  if( 0 != m_pList->uConversion ) //Raid #550912, yanggao.
                  {
                     dwSuggest = (LONG_PTR) ((DWORD)pList->uDefault/ m_pList->uConversion);
                  }
                  else
                  {
                     dwSuggest = (LONG_PTR) ((DWORD)pList->uDefault);
                  }
               } else {
                  dwSuggest = (LONG_PTR) ((DWORD)pList->uDefault * m_pList->uConversion);
               }
               dwCheck = pList->uDefault;
            }

            if( pList->uOpFlags & DPCHECK_FOREVER){
               //
               // Convert values to maximum natural number.
               //
               if(dwItem == SCE_FOREVER_VALUE){
                  dwItem = -1;
               }

               //
               // The value to check against.
               //
               if(dwCheck == SCE_FOREVER_VALUE){
                  dwCheck = -1;
               } else {
                  goto ConvertUnits;
               }
            } else {
ConvertUnits:
               //
               // Normal conversion routine.  We need to convert the number to
               // the item we are checkings units.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  //
                  // When deviding by integers we want to round up, not down.
                  //
                  if( 0 != pList->uConversion && 0 != m_pList->uConversion) //Raid #550912, yanggao.
                  {
                     dwCheck = (DWORD)(dwCheck / pList->uConversion) + (dwCheck%m_pList->uConversion ? 1:0);
                  }
               } else {
                  dwCheck = (DWORD)(dwCheck * pList->uConversion);
               }
            }

            switch( 0x0000FFFF & pList->uOpFlags ){
            case DPCHECK_GREATEREQUAL:
               //
               // Fails only if the dependency value is less than the item we
               // are checking.
               //
               if( dwCheck < dwItem){
                  dwSuggest = (LONG_PTR)dwValue;
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_GREATER:
               //
               // Fails only if the dependency value is less than or equal to
               // the item we are checking.
               //
               if( dwCheck <= dwItem){
                  dwSuggest = (LONG_PTR)(dwValue + 1);
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_LESSEQUAL:
               //
               // Fails if the dependency value is greater than the value.
               //
               if( dwCheck > dwItem ){
                  dwSuggest = (LONG_PTR)dwValue;
                  bFailed = TRUE;
               }
               break;
            case DPCHECK_LESS:
               //
               // Fails if the dependency value is greater than or equal to the value.
               //
               if( dwCheck >= dwItem ){
                  dwSuggest = (LONG_PTR)dwValue - 1;
                  bFailed = TRUE;
               }
               break;
            }

            //
            // We do one more final check on the dependency value.  If the dependency value
            // is not configured or an error then we know the test failed.
            // so set the bFailed flag.  The suggested value has already been set at
            // this point.
            //
            if( pDepends->GetBase() == (LONG_PTR)SCE_NO_VALUE ||
                pDepends->GetBase() == (LONG_PTR)SCE_ERROR_VALUE ){
               bFailed = TRUE;
            }
         }

         if(bFailed){
            //
            // The check failed so add the item to the failed list.
            //
            dwItem = (DWORD)dwSuggest;

            //
            // Calculate the actual value.
            //
            if(dwItem == -1 && pList->uOpFlags & DPCHECK_FOREVER){
               //
               // Special case for forever value.
               dwSuggest = (LONG_PTR)SCE_FOREVER_VALUE;
            } else if(dwItem != SCE_NO_VALUE){
               //
               // Other values must be converted back to their units.
               //
               if(pList->uOpFlags & DPCHECK_INVERSE){
                  dwSuggest = (LONG_PTR) (dwItem * pList->uConversion);
               } else {
                  if( 0 != pList->uConversion && 0 != m_pList->uConversion ) //Raid #550912, yanggao.
                  {
                     if(dwItem%pList->uConversion){
                        dwSuggest = (LONG_PTR) ((dwItem + pList->uConversion)/m_pList->uConversion);
                     } else {
                        dwSuggest = (LONG_PTR) ((dwItem)/pList->uConversion);
                     }
                  }
                  else
                  {
                     dwSuggest = (LONG_PTR)SCE_FOREVER_VALUE;
                  }
               }
            }

            //
            // check bounds on suggested settings.
            //
            const DEPENDENCYMINMAX *pMinMax = LookupMinMaxInfo( (UINT)pDepends->GetID());
            if(pMinMax && dwSuggest != SCE_NO_VALUE && dwSuggest != SCE_FOREVER_VALUE){
               if(pMinMax->uMin > (UINT)dwSuggest){
                  dwSuggest = pMinMax->uMin;
               } else if( pMinMax->uMax < (UINT)dwSuggest ){
                  dwSuggest = pMinMax->uMax;
               }
            }

            if( pDepends->GetBase() != dwSuggest ) //Raid #402030
            {
               PDEPENDENCYFAILED pAdd = (PDEPENDENCYFAILED)LocalAlloc(0, sizeof(DEPENDENCYFAILED));
               if(pAdd){
               //
               // Add the item to the failed list.
               //
               pAdd->pList = pList;
               pAdd->pResult = pDepends;
               pAdd->dwSuggested = dwSuggest;
               m_aFailedList.Add( pAdd );
               }
            }
         }
      }
   }

   //
   // Returns ERROR_MORE_DATA if one of the dependencies failed.
   //
   if(m_aFailedList.GetSize()){
      return ERROR_MORE_DATA;
   }
   return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------------------
// CDlgDependencyWarn::GetResultItem
//
// Returns the first result item associated with [pBase] with matching
// [uID] throught CResult::GetID();
// Arguments   [pBase]  - To get the CFolder object.
//             [uID]    - The ID we are looking for.
// Returns:
//    If the function succeeds then a valid CREsult item is returned otherwise
//    NULL
//-------------------------------------------------------------------------------------
CResult *
CDlgDependencyWarn::GetResultItem(CResult *pBase, UINT uID)
{
   if(!pBase){
      return NULL;
   }

   CFolder *pFolder = reinterpret_cast<CFolder *>(pBase->GetCookie());
   if(!pFolder){
      //
      // Nothing to do.
      //
      return NULL;
   }

   HANDLE handle;
   pFolder->GetResultItemHandle ( &handle );
   if(!handle){
      //
      // Nothing to do.
      //
      return NULL;
   }

   POSITION pos = NULL;

   //
   // Enumerate through all the result items and find out if any of them
   // matches the ID.  If so then return the item.
   //
   pFolder->GetResultItem (handle, pos, &pBase);
   while(pBase){
      if( (UINT)pBase->GetID() == uID){
         break;
      }

      if(!pos){
         pBase = NULL;
         break;
      }
      pFolder->GetResultItem(handle, pos, &pBase);
   }

   pFolder->ReleaseResultItemHandle (handle);
   return pBase;
}

BEGIN_MESSAGE_MAP(CDlgDependencyWarn, CHelpDialog)
   //{{AFX_MSG_MAP(CDlgDependencyWarn)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDependencyWarn message handlers

//+-------------------------------------------------------------------------
// CDlgDependencyWarn::OnInitDialog
//
// When this dialog is initialized.  We prepare the listctrl for display.
// Set the title of the window and the static window that displays
// information text for the user.
// Create the columns in the list ctrl.
// For each dependency that failed, Insert the item into the list ctrl,
// and set each columns text, by querying the string from the specifide
// result item.
//
// Returns: the default.
BOOL CDlgDependencyWarn::OnInitDialog()
{
   CDialog::OnInitDialog();

   if(!m_pResult){
      //
      // Nothing to do.
      //
      return TRUE;
   }

   CWnd *pWnd       = GetDlgItem(IDC_WARNING);
   CListCtrl *pCtrl = reinterpret_cast<CListCtrl *>(GetDlgItem(IDC_FAILEDLIST));
   CString str, strVal, strTitle, strFormat;
   GetWindowText(str);
   //
   // Set the window text

   GetResultItemString(strTitle, 0, m_pResult);
   GetResultItemString(strVal, 1, m_pResult, (LONG_PTR)m_dwValue);

   strFormat.Format( str, strTitle );
   SetWindowText(strFormat);

   if(pWnd){
      //
      // Set the description text.
      //
      pWnd->GetWindowText(str);
      strFormat.Format( str, strTitle, strVal );
      pWnd->SetWindowText(strFormat);
   }

   int iItem = 0;
   if(pCtrl){
      //
      // Insert the columns.
      //
      CRect rect;
      pCtrl->GetWindowRect(rect);
      str.LoadString(IDS_ATTR);
      iItem = (int)(rect.Width() * 0.45);
      pCtrl->InsertColumn(0, str, LVCFMT_LEFT, iItem);

      CFolder* pFolder = (CFolder*)m_pResult->GetCookie(); //Raid #490553, yanggao, 11/28/2001
      if( pFolder )
      {
         switch(pFolder->GetMode())
         {
         case SCE_MODE_EDITOR: //template snapin
             str.LoadString(IDS_TEMPLATE_SET);
             break;
         case SCE_MODE_DOMAIN_COMPUTER:
         case SCE_MODE_DOMAIN_USER: //group policy
         case SCE_MODE_LOCAL_COMPUTER:
         case SCE_MODE_LOCAL_USER: //local policy
             str.LoadString(IDS_POLICY_SET);
             break;
         case SCE_MODE_VIEWER: //analysis and configuration snapin
         default:
             str.LoadString(IDS_BASE_ANALYSIS);
             break;
         }
      }
      //str.LoadString(IDS_BASE_ANALYSIS);
      rect.left += iItem;
      iItem = rect.Width()/2;
      pCtrl->InsertColumn(1, str, LVCFMT_LEFT, iItem);

      str.LoadString(IDS_SUGGESTSETTING);
      rect.left += iItem;
      pCtrl->InsertColumn(2, str, LVCFMT_LEFT, rect.Width());
   }

   //
   // Create image list for this dialog.
   //
   CBitmap bmp;
   if(bmp.LoadBitmap(IDB_ICON16)){
      CDC *dc = GetDC();
      CDC bmDC;

      if ( bmDC.CreateCompatibleDC(dc) ) {
          CBitmap *obmp = bmDC.SelectObject(&bmp);
          COLORREF cr = bmDC.GetPixel(0, 0);
          bmDC.SelectObject(obmp);
          bmp.DeleteObject();

          m_imgList.Create(IDB_ICON16, 16, 0, RGB(255,0,255)); //Raid #482861, Yanggao
          pCtrl->SetImageList(CImageList::FromHandle(m_imgList), LVSIL_SMALL);

      }
      ReleaseDC(dc);
   }


   CFolder *pFolder = reinterpret_cast<CFolder *>(m_pResult->GetCookie());
   if(pFolder){
      //
      // Add the items to the error list.
      //
      for(int i = 0; i < m_aFailedList.GetSize(); i++){
         if(!m_aFailedList[i]){
            continue;
         }

         CResult *pDepend = m_aFailedList[i]->pResult;
         if(pDepend){
            //
            // First column text.
            //
            pDepend->GetDisplayName(NULL, str, 0);

            int dwStatus = pDepend->GetStatus();
            pDepend->SetStatus(SCE_STATUS_NOT_CONFIGURED);
            iItem = pCtrl->InsertItem(0, str, GetResultImageIndex(pFolder, pDepend) );
            pDepend->SetStatus( dwStatus );

            //
            // Second column text.
            //
            GetResultItemString(str, 1, pDepend, pDepend->GetBase());
            pCtrl->SetItemText(iItem, 1, str);

            //
            // Suggested item text.
            //
            GetResultItemString(str, 1, pDepend, m_aFailedList[i]->dwSuggested);
            pCtrl->SetItemText(iItem, 2, str);
         }
      }
   }
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

//+----------------------------------------------------------------------------------
// CDlgDependencyWarn::GetResultItemString
//
// Queries the result item for the full text it would display in the specifide
// column if [dwValue] were it's base value.
//
// Arguments:  [str]    - The returned string
//             [iCol]   - The column being queryed.
//             [pResult]- The result being queryed
//             [dwValue]- The base value to set before quering string.  The old value
//                        is not erased.
//
// Returns:    TRUE     - [str] is a valid string.
//             FALSE    - something went wrong.
//-----------------------------------------------------------------------------------
BOOL
CDlgDependencyWarn::GetResultItemString(
   CString &str,
   int iCol,
   CResult *pResult,
   LONG_PTR dwValue
   )
{
   if(!pResult){
      return FALSE;
   }
   CFolder *pFolder = reinterpret_cast<CFolder *>(pResult->GetCookie());

   if(!pFolder){
      return FALSE;
   }

   //
   // Remember the old status and base.
   int iStatus = pResult->GetStatus();
   LONG_PTR lpData = pResult->GetBase();

   //
   // Set the base value to the new one, and status to not configured.
   //
   pResult->SetBase( dwValue );
   pResult->SetStatus(SCE_STATUS_NOT_CONFIGURED);

   //
   // Query for the string.
   //
   pResult->GetDisplayName( NULL, str, iCol );

   //
   // Reset the old status and base.
   //
   pResult->SetStatus( iStatus );
   pResult->SetBase(lpData);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
static int indentLevel = 0;


void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    va_list arglist;
    WCHAR Buffer[512];
    int cb;

//    if ( level < 0 )
//        indentLevel += level;
    //
    // Format the output into a buffer and then print it.
    //
//    wstring strTabs;

//    for (int nLevel = 0; nLevel < indentLevel; nLevel++)
//        strTabs += L"  ";

//    OutputDebugStringW (strTabs.c_str ());

    va_start(arglist, format);
    //This is not a safe usage. _vsnwprintf overflow returns -1. make sure Buffer is terminated. Raid #555867. Yanggao.
    cb = _vsnwprintf (Buffer, sizeof(Buffer)/sizeof(Buffer[0])-1, format, arglist);
    if ( cb > 0 )
    {
        OutputDebugStringW (Buffer);
    }

    va_end(arglist);

//    if ( level > 0 )
//        indentLevel += level;
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Wsecedit Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Wsecedit Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)


#endif

//
// yet another trace style used by chklist.h & disabled here
//
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }

#define TraceSetMask(dwMask)  
#define TraceEnter(dwMask, fn) 
#define TraceLeave           

#define Trace               
#define TraceMsg(s)        
#define TraceGUID(s, rGUID)

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\defvals.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       defvals.h
//
//----------------------------------------------------------------------------
#ifndef DEF_VALS_H
#define DEF_VALS_H

#define MAX_PASS_AGE_DEFAULT 72
#define MIN_PASS_AGE_DEFAULT 0
#define MIN_PASS_LENGTH_DEFAULT 7
#define PASS_HISTORY_SIZE_DEFAULT 18
#define PASS_COMPLEXITY_DEFAULT 1
#define REQUIRE_LOGIN_DEFAULT 1
#define LOCKOUT_BAD_COUNT_DEFAULT 0
#define RESET_LOCKOUT_COUNT_DEFAULT 5
#define LOCKOUT_DURATION_DEFAULT 30
#define AUDIT_SYSTEM_EVENTS_DEFAULT 0
#define AUDIT_LOGON_EVENTS_DEFAULT 0
#define AUDIT_OBJECT_ACCESS_DEFAULT 0
#define AUDIT_PRIVILEGE_USE_DEFAULT 0
#define AUDIT_POLICY_CHANGE_DEFAULT 0
#define AUDIT_ACCOUNT_MANAGE_DEFAULT 0
#define AUDIT_PROCESS_TRACKING_DEFAULT 0
#define AUDIT_DS_ACCESS_DEFAULT 3
#define AUDIT_ACCOUNT_LOGON_DEFAULT 0
#define FORCE_LOGOFF_DEFAULT 0
#define ENABLE_ADMIN_DEFAULT 1
#define ENABLE_GUEST_DEFAULT 0
#define SECURE_SYSTEM_PARTITION_DEFAULT 1
#define SYS_MAX_LOG_SIZE_DEFAULT 512
#define SEC_MAX_LOG_SIZE_DEFAULT 512
#define APP_MAX_LOG_SIZE_DEFAULT 512
#define SYS_LOG_RETENTION_PERIOD_DEFAULT 512
#define SEC_LOG_RETENTION_PERIOD_DEFAULT 512
#define APP_LOG_RETENTION_PERIOD_DEFAULT 512
#define SYS_LOG_RETENTION_DAYS_DEFAULT 7
#define SEC_LOG_RETENTION_DAYS_DEFAULT 7
#define APP_LOG_RETENTION_DAYS_DEFAULT 7
#define SYS_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define SEC_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define APP_RESTRICT_GUEST_ACCESS_DEFAULT 0
#define LSA_ANON_LOOKUP_DEFAULT 0

#define FILE_SYSTEM_SECURITY_DEFAULT TEXT("D:(A;CIOI;GA;;;WD)")
#define REGISTRY_SECURITY_DEFAULT TEXT("D:(A;CI;GA;;;WD)")
#define SERVICE_SECURITY_DEFAULT TEXT("D:(A;CIOI;GA;;;WD)")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\getuser.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       getuser.h
//
//  Contents:   definition of CGetUser
//                              
//----------------------------------------------------------------------------
#ifndef GETUSER_H
#define GETUSER_H

#define SCE_SHOW_USERS            0x1
#define SCE_SHOW_GROUPS           0x2
#define SCE_SHOW_ALIASES          0x4
#define SCE_SHOW_ALL              0x7
#define SCE_SHOW_LOCALONLY        0x8
#define SCE_SHOW_DOMAINGROUPS     0x10
#define SCE_SHOW_SINGLESEL        0x20

#define SCE_SHOW_BUILTIN          0x40
#define SCE_SHOW_WELLKNOWN        0x80
#define SCE_SHOW_GLOBAL           0x100
#define SCE_SHOW_LOCALGROUPS      0x200

#define SCE_SHOW_SCOPE_LOCAL      0x400
#define SCE_SHOW_SCOPE_DOMAIN     0x800
#define SCE_SHOW_SCOPE_DIRECTORY  0x1000
#define SCE_SHOW_SCOPE_ALL        (SCE_SHOW_SCOPE_LOCAL|SCE_SHOW_SCOPE_DOMAIN|SCE_SHOW_SCOPE_DIRECTORY)

#define SCE_SHOW_DIFF_MODE_OFF_DC 0x2000
#define SCE_SHOW_COMPUTER         0x4000


typedef struct _tag_WSCE_ACCOUNTINFO
{
    LPTSTR pszName;
    SID_NAME_USE sidType;
} WSCE_ACCOUNTINFO, *PWSCE_ACCOUNTINFO;

class CGetUser
{
public:
    PSCE_NAME_LIST GetUsers();
    BOOL Create(HWND hwnd, DWORD nShowFlag);
    CGetUser();
    virtual ~CGetUser();

    void SetServer( LPCTSTR pszServerName )
      { m_pszServerName = pszServerName; };

protected:
    HINSTANCE m_hinstNetUI;
    PSCE_NAME_LIST m_pNameList;

public:
    static SID_NAME_USE
    GetAccountType(LPCTSTR pszName);

protected:
    LPCTSTR m_pszServerName;
    static CTypedPtrArray<CPtrArray, PWSCE_ACCOUNTINFO> m_aKnownAccounts;
};

#endif // GETUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\edittemp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       edittemp.h
//
//  Contents:   definition of CEditTemplate
//                              
//----------------------------------------------------------------------------
#ifndef EDITTEMP_H
#define EDITTEMP_H
#include "stdafx.h"
#include "hidwnd.h"
#pragma warning(push,3)
#include <scesvc.h>
#pragma warning(pop)

class CComponentDataImpl;


#define AREA_DESCRIPTION 0x1000

class CEditTemplate {
public:
   BOOL SetDirty(AREA_INFORMATION Area);
   void LockWriteThrough();
   void UnLockWriteThrough();
   BOOL IsLockedWriteThrough() {return m_bLocked;};

   BOOL IsDirty();
   BOOL SetWriteThrough(BOOL bOn) { return m_bWriteThrough = bOn; };
   BOOL QueryWriteThrough() { return m_bWriteThrough; };
   BOOL SetWriteThroughDirty(BOOL bOn) { return m_bWriteThroughDirty = bOn; };
   void SetNotificationWindow(LPNOTIFY pNotify) { m_pNotify = pNotify; };

   BOOL QueryWriteThroughDirty() { return m_bWriteThroughDirty; };
   BOOL Save(LPCTSTR szName=NULL);
   BOOL AddService(LPCTSTR szService,
                   LPSCESVCATTACHMENTPERSISTINFO pPersistInfo);
   BOOL SetInfFile(LPCTSTR szName);
   BOOL CheckArea(AREA_INFORMATION Area) { return ((Area & m_AreaLoaded) == Area); }
   DWORD QueryArea() { return m_AreaLoaded; }
   void AddArea(AREA_INFORMATION Area) { m_AreaLoaded |= Area; }
   void ClearArea(AREA_INFORMATION Area) { m_AreaLoaded &= ~Area; SetDirty(Area); }
   void SetProfileHandle(PVOID hProfile) { m_hProfile = hProfile; }
   BOOL SetDescription(LPCTSTR szDesc);
   void SetComponentDataImpl(CComponentDataImpl *pCDI) { m_pCDI = pCDI; }
   DWORD RefreshTemplate(AREA_INFORMATION aiAreaToAdd = 0);
   BOOL SetNoSave(BOOL b) { return m_bNoSave = b; }
   BOOL QueryNoSave() { return m_bNoSave; }
   BOOL SetPolicy(BOOL b) { return m_bPolicy = b; }
   BOOL QueryPolicy() { return m_bPolicy; }

   LPCTSTR GetInfName()
      { return m_szInfFile; };

   void SetTemplateDefaults();
   LPCTSTR GetDesc() const;   
public:

   CEditTemplate();
   virtual ~CEditTemplate();
public:
   DWORD
   UpdatePrivilegeAssignedTo(
       BOOL bRemove,
       PSCE_PRIVILEGE_ASSIGNMENT *ppaLink,
       LPCTSTR pszName = NULL
       );
   LPCTSTR
   GetFriendlyName() //Raid Bug292634, Yang Gao, 3/30/2001
        { return (m_strFriendlyName.IsEmpty() ? (LPCTSTR)m_szInfFile : m_strFriendlyName); };
   void
   SetFriendlyName(LPCTSTR pszName)
        { m_strFriendlyName = pszName; };

public:
   static DWORD
   ComputeStatus(
      PSCE_REGISTRY_VALUE_INFO prvEdit,
      PSCE_REGISTRY_VALUE_INFO prvAnal
      );
   static DWORD
   ComputeStatus(
      PSCE_PRIVILEGE_ASSIGNMENT pEdit,
      PSCE_PRIVILEGE_ASSIGNMENT pAnal
      );

private:

   CMap<CString, LPCTSTR, LPSCESVCATTACHMENTPERSISTINFO, LPSCESVCATTACHMENTPERSISTINFO&> m_Services;

   PVOID m_hProfile;
   LPTSTR m_szInfFile;
   AREA_INFORMATION m_AreaDirty;
   BOOL m_bWriteThrough;
   BOOL m_bWriteThroughDirty;
   BOOL m_bNoSave;
   AREA_INFORMATION m_AreaLoaded;
   CComponentDataImpl *m_pCDI;
   LPTSTR m_szDesc;
   LPNOTIFY m_pNotify;
   CString m_strFriendlyName;
   BOOL m_bWMI;
   BOOL m_bPolicy;
   BOOL m_bLocked;
public:
   //
   // Public attributes.
   //
   PSCE_PROFILE_INFO pTemplate;

};

typedef CEditTemplate EDITTEMPLATE, *PEDITTEMPLATE;

#endif // EDITTEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\delobjs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       delobjs.cpp
//
//  Contents:   Functions for handling the deletion of template objects
//
//---------------------------------------------------------------------------



#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "wrapper.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT CSnapin::OnDeleteObjects(
   LPDATAOBJECT pDataObj,
   DATA_OBJECT_TYPES cctType,
   MMC_COOKIE cookie,
   LPARAM arg,
   LPARAM param)
{

   if ( 0 == cookie)
      return S_OK;

   if (NULL == pDataObj)
      return S_OK;

   INTERNAL *pAllInternals, *pInternal;
   pAllInternals = ExtractInternalFormat( pDataObj );

   //
   // Find out if this is a mutli select item.
   //
   int iCnt = 1;
   pInternal = pAllInternals;

   if(!pInternal)
      return S_OK;

   if(pAllInternals && pAllInternals->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE)
   {
      pInternal = pAllInternals;
      iCnt = (int)pInternal->m_type;
      pInternal++;
   }

   CFolder *pFolder = m_pSelectedFolder;
   BOOL bAsk = TRUE;

   while( iCnt-- ){
      cookie  = pInternal->m_cookie;
      cctType = pInternal->m_type;

      if ( cctType == CCT_RESULT ) {
         CResult* pResult = (CResult *)cookie;

         RESULT_TYPES rsltType = pResult->GetType();

         if ( rsltType == ITEM_PROF_GROUP ||
              rsltType == ITEM_PROF_REGSD ||
              rsltType == ITEM_PROF_FILESD
              ) {

            if(bAsk ){
               CString str,strFmt;

               //
               // The first cast asks the users if they wish to delete all selected items.
               // the second case asks to delete one file.
               //
               if(bAsk && iCnt > 0 ){  //Raid #463490, Yang Gao, 9/6/2001
                  str.LoadString( IDS_DELETE_ALL_ITEMS);
               } else {
                  strFmt.LoadString(IDS_QUERY_DELETE);
                  str.Format(strFmt,pResult->GetAttr());
                  if( str.GetLength() > MAX_PATH ) //Raid 567778, yanggao, 4/25/2002.
                  {
                     strFmt = str.Left(MAX_PATH);
                     str = strFmt + L"... ?";
                  }
               }

               //
               // Ask the question.  We only want to ask the question once, so set
               // bAsk to false so that we neve enter this block again.
               //
               if ( IDNO == AfxMessageBox((LPCTSTR)str, MB_YESNO, 0) ) {
                  iCnt = 0;
                  continue;
               }
               bAsk = FALSE;
            }

            //
            // free memory associated with the item
            //
            BOOL                  bDelete=FALSE;

            TRACE(_T("CSnapin::OnDeleteObjects-pResult(%x)\n"),pResult);

            if ( rsltType == ITEM_PROF_GROUP ) {

               PSCE_GROUP_MEMBERSHIP pGroup, pParentGrp;
               PEDITTEMPLATE         pTemplate;
               //
               // delete this group from the template
               //
               pTemplate = pResult->GetBaseProfile();

               if ( pResult->GetBase() != 0 && pTemplate && pTemplate->pTemplate &&
                    pTemplate->pTemplate->pGroupMembership ) {

                  for ( pGroup=pTemplate->pTemplate->pGroupMembership, pParentGrp=NULL;
                      pGroup != NULL; pParentGrp=pGroup, pGroup=pGroup->Next ) {

                     if ( pResult->GetBase() == (LONG_PTR)pGroup ) {
                        //
                        // remove this node from the list
                        //
                        if ( pParentGrp ) {
                           pParentGrp->Next = pGroup->Next;
                        } else {
                           pTemplate->pTemplate->pGroupMembership = pGroup->Next;
                        }
                        pGroup->Next = NULL;
                        TRACE(_T("CSnapin::OnDeleteObjects-pGroup(%x)\n"),pGroup);
                        //
                        // free the node
                        //
                        if ( pGroup ) {
                           SceFreeMemory((PVOID)pGroup, SCE_STRUCT_GROUP);
                        }
                        break;
                     }
                  }
               }
               if ( pTemplate ) {
                  (void)pTemplate->SetDirty(AREA_GROUP_MEMBERSHIP);
               }

               bDelete = TRUE;

            } else if ( rsltType == ITEM_PROF_REGSD ||
                        rsltType == ITEM_PROF_FILESD
                        ) {

               PSCE_OBJECT_SECURITY  pObject;
               PSCE_OBJECT_ARRAY     poa;
               DWORD                 i,j;
               PEDITTEMPLATE         pTemplate;
               AREA_INFORMATION      Area;

               pObject = (PSCE_OBJECT_SECURITY)(pResult->GetID());
               pTemplate = pResult->GetBaseProfile();

               if ( rsltType == ITEM_PROF_REGSD ) {
                  poa = pTemplate->pTemplate->pRegistryKeys.pAllNodes;
                  Area = AREA_REGISTRY_SECURITY;
               } else if ( rsltType == ITEM_PROF_FILESD ) {
                  poa = pTemplate->pTemplate->pFiles.pAllNodes;
                  Area = AREA_FILE_SECURITY;
               } else {
                  poa = pTemplate->pTemplate->pDsObjects.pAllNodes;
                  Area = AREA_DS_OBJECTS;
               }

               if ( pResult->GetID() != 0 && pTemplate &&
                    pTemplate->pTemplate && poa ) {

                  i=0;
                  while ( i < poa->Count &&
                          (pResult->GetID() != (LONG_PTR)(poa->pObjectArray[i])) )
                     i++;

                  if ( i < poa->Count ) {
                     //
                     // remove this node from the array, but the arry won't be reallocated
                     //
                     for ( j=i+1; j<poa->Count; j++ ) {
                        poa->pObjectArray[j-1] = poa->pObjectArray[j];
                     }
                     poa->pObjectArray[poa->Count-1] = NULL;

                     poa->Count--;
                     //
                     // free the node
                     //
                     TRACE(_T("CSnapin::OnDeleteObjects-pObject(%x)\n"),pObject);
                     if ( pObject ) {
                        if ( pObject->Name != NULL )
                           LocalFree( pObject->Name );

                        if ( pObject->pSecurityDescriptor != NULL )
                           LocalFree(pObject->pSecurityDescriptor);

                        LocalFree( pObject );
                     }
                  }
               }
               if ( pTemplate ) {
                  (void)pTemplate->SetDirty(Area);
               }

               bDelete = TRUE;
            }
            if ( bDelete ) {
               //
               // delete from the result pane
               //
               HRESULTITEM hItem = NULL;
               if(m_pResult->FindItemByLParam( (LPARAM)pResult, &hItem) == S_OK){
                   m_pResult->DeleteItem(hItem, 0);
               }
                  //
                  // delete the item from result list and free the buffer
                  //
                  POSITION pos=NULL;

                  //if ( FindResult((long)cookie, &pos) ) {
                  //   if ( pos ) {
                  if (m_pSelectedFolder->RemoveResultItem(
                              m_resultItemHandle,
                              pResult
                              ) == ERROR_SUCCESS) {

                  //
                  // delete the node
                  //
                  delete pResult;
               }

               //
               // Notify any other views to also delete the item
               //
               m_pConsole->UpdateAllViews((LPDATAOBJECT)this, (LONG_PTR)pResult, UAV_RESULTITEM_REMOVE);
            }
         }
      }
      pInternal++;
   }

   if( pAllInternals )
   {
      FREE_INTERNAL(pAllInternals);
   }
   return S_OK;
}


CResult* CSnapin::FindResult(MMC_COOKIE cookie, POSITION* thePos)
{
   POSITION pos = NULL; //m_resultItemList.GetHeadPosition();
   POSITION curPos;
   CResult* pResult = NULL;

   if(!m_pSelectedFolder || !m_resultItemHandle)
   {
      return  NULL;
   }

   do {
      curPos = pos;
      if( m_pSelectedFolder->GetResultItem(
                              m_resultItemHandle,
                              pos,
                              &pResult) != ERROR_SUCCESS )
      {
         break;
      }

      // pos is already updated to the next item after this call
      //pResult = m_resultItemList.GetNext(pos);

      // how to compare result item correctly ?
      // for now, let's compare the pointer address.
      if ((MMC_COOKIE)pResult == cookie) 
      {
         if ( thePos ) 
         {
            *thePos = curPos;
         }

         return pResult;
      }
   } while( pos );

   if ( thePos )
      *thePos = NULL;

   return NULL;
}

void
OnDeleteHelper(CRegKey& regkeySCE,CString tmpstr) {
   //
   // replace the "\" with "/" because registry does not take "\" in a single key
   //
   int npos = tmpstr.Find(L'\\');
   while (npos != -1) {
      *(tmpstr.GetBuffer(1)+npos) = L'/';
      npos = tmpstr.Find(L'\\');
   }
   regkeySCE.DeleteSubKey(tmpstr);

   regkeySCE.Close();
}

HRESULT CComponentDataImpl::OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   ASSERT(lpDataObject);
   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

   if ( lpDataObject == NULL ) {
      return S_OK;
   }

   HRESULT hr = S_OK;

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   if ( pInternal ) {
      MMC_COOKIE cookie = pInternal->m_cookie;

      CFolder* pFolder = (CFolder *)cookie;
      FOLDER_TYPES fldType = pFolder->GetType();

      if ( fldType == LOCATIONS ||
           fldType == PROFILE ) {

         //Raid #483251, Yanggao, 10/19/2001
         //If there is any property page opened under this folder, this folder is not
         //allowed to be deleted.
         if( CSnapin::m_PropertyPageList.GetCount() > 0)
         {
            CString szInfFile = pFolder->GetInfFile();
            if(fldType==LOCATIONS)
                szInfFile = pFolder->GetName();  
            szInfFile.MakeLower(); 
            POSITION newpos = CSnapin::m_PropertyPageList.GetHeadPosition();
            int nCount = (int)CSnapin::m_PropertyPageList.GetCount();
            CResult* pItem = NULL;

            while( nCount > 0 && newpos )
            {
               pItem = CSnapin::m_PropertyPageList.GetNext(newpos);
               if( pItem && szInfFile)
               {
                  pItem->m_strInfFile.MakeLower();    
                  if( _wcsicmp(pItem->m_strInfFile, szInfFile) == 0 ||
                      pItem->m_strInfFile.Find(szInfFile) == 0 )
                  {
                     CString msg;
                     msg.LoadString(IDS_NOT_DELETE_ITEM);
                     AfxMessageBox(msg, MB_OK|MB_ICONERROR); //Raid #491120, yanggao
                     return S_OK;
                  }
               }
               nCount--;
            }
         }

         CString str;
         str.Format(IDS_DELETE_CONFIRM,pFolder->GetName() );

         if ( IDYES == AfxMessageBox((LPCTSTR)str, MB_YESNO, 0) ) {
            //
            // delete the nodes and all related children info
            //
            if ( fldType == PROFILE ) {
               if (CAttribute::m_nDialogs > 0) {
                  CString str;
                  AfxFormatString1(str,IDS_CLOSE_PAGES,pFolder->GetName());
                  AfxMessageBox(str,MB_OK);
                  hr = S_FALSE;
               } else {
                  //
                  // delete a single inf file
                  //
                  if( DeleteFile(pFolder->GetInfFile()) ) //Raid #668270, yanggao, 8/9/2002
                  {
                     hr = DeleteOneTemplateNodes(cookie);
                  }
                  else
                  {
                     LPTSTR lpMsgBuf;
                     FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 GetLastError(),
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR)&lpMsgBuf,
                                 0,
                                 NULL
                                 );
                     AppMessageBox(NULL, lpMsgBuf, NULL, MB_ICONSTOP|MB_OK);
                     if ( lpMsgBuf != NULL )
                     {
                        LocalFree(lpMsgBuf);
                     }
                     hr = S_FALSE;
                  }
               }

            } else {
               //
               // delete a registry path from SCE
               //
               CRegKey regkeySCE;
               CString tmpstr;
               tmpstr.LoadString(IDS_TEMPLATE_LOCATION_KEY);
               LONG lRes;

               lRes = regkeySCE.Open(HKEY_LOCAL_MACHINE, tmpstr);
               if (lRes == ERROR_SUCCESS) {
                  OnDeleteHelper(regkeySCE,pFolder->GetName());
               }
               //
               // Bug 375324: Delete from HKCU as well as HKLM
               //
               lRes = regkeySCE.Open(HKEY_CURRENT_USER, tmpstr);
               if (lRes == ERROR_SUCCESS) {
                  OnDeleteHelper(regkeySCE,pFolder->GetName());
               }

               MMC_COOKIE FindCookie=FALSE;
               HSCOPEITEM pItemChild;

               pItemChild = NULL;
               hr = m_pScope->GetChildItem(pFolder->GetScopeItem()->ID, &pItemChild, &FindCookie);
               //
               // find a child item
               //
               while ( pItemChild ) {
                  if ( FindCookie ) {
                     //
                     // find a template, delete it
                     //
                     DeleteOneTemplateNodes(FindCookie);
                  }

                  // get next pointer
                  pItemChild = NULL;
                  FindCookie = FALSE;
                  hr = m_pScope->GetChildItem( pFolder->GetScopeItem()->ID, &pItemChild, &FindCookie);

               }
               //
               // delete this location node
               //
               DeleteThisNode(pFolder);

            }

         }
      }
      FREE_INTERNAL(pInternal);
   }

   return hr;
}


HRESULT CComponentDataImpl::DeleteOneTemplateNodes(MMC_COOKIE cookie)
{

   if ( !cookie ) {
      return S_OK;
   }

   CFolder *pFolder = (CFolder *)cookie;

   //
   // delete the template info first, this will delete handles
   // associated with any extension services
   //
   if ( pFolder->GetInfFile() ) {

      DeleteTemplate(pFolder->GetInfFile());

   }
   //
   // delete the scope items and m_scopeItemList (for all children)
   //
   DeleteChildrenUnderNode(pFolder);

   //
   // delete this location node
   //
   DeleteThisNode(pFolder);

   return S_OK;

}

void CComponentDataImpl::DeleteTemplate(CString infFile)
{

   PEDITTEMPLATE pTemplateInfo = NULL;

   CString stri = infFile;
   stri.MakeLower();

   if ( m_Templates.Lookup(stri, pTemplateInfo) ) {

      m_Templates.RemoveKey(stri);

      if ( pTemplateInfo ) {

         if ( pTemplateInfo->pTemplate ) //Raid 494837, yanggao
         {
            SceFreeProfileMemory(pTemplateInfo->pTemplate);
            pTemplateInfo->pTemplate = NULL;
         }

         delete pTemplateInfo;
      }
   }
}


void CSnapin::CreateProfilePolicyResultList(MMC_COOKIE cookie,
                                            FOLDER_TYPES type,
                                            PEDITTEMPLATE pSceInfo,
                                            LPDATAOBJECT pDataObj)
{
   if ( !pSceInfo ) {
      return;
   }

   bool bVerify=false;
   UINT i;
   DWORD curVal;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   switch ( type ) {
      case POLICY_PASSWORD:

         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MaximumPasswordAge, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MinimumPasswordAge, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN, SCE_NO_VALUE,
                       pSceInfo->pTemplate->MinimumPasswordLength, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->PasswordHistorySize, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX, SCE_NO_VALUE,
                       pSceInfo->pTemplate->PasswordComplexity, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

// NT5 new flag
         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ClearTextPassword, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON, SCE_NO_VALUE,
                       pSceInfo->pTemplate->RequireLogonToChangePassword, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

#endif
         break;

      case POLICY_KERBEROS:
         if (!VerifyKerberosInfo(pSceInfo->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_MAX_CLOCK,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_RENEWAL,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_MAX_AGE,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_PROF_DW,-1,cookie,bVerify,pSceInfo,pDataObj);
         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,SCE_NO_VALUE,
                       pSceInfo->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_PROF_BOOL,-1,cookie,bVerify,pSceInfo,pDataObj);
         break;

      case POLICY_LOCKOUT:

         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LockoutBadCount, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ResetLockoutCount, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LockoutDuration, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

         break;

      case POLICY_AUDIT:

         //
         // Event auditing
         //
         //        if ( pSceInfo->pTemplate->EventAuditingOnOff)
         //           curVal = 1;
         //        else
         //           curVal = 0;
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, SCE_NO_VALUE,
         //                      pSceInfo->pTemplate->EventAuditingOnOff, ITEM_PROF_BON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditSystemEvents, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditLogonEvents, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditObjectAccess, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditPrivilegeUse, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditPolicyChange, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditAccountManage, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditProcessTracking, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit directory service access"
         AddResultItem(IDS_DIRECTORY_ACCESS, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditDSAccess, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Audit Account Logon"
         AddResultItem(IDS_ACCOUNT_LOGON, SCE_NO_VALUE,
                       pSceInfo->pTemplate->AuditAccountLogon, ITEM_PROF_B2ON, -1, cookie, bVerify,pSceInfo,pDataObj);

         break;

      case POLICY_OTHER:

         //
         // Account Logon category
         //
         // L"Force logoff when logon hour expire", L""
         AddResultItem(IDS_FORCE_LOGOFF, SCE_NO_VALUE,
                       pSceInfo->pTemplate->ForceLogoffWhenHourExpire, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Accounts: Administrator account status", L""
         AddResultItem(IDS_ENABLE_ADMIN, SCE_NO_VALUE,
                       pSceInfo->pTemplate->EnableAdminAccount, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"Accounts: Guest account status", L""
         AddResultItem(IDS_ENABLE_GUEST, SCE_NO_VALUE,
                       pSceInfo->pTemplate->EnableGuestAccount, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         // L"New Administrator account name"
         AddResultItem(IDS_NEW_ADMIN, 0,
                       (LONG_PTR)(LPCTSTR)pSceInfo->pTemplate->NewAdministratorName,
                       ITEM_PROF_SZ, -1, cookie,bVerify,pSceInfo,pDataObj);

         // L"New Guest account name"
         AddResultItem(IDS_NEW_GUEST, NULL,
                       (LONG_PTR)(LPCTSTR)pSceInfo->pTemplate->NewGuestName,
                       ITEM_PROF_SZ, -1, cookie,bVerify,pSceInfo,pDataObj);

         // L"Network access: Allow anonymous SID/Name translation"
         AddResultItem(IDS_LSA_ANON_LOOKUP, SCE_NO_VALUE,
                       pSceInfo->pTemplate->LSAAnonymousNameLookup, ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);

         CreateProfileRegValueList(cookie, pSceInfo, pDataObj);

         break;

      case POLICY_LOG:
         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {

            // L"... Log Maximum Size", L"KBytes"
            AddResultItem(IdsMax[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->MaximumLogSize[i], ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->AuditLogRetentionPeriod[i], ITEM_PROF_RET, -1, cookie, bVerify,pSceInfo,pDataObj);

			//
			// AuditLogRetentionPeriod has already been interpreted by the 
			// SCE engine into the RetentionDays setting. So, the RSOP UI 
			// should display RetentionDays if it exists in the WMI db.
			//

//            if ( pSceInfo->pTemplate->AuditLogRetentionPeriod[i] == 1) {
//               curVal = pSceInfo->pTemplate->RetentionDays[i];
//            } else {
//               curVal = SCE_NO_VALUE;
//            }
            // L"... Log Retention days", "days"
//            AddResultItem(IdsDays[i], SCE_NO_VALUE, curVal, ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);
            AddResultItem(IdsDays[i], SCE_NO_VALUE, 
					pSceInfo->pTemplate->RetentionDays[i], ITEM_PROF_DW, -1, cookie, bVerify,pSceInfo,pDataObj);

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i], SCE_NO_VALUE,
                          pSceInfo->pTemplate->RestrictGuestAccess[i], ITEM_PROF_BOOL, -1, cookie, bVerify,pSceInfo,pDataObj);
         }

         break;
   }

}


void
CSnapin::CreateAnalysisPolicyResultList(MMC_COOKIE cookie,
                                        FOLDER_TYPES type,
                                        PEDITTEMPLATE pSceInfo,
                                        PEDITTEMPLATE pBase,
                                        LPDATAOBJECT pDataObj )
{
   if ( !pSceInfo || !pBase ) {
      AddResultItem(IDS_ERROR_NO_ANALYSIS_INFO,NULL,NULL,ITEM_OTHER,-1,cookie);
      return;
   }

   bool bVerify=true;
   UINT i;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   DWORD status;
   LONG_PTR setting;

   switch ( type ) {
      case POLICY_PASSWORD_ANALYSIS:
         //
         // password category
         //
         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE,
                       pSceInfo->pTemplate->MaximumPasswordAge,
                       pBase->pTemplate->MaximumPasswordAge,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

            // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE,
                       pSceInfo->pTemplate->MinimumPasswordAge,
                       pBase->pTemplate->MinimumPasswordAge,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN,
                       pSceInfo->pTemplate->MinimumPasswordLength,
                       pBase->pTemplate->MinimumPasswordLength,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS,
                       pSceInfo->pTemplate->PasswordHistorySize,
                       pBase->pTemplate->PasswordHistorySize,
                       ITEM_DW,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX,
                       pSceInfo->pTemplate->PasswordComplexity,
                       pBase->pTemplate->PasswordComplexity,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD,
                       pSceInfo->pTemplate->ClearTextPassword,
                       pBase->pTemplate->ClearTextPassword,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON,
                       pSceInfo->pTemplate->RequireLogonToChangePassword,
                       pBase->pTemplate->RequireLogonToChangePassword,
                       ITEM_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#endif
         break;
      case POLICY_KERBEROS_ANALYSIS:
         if (!VerifyKerberosInfo(pSceInfo->pTemplate) ||
             !VerifyKerberosInfo(pBase->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxServiceAge,
                       pBase->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_CLOCK,
                       pSceInfo->pTemplate->pKerberosInfo->MaxClockSkew,
                       pBase->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,
                       pSceInfo->pTemplate->pKerberosInfo->TicketValidateClient,
                       pBase->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_BOOL,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_RENEWAL,
                       pSceInfo->pTemplate->pKerberosInfo->MaxRenewAge,
                       pBase->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_AGE,
                       pSceInfo->pTemplate->pKerberosInfo->MaxTicketAge,
                       pBase->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_DW,-1,cookie,bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case POLICY_LOCKOUT_ANALYSIS:
         //
         // Account Lockout category
         //
         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT, pSceInfo->pTemplate->LockoutBadCount,
                       pBase->pTemplate->LockoutBadCount, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT, pSceInfo->pTemplate->ResetLockoutCount,
                       pBase->pTemplate->ResetLockoutCount, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION, pSceInfo->pTemplate->LockoutDuration,
                       pBase->pTemplate->LockoutDuration, ITEM_DW, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case POLICY_AUDIT_ANALYSIS:
         //
         // Event auditing
         //
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, pSceInfo->pTemplate->EventAuditingOnOff,
         //                   pBase->pTemplate->EventAuditingOnOff, ITEM_BON, 1, cookie, bVerify);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT, pSceInfo->pTemplate->AuditSystemEvents,
                       pBase->pTemplate->AuditSystemEvents, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT, pSceInfo->pTemplate->AuditLogonEvents,
                       pBase->pTemplate->AuditLogonEvents, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS, pSceInfo->pTemplate->AuditObjectAccess,
                       pBase->pTemplate->AuditObjectAccess, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE, pSceInfo->pTemplate->AuditPrivilegeUse,
                       pBase->pTemplate->AuditPrivilegeUse, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE, pSceInfo->pTemplate->AuditPolicyChange,
                       pBase->pTemplate->AuditPolicyChange, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE, pSceInfo->pTemplate->AuditAccountManage,
                       pBase->pTemplate->AuditAccountManage, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK, pSceInfo->pTemplate->AuditProcessTracking,
                       pBase->pTemplate->AuditProcessTracking, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit directory access "
         AddResultItem(IDS_DIRECTORY_ACCESS, pSceInfo->pTemplate->AuditDSAccess,
                       pBase->pTemplate->AuditDSAccess, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit account logon"
         AddResultItem(IDS_ACCOUNT_LOGON, pSceInfo->pTemplate->AuditAccountLogon,
                       pBase->pTemplate->AuditAccountLogon, ITEM_B2ON, 1, cookie, bVerify,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane
         break;

      case POLICY_LOG_ANALYSIS:

         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {
            // Maximum Log Size
            AddResultItem(IdsMax[i], pSceInfo->pTemplate->MaximumLogSize[i],
                          pBase->pTemplate->MaximumLogSize[i], ITEM_DW, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i], pSceInfo->pTemplate->AuditLogRetentionPeriod[i],
                          pBase->pTemplate->AuditLogRetentionPeriod[i], ITEM_RET, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            if ( pSceInfo->pTemplate->AuditLogRetentionPeriod[i] == 1 ||
                 pBase->pTemplate->AuditLogRetentionPeriod[i] == 1)
               // L"... Log Retention days", "days"
               AddResultItem(IdsDays[i], pSceInfo->pTemplate->RetentionDays[i],
                             pBase->pTemplate->RetentionDays[i], ITEM_DW, 1, cookie, bVerify,
                             pBase,               //The template to save this attribute in
                             pDataObj);           //The data object for the scope note who owns the result pane

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i], pSceInfo->pTemplate->RestrictGuestAccess[i],
                          pBase->pTemplate->RestrictGuestAccess[i], ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane
         }

         break;

      case POLICY_OTHER_ANALYSIS:

            // L"Force logoff when logon hour expire", L""
            AddResultItem(IDS_FORCE_LOGOFF, pSceInfo->pTemplate->ForceLogoffWhenHourExpire,
                          pBase->pTemplate->ForceLogoffWhenHourExpire, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"Accounts: Administrator account status", L""
            AddResultItem(IDS_ENABLE_ADMIN, pSceInfo->pTemplate->EnableAdminAccount,
                          pBase->pTemplate->EnableAdminAccount, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"Accounts: Guest account status", L""
            AddResultItem(IDS_ENABLE_GUEST, pSceInfo->pTemplate->EnableGuestAccount,
                          pBase->pTemplate->EnableGuestAccount, ITEM_BOOL, 1, cookie, bVerify,
                          pBase,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

          // L"Network access: Allow anonymous SID/Name translation"
          AddResultItem(IDS_LSA_ANON_LOOKUP, pSceInfo->pTemplate->LSAAnonymousNameLookup,
                        pBase->pTemplate->LSAAnonymousNameLookup, ITEM_BOOL, 1, cookie, bVerify,
                        pBase,               //The template to save this attribute in
                        pDataObj);           //The data object for the scope note who owns the result pane


          // L"New Administrator account name"
         setting = (LONG_PTR)(pSceInfo->pTemplate->NewAdministratorName);
         if ( !pBase->pTemplate->NewAdministratorName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pSceInfo->pTemplate->NewAdministratorName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pBase->pTemplate->NewAdministratorName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_ADMIN, setting,
                       (LONG_PTR)(LPCTSTR)pBase->pTemplate->NewAdministratorName,
                       ITEM_SZ, status, cookie,false,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Guest account name"
         setting = (LONG_PTR)(pSceInfo->pTemplate->NewGuestName);
         if ( !pBase->pTemplate->NewGuestName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pSceInfo->pTemplate->NewGuestName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pBase->pTemplate->NewGuestName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_GUEST, setting,
                       (LONG_PTR)(LPCTSTR)pBase->pTemplate->NewGuestName,
                       ITEM_SZ, status, cookie,false,
                       pBase,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         CreateAnalysisRegValueList(cookie, pSceInfo, pBase, pDataObj,ITEM_REGVALUE);

         break;
   }
}

void
CSnapin::CreateLocalPolicyResultList(MMC_COOKIE cookie,
                                     FOLDER_TYPES type,
                                     PEDITTEMPLATE pLocal,
                                     PEDITTEMPLATE pEffective,
                                     LPDATAOBJECT pDataObj )
{
   if ( !pLocal || !pEffective ) {
      AddResultItem(IDS_ERROR_NO_LOCAL_POLICY_INFO,NULL,NULL,ITEM_OTHER,-1,cookie);
      return;
   }

   bool bVerify= false;
   UINT i;
   UINT IdsMax[]={IDS_SYS_LOG_MAX, IDS_SEC_LOG_MAX, IDS_APP_LOG_MAX};
   UINT IdsRet[]={IDS_SYS_LOG_RET, IDS_SEC_LOG_RET, IDS_APP_LOG_RET};
   UINT IdsDays[]={IDS_SYS_LOG_DAYS, IDS_SEC_LOG_DAYS, IDS_APP_LOG_DAYS};
   UINT IdsGuest[]={IDS_SYS_LOG_GUEST, IDS_SEC_LOG_GUEST, IDS_APP_LOG_GUEST};

   DWORD status;
   LONG_PTR setting;

   switch ( type ) {
      case LOCALPOL_PASSWORD:
         //
         // password category
         //
         // L"Maximum passage age", L"Days"
         AddResultItem(IDS_MAX_PAS_AGE,
                       pEffective->pTemplate->MaximumPasswordAge,
                       pLocal->pTemplate->MaximumPasswordAge,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

            // L"Minimum passage age", L"Days"
         AddResultItem(IDS_MIN_PAS_AGE,
                       pEffective->pTemplate->MinimumPasswordAge,
                       pLocal->pTemplate->MinimumPasswordAge,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Minimum passage length", L"Characters"
         AddResultItem(IDS_MIN_PAS_LEN,
                       pEffective->pTemplate->MinimumPasswordLength,
                       pLocal->pTemplate->MinimumPasswordLength,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password history size", L"Passwords"
         AddResultItem(IDS_PAS_UNIQUENESS,
                       pEffective->pTemplate->PasswordHistorySize,
                       pLocal->pTemplate->PasswordHistorySize,
                       ITEM_LOCALPOL_DW,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Password complexity", L""
         AddResultItem(IDS_PAS_COMPLEX,
                       pEffective->pTemplate->PasswordComplexity,
                       pLocal->pTemplate->PasswordComplexity,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Clear Text Password", L""
         AddResultItem(IDS_CLEAR_PASSWORD,
                       pEffective->pTemplate->ClearTextPassword,
                       pLocal->pTemplate->ClearTextPassword,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#if defined(USE_REQ_LOGON_ITEM)
         // L"Require logon to change password", L""
         AddResultItem(IDS_REQ_LOGON,
                       pEffective->pTemplate->RequireLogonToChangePassword,
                       pLocal->pTemplate->RequireLogonToChangePassword,
                       ITEM_LOCALPOL_BOOL,
                       1,
                       cookie,
                       bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

#endif
         break;

      case LOCALPOL_KERBEROS:
         if (!VerifyKerberosInfo(pLocal->pTemplate) ||
             !VerifyKerberosInfo(pEffective->pTemplate)) {
            AddResultItem(IDS_CANT_DISPLAY_ERROR_OOM,NULL,NULL,ITEM_OTHER,-1,cookie);
            break;
         }
         AddResultItem(IDS_KERBEROS_MAX_SERVICE,
                       pEffective->pTemplate->pKerberosInfo->MaxServiceAge,
                       pLocal->pTemplate->pKerberosInfo->MaxServiceAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_CLOCK,
                       pEffective->pTemplate->pKerberosInfo->MaxClockSkew,
                       pLocal->pTemplate->pKerberosInfo->MaxClockSkew,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_VALIDATE_CLIENT,
                       pEffective->pTemplate->pKerberosInfo->TicketValidateClient,
                       pLocal->pTemplate->pKerberosInfo->TicketValidateClient,
                       ITEM_LOCALPOL_BOOL,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_RENEWAL,
                       pEffective->pTemplate->pKerberosInfo->MaxRenewAge,
                       pLocal->pTemplate->pKerberosInfo->MaxRenewAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         AddResultItem(IDS_KERBEROS_MAX_AGE,
                       pEffective->pTemplate->pKerberosInfo->MaxTicketAge,
                       pLocal->pTemplate->pKerberosInfo->MaxTicketAge,
                       ITEM_LOCALPOL_DW,-1,cookie,bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case LOCALPOL_LOCKOUT:
         //
         // Account Lockout category
         //
         // L"Account lockout count", L"Attempts"
         AddResultItem(IDS_LOCK_COUNT,
                       pEffective->pTemplate->LockoutBadCount,
                       pLocal->pTemplate->LockoutBadCount,ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Reset lockout count after", L"Minutes"
         AddResultItem(IDS_LOCK_RESET_COUNT,
                       pEffective->pTemplate->ResetLockoutCount,
                       pLocal->pTemplate->ResetLockoutCount,
                       ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Lockout duration", L"Minutes"
         AddResultItem(IDS_LOCK_DURATION,
                       pEffective->pTemplate->LockoutDuration,
                       pLocal->pTemplate->LockoutDuration,
                       ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         break;

      case LOCALPOL_AUDIT:
         //
         // Event auditing
         //
         // L"Event Auditing Mode",
         //        AddResultItem(IDS_EVENT_ON, pLocal->pTemplate->EventAuditingOnOff,
         //                   pEffective->pTemplate->EventAuditingOnOff, ITEM_LOCALPOL_BON, 1, cookie, bVerify);

         // L"Audit system events"
         AddResultItem(IDS_SYSTEM_EVENT,
                       pEffective->pTemplate->AuditSystemEvents,
                       pLocal->pTemplate->AuditSystemEvents,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit logon events"
         AddResultItem(IDS_LOGON_EVENT,
                       pEffective->pTemplate->AuditLogonEvents,
                       pLocal->pTemplate->AuditLogonEvents,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Object Access"
         AddResultItem(IDS_OBJECT_ACCESS,
                       pEffective->pTemplate->AuditObjectAccess,
                       pLocal->pTemplate->AuditObjectAccess,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Privilege Use"
         AddResultItem(IDS_PRIVILEGE_USE,
                       pEffective->pTemplate->AuditPrivilegeUse,
                       pLocal->pTemplate->AuditPrivilegeUse,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit policy change"
         AddResultItem(IDS_POLICY_CHANGE,
                       pEffective->pTemplate->AuditPolicyChange,
                       pLocal->pTemplate->AuditPolicyChange,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit Account Manage"
         AddResultItem(IDS_ACCOUNT_MANAGE,
                       pEffective->pTemplate->AuditAccountManage,
                       pLocal->pTemplate->AuditAccountManage,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit process tracking"
         AddResultItem(IDS_PROCESS_TRACK,
                       pEffective->pTemplate->AuditProcessTracking,
                       pLocal->pTemplate->AuditProcessTracking,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit directory access "
         AddResultItem(IDS_DIRECTORY_ACCESS,
                       pEffective->pTemplate->AuditDSAccess,
                       pLocal->pTemplate->AuditDSAccess,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"Audit account logon"
         AddResultItem(IDS_ACCOUNT_LOGON,
                       pEffective->pTemplate->AuditAccountLogon,
                       pLocal->pTemplate->AuditAccountLogon,
                       ITEM_LOCALPOL_B2ON, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane
         break;

      case LOCALPOL_LOG:

         //
         // Event Log setting
         //
         for ( i=0; i<3; i++) {
            // Maximum Log Size
            AddResultItem(IdsMax[i],
                          pEffective->pTemplate->MaximumLogSize[i],
                          pLocal->pTemplate->MaximumLogSize[i],
                          ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            // L"... Log Retention Method",
            AddResultItem(IdsRet[i],
                          pEffective->pTemplate->AuditLogRetentionPeriod[i],
                          pLocal->pTemplate->AuditLogRetentionPeriod[i],
                          ITEM_LOCALPOL_RET, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

            if ( pLocal->pTemplate->AuditLogRetentionPeriod[i] == 1 ||
                 pEffective->pTemplate->AuditLogRetentionPeriod[i] == 1)
               // L"... Log Retention days", "days"
               AddResultItem(IdsDays[i],
                             pEffective->pTemplate->RetentionDays[i],
                             pLocal->pTemplate->RetentionDays[i],
                             ITEM_LOCALPOL_DW, 1, cookie, bVerify,
                             pLocal,               //The template to save this attribute in
                             pDataObj);           //The data object for the scope note who owns the result pane

            // L"RestrictGuestAccess", L""
            AddResultItem(IdsGuest[i],
                          pEffective->pTemplate->RestrictGuestAccess[i],
                          pLocal->pTemplate->RestrictGuestAccess[i],
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane
         }

         break;

      case LOCALPOL_OTHER:

            // L"Force logoff when logon hour expire", L""
         AddResultItem(IDS_FORCE_LOGOFF,
                          pEffective->pTemplate->ForceLogoffWhenHourExpire,
                          pLocal->pTemplate->ForceLogoffWhenHourExpire,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane


            // L"Accounts: Administrator account status", L""
         AddResultItem(IDS_ENABLE_ADMIN,
                          pEffective->pTemplate->EnableAdminAccount,
                          pLocal->pTemplate->EnableAdminAccount,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane


            // L"Accounts: Guest account status", L""
         AddResultItem(IDS_ENABLE_GUEST,
                          pEffective->pTemplate->EnableGuestAccount,
                          pLocal->pTemplate->EnableGuestAccount,
                          ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                          pLocal,               //The template to save this attribute in
                          pDataObj);           //The data object for the scope note who owns the result pane

         // L"Network access: Allow anonymous SID/Name translation"
         AddResultItem(IDS_LSA_ANON_LOOKUP,
                       pEffective->pTemplate->LSAAnonymousNameLookup,
                       pLocal->pTemplate->LSAAnonymousNameLookup,
                       ITEM_LOCALPOL_BOOL, 1, cookie, bVerify,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Administrator account name"
         setting = (LONG_PTR)(pEffective->pTemplate->NewAdministratorName);
         if ( !pLocal->pTemplate->NewAdministratorName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pEffective->pTemplate->NewAdministratorName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pEffective->pTemplate->NewAdministratorName);
            status = SCE_STATUS_GOOD;
         }

         AddResultItem(IDS_NEW_ADMIN, setting,
                       (LONG_PTR)(LPCTSTR)pLocal->pTemplate->NewAdministratorName,
                       ITEM_LOCALPOL_SZ, status, cookie,false,
                       pLocal,              //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         // L"New Guest account name"
         setting = (LONG_PTR)(pEffective->pTemplate->NewGuestName);
         if ( !pLocal->pTemplate->NewGuestName ) {
            status = SCE_STATUS_NOT_CONFIGURED;
         } else if ( pEffective->pTemplate->NewGuestName) {
            status = SCE_STATUS_MISMATCH;
         } else {
            setting = (LONG_PTR)(pEffective->pTemplate->NewGuestName);
            status = SCE_STATUS_GOOD;
         }
         AddResultItem(IDS_NEW_GUEST, setting,
                       (LONG_PTR)(LPCTSTR)pLocal->pTemplate->NewGuestName,
                       ITEM_LOCALPOL_SZ, status, cookie,false,
                       pLocal,               //The template to save this attribute in
                       pDataObj);           //The data object for the scope note who owns the result pane

         CreateAnalysisRegValueList(cookie, pEffective, pLocal, pDataObj,ITEM_LOCALPOL_REGVALUE);

         break;

      case LOCALPOL_PRIVILEGE: {
         // find in the current setting list
          CString strDisp;
          TCHAR szPriv[255];
          TCHAR szDisp[255];
          DWORD cbDisp;
          DWORD dwMatch;
          PSCE_PRIVILEGE_ASSIGNMENT pPrivLocal;
          PSCE_PRIVILEGE_ASSIGNMENT pPrivEffective;

          for ( i=0; i<cPrivCnt; i++ ) {  //Raid #prefast

             cbDisp = 255;
             if ( SCESTATUS_SUCCESS == SceLookupPrivRightName(i,szPriv, (PINT)&cbDisp) ) {
                 // find the local setting
                 for (pPrivLocal=pLocal->pTemplate->OtherInfo.sap.pPrivilegeAssignedTo;
                     pPrivLocal!=NULL;
                     pPrivLocal=pPrivLocal->Next) {

                     if ( _wcsicmp(szPriv, pPrivLocal->Name) == 0 ) {
                         break;
                     }
                 }

                // find the effective setting
                for (pPrivEffective=pEffective->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                    pPrivEffective!=NULL;
                    pPrivEffective=pPrivEffective->Next) {

                    if ( _wcsicmp(szPriv, pPrivEffective->Name) == 0 ) {
                        break;
                    }
                }

                cbDisp = 255;
                GetRightDisplayName(NULL,(LPCTSTR)szPriv,szDisp,&cbDisp);

                LONG itemid = GetUserRightAssignmentItemID(szPriv);
                //
                // Status field is not loaded for local policy mode, except for not configured
                //
                dwMatch = CEditTemplate::ComputeStatus( pPrivLocal, pPrivEffective );

                CResult *pResult = AddResultItem(szDisp,              // The name of the attribute being added
                              (LONG_PTR)pPrivEffective,  // The local policy setting of the attribute
                              (LONG_PTR)pPrivLocal,      // The effective policy setting of the attribute
                              ITEM_LOCALPOL_PRIVS,       // The type of of the attribute's data
                              dwMatch,                   // The mismatch status of the attribute
                              cookie,                    // The cookie for the result item pane
                              FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
                              szPriv,                    // The units the attribute is set in
                              0,                         // An id to let us know where to save this attribute
                              pLocal,                    // The template to save this attribute in
                              pDataObj,                  // The data object for the scope note who owns the result pane
                              NULL,
                              itemid);                   // Assign an ID to this item
             }
         }

         break;
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     TransferAnalysisName
//
//  Synopsis:   Copy a name data from the last inspection information to the
//              computer template
//
//  Arguments:  [dwItem]  - The id of the item to copy
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::TransferAnalysisName(LONG_PTR dwItem)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;
   PSCE_PROFILE_INFO pBaseInfo;

   pet = GetTemplate(GT_LAST_INSPECTION,AREA_SECURITY_POLICY);
   if (!pet) {
      return;
   }
   pProfileInfo = pet->pTemplate;

   pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
   if (!pet) {
      return;
   }
   pBaseInfo = pet->pTemplate;

   switch ( dwItem ) {
      case IDS_NEW_GUEST:
         if ( pProfileInfo->NewGuestName ) {
            LocalFree(pProfileInfo->NewGuestName);
         }

         pProfileInfo->NewGuestName = pBaseInfo->NewGuestName;
         pBaseInfo->NewGuestName = NULL;

         break;
      case IDS_NEW_ADMIN:
         if ( pProfileInfo->NewAdministratorName ) {
            LocalFree(pProfileInfo->NewAdministratorName);
         }

         pProfileInfo->NewAdministratorName = pBaseInfo->NewAdministratorName;
         pBaseInfo->NewAdministratorName = NULL;
         break;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\dsobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "util.h"
#include "servperm.h"
#include "addobj.h"
#include "wrapper.h"

//#include <objsel.h>
//#include <ntdsapi.h>
//#include <dsgetdc.h>
#include <initguid.h>

#include <cmnquery.h>
#include <dsquery.h>
#include <dsclient.h>

static CLIPFORMAT g_cfDsObjectNames = 0;

#if USE_DS
HRESULT MyDsFindDsObjects(
                         IN LPTSTR pMyScope,
                         OUT PDWORD pCount,
                         OUT LPTSTR **ppSelObjs
                         );

HRESULT MyDsFreeObjectBuffer(
                            IN DWORD nCount,
                            IN LPTSTR *pSelObjs
                            );
#endif
//
// in snapmgr.cpp
//
int BrowseCallbackProc(HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData);

HRESULT CComponentDataImpl::AddAnalysisFolderToList(LPDATAOBJECT lpDataObject,
                                                    MMC_COOKIE cookie,
                                                    FOLDER_TYPES folderType)
{
   PEDITTEMPLATE pet = NULL;
   PSCE_PROFILE_INFO pProfileInfo = NULL;

   PVOID pHandle = SadHandle;
   if ( !pHandle ) {
      return E_INVALIDARG;
   }

   //
   // to select a folder.
   //

   BROWSEINFO bi;
   CString strTitle;
   LPITEMIDLIST pidlRoot = NULL;

   if (FAILED(SHGetSpecialFolderLocation(m_hwndParent,CSIDL_DRIVES,&pidlRoot))) {
      return E_FAIL;
   }

   ZeroMemory(&bi,sizeof(bi));
   bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_BROWSEINCLUDEFILES | BIF_EDITBOX | BIF_NEWDIALOGSTYLE;
   bi.lpfn = BrowseCallbackProc;
   strTitle.LoadString(IDS_ADDFILESANDFOLDERS_TITLE);
   bi.lpszTitle = strTitle;
   bi.hwndOwner = m_hwndParent;
   bi.pidlRoot = pidlRoot;

   LPITEMIDLIST pidlLocation = NULL;

   pidlLocation = SHBrowseForFolder(&bi); //Is it a safe usage?

   if (!pidlLocation) {
      return E_FAIL;
   }

   CString strPath;
   LPMALLOC pMalloc = NULL;

   SHGetPathFromIDList(pidlLocation,strPath.GetBuffer(MAX_PATH));
   strPath.ReleaseBuffer();

   if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
      pMalloc->Free(pidlLocation);
      pMalloc->Free(pidlRoot);
      pMalloc->Release();
   }

   HRESULT hr=E_FAIL;

   if ( strPath.GetLength() ) {

      PSECURITY_DESCRIPTOR pSelSD=NULL;
      SECURITY_INFORMATION SelSeInfo = 0;
      BYTE ConfigStatus = 0;
      if (GetAddObjectSecurity(  m_hwndParent,
                                 strPath,
                                 TRUE,
                                 SE_FILE_OBJECT,
                                 pSelSD,
                                 SelSeInfo,
                                 ConfigStatus
                                 ) == E_FAIL) {

         return hr;
      }
      //
      // only add the object(s) if a security descriptor is selected
      //
      if ( pSelSD && SelSeInfo ) {

         //
         // add to the engine directly
         //
         SCESTATUS sceStatus=SCESTATUS_SUCCESS;
         BYTE AnalStatus;

         //
         // start the transaction if it's not started
         //
         if ( EngineTransactionStarted() ) {

            sceStatus =  SceUpdateObjectInfo(  pHandle,
                                               AREA_FILE_SECURITY,
                                               (LPTSTR)(LPCTSTR)strPath,
                                               strPath.GetLength(), // number of characters
                                               ConfigStatus,
                                               TRUE,
                                               pSelSD,
                                               SelSeInfo,
                                               &AnalStatus
                                               );

            if ( SCESTATUS_SUCCESS == sceStatus &&
                 (pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_FILE_SECURITY))) {

               pProfileInfo = pet->pTemplate;
               //
               // just free the object list and unmark the area
               // so when the node is clicked, the profile info
               // will be reloaded
               //
               SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
               pProfileInfo->pFiles.pOneLevel = NULL;
               pet->ClearArea(AREA_FILE_SECURITY);

               pet->SetDirty(AREA_FILE_SECURITY);

            }

            if ( SCESTATUS_SUCCESS == sceStatus ) {
               hr = S_OK;
            }

         } else {
            //
            // transaction can't be started to update the object
            //
            hr = E_FAIL;
         }

      } // if no SD is selected, the object won't be added

      if ( pSelSD ) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      if ( FAILED(hr) ) {
         CString str;
         str.LoadString(IDS_CANT_ADD_FOLDER);
         AfxMessageBox(str);
      }

   } // cancel is clicked
   return hr;

}

/*-------------------------------------------------------------------------------------
Method:         CComponentDataImpl::GetAddObjectSecurity

Synopsis:       Gets security information for files and folders that are begin added.

Arguments:      [hwndParent]    - [in] Parent of the dialogs displayed.
                        [strFile]               - [in] File to display in the dialogs.
                        [bContainer]    - [in] Container security or not.
                        [pSelSD]                - [out] Security descriptor.
                        [SelSeInfo]             - [out] Se info.
                        [ConfigStatus]  - [out] Status of the configration

Returns:
                S_OK            - Operation was successful
                S_FAIL          - Operation was canceled.
-------------------------------------------------------------------------------------*/
HRESULT
CComponentDataImpl::GetAddObjectSecurity(
                                        HWND hwndParent,
                                        LPCTSTR strFile,
                                        BOOL bContainer,
                                        SE_OBJECT_TYPE seType,
                                        PSECURITY_DESCRIPTOR &pSelSD,
                                        SECURITY_INFORMATION &SelSeInfo,
                                        BYTE &ConfigStatus
                                        )
{

   if (!strFile || !lstrlen(strFile)) {
      return E_FAIL;
   }

   //
   // Default values.
   //
   DWORD SDSize;

   pSelSD = NULL;
   SelSeInfo = NULL;

   ConfigStatus = 0;
   INT_PTR nRet;
   //
   // Bring up the ACL editor.
   //
   nRet =  MyCreateSecurityPage2(  bContainer,
                                   &pSelSD,
                                   &SelSeInfo,
                                   (LPCTSTR)strFile,
                                   seType,
                                   CONFIG_SECURITY_PAGE,
                                   hwndParent,
                                   FALSE    // not modeless
                                );

   if (nRet == -1) {
      if (pSelSD) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      CString str;
      str.LoadString(IDS_CANT_ASSIGN_SECURITY);
      AfxMessageBox(str);
      return E_FAIL;
   }

   if (nRet <= 0) {
      if (pSelSD) {
         LocalFree(pSelSD);
         pSelSD = NULL;
      }
      return E_FAIL;
   }

   if ( !pSelSD ) {

      //
      // if no security is selected, use Everyone Full control
      //
      if ( SE_FILE_OBJECT == seType ) {
         GetDefaultFileSecurity(&pSelSD,&SelSeInfo);
      } else {
         GetDefaultRegKeySecurity(&pSelSD,&SelSeInfo);
      }
   }

   //
   // Bring up the object editor.
   //
   CWnd *pWnd = NULL;
   BOOL bAllocWnd = FALSE;

   if (hwndParent) {
      pWnd = CWnd::FromHandlePermanent( hwndParent );
      if (pWnd == NULL) {
         pWnd = new CWnd;
         if (!pWnd) {
             if (pSelSD) {
                LocalFree(pSelSD);
                pSelSD = NULL;
             }
            return E_FAIL;
         }
         bAllocWnd = TRUE;
         pWnd->Attach(hwndParent);
      }
   }

   CAddObject theObjAcl(
                       seType,
                       (LPTSTR)(LPCTSTR)strFile,
                       TRUE,
                       pWnd
                       );


   //
   // CAddObject frees these pointers
   //
   theObjAcl.SetSD(pSelSD);
   pSelSD = NULL;
   theObjAcl.SetSeInfo(SelSeInfo);
   SelSeInfo = NULL;

   CThemeContextActivator activator;
   nRet =  theObjAcl.DoModal();
   if (bAllocWnd) {
      pWnd->Detach();
      delete pWnd;
   }

   if (nRet == IDOK ) {

      pSelSD = theObjAcl.GetSD();
      SelSeInfo = theObjAcl.GetSeInfo();
      ConfigStatus = theObjAcl.GetStatus();

      return S_OK;
   }

   if ( pSelSD ) {
      LocalFree(pSelSD);
      pSelSD = NULL;
   }

   return E_FAIL;
}

HRESULT CComponentDataImpl::AddAnalysisFilesToList(LPDATAOBJECT lpDataObject,MMC_COOKIE cookie, FOLDER_TYPES folderType)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   PVOID pHandle = SadHandle;
   if ( !pHandle ) {
      return E_INVALIDARG;
   }

   HRESULT hr=E_FAIL;

   //
   // to select a file.
   //

   CFileDialog fd(true,
                  NULL,
                  NULL,
                  OFN_DONTADDTORECENT|
                  OFN_ALLOWMULTISELECT);
   CThemeContextActivator activator;
   if (IDOK == fd.DoModal()) {

      POSITION pos = fd.GetStartPosition();

      if ( pos ) {
         //
         // if anyone is selected, invoke acl editor
         //
         CString strPath = fd.GetNextPathName(pos);

         if ( strPath.GetLength() ) {

            PSECURITY_DESCRIPTOR pSelSD=NULL;
            SECURITY_INFORMATION SelSeInfo = 0;
            BYTE ConfigStatus = 0;

            if( GetAddObjectSecurity(  m_hwndParent,
                                            strPath,
                                            TRUE,
                                            SE_FILE_OBJECT,
                                            pSelSD,
                                            SelSeInfo,
                                            ConfigStatus
                                            ) == E_FAIL ){

                    return S_OK;
            }

            if ( pSelSD && SelSeInfo ) {
               //
               // only add the object(s) if a security descriptor is selected
               //
               SCESTATUS sceStatus=SCESTATUS_SUCCESS;

               //
               // start the transaction if it's not started
               //
               if ( EngineTransactionStarted() ) {

                   do {
                      //
                      // add to the engine directly
                      //
                      BYTE AnalStatus;

                      sceStatus =  SceUpdateObjectInfo(
                                                      pHandle,
                                                      AREA_FILE_SECURITY,
                                                      (LPTSTR)(LPCTSTR)strPath,
                                                      strPath.GetLength(), // number of characters
                                                      ConfigStatus,
                                                      FALSE,
                                                      pSelSD,
                                                      SelSeInfo,
                                                      &AnalStatus
                                                      );

                      if ( SCESTATUS_SUCCESS == sceStatus &&
                           (pet = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_FILE_SECURITY))) {

                        pProfileInfo = pet->pTemplate;
                         //
                         // just free the object list and unmark the area
                         // so when the node is clicked, the profile info
                         // will be reloaded
                         //
                         SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
                         pProfileInfo->pFiles.pOneLevel = NULL;
                         pet->ClearArea(AREA_FILE_SECURITY);

                         pet->SetDirty(AREA_FILE_SECURITY);

                      }

                      if ( SCESTATUS_SUCCESS != sceStatus ) {
                          CString str;
                          str.LoadString(IDS_SAVE_FAILED);
                         AfxMessageBox(str);
                         break;
                      }

                   } while (pos && (strPath = fd.GetNextPathName(pos)) );

                   if ( SCESTATUS_SUCCESS == sceStatus ) {
                      hr = S_OK;
                   }

               } else {
                   //
                   // no transaction is started to update the object
                   //
                   hr = E_FAIL;
               }

            } // if no SD is selected, the object won't be added

            if ( pSelSD ) {
               LocalFree(pSelSD);
               pSelSD = NULL;
            }

            if ( FAILED(hr) ) {
                CString str;
                str.LoadString(IDS_CANT_ADD_FILE);
               AfxMessageBox(str);
            }
         }
      }

   }

   return hr;
}

HRESULT CComponentDataImpl::UpdateScopeResultObject(LPDATAOBJECT pDataObj,
                                         MMC_COOKIE cookie,
                                         AREA_INFORMATION area)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   if ( !cookie || area != AREA_REGISTRY_SECURITY ) {
      return E_INVALIDARG;
   }

   pet = GetTemplate(GT_COMPUTER_TEMPLATE,area);
   if ( pet ) {
      pProfileInfo = pet->pTemplate;
      //
      // just free the object list and unmark the area
      // so when the node is clicked, the profile info
      // will be reloaded
      //
      switch ( area ) {
         case AREA_REGISTRY_SECURITY:

            SceFreeMemory((PVOID)(pProfileInfo->pRegistryKeys.pOneLevel), SCE_STRUCT_OBJECT_LIST);
            pProfileInfo->pRegistryKeys.pOneLevel = NULL;
            break;
         case AREA_FILE_SECURITY:
            SceFreeMemory((PVOID)(pProfileInfo->pFiles.pOneLevel), SCE_STRUCT_OBJECT_LIST);
            pProfileInfo->pFiles.pOneLevel = NULL;
            break;

         default:
            return E_INVALIDARG;
      }

      pet->ClearArea(area);

      CFolder *pFolder = (CFolder *)cookie;

      DeleteChildrenUnderNode(pFolder);

      if ( pFolder->IsEnumerated() ) {
         pFolder->Set(FALSE);
         EnumerateScopePane(cookie,pFolder->GetScopeItem()->ID);
      }

      pFolder->RemoveAllResultItems();
      m_pConsole->UpdateAllViews(NULL,(LONG_PTR)pFolder,UAV_RESULTITEM_UPDATEALL);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\edittemp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       edittemp.cpp
//
//  Contents:   CEditTemplate class to handle editing of SCE's INF files
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "edittemp.h"
#include "util.h"
#include "snapmgr.h"
#include <secedit.h>
#include "wrapper.h"
#include "wmihooks.h"

#include <sceattch.h>
#include <locale.h>

//+--------------------------------------------------------------------------
//
//  Method:     AddService
//
//  Synopsis:   Adds a service attachment to the template
//
//  Arguments:  [szService]    - [in] the name of the new service
//              [pPersistInfo] - [in] A pointer to the service extensions'
//                                    persistance interface
//
//  Returns:    TRUE if successfull, FALSE if either argument is null
//
//  Modifies:   m_Services
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::AddService(LPCTSTR szService, LPSCESVCATTACHMENTPERSISTINFO pPersistInfo) {
   if (!szService || !pPersistInfo) {
      return FALSE;
   }
   m_Services.SetAt(szService,pPersistInfo);
   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     IsDirty
//
//  Synopsis:   Queries whether or not there is unsaved data in the template
//
//  Returns:    TRUE if there is unsaved information, FALSE otherwise
//
//  Modifies:
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::IsDirty() {

   //
   // Some area is dirty
   //
   if (0 != m_AreaDirty) {
      return TRUE;
   }

   //
   // Loop through services until we find one that is dirty
   // or there are no more to check.
   //
   CString strService;
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   POSITION pos;

   pos = m_Services.GetStartPosition();
   while (pos) {
      m_Services.GetNextAssoc(pos,strService,pAttachPI);
      if (pAttachPI && (S_OK == pAttachPI->IsDirty(m_szInfFile))) {
         return TRUE;
      }
   }

   //
   // We didn't find anything dirty
   //
   return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     SetDirty
//
//  Synopsis:   Notify the template that some data within it has been changed.
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  Modifies:
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetDirty(AREA_INFORMATION Area) {
   DWORD AreaDirtyOld;

   AreaDirtyOld = m_AreaDirty;

   m_AreaDirty |= Area;

   //
   // If the template is supposed to immediately save any changes then
   // do so.
   //
   if (QueryWriteThrough() && !m_bLocked) {
      SetWriteThroughDirty(TRUE);

      if (Save()) {
         //
         // #204628 - don't call PolicyChanged twiced when writing through
         // Call it in SetDirty and then skip it in Save, so we don't call it
         // once in SetDirty's call to Save and a second time when Save is called
         // on its own
         //
         // #204779 - call the notification window rather than directly calling
         // the IGPEInformation interface
         //
         if (m_pNotify && QueryPolicy()) {
            m_pNotify->RefreshPolicy();
         }
      } else {
         m_AreaDirty = AreaDirtyOld;
         return FALSE;
      }
   }

   return TRUE;
}

//+--------------------------------------------------------------------------------------
// CEditTemplate::SetTemplateDefaults
//
// The caller will have to remove all memory objects used by this template if
// this function
// is called.  Everything becomes NULL and nothing is freed.
//+--------------------------------------------------------------------------------------
void CEditTemplate::SetTemplateDefaults()
{
   //
   // Local Policy Changes.  Initialize everything to not changed
   //
   SCE_PROFILE_INFO *ppi = pTemplate;

   m_AreaLoaded = 0;
   m_AreaDirty = 0;
   if(!ppi){
      ppi = pTemplate = (PSCE_PROFILE_INFO) LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
      if (!pTemplate) {
         return;
      }
   }

   //
   // Must keep to type of this template.
   //
   SCETYPE dwType = ppi->Type;
   PSCE_KERBEROS_TICKET_INFO pKerberosInfo = ppi->pKerberosInfo;

   ZeroMemory( ppi, sizeof(SCE_PROFILE_INFO));
   ppi->Type = dwType;

   //
   // Set defaults to the rest of the template.
   //
   ppi->MinimumPasswordAge=SCE_NO_VALUE;
   ppi->MaximumPasswordAge=SCE_NO_VALUE;
   ppi->MinimumPasswordLength=SCE_NO_VALUE;
   ppi->PasswordComplexity=SCE_NO_VALUE;
   ppi->PasswordHistorySize=SCE_NO_VALUE;
   ppi->LockoutBadCount=SCE_NO_VALUE;
   ppi->ResetLockoutCount=SCE_NO_VALUE;
   ppi->LockoutDuration=SCE_NO_VALUE;
   ppi->RequireLogonToChangePassword=SCE_NO_VALUE;
   ppi->ForceLogoffWhenHourExpire=SCE_NO_VALUE;
   ppi->EnableAdminAccount=SCE_NO_VALUE;
   ppi->EnableGuestAccount=SCE_NO_VALUE;
   ppi->ClearTextPassword=SCE_NO_VALUE;
   ppi->LSAAnonymousNameLookup=SCE_NO_VALUE;
   for (int i=0;i<3;i++) {
      ppi->MaximumLogSize[i]=SCE_NO_VALUE;
      ppi->AuditLogRetentionPeriod[i]=SCE_NO_VALUE;
      ppi->RetentionDays[i]=SCE_NO_VALUE;
      ppi->RestrictGuestAccess[i]=SCE_NO_VALUE;
   }
   ppi->AuditSystemEvents=SCE_NO_VALUE;
   ppi->AuditLogonEvents=SCE_NO_VALUE;
   ppi->AuditObjectAccess=SCE_NO_VALUE;
   ppi->AuditPrivilegeUse=SCE_NO_VALUE;
   ppi->AuditPolicyChange=SCE_NO_VALUE;
   ppi->AuditAccountManage=SCE_NO_VALUE;
   ppi->AuditProcessTracking=SCE_NO_VALUE;
   ppi->AuditDSAccess=SCE_NO_VALUE;
   ppi->AuditAccountLogon=SCE_NO_VALUE;

   //
   // String values
   //
   ppi->NewAdministratorName=NULL;
   ppi->NewGuestName=NULL;
   //
   // registry values
   //
   ppi->RegValueCount= 0;
   ppi->aRegValues = NULL;


   //
   // Kerberos information, if it was created then set the values.
   //
   if(pKerberosInfo){
      pKerberosInfo->MaxTicketAge         = SCE_NO_VALUE;
      pKerberosInfo->MaxRenewAge          = SCE_NO_VALUE;
      pKerberosInfo->MaxServiceAge        = SCE_NO_VALUE;
      pKerberosInfo->MaxClockSkew         = SCE_NO_VALUE;
      pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;

      ppi->pKerberosInfo = pKerberosInfo;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     Save
//
//  Synopsis:   Save the template to  disk
//
//  Arguments: [szName] - [in] [optional] the name of the INF file to save to
//
//  Returns:    TRUE if the save is successful, False otherwise
//
//  Modifies:   m_AreaDirty
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::Save(LPCTSTR szName) {
   DWORD AreaDirty;
   BOOL bSaveAs = FALSE;
   BOOL bSaveDescription = FALSE;

   setlocale(LC_ALL, ".OCP");
   SCESTATUS status = SCESTATUS_OTHER_ERROR;
   PSCE_ERROR_LOG_INFO errBuf = NULL;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (QueryNoSave()) {
      m_AreaDirty = 0;
      return TRUE;
   }

   AreaDirty = m_AreaDirty;

   //
   // If szName isn't given then default to m_szInfFile
   //
   if (!szName) {
      szName = m_szInfFile;
      //
      // We should never be able to get into a situation where
      // szName still isn't set, but just in case somebody called
      // us without szName or m_szInfFile
      //
      ASSERT(szName);
      if (!szName) {
         return FALSE;
      }
   } else {
      if (lstrcmp(szName,m_szInfFile) != 0) {
         //
         // Saving to a different name (Save As)
         //

         //
         // Make sure the path to that filename exists:
         //
         if (SCESTATUS_SUCCESS != SceCreateDirectory( m_szInfFile, FALSE, NULL )) {
            return FALSE;
         }

         AreaDirty = AREA_ALL|AREA_DESCRIPTION;
         bSaveAs = TRUE;
      }
   }

   if (AreaDirty & AREA_DESCRIPTION) {
      bSaveDescription = TRUE;
      AreaDirty &= ~AREA_DESCRIPTION;
      if (!AreaDirty) {
         //
         // Make sure we have something else to save and
         // create the file.  AREA_SECURITY_POLICY is cheap.
         //
         AreaDirty |= AREA_SECURITY_POLICY;
      }

      //
      // Bug 365485 - make sure we only write this to an already
      // existing temp file so that we don't accidentally create
      // an ansi one instead of unicode.  We can easily do this
      // by writing the description section last since we can
      // depend on the engine getting the rest right
      //
   }

   if (AreaDirty) {
      //
      // Save the dirty areas of the profile
      if (_wcsicmp(GT_COMPUTER_TEMPLATE,szName) == 0) { //Prefast warning 400: Yields unexpected results in non-English locales. Comments: It is not localizable.

         if (m_hProfile) {
             //
             // do not update object area
             //
             status = SceUpdateSecurityProfile(m_hProfile,
                                              AreaDirty & ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS),
                                              pTemplate,
                                              0
                                              );

         }
         ASSERT(m_pCDI);
         if (m_pCDI) {
            m_pCDI->EngineCommitTransaction();
         }
      } else if (lstrcmp(GT_LOCAL_POLICY_DELTA,szName) == 0) {
         //
         // Save Changes only to Local Policy
         //
         status = SceUpdateSecurityProfile(NULL,
                                           AreaDirty & ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS),
                                           pTemplate,
                                           SCE_UPDATE_SYSTEM
                                           );
         SetTemplateDefaults();
         if (!bSaveAs) {
            m_AreaDirty = 0;
            m_AreaLoaded = 0;
         }

      } else if ((lstrcmp(GT_LAST_INSPECTION,szName) != 0) &&
                 (lstrcmp(GT_RSOP_TEMPLATE,szName) != 0) &&
                 (lstrcmp(GT_LOCAL_POLICY,szName) != 0) &&
                 (lstrcmp(GT_EFFECTIVE_POLICY,szName) != 0)) {

         status = SceWriteSecurityProfileInfo(szName,
                                              AreaDirty,
                                              pTemplate,
                                              &errBuf);
      } else {
         //
         // No need (or way) to save the last inspection area
         //
         status = SCESTATUS_SUCCESS;
      }

      if (SCESTATUS_SUCCESS == status) {
         //
         // Those areas are no longer dirty.
         //
         if (!bSaveAs) {
            m_AreaDirty = 0;
         }

      } else {
         //
         // Save failed; Notify the user & return false
         //
         CString strMsg,strBase;
         strBase.LoadString(IDS_SAVE_FAILED); //Raid #485372, yanggao, 11/28/2001
         strBase += GetFriendlyName();
         strBase += L".";
         MyFormatMessage(status, (LPCTSTR)strBase, NULL, strMsg);
         AfxMessageBox(strMsg);

         return FALSE;
      }
   }

   if (bSaveDescription) {
      if (m_szDesc) {
         if (WritePrivateProfileSection(
                                   szDescription,
                                   NULL,
                                   szName)) {

            WritePrivateProfileString(
                                     szDescription,
                                     L"Description",
                                     m_szDesc,
                                     szName);
         }
      }
   }

   //
   // Save any dirty services
   //
   CString strService;
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   POSITION pos;
   SCESVCP_HANDLE *scesvcHandle;
   PVOID pvData;
   BOOL bOverwriteAll;

   pos = m_Services.GetStartPosition();
   while (pos) {
      m_Services.GetNextAssoc(pos,strService,pAttachPI);
      if (S_OK == pAttachPI->IsDirty( (LPTSTR)szName )) {

         if (SUCCEEDED(pAttachPI->Save( (LPTSTR)szName,(SCESVC_HANDLE *)&scesvcHandle,&pvData,&bOverwriteAll ))) {
            if (scesvcHandle) {

                if (lstrcmp(GT_COMPUTER_TEMPLATE,szName) == 0) {
                    //
                    // database
                    //
                   status =  SceSvcUpdateInfo(
                                m_hProfile,
                                scesvcHandle->ServiceName,
                                (PSCESVC_CONFIGURATION_INFO)pvData
                                );

                } else {
                   //
                   // inf templates
                   //
                   status = SceSvcSetInformationTemplate(scesvcHandle->TemplateName,
                                                scesvcHandle->ServiceName,
                                                bOverwriteAll,
                                                (PSCESVC_CONFIGURATION_INFO)pvData);
                }
                if (SCESTATUS_SUCCESS != status) {
                    CString strTitle,strMsg,strBase;
                    strTitle.LoadString(IDS_NODENAME);
                    strBase.LoadString(IDS_SAVE_FAILED);
                    strBase += scesvcHandle->ServiceName; //szName;
                    MyFormatMessage(status, (LPCTSTR)strBase, errBuf,strMsg);
                    AfxMessageBox(strMsg);
                }
            }
         }
      }
   }
   return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Method:     SetInfFile
//
//  Synopsis:   Set the name of the INF file this template is associated with
//
//  Arguments:  [szFile] - [in] the name of the INF file to associate with
//
//  Returns:    TRUE if the filename is set successfully, FALSE otherwise
//
//  Modifies:   m_szInfFile
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetInfFile(LPCTSTR szFile) {
   LPTSTR szInfFile;

   if (szFile) {
      szInfFile = new TCHAR[lstrlen(szFile)+1];
      if (szInfFile) {
         //This is a safe usage.
         lstrcpy(szInfFile,szFile);
         if (m_szInfFile) {
            delete[] m_szInfFile;
         }
         m_szInfFile = szInfFile;
      } else {
         return FALSE;
      }
   }
   return szFile != 0;
}


//+--------------------------------------------------------------------------
//
//  Method:     SetDescription
//
//  Synopsis:   Set the description for this template file
//
//  Arguments:  [szDesc] [in] the description for the template
//
//  Returns:    TRUE if the description is set successfully, FALSE otherwise
//
//  Modifies:   m_szDesc
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CEditTemplate::SetDescription(LPCTSTR szDesc) {
   LPTSTR szDescriptionLoc; //Raid #prefast

   if (szDesc) {
      szDescriptionLoc = new TCHAR[lstrlen(szDesc)+1];
      if (szDescriptionLoc) {
         //This is a safe usage.
         lstrcpy(szDescriptionLoc,szDesc);
         if (m_szDesc) {
            delete[] m_szDesc;
         }
         m_szDesc = szDescriptionLoc;
         SetDirty(AREA_DESCRIPTION);
      } else {
         return FALSE;
      }
   }
   return szDesc != 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     CEditTemplate
//
//  Synopsis:   Constructor for CEditTemplate
//
//  History:
//
//---------------------------------------------------------------------------
CEditTemplate::CEditTemplate() {

   m_AreaDirty = 0;
   m_AreaLoaded = 0;
   m_bWriteThrough = FALSE;
   m_bWriteThroughDirty = FALSE;
   m_hProfile = NULL;
   m_szInfFile = NULL;
   m_pNotify = NULL;
   m_pCDI = NULL;
   m_bNoSave = FALSE;
   m_strFriendlyName.Empty();
   m_szDesc = NULL;
   m_bWMI = NULL;
   m_bPolicy = FALSE;
   m_bLocked = FALSE;
   pTemplate = NULL;
}


//+--------------------------------------------------------------------------
//
//  Method:     ~CEditTemplate
//
//  Synopsis:   Destructor for CEditTemplate
//
//  History:
//
//---------------------------------------------------------------------------
CEditTemplate::~CEditTemplate() {
   POSITION pos;
   CString strKey;

   pos = m_Services.GetStartPosition();
   LPSCESVCATTACHMENTPERSISTINFO pAttachPI;
   while (pos) {
      m_Services.GetNextAssoc(pos,strKey,pAttachPI);
      delete pAttachPI;
   }
   if (m_szInfFile) {
      delete[] m_szInfFile;
   }
   if (m_szDesc) {
      delete[] m_szDesc;
   }
   if (pTemplate) {
      if (m_bWMI) {
         FreeWMI_SCE_PROFILE_INFO((PWMI_SCE_PROFILE_INFO)pTemplate);
      } else {
         SceFreeProfileMemory(pTemplate);
      }
      pTemplate = NULL;
   }
   m_AreaDirty = 0;
}


//+--------------------------------------------------------------------------
//
//  Method:     RefreshTemplate
//
//  Synopsis:   Reload the loaded parts of the template
//
//  Arguments:  [aiArea]     - Areas to load even if not previously loaded
//
//  Returns:    0 if the template is reloaded successfully, an error code otherwise
//
//  Modifies:   pTemplate;
//---------------------------------------------------------------------------
DWORD
CEditTemplate::RefreshTemplate(AREA_INFORMATION aiAreaToAdd) {
   AREA_INFORMATION aiArea;
   PVOID pHandle = NULL;
   SCESTATUS rc;


   aiArea = m_AreaLoaded | aiAreaToAdd;
   if (!m_szInfFile) {
      return 1;
   }

   m_AreaDirty = 0;

   if (pTemplate) {
      if (m_bWMI) {
         FreeWMI_SCE_PROFILE_INFO((PWMI_SCE_PROFILE_INFO)pTemplate);
      } else {
         SceFreeProfileMemory(pTemplate);
      }
      pTemplate = NULL;
   }

   //Prefast warning 400: Yields unexpected results in non-English locales. Comments: They are not localizable.
   if ((_wcsicmp(GT_COMPUTER_TEMPLATE,m_szInfFile) == 0) ||
       (_wcsicmp(GT_LAST_INSPECTION,m_szInfFile) == 0) ||
       (_wcsicmp(GT_LOCAL_POLICY, m_szInfFile) == 0) ||
       (_wcsicmp(GT_EFFECTIVE_POLICY, m_szInfFile) == 0) ) {
      //
      // Analysis pane areas from jet database, not INF files
      //
      SCETYPE sceType;

      PSCE_ERROR_LOG_INFO perr = NULL;

      if  (_wcsicmp(GT_COMPUTER_TEMPLATE,m_szInfFile) == 0) { //Prefast warning 400: Yields unexpected results in non-English locales. Comments: It is not localizable.
         sceType = SCE_ENGINE_SMP;
      } else if (_wcsicmp(GT_LOCAL_POLICY, m_szInfFile) == 0)  {
         sceType = SCE_ENGINE_SYSTEM;
         if (!IsAdmin()) {
            m_hProfile = NULL;
         }
      } else if (_wcsicmp(GT_EFFECTIVE_POLICY,m_szInfFile) == 0){
         sceType = SCE_ENGINE_GPO;
      } else {
         sceType = SCE_ENGINE_SAP;
      }

      rc = SceGetSecurityProfileInfo(m_hProfile,                  // hProfile
                                     sceType,                     // Profile type
                                     aiArea,                      // Area
                                     &pTemplate,                // SCE_PROFILE_INFO [out]
                                     &perr);                      // Error List [out]

      if (SCESTATUS_SUCCESS != rc) {
         if ((SCE_ENGINE_GPO == sceType) &&
             (0 == _wcsicmp(GT_EFFECTIVE_POLICY,m_szInfFile))) {
            SetTemplateDefaults();
            return 0;
         } else {
            return IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
      }
   } else if (_wcsicmp(GT_RSOP_TEMPLATE, m_szInfFile) == 0)  { //Prefast warning 400: Yields unexpected results in non-English locales. Comments: It is not localizable.
      if (!m_pCDI) {
         return IDS_ERROR_CANT_GET_PROFILE_INFO;
      }
      m_bWMI = TRUE;

      CWMIRsop Rsop(m_pCDI->m_pRSOPInfo);
      HRESULT hr;
      PWMI_SCE_PROFILE_INFO pProfileInfo;

      //
      // GetPrecedenceOneRSOPInfo should (but doesn't) support
      // getting just the requested area.
      //
      hr = Rsop.GetPrecedenceOneRSOPInfo(&pProfileInfo);
      if (FAILED(hr)) {
         return IDS_ERROR_CANT_GET_PROFILE_INFO;
      }
      pTemplate = pProfileInfo;
      //
      // Since it doesn't, set all areas not just the ones that
      // were asked for
      //
      AddArea(AREA_ALL);
      return 0;
   } else {
      LPTSTR szInfFile=NULL;

      if  (_wcsicmp(GT_DEFAULT_TEMPLATE,m_szInfFile) == 0) { //Prefast warning 400: Yields unexpected results in non-English locales. Comments: It is not localizable.
         DWORD RegType;
         rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                         SCE_REGISTRY_KEY,
                         SCE_REGISTRY_DEFAULT_TEMPLATE,
                         (PVOID *)&szInfFile,
                         &RegType );

         if (ERROR_SUCCESS != rc) {
            if (szInfFile) {
               LocalFree(szInfFile);
               szInfFile = NULL;
            }
            return IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
         if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            SetTemplateDefaults();
            LocalFree(szInfFile);
            szInfFile = NULL;
            return 0;
         }
         LocalFree(szInfFile);
         szInfFile = NULL;
      } else {
         if (EngineOpenProfile(m_szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            return IDS_ERROR_CANT_OPEN_PROFILE;
         }
      }
      ASSERT(pHandle); //Check the pHandle and return IDS_ERROR_CANT_GET_PROFILE_INFO if it fails.

      //
      // get information from this template
      //
      PSCE_ERROR_LOG_INFO perr = NULL;
      if( pHandle ) //Raid #550912, yanggao.
      {
         rc = SceGetSecurityProfileInfo(pHandle,
                                     SCE_ENGINE_SCP,
                                     aiArea,
                                     &pTemplate,
                                     &perr //NULL  // &ErrBuf do not care errors
                                    );

         if (SCESTATUS_SUCCESS != rc) {
            // Oops!
         }
         SceCloseProfile(&pHandle);
         pHandle = NULL;
      }
      else
      {
         return IDS_ERROR_CANT_OPEN_PROFILE;
      }
   }
   /*
         if do not care errors, no need to use this buffer

         if ( ErrBuf ) {
            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }
   */
   if (rc != SCESTATUS_SUCCESS) {
      return IDS_ERROR_CANT_GET_PROFILE_INFO;
   }

   //
   // Set the area in the template
   //
   AddArea(aiArea);


   if ( aiArea & AREA_SECURITY_POLICY && pTemplate ) {
      //
      // expand registry value section based on registry values list on local machine
      //

      SceRegEnumAllValues(
                         &(pTemplate->RegValueCount),
                         &(pTemplate->aRegValues)
                         );
   }

   return 0;
}

//+----------------------------------------------------------------------------------
//Method:       UpdatePrivilegeAssignedTo
//
//Synopsis:     Updates a priviledge item, depending on the [bRemove] argument.
//              if [bRemove] is
//              FALSE   - A new link is created and the pointer is returned through
//                          ppaLink
//              TRUE    - The link is removed from the list.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CEditTemplate::UpdatePrivilegeAssignedTo(
    BOOL bRemove,
    PSCE_PRIVILEGE_ASSIGNMENT *ppaLink,
    LPCTSTR pszName
    )
{

    if(!ppaLink){
        return ERROR_INVALID_PARAMETER;
    }
    PSCE_PRIVILEGE_ASSIGNMENT *pNext = NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pCurrent = NULL;

    if(bRemove) {
        __try {
            if(!*ppaLink){
                return ERROR_INVALID_PARAMETER;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) { //Raid #630245, yanggao, 6/05/2002.
            return (DWORD)E_POINTER;
        }

        //
        // Remove the link from the list.
        //

        pCurrent = pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
        if(pCurrent == (*ppaLink) ){
            pNext = &(pTemplate->OtherInfo.smp.pPrivilegeAssignedTo);
        } else if(pCurrent && pCurrent != (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE)) {
            while( pCurrent->Next ){
                if(pCurrent->Next == *ppaLink){
                    pNext = &(pCurrent->Next);
                    break;
                }
                pCurrent = pCurrent->Next;
            }
        }

        if(pNext && pCurrent){
            (*pNext) = (*ppaLink)->Next;

            if( (*ppaLink)->Name){
                LocalFree( (*ppaLink)->Name);
                (*ppaLink)->Name = NULL;
            }

            SceFreeMemory( (*ppaLink)->AssignedTo, SCE_STRUCT_NAME_LIST);
            LocalFree( *ppaLink );

            *ppaLink = NULL;
        } else {
            return ERROR_RESOURCE_NOT_FOUND;
        }
    } else {
        int iLen;

        if(!pszName){
            return ERROR_INVALID_PARAMETER;
        }
        __try {
            iLen = lstrlen( pszName );
        } __except(EXCEPTION_CONTINUE_EXECUTION){
            return (DWORD)E_POINTER;
        }
        //
        // Create a new link.
        //
        pCurrent = (PSCE_PRIVILEGE_ASSIGNMENT)LocalAlloc( 0, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        if(!pCurrent){
            return (DWORD)E_OUTOFMEMORY;
        }
        ZeroMemory(pCurrent, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        //
        // Allocate space for the name.
        //
        pCurrent->Name = (LPTSTR)LocalAlloc( 0, sizeof(TCHAR) * (iLen + 1));
        if(!pCurrent->Name){
            LocalFree(pCurrent);
            return (DWORD)E_OUTOFMEMORY;
        }
        //This may not be a safe usage. pCurrent->Name is PWSTR. Consider fix.
        lstrcpy(pCurrent->Name, pszName);
        if (*ppaLink) {
           pCurrent->Status = (*ppaLink)->Status;
           pCurrent->AssignedTo = (*ppaLink)->AssignedTo;
        }
        //
        // Assign it to the link.
        //
        pCurrent->Next = pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
        pTemplate->OtherInfo.smp.pPrivilegeAssignedTo = pCurrent;
        *ppaLink = pCurrent;
    }

   return ERROR_SUCCESS;
}

DWORD
CEditTemplate::ComputeStatus(
   PSCE_PRIVILEGE_ASSIGNMENT pEdit,
   PSCE_PRIVILEGE_ASSIGNMENT pAnal
   )
{
   if (!pEdit || (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) == pEdit) {
      return  SCE_STATUS_NOT_CONFIGURED;
   } else if (pEdit->Status == SCE_STATUS_NOT_CONFIGURED) {
      return SCE_STATUS_NOT_CONFIGURED;
   } else if (!pAnal || (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) == pAnal) {
      return SCE_STATUS_MISMATCH;
   } else if (SceCompareNameList(pEdit->AssignedTo, pAnal->AssignedTo)) {
      return SCE_STATUS_GOOD;
   }

   return pAnal->Status;
}


DWORD
CEditTemplate::ComputeStatus(
   PSCE_REGISTRY_VALUE_INFO prvEdit,
   PSCE_REGISTRY_VALUE_INFO prvAnal
   )
{
   //
   // Calculate information.
   //
   if(!prvEdit){
      return SCE_STATUS_NOT_CONFIGURED;
   }

   if(!prvAnal || (PSCE_REGISTRY_VALUE_INFO)ULongToPtr(SCE_NO_VALUE) == prvAnal){
      return SCE_STATUS_ERROR_NOT_AVAILABLE;
   }

   //
   // Calulate base on other information
   //
   if ( !(prvEdit->Value) ) {
      return SCE_STATUS_NOT_CONFIGURED;
   } else if ( (prvAnal->Value == NULL || prvAnal->Value == (LPTSTR)ULongToPtr(SCE_ERROR_VALUE))) {
       return prvAnal->Status;
   } else if ( _wcsicmp(prvEdit->Value, prvAnal->Value) != 0 ) {
       return SCE_STATUS_MISMATCH;
   }

   return SCE_STATUS_GOOD;
}

void
CEditTemplate::LockWriteThrough() {
   ASSERT(!m_bLocked);
   m_bLocked = TRUE;
}

void
CEditTemplate::UnLockWriteThrough() {
   ASSERT(m_bLocked);

   BOOL bSave = m_bLocked;
   m_bLocked = FALSE;

   //
   // Set dirty to save out any still dirty changes that
   // would have been written out had we not been locked
   //
   if ( bSave ) {
       SetDirty(0);
       SetTemplateDefaults();
   }
}

//Bug 212287, Yanggao, 3/20/2001
LPCTSTR CEditTemplate::GetDesc() const
{
   return m_szDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\genserv.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       genserv.cpp
//
//  Contents:   Functions for handling the services within SCE
//
//  History:
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "cservice.h"
#include "aservice.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

void CSnapin::CreateProfServiceResultList(MMC_COOKIE cookie,
                                          FOLDER_TYPES type,
                                          PEDITTEMPLATE pSceInfo,
                                          LPDATAOBJECT pDataObj
                                          )
{
   if ( pSceInfo == NULL || pSceInfo->pTemplate == NULL ) {
      return;
   }
   PSCE_SERVICES pAllServices=NULL, pConfigService;
   DWORD         rc;

   rc = SceEnumerateServices(
                            &pAllServices,
                            TRUE//FALSE
                            );

   if ( rc == NO_ERROR ) {

      for ( PSCE_SERVICES pThisService=pAllServices;
          pThisService != NULL; pThisService = pThisService->Next ) {
         for ( pConfigService=pSceInfo->pTemplate->pServices;
             pConfigService != NULL; pConfigService = pConfigService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 ) {
               break;
            }
         }
         //
         // no matter if config exist for the service, add it
         //
         PWSTR DisplayName=pThisService->DisplayName;
         if ( DisplayName == NULL && pConfigService != NULL ) {
            DisplayName = pConfigService->DisplayName;
         }
         if ( DisplayName == NULL ) {
            DisplayName = pThisService->ServiceName;
         }
         AddResultItem(DisplayName,
                       (LONG_PTR)pThisService,
                       (LONG_PTR)pConfigService,
                       ITEM_PROF_SERV,
                       -1,
                       cookie,
                       FALSE,
                       pThisService->ServiceName,
                       (LONG_PTR)pAllServices,
                       pSceInfo,
                       pDataObj,
                       NULL,
                       IDS_SYSTEM_SERVICES); //assign an ID to this item
      }

      //
      // add the ones not exist in the current system
      //
      for ( pConfigService=pSceInfo->pTemplate->pServices;
          pConfigService != NULL; pConfigService = pConfigService->Next ) {

         for ( pThisService=pAllServices;
             pThisService != NULL; pThisService = pThisService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 )
               break;
         }

         if ( pThisService == NULL ) {
            //
            // the configuration does not exist on local system
            //
            PWSTR DisplayName=pConfigService->DisplayName;
            if ( DisplayName == NULL ) {
               DisplayName = pConfigService->ServiceName;
            }

            AddResultItem( DisplayName,
                           0,
                           (LONG_PTR)pConfigService,
                           ITEM_PROF_SERV,
                           -1,
                           cookie,
                           FALSE,
                           pConfigService->ServiceName,
                           (LONG_PTR)pAllServices,
                           pSceInfo,
                           pDataObj,
                           NULL,
                           IDS_SYSTEM_SERVICES); //Assign an ID to this item

         }
      }
   }

}


void CSnapin::DeleteServiceResultList(MMC_COOKIE cookie)
{
   CFolder* pFolder = (CFolder *)cookie;
   // pFolder could be NULL for the root.
   if ( pFolder == NULL )
      return;

   FOLDER_TYPES type = pFolder->GetType();

   if ( type != AREA_SERVICE &&
         type != AREA_SERVICE_ANALYSIS )
      return;


   if ( m_pSelectedFolder == pFolder && m_resultItemHandle )
   {
      POSITION pos = NULL;
      CResult *pResult = NULL;
      if (m_pSelectedFolder->GetResultItem( 
            m_resultItemHandle, 
            pos, 
            &pResult) != ERROR_SUCCESS) 
      {
         if ( pResult != NULL ) 
         {
            PSCE_SERVICES pAllServices = (PSCE_SERVICES)(pResult->GetID());

            SceFreeMemory(pAllServices, SCE_STRUCT_SERVICES);
         }
      }
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAnalysisServiceResultList
//
//  Synopsis:   Create the list of items to display in the result pane
//              when in the Analysis/Service section
//
//
//  Arguments:  [cookie]   -
//              [type]     -
//              [pSceInfo] -
//              [pBase]    -
//              [pDataObj] -
//
//  Returns:    none
//
//---------------------------------------------------------------------------

void
CSnapin::CreateAnalysisServiceResultList(MMC_COOKIE cookie,
                                         FOLDER_TYPES type,
                                         PEDITTEMPLATE pSceInfo,
                                         PEDITTEMPLATE pBase,
                                         LPDATAOBJECT pDataObj )
{

   if ( pSceInfo == NULL || pBase == NULL ) {
      return;
   }

   PSCE_SERVICES pAllServices=NULL, pConfigService, pAnalService;
   DWORD         rc;

   rc = SceEnumerateServices(
                            &pAllServices,
                            FALSE
                            );

   if ( rc == NO_ERROR ) {

      for ( PSCE_SERVICES pThisService=pAllServices;
          pThisService != NULL; pThisService = pThisService->Next ) {
         //
         // look for base setting on this service
         //
         for ( pConfigService=pBase->pTemplate->pServices;
              pConfigService != NULL;
             pConfigService = pConfigService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 ) {
               break;
            }
         }
         //
         // look for current setting on this service
         //
         for ( pAnalService=pSceInfo->pTemplate->pServices;
              pAnalService != NULL;
             pAnalService = pAnalService->Next ) {

            if ( _wcsicmp(pThisService->ServiceName, pAnalService->ServiceName) == 0 ) {
               break;
            }
         }
         if ( NULL == pAnalService ) {
            if ( NULL != pConfigService ) {
               //
               // a matched item, use base info as the analysis info
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pConfigService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pConfigService, // use the same base info
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             0,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj,
                             NULL,
                             IDS_SYSTEM_SERVICES); // Assign an ID to this item
            } else {
               //
               // a new service
               //
               PWSTR DisplayName=pThisService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pConfigService, // use the same base info
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             SCE_STATUS_NEW_SERVICE,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj,
                             NULL,
                             IDS_SYSTEM_SERVICES); // Assign an ID to this item
            }
         } else {
            if ( NULL != pConfigService ) {
               //
               // a matched or mismatched item, depending on status
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pConfigService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pAnalService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pAnalService,
                             (LONG_PTR)pConfigService,
                             ITEM_ANAL_SERV,
                             pAnalService->Status,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj,
                             NULL,
                             IDS_SYSTEM_SERVICES); // Assign an ID to this item
            } else {
               //
               // a not configured service, use last analysis as default
               //
               PWSTR DisplayName=pThisService->DisplayName;
               if ( NULL == DisplayName )
                  DisplayName = pAnalService->DisplayName;

               if ( NULL == DisplayName )
                  DisplayName = pThisService->ServiceName;

               AddResultItem(DisplayName,
                             (LONG_PTR)pAnalService,
                             0,
                             ITEM_ANAL_SERV,
                             SCE_STATUS_NOT_CONFIGURED,
                             cookie,
                             FALSE,
                             pThisService->ServiceName,
                             (LONG_PTR)pAllServices,
                             pBase,
                             pDataObj,
                             NULL,
                             IDS_SYSTEM_SERVICES); // Assign an ID to this item
            }
         }
      }

      //
      // ignore the services not existing on the current system
      //
      /*
              for ( pConfigService=pSceInfo->pTemplate->pServices;
                    pConfigService != NULL; pConfigService = pConfigService->Next ) {

                  for ( pThisService=pAllServices;
                        pThisService != NULL; pThisService = pThisService->Next ) {

                      if ( _wcsicmp(pThisService->ServiceName, pConfigService->ServiceName) == 0 )
                          break;
                  }

                  if ( pThisService == NULL ) {
                      //
                      // the configuration does not exist on local system
                      //
                      PWSTR DisplayName=pConfigService->DisplayName;
                      if ( DisplayName == NULL ) {
                          DisplayName = pConfigService->ServiceName;
                      }

                      AddResultItem( DisplayName, 0, (DWORD)pConfigService,
                                    ITEM_PROF_SERV, -1, cookie,false,
                                    pConfigService->ServiceName,(DWORD)pAllServices,pSceInfo);

                  }
              }
      */
   }
}


HRESULT CSnapin::GetDisplayInfoForServiceNode(RESULTDATAITEM *pResult,
                                              CFolder *pFolder,
                                              CResult *pData)
{
   if ( NULL == pResult || NULL == pFolder || NULL == pData ) {
      return E_INVALIDARG;
   }

   // get display info for columns 1,2, and 3
   PSCE_SERVICES pService = (PSCE_SERVICES)(pData->GetBase());
   PSCE_SERVICES pSetting = (PSCE_SERVICES)(pData->GetSetting());

   if ( pResult->nCol > 3 ) {
      m_strDisplay = L"";
   } else if ((pResult->nCol == 3) && 
              ((GetModeBits() & MB_RSOP) == MB_RSOP)) {
      m_strDisplay = pData->GetSourceGPOString();
   } else if ( NULL == pService ) {
      if ( pFolder->GetType() == AREA_SERVICE_ANALYSIS &&
           NULL != pSetting ) {
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED); //(IDS_INSPECTED);
      } else {
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED);
      }
   } else if ( pFolder->GetType() == AREA_SERVICE_ANALYSIS &&
               (NULL == pSetting ||
                NULL == pSetting->General.pSecurityDescriptor )) {
      m_strDisplay.LoadString(IDS_CONFIGURED);
   } else if (pResult->nCol == 1) {  // both pService and pSetting exist
      // startup value
      if ( pFolder->GetType() == AREA_SERVICE ) {
         switch ( pService->Startup ) {
            case SCE_STARTUP_AUTOMATIC:
               m_strDisplay.LoadString(IDS_AUTOMATIC);
               break;
            case SCE_STARTUP_MANUAL:
               m_strDisplay.LoadString(IDS_MANUAL);
               break;
            default:
               m_strDisplay.LoadString(IDS_DISABLED);
         }
      } else {
         // analysis area
         if ( pService->Startup == pSetting->Startup ) {
            m_strDisplay.LoadString(IDS_OK);
         } else {
            m_strDisplay.LoadString(IDS_INVESTIGATE);
         }
      }

   } else if ( pResult->nCol == 2 ) {
      // column 2 - permission
      if ( pService->SeInfo & DACL_SECURITY_INFORMATION ) {

         if ( pFolder->GetType() == AREA_SERVICE ) {
            m_strDisplay.LoadString(IDS_CONFIGURED);
         } else {
            // analysis area
            if ( pService == pSetting || pSetting->Status == 0 ) {
               m_strDisplay.LoadString(IDS_OK);
            } else {
               m_strDisplay.LoadString(IDS_INVESTIGATE);
            }
         }
      } else {// permission is not configured
         m_strDisplay.LoadString(IDS_NOT_CONFIGURED);
      }

   }

   pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method:     SetupLinkServiceNodeToBase
//
//  Synopsis:
//
//
//
//  Arguments:  [bAdd]   -
//              [theNode]     -
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::SetupLinkServiceNodeToBase(BOOL bAdd, LONG_PTR theNode)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pBaseInfo;

   //
   // look for the address stored in m_pData->GetBase()
   // if found it, delete it.
   //
   if (0 == theNode) {
      return;
   }

   pet = GetTemplate(GT_COMPUTER_TEMPLATE, AREA_SYSTEM_SERVICE);
   if (NULL == pet) {
      return;
   }
   pBaseInfo = pet->pTemplate;

   PSCE_SERVICES pServParent, pService;

   for ( pService=pBaseInfo->pServices, pServParent=NULL;
       pService != NULL; pServParent=pService, pService=pService->Next ) {

      if ( theNode == (LPARAM)pService ) {
         //
         // find the service node
         //
         if ( !bAdd ) {
            //
            // unlink
            //
            if ( pServParent == NULL ) {
               //
               // the first service
               //
               pBaseInfo->pServices = pService->Next;

            } else {
               pServParent->Next = pService->Next;
            }

            pService->Next = NULL;
         }
         break;
      }
   }
   if ( bAdd && NULL == pService ) {
      //
      // need to add this one
      //
      pService = (PSCE_SERVICES)theNode;
      pService->Next = pBaseInfo->pServices;
      pBaseInfo->pServices = pService;
   }
   return;

}

void CSnapin::AddServiceNodeToProfile(PSCE_SERVICES pNode)
{
   PEDITTEMPLATE pet;
   PSCE_PROFILE_INFO pProfileInfo;

   if ( pNode ) {
      pet = GetTemplate(GT_LAST_INSPECTION, AREA_SYSTEM_SERVICE);
      if (!pet) {
         return;
      }
      pProfileInfo = pet->pTemplate;
      pNode->Next = pProfileInfo->pServices;
      pProfileInfo->pServices = pNode;
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\getuser.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       getuser.cpp
//
//  Contents:   implementation of CGetUser
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "GetUser.h"
#include "util.h"
#include "wrapper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

const TCHAR c_szSep[]               = TEXT("\\");

//////////////////////////////////////////////////////////////////////
// CGetUser Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CTypedPtrArray<CPtrArray, PWSCE_ACCOUNTINFO> CGetUser::m_aKnownAccounts;

BOOL IsDomainAccountSid( PSID pSid )
{
   if ( pSid == NULL ) {
     return(FALSE);
   }

   if ( !IsValidSid(pSid) ) {
     return(FALSE);
   }

   PISID ISid = (PISID)pSid;

   if ( ISid->IdentifierAuthority.Value[5] != 5 ||
       ISid->IdentifierAuthority.Value[0] != 0 ||
       ISid->IdentifierAuthority.Value[1] != 0 ||
       ISid->IdentifierAuthority.Value[2] != 0 ||
       ISid->IdentifierAuthority.Value[3] != 0 ||
       ISid->IdentifierAuthority.Value[4] != 0 ) {
      //
      // this is not a account from account domain
      //
      return(FALSE);
   }

   if ( ISid->SubAuthorityCount == 0 ||
      ISid->SubAuthority[0] != SECURITY_NT_NON_UNIQUE ) {
      return(FALSE);
   }

   return(TRUE);
}


/*------------------------------------------------------------------------------------------------------------
CGetUser::GetAccountType

Synopsis:   Returns the type of the user account.  Call this function with a NULL to remove saved
            account name information.

Arguments:  [pszName]   - The account name old NT4 format

Returns:    One of the enumerated Sid types.
------------------------------------------------------------------------------------------------------------*/

SID_NAME_USE
CGetUser::GetAccountType(LPCTSTR pszName)
{
    if(!pszName){
        // Delete the whole list.
        for(int i = 0; i < m_aKnownAccounts.GetSize(); i++){
            PWSCE_ACCOUNTINFO pAccount = m_aKnownAccounts[i];

            if(pAccount){
                if(pAccount->pszName){
                    LocalFree(pAccount->pszName);
                }

                LocalFree(pAccount);
            }

        }
        m_aKnownAccounts.RemoveAll();

        return SidTypeUnknown;
    }

    // Check to see if we've already got the account.
    for(int i = 0; i < m_aKnownAccounts.GetSize(); i++){
        if( !lstrcmpi( m_aKnownAccounts[i]->pszName, pszName) ){
            return m_aKnownAccounts[i]->sidType;
        }
    }

    PSID            sid         = NULL;
    LPTSTR          pszDomain   = NULL;
    DWORD           cbSid       = 0,
                    cbRefDomain = 0;
    SID_NAME_USE    type        = SidTypeUnknown;

    LookupAccountName(
            NULL,
            pszName,
            sid,
            &cbSid,
            NULL,
            &cbRefDomain,
            &type
            );

    if(cbSid){
        sid = (PSID)LocalAlloc(0, cbSid);
        if(!sid){
            return SidTypeUnknown;
        }
        pszDomain = (LPTSTR)LocalAlloc(0, (cbRefDomain + 1) * sizeof(TCHAR));
        if(!pszDomain){
            cbRefDomain = 0;
        }

        type = SidTypeUser;
        if( LookupAccountName(
                NULL,
                pszName,
                sid,
                &cbSid,
                pszDomain,
                &cbRefDomain,
                &type
                ) ){

            //
            // Add the account name to the list.
            //
            PWSCE_ACCOUNTINFO pNew = (PWSCE_ACCOUNTINFO)LocalAlloc(0, sizeof(WSCE_ACCOUNTINFO));
            if(pNew){
                pNew->pszName = (LPTSTR)LocalAlloc(0, (lstrlen( pszName ) + 1) * sizeof(TCHAR));
                if(!pNew->pszName){
                    LocalFree(pNew);
                    LocalFree(sid);
                    if ( pszDomain ) {
                        LocalFree(pszDomain);
                    }
                    return SidTypeUnknown;
                }
                // This is a safe usage. 
                lstrcpy(pNew->pszName, pszName);
                pNew->sidType = type;

                m_aKnownAccounts.Add(pNew);
            }
        }

        LocalFree(sid);
        if(pszDomain){
            LocalFree(pszDomain);
        }

    }
    return type;
}


CGetUser::CGetUser()
{
    m_pszServerName = NULL;

   m_pNameList = NULL;
}

CGetUser::~CGetUser()
{
   PSCE_NAME_LIST p;

   while(m_pNameList) {
      p=m_pNameList;
      m_pNameList = m_pNameList->Next;
      LocalFree(p->Name);
      LocalFree(p);
   }
}

BOOL CGetUser::Create(HWND hwnd, DWORD nShowFlag)
{
   if( m_pNameList ) {
      return FALSE;
   }
   HRESULT hr = S_OK;
   IDsObjectPicker *pDsObjectPicker;
   BOOL bRet = TRUE;
   PSCE_NAME_LIST pName;
   BOOL bDC = IsDomainController( m_pszServerName );
   BOOL bHasADsPath;
   //
   // Initialize and get the Object picker interface.
   //
   hr = CoInitialize(NULL);
   if (!SUCCEEDED(hr)) {
      return FALSE;
   }
   // This is a safe usage.
   hr = CoCreateInstance(
            CLSID_DsObjectPicker,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDsObjectPicker,
            (void **) &pDsObjectPicker
            );
   if(!SUCCEEDED(hr)){
      CoUninitialize();
      return FALSE;
   }


#define SCE_SCOPE_INDEX_DOMAIN 0
#define SCE_SCOPE_INDEX_DIRECTORY 1
#define SCE_SCOPE_INDEX_LOCAL 2
#define SCE_SCOPE_INDEX_ROOT 3   //Raid #522908, 2/23/2002, yanggao
#define SCE_SCOPE_INDEX_EXUP 4
#define SCE_NUM_SCOPE_INDICES 5
   DSOP_SCOPE_INIT_INFO aScopes[SCE_NUM_SCOPE_INDICES];
   DSOP_SCOPE_INIT_INFO aScopesUsed[SCE_NUM_SCOPE_INDICES];

   ZeroMemory(aScopes, sizeof(aScopes));
   ZeroMemory(aScopesUsed, sizeof(aScopesUsed));

    DWORD dwDownLevel = 0, dwUpLevel = 0;

    //
    // Users
    //
    if (nShowFlag & SCE_SHOW_USERS ) {
        dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_USERS;
        dwUpLevel   |= DSOP_FILTER_USERS ;
    }

    if( nShowFlag & SCE_SHOW_LOCALGROUPS ){
       dwUpLevel |= DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
       if (nShowFlag & SCE_SHOW_COMPUTER ) //Raid #477428, Yanggao
       {
           dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_COMPUTERS;
           dwUpLevel   |= DSOP_FILTER_COMPUTERS ;
       }
    }

    if( nShowFlag & SCE_SHOW_BUILTIN ){
       dwUpLevel |= DSOP_FILTER_BUILTIN_GROUPS;
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    } else {
       dwDownLevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
    }


    //
    // Built in groups.
    //
    if (nShowFlag & SCE_SHOW_GROUPS ) {
      dwDownLevel |= DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
        dwUpLevel   |= DSOP_FILTER_BUILTIN_GROUPS;
    }

    //
    // Domain groups.
    //
    if( nShowFlag & (SCE_SHOW_GROUPS | SCE_SHOW_DOMAINGROUPS | SCE_SHOW_ALIASES | SCE_SHOW_GLOBAL) ){
        if( !(nShowFlag & SCE_SHOW_LOCALONLY)){
            dwUpLevel |=    DSOP_FILTER_UNIVERSAL_GROUPS_SE
                            | DSOP_FILTER_GLOBAL_GROUPS_SE
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
        } else if(bDC){
          dwDownLevel |= DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER;
            dwUpLevel |=    DSOP_FILTER_GLOBAL_GROUPS_SE
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
        }
        if (nShowFlag & SCE_SHOW_COMPUTER ) //Raid #477428, Yanggao
        {
            dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            dwUpLevel   |= DSOP_FILTER_COMPUTERS ;
        }
    }

    //
    //
    // principal well known sids.
    //
    if( (!(nShowFlag & SCE_SHOW_LOCALONLY) &&
        nShowFlag & SCE_SHOW_GROUPS &&
        nShowFlag & SCE_SHOW_USERS) ||
        nShowFlag & SCE_SHOW_WELLKNOWN ){
/*
        dwDownLevel |=  DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER
                      | DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP
                      | DSOP_DOWNLEVEL_FILTER_INTERACTIVE
                      | DSOP_DOWNLEVEL_FILTER_SYSTEM
                      | DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER
                      | DSOP_DOWNLEVEL_FILTER_WORLD
                      | DSOP_DOWNLEVEL_FILTER_ANONYMOUS
                      | DSOP_DOWNLEVEL_FILTER_BATCH
                      | DSOP_DOWNLEVEL_FILTER_DIALUP
                      | DSOP_DOWNLEVEL_FILTER_NETWORK
                      | DSOP_DOWNLEVEL_FILTER_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER
                      | DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE
                      | DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON;
*/
        dwDownLevel |= DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

        dwUpLevel |= DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
    }


   DSOP_INIT_INFO  InitInfo;
   ZeroMemory(&InitInfo, sizeof(InitInfo));

   //
   // Other attributes that we need object picker to return to use.
   //
   PCWSTR aAttributes[] = { L"groupType",
                            L"objectSid" };

   InitInfo.cAttributesToFetch = 2;
   InitInfo.apwzAttributeNames = aAttributes;
   //
   // First Item we want to view is the local computer.
   //
   aScopes[SCE_SCOPE_INDEX_LOCAL].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_LOCAL].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   aScopes[SCE_SCOPE_INDEX_LOCAL].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_LOCAL].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   aScopes[SCE_SCOPE_INDEX_LOCAL].FilterFlags.flDownlevel = dwDownLevel;

   //
   // Flags for the domain we're joined to.
   //
   aScopes[SCE_SCOPE_INDEX_DOMAIN].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_DOMAIN].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
   aScopes[SCE_SCOPE_INDEX_DOMAIN].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
                                       |DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS |DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS; //Raid #626152, Yanggao
   //
   // May need to differentiate native & mixed modes on non-DCs.
   //
   if (nShowFlag & SCE_SHOW_DIFF_MODE_OFF_DC && !bDC) {
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flNativeModeOnly = dwUpLevel;
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flMixedModeOnly =
                                         ( dwUpLevel & (~( DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE )) );
   } else {
      aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   }
   aScopes[SCE_SCOPE_INDEX_DOMAIN].FilterFlags.flDownlevel = dwDownLevel;
   
   //
   // Next set flags for other scope items. Everything same, only not show builtin and local groups
   //
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.Uplevel.flBothModes = dwUpLevel; //Raid #516311, 2/23/2002, yanggao
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.flDownlevel = dwDownLevel;
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS |
                                                                 DSOP_DOWNLEVEL_FILTER_COMPUTERS;
   aScopes[SCE_SCOPE_INDEX_DIRECTORY].flType = DSOP_SCOPE_TYPE_WORKGROUP
                                               | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                               | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
                                               | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                               | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

   //Root forest
   aScopes[SCE_SCOPE_INDEX_ROOT].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_ROOT].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_ROOT].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   aScopes[SCE_SCOPE_INDEX_ROOT].FilterFlags.flDownlevel = dwDownLevel;
   aScopes[SCE_SCOPE_INDEX_ROOT].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS |
                                                                 DSOP_DOWNLEVEL_FILTER_COMPUTERS;
   aScopes[SCE_SCOPE_INDEX_ROOT].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

   //Entire forest
   aScopes[SCE_SCOPE_INDEX_EXUP].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   aScopes[SCE_SCOPE_INDEX_EXUP].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   aScopes[SCE_SCOPE_INDEX_EXUP].FilterFlags.Uplevel.flBothModes = dwUpLevel;
   aScopes[SCE_SCOPE_INDEX_EXUP].FilterFlags.flDownlevel = dwDownLevel;
   aScopes[SCE_SCOPE_INDEX_EXUP].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS |
                                                                 DSOP_DOWNLEVEL_FILTER_COMPUTERS;
   aScopes[SCE_SCOPE_INDEX_EXUP].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;

   //
   // Show each scope's information or not.
   //
   InitInfo.cDsScopeInfos = 0;

   //Root and Entire forest
   //These five memcpy() is a safe usage. aScopesUsed and aScopes are both defined locally.
   //Below 5 memcpy usages are safe usages.
   memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_ROOT],sizeof(DSOP_SCOPE_INIT_INFO));
   InitInfo.cDsScopeInfos++;
   memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_EXUP],sizeof(DSOP_SCOPE_INIT_INFO));
   InitInfo.cDsScopeInfos++;

   if (nShowFlag & SCE_SHOW_SCOPE_LOCAL) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_LOCAL],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }
   if (nShowFlag & SCE_SHOW_SCOPE_DOMAIN) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_DOMAIN],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }
   if (nShowFlag & SCE_SHOW_SCOPE_DIRECTORY) {
      memcpy(&aScopesUsed[InitInfo.cDsScopeInfos],&aScopes[SCE_SCOPE_INDEX_DIRECTORY],sizeof(DSOP_SCOPE_INIT_INFO));
      InitInfo.cDsScopeInfos++;
   }
   ASSERT(InitInfo.cDsScopeInfos > 0);

   //
   // Initialize and display the object picker.
   //

   InitInfo.cbSize = sizeof(InitInfo);
   InitInfo.aDsScopeInfos = aScopesUsed;
   InitInfo.flOptions = ((nShowFlag & SCE_SHOW_SINGLESEL) ? 0:DSOP_FLAG_MULTISELECT);

   if( (nShowFlag & SCE_SHOW_SCOPE_LOCAL) && bDC ) //Raid #462447, Yang Gao, 8/30/2001.
   {
      InitInfo.flOptions = InitInfo.flOptions | DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
   }

   InitInfo.pwzTargetComputer = m_pszServerName;

   hr = pDsObjectPicker->Initialize(&InitInfo);

   if( FAILED(hr) ){
      CoUninitialize();
      return FALSE;
   }

   IDataObject *pdo = NULL;

   hr = pDsObjectPicker->InvokeDialog(hwnd, &pdo);

   while (SUCCEEDED(hr) && pdo) { // FALSE LOOP
      //
      // The user pressed OK. Prepare clipboard dataformat from the object picker.
      //
      STGMEDIUM stgmedium =
      {
         TYMED_HGLOBAL,
         NULL
      };

      CLIPFORMAT cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

      FORMATETC formatetc =
      {
         cf,
         NULL,
         DVASPECT_CONTENT,
         -1,
         TYMED_HGLOBAL
      };

      hr = pdo->GetData(&formatetc, &stgmedium);

      if ( FAILED(hr) ) {
         bRet = FALSE;
         pdo->Release();
         pdo = NULL;
         break;
      }

      //
      // Lock the selection list.
      //
      PDS_SELECTION_LIST pDsSelList =
      (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

      ULONG i;
      ULONG iLen = 0;
      BOOL fFromSID = FALSE;
      PWSTR pSIDBuf = NULL;
      LSA_HANDLE hLsa = NULL;
      //
      // Enumerate through all selections.
      //
      PSID pSid = NULL;
      for (i = 0; i < pDsSelList->cItems && bRet; i++) {
         LPTSTR pszCur = pDsSelList->aDsSelection[i].pwzADsPath;
         fFromSID = FALSE;
         //make sure getting local wellknown account name.
         VARIANT* pSidArray = pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1;
         pSid = NULL;
         if( NULL != pSidArray && (VT_ARRAY | VT_UI1) == V_VT(pSidArray)
            && SUCCEEDED(SafeArrayAccessData(V_ARRAY(pSidArray), &pSid)) )
         {
            if ( IsValidSid(pSid) )
            {
               if( !hLsa )
               {
                  LSA_OBJECT_ATTRIBUTES ObjectAttributes;
                  //LSA_HANDLE hLsa;
                  ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
                  if( SCESTATUS_SUCCESS != LsaOpenPolicy(
                           NULL, &ObjectAttributes, 
                           MAXIMUM_ALLOWED,//POLICY_ALL_ACCESS,
                           &hLsa
                           ) )
                  {
                     SafeArrayUnaccessData(V_ARRAY(pSidArray));
                     bRet = FALSE;
                     break;
                  }
               }
               
               PLSA_TRANSLATED_NAME    pTranslatedName = NULL;
               PLSA_REFERENCED_DOMAIN_LIST pReferencedDomains = NULL;
               if( SCESTATUS_SUCCESS == LsaLookupSids(hLsa, 1, &pSid,
                           &pReferencedDomains, &pTranslatedName) && 
                        pTranslatedName->Use == SidTypeWellKnownGroup )
               {
                  if( pSIDBuf )
                  {
                     long nsize = (wcslen(pSIDBuf)+1)*sizeof(WCHAR);
                     if( nsize < (long)(pTranslatedName->Name.Length+sizeof(WCHAR)) )
                     {
                        pSIDBuf = (PWSTR)LocalReAlloc(pSIDBuf, pTranslatedName->Name.Length+sizeof(WCHAR), LMEM_MOVEABLE);
                        nsize = pTranslatedName->Name.Length+sizeof(WCHAR);
                     }
                     ZeroMemory(pSIDBuf, nsize);
                  }
                  else
                  {
                     pSIDBuf = (PWSTR)LocalAlloc(LPTR, pTranslatedName->Name.Length+sizeof(WCHAR));
                  }
                  if( pSIDBuf )
                  {
                     wcsncpy(pSIDBuf, pTranslatedName->Name.Buffer, pTranslatedName->Name.Length/sizeof(WCHAR));
                     fFromSID = TRUE;
                  }
                  else
                  {
                     if( pTranslatedName )
                     {  
                        LsaFreeMemory(pTranslatedName);
                     }
                     if( pReferencedDomains )
                     {
                        LsaFreeMemory(pReferencedDomains);
                     }
                     SafeArrayUnaccessData(V_ARRAY(pSidArray));
                     bRet = FALSE;
                     break;
                  }
               }
               if( pTranslatedName )
               {
                  LsaFreeMemory(pTranslatedName);
               }
               if( pReferencedDomains )
               {
                  LsaFreeMemory(pReferencedDomains);
               }
            }
            SafeArrayUnaccessData(V_ARRAY(pSidArray));
         }

         bHasADsPath = TRUE;
         int iPath = 0;

         //
         // Se if this is a valid string.  If the string isn't empty or NULL then use it
         // with the full path, we will figure out later wiether we need to strip the prefix.
         //
         if (pszCur && *pszCur && !fFromSID )
         {
            //
            // Create name with one path.
            //
            iLen = lstrlen(pszCur);
            while (iLen) {
               if ( pszCur[iLen] == L'/' ) {
                  if (iPath) {
                     iLen++;
                     iPath -= iLen;
                     break;
                  }
                  iPath = iLen;
               }
               iLen--;
            }
            pszCur += iLen;
         }
         else
         {
            //
            // Use just the name then.
            //
            bHasADsPath = FALSE;
            if( fFromSID )
            {
               pszCur = pSIDBuf;
            }
            else
            {
               pszCur = pDsSelList->aDsSelection[i].pwzName;
               if (!pszCur || !(*pszCur)) {
                  continue;
               }
            }
         }

         iLen = lstrlen(pszCur);


         if (iLen) {
            //
            // Allocate and copy the user name.
            //
            LPTSTR pszNew = (LPTSTR)LocalAlloc( LMEM_FIXED, (iLen + 1) * sizeof(TCHAR));
            if (!pszNew) {
               bRet = FALSE;
               break;
            }
            // This is an safe usage. pszCur is a trusted source string and is validated.
            lstrcpy(pszNew, pszCur);

            if (bHasADsPath)
            {
                if (iPath) {
                   //
                   // Set forward slash to back slash.
                   //
                   pszNew[iPath] = L'\\';
                }

                ULONG uAttributes;
                //
                // Bug 395424:
                //
                // Obsel passes attributes in VT_I4 on DCs and in VT_UI4 on other systems
                // Need to check both to properly detect built-ins, etc.
                //

                if (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_UI4) {
                   uAttributes = V_UI4(pDsSelList->aDsSelection[i].pvarFetchedAttributes);
                } else if (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_I4) {
                   uAttributes = static_cast<ULONG>(V_I4(pDsSelList->aDsSelection[i].pvarFetchedAttributes));
                }

                //
                // Determine if the name we recieved is group.
                // The type and value of pDsSelList->aDsSelection[i].pvarFetchedAttributes
                // may change in the future release by Object Picker. Therefore,
                // the following code should change accordingly.
                //
                if ( (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_UI4) ||
                     (V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_I4 ))
                {
                    //
                    // Determine if it is a built-in group.  We don't want
                    // built-in groups to have a prefix.
                    //
                    if ( uAttributes & 0x1 &&
                         V_ISARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) )
                    {
                        // This is an safe usage. pszCur is a trusted source string and is validated.
                        // iPath is less than iLen.
                        lstrcpy( pszNew, &(pszCur[iPath + 1]) );
                    }
                    else if ( uAttributes & 0x4 &&
                              V_ISARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) )
                    {
                        //
                        // It's a group, but we have to check the sids account type.  If it's
                        // not in the domain accounts authority then we can assume it's a built-in sid
                        //
                        PVOID pvData = NULL;
                        hr = SafeArrayAccessData( V_ARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1), &pvData); //Raid #prefast

                        if (SUCCEEDED(hr) ) {
                            if ( IsValidSid( (PSID)pvData ) && !IsDomainAccountSid( (PSID)pvData ) )
                            {
                                // This is an safe usage. pszCur is a trusted source string and is validated.
                                // iPath is less than iLen.
                                lstrcpy(pszNew, &(pszCur[iPath + 1]) );
                            }
                            hr = SafeArrayUnaccessData( V_ARRAY(pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1) );
                        }
                    }
                }
                else if(V_VT(pDsSelList->aDsSelection[i].pvarFetchedAttributes) == VT_EMPTY)
                {
                    LPTSTR pszTemp = pDsSelList->aDsSelection[i].pwzClass;
                    //
                    // Determine if it is a well-known account.  We don't want
                    // well-known account to have a prefix.
                    // Prefast warning 400: Yields unexpected results in non-English locales. Comments: They are not localizable.
                    if (_wcsicmp(pszTemp, _T("user")) && _wcsicmp(pszTemp, _T("computer"))) //Raid #477428, Yanggao
                    {
                        // This is an safe usage. pszCur is a trusted source string and is validated.
                        // iPath is less than iLen.
                        lstrcpy( pszNew, &(pszCur[iPath + 1]) );
                    }
                }
            }

            //
            // Make sure we don't already have this name in the list.
            //
            pName = m_pNameList;
            while (pName) {
               if (!lstrcmpi(pName->Name, pszNew)) {
                  LocalFree(pszNew);
                  pszNew = NULL;
                  break;
               }
               pName = pName->Next;
            }

            if ( !pszNew ) {
               //
               // Don;t do anything because this name already exists.
               //
               continue;
            }

            //
            // New entry in list.
            //
            pName = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));
            if ( !pName ) {
               LocalFree(pszNew);
               bRet = FALSE;
               break;
            }
            ZeroMemory(pName, sizeof(SCE_NAME_LIST));

            //GetAccountType(pszNew);
            pName->Name = pszNew;
            pName->Next = m_pNameList;
            m_pNameList = pName;
         }
      }
      GlobalUnlock(stgmedium.hGlobal);
      ReleaseStgMedium(&stgmedium);
      pdo->Release();
      if(hLsa)
      {
         LsaClose(hLsa);
      }
      if(pSIDBuf)
      {
         LocalFree(pSIDBuf);
      }
      break;
   }

   pDsObjectPicker->Release();
   CoUninitialize();

   if (!bRet) {
      //
      // If we had an error somewhere clean up.
      //
      pName = m_pNameList;
      while (pName) {
         if (pName->Name) {
            LocalFree(pName->Name);
         }
         m_pNameList = pName->Next;
         LocalFree(pName);

         pName = m_pNameList;
      }
      m_pNameList = NULL;
   }
   return bRet;

}

PSCE_NAME_LIST CGetUser::GetUsers()
{
   return m_pNameList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "util.h"
#include "AString.h"
#include "ANumber.h"
#include "AEnable.h"
#include "AAudit.h"
#include "ARet.h"
#include "ARight.h"
#include "CAudit.h"
#include "CNumber.h"
#include "CEnable.h"
#include "CName.h"
#include "CPrivs.h"
#include "CGroup.h"
#include "Cret.h"
#include "chklist.h"
#include "servperm.h"
#include "aobject.h"
#include "cobject.h"

#include "UIThread.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long CSnapin::GetUserRightAssignmentItemID(LPCWSTR szItem) //Raid #510407, 2/25/2002, yanggao
{
   //assign each one an ID
   long itemid = 0;
   if( _wcsicmp(szItem, L"SeNetworkLogonRight") == 0 )
   {
      itemid = IDS_COMPUTER_NET;
   }else
   if( _wcsicmp(szItem, L"SeTcbPrivilege") == 0 )
   {
      itemid = IDS_ACTAS_PART;
   }else
   if( _wcsicmp(szItem, L"SeMachineAccountPrivilege") == 0 )
   {
      itemid = IDS_ADD_WORKSTATION;
   }else
   if( _wcsicmp(szItem, L"SeBackupPrivilege") == 0 )
   {
      itemid = IDS_BACKUP_FILES;
   }else
   if( _wcsicmp(szItem, L"SeChangeNotifyPrivilege") == 0 )
   {
      itemid = IDS_BYPASS_CHECK;
   }else
   if( _wcsicmp(szItem, L"SeSystemtimePrivilege") == 0 )
   {
      itemid = IDS_CHANGE_SYSTEMTIME;
   }else
   if( _wcsicmp(szItem, L"SeCreatePagefilePrivilege") == 0 )
   {
      itemid = IDS_CREATE_PAGEFILE;
   }else
   if( _wcsicmp(szItem, L"SeCreateTokenPrivilege") == 0 )
   {
      itemid = IDS_CREATE_TOKEN;
   }else
   if( _wcsicmp(szItem, L"SeCreatePermanentPrivilege") == 0 )
   {
      itemid = IDS_CREATE_SHARED_OBJ;
   }else
   if( _wcsicmp(szItem, L"SeDebugPrivilege") == 0 )
   {
      itemid = IDS_DEBUG_PROGRAM;
   }else
   if( _wcsicmp(szItem, L"SeRemoteShutdownPrivilege") == 0 )
   {
      itemid = IDS_FORCE_SHUTDOWN;
   }else
   if( _wcsicmp(szItem, L"SeAuditPrivilege") == 0 )
   {
      itemid = IDS_SECURITY_AUDIT;
   }else
   if( _wcsicmp(szItem, L"SeIncreaseQuotaPrivilege") == 0 )
   {
      itemid = IDS_MEMORY_ADJUST;
   }else
   if( _wcsicmp(szItem, L"SeIncreaseBasePriorityPrivilege") == 0 )
   {
      itemid = IDS_INCREASE_PRIORITY;
   }else
   if( _wcsicmp(szItem, L"SeLoadDriverPrivilege") == 0 )
   {
      itemid = IDS_LOAD_DRIVER;
   }else
   if( _wcsicmp(szItem, L"SeLockMemoryPrivilege") == 0 )
   {
      itemid = IDS_LOCK_PAGE;
   }else
   if( _wcsicmp(szItem, L"SeBatchLogonRight") == 0 )
   {
      itemid = IDS_LOGON_BATCH;
   }else
   if( _wcsicmp(szItem, L"SeServiceLogonRight") == 0 )
   {
      itemid = IDS_LOGON_SERVICE;
   }else
   if( _wcsicmp(szItem, L"SeInteractiveLogonRight") == 0 )
   {
      itemid = IDS_LOGON_LOCALLY;
   }else
   if( _wcsicmp(szItem, L"SeSecurityPrivilege") == 0 )
   {
      itemid = IDS_MANAGE_LOG;
   }else
   if( _wcsicmp(szItem, L"SeSystemEnvironmentPrivilege") == 0 )
   {
      itemid = IDS_MODIFY_ENVIRONMENT;
   }else
   if( _wcsicmp(szItem, L"SeProfileSingleProcessPrivilege") == 0 )
   {
      itemid = IDS_SINGLE_PROCESS;
   }else
   if( _wcsicmp(szItem, L"SeSystemProfilePrivilege") == 0 )
   {
      itemid = IDS_SYS_PERFORMANCE;
   }else
   if( _wcsicmp(szItem, L"SeAssignPrimaryTokenPrivilege") == 0 )
   {
      itemid = IDS_PROCESS_TOKEN;
   }else
   if( _wcsicmp(szItem, L"SeRestorePrivilege") == 0 )
   {
      itemid = IDS_RESTORE_FILE;
   }else
   if( _wcsicmp(szItem, L"SeShutdownPrivilege") == 0 )
   {
      itemid = IDS_SHUTDOWN;
   }else
   if( _wcsicmp(szItem, L"SeTakeOwnershipPrivilege") == 0 )
   {
      itemid = IDS_TAKE_OWNERSHIP;
   }else
   if( _wcsicmp(szItem, L"SeDenyNetworkLogonRight") == 0 )
   {
      itemid = IDS_DENY_COMPUTER_NET;
   }else
   if( _wcsicmp(szItem, L"SeDenyBatchLogonRight") == 0 )
   {
      itemid = IDS_DENY_LOG_BATCH;
   }else
   if( _wcsicmp(szItem, L"SeDenyServiceLogonRight") == 0 )
   {
      itemid = IDS_DENY_LOG_SERVICE;
   }else
   if( _wcsicmp(szItem, L"SeDenyInteractiveLogonRight") == 0 )
   {
      itemid = IDS_DENY_LOG_LOCALLY;
   }else
   if( _wcsicmp(szItem, L"SeUndockPrivilege") == 0 )
   {
      itemid = IDS_REMOVE_COMPUTER;
   }else
   if( _wcsicmp(szItem, L"SeSyncAgentPrivilege") == 0 )
   {
      itemid = IDS_SYNC_DATA;
   }else
   if( _wcsicmp(szItem, L"SeEnableDelegationPrivilege") == 0 )
   {
      itemid = IDS_ENABLE_DELEGATION;
   }else
   if( _wcsicmp(szItem, L"SeManageVolumePrivilege") == 0 )
   {
      itemid = IDS_MAITENANCE;
   }else
   if( _wcsicmp(szItem, L"SeRemoteInteractiveLogonRight") == 0 )
   {
      itemid = IDS_LOG_TERMINAL;
   }else
   if( _wcsicmp(szItem, L"SeDenyRemoteInteractiveLogonRight") == 0 )
   {
      itemid = IDS_DENY_LOG_TERMINAL;
   }
   return itemid;
}
/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify
/////////////////////////////////////////////////////////////////////////////

HRESULT CSnapin::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   ASSERT(FALSE);

   return S_OK;
}

HRESULT CSnapin::OnShow(LPDATAOBJECT pDataObj, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   // Note - arg is TRUE when it is time to enumerate
   if (arg == TRUE) 
   {
      m_ShowCookie = cookie;

      // Show the headers for this nodetype
      InitializeHeaders(cookie);
      // Show data
      EnumerateResultPane(cookie, param, pDataObj);

      // BUBBUG - Demonstration to should how you can attach
      // and a toolbar when a particular nodes gets focus.
      // warning this needs to be here as the toolbars are
      // currently hidden when the previous node looses focus.
      // This should be update to show the user how to hide
      // and show toolbars. (Detach and Attach).

      //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
      //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);


   } 
   else 
   {
      // Free data associated with the result pane items, because
      // your node is no longer being displayed.
      // Note: The console will remove the items from the result pane
      m_ShowCookie = 0;

      DeleteServiceResultList(cookie);
      DeleteList(FALSE);
   }

   return S_OK;
}

HRESULT CSnapin::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   return S_OK;
}

BOOL CALLBACK MyPropSheetDlgProc(HWND hwnd, UINT uMsg, WPARAM wp, LPARAM lp) 
{
   return FALSE;
}


HRESULT CSnapin::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject)
{

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Method:     InitializeHeaders
//
//  Synopsis:   Set the result item headers appropriate for the area
//
//  Arguments:  [cookie] - [in] the folder whose result item to setting headers for
//
//  Returns:
//
//  History:
//
//---------------------------------------------------------------------------
SCE_COLUMNINFO g_columnInfo[] = {

    { AREA_REGISTRY_ANALYSIS,        5,              0 },
    { IDS_COL_OBJECT,       LVCFMT_LEFT,    220 },
    { IDS_PERMISSION,       LVCFMT_LEFT,    80 },
    { IDS_AUDITING,         LVCFMT_LEFT,    70 },
    { IDS_COL_BAD_COUNT,    LVCFMT_LEFT,    60 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_REGISTRY,        2,              0 },
    { IDS_COL_OBJECT,       LVCFMT_LEFT,    220 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_GROUPS,          4,              0 },
    { IDS_GROUP_NAME,       LVCFMT_LEFT,    200 },
    { IDS_COL_MEMBERSHIP,   LVCFMT_LEFT,    120 },
    { IDS_COL_MEMBEROF,     LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { AREA_SERVICE,         4,              0 },
    { IDS_COL_SERVICE,      LVCFMT_LEFT,    170 },
    { IDS_STARTUP,          LVCFMT_LEFT,    80 },
    { IDS_PERMISSION,       LVCFMT_LEFT,    80 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { POLICY_PASSWORD,      3,              0 },
    { IDS_ATTR,             LVCFMT_LEFT,    250 },
    { IDS_BASE_TEMPLATE,    LVCFMT_LEFT,    190 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { POLICY_PASSWORD_ANALYSIS, 4,          0 },
    { IDS_ATTR,             LVCFMT_LEFT,    200 },
    { IDS_BASE_ANALYSIS,    LVCFMT_LEFT,    120 },
    { IDS_SETTING,          LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { LOCALPOL_PASSWORD,    3,              0 },
    { IDS_ATTR,             LVCFMT_LEFT,    200 },
    { IDS_LOCAL_POLICY_COLUMN,             LVCFMT_LEFT,    120 },
    { IDS_RSOP_GPO,         LVCFMT_LEFT,    100 },
    { NONE,                 2,              0 },
    { IDS_NAME,             LVCFMT_LEFT,    180 },
    { IDS_DESC,             LVCFMT_LEFT,    270 },
};

HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
   HRESULT hr = S_OK;

   ASSERT(m_pHeader); //Check m_pHeader.
   if( !m_pHeader ) //Raid #550912, yanggao.
   {
      return E_FAIL;
   }
   // Create a new array of column sizes.  We just need to copy the static buffer
   // g_columnInfo.
   FOLDER_TYPES type;
   CFolder* pFolder = (CFolder *)cookie;
   if ( NULL == cookie) 
   {
      // the root
      type = NONE;
   } 
   else 
      type = pFolder->GetType();

   PSCE_COLUMNINFO pCur = NULL;
   CString str;
   int i = 0;
   int iDesc = 0;
   int iInsert = 0;

   PSCE_COLINFOARRAY pHeader = NULL;
   if(m_pComponentData){
       pHeader = reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->GetColumnInfo( type );
   }
   if( !pHeader )
   {
        // Create new header look up.
        switch(type){
        case AREA_REGISTRY:
        case AREA_FILESTORE:
           type = AREA_REGISTRY;
           break;

        case AREA_REGISTRY_ANALYSIS:
        case AREA_FILESTORE_ANALYSIS:
        case REG_OBJECTS:
        case FILE_OBJECTS:
           type = AREA_REGISTRY_ANALYSIS;
           break;

        case AREA_GROUPS:
        case AREA_GROUPS_ANALYSIS:
           type = AREA_GROUPS;
           break;

        case AREA_SERVICE:
        case AREA_SERVICE_ANALYSIS:
           type = AREA_SERVICE;
           break;

        default:
           if ( type >= POLICY_PASSWORD &&
                type <= AREA_FILESTORE ) 
           {
              type = POLICY_PASSWORD;
           } 
           else if ( type >= POLICY_PASSWORD_ANALYSIS &&
                       type <= REG_OBJECTS ) 
           {
              type = POLICY_PASSWORD_ANALYSIS;
           } 
           else if (type >= LOCALPOL_PASSWORD &&
                      type <= LOCALPOL_LAST) 
           {
              type = LOCALPOL_PASSWORD;
           } 
           else 
           {
               type = NONE;
           }
           break;
        }

        pCur = g_columnInfo;
        for( i = 0; i < sizeof(g_columnInfo)/sizeof(SCE_COLUMNINFO);i++)
        {
           if(pCur[i].colID == type)
           {
              iInsert = pCur[i].nCols;
              i++;
              break;
           }
           i += pCur[i].nCols;
        }

        //
        // RSOP Mode has an extra column for the GPO source
        // If we're not in RSOP mode then ignore that column
        //
        if (((GetModeBits() & MB_RSOP) != MB_RSOP) && (NONE != type)) 
        {
           iInsert--;
        }

        if(pFolder)
        {
            type = pFolder->GetType();
        }

        iDesc = i;
        pCur += iDesc;
        pHeader = (PSCE_COLINFOARRAY)LocalAlloc(0, sizeof(SCE_COLINFOARRAY) + (sizeof(int) * iInsert) );
        if(pHeader)
        {
            pHeader->iIndex = i;
            pHeader->nCols  = iInsert;

            for(i = 0; i < iInsert; i++)
            {
                pHeader->nWidth[i] = pCur[i].nWidth;
            }

            reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->SetColumnInfo( type, pHeader );
        }
   } 
   else 
   {
       iDesc   = pHeader->iIndex;
       iInsert = pHeader->nCols;
   }

   // Insert the columns.
   m_nColumns = iInsert;

   BOOL bGroupPolicy = FALSE;

   //
   // special case Group Policy mode since "Policy Setting" has
   // to be displayed instead of "Computer Setting"
   //

   if (GetModeBits() & MB_GROUP_POLICY) 
   {
       bGroupPolicy = TRUE;
   }

   pCur = g_columnInfo + iDesc;
   for(i = 0; i < iInsert; i++)
   {
        if (bGroupPolicy && pCur->colID == IDS_BASE_TEMPLATE) 
        {
            str.LoadString( IDS_POLICY_SETTING );
        }
        else 
        {
            str.LoadString( pCur->colID );
        }

        if(pHeader)
        {
            m_pHeader->InsertColumn( i, str, pCur->nCols, pHeader->nWidth[i] );
        } 
        else 
        {
            m_pHeader->InsertColumn( i, str, pCur->nCols, pCur->nWidth );
        }
        pCur++;
   }

   switch(type) {
      case STATIC:
      case ROOT:
      case ANALYSIS:
      case CONFIGURATION:
      case LOCATIONS:
      case PROFILE:
      case LOCALPOL:
      case POLICY_LOCAL:
      case POLICY_ACCOUNT:
      case POLICY_LOCAL_ANALYSIS:
      case POLICY_ACCOUNT_ANALYSIS:
      case LOCALPOL_ACCOUNT:
      case LOCALPOL_LOCAL:
         m_pResult->ModifyViewStyle(MMC_NOSORTHEADER,(MMC_RESULT_VIEW_STYLE)0);
         break;
      default:
         m_pResult->ModifyViewStyle((MMC_RESULT_VIEW_STYLE)0,MMC_NOSORTHEADER);
         break;
   }

   return hr;
}

HRESULT CSnapin::InitializeBitmaps(MMC_COOKIE cookie)
{
   ASSERT(m_pImageResult != NULL); //Validate m_pImageResult.
   if( !m_pImageResult )//Raid #550912, yanggao.
      return E_FAIL;

   CBitmap bmp16x16;
   CBitmap bmp32x32;

   // Load the bitmaps from the dll

   bmp16x16.LoadBitmap(IDB_ICON16 /*IDB_16x16 */);
   bmp32x32.LoadBitmap(IDB_ICON32 /*IDB_32x32 */);

   // Set the images
   m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                                     reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                                     0, RGB(255, 0, 255));

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   CComponentDataImpl::SerializeColumnInfo
//
//  Synopsis:   Saves or loads column information contained in m_mapColumns.
//              The function saves out the information in char format.
//              SCECOLUMNS:%d   - number of column information structures.
//              T:%d,           - type of column (key)
//              I:%d,           - Index into [g_columnInfo]
//              C:%d,           - Number of columns
//              W:%d,           - Width of a column.
//
//  Arguments:  [pStm]          - Stream to read or write to.
//              [pTotalWrite]   - [Optional] Total number of bytes written.
//              [bRead]         - If True then we should read from the stream.
//
//  Returns:    ERROR_SUCCESS   - Everything was successful.
//              E_OUTOFMEMORY   - Out of memory.
//
//  History:
//
//---------------------------------------------------------------------------
DWORD CComponentDataImpl::SerializeColumnInfo(
    IStream *pStm,
    ULONG *pTotalWrite,
    BOOL bRead)
{
   ULONG nBytesWritten = 0;
   POSITION pos = NULL;
   FOLDER_TYPES fType;
   PSCE_COLINFOARRAY pData = 0;
   ULONG totalWrite = 0;
   int i = 0;

   LPCTSTR pszHeader     = TEXT("SCECOLUMNS:%d{");
   LPCTSTR pszColHead    = TEXT("{T:%d,I:%d,C:%d,");
   if(!bRead)
   {
       // Write columns.  Save the information in text format so that we will be
       // independent of sizeof stuff.
       pos = m_mapColumns.GetStartPosition();
       totalWrite = 0;
       if(pos)
       {
           char szWrite[256];
           // Write header.
           totalWrite += WriteSprintf(pStm, pszHeader, m_mapColumns.GetCount());
           while(pos)
           {
               m_mapColumns.GetNextAssoc(pos, fType, pData);
               if(pData)
               {
                   // write out the type.
                   totalWrite += WriteSprintf(pStm, pszColHead, fType, g_columnInfo[pData->iIndex - 1].colID, pData->nCols);

                   // write out each column width.
                   for(i = 0; i < pData->nCols; i++)
                   {
                       if( i + 1 < pData->nCols)
                       {
                            totalWrite += WriteSprintf(pStm, TEXT("W:%d,"), pData->nWidth[i]);
                       } 
                       else 
                       {
                            totalWrite += WriteSprintf(pStm, TEXT("W:%d}"), pData->nWidth[i]);
                       }
                   }
               }
           }
           totalWrite += WriteSprintf(pStm, TEXT("}"));
       }

       if(pTotalWrite)
       {
           *pTotalWrite = totalWrite;
       }
   } 
   else 
   {
       int iTotalTypes = 0;
       int iIndex = 0;
       int nCols = 0;

       if( ReadSprintf( pStm, pszHeader, &iTotalTypes) != -1)
       {
           for( i = 0; i < iTotalTypes; i++)
           {
               if( ReadSprintf(pStm, pszColHead, &fType, &iIndex, &nCols) == - 1)
               {
                   break;
               }

               // find index of column information.
               for(int k = 0; k < sizeof(g_columnInfo)/sizeof(SCE_COLUMNINFO); k++)
               {
                   if( g_columnInfo[k].colID == iIndex )
                   {
                       iIndex = k + 1;
                       break;
                   }
               }

               pData = (PSCE_COLINFOARRAY)LocalAlloc(0, sizeof(SCE_COLINFOARRAY) + (sizeof(int) * nCols) );

               if(pData)
               {
                   pData->iIndex = iIndex;
                   pData->nCols = nCols;

                   for( iIndex = 0; iIndex < nCols; iIndex++)
                   {
                       if( iIndex + 1 < nCols)
                            ReadSprintf(pStm, TEXT("W:%d,"), &(pData->nWidth[ iIndex ]) );
                       else 
                            ReadSprintf(pStm, TEXT("W:%d}"), &(pData->nWidth[ iIndex ]) );
                   }

                   SetColumnInfo( fType, pData );
               } 
               else
                   return (DWORD)E_OUTOFMEMORY;
           }
           ReadSprintf(pStm, TEXT("}"));
       }
   }

   return ERROR_SUCCESS;
}
//+--------------------------------------------------------------------------
//
//  Method:     EnumerateResultPane
//
//  Synopsis:   Create the result pane items for the result pane that MMC
//              is displaying
//
//  Arguments:  [cookie]   - The cookie representing the node's who we
//                           are enumerating
//              [pParent]  - The scope node whose result pane we are showing
//              [pDataObj] - The data object for the scope node we are showing
//
//  Returns:    none
//
//  Modifies:   m_resultItemList
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------
void CSnapin::EnumerateResultPane(MMC_COOKIE cookie, HSCOPEITEM pParent, LPDATAOBJECT pDataObj)
{
   PEDITTEMPLATE pTemplateInfo = 0;
   PEDITTEMPLATE pProfileTemplate = 0;
   PEDITTEMPLATE pBaseTemplate = 0;
   PSCE_PROFILE_INFO pProfileInfo = 0;
   PSCE_PROFILE_INFO pBaseInfo = 0;
   DWORD idErr = 0;
   CComponentDataImpl *pccDataImpl = 0;

   //Validate m_pResult and m_pComponentData.
   ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
   ASSERT(m_pComponentData != NULL);
   if( !m_pResult || !m_pComponentData ) //Raid #550912, yanggao.
      return;

   pccDataImpl = (CComponentDataImpl *)m_pComponentData;
   //
   // This may take a while; let the user have some warning rather than
   // just going blank on them
   //
   CWaitCursor wc;

   //
   // cookie is the scope pane item for which to enumerate.
   // for safety, we should find the object in m_pComponentData
   //   CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie, NULL);
   // but for performance (and hopes nothing mess up), we could
   // cast the cookie to scope item type (CFolder)
   //

   CFolder* pFolder = 0;
   CString sErr;
   SCESTATUS rc = 0;

   PSCE_ERROR_LOG_INFO ErrBuf=NULL;
   AREA_INFORMATION area=0;
   CString StrErr;
   PVOID pHandle=NULL;

   if ( cookie ) 
      pFolder = (CFolder *)cookie;
   else
      pFolder = ((CComponentDataImpl *)m_pComponentData)->FindObject(cookie, NULL);
   

   //
   // pFolder could be NULL for the root.
   //
   if ( pFolder == NULL ) 
      return;
   
   FOLDER_TYPES type = pFolder->GetType();
   if( pFolder == m_pSelectedFolder &&
      m_pSelectedFolder &&
      m_pSelectedFolder->GetResultListCount() ) 
   {
      //
      // Do nothing.
      return;
   } 
   else 
   {
      if( m_pSelectedFolder && m_resultItemHandle )
      {
         m_pSelectedFolder->ReleaseResultItemHandle( m_resultItemHandle );
      }

      pFolder->GetResultItemHandle( &m_resultItemHandle );
      m_pSelectedFolder = pFolder;
      if( pFolder->GetResultListCount() )
      {
         goto AddToResultPane;
      }
   }
   //
   // If this is the top Analysis folder and it hasn't been enumerated yet then
   // Make sure we do so and put back any folders that we've removed from there,
   // Since MMC won't give us a second expand event to do it on
   //

   //
   // The Analysis Pane isn't available now; let the user know why
   //
   if (type == ANALYSIS) 
   {
      if (((CComponentDataImpl *) m_pComponentData)->m_bIsLocked) 
      {
         //
         // should print more informative messages as to why the info isn't available
         //
         AddResultItem(IDS_ERROR_ANALYSIS_LOCKED, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      if (!(((CComponentDataImpl *) m_pComponentData)->SadHandle)) 
      {
         //
         // should print more informative messages as to why the info isn't available
         //
         FormatDBErrorMessage(
               ((CComponentDataImpl *)m_pComponentData)->SadErrored,
               ((CComponentDataImpl *)m_pComponentData)->SadName,
               sErr);

         sErr.TrimLeft();
         sErr.TrimRight();

         AddResultItem(sErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);

         goto AddToResultPane;
      }
   }
   if (type == ANALYSIS ||
       (type >= AREA_POLICY_ANALYSIS && type <= REG_OBJECTS)) 
   {
      CString strDBName;
      CString strDBFmt;
      CString strDB;
      LPTSTR szDBName;
      strDB = ((CComponentDataImpl *)m_pComponentData)->SadName;
      if (strDB.IsEmpty() || IsSystemDatabase(strDB)) 
         strDBFmt.LoadString(IDS_SYSTEM_DB_NAME_FMT);
      else 
         strDBFmt.LoadString(IDS_PRIVATE_DB_NAME_FMT);
      
      strDBName.Format(strDBFmt,strDB);
      szDBName = strDBName.GetBuffer(1);
      m_pResult->SetDescBarText(szDBName);
      //AddResultItem(strDBFmt,NULL,NULL,ITEM_OTHER,SCE_STATUS_GOOD,cookie);
   }

   if (type >= CONFIGURATION && type <= AREA_FILESTORE) 
   {
      //
      // We're in the Profile area, so we don't need to keep the Analysis area
      // open.  Close it to save memory:
      //
      ((CComponentDataImpl *)m_pComponentData)->CloseAnalysisPane();
   }

   if ( type == PROFILE ) 
   {
      //
      // Do not display the error message if we do not implement native modes.
      //
      if( pFolder->GetState() & CFolder::state_InvalidTemplate &&
         !(pFolder->GetMode() & MB_NO_NATIVE_NODES ))
      {
         StrErr.LoadString( IDS_ERROR_CANT_OPEN_PROFILE );
            AddResultItem(StrErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      } 
      else if (pFolder->GetMode() == SCE_MODE_DOMAIN_COMPUTER_ERROR) 
      {
         StrErr.LoadString( IDS_ERROR_NOT_ON_PDC );
            AddResultItem(StrErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
   }

   if ( (type < AREA_POLICY) ||
        (type > AREA_LAST)) 
   {
      return;
   }


   switch (type) 
   {
      case AREA_PRIVILEGE:
      case AREA_PRIVILEGE_ANALYSIS:
      case LOCALPOL_PRIVILEGE:
         area = AREA_PRIVILEGES;
         break;

      case AREA_GROUPS:
      case AREA_GROUPS_ANALYSIS:
         area = AREA_GROUP_MEMBERSHIP;
         break;

      case AREA_SERVICE:
      case AREA_SERVICE_ANALYSIS:
         area = AREA_SYSTEM_SERVICE;
         break;

      case AREA_REGISTRY:
      case AREA_REGISTRY_ANALYSIS:
      case REG_OBJECTS:
         area = AREA_REGISTRY_SECURITY;
         break;

      case AREA_FILESTORE:
      case AREA_FILESTORE_ANALYSIS:
      case FILE_OBJECTS:
         area = AREA_FILE_SECURITY;
         break;

      default:
         // case AREA_POLICY:
         // case AREA_POLICY_ANALYSIS:
         // case AREA_LOCALPOL_POLICY:
         area = AREA_SECURITY_POLICY;
         break;
   }

   if ( type >= AREA_POLICY &&
        type <= AREA_FILESTORE ) 
   {
      //
      // inf profiles
      //
      ASSERT(pFolder->GetInfFile());
      if ( pFolder->GetInfFile() == NULL ) 
         return;

      //
      // Get the Profile info from the cache
      //
      pTemplateInfo = GetTemplate(pFolder->GetInfFile(),AREA_ALL,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr,NULL,NULL,ITEM_OTHER,SCE_STATUS_ERROR_NOT_AVAILABLE,cookie);
      } 
      else 
      {
         CreateProfileResultList(cookie,
                                 type,
                                 pTemplateInfo,
                                 pDataObj);
      }
   } 
   else if ((type >= LOCALPOL_ACCOUNT) &&
              (type <= LOCALPOL_LAST)) 
   {
      if (!((CComponentDataImpl*)m_pComponentData)->SadHandle &&
          (ERROR_SUCCESS != ((CComponentDataImpl*)m_pComponentData)->SadErrored)) 
      {
         ((CComponentDataImpl*)m_pComponentData)->LoadSadInfo(FALSE);
      }
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      //
      // Get the Computer and Last Inspection Templates
      //
      pTemplateInfo = GetTemplate(GT_EFFECTIVE_POLICY,area,&idErr);

      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pBaseTemplate = pTemplateInfo;

      pTemplateInfo = GetTemplate(GT_LOCAL_POLICY,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pProfileTemplate = pTemplateInfo;

      CreateLocalPolicyResultList(cookie, type, pProfileTemplate, pBaseTemplate, pDataObj);
   } 
   else if ( area != AREA_REGISTRY_SECURITY &&
               area != AREA_FILE_SECURITY &&
               area != AREA_DS_OBJECTS ) 
   {
      //
      // SadName and SadHandle should already been populated
      //
      if (!((CComponentDataImpl*)m_pComponentData)->SadHandle &&
         ((CComponentDataImpl*)m_pComponentData)->SadErrored != SCESTATUS_SUCCESS) 
      {
         ((CComponentDataImpl*)m_pComponentData)->LoadSadInfo(TRUE);
      }
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      if ( NULL == pHandle ) 
      {
         AddResultItem(IDS_ERROR_NO_ANALYSIS_INFO, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      //
      // Get the Computer and Last Inspection Templates
      //
      pTemplateInfo = GetTemplate(GT_COMPUTER_TEMPLATE,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pBaseTemplate = pTemplateInfo;

      pTemplateInfo = GetTemplate(GT_LAST_INSPECTION,area,&idErr);
      if (!pTemplateInfo) 
      {
         AddResultItem(idErr, NULL, NULL, ITEM_OTHER, SCE_STATUS_ERROR_NOT_AVAILABLE, cookie);
         goto AddToResultPane;
      }
      pProfileTemplate = pTemplateInfo;

      CreateAnalysisResultList(cookie, type, pProfileTemplate, pBaseTemplate,pDataObj);
   } 
   else if (AREA_FILE_SECURITY == area) 
   {
      // registry and file objects
      // SadName and SadHandle should already been populated
      pHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
      if ( NULL == pHandle ) 
      {
         return;
      }
      PSCE_OBJECT_CHILDREN ObjectList=NULL;

      if ( type == FILE_OBJECTS ) 
      {
         // get next level objects
         rc = SceGetObjectChildren(pHandle,
                                   SCE_ENGINE_SAP,
                                   area,
                                   pFolder->GetName(),
                                   &ObjectList,
                                   &ErrBuf);
      }

      CreateObjectResultList(cookie, type, area, ObjectList, pHandle, pDataObj);

      if ( (type == REG_OBJECTS || type == FILE_OBJECTS) && ObjectList ) 
      {
         SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN);
      }

   }

   // free memory buffers
   if ( ErrBuf ) 
      SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
   

AddToResultPane:
   if (m_pResult)
   {
       //
       // Prepare the result window.
       //
       m_pResult->SetItemCount(
                        m_pSelectedFolder->GetResultListCount( ),
                        MMCLV_UPDATE_NOINVALIDATEALL);

      RESULTDATAITEM resultItem;

      ZeroMemory(&resultItem,sizeof(resultItem));
      resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
      resultItem.str = MMC_CALLBACK;
      resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;


      // Set the result as the cookie
      POSITION pos = NULL;
      do {
         if( m_pSelectedFolder->GetResultItem(
                           m_resultItemHandle,
                           pos,
                           (CResult **)&(resultItem.lParam)
                           ) == ERROR_SUCCESS)
        {
           if(resultItem.lParam)
           {
               m_pResult->InsertItem(&resultItem);
           }
        } 
        else
           break;
      } while(pos);
      m_pResult->Sort(0, 0, 0);
   }
}

void ConvertNameListToString(PSCE_NAME_LIST pList, LPTSTR *sz, BOOL fReverse)
{
   LPTSTR pszNew;
   if (NULL == sz)
      return;
   

   if (NULL == pList)
      return;
   
   //
   // Get Total size for buffer.
   //
   int iSize = 0;
   PSCE_NAME_LIST pTemp = 0;
   for( pTemp=pList;pTemp != NULL; pTemp=pTemp->Next) 
   {
       if ( !(pTemp->Name) )
           continue;
       
       iSize += lstrlen(pTemp->Name) + 1;
   }

   //
   // Allocate buffer.
   //
   pszNew = new TCHAR[iSize + 1];
   if (!pszNew)
       return;
   

   *sz = pszNew;
   //
   // Copy the strings.
   //
   if( fReverse ) //Raid #483744, yanggao, reverse order.
   {
      pszNew = pszNew + iSize - 1;
      *pszNew = 0;
      for (pTemp=pList; pTemp != NULL; pTemp=pTemp->Next) 
      {
         if (!(pTemp->Name))
            continue;
        
         iSize = lstrlen(pTemp->Name);
         pszNew = pszNew - iSize;
         //This may not be a safe usage. pTemp->Name is PWCHAR and pszNew is LPTSTR. Consider fix.
         memcpy(pszNew, pTemp->Name, iSize * sizeof(TCHAR));
         if( NULL != pTemp->Next )
         {
            pszNew--;
            *pszNew = L',';
         }
      }
   }
   else
   {
      for (pTemp=pList; pTemp != NULL; pTemp=pTemp->Next) 
      {
         if (!(pTemp->Name))
            continue;
        
         iSize = lstrlen(pTemp->Name);
         //This may not be a safe usage. pTemp->Name is PWCHAR. Consider fix.
         memcpy(pszNew, pTemp->Name, iSize * sizeof(TCHAR));
         pszNew += iSize;
         *pszNew = L',';
         pszNew++;
      }
      *(pszNew - 1) = 0;
   }
}


//+--------------------------------------------------------------------------
//
//  Method:     CreateProfileResultList
//
//  Synopsis:   Create the result pane items for profile section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [pSceInfo] - The overall template that we are enumerating
//              [pDataObj] - The data object for this folder
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void
CSnapin::CreateProfileResultList(MMC_COOKIE cookie,
                                 FOLDER_TYPES type,
                                 PEDITTEMPLATE pSceInfo,
                                 LPDATAOBJECT pDataObj)
{
   bool     bVerify=false;
   CString  listStr;
   PSCE_PRIVILEGE_ASSIGNMENT pPriv=NULL;
   PSCE_GROUP_MEMBERSHIP pGroup=NULL;
   PSCE_OBJECT_ARRAY pObject = 0;
   UINT i  = 0;

   switch (type) 
   {
      case POLICY_KERBEROS:
      case POLICY_PASSWORD:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
      case POLICY_OTHER:
      case POLICY_LOG:
         CreateProfilePolicyResultList(cookie,
                                       type,
                                       pSceInfo,
                                       pDataObj);
         break;

      case AREA_POLICY:
         //
         // Policy folder only contains other folders, no actual result items
         //
         break;

      case AREA_PRIVILEGE: 
         {
            CString strDisp;
            LPTSTR szDisp;
            DWORD cbDisp;
            szDisp = new TCHAR [255];

            if (!szDisp) 
               break;

            LPTSTR szPriv = new TCHAR [255];
            if ( !szPriv )
            {
                delete[] szDisp;
                break;
            }

            for ( int i2=0; i2<cPrivCnt; i2++ ) 
            {
                cbDisp = 255;
                if ( SCESTATUS_SUCCESS == SceLookupPrivRightName(i2,szPriv, (PINT)&cbDisp) ) 
                {
                    for (pPriv=pSceInfo->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                         pPriv!=NULL;
                         pPriv=pPriv->Next) 
                    {
                        if ( _wcsicmp(szPriv, pPriv->Name) == 0 ) 
                            break;
                    }

                    cbDisp = 255;
                    if ( pPriv ) 
                    {
                        //
                        // find it in the template
                        //
                        GetRightDisplayName(NULL,(LPCTSTR)pPriv->Name,szDisp,&cbDisp);
                        long itemid = GetUserRightAssignmentItemID(szPriv); //Raid #595121, yanggao, 4/4/2002.
                        AddResultItem(szDisp,                    // The name of the attribute being added
                                      (LONG_PTR)(i2>=cPrivW2k),  // Raid #382263, The last inspected setting of the attribute
                                      (LONG_PTR)pPriv->AssignedTo,  // The template setting of the attribute
                                      ITEM_PROF_PRIVS,           // The type of of the attribute's data
                                      -1,                        // The mismatch status of the attribute
                                      cookie,                    // The cookie for the result item pane
                                      FALSE,                     // Copy last inspected from template
                                      NULL,                      // The units the attribute is set in
                                      (LONG_PTR) pPriv,          // An id to let us know where to save this attribute
                                      pSceInfo,                  // The template to save this attribute in
                                      pDataObj,                  // The data object for the scope note who owns the result pane
                                      NULL,                      // CResult*
                                      itemid                     // Identify this item    
                                      );
                    } 
                    else 
                    {
                        //
                        // a not configured privilege
                        //
                        GetRightDisplayName(NULL,(LPCTSTR)szPriv,szDisp,&cbDisp);

                        long itemid = GetUserRightAssignmentItemID(szPriv);
                        
                        AddResultItem(szDisp,                    // The name of the attribute being added
                                      (LONG_PTR)(i2>=cPrivW2k),  // Raid #382263, The last inspected setting of the attribute
                                      (LONG_PTR)ULongToPtr(SCE_NO_VALUE),  // The template setting of the attribute
                                      ITEM_PROF_PRIVS,           // The type of of the attribute's data
                                      -1,                        // The mismatch status of the attribute
                                      cookie,                    // The cookie for the result item pane
                                      FALSE,                     // Copy last inspected from template
                                      szPriv,                    // Save the privilege name in this buffer
                                      0,                         // An id to let us know where to save this attribute
                                      pSceInfo,                  // The template to save this attribute in
                                      pDataObj,                  // The data object for the scope note who owns the result pane
                                      NULL,                      // CResult*
                                      itemid                     // Identify this item
                                      );
                    }
                } 
                else 
                {
                    // impossible, just continue
                }

            }

            delete[] szDisp;
            delete[] szPriv;
         }
         break;

      case AREA_GROUPS:
         for (pGroup=pSceInfo->pTemplate->pGroupMembership;
              pGroup!=NULL;
              pGroup=pGroup->Next) 
         {
            AddResultItem((LPCTSTR)pGroup->GroupName,    // The name of the attribute being added
                          0,                             // The last inspection
                          (LONG_PTR)pGroup,              // The template info
                          ITEM_PROF_GROUP,               // The type of of the attribute's data
                          -1,                            // The mismatch status of the attribute
                          cookie,                        // The cookie for the result item pane
                          FALSE,                         // Copy last inspected from template
                          NULL,                          // The units the attribute is set in
                          (LONG_PTR)pGroup,              // An id to let us know where to save this attribute
                          pSceInfo,                      // The template to save this attribute in
                          pDataObj,                     // The data object for the scope note who owns the result pane
                          NULL,
                          IDS_RESTRICTED_GROUPS);       // Assing a ID to this item.
         }
         break;

      case AREA_SERVICE:
         CreateProfServiceResultList(cookie,
                                     type,
                                     pSceInfo,
                                     pDataObj);
         break;

      case AREA_REGISTRY:
         pObject = pSceInfo->pTemplate->pRegistryKeys.pAllNodes;
         if ( pObject!=NULL ) 
         {
            for (i=0; i<pObject->Count; i++) 
            {

               AddResultItem(pObject->pObjectArray[i]->Name,                        // The name of the attribute being added
                             NULL,                                                  // The last inspected setting of the attribute
                             (LONG_PTR)pObject->pObjectArray[i]->pSecurityDescriptor,  // The template setting of the attribute
                             ITEM_PROF_REGSD,                                       // The type of of the attribute's data
                             pObject->pObjectArray[i]->Status,                      // The mismatch status of the attribute
                             cookie,                                                // The cookie for the result item pane
                             FALSE,                                                 // Copy last inspected from template
                             NULL,                                                  // The units the attribute is set in
                             (LONG_PTR)pObject->pObjectArray[i],                       // An id to let us know where to save this attribute
                             pSceInfo,                                              // The template to save this attribute in
                             pDataObj,                                              // The data object for the scope note who owns the result pane
                             NULL,
                             IDS_REGISTRY_SETTING);                                 //Assign an ID to this item
            }
         }
         break;

      case AREA_FILESTORE:
         pObject = pSceInfo->pTemplate->pFiles.pAllNodes;
         if ( pObject!=NULL ) 
         {
            for (i=0; i<pObject->Count; i++) 
            {

               AddResultItem(pObject->pObjectArray[i]->Name,                        // The name of the attribute being added
                             NULL,                                                  // The last inspected setting of the attribute
                             (LONG_PTR)pObject->pObjectArray[i]->pSecurityDescriptor,  // The template setting of the attribute
                             ITEM_PROF_FILESD,                                      // The type of of the attribute's data
                             pObject->pObjectArray[i]->Status,                      // The mismatch status of the attribute
                             cookie,                                                // The cookie for the result item pane
                             FALSE,                                                 // Copy last inspected from template
                             NULL,                                                  // The units the attribute is set in
                             (LONG_PTR)pObject->pObjectArray[i],                       // An id to let us know where to save this attribute
                             pSceInfo,                                              // The template to save this attribute in
                             pDataObj,                                              // The data object for the scope note who owns the result pane
                             NULL,
                             IDS_FILESYSTEM_SETTING);                               // Assign an ID to this item
            }
         }
         break;

      default:
         break;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAnalysisResultList
//
//  Synopsis:   Create the result pane items for the analysis section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [pSceInfo] - The last inspection template that we are enumerating
//              [pSceBase] - The computer template that we are enumerating
//              [pDataObj] - The data object for this folder
//
//  Returns:    none
//
//---------------------------------------------------------------------------

void CSnapin::CreateAnalysisResultList(MMC_COOKIE cookie,
                                  FOLDER_TYPES type,
                                  PEDITTEMPLATE pSceInfo,
                                  PEDITTEMPLATE pBase,
                                  LPDATAOBJECT pDataObj )
{
   bool     bVerify=true;
   CString  listStr;
   CString  listBase;
   PSCE_PRIVILEGE_ASSIGNMENT pPriv = 0;
   PSCE_PRIVILEGE_ASSIGNMENT pPrivBase = 0;
   UINT i = 0;

   switch (type) 
   {
      case POLICY_KERBEROS_ANALYSIS:
      case POLICY_PASSWORD_ANALYSIS:
      case POLICY_LOCKOUT_ANALYSIS:
      case POLICY_AUDIT_ANALYSIS:
      case POLICY_OTHER_ANALYSIS:
      case POLICY_LOG_ANALYSIS:
         CreateAnalysisPolicyResultList(cookie,
                                        type,
                                        pSceInfo,
                                        pBase,
                                        pDataObj);
         break;

      case AREA_POLICY_ANALYSIS:
         break;

      case AREA_PRIVILEGE_ANALYSIS: 
         {
            // find in the current setting list
            TCHAR szDisp[255];
            DWORD cbDisp = 0;
            for (pPriv=pSceInfo->pTemplate->OtherInfo.sap.pPrivilegeAssignedTo;
                pPriv!=NULL;
                pPriv=pPriv->Next) 
            {

               // find in the base setting list
               for (pPrivBase=pBase->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo;
                   pPrivBase!=NULL;
                   pPrivBase=pPrivBase->Next) 
               {

                  if ( pPrivBase->Value == pPriv->Value )
                     break;
               }


               cbDisp = 255;
               GetRightDisplayName(NULL,(LPCTSTR)pPriv->Name,szDisp,&cbDisp);

               long itemid = GetUserRightAssignmentItemID(pPriv->Name);
               
               if (pPrivBase == NULL)
               {
                   pPrivBase = (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE);
               }
               AddResultItem(szDisp,              // The name of the attribute being added
                             (LONG_PTR)pPriv,        // The last inspected setting of the attribute
                             (LONG_PTR)pPrivBase,    // The template setting of the attribute
                             ITEM_PRIVS,          // The type of of the attribute's data
                             pPriv->Status,       // The mismatch status of the attribute
                             cookie,              // The cookie for the result item pane
                             FALSE,               // True if the setting is set only if it differs from base (so copy the data)
                             NULL,                // The units the attribute is set in
                             0,                   // An id to let us know where to save this attribute
                             pBase,               // The template to save this attribute in
                             pDataObj,            // The data object for the scope note who owns the result pane
                             NULL,
                             itemid);             // Assign an ID to this item
            }
         }
         break;

      case AREA_GROUPS_ANALYSIS: 
         {
            PSCE_GROUP_MEMBERSHIP pGroup = 0;
            PSCE_GROUP_MEMBERSHIP grpBase = 0;

            //
            // it is OK to start with pSceInfo because each group at least has
            // PrivilegesHeld field not null.
            //
            bVerify = FALSE;
            for (pGroup=pSceInfo->pTemplate->pGroupMembership; pGroup!=NULL; pGroup=pGroup->Next) 
            {
               //
               // find the base to compare with
               //

               if ( NULL == pGroup->GroupName )
                   continue;

               for (grpBase=pBase->pTemplate->pGroupMembership; grpBase!=NULL;
                   grpBase=grpBase->Next) 
               {
                  if ( grpBase->GroupName &&
                       _wcsicmp(pGroup->GroupName, grpBase->GroupName) == 0 ) 
                  {
                     break;
                  }
               }

               AddResultItem((LPCTSTR)pGroup->GroupName,    // The name of the attribute being added
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_MEMBEROF), // The last inspected setting of the attribute
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_MEMBERS), // The template setting of the attribute
                             ITEM_GROUP,                    // The type of of the attribute's data
                             GetGroupStatus(pGroup->Status, STATUS_GROUP_RECORD),  // status             // The mismatch status of the attribute
                             cookie,                        // The cookie for the result item pane
                             FALSE,                         // Copy last inspected from template
                             (LPTSTR)grpBase, //NULL,        // The units the attribute is set in
                             (LONG_PTR)pGroup,                 // An id to let us know where to save this attribute
                             pBase, //pSceInfo,                      // The template to save this attribute in
                             pDataObj,                     // The data object for the scope note who owns the result pane
                             NULL,
                             IDS_RESTRICTED_GROUPS);        // Assign an ID to this item
            }
         }
         break;

      case AREA_SERVICE_ANALYSIS:
         //         AddResultItem(L"Not Implemented", NULL, NULL, ITEM_OTHER, -1, cookie);
         CreateAnalysisServiceResultList(cookie,
                                         type,
                                         pSceInfo,
                                         pBase,
                                         pDataObj);

         break;

      default:
         break;
   }

}

//+--------------------------------------------------------------------------
//
//  Method:     CreateObjectResultList
//
//  Synopsis:   Create the result pane items for an Object section
//
//  Arguments:  [cookie]   - The cookie representing the folder which we
//                           are enumerating
//              [type]     - The type of the folder we are enumerating
//              [Area]     - The SCE Area we're enumerating
//              [pObjList] - The array of object to enumerate
//              [pHandle]  -
//              [pDataObj] - The data object for the folder we're enumerating
//
//  Returns:    none
//
//---------------------------------------------------------------------------
void CSnapin::CreateObjectResultList(MMC_COOKIE cookie,
                                     FOLDER_TYPES type,
                                     AREA_INFORMATION Area,
                                     PSCE_OBJECT_CHILDREN pObjList,
                                     PVOID pHandle,
                                     LPDATAOBJECT pDataObj )
{
   if ( pObjList == NULL ) 
   {
       //
       // no object to add
       //
       return;
   }

   PWSTR ObjSetting=NULL;
   PWSTR ObjBase=NULL;
   CString tmpstr;
   LPTSTR szPath = NULL;

   RESULT_TYPES rsltType;
   if ( Area == AREA_REGISTRY_SECURITY)
      rsltType = ITEM_REGSD;
   else if ( Area == AREA_FILE_SECURITY )
      rsltType = ITEM_FILESD;
   else 
   {
      ASSERT(FALSE);
      return;
   }

   PSCE_OBJECT_CHILDREN_NODE *pObjNode=&(pObjList->arrObject);

   for (DWORD i=0; i<pObjList->nCount; i++) 
   {
      BOOL bContainer = FALSE;
      CString strName;

      if ( pObjNode[i] == NULL ||
           pObjNode[i]->Name == NULL ) 
      {
          continue;
      }

      if (AREA_FILE_SECURITY == Area) 
      {
         DWORD dw = (DWORD)-1;

         strName = ((CFolder *)cookie)->GetName();
         if (strName.Right(1) != L"\\") 
         {
            strName += L"\\";
         }
         strName += pObjNode[i]->Name;
         dw = GetFileAttributes(strName);
         if ((DWORD)-1 == dw) 
         {
            //
            // GetFileAttributes should never fail, but in case it does assume
            // that this isn't a container (this matches CreateFolderList)
            //
            bContainer = FALSE;
         }
         else 
         {
            bContainer = dw & FILE_ATTRIBUTE_DIRECTORY;
         }
      } 
      else 
      {
         bContainer = FALSE;
      }
      if ( !bContainer ) 
      {
         //
         // only add the leaf objects in result pane.
         // non-leaf objects are added to the scope pane already
         //
         PEDITTEMPLATE pBaseObject=NULL;

         if ( type == REG_OBJECTS ||
              type == FILE_OBJECTS ) 
         {
            tmpstr = ((CFolder*)cookie)->GetName();
            if (tmpstr.Right(1) != L"\\") 
            {
               tmpstr += L"\\";
            }
            tmpstr += pObjNode[i]->Name;

         } 
         else 
         {
            //
            // shouldn't get here
            //
            tmpstr = TEXT("");
         }

         szPath = (LPTSTR) malloc((tmpstr.GetLength()+1) * sizeof(TCHAR));
         if (szPath) 
         {
            //This is a safe usage.
            lstrcpy(szPath,tmpstr.GetBuffer(2));

            long itemID = 0; //Raid #510407, 2/28/2002, yanggao
            if( REG_OBJECTS == type )
            {
               itemID = IDS_REGISTRY_SETTING;
            }
            else
            if( FILE_OBJECTS == type )
            {
               itemID = IDS_FILESYSTEM_SETTING;
            }
            AddResultItem(pObjNode[i]->Name,  //   The name of the attribute being added
                          NULL,           //   The last inspected setting of the attribute
                          NULL,           //   The template setting of the attribute
                          rsltType,       //   The type of of the attribute's data
                          pObjNode[i]->Status,//   The mismatch status of the attribute
                          cookie,         //   The cookie for the result item pane
                          FALSE,          //   True if the setting is set only if it differs from base (so copy the data)
                          szPath,         //   The units the attribute is set in
                          (LONG_PTR)pHandle, //   An id to let us know where to save this attribute
                          pBaseObject,    //   The template to save this attribute in
                          pDataObj,       //   The data object for the scope note who owns the result pane
                          NULL,
                          itemID);        // Assign an ID to this item
         } 
         else 
         {
            // Out of memory
         }
      }
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add an item to the result pane from a string resource
//
//  Arguments: [rID]       - The resource id of name of the attribute being added
//             [setting]   - The last inspected setting of the attribute
//             [base]      - The template setting of the attribute
//             [type]      - The type of of the attribute's data
//             [status]    - The mismatch status of the attribute
//             [cookie]    - The cookie for the result item pane
//             [bVerify]   - True if the setting is set only if it differs
//                           from base (so copy the data)
//             [pBaseInfo] - The template to save this attribute in
//             [pDataObj]  - The data object for the scope note who owns the result pane
//
//  Returns:   a pointer to the CResult created to hold the item
//
//  History:
//
//---------------------------------------------------------------------------
CResult* CSnapin::AddResultItem(UINT rID,
                       LONG_PTR setting,
                       LONG_PTR base,
                       RESULT_TYPES type,
                       int status,
                       MMC_COOKIE cookie,
                       BOOL bVerify,
                       PEDITTEMPLATE pBaseInfo,
                       LPDATAOBJECT pDataObj,
                       long hID)
{
   CString strRes;
   strRes.LoadString(rID);

   if( hID == 0 ) //If no help ID is assigned then use its item ID.
   {
      hID = rID;
   }

   if (!strRes)
      return NULL;


   LPCTSTR Attrib = 0;
   LPCTSTR unit=NULL;

   //
   // The unit for the attribute is stored in the resource after a \n
   //
   int npos = strRes.ReverseFind(L'\n');
   if ( npos > 0 ) 
   {
      Attrib = strRes.GetBufferSetLength(npos);
      unit = (LPCTSTR)strRes+npos+1;
   } 
   else 
   {
      Attrib = (LPCTSTR)strRes;
   }

   return AddResultItem(Attrib,setting,base,type,status,cookie,bVerify,unit,rID,pBaseInfo,pDataObj,NULL,hID);
}


//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add an item to the result pane
//
//  Arguments: [Attrib]    - The name of the attribute being added
//             [setting]   - The last inspected setting of the attribute
//             [base]      - The template setting of the attribute
//             [type]      - The type of of the attribute's data
//             [status]    - The mismatch status of the attribute
//             [cookie]    - The cookie for the result item pane
//             [bVerify]   - True if the setting is set only if it differs
//                           from base (so copy the data)
//             [unit]      - The units the attribute is set in
//             [nID]       - An id to let us know where to save this attribute
//             [pBaseInfo] - The template to save this attribute in
//             [pDataObj]  - The data object for the scope note who owns the result pane
//
//  Returns:   a pointer to the CResult created to hold the item
//
//  History:
//
//---------------------------------------------------------------------------
CResult* CSnapin::AddResultItem(LPCTSTR Attrib,
                       LONG_PTR setting,
                       LONG_PTR base,
                       RESULT_TYPES type,
                       int status,
                       MMC_COOKIE cookie,
                       BOOL bVerify,
                       LPCTSTR unit,
                       LONG_PTR nID,
                       PEDITTEMPLATE pBaseInfo,
                       LPDATAOBJECT pDataObj,
                       CResult *pResult,
                       long hID)
{
   if ( bVerify ) 
   {
      if ( (LONG_PTR)SCE_NOT_ANALYZED_VALUE == setting ) 
      {
         //
         // The setting was changed but has not been analyzed.
         //
         status = SCE_STATUS_NOT_ANALYZED;
      } 
      else if ( base == (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ||
           (BYTE)base == (BYTE)SCE_NO_VALUE ) 
      {
         //
         // The setting is no longer configured.
         //
         status = SCE_STATUS_NOT_CONFIGURED;

      } 
      else if ( !(m_pSelectedFolder->GetModeBits() &  MB_LOCAL_POLICY) &&
                  (setting == (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ||
                  (BYTE)setting == (BYTE)SCE_NO_VALUE )) 
      {
         // add the base for current setting
         setting = base;
         status = SCE_STATUS_GOOD;  // a good item

      } 
      else if ( setting != base ) 
         status = SCE_STATUS_MISMATCH;
      else
         status = SCE_STATUS_GOOD;
   }

   CResult* pNewResult = pResult;
   if (!pNewResult)
   {
       pNewResult = new CResult();
       // refCount is already 1 // result->AddRef();
   }

   ASSERT(pNewResult);

   if ( pNewResult ) 
   {
      pNewResult->Create(Attrib,
                     base,
                     setting,
                     type,
                     status,
                     cookie,
                     unit,
                     nID,
                     pBaseInfo,
                     pDataObj,
                     m_pNotifier,
                     this,
                     hID);

      if (!pResult)
      {
         m_pSelectedFolder->AddResultItem (
                        m_resultItemHandle,
                        pNewResult);
      }
   }
   return pNewResult;
}



//+--------------------------------------------------------------------------
//
//  Method:    AddResultItem
//
//  Synopsis:  Add a group item to the analysis section result pane.
//             This adds three actual result pane items:
//                1) The actual name of the group
//                2) The members of the group
//                3) The groups this group is a member of
//
//  Arguments: [szName]      - The name of the group being added
//             [grpTemplate] - The last inspected setting of the attribute
//             [grpInspecte] - The template setting of the attribute
//             [cookie]      - The cookie IDing the result pane item
//             [pDataObj]    - The data object for the scope pane item
//
//  History:
//
//---------------------------------------------------------------------------
void CSnapin::AddResultItem(LPCTSTR szName,
                       PSCE_GROUP_MEMBERSHIP grpTemplate,
                       PSCE_GROUP_MEMBERSHIP grpInspect,
                       MMC_COOKIE cookie,
                       LPDATAOBJECT pDataObj)
{
   //
   // This area contains MAX_ITEM_ID_INDEX(3) linked result lines:
   //    Group Name
   //        Members:       Template    Last Inspected
   //        Membership:    Template    Last Inspected
   //comment out        Privileges:    Template    Last Inspected
   //
   if ( !grpInspect || !szName || !cookie ) 
   {
      ASSERT(FALSE);
      return;
   }

   //
   // pResults & hResultItems are needed to link the lines together
   //
   typedef CResult *PRESULT;
   PRESULT pResults[3];
   HRESULTITEM hResultItems[3];
   int status = 0;


   //
   // add one entry for the group name
   //
   if ( grpInspect->Status & SCE_GROUP_STATUS_NOT_ANALYZED ) 
      status = SCE_STATUS_NOT_CONFIGURED;
   else
      status = -1;
   
   pResults[0]= AddResultItem(szName,                  // The name of the attribute being added
                              (LONG_PTR)grpInspect,       // The last inspected setting of the attribute
                              (LONG_PTR)grpTemplate,      // The template setting of the attribute
                              ITEM_GROUP,              // The type of of the attribute's data
                              status,                  // The mismatch status of the attribute
                              cookie,                  // The cookie for the result item pane
                              FALSE,                   // True if the setting is set only if it differs from base (so copy the data)
                              NULL,                    // The units the attribute is set in
                              NULL,                    // An id to let us know where to save this attribute
                              (CEditTemplate *)szName, // The template to save this attribute in
                              pDataObj);               // The data object for the scope note who owns the result pane

   //
   // L"    -- Members"
   //
   status = grpInspect->Status;
   if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ||
        status & SCE_GROUP_STATUS_NC_MEMBERS ) 
   {
      status = SCE_STATUS_NOT_CONFIGURED;
   } 
   else if ( status & SCE_GROUP_STATUS_MEMBERS_MISMATCH ) 
   {
      status = SCE_STATUS_MISMATCH;
   } 
   else
      status = SCE_STATUS_GOOD;

   pResults[1] = AddResultItem(IDS_GRP_MEMBERS,
                               (LONG_PTR)grpInspect,
                               (LONG_PTR)grpTemplate,
                               ITEM_GROUP_MEMBERS,
                               status,
                               cookie,
                               false,
                               (PEDITTEMPLATE)szName,
                               pDataObj);

   //
   // L"    -- Membership"
   //
   status = grpInspect->Status;
   if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ||
        status & SCE_GROUP_STATUS_NC_MEMBEROF ) 
   {
      status = SCE_STATUS_NOT_CONFIGURED;
   } 
   else if ( status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH ) 
   {
      status = SCE_STATUS_MISMATCH;
   } 
   else
      status = SCE_STATUS_GOOD;

   pResults[2] = AddResultItem(IDS_GRP_MEMBEROF,
                               (LONG_PTR)grpInspect,
                               (LONG_PTR)grpTemplate,
                               ITEM_GROUP_MEMBEROF,
                               status,
                               cookie,
                               false,
                               (PEDITTEMPLATE)szName,
                               pDataObj);
   //
   // save the relative cookies
   //
   if ( pResults[0] )
      pResults[0]->SetRelativeCookies((MMC_COOKIE)pResults[1], (MMC_COOKIE)pResults[2]);

   if ( pResults[1] )
      pResults[1]->SetRelativeCookies((MMC_COOKIE)pResults[0], (MMC_COOKIE)pResults[2]);

   if ( pResults[2] )
      pResults[2]->SetRelativeCookies((MMC_COOKIE)pResults[0], (MMC_COOKIE)pResults[1]);

}

void CSnapin::DeleteList (BOOL bDeleteResultItem)
{
   POSITION pos = NULL;
   if (m_pSelectedFolder && m_resultItemHandle)
   {
      CResult *pResult = 0;

      do {
         if( m_pSelectedFolder->GetResultItem(
                     m_resultItemHandle,
                     pos,
                     &pResult) != ERROR_SUCCESS) 
         {
            break;
         }

         if ( pResult ) 
         {
            if ( bDeleteResultItem ) 
            {
               HRESULTITEM hItem = NULL;
               if( S_OK == m_pResult->FindItemByLParam((LPARAM)m_pResult, &hItem ))
               {
                  if(hItem)
                  {
                     m_pResult->DeleteItem(hItem, 0);
                  }
               }
            }
         } 
         else
            break;
      } while( pos );

      //
      // Release the hold on this object.
      //
      m_pSelectedFolder->ReleaseResultItemHandle( m_resultItemHandle );
      m_resultItemHandle = NULL;
      m_pSelectedFolder = NULL;
   }
}


//+--------------------------------------------------------------------------
//
//  Function:   OnUpdateView
//
//  Synopsis:   If the updated view is being shown by this CSnapin then
//              clear out the old view and redisplay it with the new info
//
//  Arguments:  [lpDataObject] - unused
//              [data] - the cookie for the folder being updated
//              [hint] - unused
//
//
//---------------------------------------------------------------------------
HRESULT
CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject,LPARAM data, LPARAM hint )
{
   if (lpDataObject == (LPDATAOBJECT)this) 
      return S_OK;

   CResult *pResult = (CResult *)data;
   HRESULTITEM hRItem = NULL;
   RESULTDATAITEM resultItem;
   HRESULT hr = m_pResult->FindItemByLParam( (LPARAM)pResult, &hRItem );
   POSITION pos = NULL;

   switch(hint)
   {
   case UAV_RESULTITEM_UPDATEALL:
       //
       // The caller is responsible for clearing the result items from this
       //  this will invalidate all references to the folder object.  Because of
       //  this we have to make sure the reference counter is updated correctly,
       //  so for every CSnapin object GetResultITemHandle is called so that we
       //  don't delete the list when it is still needed.
       //
       if(data != (LPARAM)m_pSelectedFolder && (CFolder*)data != NULL)
       {
           //Raid #258237, 4/12/2001
           CFolder* pCurFolder = (CFolder*)data;
           if( !pCurFolder->GetViewUpdate() )
                return S_OK;
           CFolder* pOldFolder = m_pSelectedFolder;
           pCurFolder->SetViewUpdate(FALSE);
           if( !pCurFolder->GetResultListCount() )
           {
               EnumerateResultPane(
                    (MMC_COOKIE)pCurFolder,
                    pCurFolder->GetScopeItem()->ID,
                    NULL
                    );
               m_pSelectedFolder = pOldFolder;
           }
       }
       if( m_pSelectedFolder->GetViewUpdate() )
           m_pSelectedFolder->SetViewUpdate(FALSE); 

       m_pResult->DeleteAllRsltItems();

       if( !m_pSelectedFolder->GetResultListCount() )
       {
           //
           // This should only be called by the first CSnapin who recieves this message.
           //
           EnumerateResultPane(
               (MMC_COOKIE)m_pSelectedFolder,
               m_pSelectedFolder->GetScopeItem()->ID,
               NULL
               );
         break;
       } 
       else 
       {
           m_pSelectedFolder->GetResultItemHandle(
                                &m_resultItemHandle);
      }
      break;

   case UAV_RESULTITEM_REDRAWALL:
      if( data != (LPARAM)m_pSelectedFolder )
      {
         return S_OK;
      }

      m_pResult->DeleteAllRsltItems();

        ZeroMemory(&resultItem,sizeof(resultItem));
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;

        pos = NULL;

        m_pResult->SetItemCount(
                        m_pSelectedFolder->GetResultListCount( ),
                        MMCLV_UPDATE_NOINVALIDATEALL);

        do {
            m_pSelectedFolder->GetResultItem(
                m_resultItemHandle,
                pos,
                (CResult **)&(resultItem.lParam));
            if(resultItem.lParam)
            {
                m_pResult->InsertItem( &resultItem );
            }
        } while(pos);

        m_pResult->Sort(0, 0, 0);
        break;

    case UAV_RESULTITEM_ADD:
        //
        // This adds a CResult item to the result pane, if and only if the item
        //  does not already exist withen the pane.
        //
        if(!m_pSelectedFolder ||
           !m_pSelectedFolder->GetResultItemPosition(
                m_resultItemHandle,
                pResult) ||
            hRItem ) 
        {
            return S_OK;
        }

       ZeroMemory(&resultItem,sizeof(resultItem));
       resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
       resultItem.str = MMC_CALLBACK;
       resultItem.nImage = -1; // equivalent to: MMC_CALLBACK;

       resultItem.lParam = (LPARAM)pResult;
       m_pResult->InsertItem( &resultItem );
       m_pResult->Sort(0, 0, 0);
        break;

    case UAV_RESULTITEM_REMOVE:
        //
        // This removes the HRESULTITEM associated with the CResult item passed in
        // through the data member.
        //
        if(hRItem)
            m_pResult->DeleteItem( hRItem, 0 );
        break;

    default:
        //
        // By default we just repaint the item.
        //
         m_pResult->UpdateItem( hRItem );
         break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\helpdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       helpdlg.h
//
//  Contents:   definition of CHelpDialog
//                              
//----------------------------------------------------------------------------

#if !defined(AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CHelpDialog : public CDialog
{
public:
    CHelpDialog(const DWORD* pHelpIDs, UINT nIDTemplate, CWnd* pParentWnd)
        : m_pHelpIDs(pHelpIDs), CDialog(nIDTemplate, pParentWnd)
    {
    }

protected:
    afx_msg BOOL    OnHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

private:
    const DWORD*    m_pHelpIDs;
};

#endif  // !defined(AFX_HELPDLG_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\helpdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       helpdlg.cpp
//
//  Contents:   implementation of CHelpDialog
//
//----------------------------------------------------------------------------

#include "StdAfx.h"

#include "HelpDlg.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
    //{{AFX_MSG_MAP(CHelpDialog)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog member functions

afx_msg
BOOL
CHelpDialog::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        if( pHelpInfo->iCtrlId != IDC_TITLE ) //Raid #499556, yanggao, 12/17/2001
        {
            if (!::WinHelp(
                (HWND)pHelpInfo->hItemHandle,
                GetSeceditHelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR)m_pHelpIDs))
            {
            ;
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\laudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       laudit.cpp
//
//  Contents:   implementation of CLocalPolAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "laudit.h"
#include "util.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit dialog


CLocalPolAudit::CLocalPolAudit()
: CConfigAudit(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolAudit)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a226HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit message handlers

BOOL CLocalPolAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      DWORD status = 0;

      UpdateData(TRUE);
      if (m_bConfigure) 
      {
         if (m_fSuccessful)
            dw |= AUDIT_SUCCESS;
         
         if (m_fFailed)
            dw |= AUDIT_FAILURE;

         m_pData->SetBase(dw);
         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (SCE_ERROR_VALUE != status) 
         {
            m_pData->SetStatus(status);
            m_pData->Update(m_pSnapin);
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\hidwnd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hidwnd.h
//
//  Contents:   definition of CHiddenWnd
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning(push,3)
#include <gpedit.h>
#pragma warning(pop)

class CSnapin;
class CFolder;
class CResult;
class CComponentDataImpl;


typedef struct {
   LPDATAOBJECT pDataObject;
   LPARAM       data;
   LPARAM       hint;
} UpdateViewData,*PUPDATEVIEWDATA;


/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd window

class CHiddenWnd : public CWnd
{
// Construction
public:
   CHiddenWnd();
   virtual ~CHiddenWnd();

// Attributes
public:

// Operations
public:

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CHiddenWnd)
   //}}AFX_VIRTUAL

// Implementation
public:
   HRESULT UpdateAllViews(LPDATAOBJECT pDO, LPARAM data, LPARAM hint);
   HRESULT UpdateItem(LPRESULTDATA pRD,HRESULTITEM hri);
   HRESULT RefreshPolicy();
   HRESULT ReloadLocation(CFolder *pFolder, CComponentDataImpl *pCDI);
   HRESULT LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg = TRUE);
   HRESULT SetProfileDescription(CString *strFile, CString *strDescription);
   void SetConsole(LPCONSOLE pConsole);
   void SetComponentDataImpl(CComponentDataImpl *pCDI) { m_pCDI = pCDI; };
   void SetGPTInformation(LPGPEINFORMATION GPTInfo);
   void CloseAnalysisPane();
   void SelectScopeItem(HSCOPEITEM ID);


   HRESULT
   UpdateAllViews(
      LPDATAOBJECT pDO,
      CSnapin *pSnapin,
      CFolder *pFolder,
      CResult *pResult,
      UINT uAction
      );

   //virtual ~CHiddenWnd();

   // Generated message map functions
protected:
   //{{AFX_MSG(CHiddenWnd)
      // NOTE - the ClassWizard will add and remove member functions here.
   //}}AFX_MSG
   afx_msg void OnUpdateAllViews( WPARAM, LPARAM);
   afx_msg void OnUpdateItem( WPARAM, LPARAM);
   afx_msg void OnRefreshPolicy( WPARAM, LPARAM);
   afx_msg void OnReloadLocation( WPARAM, LPARAM);
   afx_msg void OnLockAnalysisPane( WPARAM, LPARAM);
   afx_msg void OnCloseAnalysisPane( WPARAM, LPARAM);
   afx_msg void OnSelectScopeItem( WPARAM, LPARAM);

   DECLARE_MESSAGE_MAP()


private:
   LPCONSOLE m_pConsole;
   CComponentDataImpl *m_pCDI;
   LPGPEINFORMATION m_GPTInfo;

};

typedef CHiddenWnd *LPNOTIFY;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HIDWND_H__9C4F7D75_B77E_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\laudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       laudit.h
//
//  Contents:   definition of CLocalPolAudit
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "caudit.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolAudit dialog

class CLocalPolAudit : public CConfigAudit
{
// Construction
public:
   CLocalPolAudit();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolAudit)
	enum { IDD = IDD_LOCALPOL_AUDIT };
	//}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolAudit)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolAudit)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LAUDIT_H__2B949F0A_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\hlpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hlpids.h
//
//----------------------------------------------------------------------------
#define IDH_199_323	21168327	// Analyzing System Security: "g" (Static)
#define IDH_170_301	19726506	// Audit File Access : "" (Edit)
#define IDH_199_324	21233863	// Analyzing System Security: "g" (Static)
#define IDH_189_301	19726525	// System Log Retention Method: "Static" (Static)
#define IDH_229_301	19726565	// System Log Retention Method: "Static" (Static)
#define IDH_226_301	19726562	// Audit File Access : "" (Edit)
#define IDH_199_325	21299399	// Analyzing System Security: "g" (Static)
#define IDH_190_302	19792062	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_189_302	19792061	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_168_233	15270056	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
#define IDH_229_302	19792101	// System Log Retention Method: "Overwrite events by &days" (Button)
#define IDH_181_233	15270069	// Lockout Account: "Spin2" (msctls_updown32)
#define IDH_228_233	15270116	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
#define IDH_167_349	22872231	// Rename Administrator Account: "Analyzed Computer Setting" (Button)
#define IDH_199_326	21364935	// Analyzing System Security: "g" (Static)
#define IDH_190_303	19857598	// System Log Retention Method: "Retain log:" (Static)
#define IDH_189_303	19857597	// System Log Retention Method: "Retain log:" (Static)
#define IDH_195_303	19857603	// Logical Disk Manager: "Service startup mode:" (Static)
#define IDH_194_303	19857602	// Directory Replicator: "Service startup mode:" (Static)
#define IDH_173_257	16842925	// Untitled: "Apply" (Button)
#define IDH_168_234	15335592	// Edit Numeric Attribute: "" (Edit)
#define IDH_167_234	15335591	// Rename Administrator Account: "" (Edit)
#define IDH_229_303	19857637	// System Log Retention Method: "Retain log:" (Static)
#define IDH_230_234	15335654	// Rename Administrator Account: "" (Edit)
#define IDH_228_234	15335652	// Edit Numeric Attribute: "" (Edit)
#define IDH_170_350	22937770	// Audit File Access : "Change template setting in database to" (Button)
#define IDH_169_350	22937769	// Secure System Objects: "Change template setting in database to" (Button)
#define IDH_167_350	22937767	// Rename Administrator Account: "C&hange template setting in database to" (Button)
#define IDH_190_350	22937790	// System Log Retention Method: "Change computer template setting to" (Button)
#define IDH_189_350	22937789	// System Log Retention Method: "Change computer template setting to" (Button)
#define IDH_183_350	22937783	// Rename Administrator Account: "C&hange template setting to" (Button)
#define IDH_182_350	22937782	// Edit Enable/Disable Attribute: "Change template setting to" (Button)
#define IDH_181_350	22937781	// Lockout Account: "C&hange template setting to" (Button)
#define IDH_180_350	22937780	// Audit File Access: "Change template setting to" (Button)
#define IDH_198_350	22937798	// Analysis Areas: "Change template setting in database to" (Button)
#define IDH_197_350	22937797	// File and Registry Object Configuration: "Change Template setting to" (Button)
#define IDH_195_350	22937795	// Logical Disk Manager: "Change template setting to" (Button)
#define IDH_194_350	22937794	// Directory Replicator: "Change template setting in database to" (Button)
#define IDH_170_304	19923114	// Audit File Access : "E&xclude from future configurations and analyses" (Button)
#define IDH_169_304	19923113	// Secure System Objects: "E&xclude from future configurations and analyses" (Button)
#define IDH_168_304	19923112	// Edit Numeric Attribute: "E&xclude from future configurations and analyses" (Button)
#define IDH_167_304	19923111	// Rename Administrator Account: "E&xclude from future configurations and analyses" (Button)
#define IDH_199_327	21430471	// Analyzing System Security: "g" (Static)
#define IDH_190_304	19923134	// System Log Retention Method: "E&xclude this setting from configuration" (Button)
#define IDH_189_304	19923133	// System Log Retention Method: "E&xclude from future configurations and analyses" (Button)
#define IDH_183_304	19923127	// Rename Administrator Account: "E&xclude this setting from configuration" (Button)
#define IDH_182_304	19923126	// Edit Enable/Disable Attribute: "E&xclude this setting from configuration" (Button)
#define IDH_181_304	19923125	// Lockout Account: "E&xclude this setting from configuration" (Button)
#define IDH_180_304	19923124	// Audit File Access: "E&xclude this setting from configuration" (Button)
#define IDH_237_350	22937837	// Dialog: "C&hange template setting in database to" (Button)
#define IDH_236_350	22937836	// Dialog: "C&hange template setting to" (Button)
#define IDH_198_304	19923142	// Analysis Areas: "E&xclude from future configurations and analyses" (Button)
#define IDH_197_304	19923141	// File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
#define IDH_195_304	19923139	// Logical Disk Manager: "E&xclude this setting from configuration" (Button)
#define IDH_194_304	19923138	// Directory Replicator: "E&xclude from future configurations and analyses" (Button)
#define IDH_168_235	15401128	// Edit Numeric Attribute: "failed attempts" (Static)
#define IDH_237_304	19923181	// Dialog: "E&xclude from future configurations and analyses" (Button)
#define IDH_236_304	19923180	// Dialog: "E&xclude this setting from configuration" (Button)
#define IDH_235_304	19923179	// Dialog: "E&xclude from local policy" (Button)
#define IDH_230_304	19923174	// Rename Administrator Account: "E&xclude from local policy" (Button)
#define IDH_229_304	19923173	// System Log Retention Method: "E&xclude from local policy" (Button)
#define IDH_228_304	19923172	// Edit Numeric Attribute: "E&xclude from local policy" (Button)
#define IDH_227_304	19923171	// Secure System Objects: "E&xclude from local policy" (Button)
#define IDH_226_304	19923170	// Audit File Access : "E&xclude from local policy" (Button)
#define IDH_181_235	15401141	// Lockout Account: "failed attempts" (Static)
#define IDH_228_235	15401188	// Edit Numeric Attribute: "failed attempts" (Static)
#define IDH_170_351	23003306	// Audit File Access : "Analyzed Computer Setting" (Button)
#define IDH_169_351	23003305	// Secure System Objects: "Analyzed Computer Setting" (Button)
#define IDH_168_351	23003304	// Edit Numeric Attribute: "Analyzed Computer Setting" (Button)
#define IDH_198_351	23003334	// Analysis Areas: "Analyzed Computer Setting" (Button)
#define IDH_194_351	23003330	// Directory Replicator: "Analyzed Computer Setting" (Button)
#define IDH_199_328	21496007	// Analyzing System Security: "f" (Static)
#define IDH_191_305	19988671	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_237_351	23003373	// Dialog: "Analyzed Computer Setting" (Button)
#define IDH_231_305	19988711	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_195_236	15466691	// Logical Disk Manager: "&Manual" (Button)
#define IDH_194_236	15466690	// Directory Replicator: "&Manual" (Button)
#define IDH_177_352	23068849	// Select Registry Key: "&Registry:" (Static)
#define IDH_183_283	18546871	// Rename Administrator Account: "" (Edit)
#define IDH_173_260	17039533	// Untitled: "&View..." (Button)
#define IDH_212_306	20054228	// Configure System: "Error log file path" (Button)
#define IDH_169_237	15532201	// Secure System Objects: "&Enabled" (Button)
#define IDH_182_237	15532214	// Edit Enable/Disable Attribute: "&Enabled" (Button)
#define IDH_195_237	15532227	// Logical Disk Manager: "&Automatic" (Button)
#define IDH_194_237	15532226	// Directory Replicator: "&Automatic" (Button)
#define IDH_227_237	15532259	// Secure System Objects: "&Enabled" (Button)
#define IDH_186_353	23134394	// Save Computer Templates: "&Select to save:" (Static)
#define IDH_199_330	21627079	// Analyzing System Security: "Account policies" (Static)
#define IDH_198_307	20119750	// Analysis Areas: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
#define IDH_197_307	20119749	// File and Registry Object Configuration: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
#define IDH_195_307	20119747	// Logical Disk Manager: "&Edit Security..." (Button)
#define IDH_194_307	20119746	// Directory Replicator: "&Edit Security..." (Button)
#define IDH_173_261	17105069	// Untitled: "View/&Edit..." (Button)
#define IDH_169_238	15597737	// Secure System Objects: "&Disabled" (Button)
#define IDH_182_238	15597750	// Edit Enable/Disable Attribute: "&Disabled" (Button)
#define IDH_195_238	15597763	// Logical Disk Manager: "&Disabled" (Button)
#define IDH_194_238	15597762	// Directory Replicator: "&Disabled" (Button)
#define IDH_227_238	15597795	// Secure System Objects: "&Disabled" (Button)
#define IDH_218_215	14090458	// Template Description: "" (Edit)
#define IDH_225_215	14090465	// New Template: "" (Edit)
#define IDH_189_354	23199933	// System Log Retention Method: "Last inspected setting" (Button)
#define IDH_168_331	21692584	// Edit Numeric Attribute: "Lockout account after:" (Static)
#define IDH_199_331	21692615	// Analyzing System Security: "Local policies" (Static)
#define IDH_190_308	20185278	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_189_308	20185277	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_194_308	20185282	// Directory Replicator: "&Service Security" (Button)
#define IDH_228_331	21692644	// Edit Numeric Attribute: "Lockout account after:" (Static)
#define IDH_229_308	20185317	// System Log Retention Method: "Overwrite events as &needed" (Button)
#define IDH_191_355	23265471	// Untitled: "Assigned to" (Static)
#define IDH_168_332	21758120	// Edit Numeric Attribute: "&Lockout account after:" (Static)
#define IDH_199_332	21758151	// Analyzing System Security: "Restricted groups" (Static)
#define IDH_190_309	20250814	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
#define IDH_189_309	20250813	// System Log Retention Method: "Do not overwrite events(clean log &manually)" (Button)
#define IDH_231_355	23265511	// Untitled: "Assigned to" (Static)
#define IDH_197_309	20250821	// File and Registry Object Configuration: "Igno&reDo not include this object and its child objects in any future configurations or analyses." (Button)
#define IDH_228_332	21758180	// Edit Numeric Attribute: "&Lockout account after:" (Static)
#define IDH_229_309	20250853	// System Log Retention Method: "Do not overwrite events(clean log &manually)" (Button)
#define IDH_106_287	18808938	// Configure Privilege Grant List: "" (ListBox)
#define IDH_191_356	23331007	// Untitled: "Configuration Setting" (Static)
#define IDH_199_333	21823687	// Analyzing System Security: "Registry" (Static)
#define IDH_173_241	15794349	// Untitled: "Change to recommended settings" (Button)
#define IDH_107_288	18874475	// Configure Membership for <group>: "" (ListBox)
#define IDH_191_357	23396543	// Untitled: "Analyzed Setting" (Static)
#define IDH_214_357	23396566	// Untitled: "Analyzed Setting" (Static)
#define IDH_199_334	21889223	// Analyzing System Security: "File systems" (Static)
#define IDH_217_334	21889241	// Untitled: "Overwrite existing template in database" (Button)
#define IDH_216_334	21889240	// Import Template: "&Overwrite existing template in database" (Button)
#define IDH_197_311	20381893	// File and Registry Object Configuration: "&Edit Security..." (Button)
#define IDH_173_242	15859885	// Untitled: "Accept current security settings" (Button)
#define IDH_194_358	23462082	// Directory Replicator: "Service startup mode:" (Static)
#define IDH_199_335	21954759	// Analyzing System Security: "System services" (Static)
#define IDH_216_335	21954776	// Import Template: "" (Edit)
#define IDH_215_335	21954775	// Perform Analysis: "" (Edit)
#define IDH_212_335	21954772	// Configure System: "" (Edit)
#define IDH_170_243	15925418	// Audit File Access : "Audit &successful attempts" (Button)
#define IDH_226_243	15925474	// Audit File Access : "Audit &successful attempts" (Button)
#define IDH_107_290	19005547	// Configure Membership for <group>: "" (ListBox)
#define IDH_214_359	23527638	// Untitled: "Template Setting" (Static)
#define IDH_199_336	22020295	// Analyzing System Security: "Directory service objects" (Static)
#define IDH_216_336	22020312	// Import Template: "&Browse ..." (Button)
#define IDH_215_336	22020311	// Perform Analysis: "&Browse ..." (Button)
#define IDH_212_336	22020308	// Configure System: "&Browse ..." (Button)
#define IDH_198_313	20512966	// Analysis Areas: "&Edit Security..." (Button)
#define IDH_170_244	15990954	// Audit File Access : "Audit &failed attempts" (Button)
#define IDH_214_290	19005654	// Untitled: "CheckList" (CHECKLIST_SCE)
#define IDH_226_244	15991010	// Audit File Access : "Audit &failed attempts" (Button)
#define IDH_106_337	22085738	// Configure Privilege Grant List: "E&xclude from future configurations and analyses" (Button)
#define IDH_107_291	19071083	// Configure Membership for <group>: "Members of this group" (Button)
#define IDH_191_337	22085823	// Untitled: "E&xclude from future configurations and analyses" (Button)
#define IDH_216_360	23593176	// Import Template: "Error log file path" (Button)
#define IDH_198_314	20578502	// Analysis Areas: "&View Security..." (Button)
#define IDH_231_337	22085863	// Untitled: "E&xclude from local policy" (Button)
#define IDH_107_292	19136619	// Configure Membership for <group>: "&Add" (Button)
#define IDH_106_246	16121962	// Configure Privilege Grant List: "A&dd" (Button)
#define IDH_218_361	23658714	// Template Description: "&Description:" (Static)
#define IDH_225_361	23658721	// New Template: "&Description" (Button)
#define IDH_215_338	22151383	// Perform Analysis: "" (Static)
#define IDH_212_338	22151380	// Configure System: "" (Static)
#define IDH_198_315	20644038	// Analysis Areas: "Static" (Static)
#define IDH_191_246	16122047	// Untitled: "&Add..." (Button)
#define IDH_214_246	16122070	// Untitled: "A&dd..." (Button)
#define IDH_231_246	16122087	// Untitled: "&Add..." (Button)
#define IDH_107_293	19202155	// Configure Membership for <group>: "&Remove" (Button)
#define IDH_106_247	16187498	// Configure Privilege Grant List: "&Remove" (Button)
#define IDH_177_339	22216881	// Select Registry Key: "" (Edit)
#define IDH_181_316	20709557	// Lockout Account: "&Lockout account after:" (Static)
#define IDH_225_362	23724257	// New Template: "&Template Name:" (Button)
#define IDH_214_316	20709590	// Untitled: "Members" (Static)
#define IDH_107_248	16253035	// Configure Membership for <group>: "A&dd" (Button)
#define IDH_199_340	22282439	// Analyzing System Security: "Analyzing:" (Static)
#define IDH_235_363	23789803	// Dialog: "Effective Policy Setting" (Button)
#define IDH_230_363	23789798	// Rename Administrator Account: "Effective Policy Setting" (Button)
#define IDH_229_363	23789797	// System Log Retention Method: "Effective Policy Setting" (Button)
#define IDH_228_363	23789796	// Edit Numeric Attribute: "Effective Policy Setting" (Button)
#define IDH_227_363	23789795	// Secure System Objects: "Effective Policy Setting" (Button)
#define IDH_226_363	23789794	// Audit File Access : "Effective Policy Setting" (Button)
#define IDH_177_294	19267761	// Select Registry Key: "Tree1" (SysTreeView32)
#define IDH_180_271	17760436	// Audit File Access: "Audit &successful attempts" (Button)
#define IDH_209_202	13238481	// Untitled: "Security Configuration & Analysis is an administrative tool to secure a computer and analyze security aspects. You can create or edit a security template, apply the security template, perform analysis based on a template, and display analysis results." (Static)
#define IDH_107_249	16318571	// Configure Membership for <group>: "Re&move" (Button)
#define IDH_235_364	23855339	// Dialog: "C&hange Local Policy to" (Button)
#define IDH_230_364	23855334	// Rename Administrator Account: "C&hange Local Policy to" (Button)
#define IDH_229_364	23855333	// System Log Retention Method: "Change Local Policy to" (Button)
#define IDH_228_364	23855332	// Edit Numeric Attribute: "C&hange Local Policy to" (Button)
#define IDH_227_364	23855331	// Secure System Objects: "Change Local Policy to" (Button)
#define IDH_226_364	23855330	// Audit File Access : "Change Local Policy to" (Button)
#define IDH_198_318	20840646	// Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
#define IDH_186_295	19333306	// Save Computer Templates: "" (ListBox)
#define IDH_225_341	22348001	// New Template: "" (Edit)
#define IDH_180_272	17825972	// Audit File Access: "Audit &failed attempts" (Button)
#define IDH_209_203	13304017	// Untitled: "Security Configuration & Analysis v1.0" (Static)
#define IDH_231_365	23920871	// Untitled: "Local Policy" (Static)
#define IDH_198_319	20906182	// Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
#define IDH_106_228	14942314	// Configure Privilege Grant List: "User rights" (Button)
#define IDH_231_366	23986407	// Untitled: "Effective Policy" (Static)
#define IDH_197_320	20971717	// File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
#define IDH_237_343	22479085	// Dialog: "" (ComboBox)
#define IDH_236_343	22479084	// Dialog: "" (ComboBox)
#define IDH_235_343	22479083	// Dialog: "" (ComboBox)
#define IDH_215_228	14942423	// Perform Analysis: "Error log file path" (Button)
#define IDH_107_229	15007851	// Configure Membership for <group>: "Group is a member of" (Button)
#define IDH_199_321	21037255	// Analyzing System Security: "Progress1" (msctls_progress32)
#define IDH_238_344	22544622	// Dependency failed on %s: "List1" (SysListView32)
#define IDH_181_275	18022581	// Lockout Account: "" (Edit)
#define IDH_169_229	15007913	// Secure System Objects: "" (Edit)
#define IDH_168_229	15007912	// Edit Numeric Attribute: "" (Edit)
#define IDH_167_229	15007911	// Rename Administrator Account: "" (Edit)
#define IDH_194_229	15007938	// Directory Replicator: "Static" (Static)
#define IDH_237_229	15007981	// Dialog: "" (Edit)
#define IDH_235_229	15007979	// Dialog: "" (Edit)
#define IDH_230_229	15007974	// Rename Administrator Account: "" (Edit)
#define IDH_228_229	15007972	// Edit Numeric Attribute: "" (Edit)
#define IDH_227_229	15007971	// Secure System Objects: "" (Edit)
#define IDH_199_322	21102791	// Analyzing System Security: "g" (Static)
#define IDH_238_345	22610158	// Dependency failed on %s: "Warning: By changing '%s' to '%s' you must configure the following items to at least the suggested values." (Static)
#define IDH_239_391	22610100	// Precedency list for RSop result.(SysListView32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\hidwnd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hidwnd.cpp
//
//  Contents:   implementation of CHiddenWnd
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <mmc.h>
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "HidWnd.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SCEM_UPDATE_ALL_VIEWS         (WM_APP+101)
#define SCEM_UPDATE_ITEM              (WM_APP+102)
#define SCEM_REFRESH_POLICY           (WM_APP+103)
#define SCEM_RELOAD_LOCATION          (WM_APP+104)
#define SCEM_SET_PROFILE_DESC         (WM_APP+105)
#define SCEM_LOCK_ANAL_PANE           (WM_APP+106)
#define SCEM_CLOSE_ANAL_PANE          (WM_APP+107)
#define SCEM_SELECT_SCOPE_ITEM        (WM_APP+108)

/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd

CHiddenWnd::CHiddenWnd()
{
   m_GPTInfo = NULL;

   m_pConsole = NULL;
}


CHiddenWnd::~CHiddenWnd()
{
   DestroyWindow(); //Memory leak, 4/27/2001
   if (m_pConsole) {
      m_pConsole->Release();
   }
   if (m_GPTInfo) {
      m_GPTInfo->Release();
   }
}

BEGIN_MESSAGE_MAP(CHiddenWnd, CWnd)
   //{{AFX_MSG_MAP(CHiddenWnd)
      // NOTE - the ClassWizard will add and remove mapping macros here.
   //}}AFX_MSG_MAP
   ON_MESSAGE(SCEM_UPDATE_ALL_VIEWS,OnUpdateAllViews)
   ON_MESSAGE(SCEM_UPDATE_ITEM,OnUpdateItem)
   ON_MESSAGE(SCEM_REFRESH_POLICY,OnRefreshPolicy)
   ON_MESSAGE(SCEM_RELOAD_LOCATION,OnReloadLocation)
   ON_MESSAGE(SCEM_LOCK_ANAL_PANE,OnLockAnalysisPane)
   ON_MESSAGE(SCEM_CLOSE_ANAL_PANE,OnCloseAnalysisPane)
   ON_MESSAGE(SCEM_SELECT_SCOPE_ITEM,OnSelectScopeItem)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd message handlers

#define VOID_RET
void
CHiddenWnd::OnUpdateAllViews(WPARAM uParam, LPARAM lParam)
{


   PUPDATEVIEWDATA puvd;

   puvd = (PUPDATEVIEWDATA)uParam;


   if (!puvd) {
      return VOID_RET;
   }

   if (m_pConsole) {
      m_pConsole->UpdateAllViews(puvd->pDataObject,puvd->data,puvd->hint);
   }

   if( puvd->pDataObject && 1 == (int)lParam ) //Raid #357968, #354861, 4/25/2001
   {
       puvd->pDataObject->Release(); 
   }
   LocalFree(puvd);

   return VOID_RET;
}

void
CHiddenWnd::OnUpdateItem(WPARAM uParam, LPARAM lParam)
{

   LPRESULTDATA pResultPane;
   HRESULTITEM hResultItem;


   pResultPane = (LPRESULTDATA)uParam;
   hResultItem = (HRESULTITEM)lParam;

   if (!pResultPane) {
      return VOID_RET;
   }

   try {
      pResultPane->UpdateItem(hResultItem);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}

void
CHiddenWnd::OnRefreshPolicy(WPARAM uParam, LPARAM lParam)
{
   GUID guidExtension = { 0x827d319e, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a }};
   GUID guidSnapin = CLSID_Snapin;

   if (!m_GPTInfo) {
      return VOID_RET;
   }

   try {
      if (!SUCCEEDED(m_GPTInfo->PolicyChanged(TRUE, TRUE, &guidExtension, &guidSnapin))) {
         AfxMessageBox(IDS_ERROR_REFRESH_POLICY_FAILED);
      }
   } catch (...) {
      AfxMessageBox(IDS_ERROR_REFRESH_POLICY_FAILED);
      ASSERT(FALSE);
   }

   return VOID_RET;
}

void
CHiddenWnd::OnReloadLocation(WPARAM uParam, LPARAM lParam)
{
   CFolder *pFolder;
   CComponentDataImpl *pCDI;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   if (lParam) {
      pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   } else {
      pCDI = m_pCDI;
   }


   try {
      pCDI->ReloadLocation(pFolder);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}

HRESULT
CHiddenWnd::UpdateAllViews(
   LPDATAOBJECT pDO,
   CSnapin *pSnapin,
   CFolder *pFolder,
   CResult *pResult,
   UINT uAction
   )
{
   PUPDATEVIEWDATA puvd;
   if(!m_hWnd){
      return S_OK;
   }

   //
   // Notify item.
   //
   puvd = (UpdateViewData *)LocalAlloc(0, sizeof( UpdateViewData ));

   if (!puvd) {
      return E_FAIL;
   }

   puvd->pDataObject = (LPDATAOBJECT)pSnapin;
   puvd->data        = (LPARAM)pResult;
   puvd->hint        = uAction;

   if (!::PostMessage(m_hWnd, SCEM_UPDATE_ALL_VIEWS, (WPARAM)puvd, 0))
   {
      //
      // puvd will be freed by the SCEM_UPDATE_ALL_VIEWS handler,
      // but if somehow the PostMessage fails we need to free it ourselves.
      //
      LocalFree(puvd);
   }

   return S_OK;
}

HRESULT
CHiddenWnd::UpdateAllViews(LPDATAOBJECT pDO, LPARAM data, LPARAM hint)
{
   PUPDATEVIEWDATA puvd;


   puvd = (UpdateViewData *)LocalAlloc(0, sizeof(UpdateViewData));
   if (!puvd) {
      return E_FAIL;
   }

   puvd->pDataObject = pDO;
   puvd->data = data;
   puvd->hint = hint;

   if (!m_hWnd || !::PostMessage(m_hWnd,SCEM_UPDATE_ALL_VIEWS,(WPARAM)puvd,(LPARAM)1))
   {
      //
      // puvd will be freed by the SCEM_UPDATE_ALL_VIEWS handler,
      // but if somehow the PostMessage fails we need to free it ourselves.
      //
        if( puvd->pDataObject ) //Raid #357968, #354861, 4/25/2001
        {
            puvd->pDataObject->Release();   
        }
        LocalFree( puvd );
   }
   return S_OK;
}


HRESULT
CHiddenWnd::UpdateItem(LPRESULTDATA pResultPane,HRESULTITEM hResultItem)
{
   if (!pResultPane) {
      return E_INVALIDARG;
   }

   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_UPDATE_ITEM,(WPARAM)pResultPane,(LPARAM)hResultItem);
   }
   return S_OK;
}

HRESULT
CHiddenWnd::RefreshPolicy()
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_REFRESH_POLICY,0,0);
   }
   return S_OK;
}

void
CHiddenWnd::SetGPTInformation(LPGPEINFORMATION GPTInfo)
{
   if (m_GPTInfo) {
      m_GPTInfo->Release();
   }
   m_GPTInfo = GPTInfo;
   if (m_GPTInfo) {
      m_GPTInfo->AddRef();
   }
}

void
CHiddenWnd::SetConsole(LPCONSOLE pConsole)
{
   if (m_pConsole) {
      m_pConsole->Release();
   }
   m_pConsole = pConsole;
   if (m_pConsole) {
      m_pConsole->AddRef();
   }
}


HRESULT
CHiddenWnd::ReloadLocation(CFolder * pFolder,CComponentDataImpl * pCDI)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_RELOAD_LOCATION, (WPARAM)pFolder, (LPARAM)pCDI);
   }
   return S_OK;
}

HRESULT
CHiddenWnd::SetProfileDescription(CString *strFile, CString *strDescription)
{
   LPTSTR szFile = NULL;
   LPTSTR szDes = NULL; //Raid #prefast

   if (!strFile->IsEmpty()) {
      szFile = (LPTSTR)LocalAlloc(LPTR,(strFile->GetLength()+1)*sizeof(TCHAR));
      if (!szFile) {
         return E_OUTOFMEMORY;
      }
   }
   if (!strDescription->IsEmpty()) {
      szDes = (LPTSTR)LocalAlloc(LPTR,(strDescription->GetLength()+1)*sizeof(TCHAR));
      if (!szDes) {
         LocalFree(szFile);
         return E_OUTOFMEMORY;
      }
   }
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_RELOAD_LOCATION, (WPARAM)szFile, (LPARAM)szDes);
   }
   return S_OK;
}


void
CHiddenWnd::OnLockAnalysisPane(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->LockAnalysisPane((BOOL)uParam,(BOOL)lParam);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


HRESULT
CHiddenWnd::LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_LOCK_ANAL_PANE, (WPARAM)bLock, (LPARAM)fRemoveAnalDlg);
   }
   return S_OK;
}

void
CHiddenWnd::OnCloseAnalysisPane(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->CloseAnalysisPane();
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


void
CHiddenWnd::CloseAnalysisPane()
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_CLOSE_ANAL_PANE, NULL, NULL);
   }
}


void
CHiddenWnd::OnSelectScopeItem(WPARAM uParam, LPARAM lParam)
{
   try {
      m_pCDI->GetConsole()->SelectScopeItem(uParam);
   } catch (...) {
      ASSERT(FALSE);
   }

   return VOID_RET;
}


void
CHiddenWnd::SelectScopeItem(HSCOPEITEM ID)
{
   if (m_hWnd) {
      ::PostMessage(m_hWnd,SCEM_SELECT_SCOPE_ITEM, (WPARAM) ID, NULL);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\hlparray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       hlparray.h
//
//----------------------------------------------------------------------------

const DWORD a106HelpIDs[]=
{
	IDC_GRANTLIST,	IDH_106_287,	// Configure Privilege Grant List: "" (ListBox)
	IDC_CONFIGURE,	IDH_106_337,	// Configure Privilege Grant List: "E&xclude from future configurations and analyses" (Button)
	IDC_ADD,	IDH_106_246,	// Configure Privilege Grant List: "A&dd" (Button)
	IDC_REMOVE,	IDH_106_247,	// Configure Privilege Grant List: "&Remove" (Button)
	IDC_NC_GROUPS,	IDH_106_228,	// Configure Privilege Grant List: "User rights" (Button)
	0, 0
};




const DWORD a107HelpIDs[]=
{
	IDC_MEMBEROF,	IDH_107_288,	// Configure Membership for <group>: "" (ListBox)
	IDC_MEMBERS,	IDH_107_290,	// Configure Membership for <group>: "" (ListBox)
	IDC_TITLE_MEMBERS,	IDH_107_291,	// Configure Membership for <group>: "Members of this group" (Button)
	IDC_ADD_MEMBER,	IDH_107_292,	// Configure Membership for <group>: "&Add" (Button)
	IDC_REMOVE_MEMBER,	IDH_107_293,	// Configure Membership for <group>: "&Remove" (Button)
	IDC_ADD_MEMBEROF,	IDH_107_248,	// Configure Membership for <group>: "A&dd" (Button)
	IDC_REMOVE_MEMBEROF,	IDH_107_249,	// Configure Membership for <group>: "Re&move" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_107_229,	// Configure Membership for <group>: "Group is a member of" (Button)
	0, 0
};




const DWORD a167HelpIDs[]=
{
	IDC_ANALYZED_COMPUTER_STRING_STATIC,	IDH_167_349,	// Rename Administrator Account: "Analyzed Computer Setting" (Button)
	IDC_NEW,	IDH_167_234,	// Rename Administrator Account: "" (Edit)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_167_350,	// Rename Administrator Account: "C&hange template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_167_304,	// Rename Administrator Account: "E&xclude from future configurations and analyses" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_167_229,	// Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a168HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_168_233,	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
	IDC_NEW,	IDH_168_234,	// Edit Numeric Attribute: "" (Edit)
	IDC_CONFIGURE,	IDH_168_304,	// Edit Numeric Attribute: "E&xclude from future configurations and analyses" (Button)
	IDC_UNITS,	IDH_168_235,	// Edit Numeric Attribute: "failed attempts" (Static)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_168_351,	// Edit Numeric Attribute: "Analyzed Computer Setting" (Button)
	IDC_LI_TITLE,	IDH_168_331,	// Edit Numeric Attribute: "Lockout account after:" (Static)
	IDC_TEMPLATE_TITLE,	IDH_168_332,	// Edit Numeric Attribute: "&Lockout account after:" (Static)
	IDC_TITLE_MEMBER_OF,	IDH_168_229,	// Edit Numeric Attribute: "" (Edit)
	0, 0
};




const DWORD a169HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_169_350,	// Secure System Objects: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_169_304,	// Secure System Objects: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_169_351,	// Secure System Objects: "Analyzed Computer Setting" (Button)
	IDC_ENABLED,	IDH_169_237,	// Secure System Objects: "&Enabled" (Button)
	IDC_DISABLED,	IDH_169_238,	// Secure System Objects: "&Disabled" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_169_229,	// Secure System Objects: "" (Edit)
	IDC_SETTING,   IDH_169_351, //Computer Setting
	0, 0
};




const DWORD a170HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_170_301,	// Audit File Access : "" (Edit)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_170_350,	// Audit File Access : "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_170_304,	// Audit File Access : "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_170_351,	// Audit File Access : "Analyzed Computer Setting" (Button)
	IDC_CHANGE_SUCCESS,	IDH_170_243,	// Audit File Access : "Audit &successful attempts" (Button)
	IDC_CURRENT_MEMBER_OF,	IDH_170_244,	// Audit File Access : "Audit &failed attempts" (Button)
	0, 0
};




const DWORD a173HelpIDs[]=
{
	IDC_APPLY,	IDH_173_257,	// Untitled: "Apply" (Button)
	IDC_VIEW,	IDH_173_260,	// Untitled: "&View..." (Button)
	IDC_VIEW_EDIT,	IDH_173_261,	// Untitled: "View/&Edit..." (Button)
	IDC_CHANGE,	IDH_173_241,	// Untitled: "Change to recommended settings" (Button)
	IDC_ACCEPT,	IDH_173_242,	// Untitled: "Accept current security settings" (Button)
	0, 0
};




const DWORD a177HelpIDs[]=
{
	IDC_REGISTRY_STATIC,	IDH_177_352,	// Select Registry Key: "&Registry:" (Static)
	IDC_REGKEY,	IDH_177_339,	// Select Registry Key: "" (Edit)
	IDC_REGTREE,	IDH_177_294,	// Select Registry Key: "Tree1" (SysTreeView32)
	0, 0
};




const DWORD a180HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_180_350,	// Audit File Access: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_180_304,	// Audit File Access: "E&xclude this setting from configuration" (Button)
	IDC_SUCCESSFUL,	IDH_180_271,	// Audit File Access: "Audit &successful attempts" (Button)
	IDC_FAILED,	IDH_180_272,	// Audit File Access: "Audit &failed attempts" (Button)
	IDC_STATIC_DESCRIPTION2, IDH_180_350, //Audit 
	0, 0
};




const DWORD a181HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_181_233,	// Lockout Account: "Spin2" (msctls_updown32)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_181_350,	// Lockout Account: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_181_304,	// Lockout Account: "E&xclude this setting from configuration" (Button)
	IDC_UNITS,	IDH_181_235,	// Lockout Account: "failed attempts" (Static)
	IDC_HEADER,	IDH_181_316,	// Lockout Account: "&Lockout account after:" (Static)
	IDC_VALUE,	IDH_181_275,	// Lockout Account: "" (Edit)
	0, 0
};




const DWORD a182HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_182_350,	// Edit Enable/Disable Attribute: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_182_304,	// Edit Enable/Disable Attribute: "E&xclude this setting from configuration" (Button)
	IDC_ENABLED,	IDH_182_237,	// Edit Enable/Disable Attribute: "&Enabled" (Button)
	IDC_DISABLED,	IDH_182_238,	// Edit Enable/Disable Attribute: "&Disabled" (Button)
	0, 0
};




const DWORD a183HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_183_350,	// Rename Administrator Account: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_183_304,	// Rename Administrator Account: "E&xclude this setting from configuration" (Button)
	IDC_NAME,	IDH_183_283,	// Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a186HelpIDs[]=
{
	IDC_SELECT_TO_SAVE_STATIC,	IDH_186_353,	// Save Computer Templates: "&Select to save:" (Static)
	IDC_TEMPLATE_LIST,	IDH_186_295,	// Save Computer Templates: "" (ListBox)
	0, 0
};




const DWORD a189HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_189_301,	// System Log Retention Method: "Static" (Static)
	IDC_RETENTION,	IDH_189_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_189_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_189_350,	// System Log Retention Method: "Change computer template setting to" (Button)
	IDC_CONFIGURE,	IDH_189_304,	// System Log Retention Method: "E&xclude from future configurations and analyses" (Button)
	IDC_LAST_INSPECTED_STATICSTATIC,	IDH_189_354,	// System Log Retention Method: "Last inspected setting" (Button)
	IDC_RADIO2,	IDH_189_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_189_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	0, 0
};




const DWORD a190HelpIDs[]=
{
	IDC_RETENTION,	IDH_190_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_190_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_190_350,	// System Log Retention Method: "Change computer template setting to" (Button)
	IDC_CONFIGURE,	IDH_190_304,	// System Log Retention Method: "E&xclude this setting from configuration" (Button)
	IDC_RADIO2,	IDH_190_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_190_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	0, 0
};




const DWORD a191HelpIDs[]=
{
	IDC_RIGHTS,	IDH_191_305,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ASSIGNED_TO_STATIC,	IDH_191_355,	// Untitled: "Assigned to" (Static)
	IDC_CONFIGURATION_SETTING_STATIC,	IDH_191_356,	// Untitled: "Configuration Setting" (Static)
	IDC_ANALYZED_SETTING_STATIC,	IDH_191_357,	// Untitled: "Analyzed Setting" (Static)
	IDC_CONFIGURE,	IDH_191_337,	// Untitled: "E&xclude from future configurations and analyses" (Button)
	IDC_ADD,	IDH_191_246,	// Untitled: "&Add..." (Button)
	0, 0
};




const DWORD a194HelpIDs[]=
{
	IDC_ATTRIBUTE_NAME,	IDH_194_303,	// Directory Replicator: "Service startup mode:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_194_350,	// Directory Replicator: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_194_304,	// Directory Replicator: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_194_351,	// Directory Replicator: "Analyzed Computer Setting" (Button)
	IDC_IGNORE,	IDH_194_236,	// Directory Replicator: "&Manual" (Button)
	IDC_ENABLED,	IDH_194_237,	// Directory Replicator: "&Automatic" (Button)
	IDC_OVERWRITE,	IDH_194_307,	// Directory Replicator: "&Edit Security..." (Button)
	IDC_DISABLED,	IDH_194_238,	// Directory Replicator: "&Disabled" (Button)
	IDC_RADIO2,	IDH_194_308,	// Directory Replicator: "&Service Security" (Button)
	IDC_SERVICE_STARTUP_MODE_STATIC,	IDH_194_358,	// Directory Replicator: "Service startup mode:" (Static)
	IDC_TITLE_MEMBER_OF,	IDH_194_229,	// Directory Replicator: "Static" (Static)
	0, 0
};




const DWORD a195HelpIDs[]=
{
	IDC_ATTRIBUTE_NAME,	IDH_195_303,	// Logical Disk Manager: "Service startup mode:" (Static)
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_195_350,	// Logical Disk Manager: "Change template setting to" (Button)
	IDC_CONFIGURE,	IDH_195_304,	// Logical Disk Manager: "E&xclude this setting from configuration" (Button)
	IDC_IGNORE,	IDH_195_236,	// Logical Disk Manager: "&Manual" (Button)
	IDC_ENABLED,	IDH_195_237,	// Logical Disk Manager: "&Automatic" (Button)
	IDC_OVERWRITE,	IDH_195_307,	// Logical Disk Manager: "&Edit Security..." (Button)
	IDC_DISABLED,	IDH_195_238,	// Logical Disk Manager: "&Disabled" (Button)
	0, 0
};




const DWORD a197HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_197_350,	// File and Registry Object Configuration: "Change Template setting to" (Button)
	IDC_CONFIGURE,	IDH_197_304,	// File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
	IDC_OVERWRITE,	IDH_197_307,	// File and Registry Object Configuration: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
	IDC_RADIO3,	IDH_197_309,	// File and Registry Object Configuration: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	IDC_SECURITY,	IDH_197_311,	// File and Registry Object Configuration: "&Edit Security..." (Button)
	IDC_CHECK,	IDH_197_320,	// File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_CONFIG, IDH_197_304, // File and Registry Object Configuration: "E&xclude this setting from configuration" (Button)
	IDC_INHERIT, IDH_197_320, // File and Registry Object Configuration: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_PREVENT, IDH_197_309, // File and Registry Object Configuration: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	0, 0
};




const DWORD a198HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_198_350,	// Analysis Areas: "Change template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_198_304,	// Analysis Areas: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_198_351,	// Analysis Areas: "Analyzed Computer Setting" (Button)
	IDC_OVERWRITE,	IDH_198_307,	// Analysis Areas: "&Overwrite Security is applied to this object and inherited by child objects, overwriting any existing security." (Button)
	IDC_TEMPLATE_SECURITY,	IDH_198_313,	// Analysis Areas: "&Edit Security..." (Button)
	IDC_INSPECTED_SECURITY,	IDH_198_314,	// Analysis Areas: "&View Security..." (Button)
	IDC_INSPECTED,	IDH_198_315,	// Analysis Areas: "Static" (Static)
	IDC_AUTOINHERIT,	IDH_198_318,	// Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_NOAUTOINHERIT,	IDH_198_319,	// Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	IDC_CONFIG, IDH_198_304, // Analysis Areas: "E&xclude from future configurations and analyses" (Button)
	IDC_INHERIT, IDH_198_318, // Analysis Areas: "&Inherit Security is applied to this object and inherited by child objects as appropriate." (Button)
	IDC_PREVENT, IDH_198_319, // Analysis Areas: "Igno&re Do not include this object and its child objects in any future configurations or analyses." (Button)
	0, 0
};




const DWORD a199HelpIDs[]=
{
	IDC_ICON2,	IDH_199_323,	// Analyzing System Security: "g" (Static)
	IDC_ICON3,	IDH_199_324,	// Analyzing System Security: "g" (Static)
	IDC_ICON4,	IDH_199_325,	// Analyzing System Security: "g" (Static)
	IDC_ICON5,	IDH_199_326,	// Analyzing System Security: "g" (Static)
	IDC_ICON6,	IDH_199_327,	// Analyzing System Security: "g" (Static)
	IDC_ICON7,	IDH_199_328,	// Analyzing System Security: "f" (Static)
	IDC_AREA1,	IDH_199_330,	// Analyzing System Security: "Account policies" (Static)
	IDC_LI_TITLE,	IDH_199_331,	// Analyzing System Security: "Local policies" (Static)
	IDC_TEMPLATE_TITLE,	IDH_199_332,	// Analyzing System Security: "Restricted groups" (Static)
	IDC_CHECK1,	IDH_199_333,	// Analyzing System Security: "Registry" (Static)
	IDC_INCREMENTAL,	IDH_199_334,	// Analyzing System Security: "File systems" (Static)
	IDC_LOG_FILE,	IDH_199_335,	// Analyzing System Security: "System services" (Static)
	IDC_BROWSE,	IDH_199_336,	// Analyzing System Security: "Directory service objects" (Static)
	IDC_VERB,	IDH_199_340,	// Analyzing System Security: "Analyzing:" (Static)
	IDC_PROGRESS1,	IDH_199_321,	// Analyzing System Security: "Progress1" (msctls_progress32)
	IDC_ICON1,	IDH_199_322,	// Analyzing System Security: "g" (Static)
	0, 0
};




const DWORD a209HelpIDs[]=
{
	IDC_STATIC_DESC,	IDH_209_202,	// Untitled: "Security Configuration & Analysis is an administrative tool to secure a computer and analyze security aspects. You can create or edit a security template, apply the security template, perform analysis based on a template, and display analysis results." (Static)
	IDC_STATIC_TITLE,	IDH_209_203,	// Untitled: "Security Configuration & Analysis v1.0" (Static)
	0, 0
};




const DWORD a212HelpIDs[]=
{
	IDC_STATIC_FILENAME,	-1,//IDH_212_306, Configure System: "Error log file path" (Button)
	IDC_LOG_FILE,	IDH_212_335,	// Configure System: "" (Edit)
	IDC_BROWSE,	IDH_212_336,	// Configure System: "&Browse ..." (Button)
	IDC_ERROR,	IDH_212_338,	// Configure System: "" (Static)
	0, 0
};




const DWORD a214HelpIDs[]=
{
	IDC_ANALYZED_SETTING_STATIC,	IDH_214_357,	// Untitled: "Analyzed Setting" (Static)
	IDC_TEMPLATE_SETTING_STATIC,	IDH_214_359,	// Untitled: "Template Setting" (Static)
	IDC_MEMBERS,	IDH_214_290,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ADD,	IDH_214_246,	// Untitled: "A&dd..." (Button)
	IDC_HEADER,	IDH_214_316,	// Untitled: "Members" (Static)
   IDC_DEFINE_GROUP, IDH_168_304, // Define this group in the database (Checkbox)
	0, 0
};




const DWORD a215HelpIDs[]=
{
    IDC_STATIC_FILENAME, -1, //disable this help topic
	IDC_LOG_FILE,	IDH_215_335,	// Perform Analysis: "" (Edit)
	IDC_BROWSE,	IDH_215_336,	// Perform Analysis: "&Browse ..." (Button)
	IDC_ERROR,	IDH_215_338,	// Perform Analysis: "" (Static)
	IDC_NC_GROUPS,	IDH_215_228,	// Perform Analysis: "Error log file path" (Button)
	0, 0
};




const DWORD a216HelpIDs[]=
{
	IDC_INCREMENTAL,	IDH_216_334,	// Import Template: "&Overwrite existing template in database" (Button)
	IDC_LOG_FILE,	IDH_216_335,	// Import Template: "" (Edit)
	IDC_BROWSE,	IDH_216_336,	// Import Template: "&Browse ..." (Button)
	IDC_ERROR_LOG_PROFILE_PATH_STATIC,	IDH_216_360,	// Import Template: "Error log file path" (Button)
	0, 0
};




const DWORD a217HelpIDs[]=
{
	IDC_INCREMENTAL,	IDH_217_334,	// Untitled: "Overwrite existing template in database" (Button)
	0, 0
};




const DWORD a218HelpIDs[]=
{
	IDC_DESCRIPTION,	IDH_218_215,	// Template Description: "" (Edit)
	IDC_DESCRIPTION_STATIC,	IDH_218_361,	// Template Description: "&Description:" (Static)
	0, 0
};




const DWORD a225HelpIDs[]=
{
	IDC_DESCRIPTION,	IDH_225_215,	// New Template: "" (Edit)
	IDC_DESCRIPTION_STATIC,	IDH_225_361,	// New Template: "&Description" (Button)
	IDC_TEMPLATE_NAME_STATIC,	IDH_225_362,	// New Template: "&Template Name:" (Button)
	IDC_CONFIG_NAME,	IDH_225_341,	// New Template: "" (Edit)
	0, 0
};




const DWORD a226HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_226_301,	// Audit File Access : "" (Edit)
	IDC_CONFIGURE,	IDH_226_304,	// Audit File Access : "E&xclude from local policy" (Button)
	IDC_CHANGE_SUCCESS,	IDH_226_243,	// Audit File Access : "Audit &successful attempts" (Button)
	IDC_CURRENT_MEMBER_OF,	IDH_226_244,	// Audit File Access : "Audit &failed attempts" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_226_363,	// Audit File Access : "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_226_364,	// Audit File Access : "Change Local Policy to" (Button)
	IDC_STATIC_DESCRIPTION2, IDH_228_332, //Attribute: (Static)
	IDC_SUCCESSFUL, IDH_226_243, // Audit File Access : "Audit &successful attempts" (Button)
	IDC_FAILED, IDH_226_244, // Audit File Access : "Audit &failed attempts" (Button)
	0, 0
};




const DWORD a227HelpIDs[]=
{
	IDC_CONFIGURE,	IDH_227_304,	// Secure System Objects: "E&xclude from local policy" (Button)
	IDC_ENABLED,	IDH_227_237,	// Secure System Objects: "&Enabled" (Button)
	IDC_DISABLED,	IDH_227_238,	// Secure System Objects: "&Disabled" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_227_363,	// Secure System Objects: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_227_364,	// Secure System Objects: "Change Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_227_229,	// Secure System Objects: "" (Edit)
	0, 0
};




const DWORD a228HelpIDs[]=
{
	IDC_NC_SERVICE,	IDH_228_233,	// Edit Numeric Attribute: "Spin1" (msctls_updown32)
	IDC_NEW,	IDH_228_234,	// Edit Numeric Attribute: "" (Edit)
	IDC_CONFIGURE,	IDH_228_304,	// Edit Numeric Attribute: "E&xclude from local policy" (Button)
	IDC_UNITS,	IDH_228_235,	// Edit Numeric Attribute: "failed attempts" (Static)
	IDC_LI_TITLE,	IDH_228_331,	// Edit Numeric Attribute: "Lockout account after:" (Static)
	IDC_TEMPLATE_TITLE,	IDH_228_332,	// Edit Numeric Attribute: "&Lockout account after:" (Static)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_228_363,	// Edit Numeric Attribute: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_228_364,	// Edit Numeric Attribute: "C&hange Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_228_229,	// Edit Numeric Attribute: "" (Edit)
	IDC_VALUE,	IDH_228_229, // Lockout Account: "" (Edit)
	IDC_HEADER, IDH_228_332,  // Edit Numeric Attribute: "&Lockout account after:" (Static)
	0, 0
};




const DWORD a229HelpIDs[]=
{
	IDC_LAST_INSPECT,	IDH_229_301,	// System Log Retention Method: "Static" (Static)
	IDC_RETENTION,	IDH_229_302,	// System Log Retention Method: "Overwrite events by &days" (Button)
	IDC_ATTRIBUTE_NAME,	IDH_229_303,	// System Log Retention Method: "Retain log:" (Static)
	IDC_CONFIGURE,	IDH_229_304,	// System Log Retention Method: "E&xclude from local policy" (Button)
	IDC_RADIO2,	IDH_229_308,	// System Log Retention Method: "Overwrite events as &needed" (Button)
	IDC_RADIO3,	IDH_229_309,	// System Log Retention Method: "Do not overwrite events (clean log &manually)" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_229_363,	// System Log Retention Method: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_229_364,	// System Log Retention Method: "Change Local Policy to" (Button)
	0, 0
};




const DWORD a230HelpIDs[]=
{
	IDC_NEW,	IDH_230_234,	// Rename Administrator Account: "" (Edit)
	IDC_CONFIGURE,	IDH_230_304,	// Rename Administrator Account: "E&xclude from local policy" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_230_363,	// Rename Administrator Account: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_230_364,	// Rename Administrator Account: "C&hange Local Policy to" (Button)
	IDC_TITLE_MEMBER_OF,	IDH_230_229,	// Rename Administrator Account: "" (Edit)
	IDC_NAME, IDH_230_229, // Rename Administrator Account: "" (Edit)
	0, 0
};




const DWORD a231HelpIDs[]=
{
	IDC_RIGHTS,	IDH_231_305,	// Untitled: "CheckList" (CHECKLIST_SCE)
	IDC_ASSIGNED_TO_STATIC,	IDH_231_355,	// Untitled: "Assigned to" (Static)
	IDC_CONFIGURE,	IDH_231_337,	// Untitled: "E&xclude from local policy" (Button)
	IDC_ADD,	IDH_231_246,	// Untitled: "&Add..." (Button)
	IDC_REMOVE,	IDH_106_247,	// Configure Privilege Grant List: "&Remove" (Button)
	IDC_LOCAL_POLICY_STATIC,	IDH_231_365,	// Untitled: "Local Policy" (Static)
	IDC_EFFECTIVE_POLICY_STATIC,	IDH_231_366,	// Untitled: "Effective Policy" (Static)
	IDC_GRANTLIST,	IDH_106_287,	// Configure Privilege Grant List: "" (ListBox)
	0, 0
};




const DWORD a235HelpIDs[]=
{
	IDC_CONFIGURE,	IDH_235_304,	// Dialog: "E&xclude from local policy" (Button)
	IDC_EFFECTIVE_POLICY_SETTING_STATIC,	IDH_235_363,	// Dialog: "Effective Policy Setting" (Button)
	IDC_CHANGE_LOCAL_POLICY_TO_STATIC,	IDH_235_364,	// Dialog: "C&hange Local Policy to" (Button)
	IDC_CHOICES,	IDH_235_343,	// Dialog: "" (ComboBox)
	IDC_TITLE_MEMBER_OF,	IDH_235_229,	// Dialog: "" (Edit)
	IDC_CHECKBOX,   IDH_235_343, // Dialog: "" (CHECKLIST_SCE)
	0, 0
};




const DWORD a236HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_236_350,	// Dialog: "C&hange template setting to" (Button)
	IDC_CONFIGURE,	IDH_236_304,	// Dialog: "E&xclude this setting from configuration" (Button)
	IDC_CHOICES,	IDH_236_343,	// Dialog: "" (ComboBox)
	IDC_CHECKBOX,  IDH_236_343,	// Dialog: "" (CHECKLIST_SCE)
	0, 0
};




const DWORD a237HelpIDs[]=
{
	IDC_CHANGE_TEMPLATE_SETTING_STATIC,	IDH_237_350,	// Dialog: "C&hange template setting in database to" (Button)
	IDC_CONFIGURE,	IDH_237_304,	// Dialog: "E&xclude from future configurations and analyses" (Button)
	IDC_ANALYZED_COMPUTER_SETTING_STATIC,	IDH_237_351,	// Dialog: "Analyzed Computer Setting" (Button)
	IDC_CHOICES,	IDH_237_343,	// Dialog: "" (ComboBox)
	IDC_TITLE_MEMBER_OF,	IDH_237_229,	// Dialog: "" (Edit)
	0, 0
};




const DWORD a238HelpIDs[]=
{
	IDC_FAILEDLIST,	IDH_238_344,	// Dependency failed on %s: "List1" (SysListView32)
	IDC_WARNING,	IDH_238_345,	// Dependency failed on %s: "Warning: By changing '%s' to '%s' you must configure the following items to at least the suggested values." (Static)
	0, 0
};

const DWORD a239HelpIDs[]=
{
	IDC_PRECEDENCE_LIST,	IDH_239_391,	// Precedency list for RSop result.(SysListView32)
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lenable.cpp
//
//  Contents:   implementation of CLocalPolEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "snapmgr.h"
#include "lenable.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolEnable dialog


CLocalPolEnable::CLocalPolEnable()
: CConfigEnable(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolEnable)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a227HelpIDs;
   m_uTemplateResID = IDD;
}

BOOL CLocalPolEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int status = 0;
      UpdateData(TRUE);

      if (m_bConfigure) 
      {
         if ( 0 == m_nEnabledRadio ) 
         {
            // ENABLED
            dw = 1;
         }
         else
         {
            // DISABLED
            dw = 0;
         }

         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (SCE_ERROR_VALUE != status)
         {
            m_pData->SetBase(dw); //Bug211219, Yanggao, 3/15/2001
            m_pData->SetStatus(status);
            m_pData->Update(m_pSnapin);
         }
      }
   }
   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lchoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lchoice.h
//
//  Contents:   definition of CLocalPolChoice
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_
#include "cchoice.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice dialog

class CLocalPolChoice : public CConfigChoice
{
// Construction
public:
   CLocalPolChoice();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolChoice)
	enum { IDD = IDD_LOCALPOL_REGCHOICES };
	//}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolChoice)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolChoice)
   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lchoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lchoice.cpp
//
//  Contents:   implementation of CLocalPolChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "LChoice.h"
#include "util.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice dialog


CLocalPolChoice::CLocalPolChoice()
: CConfigChoice(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolChoice)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a235HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolChoice message handlers

BOOL CLocalPolChoice::OnInitDialog()
{
   CConfigChoice::OnInitDialog();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   if (!prv ) //Raid 372939, 4/20/2001
   {
      m_cbChoices.SetCurSel(-1);
   }
   else //Raid #457885, Yang Gao, 8/21/2001
   {
      if( prv->Value == NULL )
      {
         m_cbChoices.SetCurSel(-1);
         m_bConfigure = TRUE;
         UpdateData(FALSE); //Raid #480375, Yanggao, 10/12/2001
         EnableUserControls(m_bConfigure);
      }
   }
   OnSelchangeChoices();
   return TRUE;
}

BOOL CLocalPolChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int nIndex = 0;

      UpdateData(TRUE);
      if (m_bConfigure) 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex) 
            dw = (DWORD) m_cbChoices.GetItemData(nIndex);
         
         PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

         //
         // this address should never be NULL
         //
         if ( prv ) 
         {
            PWSTR pTmp=NULL;

            if ( dw != SCE_NO_VALUE ) 
            {
               CString strTmp;
               // allocate buffer
               strTmp.Format(TEXT("%d"), dw);
               pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

               if ( pTmp )
                  //This may not be a safe usage. using WCHAR instead of TCHAR. Consider fix.
                  wcscpy(pTmp,(LPCTSTR)strTmp);
               else 
               {
                  // can't allocate buffer, error!!
                  return FALSE;
               }
            }

            if ( prv->Value )
               LocalFree(prv->Value);
            
            prv->Value = pTmp;

            m_pSnapin->UpdateLocalPolRegValue(m_pData);
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lflags.cpp
//
//  Contents:   implementation of CLocalPolRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "LFlags.h"
#include "util.h"
#include "chklist.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegFlags dialog


CLocalPolRegFlags::CLocalPolRegFlags()
: CConfigRegFlags(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolRegFlags)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR) a235HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegFlags message handlers

BOOL CLocalPolRegFlags::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL) 
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for (int i=0;i<nItems;i++) 
         {
            dw = (DWORD) wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1));
            if (CLST_CHECKED == dw)
               fFlags |= (DWORD)wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv);
      if ( prv ) 
      {
         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = NULL;

         if ( fFlags != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( prv->Value )
               //This is a safe usage.
               lstrcpy(prv->Value,(LPCTSTR)strTmp);
            else
               return FALSE;
         }

         m_pSnapin->UpdateLocalPolRegValue(m_pData);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CLocalPolRegFlags::Initialize(CResult * pResult)
{
   CConfigRegFlags::Initialize(pResult);
   if (!m_bConfigure) {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lenable.h
//
//  Contents:   definition of CLocalPolEnable
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolEnable dialog
#include "cenable.h"

class CLocalPolEnable : public CConfigEnable
{
// Construction
public:
   CLocalPolEnable();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolEnable)
   enum { IDD = IDD_LOCALPOL_ENABLE };
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolEnable)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolEnable)
   virtual BOOL OnApply();
   //}}AFX_MSG

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LENABLE_H__2B949F0C_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lnumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lnumber.cpp
//
//  Contents:   implementation of CLocalPolNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "anumber.h"
#include "lnumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolNumber dialog


CLocalPolNumber::CLocalPolNumber()
: CConfigNumber(IDD)
{
    m_pHelpIDs = (DWORD_PTR)a228HelpIDs;
    m_uTemplateResID = IDD;
}

BOOL CLocalPolNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bUpdateAll = FALSE;
      DWORD dw = 0;
      CString strForever,strOff;
      int status = 0;

      UpdateData(TRUE);

      if (m_bConfigure) 
      {
         dw = CurrentEditValue();

         bUpdateAll = FALSE;


         PEDITTEMPLATE pLocalDeltaTemplate = m_pSnapin->GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
         if (pLocalDeltaTemplate)
            pLocalDeltaTemplate->LockWriteThrough();

         //
         // Check dependencies for the item.
         //
         if (DDWarn.CheckDependencies (dw) == ERROR_MORE_DATA ) 
         {
            //
            // If the user presses cancel then we will not allow them to set the item and let
            // them press cancel.
            //
            CThemeContextActivator activator;
            if ( DDWarn.DoModal() != IDOK)
               return FALSE;

            //
            // The user is giving us the go ahead to set the items to the suggested 
            // configuration.
            //
            for (int i = 0; i < DDWarn.GetFailedCount(); i++) 
            {
               PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
               if (pItem && pItem->pResult ) 
               {
                  //
                  // Update local policy for each item that failed the dependency.
                  // The suggested values are relative to the item we are configuring.
                  //
                  status = m_pSnapin->SetLocalPolInfo(
                                                     pItem->pResult->GetID(), 
                                                     pItem->dwSuggested);
                  if (SCE_ERROR_VALUE != status) 
                  {
                     pItem->pResult->SetBase( pItem->dwSuggested );
                     pItem->pResult->SetStatus( status );
                     pItem->pResult->Update(m_pSnapin, FALSE);
                  }
               }
            }

         }

         //
         // Update local policy for this item.
         //
         status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
         if (pLocalDeltaTemplate) 
            pLocalDeltaTemplate->UnLockWriteThrough();
      
         if (SCE_ERROR_VALUE != status) 
         {
            m_pData->SetBase(dw);
            m_pData->SetStatus(status);

            //
            // Update the entire pane, not just this particular item, since
            // many of these changes will effect a second item in the pane
            //
            switch (m_pData->GetID()) 
            {
               case IDS_SEC_LOG_DAYS:
               case IDS_APP_LOG_DAYS:
               case IDS_SYS_LOG_DAYS:
                  bUpdateAll = TRUE;
                  break;

               default:
                  break;
            }
         }

         //
         // Redraw the result pane.
         //
         if (SCE_ERROR_VALUE != status || bUpdateAll)
            m_pData->Update(m_pSnapin, bUpdateAll);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lflags.h
//
//  Contents:   definition of CLocalPolRegFlags
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_
#include "cflags.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolflags dialog

class CLocalPolRegFlags : public CConfigRegFlags
{
// Construction
public:
   CLocalPolRegFlags();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolRegflags)
        enum { IDD = IDD_LOCALPOL_REGFLAGS };
        //}}AFX_DATA

   virtual void Initialize(CResult *pResult);


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRegFlags)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolFlags)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_Lflags_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lnumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lnumber.h
//
//  Contents:   definition of CLocalPolNumber
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "cnumber.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolNumber dialog

class CLocalPolNumber : public CConfigNumber
{
// Construction
public:
   CLocalPolNumber();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolNumber)
   enum { IDD = IDD_LOCALPOL_NUMBER };
   //}}AFX_DATA

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolNumber)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LNUMBER_H__2B949F0D_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lret.cpp
//
//  Contents:   implementation of CLocalPolRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "lret.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRet dialog


CLocalPolRet::CLocalPolRet()
: CConfigRet(IDD)
{
    //{{AFX_DATA_INIT(CLocalPolRet)
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a229HelpIDs;
    m_uTemplateResID = IDD;
}

BOOL CLocalPolRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      int status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;

         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;

         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;

         default:
            break;
         }
      }


      PEDITTEMPLATE pLocalDeltaTemplate = m_pSnapin->GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
      if (pLocalDeltaTemplate) 
         pLocalDeltaTemplate->LockWriteThrough();

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw) == ERROR_MORE_DATA )
      {
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetLocalPolInfo(pItem->pResult->GetID(),
                                                   pItem->dwSuggested);
               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }
      m_pData->SetBase(dw);
      status = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
      if (SCE_ERROR_VALUE != status) 
      {
         m_pData->SetStatus(status);
         m_pData->Update(m_pSnapin, TRUE);
      }

      if (pLocalDeltaTemplate)
         pLocalDeltaTemplate->UnLockWriteThrough();
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lret.h
//
//  Contents:   definition of CLocalPolRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRet dialog
#include "cret.h"

class CLocalPolRet : public CConfigRet
{
// Construction
public:
   CLocalPolRet();   // standard constructor
// Dialog Data
   //{{AFX_DATA(CLocalPolRet)
   enum { IDD = IDD_LOCALPOL_RET };
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRet)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolRet)
   virtual BOOL OnApply();
   //}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LRET_H__2B949F0E_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\locdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       locdesc.h
//
//  Contents:   definition of CSetLocationDescription
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
#define AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SetLocationDescription.h : header file
//

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription dialog

class CSetLocationDescription : public CHelpDialog
{
// Construction
public:
   CSetLocationDescription(CWnd* pParent = NULL);   // standard constructor

   void Initialize(CFolder *pFolder, CComponentDataImpl *pCDI);

// Dialog Data
   //{{AFX_DATA(CSetLocationDescription)
   enum { IDD = IDD_SET_DESCRIPTION };
   CString  m_strDesc;
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CSetLocationDescription)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CSetLocationDescription)
   virtual void OnOK();
   virtual void OnCancel();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CFolder *m_pFolder;
   CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETLOCATIONDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\locdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       locdesc.cpp
//
//  Contents:   implementation of CSetLocationDescription
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "cookie.h"
#include "LocDesc.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription dialog


CSetLocationDescription::CSetLocationDescription(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a218HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CSetLocationDescription)
   m_strDesc = _T("");
   //}}AFX_DATA_INIT
}


void CSetLocationDescription::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSetLocationDescription)
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDesc);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetLocationDescription, CHelpDialog)
   //{{AFX_MSG_MAP(CSetLocationDescription)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSetLocationDescription::Initialize(CFolder *pFolder, CComponentDataImpl *pCDI) {
   m_pFolder = pFolder;
   m_pCDI = pCDI;
   m_strDesc = pFolder->GetDesc();
}

/////////////////////////////////////////////////////////////////////////////
// CSetLocationDescription message handlers
DWORD 
SetDescHelper(HKEY hKey,CFolder *pFolder,CString strDesc) {
   DWORD status = RegSetValueEx(hKey,
                          L"Description", // Value name (not localized)
                          0,              // Reserved
                          REG_SZ,
                          (CONST BYTE *)(LPCTSTR)strDesc,
                          (strDesc.GetLength()+1)*sizeof(TCHAR));
   if (NO_ERROR == status) {
      pFolder->SetDesc(strDesc);
   } else {
      // Couldn't set a value
   }

   RegCloseKey(hKey);
   return status;
}

void CSetLocationDescription::OnOK()
{
   DWORD status = 0;
   HKEY hKey = 0;
   CString strLocKey;
   CString strErr;
   LPTSTR szName = 0;
   LPTSTR sz = 0;

   UpdateData(TRUE);

   strLocKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);
   strLocKey += L'\\';
   szName = m_pFolder->GetName();
   // replace '\' with '/' because Registry does not
   // take '/' in a single key
   //
   sz = wcschr(szName, L'\\');
   while (sz) {
      *sz = L'/';
      sz = wcschr(sz, L'\\');
   }
   strLocKey += szName;

   if( !m_strDesc.IsEmpty() ) //Raid #482845, Yanggao
   {
      m_strDesc.Replace(L"\r\n", NULL);
   }
   PCWSTR szInvalidCharSet = INVALID_DESC_CHARS;
   if( m_strDesc.FindOneOf(szInvalidCharSet) != -1 )
   {
      CString text;
      text.FormatMessage (IDS_INVALID_DESC, szInvalidCharSet);
      AfxMessageBox(text);
      GetDlgItem(IDC_DESCRIPTION)->SetFocus();
      return;
   }

   status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         strLocKey,
                         0,
                         KEY_SET_VALUE,
                         &hKey);

   if (NO_ERROR == status) {
      status = SetDescHelper(hKey,m_pFolder,m_strDesc);
   } else {
      //
      // Only display an error if we can read (and thus displayed)
      // this key
      //
      if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   strLocKey,
                                   0,
                                   KEY_READ,
                                   &hKey)) {
         strErr.LoadString(IDS_ERR_GLOBAL_LOC_DESC);
         MessageBox(strErr);
         RegCloseKey(hKey);
      }
   }

   if (NO_ERROR != status) {
      //
      // Bug 375324: if we can't succeed under HKLM try under HKCU
      //
      status = RegOpenKeyEx(HKEY_CURRENT_USER,
                            strLocKey,
                            0,
                            KEY_SET_VALUE,
                            &hKey);
   
      if (NO_ERROR == status) {
         status = SetDescHelper(hKey,m_pFolder,m_strDesc);
      } else {
      //
      // Only display an error if we can read (and thus displayed) 
      // this key
      //
         if (NO_ERROR == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      strLocKey,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
            strErr.LoadString(IDS_ERR_LOCAL_LOC_DESC);
            MessageBox(strErr);
            RegCloseKey(hKey);
         }
      } 
   }

   szName = m_pFolder->GetName();
   // replace '/' with '\' because Registry does not
   sz = wcschr(szName, L'/');
   while (sz) {
      *sz = L'\\';
      sz = wcschr(sz, L'/');
   }

   LPCONSOLENAMESPACE tempnamespace = m_pCDI->GetNameSpace(); //Raid #252638, 5/2/2001
   if( tempnamespace )
   {
       tempnamespace->SetItem(m_pFolder->GetScopeItem());
   }

   DestroyWindow();
}

void CSetLocationDescription::OnCancel()
{
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lright.cpp
//
//  Contents:   implementation of CLocalPolRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "util.h"
#include "chklist.h"
#include "getuser.h"
#include "lright.h"

#ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRight dialog


CLocalPolRight::CLocalPolRight()
: CConfigPrivs(IDD)
{
    m_pHelpIDs = (DWORD_PTR)a231HelpIDs;
    m_uTemplateResID = IDD;
}


BEGIN_MESSAGE_MAP(CLocalPolRight, CConfigPrivs)
    //{{AFX_MSG_MAP(CConfigPrivs)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


PSCE_PRIVILEGE_ASSIGNMENT
CLocalPolRight::GetPrivData() {
   ASSERT(m_pData);
   if (m_pData) {
      return (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetBase();
   }
   return NULL;
}

void
CLocalPolRight::SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa) {
   ASSERT(m_pData);
   if (m_pData) {
      m_pSnapin->UpdateLocalPolInfo(m_pData,
                                    FALSE,
                                    &ppa,
                                    m_pData->GetUnits()
                                    );
      m_pData->SetBase((LONG_PTR)ppa);
   }
}

void CLocalPolRight::OnAdd() {
   CGetUser gu;

   if (gu.Create( GetSafeHwnd(), 
                  SCE_SHOW_USERS | 
                  SCE_SHOW_LOCALGROUPS | 
                  SCE_SHOW_GLOBAL | 
                  SCE_SHOW_WELLKNOWN | 
                  SCE_SHOW_BUILTIN |
                  SCE_SHOW_SCOPE_ALL | 
                  SCE_SHOW_DIFF_MODE_OFF_DC |
                  SCE_SHOW_COMPUTER)) { //Raid #477428, Yanggao
      PSCE_NAME_LIST pName = gu.GetUsers();
      CListBox *plbGrant = (CListBox*)GetDlgItem(IDC_GRANTLIST);
      while(pName)
      {
         if (plbGrant && 
             (LB_ERR == plbGrant->FindStringExact(-1,pName->Name)))
         {
            plbGrant->AddString(pName->Name);
            m_fDirty = true;
            SetModified(TRUE); //Raid #389890, 5/11/2001
         }
         pName = pName->Next;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lstring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lstring.cpp
//
//  Contents:   implementation of CLocalPolString
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "wsecmgr.h"
#include "lstring.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString dialog


CLocalPolString::CLocalPolString()
: CConfigName(IDD)
{
   //{{AFX_DATA_INIT(CLocalPolString)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a230HelpIDs;
   m_uTemplateResID = IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString message handlers

BOOL CLocalPolString::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);

      BOOL bChanged=TRUE;

      m_strName.TrimLeft();
      m_strName.TrimRight();

      if (m_bConfigure) 
      {
         dw = (LONG_PTR)(LPCTSTR)m_strName;
         if ( m_pData->GetBase() && dw &&
              _wcsicmp((LPTSTR)(m_pData->GetBase()), (LPTSTR)dw) == 0 ) 
         {
             bChanged = FALSE;
         }

         if ( bChanged ) 
         {
             if ( m_pData->GetSetting() == m_pData->GetBase() &&
                  m_pData->GetSetting() ) 
             {
                 // a good item, need take the base into setting
                 m_pSnapin->TransferAnalysisName(m_pData->GetID());
             }

             m_pData->SetBase(dw);

             DWORD dwStatus = m_pSnapin->SetLocalPolInfo(m_pData->GetID(),dw);
             //Yanggao 1/31/2001 Bug211219.
             if( SCE_STATUS_MISMATCH == dwStatus )
             {
                m_pData->SetStatus(dwStatus);
                m_pData->Update(m_pSnapin,TRUE);
             }
             else if (SCE_ERROR_VALUE != dwStatus)
             {
                m_pData->SetStatus(dwStatus);
                m_pData->Update(m_pSnapin);
             }
         }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lright.h
//
//  Contents:   definition of CLocalPolRight
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRight dialog
#include "cprivs.h"

class CLocalPolRight : public CConfigPrivs
{
// Construction
public:
//	virtual void Initialize(CResult *pResult);
   CLocalPolRight();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CLocalPolRight)
   enum { IDD = IDD_LOCALPOL_RIGHT };
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolRight)
   protected:
   //}}AFX_VIRTUAL

// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CLocalPolRight)
	afx_msg void OnAdd();
   //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   virtual PSCE_PRIVILEGE_ASSIGNMENT GetPrivData();
   virtual void SetPrivData(PSCE_PRIVILEGE_ASSIGNMENT ppa);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LRIGHT_H__2B949F0F_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\lstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       lstring.h
//
//  Contents:   definition of CLocalPolString
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
#define AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"
#include "attr.h"
#include "snapmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CLocalPolString dialog
#include "cname.h"

class CLocalPolString : public CConfigName
{
// Construction
public:
   CLocalPolString();   // standard constructor
// Dialog Data
   //{{AFX_DATA(CLocalPolString)
   enum { IDD = IDD_LOCALPOL_STRING };
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CLocalPolString)
   protected:
   //}}AFX_VIRTUAL


// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CLocalPolString)
	virtual BOOL OnApply();
	//}}AFX_MSG
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LSTRING_H__2B949F10_4F4D_11D2_ABC8_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\multisz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       multisz.h
//
//  Contents:   definition of CDomainRegMultiSZ
//                              CAttrRegMultiSZ
//                              CLocalPolRegMultiSZ
//                              CConfigRegMultiSZ
//                              
//----------------------------------------------------------------------------
#include "regvldlg.h"

class CDomainRegMultiSZ : public CDomainRegString 
{
public:
   enum { IDD =IDD_DOMAIN_REGMULTISZ };
   CDomainRegMultiSZ() : CDomainRegString(IDD) //Raid #381309, 4/31/2001
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }

protected:
    virtual BOOL OnInitDialog ()
    {
        CDomainRegString::OnInitDialog ();

        SendDlgItemMessage (IDC_NAME, EM_LIMITTEXT, 4096);
	    return TRUE;
    }
};

class CAttrRegMultiSZ : public CAttrRegString 
{
public:
   enum { IDD =IDD_ATTR_REGMULTISZ };
   CAttrRegMultiSZ() : CAttrRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }
};

class CLocalPolRegMultiSZ : public CLocalPolRegString 
{
public:
   enum { IDD =IDD_LOCALPOL_REGMULTISZ };
   CLocalPolRegMultiSZ() : CLocalPolRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }
};


class CConfigRegMultiSZ : public CConfigRegString 
{
public:
   enum { IDD =IDD_CONFIG_REGMULTISZ };
   CConfigRegMultiSZ() : CConfigRegString(IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL QueryMultiSZ() { return TRUE; }


protected:
    virtual BOOL OnInitDialog ()
    {
        CConfigRegString::OnInitDialog ();

        SendDlgItemMessage (IDC_NAME, EM_LIMITTEXT, 4096);
	    return TRUE;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\perfanal.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       perfanal.h
//
//  Contents:   definition of CPerformAnalysis
//
//----------------------------------------------------------------------------
#if !defined(AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis dialog

class CPerformAnalysis : public CHelpDialog
{
// Construction
public:
   CPerformAnalysis(CWnd * pParent, UINT nTemplateID);   // standard constructor

// Dialog Data
   //{{AFX_DATA(CPerformAnalysis)
   enum { IDD = IDD_PERFORM_ANALYSIS };
   CButton  m_ctlOK;
   CString  m_strError;
   CString  m_strLogFile;
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CPerformAnalysis)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CPerformAnalysis)
   afx_msg void OnBrowse();
   afx_msg void OnOK();
   afx_msg void OnCancel();
   afx_msg BOOL OnInitDialog();
   afx_msg void OnChangeLogFile();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   virtual DWORD DoIt();

   CString m_strOriginalLogFile;
   CComponentDataImpl *m_pComponentData;
   HWND  m_hPWnd;

public:
   CString m_strDataBase;

   void SetComponentData(CComponentDataImpl *pCD) { m_pComponentData = pCD; }

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERFANAL_H__69D140AD_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\newprof.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       newprof.h
//
//  Contents:   definition of CNewProfile
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_)
#define AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CNewProfile dialog

class CNewProfile : public CHelpDialog
{
// Construction
public:
   CNewProfile(CWnd* pParent = NULL);   // standard constructor

   void Initialize(CFolder *pFolder, CComponentDataImpl *pCDI);

// Dialog Data
   //{{AFX_DATA(CNewProfile)
   enum { IDD = IDD_NEW_PROFILE };
   CButton  m_btnOK;
   CString  m_strNewFile;
   CString  m_strDescription;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CNewProfile)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation

protected:

   // Generated message map functions
   //{{AFX_MSG(CNewProfile)
   afx_msg void OnChangeConfigName();
   virtual void OnOK();
   virtual BOOL OnInitDialog();
   virtual void OnCancel();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CFolder *m_pFolder;
   CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROFILE_H__BFAC7E70_3C50_11D2_93B4_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\newprof.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       newprof.cpp
//
//  Contents:   implementation of CNewProfile
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "cookie.h"
#include "snapmgr.h"
#include "NewProf.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProfile dialog


CNewProfile::CNewProfile(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a225HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CNewProfile)
   m_strNewFile = _T("");
   m_strDescription = _T("");
   //}}AFX_DATA_INIT
}


void CNewProfile::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CNewProfile)
   DDX_Control(pDX, IDOK, m_btnOK);
   DDX_Text(pDX, IDC_CONFIG_NAME, m_strNewFile);
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewProfile, CHelpDialog)
    //{{AFX_MSG_MAP(CNewProfile)
    ON_EN_CHANGE(IDC_CONFIG_NAME, OnChangeConfigName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CNewProfile::Initialize(CFolder *pFolder, CComponentDataImpl *pCDI) {
   m_pFolder = pFolder;
   m_pCDI = pCDI;
   m_strDescription.Empty();
   m_strNewFile.Empty(); //Raid #401939.
}


/////////////////////////////////////////////////////////////////////////////
// CNewProfile message handlers

void CNewProfile::OnChangeConfigName()
{
   UpdateData(TRUE);
   if( m_strNewFile.Find(L' ') == 0 ) //Raid #477191, yanggao, 11/5/01
   {
      m_strNewFile.TrimLeft();
      GetDlgItem(IDC_CONFIG_NAME)->SetWindowText(m_strNewFile);
   }
   m_btnOK.EnableWindow(!m_strNewFile.IsEmpty());
}

void CNewProfile::OnOK()
{
   CString strExt;
   CString strFile;
   int i = 0;

   UpdateData(TRUE);
   //
   // Make sure the file name is correct.
   //

   strExt.LoadString(IDS_PROFILE_DEF_EXT); //Raid #533425, #574018, yanggao, 4/1/2002.
   strExt = TEXT(".") + strExt;
   //Raid #533432, yanggao, 4/3/2002
   if( !IsValidFileName(m_strNewFile) || IsNameReserved(m_strNewFile, strExt) ) //Raid #484084, Yanggao, 12/23/2001
   {
      CWnd* pwnd = GetDlgItem(IDC_CONFIG_NAME); //Raid #498477, yanggao
      if( pwnd )
      {
         pwnd->SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
         pwnd->SetFocus();
      }
      return;
   }

   i = m_strNewFile.ReverseFind(L'.');
   if( i >= 0 && strExt == m_strNewFile.Right(m_strNewFile.GetLength()-i) )
   {
      //
      // If they provided a correct extension then use it
      //
      strExt = m_strNewFile;
   } else {
      //
      // Otherwise add our own
      //
      strFile = m_strNewFile;
      strExt = strFile + strExt;
   }

   strFile = m_pFolder->GetName();
   if( strExt.GetAt(0) == L'\\' || strExt.GetAt(0) == L'/' ) //Raid #498480, yanggao, 11/21/2001
   {
      strFile += strExt;
   }
   else
   {
      strFile += TEXT("\\") + strExt;
   }

   //
   // Make sure we can create the file
   //
   HANDLE hFile;
   hFile = ExpandAndCreateFile(
                             strFile,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_NEW,
                             FILE_ATTRIBUTE_ARCHIVE,
                             NULL
                             );
   if (hFile == INVALID_HANDLE_VALUE) {
      LPTSTR pszErr;
      CString strMsg;

      FormatMessage(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   0,
                   (LPTSTR)&pszErr,
                   0,
                   NULL
                   );

      strMsg = pszErr + strFile;
      if( strFile.GetLength() > MAX_PATH ) //Raid 501615, yanggao
      {
         CString strTemp;
         strTemp.LoadString(IDS_PATH_TOO_LONG);
         strMsg = strMsg + L"\n" + strTemp;
      }
      AfxMessageBox(strMsg, MB_OK);
      strFile.Empty();

      CWnd* pwnd = GetDlgItem(IDC_CONFIG_NAME); //Raid #502392, yanggao
      if( pwnd )
      {
         pwnd->SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
         pwnd->SetFocus();
      }
      return;
   } else {
      //
      // Successfully Created the File
      //
      if (hFile) {
         ::CloseHandle( hFile );
      }
      //
      // Delete it so we can create a new one in its place
      //
      DeleteFile( strFile );
      CreateNewProfile(strFile);


      LPNOTIFY pNotifier = NULL;
      if (m_pCDI) {
         pNotifier = m_pCDI->GetNotifier();
      }

      //
      // Save the description in the template
      //
      if (!m_strDescription.IsEmpty()) {

         CEditTemplate *pet;
         if (m_pCDI) {
            pet = m_pCDI->GetTemplate(strFile);
            if (pet) {
               pet->SetDescription(m_strDescription);
               pet->Save();
            }
         }
      }

      if( LOCATIONS == m_pFolder->GetType() && !m_pFolder->IsEnumerated() ) //Raid #191582, 4/26/2001
      {
         ::EnableWindow(m_pCDI->GetParentWindow(), TRUE); //Raid #492433, yanggao
         DestroyWindow();
         return;
      }

      if (pNotifier) {
         pNotifier->ReloadLocation(m_pFolder,m_pCDI);
      }
   }

   ::EnableWindow(m_pCDI->GetParentWindow(), TRUE); //Raid #492433, yanggao
   DestroyWindow();
}


BOOL CNewProfile::OnInitDialog()
{
   CDialog::OnInitDialog();

   GetDlgItem(IDC_CONFIG_NAME)->SendMessage(EM_LIMITTEXT, MAX_PATH, 0); //Raid #481595, Yanggao, 10/17/2001
   GetDlgItem(IDC_DESCRIPTION)->SendMessage(EM_LIMITTEXT, MAX_PATH, 0); //Raid #525155, Yanggao, 2/28/2002

   m_btnOK.EnableWindow(!m_strNewFile.IsEmpty());

   ::EnableWindow(m_pCDI->GetParentWindow(), FALSE); //Raid #492433, yanggao, avoid closing snapin window.
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewProfile::OnCancel()
{
   ::EnableWindow(m_pCDI->GetParentWindow(), TRUE); //Raid #492433, yanggao
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\perfanal.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       perfanal.cpp
//
//  Contents:   implementation of CPerformAnalysis
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "PerfAnal.h"
#include "wrapper.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis dialog


CPerformAnalysis::CPerformAnalysis(CWnd * pParent, UINT nTemplateID)
: CHelpDialog(a215HelpIDs, nTemplateID ? nTemplateID : IDD, pParent)
{
   //{{AFX_DATA_INIT(CPerformAnalysis)
   m_strLogFile = _T("");
   //}}AFX_DATA_INIT
}


void CPerformAnalysis::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPerformAnalysis)
   DDX_Control(pDX, IDOK, m_ctlOK);
   DDX_Text(pDX, IDC_ERROR, m_strError);
   DDX_Text(pDX, IDC_LOG_FILE, m_strLogFile);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPerformAnalysis, CHelpDialog)
   //{{AFX_MSG_MAP(CPerformAnalysis)
   ON_BN_CLICKED(IDOK, OnOK)
   ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
   ON_EN_CHANGE(IDC_LOG_FILE, OnChangeLogFile)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPerformAnalysis message handlers

void CPerformAnalysis::OnBrowse()
{
   CString strLogFileExt;
   CString strLogFileFilter;
   CString strTitle;

   OPENFILENAME ofn;
   ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
   ofn.lStructSize = sizeof(OPENFILENAME);

   UpdateData(TRUE);

   m_strLogFile.Remove(L'<'); //Raid #463367, '<' is a invalid filename char.

   strLogFileExt.LoadString(IDS_LOGFILE_DEF_EXT);
   strLogFileFilter.LoadString(IDS_LOGFILE_FILTER);
   strTitle.LoadString(IDS_LOGFILE_PICKER_TITLE);

   // Translate filter into commdlg format (lots of \0)
   LPTSTR szFilter = strLogFileFilter.GetBuffer(0); // modify the buffer in place
   // MFC delimits with '|' not '\0'

   LPTSTR pch = szFilter;
   while ((pch = _tcschr(pch, '|')) != NULL)
        *pch++ = '\0';
   // do not call ReleaseBuffer() since the string contains '\0' characters

   ofn.lpstrFilter = szFilter;
   ofn.lpstrFile = m_strLogFile.GetBuffer(MAX_PATH),
   ofn.nMaxFile = MAX_PATH;
   ofn.lpstrDefExt = strLogFileExt,
   ofn.hwndOwner = m_hWnd;
   ofn.Flags = OFN_HIDEREADONLY |
               OFN_EXPLORER |
               OFN_DONTADDTORECENT|
               OFN_NOREADONLYRETURN,
   ofn.lpstrTitle = strTitle;

   //
   // Default to the currently picked log file
   //

   if (GetOpenFileName(&ofn)) {
      m_strLogFile.ReleaseBuffer();
      UpdateData(FALSE);
      if (m_strLogFile.IsEmpty()) //Raid #669231, yanggao, 8/9/2002
         m_ctlOK.EnableWindow(FALSE);
      else
         m_ctlOK.EnableWindow(TRUE);
   } else {
      m_strLogFile.ReleaseBuffer();
   }

}

//+--------------------------------------------------------------------------
//
//  Method:     DoIt
//
//  Synopsis:   Actually Analyzes the system (separated from OnOK so it can
//              be overridden to Configure the system, etc. while still using
//              the same OnOK shell code
//
//---------------------------------------------------------------------------
DWORD CPerformAnalysis::DoIt() {
   //
   // Store the log file we're using for next time
   //
   LPTSTR szLogFile = m_strLogFile.GetBuffer(0);
   m_pComponentData->GetWorkingDir(GWD_ANALYSIS_LOG,&szLogFile,TRUE,TRUE);
   m_strLogFile.ReleaseBuffer();
   //
   // InspectSystem will handle multi-threading and progress UI so
   // SCE doesn't get wierd on the user
   //
   return InspectSystem(
              NULL, // Always use the configuration assigned to the DB
              m_strDataBase.IsEmpty() ? NULL: (LPCTSTR)m_strDataBase,
              (LPCTSTR)m_strLogFile,
              AREA_ALL
              );
}

//+--------------------------------------------------------------------------
//
//  Method:     OnOK
//
//  Synopsis:   Analyzes the system
//
//---------------------------------------------------------------------------
afx_msg void CPerformAnalysis::OnOK()
{
   CWnd *cwnd;
   HANDLE hLogFile;

   UpdateData(TRUE);

   //
   // We require a log file that we can write to
   //
   CString strLogFileExt;
   strLogFileExt.LoadString(IDS_LOGFILE_DEF_EXT); //Raid #553110, yanggao
   strLogFileExt = TEXT(".") + strLogFileExt;
   if (m_strLogFile.IsEmpty()) {
      return;
   }
   else {
      m_strLogFile = ExpandEnvironmentStringWrapper(m_strLogFile);
      if( !IsValidFileName(m_strLogFile) || IsNameReserved(m_strLogFile, strLogFileExt)) //Raid #463367, Yang Gao, 9/5/2001.
      {
          CWnd* pwnd = GetDlgItem(IDC_LOG_FILE); //Raid #501877, yanggao, 12/03/2001
          if( pwnd )
          {
             pwnd->SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
             pwnd->SetFocus();
          }
          return;
      }
   }

   int i = m_strLogFile.ReverseFind(L'.'); //Raid #553110, yanggao
   if( i < 0 || strLogFileExt != m_strLogFile.Right(m_strLogFile.GetLength()-i) )
   {
      m_strLogFile = m_strLogFile + strLogFileExt;
   }

   LONG dwPosLow = 0, dwPosHigh = 0;
   //This is a safe usage. m_strLogFile is full path.
   hLogFile = CreateFile(m_strLogFile,  // pointer to name of the file
                        GENERIC_WRITE, // access (read-write) mode
                        0,             // share mode
                        NULL,          // pointer to security attributes
                        OPEN_ALWAYS,   // how to create
                        FILE_ATTRIBUTE_NORMAL, // file attributes
                        NULL           // handle to file with attributes to copy
                        );

   if (INVALID_HANDLE_VALUE == hLogFile) {
      LPTSTR pszErr;
      CString strMsg;

      ////Raid #501886, yanggao, 12/03/2001, Get the error description from system.
      FormatMessage(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   0,
                   (LPTSTR)&pszErr,
                   0,
                   NULL
                   );

      strMsg = pszErr + m_strLogFile;
      if( m_strLogFile.GetLength() >= MAX_PATH )
      {
         CString strTemp;
         strTemp.LoadString(IDS_PATH_TOO_LONG);
         strMsg = strMsg + L"\n" + strTemp;
      }

      CString strTitle;
      strTitle.LoadString(IDS_ANALYSIS_VIEWER_NAME);

      MessageBox(strMsg,strTitle,MB_OK);

      CWnd* pwnd = GetDlgItem(IDC_LOG_FILE);
      if( pwnd )
      {
         pwnd->SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
         pwnd->SetFocus();
      }

      return;
   }

   dwPosLow = SetFilePointer(hLogFile, 0, &dwPosHigh, FILE_END );
   CloseHandle(hLogFile);


   CWaitCursor wc;

   DWORD smstatus = ERROR_SUCCESS;

   LPNOTIFY pNotify = m_pComponentData->GetNotifier();
   ASSERT(pNotify);

   //
   // Lock the analysis pane since its data is invalid while we're inspecting
   //
   if (pNotify) {
      pNotify->LockAnalysisPane(TRUE);
   }
   CFolder *pFolder = m_pComponentData->GetAnalFolder();

   //
   // Force the Analysis root node to be selected so that we display
   // the generating information message.  If we forse this repaint to happen
   // now then we don't seem to have that AV problem.
   //
   if(pFolder && pNotify){
      pNotify->SelectScopeItem(pFolder->GetScopeItem()->ID);
   }
   //
   // Make sure we don't have the database open.  That'll prevent us
   // from being able to configure.
   //
   m_pComponentData->UnloadSadInfo();


   //
   // Disable the child windows so they don't respond to input while we're
   // performing the inspection
   //
   cwnd = GetWindow(GW_CHILD);
   while(cwnd) {
      cwnd->EnableWindow(FALSE);
      cwnd = cwnd->GetNextWindow();
   }

   smstatus = DoIt();

   //Raid #358503, 4/17/2001
   if( m_hPWnd )
   {
       ::EnableWindow(m_hPWnd, TRUE);
   }
   //
   // The inspection data is valid now, so let people back at it
   //
   if (pNotify) {
      pNotify->LockAnalysisPane(false, false);
   }
   m_pComponentData->SetErroredLogFile(m_strLogFile, dwPosLow );
   //
   // There was an error so display the log file (if any)
   //
   if (ERROR_SUCCESS != smstatus) {
      m_pComponentData->SetFlags( CComponentDataImpl::flag_showLogFile );
   }


   //
   // We're done inspecting so reenable input to the child windows
   //
   cwnd = GetWindow(GW_CHILD);
   while(cwnd) {
      cwnd->EnableWindow(TRUE);
      cwnd = cwnd->GetNextWindow();
   }

   //CDialog::OnOK();
   UpdateData();
   DestroyWindow();
}

BOOL CPerformAnalysis::OnInitDialog()
{
   //Raid #669945, yanggao, 8/9/2002
   HWND framehwnd = NULL; 
   LPCONSOLE pconsole = m_pComponentData->GetConsole();
   if( pconsole )
   {
      pconsole->GetMainWindow(&framehwnd);
      if( framehwnd )
      {
         m_hPWnd = framehwnd;
         ::EnableWindow(framehwnd, FALSE);
      }
   }

   CDialog::OnInitDialog();

   CWnd* pwnd = GetDlgItem(IDC_LOG_FILE); //Raid #501886, yanggao, 12/03/2001
   if( pwnd )
   {
      pwnd->SendMessage(EM_LIMITTEXT, MAX_PATH, 0);
   }

   UpdateData(FALSE);
   if (m_strLogFile.IsEmpty()) {
      m_ctlOK.EnableWindow(FALSE);
   }

   m_strOriginalLogFile = m_strLogFile;

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CPerformAnalysis::OnChangeLogFile()
{
   UpdateData(TRUE);
   if (m_strLogFile.IsEmpty()) 
      m_ctlOK.EnableWindow(FALSE);
   else
      m_ctlOK.EnableWindow(TRUE);
   m_strError.Empty();
}


void CPerformAnalysis::OnCancel() {
//   CDialog::OnCancel();

   if( m_hPWnd ) //Raid #669945, yanggao, 8/9/2002
   {
      ::EnableWindow(m_hPWnd, TRUE);
   }

   m_strLogFile = m_strOriginalLogFile;
   DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\precdisp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precdisp.h
//
//  Contents:   definition of PrecedenceDisplay
//
//----------------------------------------------------------------------------
#ifndef PRECDISP_H
#define PRECDISP_H

#include "wmihooks.h"

class PrecedenceDisplay 
{
public:
   PrecedenceDisplay (LPTSTR GPOName, LPTSTR Value, ULONG Status, ULONG Error, LPTSTR Value2 = L"") :
      m_szGPO(GPOName),
      m_szValue(Value),
      m_uStatus(Status),
      m_uError(Error),
      m_szValue2(Value2)
   {
   }
   virtual ~PrecedenceDisplay() 
   {
   }

   CString m_szGPO;
   CString m_szValue;
   CString m_szValue2;
   ULONG m_uStatus;
   ULONG m_uError;
};

typedef PrecedenceDisplay *PPRECEDENCEDISPLAY;



#endif // PRECDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\precdisp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precdisp.cpp
//
//  Contents:   implementation of PRECEDENCEDISPLAY
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wmihooks.h"
#include "snapmgr.h"
#include "cookie.h"
#include "util.h"

vector<PPRECEDENCEDISPLAY>* CResult::GetPrecedenceDisplays() 
{
   if (m_pvecPrecedenceDisplays) 
      return m_pvecPrecedenceDisplays;

   switch(GetType()) 
   {
      case ITEM_PROF_BOOL:
      case ITEM_PROF_DW:
      case ITEM_PROF_SZ:
      case ITEM_PROF_RET:
      case ITEM_PROF_BON:
      case ITEM_PROF_B2ON:
         m_pvecPrecedenceDisplays = GetPolicyPrecedenceDisplays();
         break;

      case ITEM_PROF_REGVALUE:
         m_pvecPrecedenceDisplays = GetRegValuePrecedenceDisplays();
         break;

      case ITEM_PROF_PRIVS:
         m_pvecPrecedenceDisplays = GetPrivilegePrecedenceDisplays();
         break;

      case ITEM_PROF_GROUP:
         m_pvecPrecedenceDisplays = GetGroupPrecedenceDisplays();
         break;

      case ITEM_PROF_REGSD:
         m_pvecPrecedenceDisplays = GetRegistryPrecedenceDisplays();
         break;

      case ITEM_PROF_FILESD:
         m_pvecPrecedenceDisplays = GetFilePrecedenceDisplays();
         break;

      case ITEM_PROF_SERV:
         m_pvecPrecedenceDisplays = GetServicePrecedenceDisplays();
         break;

      default:
//         _ASSERT(0);
         break;
   }

   return m_pvecPrecedenceDisplays;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetPolicyPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;

      ASSERT(pspi);
      if (!pspi) 
         continue;

      LPTSTR szValue = NULL;
      LPTSTR szGPO = NULL;

#define HANDLE_PROFILE_CASE(Y,X) \
         case Y: { \
            if (pspi->X == SCE_NO_VALUE) \
               continue; \
            else { \
               szValue = NULL; \
               szGPO = NULL; \
               TranslateSettingToString(pspi->X, GetUnits(), GetType(), &szValue); \
               if (szValue) \
               { \
                  if (pspi->pRI##X && \
                      SUCCEEDED(pWMI->GetGPOFriendlyName(pspi->pRI##X->pszGPOID,&szGPO))) \
                  { \
                     ULONG uStatus = pspi->pRI##X->status; \
                     ULONG uError = pspi->pRI##X->error; \
                     ppd = new PrecedenceDisplay(szGPO, \
                                                 szValue, \
                                                 uStatus, \
                                                 uError); \
                     if (ppd) \
                        pvecDisplay->push_back(ppd); \
                     LocalFree(szGPO); \
                  } \
                  delete [] szValue; \
               } \
            } \
            break; \
        }

#define HANDLE_PROFILE_STRING_CASE(Y,X) \
         case Y: { \
            if (pspi->X == 0) {  \
               continue; \
            } else { \
               szGPO = NULL; \
               if (pspi->pRI##X && \
                   SUCCEEDED(pWMI->GetGPOFriendlyName(pspi->pRI##X->pszGPOID,&szGPO))) { \
                  ULONG uStatus = pspi->pRI##X->status; \
                  ULONG uError = pspi->pRI##X->error; \
                  ppd = new PrecedenceDisplay(szGPO, \
                                              pspi->X, \
                                              uStatus, \
                                              uError); \
                  if (ppd) \
                     pvecDisplay->push_back(ppd); \
                  LocalFree(szGPO); \
               } \
            } \
            break; \
        }

	LONG_PTR id = GetID ();
	switch (id) 
	{
      // L"Maximum passage age", L"Days"
      HANDLE_PROFILE_CASE(IDS_MAX_PAS_AGE,MaximumPasswordAge);

      // L"Minimum passage age", L"Days"
      HANDLE_PROFILE_CASE(IDS_MIN_PAS_AGE,MinimumPasswordAge);

      // L"Minimum passage length", L"Characters"
      HANDLE_PROFILE_CASE(IDS_MIN_PAS_LEN,MinimumPasswordLength);

      // L"Password history size", L"Passwords"
      HANDLE_PROFILE_CASE(IDS_PAS_UNIQUENESS,PasswordHistorySize);

      // L"Password complexity", L""
      HANDLE_PROFILE_CASE(IDS_PAS_COMPLEX,PasswordComplexity);

      // L"Clear Text Password", L""
      HANDLE_PROFILE_CASE(IDS_CLEAR_PASSWORD,ClearTextPassword);

      // L"Require logon to change password", L""
      HANDLE_PROFILE_CASE(IDS_REQ_LOGON,RequireLogonToChangePassword);

     // L"Account lockout count", L"Attempts"
     HANDLE_PROFILE_CASE(IDS_LOCK_COUNT,LockoutBadCount);

     // L"Reset lockout count after", L"Minutes"
     HANDLE_PROFILE_CASE(IDS_LOCK_RESET_COUNT,ResetLockoutCount);

     // L"Lockout duration", L"Minutes"
     HANDLE_PROFILE_CASE(IDS_LOCK_DURATION,LockoutDuration);

     // L"Audit system events"
     HANDLE_PROFILE_CASE(IDS_SYSTEM_EVENT,AuditSystemEvents);

     // L"Audit logon events"
     HANDLE_PROFILE_CASE(IDS_LOGON_EVENT,AuditLogonEvents);

     // L"Audit Object Access"
     HANDLE_PROFILE_CASE(IDS_OBJECT_ACCESS,AuditObjectAccess);

     // L"Audit Privilege Use"
     HANDLE_PROFILE_CASE(IDS_PRIVILEGE_USE,AuditPrivilegeUse);

     // L"Audit policy change"
     HANDLE_PROFILE_CASE(IDS_POLICY_CHANGE,AuditPolicyChange);

     // L"Audit Account Manage"
     HANDLE_PROFILE_CASE(IDS_ACCOUNT_MANAGE,AuditAccountManage);

     // L"Audit process tracking"
     HANDLE_PROFILE_CASE(IDS_PROCESS_TRACK,AuditProcessTracking);

     // L"Audit directory service access"
     HANDLE_PROFILE_CASE(IDS_DIRECTORY_ACCESS,AuditDSAccess);

     // L"Audit Account Logon"
     HANDLE_PROFILE_CASE(IDS_ACCOUNT_LOGON,AuditAccountLogon);

     // L"Force logoff when logon hour expire", L""
     HANDLE_PROFILE_CASE(IDS_FORCE_LOGOFF,ForceLogoffWhenHourExpire);

     // L"Network access: Allow anonymous SID/Name translation"
     HANDLE_PROFILE_CASE(IDS_LSA_ANON_LOOKUP,LSAAnonymousNameLookup);

     // L"Accounts: Administrator account status", L""
     HANDLE_PROFILE_CASE(IDS_ENABLE_ADMIN,EnableAdminAccount);

     // L"Accounts: Guest account status", L""
     HANDLE_PROFILE_CASE(IDS_ENABLE_GUEST,EnableGuestAccount);

      // "Maximum application log size"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_MAX, MaximumLogSize[2]); //Raid #493459, yanggao.

      // "Maximum security log size"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_MAX, MaximumLogSize[1]);

      // "Maximum system log size"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_MAX, MaximumLogSize[0]);

      // "Prevent local guests group from accessing application log"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_GUEST, RestrictGuestAccess[2]); //Raid #493459, yanggao.

      // "Prevent local guests group from accessing security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_GUEST, RestrictGuestAccess[1]);

      // "Prevent local guests group from accessing system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_GUEST, RestrictGuestAccess[0]);

      // "Retain application log"
      HANDLE_PROFILE_CASE(IDS_APP_LOG_DAYS, RetentionDays[2]); //Raid #493459, yanggao.

      // "Retain security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_DAYS, RetentionDays[1]);

      // "Retain system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_DAYS, RetentionDays[0]);

      // "Retention method for application log""
      HANDLE_PROFILE_CASE(IDS_APP_LOG_RET, AuditLogRetentionPeriod[EVENT_TYPE_APP]);

      // "Retention method for security log"
      HANDLE_PROFILE_CASE(IDS_SEC_LOG_RET , AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);

      // "Retention method for system log"
      HANDLE_PROFILE_CASE(IDS_SYS_LOG_RET, AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);

	  // "Accounts: Rename administrator account"
      HANDLE_PROFILE_STRING_CASE(IDS_NEW_ADMIN, NewAdministratorName);

      // "Accounts: Rename guest account"
      HANDLE_PROFILE_STRING_CASE(IDS_NEW_GUEST, NewGuestName);

   default:
//      _ASSERT (0);
      break;
      }
   }
#undef HANDLE_PROFILE_CASE
#undef HANDLE_PROFILE_STRING_CASE

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetGroupPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_GROUP_MEMBERSHIP pGroup = pspi->pGroupMembership;
      list<PRSOP_INFO>::iterator pRIGroup = pspi->listRIGroupMemebership.begin();
      while(pGroup) 
      {
         if (0 == lstrcmp(pGroup->GroupName,GetAttr())) 
         {
            //
            // found our group
            //
            LPTSTR szValue1 = NULL;
            LPTSTR szValue2 = NULL;
            LPTSTR szGPO = NULL;

            ConvertNameListToString(pGroup->pMembers,&szValue1);
            ConvertNameListToString(pGroup->pMemberOf,&szValue2);
            //
            // szValue1 & szValue2 may legitimately be NULL
            //
            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIGroup)->pszGPOID,&szGPO))) 
            {
               ULONG uError = (*pRIGroup)->error;
               ULONG uStatus = (*pRIGroup)->status;
               ppd = new PrecedenceDisplay(szGPO,
                                           szValue1,
                                           uStatus,
                                           uError,
                                           szValue2);
               if (ppd) 
                  pvecDisplay->push_back(ppd);

               LocalFree(szGPO);
            } 
            if (szValue1) 
               delete [] szValue1;
            if (szValue2) 
               delete [] szValue2;
            break;
         }
         pGroup = pGroup->Next;
         ++pRIGroup;
      }

   }
   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetPrivilegePrecedenceDisplays() 
{
    //
    // Get all of the RSOP info and loop through, collecting
    // the display info for the policy we care about.
    //
    CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
    ASSERT(pWMI);
    if (!pWMI)
        return NULL;
    
    vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
    if (!pvecDisplay)
        return NULL;
    
    PPRECEDENCEDISPLAY ppd = NULL;

    vector<PWMI_SCE_PROFILE_INFO> vecInfo;
    if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
    {
       delete pvecDisplay;
       return NULL;
    }

    if (GetID() <= 0)
    {
        return pvecDisplay;
    }

    PWSTR pName = ((PSCE_PRIVILEGE_ASSIGNMENT)GetID())->Name;

    if (NULL == pName)
    {
        return pvecDisplay;
    }

    for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
        i != vecInfo.end();
        ++i)
    {
        PWMI_SCE_PROFILE_INFO pspi = *i;
        //
        // Find this group in pspi
        //
        PSCE_PRIVILEGE_ASSIGNMENT pPriv = pspi->OtherInfo.smp.pPrivilegeAssignedTo;
        list<PRSOP_INFO>::iterator pRIPriv = pspi->listRIInfPrivilegeAssignedTo.begin();
        while (pPriv)
        {
            if (0 == lstrcmp(pPriv->Name, pName))
            {
                //
                // found our privilege
                //
                LPTSTR szValue = NULL;
                LPTSTR szGPO = NULL;

                ConvertNameListToString(pPriv->AssignedTo,&szValue);
                //
                // szValue may legitimately be NULL
                //
                if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIPriv)->pszGPOID,&szGPO))) 
                {
                   ULONG uStatus = (*pRIPriv)->status;
                   ULONG uError = (*pRIPriv)->error;
                   ppd = new PrecedenceDisplay(szGPO,
                                               szValue,
                                               uStatus,
                                               uError);
                   if (ppd)
                       pvecDisplay->push_back(ppd);

                   LocalFree(szGPO);
                } 
                 if (szValue) 
                    delete [] szValue;
                break;
            }

            pPriv = pPriv->Next;
            ++pRIPriv;
        }
    }

    return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetFilePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_OBJECT_ARRAY pFiles = pspi->pFiles.pAllNodes;
      if (pFiles) 
      {
         for(DWORD j=0;j<pFiles->Count;j++) 
         {
            if (0 == lstrcmp(pFiles->pObjectArray[j]->Name,GetAttr())) 
            {
               //
               // Found our file
               //

               //
               // Just get the GPO name.  Files don't have displayable settings
               //
               LPTSTR szGPO = NULL;

               vector<PRSOP_INFO>::reference pRIFiles = pspi->vecRIFiles[j];
               if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIFiles).pszGPOID,&szGPO))) 
               {
                  ULONG uStatus = (*pRIFiles).status;
                  ULONG uError = (*pRIFiles).error;
                  ppd = new PrecedenceDisplay(szGPO,
                                              L"",
                                              uStatus,
                                              uError);
                  if (ppd)
                     pvecDisplay->push_back(ppd);
               }
               break;
            }
         }
      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetRegistryPrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;
   
   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_OBJECT_ARRAY pRegistryKeys = pspi->pRegistryKeys.pAllNodes;
      if (pRegistryKeys) 
      {
         for(DWORD j=0;j<pRegistryKeys->Count;j++) 
         {
            if (0 == lstrcmp(pRegistryKeys->pObjectArray[j]->Name,GetAttr())) 
            {
               //
               // Found our RegistryKey
               //

               //
               // Just get the GPO name.  RegistryKeys don't have displayable settings
               //
               LPTSTR szGPO = NULL;

               vector<PRSOP_INFO>::reference pRIReg = pspi->vecRIReg[j];
               if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIReg).pszGPOID,&szGPO))) 
               {
                  ULONG uStatus = (*pRIReg).status;
                  ULONG uError = (*pRIReg).error;
                  ppd = new PrecedenceDisplay(szGPO,
                                              L"",
                                              uStatus,
                                              uError);
                  if (ppd) 
                     pvecDisplay->push_back(ppd);

                  LocalFree(szGPO);
               }
               break;
            }
         }

      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetServicePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      PSCE_SERVICES pServices = pspi->pServices;
      list<PRSOP_INFO>::iterator pRIServices = pspi->listRIServices.begin();
      while(pServices) 
      {
         if (0 == lstrcmp(pServices->ServiceName,GetUnits())) 
         {
            //
            // found our Servicesilege
            //
            LPTSTR szGPO = NULL;

            //
            // Just get the GPO name.  Services don't have displayable settings
            //
            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIServices)->pszGPOID,&szGPO))) 
            {
               ULONG uStatus = (*pRIServices)->status;
               ULONG uError = (*pRIServices)->error;
               ppd = new PrecedenceDisplay(szGPO,
                                           L"",
                                           uStatus,
                                           uError);
               if (ppd)
                  pvecDisplay->push_back(ppd);

               LocalFree(szGPO);
               szGPO = NULL;
            }
            break;
         }
         pServices = pServices->Next;
         ++pRIServices;
      }
   }

   return pvecDisplay;
}

vector<PPRECEDENCEDISPLAY>* CResult::GetRegValuePrecedenceDisplays() 
{
   //
   // Get all of the RSOP info and loop through, collecting
   // the display info for the policy we care about.
   //
   CWMIRsop *pWMI = m_pSnapin->GetWMIRsop();
   ASSERT(pWMI);
   if (!pWMI)
      return NULL;

   vector<PPRECEDENCEDISPLAY> *pvecDisplay = new vector<PPRECEDENCEDISPLAY>;
   if (!pvecDisplay)
      return NULL;
   
   PPRECEDENCEDISPLAY ppd = NULL;

   vector<PWMI_SCE_PROFILE_INFO> vecInfo;
   if (FAILED(pWMI->GetAllRSOPInfo(&vecInfo)))
   {
       delete pvecDisplay;
       return NULL;
   }

   for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo.begin();
       i != vecInfo.end();
       ++i ) 
   {
      PWMI_SCE_PROFILE_INFO pspi = *i;
      //
      // Find this group in pspi
      //
      for(DWORD j=0;j < pspi->RegValueCount;j++) 
      {
         if (0 == lstrcmp(pspi->aRegValues[j].FullValueName,((PSCE_REGISTRY_VALUE_INFO)GetBase())->FullValueName)) 
         {
            //
            // Found our Registry Value
            //
            LPTSTR pDisplayName=NULL;
            DWORD displayType = 0;
            LPTSTR szUnits=NULL;
            PREGCHOICE pChoices=NULL;
            PREGFLAGS pFlags=NULL;
            LPTSTR szValue = NULL;

            PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO) GetBase();
            if (LookupRegValueProperty(prv->FullValueName,
                                       &pDisplayName,
                                       &displayType,
                                       &szUnits,
                                       &pChoices,
                                       &pFlags) ) 
            {
               //
               // Determine string by the item value.
               //
               switch ( GetID() ) 
               {
                  case SCE_REG_DISPLAY_NUMBER:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(
                                                _wtol(prv->Value),
                                                GetUnits(),
                                                ITEM_DW,
                                                &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_CHOICE:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(_wtol(prv->Value),
                                                 NULL,
                                                 ITEM_REGCHOICE,
                                                 &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_FLAGS:
                     if ( prv->Value ) 
                     {
                        TranslateSettingToString(_wtol(prv->Value),
                                                 NULL,
                                                 ITEM_REGFLAGS,
                                                 &szValue);
                     }
                     break;

                  case SCE_REG_DISPLAY_MULTISZ:
                  case SCE_REG_DISPLAY_STRING:
                     if (prv && prv->Value) 
                     {
                        szValue = new TCHAR[lstrlen(prv->Value)+1];
                        if (szValue)
                           //This is a safe usage.
                           lstrcpy(szValue,prv->Value);
                     }
                     break;

                  default: // boolean
                     if ( prv->Value ) 
                     {
                        long val = _wtol(prv->Value);
                        TranslateSettingToString( val,
                                                  NULL,
                                                  ITEM_BOOL,
                                                  &szValue);
                     }
                     break;
               }
            }

            LPTSTR szGPO = NULL;
            vector<PRSOP_INFO>::reference pRIReg = pspi->vecRIRegValues[j];

            if (SUCCEEDED(pWMI->GetGPOFriendlyName((*pRIReg).pszGPOID,&szGPO))) 
            {
               ULONG uStatus = (*pRIReg).status;
               ULONG uError = (*pRIReg).error;
               ppd = new PrecedenceDisplay(szGPO,
                                           szValue,
                                           uStatus,
                                           uError);
               if (ppd) 
               {
                  pvecDisplay->push_back(ppd);
                  szGPO = NULL;
                  szValue = NULL;
               } 
            }

            if ( szGPO )
                LocalFree(szGPO);

            if ( szValue ) 
                delete [] szValue;
            //
            // no need to keep looking once we've found the one we're looking for
            //
            break;
         }
      }
   }

   return pvecDisplay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\precpage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precpage.cpp
//
//  Contents:   implementation of CPrecedencePage
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <secedit.h>
#include "wsecmgr.h"
#include "precpage.h"
#include "snapmgr.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define PRECEDENCE_STATUS_SUCCESS 1
#define PRECEDENCE_STATUS_NO_CONFIG 0
#define PRECEDENCE_STATUS_INVALID 2
#define PRECEDENCE_STATUS_ERROR 3
#define PRECEDENCE_STATUS_CHILD_ERROR 4

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage property page

IMPLEMENT_DYNCREATE(CPrecedencePage, CSelfDeletingPropertyPage)

CPrecedencePage::CPrecedencePage() : CSelfDeletingPropertyPage(IDD)
{
        //{{AFX_DATA_INIT(CPrecedencePage)
        m_strSuccess = _T("");
        m_strTitle = _T("");
        m_strError = _T("");
        //}}AFX_DATA_INIT

   m_pResult = NULL;
   m_pWMI = NULL;
   m_pHelpIDs = (DWORD_PTR)a239HelpIDs;
}

CPrecedencePage::~CPrecedencePage()
{
}

void CPrecedencePage::DoDataExchange(CDataExchange* pDX)
{
        CSelfDeletingPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPrecedencePage)
        DDX_Control(pDX, IDC_PRECEDENCE_LIST, m_PrecedenceList);
        DDX_Control(pDX, IDC_ERROR_ICON, m_iconError);
        DDX_Text(pDX, IDC_SUCCESS_TEXT, m_strSuccess);
        DDX_Text(pDX, IDC_TITLE, m_strTitle);
        DDX_Text(pDX, IDC_ERROR_TEXT, m_strError);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrecedencePage, CSelfDeletingPropertyPage)
        //{{AFX_MSG_MAP(CPrecedencePage)
        //}}AFX_MSG_MAP
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp) //Bug 139470, 4/19/2001
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage message handlers

BOOL CPrecedencePage::OnInitDialog()
{
   CSelfDeletingPropertyPage::OnInitDialog();

   CString strColumn;

#define COL_WIDTH 200

   strColumn.LoadString(IDS_PRECEDENCE_GPO_HEADER);
   m_PrecedenceList.InsertColumn(0,strColumn,LVCFMT_LEFT,COL_WIDTH,0);

   switch(m_pResult->GetType()) 
   {
      case ITEM_PROF_GROUP:
         //
         // Two value columns for groups
         //
         strColumn.LoadString(IDS_COL_MEMBERSHIP);
         m_PrecedenceList.InsertColumn(1,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         strColumn.LoadString(IDS_COL_MEMBEROF);
         m_PrecedenceList.InsertColumn(2,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         break;

      case ITEM_PROF_REGSD:
      case ITEM_PROF_FILESD:
      case ITEM_PROF_SERV:
         //
         // No value columns for files, reg keys, or services
         //
         break;

      default:
         //
         // One value column for everything else
         //
         strColumn.LoadString(IDS_PRECEDENCE_VALUE_HEADER);
         m_PrecedenceList.InsertColumn(1,strColumn,LVCFMT_LEFT,COL_WIDTH,1);
         break;
   }

   vector<PPRECEDENCEDISPLAY>* pvecDisplay = m_pResult->GetPrecedenceDisplays();
   ASSERT(pvecDisplay);
   if (!pvecDisplay || pvecDisplay->empty()) 
   {
      return TRUE;
   }

   int nItem = 0;
   for(vector<PPRECEDENCEDISPLAY>::iterator i = pvecDisplay->begin();
       i != pvecDisplay->end();
       ++i ) 
   {
      PPRECEDENCEDISPLAY ppd = *i;

      if ( ppd->m_szGPO.IsEmpty ()) 
      {
         ASSERT(!ppd->m_szGPO.IsEmpty ());
         continue;
      }

      //
      // CListCtrl will make a copy of the string passed in so
      // there is no point allocating buffer
      // (and not free it)
      //
      nItem = m_PrecedenceList.InsertItem (nItem,
                                         (PCWSTR) ppd->m_szGPO);

      if (nItem != -1) 
      {
         if ( !ppd->m_szValue.IsEmpty () ) 
         {
            m_PrecedenceList.SetItem(nItem,
                                 1,
                                 LVIF_TEXT,
                                 (PCWSTR) ppd->m_szValue,
                                 0,
                                 0,
                                 0,
                                 0);
         }
         if ( !ppd->m_szValue2.IsEmpty () ) 
         {
            m_PrecedenceList.SetItem(nItem,
                                 2,
                                 LVIF_TEXT,
                                 (PCWSTR) ppd->m_szValue2,
                                 0,
                                 0,
                                 0,
                                 0);
         }
      }
      nItem++;
   }

   vector<PPRECEDENCEDISPLAY>::reference ppd = pvecDisplay->front();
   if (ppd) 
   {
      if (ppd->m_uStatus == PRECEDENCE_STATUS_SUCCESS) 
      {
         GetDlgItem(IDC_ERROR_TEXT)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
         GetDlgItem(IDC_ERROR_ICON)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
      } 
      else 
      {
         GetDlgItem(IDC_SUCCESS_TEXT)->SetWindowPos(NULL,0,0,0,0,SWP_HIDEWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
      }

      CImageList il;
      HICON icon = NULL;
      il.Create(IDB_ICON16,16,1,RGB(255,0,255));
      if (ppd->m_uStatus != PRECEDENCE_STATUS_SUCCESS) 
      {
         icon = m_iconError.SetIcon(il.ExtractIcon(SCE_CRITICAL_IDX));
         if (icon) 
         {
            DestroyIcon(icon);
         }
      }
   }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CPrecedencePage::Initialize(CResult *pResult, CWMIRsop *pWMI) 
{
   m_pResult = pResult;
   m_pWMI = pWMI;

   vector<PPRECEDENCEDISPLAY>* pvecDisplay = m_pResult->GetPrecedenceDisplays();
   ASSERT(pvecDisplay);
   if (pvecDisplay && !pvecDisplay->empty()) 
   {
      vector<PPRECEDENCEDISPLAY>::reference ppd = pvecDisplay->front();
      if (ppd) 
      {
         switch (ppd->m_uStatus) 
         {
            case PRECEDENCE_STATUS_NO_CONFIG:
               m_strError.LoadString(IDS_PRECEDENCE_NO_CONFIG);
               break;

            case PRECEDENCE_STATUS_INVALID:
               AfxFormatString1 (m_strError, IDS_PRECEDENCE_INVALID,
                     (PCWSTR) ppd->m_szGPO);
               break;

            case PRECEDENCE_STATUS_ERROR: 
               {
                  CString strErr;
                  if (SCESTATUS_SUCCESS != FormatDBErrorMessage (ppd->m_uError,
                        NULL, strErr)) 
                  {
                     strErr.LoadString(IDS_UNKNOWN_ERROR);
                  }
                  AfxFormatString2 (m_strError, IDS_PRECEDENCE_ERROR, 
                        (PCWSTR) ppd->m_szGPO, strErr);
               }
               break;
               
            case PRECEDENCE_STATUS_SUCCESS:
               AfxFormatString1 (m_strSuccess, IDS_PRECEDENCE_SUCCESS, 
                     (PCWSTR) ppd->m_szGPO);
               break;

            case PRECEDENCE_STATUS_CHILD_ERROR:
               m_strError.LoadString(IDS_PRECEDENCE_CHILD_ERROR);
               break;

            default:
               break;
         }
      }
   }
}


BOOL CPrecedencePage::OnHelp(WPARAM wParam, LPARAM lParam) //Bug 316461, Yanggao, 3/14/2001
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        if(pHelpInfo->iCtrlId != -1)
            this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CPrecedencePage::DoContextHelp(HWND hWndControl) //Bug 316461, Yanggao, 3/14/2001
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetGpeditHelpFilename(),
            HELP_WM_HELP,
            m_pHelpIDs))
    {

    }
}

BOOL CPrecedencePage::OnContextHelp(WPARAM wParam, LPARAM lParam)
{
HMENU hMenu = CreatePopupMenu();

    if( hMenu )
    {
        CString str;
        str.LoadString(IDS_WHAT_ISTHIS); 
        if( AppendMenu(hMenu, MF_STRING, IDM_WHAT_ISTHIS, str) )
        {
            int itemID = TrackPopupMenu(hMenu, 
                                TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RETURNCMD|
                                TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                LOWORD(lParam), HIWORD(lParam), 0, (HWND)wParam, NULL);
            if( itemID == IDM_WHAT_ISTHIS ) //Raid #139470, 4/11/2001
            {
                if( ((HWND)wParam) != this->m_hWnd )
                {
                    ::WinHelp((HWND)wParam,
                        GetGpeditHelpFilename(),
                        HELP_WM_HELP,
                        m_pHelpIDs);
                }
                else
                {
                    POINT pos;
                    pos.x = LOWORD(lParam);
                    pos.y = HIWORD(lParam);
                    ScreenToClient( &pos );
                    CWnd* pWnd = ChildWindowFromPoint(pos, CWP_SKIPINVISIBLE);
                    if( pWnd )
                    {
				        ::WinHelp(pWnd->m_hWnd,
                            GetGpeditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                    else
                    {
                        ::WinHelp((HWND)wParam,
                            GetGpeditHelpFilename(),
                            HELP_WM_HELP,
                            m_pHelpIDs);
                    }
                }
            }
        }
    }
	return TRUE;
}

//********************************************************************
//Get the image icon for the result item, based on where the status of
//RSOP result item.
//********************************************************************
int GetRSOPImageIndex(int nImage, CResult* pResult)
{
   if ( !pResult )
   {
      return nImage;
   }

   vector<PPRECEDENCEDISPLAY>* vppd = pResult->GetPrecedenceDisplays();
   if (vppd && !vppd->empty()) 
   {
      PPRECEDENCEDISPLAY ppd = vppd->front();
      if( ppd && ppd->m_uStatus != PRECEDENCE_STATUS_SUCCESS )
      {
         return SCE_CRITICAL_IDX;
      }
   }

   return nImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\profdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       profdesc.cpp
//
//  Contents:   implementation of CSetProfileDescription
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "cookie.h"
#include "snapmgr.h"
#include "profdesc.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription dialog


CSetProfileDescription::CSetProfileDescription()
: CHelpDialog(a218HelpIDs, IDD, 0)
{
   //{{AFX_DATA_INIT(CSetProfileDescription)
   m_strDesc = _T("");
   //}}AFX_DATA_INIT
}


void CSetProfileDescription::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSetProfileDescription)
   DDX_Text(pDX, IDC_DESCRIPTION, m_strDesc);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetProfileDescription, CHelpDialog)
    //{{AFX_MSG_MAP(CSetProfileDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription message handlers

void CSetProfileDescription::OnOK()
{
   UpdateData(TRUE);

   //
   // empty the description section first.
   //

   CEditTemplate *pet;
   LPCTSTR szInfFile;

   if( !m_strDesc.IsEmpty() ) //Raid #482845, Yanggao
   {
      m_strDesc.Replace(L"\r\n", NULL);
   }

   PCWSTR szInvalidCharSet = INVALID_DESC_CHARS; //Raid 481533, yanggao, 11/27/2001
   if( m_strDesc.FindOneOf(szInvalidCharSet) != -1 )
   {
      CString text;
      text.FormatMessage (IDS_INVALID_DESC, szInvalidCharSet);
      AfxMessageBox(text);
      GetDlgItem(IDC_DESCRIPTION)->SetFocus(); 
      return;
   }

   szInfFile = m_pFolder->GetInfFile();
   if (szInfFile) {
      pet = m_pCDI->GetTemplate(szInfFile);
      pet->SetDescription(m_strDesc);
      pet->Save(); //Raid #453581, Yang Gao, 8/10/2001
   }
   m_pFolder->SetDesc(m_strDesc);
   DestroyWindow();
}

void CSetProfileDescription::OnCancel()
{
   DestroyWindow();
}

BOOL CSetProfileDescription::OnInitDialog()
{
   CDialog::OnInitDialog();

   GetDlgItem(IDC_DESCRIPTION)->SendMessage(EM_LIMITTEXT, MAX_PATH, 0); //Raid #525155, Yanggao, 4/1/2002

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\precpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       precpage.h
//
//  Contents:   definition of CPrecedencePage
//
//----------------------------------------------------------------------------
#if !defined(AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_)
#define AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cookie.h"
#include "wmihooks.h"
#include "SelfDeletingPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPrecedencePage dialog

class CPrecedencePage : public CSelfDeletingPropertyPage
{
	DECLARE_DYNCREATE(CPrecedencePage)

// Construction
public:
	CPrecedencePage();
	virtual ~CPrecedencePage();

   virtual void SetTitle(LPCTSTR sz) { m_strTitle = sz; };
   virtual void Initialize(CResult *pResult,CWMIRsop *pWMI);

// Dialog Data
	//{{AFX_DATA(CPrecedencePage)
	enum { IDD = IDD_PRECEDENCE };
	CListCtrl	m_PrecedenceList;
	CStatic	m_iconError;
	CString	m_strSuccess;
	CString	m_strTitle;
	CString	m_strError;
	//}}AFX_DATA



// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPrecedencePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DWORD_PTR m_pHelpIDs;
	void DoContextHelp(HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CPrecedencePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg	BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
   CResult *m_pResult;
   CWMIRsop *m_pWMI;
};

int GetRSOPImageIndex(int nImage, CResult* pResult);
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRECPAGE_H__CE5002B0_6D67_4DB3_98C9_17D31A493E85__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\profdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       profdesc.h
//
//  Contents:   definition of CSetProfileDescription
//
//----------------------------------------------------------------------------
#if !defined(AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
#define AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSetProfileDescription dialog

class CSetProfileDescription : public CHelpDialog
{
// Construction
public:
    CSetProfileDescription();   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSetProfileDescription)
    enum { IDD = IDD_SET_DESCRIPTION };
    CString  m_strDesc;
    //}}AFX_DATA

    void Initialize(CFolder *pFolder,CComponentDataImpl *pCDI) {
        m_pFolder = pFolder; m_pCDI = pCDI;
    }
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSetProfileDescription)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSetProfileDescription)
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CFolder *m_pFolder;
    CComponentDataImpl *m_pCDI;
};

//{{AFX_INSERT_Profile}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETProfileDESCRIPTION_H__2AD86C99_F660_11D1_AB9A_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\regdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regdlg.cpp
//
//  Contents:   implementation of CRegistryDialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "util.h"
#include "servperm.h"
#include "addobj.h"
#include "RegDlg.h"

#include <accctrl.h>
#include <aclapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#define MAX_REGKEY 256
/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog dialog


CRegistryDialog::CRegistryDialog()
: CHelpDialog(a177HelpIDs, IDD, 0)
{
    //{{AFX_DATA_INIT(CRegistryDialog)
    m_strReg = _T("");
    //}}AFX_DATA_INIT

   m_pConsole = NULL;
   m_pTemplate = NULL;
   m_dbHandle = NULL;
   m_cookie = 0;
   m_pIl = NULL;
   m_pDataObj = NULL;
   m_bNoUpdate = FALSE;
}

void CRegistryDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRegistryDialog)
    DDX_Control(pDX, IDC_REGTREE, m_tcReg);
    DDX_Text(pDX, IDC_REGKEY, m_strReg);
    //}}AFX_DATA_MAP
}

/*-------------------------------------------------------------------------------------------
    Method:     CreateKeyInfo

    Synopsis:   Create a new TI_KEYINFO structure and optionaly set its members

    Arguments:  [hKey]      - Optional value to set the hKey member of TI_KEYINFO
                                default is zero
                [Enum]      - Optional value to set the Enum member of TI_KEYINFO
                                default is zero
    Returns:    a LPTI_KEYINFO pointer
---------------------------------------------------------------------------------------------*/
LPTI_KEYINFO CRegistryDialog::CreateKeyInfo(HKEY hKey, bool Enum)
{

    LPTI_KEYINFO pInfo = NULL;
    pInfo = new TI_KEYINFO;

    if(pInfo){
        pInfo->hKey = hKey;
        pInfo->Enum = Enum;
    }
    return pInfo;
}

/*-------------------------------------------------------------------------------------------
    Method:     IsValidRegPath

    Synopsis:   Returns true if strReg path.  We can't assume that this
                HKEY exists in the current registry.  We will only make
                sure that the root node exists and each string in
                between '\'s isn't blank.

    Arguments:  [strReg]    - A string represending a registry path
                                subkeys are seperated by '\'s

    Returns:    TRUE if strReg is a valid path.
---------------------------------------------------------------------------------------------*/
BOOL CRegistryDialog::IsValidRegPath(LPCTSTR strReg)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    if(!strReg) return FALSE;

    int iStr = 0;           // Current position in strReg
    CString strCheck;       // String to check
    LPTI_KEYINFO pkInfo;    // Tree item key info.

    //
    // Find which root node this registry value is in.
    //

    while(strReg[iStr] && strReg[iStr] != _T('\\')) iStr++;
    strCheck = strReg;
    strCheck = strCheck.Left(iStr);
    strCheck.MakeUpper();

    // Get the HKEY value from the tree ctrl
    HTREEITEM hTi = m_tcReg.GetRootItem();
    while(hTi){
        if(m_tcReg.GetItemText(hTi) == strCheck)
            break;

        hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
    }
    if(hTi == NULL) return FALSE;

    // Get TI_KEYINFO for this root node
    pkInfo = (LPTI_KEYINFO)m_tcReg.GetItemData(hTi);

    // This value should never be NULL.
    if(!pkInfo){
        TRACE(TEXT("Tree item TI_KEYINFO is NULL for root node '%s'"), (LPCTSTR)strCheck);
        return FALSE;
    }

    //
    // Check the rest of the string to make sure that string's
    //  in between '\'s aren't blank
    //
    while(strReg[iStr]){

        // Check to make sure that the string item before
        //  and after the '\' aren't spaces.
        if(strReg[iStr] == _T('\\')){
            if( strReg[iStr + 1] == _T(' ') ||
                strReg[iStr + 1] == _T('\t') ||
                //strReg[iStr + 1] == 0 ||

                iStr > 0 &&
                (
                  strReg[iStr - 1] == _T(' ') ||
                  strReg[iStr - 1] == _T('\t')
                )
               )
                return FALSE;
        }
        iStr++;
    }

    return TRUE;
}


/*-------------------------------------------------------------------------------------------
    Method:     MakePathVisible

    Synopsis:
    Arguments:  [strReg]    - A string represending a registry path
                                subkeys are seperated by '\'s

    Returns:    TRUE if strReg is a valid path.
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::MakePathVisible(LPCTSTR strReg)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    if(!strReg) return;

    int iStr = 0;           // Current position in strReg
    CString strCheck;       // String to check
    LPTI_KEYINFO pkInfo;    // Tree item key info.

    //
    // Find which root node this registry value is in.
    //

    while(strReg[iStr] && strReg[iStr] != _T('\\')) iStr++;
    strCheck = strReg;
    strCheck = strCheck.Left(iStr);
    strCheck.MakeUpper();

    // Get the HKEY value from the tree ctrl
    HTREEITEM hTi = m_tcReg.GetRootItem();
    while(hTi){
        if(m_tcReg.GetItemText(hTi) == strCheck)
            break;

        hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
    }
    if(hTi == NULL) return;

    // Get TI_KEYINFO for this root node
    pkInfo = (LPTI_KEYINFO)m_tcReg.GetItemData(hTi);

    // This value should never be NULL.
    if(!pkInfo){
        TRACE(TEXT("Tree item TI_KEYINFO is NULL for root node '%s'"), (LPCTSTR)strCheck);
        return;
    }

    //
    // Step through each sub item to see if it exists in the tree control
    //
    int iBegin = iStr + 1;
    int iNotFound = -1;

    while(strReg[iStr] && hTi){
        iStr++;
        if(strReg[iStr] == _T('\\') || strReg[iStr] == 0){
            CString strItem;
            //
            // Make sure we have tree items we can use.
            //
            EnumerateChildren(hTi);

            if(strReg[iStr] == 0 && strReg[iStr - 1] == _T('\\'))
                m_tcReg.Expand(hTi, TVE_EXPAND);

            //
            // Parse out the subkeys name.
            strCheck = strReg;
            strCheck = strCheck.Mid(iBegin, iStr - iBegin);

            strCheck.MakeUpper();
            iBegin = iStr + 1;

            //
            // Find child item with this name.
            //

            hTi = m_tcReg.GetNextItem(hTi, TVGN_CHILD);
            while(hTi){
                strItem = m_tcReg.GetItemText(hTi);
                strItem.MakeUpper();

                iNotFound = lstrcmpiW(strItem, strCheck);
                if(iNotFound >= 0)
                    break;

                hTi = m_tcReg.GetNextItem(hTi, TVGN_NEXT);
            }
            if(strReg[iStr] != 0 && iNotFound != 0){
                hTi = NULL;
                break;
            }
        }
    }

    //
    // Select and ensure visibility if the path was found
    //
    if(hTi){
        if(strReg[iStr - 1] != _T('\\'))
            m_tcReg.Expand(hTi, TVE_COLLAPSE);
        if(!iNotFound){
            m_tcReg.SelectItem(hTi);
        }

        m_tcReg.EnsureVisible(hTi);
    }

}

/*-------------------------------------------------------------------------------------------
    Method:     EnumerateChildren

    Synopsis:   Enumerates a HKEY subkey and places them as children of 'hParent'

    Arguments:  [hParent]   - HTREEITEM to enumerate.

    Returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::EnumerateChildren(HTREEITEM hParent)
{
    ASSERT(this);
    ASSERT(m_tcReg);

    //
    // We won't enumerate for the root.
    //
    if(!hParent || hParent == TVI_ROOT) return;

    LPTI_KEYINFO hkeyParent;    // Used if the item being expanded has an invalid HKEY value
    LPTI_KEYINFO hkeyThis;      // HKEY value of item expanding
    int n = 0;                  // Counter
    LPTSTR szName;              // Used to acquire the name of a HKEY item
    DWORD cchName;              // Buffer size of szName
    HTREEITEM hti;
    TV_INSERTSTRUCT tvii;
    TV_ITEM tviNew;             // Expanding tree item
    TV_ITEM tvi;                // Used to add children to the expanding HTREEITEM


    // pNMTreeView->itemNew is the TV_ITEM we're expanding.
    hkeyThis = (LPTI_KEYINFO)m_tcReg.GetItemData(hParent);

    // Exit if we have an invalid pointer.
    if(!hkeyThis) return;

    //
    //  Allocate buffer for HKEY name
    //
    szName = new TCHAR [MAX_REGKEY]; //Raid #613152, yanggao
    if(!szName) return;
    cchName = MAX_REGKEY;

    //
    // Get item text
    //
    ZeroMemory(&tviNew,sizeof(tviNew));
    tviNew.hItem = hParent;
    tviNew.mask = TVIF_TEXT;
    tviNew.pszText = szName;
    tviNew.cchTextMax = cchName;
    m_tcReg.GetItem(&tviNew);

    //
    // Do we have an invalid HKEY value?
    //
    if (!hkeyThis->hKey) {

        // Get HKEY value of parent
        hti = m_tcReg.GetParentItem(hParent);
        ZeroMemory(&tvi,sizeof(tvi));
        tvi.hItem = hti;
        tvi.mask = TVIF_PARAM;
        m_tcReg.GetItem(&tvi);
        hkeyParent = (LPTI_KEYINFO)tvi.lParam;

        if(!hkeyParent){
            TRACE(TEXT("Parent of %s has an does not have a valid TI_KEYINFO struct"), (LPCTSTR)tviNew.pszText);
            delete [] szName;
            return;
        }

        //
        // If we can't open this key then set the parent item
        //  to have no children.
        // This is not a safe usage. Change KEY_ALL_ACCESS. Raid #555894, yanggao.
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyParent->hKey,tviNew.pszText,0,KEY_READ,&(hkeyThis->hKey))) {
            tvi.mask = TVIF_CHILDREN;
            tvi.cChildren = 0;
            m_tcReg.SetItem(&tvi);

            delete [] szName;
            return;
        }
        //
        // Set the HKEY value for the item
        //
        tvi.hItem = hParent;
        tvi.lParam = (LPARAM) hkeyThis;
        m_tcReg.SetItem(&tvi);
    }

    //
    // Don't do anything if this item has already been enumerated or
    //  does not have a valid TI_KEYINFO structure
    //
    if( !hkeyThis->Enum ){
        hkeyThis->Enum = true;

        DWORD cSubKeys;             // Used when quering for number of children.
        HKEY hKey;                  // Used To querry sub keys.

        //
        // Prepare the TV_INSERTSTRUCT
        //
        ZeroMemory(&tvii, sizeof(TV_INSERTSTRUCT));
        tvii.hParent = hParent;
        tvii.hInsertAfter = TVI_LAST;
        tvii.item.mask = TVIF_CHILDREN | TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvii.item.cChildren = 0;
        tvii.item.iImage = CONFIG_REG_IDX;
        tvii.item.iSelectedImage = CONFIG_REG_IDX;

        //
        // Add subkeys
        //
        while(ERROR_SUCCESS == RegEnumKeyEx(hkeyThis->hKey,n++, szName,&cchName,NULL,NULL,0,NULL)) {

            // Open the key so we can query it for the count of children
            // This is not a safe usage. Change KEY_ALL_ACCESS. Raid #555894, yanggao.
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyThis->hKey, szName, 0, KEY_READ, &(hKey))) {
                if(ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
                    tvii.item.cChildren = cSubKeys;
                RegCloseKey(hKey);
            }
            else
                tvii.item.cChildren = 0;

            tvii.item.cchTextMax = cchName;
            tvii.item.pszText = szName;
            tvii.item.lParam = (LPARAM)CreateKeyInfo(0, false);

            m_tcReg.InsertItem(&tvii);
            cchName = MAX_REGKEY;
        }

        //
        // Sort children
        //
        m_tcReg.SortChildren(hParent);
    }

    delete [] szName;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetProfileInfo

    Synopsis:   Sets either m_pTemplate;

    Arguments:  [pspi]      - the PEDITTEMPLATE to save the results in
                [ft]        - Type of pointer 'pspi' is (unused)
    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetProfileInfo(PEDITTEMPLATE pspi, FOLDER_TYPES ft)
{
   m_pTemplate = (PEDITTEMPLATE)pspi;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetConsole

    Synopsis:   Sets class variable 'm_pConsole'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetConsole(LPCONSOLE pConsole)
{
   m_pConsole = pConsole;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetComponentData

    Synopsis:   Sets class varaible 'm_pComponentData'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetComponentData(CComponentDataImpl *pComponentData)
{
   m_pComponentData = pComponentData;
}

/*-------------------------------------------------------------------------------------------
    Method:     SetCookie

    Synopsis:   Sets class variable 'm_cookie'

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::SetCookie(MMC_COOKIE cookie)
{
   m_cookie = cookie;
}


BEGIN_MESSAGE_MAP(CRegistryDialog, CHelpDialog)
    //{{AFX_MSG_MAP(CRegistryDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_REGTREE, OnItemexpandingRegtree)
    ON_NOTIFY(TVN_DELETEITEM, IDC_REGTREE, OnDeleteitemRegtree)
    ON_NOTIFY(TVN_SELCHANGED, IDC_REGTREE, OnSelchangedRegtree)
    ON_EN_CHANGE(IDC_REGKEY, OnChangeRegkey)
    ON_EN_SETFOCUS(IDC_REGKEY, OnSetFocus)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog message handlers

/*-------------------------------------------------------------------------------------------
    Method:     OnOK

    Synopsis:   Message handler for the IDOK button,

    **BUG**     Creating the new configuration item should happen outside of
                the dialog.

    Returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnOK()
{
   UpdateData(TRUE);


   if (!m_strReg.IsEmpty()) {

      int nCont=0;
      CFolder *pFolder = (CFolder *)m_cookie;

      if ( m_cookie && AREA_REGISTRY_ANALYSIS == pFolder->GetType() ) {
         //
         // add a key to analysis area
         //
         if ( m_dbHandle ) {
            nCont = 1;
         }

      } else if ( m_pTemplate && m_pTemplate->pTemplate ) {

         nCont = 2;
         //
         // if no object is in the buffer, create it with count = 0
         // this buffer will be freed when the template is freed
         //
         if ( !m_pTemplate->pTemplate->pRegistryKeys.pAllNodes ) {

            PSCE_OBJECT_ARRAY pTemp = (PSCE_OBJECT_ARRAY)LocalAlloc(0, sizeof(SCE_OBJECT_ARRAY));
            if ( pTemp ) {
               pTemp->Count = 0;
               pTemp->pObjectArray = NULL;
               m_pTemplate->pTemplate->pRegistryKeys.pAllNodes = pTemp;
            } else
               nCont = 0;
         }
         else
         {
            //Raid #477628, yanggao
            //Make sure this key isn't already in the list:
            PSCE_OBJECT_ARRAY poa;
            unsigned int i;

            poa = m_pTemplate->pTemplate->pRegistryKeys.pAllNodes;

            for (i=0;i < poa->Count;i++)
            {
               if (lstrcmpi(poa->pObjectArray[i]->Name,m_strReg) == 0)
               {
                  CDialog::OnOK();
                  return;
               }
            }
         }
      }

      HRESULT hr=E_FAIL;

      if ( nCont ) {
         PSECURITY_DESCRIPTOR pSelSD=NULL;
         SECURITY_INFORMATION SelSeInfo = 0;
         BYTE ConfigStatus = 0;

         if (m_pComponentData) {
            if ( m_pComponentData->GetAddObjectSecurity(
                                                       GetSafeHwnd(),
                                                       m_strReg,
                                                       TRUE,
                                                       SE_REGISTRY_KEY,
                                                       pSelSD,
                                                       SelSeInfo,
                                                       ConfigStatus
                                                       ) == E_FAIL ) {
               return;
            }
         } else {
            return;
         }

         hr = S_OK;

         if ( pSelSD && SelSeInfo ) {

            if ( 1 == nCont ) {
               //
               // add to the engine directly
               //
               SCESTATUS sceStatus=SCESTATUS_SUCCESS;
               BYTE AnalStatus;

               //
               // start the transaction if it's not started
               //
               if ( m_pComponentData->EngineTransactionStarted() ) {

                  sceStatus =  SceUpdateObjectInfo(
                                                  m_dbHandle,
                                                  AREA_REGISTRY_SECURITY,
                                                  (LPTSTR)(LPCTSTR)m_strReg,
                                                  m_strReg.GetLength(), // number of characters
                                                  ConfigStatus,
                                                  TRUE,
                                                  pSelSD,
                                                  SelSeInfo,
                                                  &AnalStatus
                                                  );
                  if ( SCESTATUS_SUCCESS == sceStatus ) {

                     hr = m_pComponentData->UpdateScopeResultObject(m_pDataObj,
                                                                    m_cookie,
                                                                    AREA_REGISTRY_SECURITY);

                     m_pTemplate->SetDirty(AREA_REGISTRY_SECURITY);

                  }
               } else {
                  //
                  // can't start transaction
                  //
                  hr = E_FAIL;
               }

            } else {
               //
               // add to configuration template
               //

               PSCE_OBJECT_ARRAY poa;
               unsigned int i;

               poa = m_pTemplate->pTemplate->pRegistryKeys.pAllNodes;

               PSCE_OBJECT_SECURITY *pCopy;

               // For some reason the LocalReAlloc version of this keeps giving out of memory
               // errors, but allocing & copying everything works fine.
               pCopy = (PSCE_OBJECT_SECURITY *)LocalAlloc(LPTR,(poa->Count+1)*sizeof(PSCE_OBJECT_SECURITY));
               if (pCopy) {

                  for (i=0; i<poa->Count; i++) {
                     pCopy[i] = poa->pObjectArray[i];
                  }

                  pCopy[poa->Count] = (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
                  if ( pCopy[poa->Count] ) {
                     pCopy[poa->Count]->Name = (PWSTR) LocalAlloc(LPTR,(m_strReg.GetLength()+1)*sizeof(TCHAR));

                     if ( pCopy[poa->Count]->Name ) {
                        //This may not be a safe usage. pCopy[poa->Count]->Name is PWSTR. Consider fix.
                        lstrcpy(pCopy[poa->Count]->Name,m_strReg);
                        pCopy[poa->Count]->pSecurityDescriptor = pSelSD;
                        pCopy[poa->Count]->SeInfo = SelSeInfo;
                        pCopy[poa->Count]->Status = ConfigStatus;
                        pCopy[poa->Count]->IsContainer = TRUE;

                        pSelSD = NULL;

                        poa->Count++;

                        if ( poa->pObjectArray ) {
                           LocalFree(poa->pObjectArray);
                        }
                        poa->pObjectArray = pCopy;

                        m_pTemplate->SetDirty(AREA_REGISTRY_SECURITY);

                        ((CFolder *)m_cookie)->RemoveAllResultItems();
                        m_pConsole->UpdateAllViews(NULL ,m_cookie, UAV_RESULTITEM_UPDATEALL);

                        hr = S_OK;

                     } else {
                        LocalFree(pCopy[poa->Count]);
                        LocalFree(pCopy);
                     }
                  } else
                     LocalFree(pCopy);
               }
            }
            if ( pSelSD ) {
               LocalFree(pSelSD);
            }
         }
      }

      if ( FAILED(hr) ) {
         CString str;
         str.LoadString(IDS_CANT_ADD_KEY);
         AfxMessageBox(str);
      }
   }

   CDialog::OnOK();
}

/*-------------------------------------------------------------------------------------------
    Method:     OnInitDialog

    Synopsis:   Create root HKEY entries HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT,
                and HKEY_USERS in the tree control.

    Returns:    return TRUE
---------------------------------------------------------------------------------------------*/
BOOL CRegistryDialog::OnInitDialog()
{
    CString strRegKeyName;          // Used to load string resources
                                    //  for name of the HTREEITEM
    HTREEITEM hti;
    TV_INSERTSTRUCT tvi;

    CDialog::OnInitDialog();

    //
    // Create image list for tree control
    //
    CThemeContextActivator activator; //Bug 424909, Yanggao, 6/29/2001
    m_pIl.Create(IDB_ICON16,16,1,RGB(255,0,255));
    m_tcReg.SetImageList (CImageList::FromHandle (m_pIl), TVSIL_NORMAL);

    //
    // Add Root HKEY items.
    //
    ZeroMemory(&tvi,sizeof(tvi));
    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_CHILDREN | TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.item.cChildren = 1;         // Initial UI +
    tvi.item.iImage = CONFIG_REG_IDX;
    tvi.item.iSelectedImage = CONFIG_REG_IDX;

    // Insert HKEY_CLASSES_ROOT
    strRegKeyName.LoadString(IDS_HKCR);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_CLASSES_ROOT, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Insert HKEY_LOCAL_MACHINE
    strRegKeyName.LoadString(IDS_HKLM);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_LOCAL_MACHINE, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Insert HKEY_USERS
    strRegKeyName.LoadString(IDS_HKU);
    tvi.item.cchTextMax = strRegKeyName.GetLength()+1;
    tvi.item.pszText = strRegKeyName.LockBuffer();
    tvi.item.lParam = (LPARAM)CreateKeyInfo(HKEY_USERS, false);
    hti = m_tcReg.InsertItem(&tvi);
    strRegKeyName.UnlockBuffer();

    // Sort the tree control
    m_tcReg.SortChildren(NULL);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/*-------------------------------------------------------------------------------------------
    Method:     OnItemexpandingRegtree

    Synopsis:   MFC OnNotify TVN_ITEMEXPANDING message handler. The lParam member of
                the HTREEITEM is a pointer to a TI_KEYINFO structure.  When
                a tree item is expanded for the first time, we must enumerate all
                its children. The function will set the TI_KEYINFO.Enum = true after
                enumeration.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnItemexpandingRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    *pResult = 0;
    EnumerateChildren(pNMTreeView->itemNew.hItem);
}

/*-------------------------------------------------------------------------------------------
    Method:     OnDeleteitemRegtree

    Synopsis:   MFC OnNotify TVN_DELETEITEM message handler.  Delete the TI_KEYINFO
                structure associated with 'itemOld' and close
                the regestry key.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnDeleteitemRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    LPTI_KEYINFO pInfo = (LPTI_KEYINFO)pNMTreeView->itemOld.lParam;
    if(pInfo){

        // Close registry key
        if(pInfo->hKey && (INT_PTR)(pInfo->hKey) != -1)
            RegCloseKey(pInfo->hKey);

        // delete the TI_KEYINFO
        delete pInfo;
    }
    *pResult = 0;
}

/*-------------------------------------------------------------------------------------------
    Method:     ~CRegistryDialog

    Synopsis:   Release memory used by this class

    returns:    void
---------------------------------------------------------------------------------------------*/
CRegistryDialog::~CRegistryDialog()
{
   m_pIl.Destroy(); //Bug 424909, Yanggao, 6/29/2001
}

/*-------------------------------------------------------------------------------------------
    Method:     OnSelchangedRegtree

    Synopsis:   MFC OnNotify TVN_SELCHANGED message handler.  Updates 'm_strReg' to
                the full path of the HKEY item

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnSelchangedRegtree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    *pResult = 0;

    //
    // Sometime we don't want to be updated.
    //
    if(m_bNoUpdate) return;

    TV_ITEM tvi;        // Used to get information about tree items

    CString strSel;     // Used to build the path to the selected item
    LPTSTR szBuf;       // Name of tree item
    DWORD cchBuf;       // size of szBuf

    cchBuf = 500;
    szBuf = new TCHAR [ cchBuf ];
    if(!szBuf) return;

    // Get the selected items text
    tvi.hItem = pNMTreeView->itemNew.hItem;
    tvi.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.pszText = szBuf;
    tvi.cchTextMax = cchBuf;
    if( tvi.hItem ) //Raid #473800, Yanggao
    {
        m_tcReg.GetItem(&tvi);

        strSel = tvi.pszText;

        // Retrieve text of all parent items.
        while(tvi.hItem = m_tcReg.GetParentItem(tvi.hItem)) {
            m_tcReg.GetItem(&tvi);
            strSel = L"\\" + strSel;
            strSel = tvi.pszText + strSel;
        }

        m_strReg = strSel;
        UpdateData(FALSE);
    
        // Enable the OK button
        if(GetDlgItem(IDOK)) GetDlgItem(IDOK)->EnableWindow(TRUE);
    }
    delete[] szBuf;
}

/*-------------------------------------------------------------------------------------------
    Method:     OnChangeRegkey

    Synopsis:   IDC_REGKEY edit control EN_CHANGE handler.

    returns:    void
---------------------------------------------------------------------------------------------*/
void CRegistryDialog::OnChangeRegkey()
{
    UpdateData(TRUE);

    if(IsValidRegPath(m_strReg) && GetDlgItem(IDOK)) {
        GetDlgItem(IDOK)->EnableWindow(TRUE);

        m_bNoUpdate = TRUE;
        MakePathVisible(m_strReg);
        m_bNoUpdate = FALSE;
    }
    else {
        HTREEITEM hItem = m_tcReg.GetSelectedItem(); //Raid #473800, Yanggao
        if( hItem == NULL )
        {
            GetDlgItem(IDOK)->EnableWindow(FALSE);
        }
    }
}

void CRegistryDialog::OnSetFocus() //Raid #473800, Yanggao
{
    HTREEITEM hItem = m_tcReg.GetSelectedItem();
    if( hItem != NULL )
    {
        m_tcReg.SelectItem(NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\regvalue.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "snapmgr.h"
#include "util.h"
#include "regvldlg.h"
//#include <shlwapi.h>
//#include <shlwapip.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long GetRegValueItemID(LPCWSTR szItem) //Raid #510407, 2/24/2002, yanggao
{
   long itemID = 0;
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\NTDS\\Parameters\\LDAPServerIntegrity") == 0 )
   {
      itemID = IDS_LDAPSERVERINTEGRITY;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\SignSecureChannel") == 0 )
   {
      itemID = IDS_SIGNSECURECHANNEL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\SealSecureChannel") == 0 )
   {
      itemID = IDS_SEALSECURECHANNEL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RequireStrongKey") == 0 )
   {
      itemID = IDS_REQUIRESTRONGKEY;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RequireSignOrSeal") == 0 )
   {
      itemID = IDS_REQUIRESIGNORSEAL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RefusePasswordChange") == 0 )
   {
      itemID = IDS_REFUSEPASSWORDCHANGE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\MaximumPasswordAge") == 0 )
   {
      itemID = IDS_MAXIMUMPASSWORDAGE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\DisablePasswordChange") == 0 )
   {
      itemID = IDS_DISABLEPASSWORDCHANGE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LDAP\\LDAPClientIntegrity") == 0 )
   {
      itemID = IDS_LDAPCLIENTINTEGRITY;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\RequireSecuritySignature") == 0 )
   {
      itemID = IDS_REQUIRESECURITYSIGNATURE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\EnableSecuritySignature") == 0 )
   {
      itemID = IDS_ENABLESECURITYSIGNATURE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\EnablePlainTextPassword") == 0 )
   {
      itemID = IDS_ENABLEPLAINTEXTPASSWORD;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\RestrictNullSessAccess") == 0 )
   {
      itemID = IDS_RESTRICTNULLSESSACCESS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\RequireSecuritySignature") == 0 )
   {
      itemID = IDS_SERREQUIRESECURITYSIGNATURE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\NullSessionShares") == 0 )
   {
      itemID = IDS_NULLSESSIONSHARES;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\NullSessionPipes") == 0 )
   {
      itemID = IDS_NULLSESSIONPIPES;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\EnableSecuritySignature") == 0 )
   {
      itemID = IDS_SERENABLESECURITYSIGNATURE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\EnableForcedLogOff") == 0 )
   {
      itemID = IDS_ENABLEFORCEDLOGOFF;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\AutoDisconnect") == 0 )
   {
      itemID = IDS_AUTODISCONNECT;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\ProtectionMode") == 0 )
   {
      itemID = IDS_PROTECTIONMODE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\ClearPageFileAtShutdown") == 0 )
   {
      itemID = IDS_CLEARPAGEFILEATSHUTDOWN;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Kernel\\ObCaseInsensitive") == 0 )
   {
      itemID = IDS_OBCASEINSENSITIVE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\SecurePipeServers\\Winreg\\AllowedPaths\\Machine") == 0 )
   {
      itemID = IDS_MACHINE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers\\AddPrinterDrivers") == 0 )
   {
      itemID = IDS_ADDPRINTERDRIVERS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\SubmitControl") == 0 )
   {
      itemID = IDS_SUBMITCONTROL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\RestrictAnonymousSAM") == 0 )
   {
      itemID = IDS_RESTRICTANONYMOUSSAM;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\RestrictAnonymous") == 0 )
   {
      itemID = IDS_RESTRICTANONYMOUS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\NoLMHash") == 0 )
   {
      itemID = IDS_NOLMHASH;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\NoDefaultAdminOwner") == 0 )
   {
      itemID = IDS_NODEFAULTADMINOWNER;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\NTLMMinServerSec") == 0 )
   {
      itemID = IDS_NTLMMINSERVERSEC;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\NTLMMinClientSec") == 0 )
   {
      itemID = IDS_NTLMMINCLIENTSEC;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel") == 0 )
   {
      itemID = IDS_LMCOMPATIBILITYLEVEL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LimitBlankPasswordUse") == 0 )
   {
      itemID = IDS_LIMITBLANKPASSWORDUSE;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\FullPrivilegeAuditing") == 0 )
   {
      itemID = IDS_FULLPRIVILEGEAUDITING;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\ForceGuest") == 0 )
   {
      itemID = IDS_FORCEGUEST;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy") == 0 )
   {
      itemID = IDS_FIPSALGORITHMPOLICY;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\EveryoneIncludesAnonymous") == 0 )
   {
      itemID = IDS_EVERYONEINCLUDESANONYMOUS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\DisableDomainCreds") == 0 )
   {
      itemID = IDS_DISABLEDOMAINCREDS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\CrashOnAuditFail") == 0 )
   {
      itemID = IDS_CRASHONAUDITFAIL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\AuditBaseObjects") == 0 )
   {
      itemID = IDS_AUDITBASEOBJECTS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\UndockWithoutLogon") == 0 )
   {
      itemID = IDS_UNDOCKWITHOUTLOGON;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ShutdownWithoutLogon") == 0 )
   {
      itemID = IDS_SHUTDOWNWITHOUTLOGON;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ScForceOption") == 0 )
   {
      itemID = IDS_SCFORCEOPTION;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LegalNoticeText") == 0 )
   {
      itemID = IDS_LEGALNOTICETEXT;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LegalNoticeCaption") == 0 )
   {
      itemID = IDS_LEGALNOTICECAPTION;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DontDisplayLastUserName") == 0 )
   {
      itemID = IDS_DONTDISPLAYLASTUSERNAME;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableCAD") == 0 )
   {
      itemID = IDS_DISABLECAD;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ScRemoveOption") == 0 )
   {
      itemID = IDS_SCREMOVEOPTION;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PasswordExpiryWarning") == 0 )
   {
      itemID = IDS_PASSWORDEXPIRYWARNING;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ForceUnlockLogon") == 0 )
   {
      itemID = IDS_FORCEUNLOCKLOGON;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CachedLogonsCount") == 0 )
   {
      itemID = IDS_CACHEDLOGONSCOUNT;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateFloppies") == 0 )
   {
      itemID = IDS_ALLOCATEFLOPPIES;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateDASD") == 0 )
   {
      itemID = IDS_ALLOCATEDASD;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateCDRoms") == 0 )
   {
      itemID = IDS_ALLOCATECDROMS;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole\\SetCommand") == 0 )
   {
      itemID = IDS_SETCOMMAND;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole\\SecurityLevel") == 0 )
   {
      itemID = IDS_SECURITYLEVEL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Microsoft\\Driver Signing\\Policy") == 0 )
   {
      itemID = IDS_REGPOLICY;
   }else
   //Raid #652307, yanggao, 8/9/2002
   if( _wcsicmp(szItem, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SubSystems\\optional") == 0 )
   {
      itemID = IDS_OPTIONAL;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers\\AuthenticodeEnabled") == 0 )
   {
      itemID = IDS_AUTHENTICODEENABLED;
   }else
   if( _wcsicmp(szItem, L"MACHINE\\Software\\Policies\\Microsoft\\Cryptography\\ForceKeyProtection") == 0 )
   {
      itemID = IDS_FORCEHIGHPROTECTION;
   }
   return itemID;
}
//
// create registry value list under configuration node
//
void CSnapin::CreateProfileRegValueList(MMC_COOKIE cookie,
                                        PEDITTEMPLATE pSceInfo,
                                        LPDATAOBJECT pDataObj)
{
    if ( !pSceInfo || !(pSceInfo->pTemplate) ) {
        return;
    }


    DWORD nCount = pSceInfo->pTemplate->RegValueCount;
    PSCE_REGISTRY_VALUE_INFO regArray = pSceInfo->pTemplate->aRegValues;

    CString strDisplayName;
    LPTSTR pDisplayName=NULL;
    DWORD displayType = 0;
    LPTSTR szUnits=NULL;
    PREGCHOICE pChoices=NULL;
    PREGFLAGS pFlags=NULL;
    CResult *pResult;
    long itemID = 0;

    for ( DWORD i=0; i<nCount; i++) {

         if ( !LookupRegValueProperty(regArray[i].FullValueName,
                                      &pDisplayName,
                                      &displayType,
                                      &szUnits,
                                      &pChoices,
                                      &pFlags) ) {
             continue;
         }

         if ( !pDisplayName ) {

             strDisplayName = regArray[i].FullValueName;

         } else {
             strDisplayName = pDisplayName;
             LocalFree(pDisplayName);
         }

         itemID = GetRegValueItemID(regArray[i].FullValueName);

         //
         // add this item
         //
         pResult = AddResultItem(strDisplayName,
                       NULL,
                       (LONG_PTR)&(regArray[i]),
                       ITEM_PROF_REGVALUE,
                       -1,
                       cookie,
                       false,
                       szUnits,
                       displayType,
                       pSceInfo,
                       pDataObj,
                       NULL,
                       itemID     //assign an identifier to this item
                       );

         if (pResult && pChoices) {
            pResult->SetRegChoices(pChoices);
         }
         if (pResult && pFlags) {
            pResult->SetRegFlags(pFlags);
         }

         if ( szUnits ) {
             LocalFree(szUnits);
         }
         szUnits = NULL;

    }

    return;
}

void
CSnapin::CreateAnalysisRegValueList(MMC_COOKIE cookie,
                                    PEDITTEMPLATE pAnalTemp,
                                    PEDITTEMPLATE pEditTemp,
                                    LPDATAOBJECT pDataObj,
                                    RESULT_TYPES type)
{
    if ( !pAnalTemp || !(pAnalTemp->pTemplate) ||
         !pEditTemp || !(pEditTemp->pTemplate) ) {

        return;
    }


    DWORD nEditCount = pEditTemp->pTemplate->RegValueCount;   // should be everything
    PSCE_REGISTRY_VALUE_INFO paEdit = pEditTemp->pTemplate->aRegValues;
    PSCE_REGISTRY_VALUE_INFO paAnal = pAnalTemp->pTemplate->aRegValues;

    CString strDisplayName;
    LPTSTR pDisplayName=NULL;
    DWORD displayType = 0;
    LPTSTR szUnits = NULL;
    PREGCHOICE pChoices = NULL;
    PREGFLAGS pFlags = NULL;
    CResult *pResult=NULL;
    long itemID = 0;

    for ( DWORD i=0; i<nEditCount; i++) {

        if ( !LookupRegValueProperty(paEdit[i].FullValueName,
                                     &pDisplayName,
                                     &displayType,
                                     &szUnits,
                                     &pChoices,
                                     &pFlags) ) {
            continue;
        }

        if ( !pDisplayName ) {

            strDisplayName = paEdit[i].FullValueName;

        } else {
            strDisplayName = pDisplayName;
            LocalFree(pDisplayName);
        }

        itemID = GetRegValueItemID(paEdit[i].FullValueName);
         //
         // find the match in the analysis array
         // should always find a match because all existing reg values are
         // added to the array when getinfo is called
         //
         for ( DWORD j=0; j< pAnalTemp->pTemplate->RegValueCount; j++ ) {

            if ( pAnalTemp->pTemplate->aRegValues &&
                 pAnalTemp->pTemplate->aRegValues[j].FullValueName &&
                 _wcsicmp(pAnalTemp->pTemplate->aRegValues[j].FullValueName, paEdit[i].FullValueName) == 0 ) {

                 if( reinterpret_cast<CFolder *>(cookie)->GetModeBits() & MB_LOCAL_POLICY ){
                    break;
                 }

                 //
                 // find a analysis result - this item may be a mismatch (when Value is not NULL)
                 // SceEnumAllRegValues will set the status field to good if this item was not
                 // added because it did not exist when it was originally loaded from the SAP table.
                 // This tells us that this item is a MATCH and we should copy the value.
                 //
                 if ( !(paAnal[j].Value)  && paEdit[i].Value &&
                      paAnal[j].Status != SCE_STATUS_ERROR_NOT_AVAILABLE &&
                      paAnal[j].Status != SCE_STATUS_NOT_ANALYZED ) {

                     //
                     // this is a good item, copy the config info as the analysis info
                     //
                     paAnal[j].Value = (PWSTR)LocalAlloc(0,
                                           (wcslen(paEdit[i].Value)+1)*sizeof(WCHAR));

                     if ( paAnal[j].Value ) {
                         //This may not be a safe usage. Both paAnal[j].Value and paEdit[i].Value are LPTSTR. Consider fix.
                         wcscpy(paAnal[j].Value, paEdit[i].Value);

                     } else {
                         // else out of memory
                         if ( szUnits ) {
                             LocalFree(szUnits);
                         }
                         szUnits = NULL;
                         return;
                     }
                 }
                 break;
            }
         }

         DWORD status = SCE_STATUS_GOOD;
         if ( j < pAnalTemp->pTemplate->RegValueCount ) {
            status = CEditTemplate::ComputeStatus( &paEdit[i], &pAnalTemp->pTemplate->aRegValues[j] );
         } else {
             //
             // did not find the analysis array, shouldn't happen
             //
             status = SCE_STATUS_NOT_CONFIGURED;
         }

         //
         // add this item
         //
         if ( j < pAnalTemp->pTemplate->RegValueCount) {

            pResult = AddResultItem(strDisplayName,
                          (LONG_PTR)&(pAnalTemp->pTemplate->aRegValues[j]),
                          (LONG_PTR)&(paEdit[i]),
                          type,
                          status,
                          cookie,
                          false,
                          szUnits,
                          displayType,
                          pEditTemp,
                          pDataObj,
                          NULL,
                          itemID);

            if (pResult && pChoices) {
               pResult->SetRegChoices(pChoices);
            }
            if (pResult && pFlags) {
               pResult->SetRegFlags(pFlags);
            }
         } else {
            //
            // a good/not configured item
            //
            pResult = AddResultItem(strDisplayName,
                          NULL,
                          (LONG_PTR)&(paEdit[i]),
                          type,
                          status,
                          cookie,
                          false,
                          szUnits,
                          displayType,
                          pEditTemp,
                          pDataObj,
                          NULL,
                          itemID);

            if (pResult && pChoices) {
               pResult->SetRegChoices(pChoices);
            }
         }

         if ( szUnits ) {
             LocalFree(szUnits);
         }
         szUnits = NULL;

    }

    return;
}


BOOL
LookupRegValueProperty(
    IN LPTSTR RegValueFullName,
    OUT LPTSTR *pDisplayName,
    OUT PDWORD displayType,
    OUT LPTSTR *pUnits OPTIONAL,
    OUT PREGCHOICE *pChoices OPTIONAL,
    OUT PREGFLAGS *pFlags OPTIONAL
    )
{
    if ( !RegValueFullName || !pDisplayName || !displayType ) {
       return FALSE;
    }

    CString strTmp = RegValueFullName;

    //
    // replace the \\ with / before search reg
    //
    int npos = strTmp.Find(L'\\');

    while (npos > 0) {
       *(strTmp.GetBuffer(1)+npos) = L'/';
       npos = strTmp.Find(L'\\');
    }

    //
    // query the values from registry
    //
    *pDisplayName = NULL;

    HKEY hKey=NULL;
    HKEY hKey2=NULL;
    DWORD rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    SCE_ROOT_REGVALUE_PATH,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if (rc == ERROR_SUCCESS) {

        rc = RegOpenKeyEx(
                hKey,
                (PWSTR)(LPCTSTR)strTmp,
                0,
                KEY_READ,
                &hKey2
                );

    }

    BOOL bRet;

    if ( ERROR_SUCCESS == rc) {

        DWORD RegType = 0;
        PWSTR Value=NULL;
        HRESULT hr = S_OK;

        Value = (PWSTR) LocalAlloc(LPTR,MAX_PATH*sizeof(WCHAR));
        if (Value) {
           //
           // 126714 - shouldn't hard code display strings in the registry
           //          store them indirectly so they can support MUI
           //
           hr = SHLoadRegUIString(hKey2,
                                  SCE_REG_DISPLAY_NAME,
                                  Value,
                                  MAX_PATH);
           if (FAILED(hr)) {
              rc = MyRegQueryValue(
                       hKey,
                       (PWSTR)(LPCTSTR)strTmp,
                       SCE_REG_DISPLAY_NAME,
                       (PVOID *)&Value,
                       &RegType
                       );
           } else {
              rc = ERROR_SUCCESS;
           }
        }
        if ( rc == ERROR_SUCCESS ) {

            if (  Value ) {
                *pDisplayName = Value;
                Value = NULL;
            } else {
                //
                // did not find correct display name, use the reg name (outsize)
                //
                *pDisplayName = NULL;
            }
        }

        rc = MyRegQueryValue(
                    hKey,
                    (PWSTR)(LPCTSTR)strTmp,
                    SCE_REG_DISPLAY_TYPE,
                    (PVOID *)&displayType,
                    &RegType
                    );

        if ( Value ) {
            LocalFree(Value);
            Value = NULL;
        }

        if ( pUnits ) {
            //
            // query the units
            //
            rc = MyRegQueryValue(
                        hKey,
                        (PWSTR)(LPCTSTR)strTmp,
                        SCE_REG_DISPLAY_UNIT,
                        (PVOID *)&Value,
                        &RegType
                        );

            if ( rc == ERROR_SUCCESS ) {

                if ( RegType == REG_SZ && Value ) {
                    *pUnits = Value;
                    Value = NULL;
                } else {
                    //
                    // did not find units
                    //
                    *pUnits = NULL;
                }
            }
            if ( Value ) {
                LocalFree(Value);
                Value = NULL;
            }
        }

        //
        // find the registry key but may not find the display name
        //
        bRet = TRUE;

        if ( pChoices ) {
           //
           // query the choices
           //
           *pChoices = NULL;

           rc = MyRegQueryValue(hKey,
                                (PWSTR)(LPCTSTR)strTmp,
                                SCE_REG_DISPLAY_CHOICES,
                                (PVOID *)&Value,
                                &RegType
                               );
           if (ERROR_SUCCESS == rc) {
              if ((REG_MULTI_SZ == RegType) && Value) {
                 LPTSTR szChoice = NULL;
                 LPTSTR szLabel = NULL; // max field size for szChoice + dwVal
                 DWORD dwVal = -1;
                 PREGCHOICE pRegChoice = NULL;
                 PREGCHOICE pLast = NULL;

                 szChoice = Value;
                 do {
                    //
                    // Divide szChoice into dwValue and szLabel sections
                    //
                    szLabel = _tcschr(szChoice,L'|');
                    if( szLabel == NULL ) //Raid #553113, yanggao
                    {
                       break;
                    }
                    *szLabel = L'\0';
                    szLabel++;
                    if( szLabel == NULL ) //Raid #553113, yanggao
                    {
                       break;
                    }
                    dwVal = _ttoi(szChoice);

                    pRegChoice = (PREGCHOICE) LocalAlloc(LPTR,sizeof(REGCHOICE));
                    if (pRegChoice) {
                       //
                       // Fill in fields of new reg choice
                       //
                       pRegChoice->dwValue = dwVal;
                       pRegChoice->szName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(szLabel)+1)*sizeof(TCHAR));
                       if (NULL == pRegChoice->szName) {
                          //
                          // Out of memory.  Bummer.
                          //
                          LocalFree(pRegChoice);
                          pRegChoice = NULL;
                          break;
                       }
                       //This is not a safe usage. Validate szLabel.
                       lstrcpy(pRegChoice->szName,szLabel);
                       //
                       // Attach new item to end of list
                       //
                       if (NULL == *pChoices) {
                          *pChoices = pRegChoice;
                       } else {
                          pLast->pNext = pRegChoice;
                       }
                       pLast = pRegChoice;
                    }
                    szChoice = _tcschr(szLabel,L'\0');
                    if( szChoice == NULL )
                    {
                       break;
                    }
                    szChoice++;
                 } while (*szChoice);
              } else {
                 //
                 // Did not find choices
                 //
                 bRet = FALSE;
              }
           }

           if ( Value ) {
               LocalFree(Value);
               Value = NULL;
           }

        }

        if ( pFlags ) {
           //
           // query the Flags
           //
           *pFlags = NULL;

           rc = MyRegQueryValue(hKey,
                                (PWSTR)(LPCTSTR)strTmp,
                                SCE_REG_DISPLAY_FLAGLIST,
                                (PVOID *)&Value,
                                &RegType
                               );
           if (ERROR_SUCCESS == rc) {
              if ((REG_MULTI_SZ == RegType) && Value) {
                 LPTSTR szFlag = NULL;
                 LPTSTR szLabel = NULL; // max field size for szFlag + dwVal
                 DWORD dwVal = -1;
                 PREGFLAGS pRegFlag = NULL;
                 PREGFLAGS pLast = NULL;

                 szFlag = Value;
                 do {
                    //
                    // Divide szFlag into dwValue and szLabel sections
                    //
                    szLabel = _tcschr(szFlag,L'|');
                    if( szLabel == NULL ) //Raid #553113, yanggao
                    {
                       break;
                    }
                    *szLabel = L'\0';
                    szLabel++;
                    if( szLabel == NULL ) //Raid #553113, yanggao
                    {
                       break;
                    }
                    dwVal = _ttoi(szFlag);

                    pRegFlag = (PREGFLAGS) LocalAlloc(LPTR,sizeof(REGFLAGS));
                    if (pRegFlag) {
                       //
                       // Fill in fields of new reg Flag
                       //
                       pRegFlag->dwValue = dwVal;
                       pRegFlag->szName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(szLabel)+1)*sizeof(TCHAR));
                       if (NULL == pRegFlag->szName) {
                          //
                          // Out of memory.  Bummer.
                          //
                          LocalFree(pRegFlag);
                          pRegFlag = NULL;
                          break;
                       }
                       //This is not a safe usage. need to validate szLabel.
                       lstrcpy(pRegFlag->szName,szLabel);
                       //
                       // Attach new item to end of list
                       //
                       if (NULL == *pFlags) {
                          *pFlags = pRegFlag;
                       } else {
                          pLast->pNext = pRegFlag;
                       }
                       pLast = pRegFlag;
                    }
                    szFlag = wcschr(szLabel,L'\0');
                    if( szFlag == NULL )
                    {
                       break;
                    }
                    szFlag++;

                 } while (*szFlag);
              } else {
                 //
                 // Did not find Flags
                 //
                 bRet = FALSE;
              }
           }

           if ( Value ) {
               LocalFree(Value);
               Value = NULL;
           }

        }
    } else {
        //
        // did not find the registry key
        //
        bRet = FALSE;
    }

    if ( hKey ) {
        RegCloseKey(hKey);
    }
    if ( hKey2 ) {
        RegCloseKey(hKey2);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\regdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regdlg.h
//
//  Contents:   definition of CRegistryDialog
//
//----------------------------------------------------------------------------
#if !defined(AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_)
#define AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "snapmgr.h"
#include "HelpDlg.h"

// This structure is used by CResistryDialog to save the HKEY value
// and enumeration state of a HTREEITEM
typedef struct _tag_TI_KEYINFO
{
   HKEY hKey;  // HKEY value of this tree item
   bool Enum;  // true if the item has already been enumerated
} TI_KEYINFO, *LPTI_KEYINFO;


/////////////////////////////////////////////////////////////////////////////
// CRegistryDialog dialog
// Used to select a registry item.  If the dialog returns IDOK
// 'm_strReg' will contain the full path of the registry item.
/////////////////////////////////////////////////////////////////////////////
class CRegistryDialog : public CHelpDialog
{
// Construction
public:
    void SetCookie(MMC_COOKIE cookie);
    void SetConsole(LPCONSOLE pConsole);
    void SetComponentData(CComponentDataImpl *pComponentData);
    void SetDataObj(LPDATAOBJECT pDataObj) { m_pDataObj = pDataObj; }
    void SetProfileInfo(PEDITTEMPLATE pspi, FOLDER_TYPES ft);
    void SetHandle(PVOID hDB) { m_dbHandle = hDB; };

   virtual ~CRegistryDialog();
    CRegistryDialog();   // standard constructor

      // Create a new TI_KEYINFO structure
   static LPTI_KEYINFO CreateKeyInfo(HKEY hKey = 0, bool Enum = 0);

      // Checks to see if strReg is a valid registry key
   BOOL IsValidRegPath(LPCTSTR strReg);

        // Add subkeys to a tree item as children.
    void EnumerateChildren(HTREEITEM hParent);

        // Makes the last item in the path visible.
    void MakePathVisible(LPCTSTR strReg);

// Dialog Data
    //{{AFX_DATA(CRegistryDialog)
    enum { IDD = IDD_REGISTRY_DIALOG };
    CTreeCtrl   m_tcReg;
    CString m_strReg;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRegistryDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CRegistryDialog)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnItemexpandingRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDeleteitemRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangedRegtree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeRegkey();
    afx_msg void OnSetFocus();
   //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Public data members
public:
    PEDITTEMPLATE m_pTemplate;
    PVOID m_dbHandle;

private:
    MMC_COOKIE m_cookie;
    CComponentDataImpl * m_pComponentData;
    LPCONSOLE m_pConsole;
    WTL::CImageList m_pIl;                   // The image list used
                                    // by the tree ctrl.
    LPDATAOBJECT m_pDataObj;
    BOOL m_bNoUpdate;                           // When we don't want the edit
                                                //  control to be updated because
                                                //  of a selection
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGISTRYDIALOG_H__C84DDDBB_D7CA_11D0_9C69_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\regvldlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regvldlg.cpp
//
//  Contents:   implementation of CSceRegistryValueInfo, CConfigRegEnable,
//              CAttrRegEnable, CLocalPolRegEnable, CConfigRegNumber, 
//              CAttrRegNumber, CLocalPolRegNumber, CConfigRegString, 
//              CAttrRegString, CLocalPolRegString, CConfigRegChoice
//              CAttrRegChoice, CLocalPolRegChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "regvldlg.h"
#include "util.h"
#include "snapmgr.h"
#include "defaults.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



extern PCWSTR g_pcszNEWLINE;

/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::CRegistryValueInfo

Synopsis:   Constructor for CRegistryValueInfo, sets m_pRegInfo.

Arguments:  [pInfo]     - A pointer toa SCE_REGISTRY_VALUE_INFO struct.

-----------------------------------------------------------------------------------------*/
CSceRegistryValueInfo::CSceRegistryValueInfo(
   PSCE_REGISTRY_VALUE_INFO pInfo)
{
   m_pRegInfo = pInfo;
}

/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::GetBoolValue

Synopsis:   Returns a boolean TRUE or false depending on the data and data type of this
         object

Returns: TRUE if the data is equal to a TRUE value, FALSE otherwise.
-----------------------------------------------------------------------------------------*/
DWORD CSceRegistryValueInfo::GetBoolValue()
{
   if (GetValue() == NULL)
      return SCE_NO_VALUE;
   

   return GetValue()[0] == L'1';
}


/*-----------------------------------------------------------------------------------------
Method:     CRegistryValueInfo::SetValueBool

Synopsis:   Sets the value to the types equivalent boolean value, SCE_NO_VALUE if
         [dwVal] is equal to SCE_NO_VALUE.

Arguments:  [bVal]      - TRUE or FALSE.

Returns: ERROR_SUCCESS     - Successfull
         E_OUTOFMEMORY     - Out of memory.
-----------------------------------------------------------------------------------------*/
DWORD
CSceRegistryValueInfo::SetBoolValue(
   DWORD dwVal)
{

   if(dwVal == SCE_NO_VALUE)
   {
      if(m_pRegInfo->Value)
	  {
         LocalFree( m_pRegInfo->Value );
      }
      m_pRegInfo->Value = NULL;
      return ERROR_SUCCESS;
   }

   //
   // Set the length of the string.
   //
   int nLen = 2;

   if ( m_pRegInfo->Value == NULL ) 
   {
       // allocate buffer
       m_pRegInfo->Value = (PWSTR)LocalAlloc(0, nLen*sizeof(WCHAR));
       if(m_pRegInfo->Value == NULL)
          return (DWORD)E_OUTOFMEMORY;
   }

   if ( m_pRegInfo->Value ) 
   {
      //
      // Convert and set the data.
      //
      m_pRegInfo->Value[0] = (int)dwVal + L'0';
      m_pRegInfo->Value[nLen-1] = L'\0';
   }
   return ERROR_SUCCESS;
}




/////////////////////////////////////////////////////////////////////////////
// CConfigRegEnable message handlers
void CConfigRegEnable::Initialize(CResult *pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase() );

   DWORD dw = prv.GetBoolValue();

   if ( dw != SCE_NO_VALUE ) 
   {
      m_bConfigure = TRUE;
      SetInitialValue(dw);

   }
   else
      m_bConfigure = FALSE;
}

BOOL CConfigRegEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_nEnabledRadio) 
	     {
         // ENABLED
         case 0:
            dw = 1;
            break;
         // DISABLED
         case 1:
            dw = 0;
            break;
		    
         // Not really configured
         default:
            dw = -1;
            break;
         }
      }

      CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase()) );
      DWORD prvdw = prv.GetBoolValue();  //Bug211219, Yanggao, 3/15/2001

      prv.SetBoolValue(dw);

      if(!UpdateProfile())
         prv.SetBoolValue(prvdw);
   }
   // Class hieirarchy is bad - call CAttribute base method directly

   return CAttribute::OnApply();
}


BOOL CConfigRegEnable::UpdateProfile()
{
   if ( m_pData->GetBaseProfile() ) //Bug211219, Yanggao, 3/15/2001
   {
      if( !(m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY)) )
      {
          m_pData->Update(m_pSnapin);
          return FALSE;
      }
      else
      {
          m_pData->Update(m_pSnapin);
          return TRUE;
      }
   }
   
   m_pData->Update(m_pSnapin);
   return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAttrRegEnable message handlers

void CAttrRegEnable::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);
   CSceRegistryValueInfo prv(NULL);

   //
   // Edit template settings.
   //
   prv.Attach( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase() );

   DWORD dw = prv.GetBoolValue();
   if(dw != SCE_NO_VALUE)
   {
      m_bConfigure = TRUE;
      m_EnabledRadio = !dw;
   }
   else
      m_bConfigure = FALSE;

   pResult->GetDisplayName( NULL, m_Current, 2 );
}

BOOL CAttrRegEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_EnabledRadio) 
	     {
            // ENABLED
            case 0:
               dw = 1;
               break;
            // DISABLED
            case 1:
               dw = 0;
               break;
            // Not really configured
            default:
               dw = -1;
               break;
         }
      }

      CSceRegistryValueInfo prv( (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase()) );

      prv.SetBoolValue(dw);
      //
      // this address should never be NULL
      //
      int status = CEditTemplate::ComputeStatus(
                                    (PSCE_REGISTRY_VALUE_INFO)m_pData->GetBase(),
                                    (PSCE_REGISTRY_VALUE_INFO)m_pData->GetSetting()
                                    );
      UpdateProfile( status );
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();

}

void CAttrRegEnable::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() ) 
      m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegEnable message handlers
BOOL CLocalPolRegEnable::UpdateProfile( )
{
   return m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegEnable::Initialize(CResult * pResult)
{
   CConfigRegEnable::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_nEnabledRadio = -1;
      m_fNotDefine = FALSE; //Raid #413225, 6/11/2001, Yanggao
   }
}


////////////////////////////////////////////////////////////
// CConfigRegNumber message handlers
//
CConfigRegNumber::CConfigRegNumber(UINT nTemplateID) : 
CConfigNumber(nTemplateID ? nTemplateID : IDD) 
{ 
};

void CConfigRegNumber::Initialize(CResult * pResult)
{
   LONG_PTR dw = 0;

   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);
   m_strUnits = pResult->GetUnits();

   m_cMinutes = 0;
   m_nLow = 0;
   m_nHigh = 999;
   m_nSave = 0;
   m_iNeverId = 0;
   m_iAccRate = 1;
   m_iStaticId = 0;
   SetZeroValueFlag(false); //Raid 509322, Yanggao, 1/3/2002, make sure zero is a useful value.

   m_strStatic = _T("");
   dw = pResult->GetBase();
   PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)dw;

   //
   // HACKHACK: since we don't have a way to specify these values
   // in the inf file to get them to the registry where we could
   // read and use them here we need to hard code the limits and
   // strings for the values we know about.
   //
   // For the next version we really need this in the inf file &
   // registry
   //
   // Prefast warning: Yields unexpected results in non-English locales. 
   // Comments: These three constant strings are not localizable.
   if (0 == _wcsicmp(prv->FullValueName,RNH_AUTODISCONNECT_NAME)) 
   {
      m_nLow = RNH_AUTODISCONNECT_LOW;
      m_nHigh = RNH_AUTODISCONNECT_HIGH;
      m_cMinutes = RNH_AUTODISCONNECT_FLAGS;
      m_iNeverId = RNH_AUTODISCONNECT_SPECIAL_STRING;
      m_iStaticId = RNH_AUTODISCONNECT_STATIC_STRING;
      SetZeroValueFlag(true); //Raid 509322, Yanggao, 1/3/2002, make sure zero is a useful value.
   }
   if (0 == _wcsicmp(prv->FullValueName,RNH_CACHED_LOGONS_NAME)) 
   {
      m_nLow = RNH_CACHED_LOGONS_LOW;
      m_nHigh = RNH_CACHED_LOGONS_HIGH;
      m_cMinutes = RNH_CACHED_LOGONS_FLAGS;
      m_iNeverId = RNH_CACHED_LOGONS_SPECIAL_STRING;
      m_iStaticId = RNH_CACHED_LOGONS_STATIC_STRING;
   }
   if (0 == _wcsicmp(prv->FullValueName,RNH_PASSWORD_WARNINGS_NAME)) 
   {
      m_nLow = RNH_PASSWORD_WARNINGS_LOW;
      m_nHigh = RNH_PASSWORD_WARNINGS_HIGH;
      m_cMinutes = RNH_PASSWORD_WARNINGS_FLAGS;
      m_iNeverId = RNH_PASSWORD_WARNINGS_SPECIAL_STRING;
      m_iStaticId = RNH_PASSWORD_WARNINGS_STATIC_STRING;
   }
   //
   // End HACKHACK
   //
   if ( prv && prv->Value ) 
   {
      m_bConfigure = TRUE;
      //Raid #702113, yanggao, 9/12/2002
      if( prv->ValueType != REG_MULTI_SZ && prv->ValueType != REG_SZ &&
             prv->ValueType != REG_EXPAND_SZ )
      {
         m_nSave = _wtol(prv->Value);
      }
      else
      {
         m_nSave = (DWORD_PTR)(prv->Value);
      }

      SetInitialValue(m_nSave);

   } 
   else
      m_bConfigure = FALSE;
}

BOOL CConfigRegNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      UpdateData(TRUE);
      DWORD dw = 0;
      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else
         dw = CurrentEditValue();

      PWSTR sz = NULL;
      if ( dw != SCE_NO_VALUE ) 
      {
         CString strTmp;
         // allocate buffer
         strTmp.Format(TEXT("%d"), dw);
         sz = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(WCHAR));
         if (!sz) 
	     {
            //
            // Display a message?
            //
            return FALSE;
         }
         //This may not be a safe usage. sz is PWSTR. Consider fix.
         lstrcpy(sz,strTmp);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      //
      // this address should never be NULL
      //
      ASSERT(prv);
      if (prv)
      {
         if ( prv->Value )
             LocalFree(prv->Value);

         prv->Value = sz;
      } 
      else if (sz)
         LocalFree(sz);

      UpdateProfile();
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CConfigRegNumber::UpdateProfile()
{
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CAttrRegNumber message handlers
CAttrRegNumber::CAttrRegNumber() : 
CAttrNumber(IDD) 
{ 
};

void CAttrRegNumber::Initialize(CResult * pResult)
{
    // Class hieirarchy is bad - call CAttribute base method directly
    CAttribute::Initialize(pResult);
    m_strUnits = pResult->GetUnits();

    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");

    m_cMinutes = 0;
    m_nLow = 0;
    m_nHigh = 999;
    m_nSave = 0;
    m_iNeverId = 0;
    m_iAccRate = 1;
    m_iStaticId = 0;

    LONG_PTR dw = pResult->GetBase();
    PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)dw;

    //
    // HACKHACK: since we don't have a way to specify these values
    // in the inf file to get them to the registry where we could
    // read and use them here we need to hard code the limits and
    // strings for the values we know about.
    //
    // For the next version we really need this in the inf file &
    // registry
    // Prefast warning: Yields unexpected results in non-English locales. 
    // Comments: These three constant strings are not localizable.
    if (0 == _wcsicmp(prv->FullValueName,RNH_AUTODISCONNECT_NAME)) 
	{
       m_nLow = RNH_AUTODISCONNECT_LOW;
       m_nHigh = RNH_AUTODISCONNECT_HIGH;
       m_cMinutes = RNH_AUTODISCONNECT_FLAGS;
       m_iNeverId = RNH_AUTODISCONNECT_SPECIAL_STRING;
       m_iStaticId = RNH_AUTODISCONNECT_STATIC_STRING;
    }
    if (0 == _wcsicmp(prv->FullValueName,RNH_CACHED_LOGONS_NAME)) 
	{
       m_nLow = RNH_CACHED_LOGONS_LOW;
       m_nHigh = RNH_CACHED_LOGONS_HIGH;
       m_cMinutes = RNH_CACHED_LOGONS_FLAGS;
       m_iNeverId = RNH_CACHED_LOGONS_SPECIAL_STRING;
       m_iStaticId = RNH_CACHED_LOGONS_STATIC_STRING;
    }
    if (0 == _wcsicmp(prv->FullValueName,RNH_PASSWORD_WARNINGS_NAME)) 
	{
       m_nLow = RNH_PASSWORD_WARNINGS_LOW;
       m_nHigh = RNH_PASSWORD_WARNINGS_HIGH;
       m_cMinutes = RNH_PASSWORD_WARNINGS_FLAGS;
       m_iNeverId = RNH_PASSWORD_WARNINGS_SPECIAL_STRING;
       m_iStaticId = RNH_PASSWORD_WARNINGS_STATIC_STRING;
    }
    //
    // End HACKHACK
    //

    if ( prv && prv->Value ) 
	{
       m_bConfigure = TRUE;

       m_nSave = _wtol(prv->Value);
       SetInitialValue(m_nSave);
    } 
	else
       m_bConfigure = FALSE;

    pResult->GetDisplayName( NULL, m_strSetting, 2 );
}

BOOL CAttrRegNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int status = 0;

      UpdateData(TRUE);

   if (!m_bConfigure)
   {
      dw = SCE_NO_VALUE;
   }
   else
   {
      dw = CurrentEditValue();
   }

      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
          DWORD dw2=SCE_NO_VALUE;
          if ( prv2 ) 
	      {
              //
              // if there is analysis setting (should always have)
              //
              if (prv2->Value ) 
		      {
                  dw2 = _wtol(prv2->Value);
              } 
		      else 
		      {
                  dw2 = SCE_NO_VALUE;
              }
          }


          if ( prv->Value )
              LocalFree(prv->Value);
          prv->Value = NULL;

          if ( dw != SCE_NO_VALUE ) 
	      {
              CString strTmp;

              // allocate buffer
              strTmp.Format(TEXT("%d"), dw);
              prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

              if ( prv->Value )
                  //This may not be a safe usage. prv->Value is LPTSTR. Consider fix.
                  wcscpy(prv->Value,(LPCTSTR)strTmp);
              else 
		        {
                  // can't allocate buffer, error!!
              }
          }

          status = CEditTemplate::ComputeStatus (prv, prv2);


          UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CAttrRegNumber::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() )
     m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegNumber message handlers
CLocalPolRegNumber::CLocalPolRegNumber() : 
CConfigRegNumber(IDD), m_bInitialValueSet(FALSE)

{
   m_pHelpIDs = (DWORD_PTR)a228HelpIDs;
   m_uTemplateResID = IDD;
}

void CLocalPolRegNumber::UpdateProfile()
{
   m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegNumber::Initialize(CResult * pResult)
{
   CConfigRegNumber::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_bInitialValueSet = TRUE;
      m_nSave = 0;
   }
}
void CLocalPolRegNumber::SetInitialValue(DWORD_PTR dw) 
{
   if (m_bConfigure && !m_bInitialValueSet) 
   {
      CConfigRegNumber::SetInitialValue(dw);
      m_bInitialValueSet = TRUE;
   }
}


/////////////////////////////////////////////////////////////////////////////
// CConfigRegString message handlers

void CConfigRegString::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) 
   {

       m_bConfigure = TRUE;

       if (QueryMultiSZ()) 
       {
          LPTSTR sz = SZToMultiSZ(prv->Value);
          m_strName = sz;
          LocalFree(sz);
          if( REG_SZ == prv->ValueType ) //Raid #376218, 4/25/2001
          {
              prv->ValueType = REG_MULTI_SZ;
          }
       } 
       else
       {
          m_strName = (LPTSTR) prv->Value;
       }
   } 
   else 
   {
       m_strName = _T("");
       m_bConfigure = FALSE;
   }
}



BOOL CConfigRegString::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      UpdateData(TRUE);

      m_strName.TrimRight();

      UpdateData (FALSE);  // put the corrected string back in the control

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      if ( prv ) 
      {
        if (!m_bConfigure) 
        {
            if ( prv->Value )
                LocalFree(prv->Value);
            prv->Value = NULL;
            this->UpdateProfile();
        } 
        else 
        {
           LPTSTR prvpt = NULL;
           LPTSTR pt = 0;
           if (QueryMultiSZ()) 
              pt = MultiSZToSZ(m_strName);
	        else 
           {
              pt = (PWSTR)LocalAlloc(0, (m_strName.GetLength()+1)*sizeof(TCHAR));
              if ( pt )
                 //This may not be a safe usage. pt is LPTSTR. Consider fix.
                 wcscpy(pt, (LPCTSTR)m_strName);
           }

           if ( pt ) 
           {
              if ( prv->Value ) 
                 prvpt = prv->Value;
              prv->Value = pt;
              
              if( QueryMultiSZ() ) //Raid #686565, yanggao, 8/22/2002
              {
                 //Raid #506090, 12/14/2001, yanggao
                 //Delete space and empty newlines
                 UpdateData(TRUE);
                 LPTSTR sz = SZToMultiSZ(pt);
                 if( sz )
                 {
                    m_strName = sz;
                    LocalFree(sz);
                 }
                 UpdateData(FALSE);
              }
           } 
	        else 
           {
               // can't allocate buffer error!!
           }

           if( !(this->UpdateProfile()) )
           {
                if ( prv->Value ) 
                    LocalFree(prv->Value);
                prv->Value = prvpt;
           }
           else
           {
                if( prvpt)
                    LocalFree(prvpt);
           }
        }
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}


BOOL CConfigRegString::UpdateProfile()
{
   if ( m_pData->GetBaseProfile() )
   {
      if( !(m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY)) )
      {
          m_pData->Update(m_pSnapin);
          return FALSE;
      }
      else
      {
          m_pData->Update(m_pSnapin);
          return TRUE;
      }
   }
   m_pData->Update(m_pSnapin);
   
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CAttrString message handlers

void CAttrRegString::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   m_strBase.Empty();
   m_strSetting.Empty();

   PSCE_REGISTRY_VALUE_INFO prv;
   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetSetting());

   pResult->GetDisplayName( NULL, m_strSetting, 2 );

   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());
   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;
       if (QueryMultiSZ()) 
	   {
          LPTSTR sz = SZToMultiSZ(prv->Value);
          m_strBase = sz;
          LocalFree(sz);
       } 
	   else 
	   {
          m_strBase = (LPTSTR) prv->Value;
       }
   } 
   else 
       m_bConfigure = FALSE;
}

BOOL CAttrRegString::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      UpdateData(TRUE);

      int status=SCE_STATUS_GOOD;

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2 = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      m_strBase.TrimRight();

      if ( prv ) 
      {
           if (!m_bConfigure) 
		   {
               if ( prv->Value ) 
                   LocalFree(prv->Value);
               prv->Value = NULL;
           } 
		   else 
		   {
               LPTSTR pt = 0;
               if (QueryMultiSZ())
                  pt = MultiSZToSZ(m_strBase);
               else 
			   {
                  pt = (PWSTR)LocalAlloc(0, (m_strBase.GetLength()+1)*sizeof(TCHAR));
                  if ( pt )
                     //This may not be a safe usage. pt is a LPTSTR. Consider fix.
                     wcscpy(pt, (LPCTSTR)m_strBase);
               }
               if ( pt ) 
			   {
                   if ( prv->Value )
                       LocalFree(prv->Value);
                   prv->Value = pt;

                   //Raid #506090, 12/14/2001, yanggao
                   //Delete space and empty newlines
                   UpdateData(TRUE);
                   LPTSTR sz = SZToMultiSZ(pt);
                   if( sz )
                   {
                      m_strBase = sz;
                      LocalFree(sz);
                   }
                   UpdateData(FALSE);
               } 
			   else 
			   {
                   // can't allocate buffer error!!
               }
           }

           status = CEditTemplate::ComputeStatus(prv, prv2);
           UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

//+----------------------------------------------------------------------------------------------
// CAttrRegString::UpdateProfile
//
// This function is called by OnApply after all the data has been retrieved from the dialog.
// Inherited classes can overload this function to update the data as needed.
//
// Arguments:  [status] - The status of [m_pData] from OnApply();
//
//----------------------------------------------------------------------------------------------
void CAttrRegString::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() )
      m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegString message handlers

//+----------------------------------------------------------------------------------------------
// CLocalPolRegString::UpdateProfile
//
// This function is called by OnApply after all the data has been retrieved from the dialog.
// Inherited classes can overload this function to update the data as needed.
//
// Arguments:  [status] - The status of [m_pData] from OnApply();
//
//----------------------------------------------------------------------------------------------
BOOL CLocalPolRegString::UpdateProfile(  )
{
   return m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegString::Initialize(CResult * pResult)
{
   CConfigRegString::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_strName = _T("");
   }
}

/////////////////////////////////////////////////////////////////////////////
// CConfigRegChoice message handlers
void CConfigRegChoice::Initialize(CResult * pResult)
{
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pResult);

   m_strAttrName = pResult->GetAttrPretty();
   m_StartIds=IDS_LM_FULL;

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;
       switch(_wtol(prv->Value)) 
	   {
       case SCE_RETAIN_ALWAYS:
          m_rabRetention = 0;
          break;
       case SCE_RETAIN_AS_REQUEST:
          m_rabRetention = 1;
          break;
       case SCE_RETAIN_NC:
          m_rabRetention = 2;
          break;
       }
   } 
   else 
      m_bConfigure = FALSE;
}

BOOL CConfigRegChoice::OnInitDialog()
{
   CConfigRet::OnInitDialog();

   //
   // load static text for the radio buttons
   //

    CString strText;
    strText.LoadString(m_StartIds);
    SetDlgItemText( IDC_RETENTION, strText );

    strText.LoadString(m_StartIds+1);
    SetDlgItemText( IDC_RADIO2, strText );

    strText.LoadString(m_StartIds+2);
    SetDlgItemText( IDC_RADIO3, strText );

   OnConfigure();

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigRegChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;

      UpdateData(TRUE);

      PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      if ( prv ) 
      {
          if (!m_bConfigure) 
	      {
               if ( prv->Value ) 
                   LocalFree(prv->Value);
               prv->Value = NULL;

          } 
	      else 
	      {
               switch(m_rabRetention) 
			   {
               case 0:
                  dw = SCE_RETAIN_ALWAYS;
                  break;
               case 1:
                  dw = SCE_RETAIN_AS_REQUEST;
                  break;
               case 2:
                  dw = SCE_RETAIN_NC;
                  break;
               }

               if ( prv->Value == NULL )
			   {
                   // allocate buffer
                   prv->Value = (PWSTR)LocalAlloc(0, 4);
			   }
               if ( prv->Value ) 
			   {
                   prv->Value[0] = (int)dw + L'0';
                   prv->Value[1] = L'\0';
               }
			   else 
			   {
                   // can't allocate buffer, error!!
               }
           }

          m_pData->Update(m_pSnapin);
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

/////////////////////////////////////////////////////////////////////////////
// CAttrRegChoice message handlers

void CAttrRegChoice::Initialize(CResult * pData)
{
   DWORD dw = 0;
   // Class hieirarchy is bad - call CAttribute base method directly
   CAttribute::Initialize(pData);

   // Display the last inspected setting in its static box
   pData->GetDisplayName( NULL, m_strLastInspect, 2 );

   // Set the template setting radio button appropriately
   m_strAttrName = pData->GetAttrPretty();
   m_StartIds=IDS_LM_FULL;

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pData->GetBase());

   if ( prv && prv->Value ) 
   {
       m_bConfigure = TRUE;

       switch(_wtol(prv->Value)) 
	   {
       case SCE_RETAIN_ALWAYS:
          m_rabRetention = 0;
          break;
       case SCE_RETAIN_AS_REQUEST:
          m_rabRetention = 1;
          break;
       case SCE_RETAIN_NC:
          m_rabRetention = 2;
          break;
       }
   } 
   else 
   {
      m_bConfigure = FALSE;
   }

}

BOOL CAttrRegChoice::OnInitDialog()
{

   CAttrRet::OnInitDialog();

   //
   // load static text for the radio buttons
   //

    CString strText;
    strText.LoadString(m_StartIds);
    SetDlgItemText( IDC_RETENTION, strText );

    strText.LoadString(m_StartIds+1);
    SetDlgItemText( IDC_RADIO2, strText );

    strText.LoadString(m_StartIds+2);
    SetDlgItemText( IDC_RADIO3, strText );

    CAttrRet::OnInitDialog();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRegChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD	dw = 0;
      int		status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_rabRetention) 
	     {
         case 0:
            dw = SCE_RETAIN_ALWAYS;
            break;
         case 1:
            dw = SCE_RETAIN_AS_REQUEST;
            break;
         case 2:
            dw = SCE_RETAIN_NC;
            break;
         }
      }

      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
      PSCE_REGISTRY_VALUE_INFO prv2=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
          DWORD dw2=SCE_NO_VALUE;
          if ( prv2 ) 
	      {
              //
              // if there is analysis setting (should always have)
              //
              if (prv2->Value ) 
                  dw2 = _wtol(prv2->Value);
		      else 
                  dw2 = SCE_NO_VALUE;
          }

          status = CEditTemplate::ComputeStatus (prv, prv2);
          if ( dw == SCE_NO_VALUE ) 
	      {
              if ( prv->Value )
                  LocalFree(prv->Value);
              prv->Value = NULL;
          } 
	      else 
	      {
              if ( prv->Value == NULL ) 
		      {
                  // allocate buffer
                  prv->Value = (PWSTR)LocalAlloc(0, 4);
              }
              if ( prv->Value ) 
		      {
                  prv->Value[0] = (int)dw + L'0';
                  prv->Value[1] = L'\0';
              } 
		      else 
		      {
                  // can't allocate buffer, error!!
              }
          }

          UpdateProfile( status );
      }
   }

   // Class hieirarchy is bad - call CAttribute base method directly
   return CAttribute::OnApply();
}

void CAttrRegChoice::UpdateProfile( DWORD status )
{
   if ( m_pData->GetBaseProfile() ) 
     m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);

   m_pData->SetStatus(status);
   m_pData->Update(m_pSnapin);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegChoice message handlers
void CLocalPolRegChoice::UpdateProfile(DWORD status)
{
   m_pSnapin->UpdateLocalPolRegValue(m_pData);
}

void CLocalPolRegChoice::Initialize(CResult * pResult)
{
   CConfigRegChoice::Initialize(pResult);
   if (!m_bConfigure) 
   {
      //
      // Since we don't have a UI to change configuration
      // fake it by "configuring" with an invalid setting
      //
      m_bConfigure = TRUE;
      m_rabRetention = 0;
   }
}

BOOL CSnapin::UpdateLocalPolRegValue( CResult *pResult ) {

   if ( !pResult)
      return FALSE;


   PEDITTEMPLATE pLocalDeltaTemplate = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
   if (!pLocalDeltaTemplate) 
      return FALSE;
   
   PSCE_PROFILE_INFO pLocalDelta = pLocalDeltaTemplate->pTemplate;

   pLocalDelta->RegValueCount = 1;
   pLocalDelta->aRegValues = (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase();

   if( pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) )
   {
      //
      // Set the status of the item.
      //
      PSCE_REGISTRY_VALUE_INFO pRviEffective = (PSCE_REGISTRY_VALUE_INFO)pResult->GetSetting();
      DWORD status = pResult->GetStatus();
      if(!pRviEffective || !pRviEffective->Value)
         status = SCE_STATUS_NOT_ANALYZED;
      else
         status = CEditTemplate::ComputeStatus( (PSCE_REGISTRY_VALUE_INFO)pResult->GetBase(), pRviEffective );
      
      pResult->SetStatus(status);
      pResult->Update(this);
      return TRUE;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\regvldlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       regvldlg.h
//
//  Contents:   definition of CSceRegistryValueInfo
//                              CConfigRegEnable
//                              CAttrRegEnable
//                              CLocalPolRegEnable
//                              CConfigRegNumber
//                              CAttrRegNumber
//                              CLocalPolRegNumber
//                              CConfigRegString
//                              CAttrRegString
//                              CLocalPolRegString
//                              CConfigRegChoice
//                              CAttrRegChoice
//                              CLocalPolRegChoice
//
//----------------------------------------------------------------------------
#if !defined(AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "cenable.h"
#include "aenable.h"
#include "lenable.h"
#include "cnumber.h"
#include "anumber.h"
#include "lnumber.h"
#include "cname.h"
#include "astring.h"
#include "lstring.h"
#include "cret.h"
#include "aret.h"
#include "lret.h"


//
// Class to encapsulate the SCE_REGISTRY_VALUE_INFO structure.
class CSceRegistryValueInfo
{
public:
   CSceRegistryValueInfo(
      PSCE_REGISTRY_VALUE_INFO pInfo
      );
   BOOL Attach(
      PSCE_REGISTRY_VALUE_INFO pInfo
      )
      { if(pInfo) {m_pRegInfo = pInfo; return TRUE;} return FALSE; };


   DWORD
   GetBoolValue();               // Returns a boolean type.


   DWORD
   SetBoolValue(              // Sets the boolean value.
      DWORD dwVal
      );

   LPCTSTR
   GetValue()                 // Returns the string pointer of the value
      { return ((m_pRegInfo && m_pRegInfo->Value) ? m_pRegInfo->Value:NULL); };

   DWORD
   GetType()                  // Returns the type reg type of the object.
      { return (m_pRegInfo ? m_pRegInfo->ValueType:0); };

   void
   SetType(DWORD dwType)         // Sets the type of this object.
      { if(m_pRegInfo) m_pRegInfo->ValueType = dwType; };

   LPCTSTR
   GetName()                  // Returns the name of this object.
      { return (m_pRegInfo ? m_pRegInfo->FullValueName:NULL); };

   DWORD
   GetStatus()                // Return status member of this object.
      { return (m_pRegInfo ? m_pRegInfo->Status:ERROR_INVALID_PARAMETER); };
protected:
   PSCE_REGISTRY_VALUE_INFO m_pRegInfo;

};



#define SCE_RETAIN_ALWAYS     0
#define SCE_RETAIN_AS_REQUEST 1
#define SCE_RETAIN_NC         2

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog

class CConfigRegEnable : public CConfigEnable
{
// Construction
public:
   CConfigRegEnable (UINT nTemplateID) :
      CConfigEnable (nTemplateID ? nTemplateID : IDD)
      {
      }
// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegEnable)
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL UpdateProfile(  );

public:
    virtual void Initialize(CResult *pdata);

};

class CAttrRegEnable : public CAttrEnable
{
// Construction
public:
   CAttrRegEnable () : CAttrEnable (IDD)
   {
   }
    virtual void Initialize(CResult *pResult);
    virtual void UpdateProfile( DWORD dwStatus );

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegEnable)
    virtual BOOL OnApply();
    //}}AFX_MSG
};


class CLocalPolRegEnable : public CConfigRegEnable
{
// Construction
public:

   enum { IDD = IDD_LOCALPOL_ENABLE };
   CLocalPolRegEnable() : CConfigRegEnable(IDD)
   {
       m_pHelpIDs = (DWORD_PTR)a227HelpIDs;
       m_uTemplateResID = IDD;
   }
   virtual void Initialize(CResult *pResult);
   virtual BOOL UpdateProfile(  );
};

/////////////////////////////////////////////////////////////////////////////
// CConfigRegNumber dialog

class CConfigRegNumber : public CConfigNumber
{
// Construction
public:
   CConfigRegNumber(UINT nTemplateID);
   // Generated message map functions
   //{{AFX_MSG(CConfigRegNumber)
   virtual BOOL OnApply();
   //}}AFX_MSG
   virtual void UpdateProfile();

public:
   virtual void Initialize(CResult *pResult);
};


/////////////////////////////////////////////////////////////////////////////
// CAttrRegNumber dialog

class CAttrRegNumber : public CAttrNumber
{
// Construction
public:
   CAttrRegNumber();
   virtual void UpdateProfile( DWORD status );
   virtual void Initialize(CResult * pResult);

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegNumber)
    virtual BOOL OnApply();
    //}}AFX_MSG
};


/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegNumber dialog

class CLocalPolRegNumber : public CConfigRegNumber
{
// Construction
public:
        enum { IDD = IDD_LOCALPOL_NUMBER };
   CLocalPolRegNumber();
   virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
   virtual void UpdateProfile();


private:
   BOOL m_bInitialValueSet;
};


/////////////////////////////////////////////////////////////////////////////
// CConfigRegString dialog

class CConfigRegString : public CConfigName
{
// Construction
public:
   CConfigRegString (UINT nTemplateID) :
      CConfigName (nTemplateID ? nTemplateID : IDD)
      {
      }

      virtual void Initialize(CResult * pResult);
// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegString)
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL UpdateProfile( );
    virtual BOOL QueryMultiSZ() { return FALSE; }
};


/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog

class CAttrRegString : public CAttrString
{
// Construction
public:
   CAttrRegString (UINT nTemplateID) :
      CAttrString (nTemplateID ? nTemplateID : IDD)
      {
      }
   virtual void Initialize(CResult * pResult);
   virtual void UpdateProfile( DWORD status );

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRegString)
        // NOTE: the ClassWizard will add member functions here
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual BOOL QueryMultiSZ() { return FALSE; }
};


/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegString dialog

class CLocalPolRegString : public CConfigRegString
{
public:
        enum { IDD = IDD_LOCALPOL_STRING };
   CLocalPolRegString(UINT nTemplateID) : 
        CConfigRegString(nTemplateID ? nTemplateID : IDD)
   {
       m_uTemplateResID = IDD;
   }
   virtual BOOL UpdateProfile(  );
   virtual void Initialize(CResult *pResult);


// Implementation
protected:
};


/////////////////////////////////////////////////////////////////////////////
// CConfigRet dialog

class CConfigRegChoice : public CConfigRet
{
// Construction
public:
   CConfigRegChoice (UINT nTemplateID) :
      CConfigRet (nTemplateID ? nTemplateID : IDD)
      {
      }
    void Initialize(CResult * pResult);

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfigRegChoice)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    //}}AFX_MSG
    virtual void UpdateProfile( DWORD status );
};


/////////////////////////////////////////////////////////////////////////////
// CAttrRegChoice dialog

class CAttrRegChoice : public CAttrRet
{
// construction
public:
    virtual void Initialize(CResult * pResult);
    virtual void UpdateProfile( DWORD status );

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAttrRegChoice)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    //}}AFX_MSG
};

/////////////////////////////////////////////////////////////////////////////
// CLocalPolRegChoice dialog

class CLocalPolRegChoice : public CConfigRegChoice
{
   enum { IDD = IDD_LOCALPOL_REGCHOICES };
// construction
public:
    CLocalPolRegChoice(UINT nTemplateID) : 
      CConfigRegChoice(nTemplateID ? nTemplateID : IDD)
    {
        m_uTemplateResID = IDD;
    }
   virtual void UpdateProfile( DWORD status );
   virtual void Initialize(CResult *pResult);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGVLDLG_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\savetemp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       savetemp.cpp
//
//  Contents:   implementation of CSaveTemplates
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "SaveTemp.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates dialog


CSaveTemplates::CSaveTemplates(CWnd* pParent /*=NULL*/)
   : CHelpDialog(a186HelpIDs, IDD, pParent)
{
   //{{AFX_DATA_INIT(CSaveTemplates)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

void CSaveTemplates::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSaveTemplates)
   DDX_Control(pDX, IDC_TEMPLATE_LIST, m_lbTemplates);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaveTemplates, CHelpDialog)
   //{{AFX_MSG_MAP(CSaveTemplates)
   ON_LBN_SELCHANGE(IDC_TEMPLATE_LIST, OnSelchangeTemplateList)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates message handlers

void CSaveTemplates::OnOK()
{
   CString strInfFile;
   CString strComputerTemplate;
   PEDITTEMPLATE pet = 0;


   int nCount = m_lbTemplates.GetCount();
   while(nCount--) 
   {
      if (m_lbTemplates.GetSel(nCount) == 0) 
      {
         //
         // Item isn't selected, so don't save it
         //
         continue;
      }

      pet = (PEDITTEMPLATE)m_lbTemplates.GetItemData( nCount );
      if (pet) {
         //
         // We found the template in our inf file cache
         // so save it
         //
         pet->Save();
      }
   }
   CDialog::OnOK();
}

void CSaveTemplates::OnCancel()
{
   CDialog::OnCancel();
}

//Raid #668724, yanggao, 8/9/2002
void CSaveTemplates::OnSelchangeTemplateList()
{
   if (m_lbTemplates.GetSelCount() > 0) 
   {
      GetDlgItem(IDOK)->EnableWindow(TRUE); 
   }
   else
   {
      GetDlgItem(IDOK)->EnableWindow(FALSE); 
   }
}

void CSaveTemplates::AddTemplate(LPCTSTR szInfFile, PEDITTEMPLATE pet)
{
   CString strInfFile;

   //
   // Special template.  Do not save.
   //
   if (pet->QueryNoSave()) {
      return;
   }

   //
   // Display the template's friendly name
   //
   CString strL = pet->GetFriendlyName();
   if (strL.IsEmpty()) {
      strL = szInfFile;
   }
   strL.MakeLower();
   m_Templates.SetAt(strL,pet);
}

BOOL CSaveTemplates::OnInitDialog()
{
   CDialog::OnInitDialog();


   POSITION pos = m_Templates.GetStartPosition();
   PEDITTEMPLATE pTemplate = 0;
   CString szKey;
   while(pos) 
   {
      m_Templates.GetNextAssoc(pos,szKey,pTemplate);
      int iIndex = m_lbTemplates.AddString( pTemplate->GetFriendlyName() );
      m_lbTemplates.SetItemData( iIndex, (LPARAM)pTemplate );
   }

   m_lbTemplates.SelItemRange(TRUE,0,m_lbTemplates.GetCount());
   
   RECT temprect; //HScroll to see full template name
   m_lbTemplates.GetWindowRect(&temprect);
   m_lbTemplates.SetHorizontalExtent((temprect.right-temprect.left)*6);

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wsecmgr.rc
//
#define IDS_EXTENSION_DESC              1
#define IDS_NAME                        2
#define IDS_DESC                        3
#define IDS_ATTR                        4
#define IDS_BASE_ANALYSIS               5
#define IDS_SETTING                     6
#define IDS_NODENAME                    7
#define IDS_CONFIGURE                   8
#define IDS_ANALYZE                     9
#define IDS_CONFIGURE_DESC              10
#define IDS_ANALYZE_DESC                11
#define IDS_POLICY                      12
#define IDS_PRIVILEGE                   13
#define IDS_GROUPS                      14
#define IDS_SERVICE                     15
#define IDS_REGISTRY                    16
#define IDS_FILESTORE                   17
#define IDS_PRIVILEGE_DESC              19
#define IDS_GROUPS_DESC                 20
#define IDS_SERVICE_DESC                21
#define IDS_REGISTRY_DESC               22
#define IDS_FILESTORE_DESC              23
#define IDS_TEMPLATE_EDITOR_NAME        24
#define IDS_NOT_SAVED_SUFFIX            25
#define IDS_EXTENSION_NAME              26
#define IDS_SCE_DESC                    27
#define IDS_SAV_DESC                    28
#define IDS_DELETE_CONFIRM              29
#define IDS_ABOUT_SECMGR                30
#define IDS_DELETE_ALL_ITEMS            30
#define IDS_ANALYZE_PROFILE             31
#define IDS_GENERATE_PROFILE            34
#define IDS_ADD_FILES                   35
#define IDS_ADD_LOCATION                36
#define IDS_NEW_PROFILE                 37
#define IDS_REMOVE_LOCATION             38
#define IDS_RELOAD_LOCATION             39
#define IDS_APPLY_PROFILE               40
#define IDS_IMPORT_POLICY_FAIL          42
#define IDS_SAVEAS_PROFILE              43
#define IDS_COPY_PROFILE                44
#define IDS_PASTE_PROFILE               45
#define IDS_RSOP_GPO                    46
#define IDS_REFRESH_AREA                47
#define IDS_SECURITY_REQUIRED           48
#define IDS_CANT_ASSIGN_SECURITY        49
#define IDS_PASSWORD_CATEGORY           50
#define IDS_MAX_PAS_AGE                 51
#define IDS_MIN_PAS_AGE                 52
#define IDS_MIN_PAS_LEN                 53
#define IDS_PAS_UNIQUENESS              54
#define IDS_PAS_COMPLEX                 55
#define IDS_REQ_LOGON                   56
#define IDS_LOCKOUT_CATEGORY            57
#define IDS_LOCK_COUNT                  58
#define IDS_LOCK_RESET_COUNT            59
#define IDS_LOCK_DURATION               60
#define IDS_CONFIRM_DELETE_TEMPLATE     61
#define IDS_ANALYZE_NT4                 62
#define IDS_FORCE_LOGOFF                63
#define IDS_NEW_ADMIN                   65
#define IDS_NEW_GUEST                   67
#define IDS_REFRESH_LOCALPOL            68
#define IDS_GROUP_NAME                  69
#define IDS_EVENT_LOG                   70
#define IDS_SYS_LOG_MAX                 71
#define IDS_SYS_LOG_RET                 72
#define IDS_SYS_LOG_DAYS                73
#define IDS_SEC_LOG_MAX                 74
#define IDS_SEC_LOG_RET                 75
#define IDS_SEC_LOG_DAYS                76
#define IDS_APP_LOG_MAX                 77
#define IDS_APP_LOG_RET                 78
#define IDS_APP_LOG_DAYS                79
#define IDS_CRASH_LOG_FULL              80
#define IDS_EVENT_AUDIT                 81
#define IDS_EVENT_ON                    82
#define IDS_SYSTEM_EVENT                83
#define IDS_LOGON_EVENT                 84
#define IDS_OBJECT_ACCESS               85
#define IDS_PRIVILEGE_USE               86
#define IDS_POLICY_CHANGE               87
#define IDS_ACCOUNT_MANAGE              88
#define IDS_PROCESS_TRACK               89
#define IDS_OTHER_CATEGORY              90
#define IDS_NO_POLICY                   92
#define IDS_CANT_ADD_MEMBER             95
#define IDS_CANT_SHOW_SECURITY          96
#define IDS_CANT_ADD_USER               97
#define IDS_CANT_ADD_DSOBJECT           98
#define IDS_CANT_ADD_FOLDER             99
#define IDS_GRP_MEMBERS                 100
#define IDS_GRP_MEMBEROF                101
#define IDS_NO_DBCS                     102
#define IDS_PERMISSION                  103
#define IDS_AUDITING                    104
#define IDD_CONFIG_PRIVS                106
#define IDS_CANT_ADD_FILE               106
#define IDD_CONFIG_MEMBERSHIP           107
#define IDS_INVALID_NAME                107
#define IDS_ERROR_GENERATE              108
#define IDS_CANT_ADD_KEY                109
#define IDS_FILE_GEN_ALL                110
#define IDS_FILE_GEN_MODIFY             111
#define IDS_FILE_GEN_READ               112
#define IDS_FILE_GEN_LIST               113
#define IDS_FILE_SPEC_READ              114
#define IDS_FILE_SPEC_WRITE             115
#define IDS_FILE_SPEC_EXECUTE           116
#define IDS_FILE_SPEC_DELETE            117
#define IDS_NONE                        120
#define IDS_KEY_ALL_ACCESS              121
#define IDS_KEY_READ                    122
#define IDS_KEY_WRITE                   123
#define IDS_KEY_QUERY_VALUE             124
#define IDS_KEY_SET_VALUE               125
#define IDS_KEY_CREATE_SUB_KEY          126
#define IDS_KEY_ENUMERATE_SUB_KEYS      127
#define IDS_KEY_NOTIFY                  128
#define IDS_KEY_CREATE_LINK             129
#define IDS_KEY_EXECUTE                 130
#define IDS_CANT_CREATE_THREAD          131
#define IDS_ERR_INVALIDACCOUNT          132
#define IDS_STATIC_LOG_NAME             141
#define IDS_ANALYZE_TITLE               143
#define IDS_SECURITY_SETTING_DESC       144
#define IDS_SECMGR_VERSION              146
#define IDS_SECMGR_DESC                 147
#define IDS_LAST_ANALYSIS               148
#define IDS_PROFILE_DESC                149
#define IDS_NO_ANALYSIS                 150
#define IDS_NEVER_ANALYSIS              151
#define IDS_TITLE_ABOUT_SECMGR          152
#define IDS_TITLE_ABOUT_ANALYSIS        153
#define IDS_ADDLOCATION_TITLE           154
#define IDS_COL_OBJECT                  165
#define IDS_COL_BAD_COUNT               166
#define IDD_ATTR_STRING                 167
#define IDD_ATTR_NUMBER                 168
#define IDS_OPEN_PROFILE                168
#define IDD_ATTR_ENABLE                 169
#define IDS_PROFILE_FILTER              169
#define IDD_ATTR_AUDIT                  170
#define IDS_PROFILE_DEF_EXT             170
#define IDS_OPEN_LOGFILE                171
#define IDS_LOGFILE_DEF_EXT             172
#define IDD_ANALYZE_SECURITY            173
#define IDS_LOGFILE_FILTER              173
#define IDD_REGISTRY_DIALOG             177
#define IDD_CONFIG_AUDIT                180
#define IDD_CONFIG_NUMBER               181
#define IDD_CONFIG_ENABLE               182
#define IDD_CONFIG_NAME                 183
#define IDD_SAVE_TEMPLATES              186
#define IDD_ATTR_RET                    189
#define IDD_CONFIG_RET                  190
#define IDD_ATTR_RIGHT                  191
#define IDS_TEMPLATE_LOCATION_KEY       193
#define IDD_ANALYSIS_GENERATE           193
#define IDS_ERROR_CANT_OPEN_PROFILE     194
#define IDD_ANALYSIS_SERVICE            194
#define IDS_ERROR_CANT_GET_PROFILE_INFO 195
#define IDD_CONFIG_SERVICE              195
#define IDS_ERROR_NO_ANALYSIS_INFO      196
#define IDS_FOREVER                     197
#define IDD_CONFIG_OBJECT               197
#define IDS_AS_NEEDED                   198
#define IDD_ATTR_OBJECT                 198
#define IDI_SCE                         199
#define IDS_BY_DAYS                     199
#define IDD_ANALYZE_PROGRESS            199
#define IDI_SCE_APP                     199
#define IDI_AREA_CHECKED                200
#define IDS_MANUALLY                    200
#define IDS_ENABLED                     201
#define IDI_AREA_CURRENT                201
#define IDC_STATIC_DESC                 202
#define IDS_DISABLED                    202
#define IDC_STATIC_TITLE                203
#define IDS_ON                          203
#define IDC_PROGRESS                    204
#define IDS_OFF                         204
#define IDS_NOT_CONFIGURED              205
#define IDB_ICON16                      205
#define IDB_TOOLBAR1                    207
#define IDB_TOOLBAR2                    208
#define IDD_ABOUT_SECMGR                209
#define IDD_APPLY                       210
#define IDS_COL_MEMBERSHIP              210
#define IDS_COL_MEMBEROF                211
#define IDB_ICON32                      211
#define IDD_APPLY_CONFIGURATION         212
#define IDS_HKCR                        214
#define IDD_ATTR_GROUP                  214
#define IDC_DESCRIPTION                 215
#define IDS_HKLM                        215
#define IDD_PERFORM_ANALYSIS            215
#define IDS_HKU                         216
#define IDD_ASSIGN_PROFILE              216
#define IDS_SCESTATUS_SUCCESS           217
#define IDD_ASSIGN_CONFIG_CHECK         217
#define IDD_SET_DESCRIPTION             218
#define IDB_ARROW                       220
#define IDB_CHECK                       221
#define IDC_DATABASE_DIR                223
#define IDB_SCE_LARGE                   223
#define IDC_CHANGE_PROFILE              224
#define IDB_SCE_SMALL                   224
#define IDC_LAST_ANALYSIS_TIME          225
#define IDD_NEW_PROFILE                 225
#define IDC_PROFILE                     226
#define IDD_LOCALPOL_AUDIT              226
#define IDC_ERROR_LOG                   227
#define IDC_NC_POLICY                   227
#define IDD_LOCALPOL_ENABLE             227
#define IDC_CHANGE_DATABASE_DIR         228
#define IDC_TITLE                       228
#define IDC_NC_GROUPS                   228
#define IDD_LOCALPOL_NUMBER             228
#define IDC_CHANGE_ERROR_LOG            229
#define IDC_CURRENT                     229
#define IDC_NC_PRIVELEGES               229
#define IDC_TITLE_MEMBER_OF             229
#define IDS_UNKNOWN_ERROR               229
#define IDD_LOCALPOL_RET                229
#define IDC_NC_REGISTRY                 230
#define IDD_LOCALPOL_STRING             230
#define IDC_NC_FILESYSTEM               231
#define IDD_LOCALPOL_RIGHT              231
#define IDS_DEFAULT_TEMPLATE_DIR        232
#define IDC_LAST_CONFIG_TIME            232
#define IDC_SPIN                        233
#define IDS_SE_NETWORK_LOGON_RIGHT      233
#define IDC_NC_SERVICE                  233
#define IDC_NEW                         234
#define IDS_SE_INTERACTIVE_LOGON_RIGHT  234
#define IDC_UNITS                       235
#define IDS_SAVE_FAILED                 235
#define IDD_LOCALPOL_REGCHOICES         235
#define IDC_IGNORE                      236
#define IDS_SAVE_PROFILE                236
#define IDD_CONFIG_REGCHOICES           236
#define IDC_ENABLED                     237
#define IDS_SECEDIT_KEY                 237
#define IDD_ATTR_REGCHOICES             237
#define IDD_WARNING_DIALOG              238
#define IDC_DISABLED                    238
#define IDS_ADDFOLDER_TITLE             238
#define IDS_ADD_FOLDER                  239
#define IDD_DOMAIN_AUDIT                239
#define IDS_ADD_KEY                     240
#define IDD_DOMAIN_ENABLE               240
#define IDC_CHANGE                      241
#define IDS_ADD_GROUP                   241
#define IDB_BITMAP1                     241
#define IDD_DOMAIN_MEMBERSHIP           241
#define IDC_ACCEPT                      242
#define IDB_TEMPLATE                    242
#define IDD_DOMAIN_NAME                 242
#define IDC_CHANGE_SUCCESS              243
#define IDB_ANALYSIS                    243
#define IDD_DOMAIN_NUMBER               243
#define IDC_CHANGE_FAILED               244
#define IDC_CURRENT_MEMBER_OF           244
#define IDI_TEMPLATE                    244
#define IDD_DOMAIN_OBJECT               244
#define IDC_RECC_MEMBER_OF              245
#define IDI_LOCALPOLICY                 245
#define IDD_DOMAIN_PRIVS                245
#define IDC_ADD                         246
#define IDI_POLICY                      246
#define IDD_DOMAIN_REGCHOICES           246
#define IDC_REMOVE                      247
#define IDI_ANALYSIS                    247
#define IDD_DOMAIN_RET                  247
#define IDC_ADD_MEMBEROF                248
#define IDS_COL_SERVICE                 248
#define IDB_POLICY                      248
#define IDD_DOMAIN_SERVICE              248
#define IDC_REMOVE_MEMBEROF             249
#define IDS_STARTUP                     249
#define IDB_LOCALPOLICY                 249
#define IDC_ACCEPT_CURRENT              250
#define IDS_INSPECTED                   250
#define IDI_WARNING_INFORMATIONAL       250
#define IDS_CONFIGURED                  251
#define IDS_AUTOMATIC                   252
#define IDC_RECC_PRIV                   253
#define IDS_MANUAL                      253
#define IDD_CONFIG_REGMULTISZ           253
#define IDC_CURRENT_PRIV                254
#define IDS_OK                          254
#define IDD_ATTR_REGMULTISZ             254
#define IDS_INVESTIGATE                 255
#define IDD_LOCALPOL_REGMULTISZ         255
#define IDS_CONFIG_SECURITY_PAGE        256
#define IDD_DOMAIN_REGMULTISZ           256
#define IDC_APPLY                       257
#define IDS_ANALYSIS_SECURITY_PAGE      257
#define IDD_CONFIG_REGFLAGS             257
#define IDS_SECURITY_PAGE               258
#define IDD_ATTR_REGFLAGS               258
#define IDS_SERVICE_ALL                 259
#define IDD_LOCALPOL_REGFLAGS           259
#define IDC_VIEW                        260
#define IDS_SERVICE_READ                260
#define IDD_DOMAIN_REGFLAGS             260
#define IDD_ADD_OBJECT                  261
#define IDC_VIEW_EDIT                   261
#define IDS_SERVICE_WRITE               261
#define IDS_GROUP_MEMBER_OF_HEADER      262
#define IDD_PRECEDENCE                  262
#define IDS_GROUP_MEMBERS_HEADER        263
#define IDS_GROUP_MEMBER_OF_PAGE_TITLE  264
#define IDC_CURRENT_MEMBERS             265
#define IDS_GROUP_MEMBERS_PAGE_TITLE    265
#define IDC_RECC_MEMBERS                266
#define IDS_ACCOUNT_POLICY              266
#define IDS_ACCOUNT_DESC                267
#define IDS_LOCAL_POLICY                268
#define IDS_LOCAL_DESC                  269
#define IDS_EVENTLOG_POLICY             270
#define IDC_SUCCESSFUL                  271
#define IDS_EVENTLOG_DESC               271
#define IDC_FAILED                      272
#define IDS_DIRECTORY_ACCESS            272
#define IDS_ACCOUNT_LOGON               273
#define IDC_VALUE                       275
#define IDS_SYS_LOG_GUEST               275
#define IDS_SEC_LOG_GUEST               276
#define IDS_APP_LOG_GUEST               277
#define IDS_LM_FULL                     278
#define IDS_OBJECT_IGNORE               281
#define IDC_NAME                        283
#define IDS_OBJECT_OVERWRITE            284
#define IDS_SE_BATCH_LOGON_RIGHT        286
#define IDC_GRANTLIST                   287
#define IDS_SE_SERVICE_LOGON_RIGHT      287
#define IDC_MEMBEROF                    288
#define IDS_DSOBJECT                    288
#define IDS_DSOBJECT_DESC               289
#define IDC_MEMBERS                     290
#define IDS_ADD_DSOBJECT                290
#define IDC_TITLE_MEMBERS               291
#define IDS_FILE_GENERIC_READ           291
#define IDC_ADD_MEMBER                  292
#define IDS_FILE_GENERIC_WRITE          292
#define IDC_REMOVE_MEMBER               293
#define IDS_FILE_SPEC_READ_DATA         293
#define IDC_REGTREE                     294
#define IDS_FILE_SPEC_READ_ATTR         294
#define IDC_TEMPLATE_LIST               295
#define IDS_FILE_SPEC_READ_EA           295
#define IDS_FILE_SPEC_WRITE_DATA        296
#define IDS_FILE_SPEC_APPEND_DATA       297
#define IDS_FILE_SPEC_WRITE_ATTR        298
#define IDS_FILE_SPEC_WRITE_EA          299
#define IDS_FILE_SPEC_DELETE_CHILD      300
#define IDC_LAST_INSPECT                301
#define IDS_STD_DELETE                  301
#define IDC_RETENTION                   302
#define IDS_STD_READ_CONTROL            302
#define IDC_ATTRIBUTE_NAME              303
#define IDS_STD_WRITE_DAC               303
#define IDC_CONFIGURE                   304
#define IDS_STD_WRITE_OWNER             304
#define IDC_RIGHTS                      305
#define IDS_STD_SYNCHRONIZE             305
#define IDC_STATIC_FILENAME             306
#define IDS_FILE_GENERAL_PUBLISH        306
#define IDC_BASESD                      307
#define IDC_OVERWRITE                   307
#define IDS_FILE_GENERAL_DEPOSIT        307
#define IDC_CURRENTSD                   308
#define IDC_RADIO2                      308
#define IDS_FILE_GENERIC_EXECUTE        308
#define IDC_RADIO3                      309
#define IDS_FILE_FOLDER                 309
#define IDS_FILE_FOLDER_SUBITEMS        310
#define IDC_SECURITY                    311
#define IDS_FILE_FOLDER_SUBFOLDER       311
#define IDS_FILE_FOLDER_FILE            312
#define IDC_TEMPLATE_SECURITY           313
#define IDS_FILE_SUBITEMS_ONLY          313
#define IDC_INSPECTED_SECURITY          314
#define IDS_FILE_SUBFOLDER_ONLY         314
#define IDC_INSPECTED                   315
#define IDS_FILE_FILE_ONLY              315
#define IDC_HEADER                      316
#define IDS_KEY_FOLDER                  316
#define IDS_KEY_FOLDER_SUBFOLDER        317
#define IDC_AUTOINHERIT                 318
#define IDS_KEY_SUBFOLDER_ONLY          318
#define IDC_NOAUTOINHERIT               319
#define IDS_KEY_FOLDER_SUBITEMS         319
#define IDS_KEY_SUBITEMS_ONLY           320
#define IDC_CHECK                       320
#define IDS_SERVICE_EXECUTE             321
#define IDC_PROGRESS1                   321
#define IDS_SERVICE_QUERY_CONFIG        322
#define IDC_ICON1                       322
#define IDS_SERVICE_CHANGE_CONFIG       323
#define IDC_ICON2                       323
#define IDS_SERVICE_QUERY_STATUS        324
#define IDC_ICON3                       324
#define IDS_SERVICE_ENUMERATE           325
#define IDC_ICON4                       325
#define IDS_SERVICE_START               326
#define IDC_ICON5                       326
#define IDS_SERVICE_STOP                327
#define IDC_ICON6                       327
#define IDS_SERVICE_PAUSE               328
#define IDC_ICON7                       328
#define IDS_SERVICE_INTERROGATE         329
#define IDS_SERVICE_USER_CONTROL        330
#define IDC_AREA1                       330
#define IDS_DS_ALL                      331
#define IDC_AREA2                       331
#define IDC_LI_TITLE                    331
#define IDS_DS_READ                     332
#define IDC_AREA3                       332
#define IDC_TEMPLATE_TITLE              332
#define IDS_DS_WRITE                    333
#define IDC_AREA4                       333
#define IDC_CHECK1                      333
#define IDC_AREA5                       334
#define IDC_INCREMENTAL                 334
#define IDS_DS_ACTRL_CREATE             335
#define IDC_AREA6                       335
#define IDC_LOG_FILE                    335
#define IDS_DS_ACTRL_DELETE             336
#define IDC_AREA7                       336
#define IDC_BROWSE                      336
#define IDS_DS_ACTRL_LIST               337
#define IDS_DS_ACTRL_SELF               338
#define IDC_ERROR                       338
#define IDC_REGKEY                      339
#define IDS_DS_ACTRL_READ_PROP          339
#define IDS_DS_ACTRL_WRITE_PROP         340
#define IDC_VERB                        340
#define IDS_DS_FOLDER                   341
#define IDC_CONFIG_NAME                 341
#define IDS_DS_FOLDER_SUBFOLDER         342
#define IDC_EFFECTIVE_POLICY            342
#define IDS_DS_SUBFOLDER_ONLY           343
#define IDC_CHOICES                     343
#define IDS_COMPUTER_TEMPLATE           344
#define IDC_FAILEDLIST                  344
#define IDS_NO_LOCKOUT                  345
#define IDC_WARNING                     345
#define IDS_CHANGE_IMMEDIATELY          346
#define IDS_PERMIT_BLANK                347
#define IDS_NO_HISTORY                  348
#define IDS_PASSWORD_EXPIRE             349
#define IDC_ANALYZED_COMPUTER_STRING_STATIC 349
#define IDS_PASSWORD_CHANGE             350
#define IDC_CHANGE_TEMPLATE_SETTING_STATIC 350
#define IDS_PASSWORD_LEN                351
#define IDC_ANALYZED_COMPUTER_SETTING_STATIC 351
#define IDS_PASSWORD_REMEMBER           352
#define IDC_REGISTRY_STATIC             352
#define IDS_LOCKOUT_AFTER               353
#define IDC_SELECT_TO_SAVE_STATIC       353
#define IDS_DURATION                    354
#define IDC_LAST_INSPECTED_STATICSTATIC 354
#define IDS_OVERWRITE_EVENT             355
#define IDC_ASSIGNED_TO_STATIC          355
#define IDS_PASSWORD_FOREVER            356
#define IDC_CONFIGURATION_SETTING_STATIC 356
#define IDS_LOCKOUT_FOREVER             357
#define IDC_ANALYZED_SETTING_STATIC     357
#define IDC_SERVICE_STARTUP_MODE_STATIC 358
#define IDS_CLEAR_PASSWORD              359
#define IDC_TEMPLATE_SETTING_STATIC     359
#define IDS_KERBEROS_CATEGORY           360
#define IDC_ERROR_LOG_PROFILE_PATH_STATIC 360
#define IDS_KERBEROS_VALIDATE_CLIENT    361
#define IDC_DESCRIPTION_STATIC          361
#define IDS_KERBEROS_MAX_CLOCK          362
#define IDC_TEMPLATE_NAME_STATIC        362
#define IDS_KERBEROS_MAX_SERVICE        363
#define IDC_EFFECTIVE_POLICY_SETTING_STATIC 363
#define IDS_KERBEROS_MAX_AGE            364
#define IDC_CHANGE_LOCAL_POLICY_TO_STATIC 364
#define IDS_KERBEROS_RENEWAL            365
#define IDC_LOCAL_POLICY_STATIC         365
#define IDS_ADDMEMBER                   366
#define IDC_EFFECTIVE_POLICY_STATIC     366
#define IDS_CANT_DISPLAY_ERROR_OOM      368
#define IDC_SELECTED_KEY                368
#define IDS_ERROR_GETTING_LAST_ANALYSIS 369
#define IDC_DEFINE_GROUP                369
#define IDS_ERROR_CANT_SAVE             370
#define IDC_STATIC_DESCRIPTION          370
#define IDS_QUERY_DELETE                371
#define IDS_ANALYSIS_VIEWER_NAME        372
#define IDC_STATIC_LABEL                372
#define IDC_STATIC_DESCRIPTION2         372
#define IDS_MISMATCH                    373
#define IDS_ASSIGN_CONFIGURATION        374
#define IDS_CANT_OPEN_LOG_FILE          376
#define IDS_LOGFILE_PICKER_TITLE        377
#define IDS_DEFAULT_DB_EXTENSION        378
#define IDS_DB_FILTER                   379
#define IDS_APPLY_CONFIGURATION         380
#define IDS_LOG_FILE_FOR_APPLY          381
#define IDC_SETTING                     381
#define IDS_SECURITY_MENU_ITEM          382
#define IDC_CONFIG                      382
#define IDS_SECURITY_MENU_ITEM_DESC     383
#define IDC_PREVENT                     383
#define IDS_CONFIGURATION_KEY           384
#define IDC_INHERIT                     384
#define IDS_SECURITY_MENU               385
#define IDS_ENV_VARS_REG_VALUE          386
#define IDC_NO_MEMBERS                  386
#define IDS_DEF_ENV_VARS                387
#define IDC_NO_MEMBER_OF                387
#define IDS_OPEN_DB                     388
#define IDS_NEW_DB                      389
#define IDC_CHECKBOX                    389
#define IDS_DESCRIBE                    390
#define IDC_PRECEDENCE_LIST             391
#define IDS_HELPFILE                    392
#define IDC_ERROR_ICON                  392
#define IDC_ERROR_TEXT                  393
#define IDC_SUCCESS_TEXT                394
#define IDS_ADD_FILE_FILTER             395
#define IDC_WARNING_ICON                395
#define IDS_SAM_NAME                    396
#define IDC_RANGEERROR                  396
#define IDS_DBERR_OTHER_ERROR           397
#define IDS_DBERR_INVALID_DATA          398
#define IDS_DBERR_PROFILE_NOT_FOUND     399
#define IDS_DBERR_BAD_FORMAT            400
#define IDS_DBERR_NOT_ENOUGH_RESOURCE   401
#define IDS_DBERR_ACCESS_DENIED         402
#define IDS_DB_DEFAULT                  403
#define IDS_PROFILE_DIRTY_SAVE          404
#define IDS_IMPORT_EXISTS               405
#define IDS_ALL_SELECTED_FILES          406
#define IDS_DENY_LOGON_LOCALLY          407
#define IDS_DENY_LOGON_NETWORK          408
#define IDS_DENY_LOGON_SERVICE          409
#define IDS_DENY_LOGON_BATCH            410
#define IDS_ADDGROUP_TITLE              411
#define IDS_ADDGROUP_GROUP              412
#define IDS_NOT_ANALYZED                413
#define IDS_ERROR_VALUE                 414
#define IDS_NOT_DEFINED                 415
#define IDS_SUGGESTSETTING              416
#define IDS_EXPORT_LOCAL                417
#define IDS_EXPORT_EFFECTIVE            418
#define IDS_HTML_OPENDATABASE           419
#define IDS_HTMLERR_HEADER              420
#define IDS_HTMLERR_END                 421
#define IDS_DBERR5_PROFILE_NOT_FOUND    422
#define IDS_LCERR5_NOTFOUND_RESOLVE     423
#define IDS_DBERR5_ACCESS_DENIED        424
#define IDS_VIEW_LOGFILE                425
#define IDS_DBERR5_NO_ANALYSIS          426
#define IDS_BAD_LOCATION                427
#define IDS_BASE_TEMPLATE               428
#define IDS_POLICY_SETTING              429
#define IDS_SECURE_WIZARD               430
#define IDS_IMPORT_POLICY_INVALID       431
#define IDS_ENABLE_ADMIN                432
#define IDS_ENABLE_GUEST                433
#define IDS_SECURITY_PROPERTIES         434  
#define IDS_EMPTY_NAME_STRING           435
#define IDS_NO_MIN                      436
#define IDS_INVALID_STRING              437
#define IDS_DB_NAME_SPACE_NOT_ENOUGH    438
#define IDS_INVALID_FILENAME            439
#define IDS_ERROR_NO_START_MODE         440
#define IDS_NOT_DELETE_ITEM             441
#define IDS_GROUP_TITLE_WRAP            442
#define IDS_RESET_COUNT                 443
#define IDS_DESCRIBE_PROFILE            444
#define IDS_INVALID_DESC                445
#define IDS_TEMPLATE_SET                446
#define IDS_POLICY_SET                  447
#define IDS_SAVE_FAILED_NOTE            449
#define IDS_OBJECT_FAILED_NOTE          450
#define IDS_INVALID_FOLDER              451
#define IDS_COMPUTER_FOLDER             452
#define IDS_PATH_TOO_LONG               453
#define IDS_COMPUTER_NET                454
#define IDS_ACTAS_PART                  455
#define IDS_ADD_WORKSTATION             456
#define IDS_BACKUP_FILES                457
#define IDS_BYPASS_CHECK                458
#define IDS_CHANGE_SYSTEMTIME           459
#define IDS_CREATE_PAGEFILE             460
#define IDS_CREATE_TOKEN                461
#define IDS_CREATE_SHARED_OBJ           462
#define IDS_DEBUG_PROGRAM               463
#define IDS_FORCE_SHUTDOWN              464
#define IDS_SECURITY_AUDIT              465
#define IDS_MEMORY_ADJUST               466
#define IDS_INCREASE_PRIORITY           467
#define IDS_LOAD_DRIVER                 468
#define IDS_LOCK_PAGE                   469
#define IDS_LOGON_BATCH                 470
#define IDS_LOGON_SERVICE               471
#define IDS_LOGON_LOCALLY               472
#define IDS_MANAGE_LOG                  473
#define IDS_MODIFY_ENVIRONMENT          474
#define IDS_SINGLE_PROCESS              475
#define IDS_SYS_PERFORMANCE             476
#define IDS_PROCESS_TOKEN               477
#define IDS_RESTORE_FILE                478
#define IDS_SHUTDOWN                    479
#define IDS_TAKE_OWNERSHIP              480
#define IDS_DENY_COMPUTER_NET           481
#define IDS_DENY_LOG_BATCH              482
#define IDS_DENY_LOG_SERVICE            483
#define IDS_DENY_LOG_LOCALLY            484
#define IDS_REMOVE_COMPUTER             485
#define IDS_SYNC_DATA                   486
#define IDS_ENABLE_DELEGATION           487
#define IDS_MAITENANCE                  488
#define IDS_LOG_TERMINAL                489
#define IDS_DENY_LOG_TERMINAL           490
#define IDS_LDAPSERVERINTEGRITY         491
#define IDS_SIGNSECURECHANNEL           492
#define IDS_SEALSECURECHANNEL           493
#define IDS_REQUIRESTRONGKEY            494
#define IDS_REQUIRESIGNORSEAL           495
#define IDS_REFUSEPASSWORDCHANGE        496
#define IDS_MAXIMUMPASSWORDAGE          497
#define IDS_DISABLEPASSWORDCHANGE       498
#define IDS_LDAPCLIENTINTEGRITY         499
#define IDS_REQUIRESECURITYSIGNATURE    500
#define IDS_ENABLESECURITYSIGNATURE     501
#define IDS_ENABLEPLAINTEXTPASSWORD     502
#define IDS_RESTRICTNULLSESSACCESS      503
#define IDS_SERREQUIRESECURITYSIGNATURE 504
#define IDS_NULLSESSIONSHARES           505
#define IDS_NULLSESSIONPIPES            506
#define IDS_SERENABLESECURITYSIGNATURE  507
#define IDS_ENABLEFORCEDLOGOFF          508
#define IDS_AUTODISCONNECT              509
#define IDS_PROTECTIONMODE              510
#define IDS_CLEARPAGEFILEATSHUTDOWN     511
#define IDS_OBCASEINSENSITIVE           512
#define IDS_MACHINE                     513
#define IDS_ADDPRINTERDRIVERS           514
#define IDS_SUBMITCONTROL               515
#define IDS_RESTRICTANONYMOUSSAM        516
#define IDS_RESTRICTANONYMOUS           517
#define IDS_NOLMHASH                    518
#define IDS_NODEFAULTADMINOWNER         519
#define IDS_NTLMMINSERVERSEC            520
#define IDS_NTLMMINCLIENTSEC            521
#define IDS_LMCOMPATIBILITYLEVEL        522
#define IDS_LIMITBLANKPASSWORDUSE       523
#define IDS_FULLPRIVILEGEAUDITING       524
#define IDS_FORCEGUEST                  525
#define IDS_FIPSALGORITHMPOLICY         526
#define IDS_EVERYONEINCLUDESANONYMOUS   527
#define IDS_DISABLEDOMAINCREDS          528
#define IDS_CRASHONAUDITFAIL            529
#define IDS_AUDITBASEOBJECTS            530
#define IDS_UNDOCKWITHOUTLOGON          531
#define IDS_SHUTDOWNWITHOUTLOGON        532
#define IDS_SCFORCEOPTION               533
#define IDS_LEGALNOTICETEXT             534
#define IDS_LEGALNOTICECAPTION          535
#define IDS_DONTDISPLAYLASTUSERNAME     536
#define IDS_DISABLECAD                  537
#define IDS_SCREMOVEOPTION              538
#define IDS_PASSWORDEXPIRYWARNING       539
#define IDS_FORCEUNLOCKLOGON            540
#define IDS_CACHEDLOGONSCOUNT           541
#define IDS_ALLOCATEFLOPPIES            542
#define IDS_ALLOCATEDASD                543
#define IDS_ALLOCATECDROMS              544
#define IDS_SETCOMMAND                  545
#define IDS_SECURITYLEVEL               546
#define IDS_REGPOLICY                   547
#define IDS_RESTRICTED_GROUPS           548
#define IDS_SYSTEM_SERVICES             549
#define IDS_REGISTRY_SETTING            550
#define IDS_FILESYSTEM_SETTING          551
#define IDS_PAS_UNIQUENESS_HTOPIC               552
#define IDS_MAX_PAS_AGE_HTOPIC                  553
#define IDS_MIN_PAS_AGE_HTOPIC                  554
#define IDS_MIN_PAS_LEN_HTOPIC                  555
#define IDS_PAS_COMPLEX_HTOPIC                  556
#define IDS_CLEAR_PASSWORD_HTOPIC               557
#define IDS_LOCK_DURATION_HTOPIC                558
#define IDS_LOCK_COUNT_HTOPIC                   559
#define IDS_LOCK_RESET_COUNT_HTOPIC             560
#define IDS_KERBEROS_VALIDATE_CLIENT_HTOPIC     561
#define IDS_KERBEROS_MAX_SERVICE_HTOPIC         562
#define IDS_KERBEROS_MAX_AGE_HTOPIC             563
#define IDS_KERBEROS_RENEWAL_HTOPIC             564
#define IDS_KERBEROS_MAX_CLOCK_HTOPIC           565
#define IDS_ACCOUNT_LOGON_HTOPIC                566
#define IDS_ACCOUNT_MANAGE_HTOPIC               567
#define IDS_DIRECTORY_ACCESS_HTOPIC             568
#define IDS_LOGON_EVENT_HTOPIC                  569
#define IDS_OBJECT_ACCESS_HTOPIC                570
#define IDS_POLICY_CHANGE_HTOPIC                571
#define IDS_PRIVILEGE_USE_HTOPIC                572
#define IDS_PROCESS_TRACK_HTOPIC                573
#define IDS_SYSTEM_EVENT_HTOPIC                 574
#define IDS_COMPUTER_NET_HTOPIC                 575
#define IDS_ACTAS_PART_HTOPIC                   576
#define IDS_ADD_WORKSTATION_HTOPIC              577
#define IDS_MEMORY_ADJUST_HTOPIC                578
#define IDS_LOG_TERMINAL_HTOPIC                 579
#define IDS_BACKUP_FILES_HTOPIC                 580
#define IDS_BYPASS_CHECK_HTOPIC                 581
#define IDS_CHANGE_SYSTEMTIME_HTOPIC            582
#define IDS_CREATE_PAGEFILE_HTOPIC              583
#define IDS_CREATE_TOKEN_HTOPIC                 584
#define IDS_CREATE_SHARED_OBJ_HTOPIC            585
#define IDS_DEBUG_PROGRAM_HTOPIC                586
#define IDS_DENY_COMPUTER_NET_HTOPIC            587
#define IDS_DENY_LOG_BATCH_HTOPIC               588
#define IDS_DENY_LOG_SERVICE_HTOPIC             589
#define IDS_DENY_LOG_LOCALLY_HTOPIC             590
#define IDS_DENY_LOG_TERMINAL_HTOPIC            591
#define IDS_ENABLE_DELEGATION_HTOPIC            592
#define IDS_FORCE_SHUTDOWN_HTOPIC               593
#define IDS_SECURITY_AUDIT_HTOPIC               594
#define IDS_INCREASE_PRIORITY_HTOPIC            595
#define IDS_LOAD_DRIVER_HTOPIC                  596
#define IDS_LOCK_PAGE_HTOPIC                    597
#define IDS_LOGON_BATCH_HTOPIC                  598
#define IDS_LOGON_SERVICE_HTOPIC                599
#define IDS_LOGON_LOCALLY_HTOPIC                600
#define IDS_MANAGE_LOG_HTOPIC                   601
#define IDS_MODIFY_ENVIRONMENT_HTOPIC           602
#define IDS_MAITENANCE_HTOPIC                   603
#define IDS_SINGLE_PROCESS_HTOPIC               604
#define IDS_SYS_PERFORMANCE_HTOPIC              605
#define IDS_REMOVE_COMPUTER_HTOPIC              606
#define IDS_PROCESS_TOKEN_HTOPIC                607
#define IDS_RESTORE_FILE_HTOPIC                 608
#define IDS_SHUTDOWN_HTOPIC                     609
#define IDS_SYNC_DATA_HTOPIC                    610
#define IDS_TAKE_OWNERSHIP_HTOPIC               611
#define IDS_ENABLE_ADMIN_HTOPIC                 612
#define IDS_ENABLE_GUEST_HTOPIC                 613
#define IDS_NEW_ADMIN_HTOPIC                    614
#define IDS_NEW_GUEST_HTOPIC                    615
#define IDS_LSA_ANON_LOOKUP_HTOPIC              616
#define IDS_FORCE_LOGOFF_HTOPIC                 617
#define IDS_LDAPSERVERINTEGRITY_HTOPIC          618
#define IDS_SIGNSECURECHANNEL_HTOPIC            619
#define IDS_SEALSECURECHANNEL_HTOPIC            620
#define IDS_REQUIRESTRONGKEY_HTOPIC             621
#define IDS_REQUIRESIGNORSEAL_HTOPIC            622
#define IDS_REFUSEPASSWORDCHANGE_HTOPIC         623
#define IDS_MAXIMUMPASSWORDAGE_HTOPIC           624
#define IDS_DISABLEPASSWORDCHANGE_HTOPIC        625
#define IDS_LDAPCLIENTINTEGRITY_HTOPIC          626
#define IDS_REQUIRESECURITYSIGNATURE_HTOPIC     627
#define IDS_ENABLESECURITYSIGNATURE_HTOPIC      628
#define IDS_ENABLEPLAINTEXTPASSWORD_HTOPIC      629
#define IDS_RESTRICTNULLSESSACCESS_HTOPIC       630
#define IDS_SERREQUIRESECURITYSIGNATURE_HTOPIC  631
#define IDS_NULLSESSIONSHARES_HTOPIC            632
#define IDS_NULLSESSIONPIPES_HTOPIC             633
#define IDS_SERENABLESECURITYSIGNATURE_HTOPIC   634
#define IDS_ENABLEFORCEDLOGOFF_HTOPIC           635
#define IDS_AUTODISCONNECT_HTOPIC               636
#define IDS_PROTECTIONMODE_HTOPIC               637
#define IDS_CLEARPAGEFILEATSHUTDOWN_HTOPIC      638
#define IDS_OBCASEINSENSITIVE_HTOPIC            639
#define IDS_MACHINE_HTOPIC                      640
#define IDS_ADDPRINTERDRIVERS_HTOPIC            641
#define IDS_SUBMITCONTROL_HTOPIC                642
#define IDS_RESTRICTANONYMOUSSAM_HTOPIC         643
#define IDS_RESTRICTANONYMOUS_HTOPIC            644
#define IDS_NOLMHASH_HTOPIC                     645
#define IDS_NODEFAULTADMINOWNER_HTOPIC          646
#define IDS_NTLMMINSERVERSEC_HTOPIC             647
#define IDS_NTLMMINCLIENTSEC_HTOPIC             648
#define IDS_LMCOMPATIBILITYLEVEL_HTOPIC         649
#define IDS_LIMITBLANKPASSWORDUSE_HTOPIC        650
#define IDS_FULLPRIVILEGEAUDITING_HTOPIC        651
#define IDS_FORCEGUEST_HTOPIC                   652
#define IDS_FIPSALGORITHMPOLICY_HTOPIC          653
#define IDS_EVERYONEINCLUDESANONYMOUS_HTOPIC    654
#define IDS_DISABLEDOMAINCREDS_HTOPIC           655
#define IDS_CRASHONAUDITFAIL_HTOPIC             656
#define IDS_AUDITBASEOBJECTS_HTOPIC             657
#define IDS_UNDOCKWITHOUTLOGON_HTOPIC           658
#define IDS_SHUTDOWNWITHOUTLOGON_HTOPIC         659
#define IDS_SCFORCEOPTION_HTOPIC                660
#define IDS_LEGALNOTICETEXT_HTOPIC              661
#define IDS_LEGALNOTICECAPTION_HTOPIC           662
#define IDS_DONTDISPLAYLASTUSERNAME_HTOPIC      663
#define IDS_DISABLECAD_HTOPIC                   664
#define IDS_SCREMOVEOPTION_HTOPIC               665
#define IDS_PASSWORDEXPIRYWARNING_HTOPIC        666
#define IDS_FORCEUNLOCKLOGON_HTOPIC             667
#define IDS_CACHEDLOGONSCOUNT_HTOPIC            668
#define IDS_ALLOCATEFLOPPIES_HTOPIC             669
#define IDS_ALLOCATEDASD_HTOPIC                 670
#define IDS_ALLOCATECDROMS_HTOPIC               671
#define IDS_SETCOMMAND_HTOPIC                   672
#define IDS_SECURITYLEVEL_HTOPIC                673
#define IDS_REGPOLICY_HTOPIC                    674
#define IDS_APP_LOG_MAX_HTOPIC                  675
#define IDS_SEC_LOG_MAX_HTOPIC                  676
#define IDS_SYS_LOG_MAX_HTOPIC                  677
#define IDS_APP_LOG_GUEST_HTOPIC                678
#define IDS_SEC_LOG_GUEST_HTOPIC                679
#define IDS_SYS_LOG_GUEST_HTOPIC                680
#define IDS_APP_LOG_DAYS_HTOPIC                 681
#define IDS_SEC_LOG_DAYS_HTOPIC                 682
#define IDS_SYS_LOG_DAYS_HTOPIC                 683
#define IDS_APP_LOG_RET_HTOPIC                  684
#define IDS_SEC_LOG_RET_HTOPIC                  685
#define IDS_SYS_LOG_RET_HTOPIC                  686
#define IDS_RESTRICTED_GROUPS_HTOPIC            687
#define IDS_SYSTEM_SERVICES_HTOPIC              688
#define IDS_REGISTRY_SETTING_HTOPIC             689
#define IDS_FILESYSTEM_SETTING_HTOPIC           690
#define IDS_POLICY_PASSWORD_HTOPIC              691
#define IDS_POLICY_LOCKOUT_HTOPIC               692
#define IDS_POLICY_KERBEROS_HTOPIC              693
#define IDS_POLICY_AUDIT_HTOPIC                 694
#define IDS_PRIVILEGE_HTOPIC                    695
#define IDS_POLICY_OTHER_HTOPIC                 696
#define IDS_INVALID_FILENAMEPATH                697
#define IDS_RESERVED_NAME                       698
#define IDS_ERR_FILE_EXTENSION                  699
#define IDS_ERR_PRIVILEGE                       700
#define IDS_INVALID_DBNAME                      701
#define IDS_NO_ACCOUNT_MAP                      702
#define IDS_AUTHENTICODEENABLED                 703
#define IDS_FORCEHIGHPROTECTION                 704   
#define IDS_OPTIONAL                            705
#define IDS_AUTHENTICODEENABLED_HTOPIC          706
#define IDS_FORCEHIGHPROTECTION_HTOPIC          707
#define IDS_OPTIONAL_HTOPIC                     708
#define IDS_FORCE_LOGOFF_WARNING                709
#define IDS_IMPORT_WARNING              57345
#define IDS_CONFIGURE_PROGRESS_TITLE    57346
#define IDS_SYSTEM_DB_NAME_FMT          57350
#define IDS_PRIVATE_DB_NAME_FMT         57351
#define IDS_ERROR_ANALYSIS_LOCKED       57352
#define IDS_IMPORT_FAILED               57353
#define IDS_CHILDREN_CONFIGURED         57354
#define IDS_NOT_AVAILABLE               57355
#define IDS_NEW_SERVICE                 57356
#define IDS_CONFIGURE_PROGRESS_VERB     57357
#define IDS_ADD_FILES_AND_FOLDERS       57358
#define IDS_ADDFILESANDFOLDERS_TITLE    57359
#define IDS_FILEFOLDER_BROWSE_TITLE     57360
#define IDS_SNAPINABOUT_PROVIDER        57361
#define IDS_SNAPINABOUT_VERSION         57362
#define IDS_SCEABOUT_DESCRIPTION        57363
#define IDS_SCMABOUT_DESCRIPTION        57364
#define IDS_SSABOUT_DESCRIPTION         57365
#define IDS_IMPORT_POLICY               57366
#define IDS_EXPORT_POLICY               57367
#define IDS_FILE_EXISTS_FMT             57368
#define IDS_SUCCESS                     57369
#define IDS_FAILURE                     57370
#define IDS_DO_NOT_AUDIT                57371
#define IDS_ERROR_REFRESH_POLICY_FAILED 57372
#define IDS_COPY_FAILED                 57373
#define IDS_ADD_FILES_OFN_TITLE         57374
#define IDS_OPEN_DB_OFN_TITLE           57375
#define IDS_NEW_DB_OFN_TITLE            57376
#define IDS_EXPORT_POLICY_OFN_TITLE     57377
#define IDS_IMPORT_POLICY_OFN_TITLE     57378
#define IDS_ASSIGN_CONFIG_OFN_TITLE     57380
#define IDS_EXPORT_CONFIG_OFN_TITLE     57381
#define IDS_LOCAL_POLICY_COLUMN         57382
#define IDS_EFFECTIVE_POLICY_COLUMN     57383
#define IDS_ERROR_NO_LOCAL_POLICY_INFO  57384
#define IDS_LOCAL_POLICY_FRIENDLY_NAME  57385
#define IDS_CANT_OPEN_SYSTEM_DB         57386
#define IDS_HELPFILE_SCE                57387
#define IDS_HELPFILE_SAV                57388
#define IDS_HELPFILE_EXTENSION          57389
#define IDS_HTMLHELP_SCE_TOPIC          57390
#define IDS_HTMLHELP_SCM_TOPIC          57391
#define IDS_HTMLHELP_POLICY_TOPIC       57392
#define IDS_EFFPOL_UPDATED              57394
#define IDS_ANALTIMESTAMP               57395
#define IDS_DBERR_NO_TEMPLATE_GIVEN     57396
#define IDS_REGISTRY_APPLY              57397
#define IDS_REGISTRY_INHERIT            57398
#define IDS_REGISTRY_PREVENT            57399
#define IDS_GROUP_TITLE                 57400
#define IDS_TICKET_EXPIRE               57401
#define IDS_TICKET_FOREVER              57402
#define IDS_TICKET_RENEWAL_EXPIRE       57403
#define IDS_TICKET_RENEWAL_FOREVER      57404
#define IDS_MAX_TOLERANCE               57405
#define IDS_NO_MAX_TOLERANCE            57406
#define IDS_NOT_APPLICABLE              57407
#define IDS_NO_MEMBERS                  57408
#define IDS_NO_MEMBER_OF                57409
#define IDS_ADD_USERGROUP               57410
#define IDS_ADD_TITLE                   57411
#define IDS_RNH_AUTODISCONNECT_SPECIAL  57412
#define IDS_RNH_AUTODISCONNECT_STATIC   57413
#define IDS_RNH_CACHED_LOGONS_SPECIAL   57414
#define IDS_RNH_CACHED_LOGONS_STATIC    57415
#define IDS_RNH_PASSWORD_WARNINGS_STATIC 57416
#define IDS_RNH_PASSWORD_WARNINGS_SPECIAL 57417
#define IDS_REGISTRY_CONFIGURE          57418
#define IDS_ERR_GLOBAL_LOC_DESC         57419
#define IDS_ERR_LOCAL_LOC_DESC          57420
#define IDS_REFRESH_TEMPLATE            57421
#define IDS_SAVE_P                      57422
#define IDS_LOCAL_SECURITY_NAME         57423
#define IDS_SS_DESC                     57424
#define IDS_LS_DESC                     57425
#define IDS_HTMLHELP_LS_TOPIC           57426
#define IDS_HELPFILE_LS                 57427
#define IDS_LSABOUT_DESCRIPTION         57428
#define IDS_HELPFILE_RSOP               57429
#define IDS_RSOP_DESC                   57430
#define IDS_RSOPABOUT_DESCRIPTION       57431
#define IDS_APPLY                       57435
#define IDS_ADMIN_NO_GPO                57436
#define IDS_NON_ADMIN_NO_GPO            57437
#define IDS_VIEW_LOGFILE_TITLE          57438
#define IDS_PRECEDENCE_GPO_HEADER       57439
#define IDS_PRECEDENCE_VALUE_HEADER     57440
#define IDS_PRECEDENCE_SUCCESS          57441
#define IDS_PRECEDENCE_CHILD_ERROR      57442
#define IDS_PRECEDENCE_ERROR            57443
#define IDS_PRECEDENCE_INVALID          57444
#define IDS_PRECEDENCE_NO_CONFIG        57445
#define IDS_VIEW_SECURITY               57446
#define IDS_EXPORT_FAILED               57447
#define IDS_SAVE_DATABASE               57448
#define IDS_DENY_REMOTE_INTERACTIVE_LOGON 57449
#define IDS_REMOTE_INTERACTIVE_LOGON    57450
#define IDS_ADD_LOC_FAILED              57451
#define IDS_DEFAULT_LOCATION            57452
#define IDS_LOGFILE_DEFAULT             57453
#define IDS_ERROR_NOT_ON_PDC            57454
#define IDS_PRIV_WARNING                57455
#define IDS_CLOSE_PAGES                 57456
#define IDS_RANGE                       57457
#define IDS_LSA_ANON_LOOKUP             57458
#define IDS_PRIV_WARNING_LOCAL_LOGON    57459
#define IDS_PRIV_WARNING_DENYLOCAL_LOGON 57460
#define IDS_PRIV_WARNING_ACCOUNT_TRANSLATION  57461
#define IDS_CLOSESUBSHEET_BEFORE_APPLY  57462
#define IDS_FAIL_CREATE_UITHREAD        57463
#define IDS_HTMLHELP_LPPOLICY_TOPIC     57464
#define IDS_WHAT_ISTHIS                 57465
#define IDS_TEMP_FILENAME               57466
#define IDS_HELPFILE_LOCAL_EXTENSION    57467
#define IDS_ADDITIONAL_RANGE            57468
#define IDS_EVENTLOG_WARNING            57469
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        709
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         397
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\savetemp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       SaveTemp.h
//
//  Contents:   definition of CSaveTemplates
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_)
#define AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSaveTemplates dialog

class CSaveTemplates : public CHelpDialog
{
// Construction
public:
	void AddTemplate(LPCTSTR szInfFile,PEDITTEMPLATE pet);

	CSaveTemplates(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSaveTemplates)
	enum { IDD = IDD_SAVE_TEMPLATES };
	CButton	m_btnSaveSel;
	CListBox	m_lbTemplates;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSaveTemplates)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSaveTemplates)
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnSaveSel();
	afx_msg void OnSelchangeTemplateList();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   CMap<CString, LPCTSTR, PEDITTEMPLATE, PEDITTEMPLATE&> m_Templates;
private:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAVETEMP_H__E6815F79_0579_11D1_9C70_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\selfdeletingpropertypage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       SelfDeletingPropertyPage.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "SelfDeletingPropertyPage.h"

IMPLEMENT_DYNCREATE(CSelfDeletingPropertyPage, CPropertyPage)

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage () 
    : CPropertyPage ()
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage (UINT nIDTemplate, UINT nIDCaption) 
    : CPropertyPage (nIDTemplate, nIDCaption)
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::CSelfDeletingPropertyPage (LPCTSTR lpszTemplateName, UINT nIDCaption)
    : CPropertyPage (lpszTemplateName, nIDCaption)
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}

CSelfDeletingPropertyPage::~CSelfDeletingPropertyPage ()
{
}

UINT CALLBACK CSelfDeletingPropertyPage::PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp)
{
    CSelfDeletingPropertyPage* pPage = (CSelfDeletingPropertyPage*)(ppsp->lParam);
    ASSERT(pPage != NULL); //This is not a safe usage. pPage should be validated. Raid #550912, yanggao.
    if( pPage == NULL )
    {
        return 0;
    }

    UINT nResult = (*(pPage->m_pfnOldPropCallback))(hwnd, uMsg, ppsp);
    if (uMsg == PSPCB_RELEASE)
    {
        delete pPage;
    }
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\scopane.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       scopane.cpp
//
//  Contents:   Functions for handling the scope pane folder structure
//
//  History:    12-12-1997   RobCap   Split out from snapmgr.cpp
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"
#include "snapmgr.h"
#include "resource.h"
#include "wrapper.h"
#include "util.h"
#include <sceattch.h>
#include <io.h>

#ifdef INITGUID
#undef INITGUID
#include <gpedit.h>
#define INITGUID
#include "userenv.h"
#endif


//
// Array of folders to list in the scope pane
// The order of this array is important:
//   All folders which appear at the same level must be adjacent
//   to each other and the array and #defines need to be kept in
//   sync
//
//
#define USE_KERBEROS    1

//
// Top level folders
//
#define ANALYSIS_FOLDER 0
#define CONFIGURATION_FOLDER (ANALYSIS_FOLDER +1)

//
// Profile level folders
//
#define PROFILE_ACCOUNT_FOLDER (CONFIGURATION_FOLDER +1)
#define PROFILE_LOCAL_FOLDER (PROFILE_ACCOUNT_FOLDER +1)
#define PROFILE_EVENTLOG_FOLDER (PROFILE_LOCAL_FOLDER +1)
#define PROFILE_GROUPS_FOLDER (PROFILE_EVENTLOG_FOLDER +1)
#define PROFILE_SERVICE_FOLDER (PROFILE_GROUPS_FOLDER +1)
#define PROFILE_REGISTRY_FOLDER (PROFILE_SERVICE_FOLDER +1)
#define PROFILE_FILESTORE_FOLDER (PROFILE_REGISTRY_FOLDER +1)

//
// Profile/Account level folders
//
#define ACCOUNT_PASSWORD_FOLDER (PROFILE_FILESTORE_FOLDER +1)
#define ACCOUNT_LOCKOUT_FOLDER (ACCOUNT_PASSWORD_FOLDER +1)
#define ACCOUNT_KERBEROS_FOLDER (ACCOUNT_LOCKOUT_FOLDER +1)

//
// Profile/Local level folders
//
#define LOCAL_AUDIT_FOLDER (ACCOUNT_KERBEROS_FOLDER +1)
#define LOCAL_PRIVILEGE_FOLDER (LOCAL_AUDIT_FOLDER +1)
#define LOCAL_OTHER_FOLDER (LOCAL_PRIVILEGE_FOLDER +1)

//
// Profile/Eventlog level folders
//
#define EVENTLOG_LOG_FOLDER (LOCAL_OTHER_FOLDER +1)


#define NUM_FOLDERS (LOCAL_OTHER_FOLDER +1)
//#define NUM_FOLDERS (EVENTLOG_LOG_FOLDER +1)

//
// #defines to identify which folders belong in which sections
//
#define FIRST_STATIC_FOLDER ANALYSIS_FOLDER
#define LAST_STATIC_FOLDER CONFIGURATION_FOLDER
#define FIRST_PROFILE_FOLDER PROFILE_ACCOUNT_FOLDER
#define LAST_PROFILE_FOLDER PROFILE_DSOBJECT_FOLDER
#define LAST_PROFILE_NODS_FOLDER PROFILE_FILESTORE_FOLDER
#define LAST_LOCALPOL_FOLDER PROFILE_LOCAL_FOLDER
#define FIRST_ACCOUNT_FOLDER ACCOUNT_PASSWORD_FOLDER
#define LAST_ACCOUNT_NODS_FOLDER ACCOUNT_LOCKOUT_FOLDER
//
// remove kerberos section from NT5 for now
//
#if defined(_NT4BACK_PORT) || !defined(USE_KERBEROS)
#define LAST_ACCOUNT_FOLDER ACCOUNT_LOCKOUT_FOLDER
#else
#define LAST_ACCOUNT_FOLDER ACCOUNT_KERBEROS_FOLDER
#endif
#define FIRST_LOCAL_FOLDER LOCAL_AUDIT_FOLDER
#define LAST_LOCAL_FOLDER LOCAL_OTHER_FOLDER
#define FIRST_EVENTLOG_FOLDER EVENTLOG_LOG_FOLDER
#define LAST_EVENTLOG_FOLDER EVENTLOG_LOG_FOLDER

//
// The actual folder data
// This must be kept in sync with the above #defines
//         should be initialized based on the #defines rather than
//         independantly on them.  Let the compiler keep things
//         accurate for us
//
FOLDER_DATA SecmgrFolders[NUM_FOLDERS] =
{
   { IDS_ANALYZE, IDS_ANALYZE_DESC, ANALYSIS},
   { IDS_CONFIGURE, IDS_CONFIGURE_DESC, CONFIGURATION},
   { IDS_ACCOUNT_POLICY, IDS_ACCOUNT_DESC, POLICY_ACCOUNT},
   { IDS_LOCAL_POLICY, IDS_LOCAL_DESC, POLICY_LOCAL},
   { IDS_EVENT_LOG, IDS_EVENT_LOG, POLICY_LOG},
   { IDS_GROUPS, IDS_GROUPS_DESC, AREA_GROUPS},
   { IDS_SERVICE, IDS_SERVICE_DESC, AREA_SERVICE},
   { IDS_REGISTRY, IDS_REGISTRY_DESC, AREA_REGISTRY},
   { IDS_FILESTORE, IDS_FILESTORE_DESC, AREA_FILESTORE},
   { IDS_PASSWORD_CATEGORY, IDS_PASSWORD_CATEGORY, POLICY_PASSWORD},
   { IDS_LOCKOUT_CATEGORY,  IDS_LOCKOUT_CATEGORY, POLICY_LOCKOUT},
   { IDS_KERBEROS_CATEGORY,  IDS_KERBEROS_CATEGORY, POLICY_KERBEROS},
   { IDS_EVENT_AUDIT, IDS_EVENT_AUDIT, POLICY_AUDIT},
   { IDS_PRIVILEGE, IDS_PRIVILEGE, AREA_PRIVILEGE},
   { IDS_OTHER_CATEGORY, IDS_OTHER_CATEGORY, POLICY_OTHER},
};

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


//+--------------------------------------------------------------------------
//
//  Function:   AddLocationsToFolderList
//
//  Synopsis:   Adds the locations from a given registry key to the
//              folder list.  Returns the number of locations added.
//              Helper function for CreateFolderList
//
//  Arguments:  [hKey]           - the key holding the locations
//              [dwMode]         - the mode SCAT is running in
//              [bCheckForDupes] - TRUE to check for duplicates before adding
//              [pPos]           - output only
//
//  Returns:    *[pPos]  - the position in m_pScopeItemList of the first
//                         folder created
//              the number of child folders created
//
//  Modifies:   CComponentDataImpl::m_pScopeItemList
//
//  History:    7-26-l999  RobCap  broken out from CreateFolderList
//
//---------------------------------------------------------------------------
INT
CComponentDataImpl::AddLocationsToFolderList(HKEY hKey,
                                             DWORD dwMode,
                                             BOOL bCheckForDupes,
                                             POSITION *pPos) {
   LPTSTR  tmpstr=NULL;
   WCHAR   pBuf[MAX_PATH+1];
   DWORD   BufSize = MAX_PATH;
   WCHAR   pExpanded[MAX_PATH+1];
   FILETIME    LastWriteTime;
   PWSTR       Desc=NULL;
   CFolder *folder =NULL;
   INT nCount = 0;
   DWORD status = 0;
   HRESULT hr = S_OK;
   //
   // enumerate all subkeys of the key
   //
   int iTotal = 0;
   do {
      memset(pBuf, '\0', (MAX_PATH+1)*sizeof(WCHAR)); //Raid #553113, Yanggao.
      BufSize = MAX_PATH;

      status = RegEnumKeyEx(hKey,
                            nCount,
                            pBuf,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            &LastWriteTime);

      if ( ERROR_SUCCESS == status ) { //Raid #553113, yanggao.
         //
         // get description of this location (subkey)
         //
         MyRegQueryValue( hKey,
                          pBuf,
                          L"Description",  // Value name (not localized)
                          (PVOID*)&Desc,
                          &BufSize );

         //
         // replace '/' with '\' because Registry does not
         // take '\' in a single key
         //
         tmpstr = wcschr(pBuf, L'/');
         while (tmpstr) {
            *tmpstr = L'\\';
            tmpstr = wcschr(tmpstr, L'/');
         }
         //This is not a safe usage. Make sure pBuf and pExpanded is terminated. Raid #553113, Yanggao.
         memset(pExpanded, '\0', (MAX_PATH+1)*sizeof(WCHAR));
         if (!ExpandEnvironmentStrings(pBuf,pExpanded,MAX_PATH)) {
            wcsncpy(pExpanded,pBuf,BufSize);
         }

         if (bCheckForDupes) {
            //
            // Make sure we haven't already added this directory
            //
            POSITION pos;
            BOOL bDuplicate = FALSE;
            pos = m_scopeItemList.GetHeadPosition();
            for (int i=0;i < m_scopeItemList.GetCount(); i++) {
               folder = m_scopeItemList.GetAt(pos);
               if (folder && (0 == lstrcmp(folder->GetName(),pExpanded))) {
                  bDuplicate = TRUE;
                  break;
               }
            }

            if (bDuplicate) {
               if ( Desc )
                   LocalFree(Desc);
               Desc = NULL;
               continue;
            }
         }

         folder = new CFolder();

         if (folder) {
            if( _wchdir( pExpanded ) ){
               folder->SetState( CFolder::state_InvalidTemplate );
            }
            //
            // Create the folder objects with static data
            //
            hr = folder->Create(pExpanded,                   // Name
                                Desc,                   // Description
                                NULL,                   // inf file name
                                CONFIG_FOLDER_IDX,      // closed icon index
                                CONFIG_FOLDER_IDX,      // open icon index
                                LOCATIONS,              // folder type
                                TRUE,                   // has children
                                dwMode,                 // SCE mode
                                NULL);                  // Extra Data
            if (SUCCEEDED(hr)) {
               m_scopeItemList.AddTail(folder);

               if ( iTotal == 0 && NULL != pPos && !bCheckForDupes) {
                  *pPos = m_scopeItemList.GetTailPosition();
               }
            } else {    // if can't create, then quit doing it anymore, no more reason to continue
               delete folder;
               if ( Desc )
                   LocalFree(Desc);
               Desc = NULL;
               break;
            }

         } else {
            hr = E_OUTOFMEMORY;
            if ( Desc )
               LocalFree(Desc);
            Desc = NULL;
            break;
         }

         if ( Desc ) {
            LocalFree(Desc);
         }
         Desc = NULL;

         nCount++;
         iTotal++;
      }
   } while ( status != ERROR_NO_MORE_ITEMS );

   return nCount;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateFolderList
//
//  Synopsis:   Adds the children folders of pFolder to m_pScopeItemList
//              and returns the location of the first such folder and the
//              number added
//
//  Arguments:  [pFolder] - the folder whose children we want to find
//              [type]    - the type of that folder
//              [pPos]    - output only
//              [Count]   - output only
//
//  Returns:    *[pPos]  - the position in m_pScopeItemList of the first
//                         folder created
//              *[Count] - the number of child folders created
//
//  Modifies:   CComponentDataImpl::m_pScopeItemList
//
//  History:    12-15-1997  RobCap  made dynamic based on mode
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::CreateFolderList(CFolder *pFolder,   // Optional, In
                                     FOLDER_TYPES type,  // In
                                     POSITION *pPos,     // Optional, Out
                                     INT *Count)         // Optional, Out,
{
   CFolder* folder = 0;

   INT     nStart = 0;
   INT     nCount = 0;
   BOOL    bHasChildren = FALSE;
   struct _wfinddata_t findData;
   intptr_t hFile = 0;
   WCHAR   pBuf[MAX_PATH];
   HKEY    hKey = 0;
   DWORD       BufSize = 0;
   DWORD       status = 0;
   PWSTR       Desc=NULL;
   LPTSTR      tmpstr=NULL;
   HRESULT     hr = S_OK;
   DWORD   dwErr = 0;

   SCESTATUS            rc = 0;
   PSCE_OBJECT_CHILDREN ObjectList=NULL;
   PSCE_OBJECT_LIST     pObject = 0;
   PSCE_ERROR_LOG_INFO  ErrBuf=NULL;
   CString              StrErr;
   PSCE_PROFILE_INFO    pProfileInfo=NULL;
   FOLDER_TYPES         newType;
   PEDITTEMPLATE        pet = 0;

   //
   // initialize dwMode and ModeBits
   //

   DWORD dwMode=0;
   DWORD ModeBits=0;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (Count)
      *Count = 0;

   if (pFolder) 
   {
      dwMode = pFolder->GetMode();
      ModeBits = pFolder->GetModeBits();
   }

   //
   // This could take some time, so create a wait curser
   //
   CWaitCursor wc;

   switch ( type ) 
   {
   case ROOT:
         //
         // Initial standalone mode root mode
         //

         folder = new CFolder();

         if (!folder)
            return E_OUTOFMEMORY;
         
         if ( GetImplType() == SCE_IMPL_TYPE_SAV ) 
         {
             dwMode = SCE_MODE_VIEWER;
             newType = ANALYSIS;
         } 
         else if ( GetImplType() == SCE_IMPL_TYPE_SCE ) 
         {
             dwMode = SCE_MODE_EDITOR;
             newType = CONFIGURATION;
         } 
         else if ( GetImplType() == SCE_IMPL_TYPE_LS) 
         {
            dwMode = SCE_MODE_LOCALSEC;
            newType = LOCALPOL;
         } 
         else 
         {
             dwMode = 0;
             newType = CONFIGURATION;
         }
         //
         // Create the folder objects with static data
         // MMC pulls in the name from the data object
         //
         hr = folder->Create(L"",              // Name
                             L"",              // Description
                             NULL,             // inf file name
                             SCE_IMAGE_IDX,    // closed icon index
                             SCE_IMAGE_IDX,    // open icon index
                             newType,          // folder type
                             TRUE,             // has children
                             dwMode,           // SCE Mode
                             NULL);            // Extra Data
         if (SUCCEEDED(hr)) 
         {
            folder->SetCookie(NULL);
            switch (m_Mode)
            {
               case SCE_MODE_DOMAIN_COMPUTER:
               case SCE_MODE_OU_COMPUTER:
               case SCE_MODE_LOCAL_COMPUTER:
               case SCE_MODE_REMOTE_COMPUTER:
                  m_computerModeBits = folder->GetModeBits();
                  break;

               case SCE_MODE_REMOTE_USER:
               case SCE_MODE_LOCAL_USER:
               case SCE_MODE_DOMAIN_USER:
               case SCE_MODE_OU_USER:
                  m_userModeBits = folder->GetModeBits();
                  break;

               default:
                  m_computerModeBits = folder->GetModeBits();
                  break;
            }
            
            m_scopeItemList.AddTail(folder);
            return S_OK;
         } 
         else 
         {
            delete folder;
            return hr;
         }


      case ANALYSIS:
         pFolder->SetInfFile(GT_COMPUTER_TEMPLATE);
         m_AnalFolder = pFolder;
         //
         // Very first time initialization of the sad name.
         // Ask the user to get a sad name if none exists.
         //
         if(!m_AnalFolder && SadName.IsEmpty() )
            OnOpenDataBase();
         //
         // enumerate security areas for analysis
         //
         if ( !SadHandle )
            LoadSadInfo(TRUE);

         //
         // The data under the Analysis node is not valid right now,
         // so don't display any folders
         //
         if (m_bIsLocked)
            return S_OK;

         //
         // We weren't able to load the Analysis data even though we're
         // not in the middle of an action that should be blocking it
         //
         if ( SadErrored != ERROR_SUCCESS || !SadHandle) 
            return E_FAIL;

         nStart = FIRST_PROFILE_FOLDER;

            //
            // Display all but the DS Objects folder
            //
            nCount = LAST_PROFILE_NODS_FOLDER - FIRST_PROFILE_FOLDER +1;
         bHasChildren = FALSE;
         break;

      case AREA_REGISTRY_ANALYSIS:
      case AREA_FILESTORE_ANALYSIS:
         if ( SadHandle == NULL ) 
         {
            //
            // We shouldn't be able to get this far without a SadHandle
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         if (m_bIsLocked) 
         {
            //
            // We shouldn't be able to get this far if we're locked
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         switch ( type ) 
         {
            case AREA_REGISTRY_ANALYSIS:
               status = AREA_REGISTRY_SECURITY; // use status temporatorily
               newType = REG_OBJECTS;
               break;

            case AREA_FILESTORE_ANALYSIS:
               status = AREA_FILE_SECURITY;
               newType = FILE_OBJECTS;
               break;

            default:
               break;
         }

         //
         // get the object roots
         //
         pet = GetTemplate(GT_LAST_INSPECTION,status,&dwErr);
         if (!pet) 
         {
            CString strErr;
            strErr.LoadString(dwErr);
            AfxMessageBox(strErr);
            return E_FAIL;
         }
         pProfileInfo = pet->pTemplate;

         if ( pProfileInfo ) 
         {
            //
            // add the object roots
            //
            if ( type == AREA_REGISTRY_ANALYSIS)
               pObject = pProfileInfo->pRegistryKeys.pOneLevel;
            else if ( type == AREA_FILESTORE_ANALYSIS )
               pObject = pProfileInfo->pFiles.pOneLevel;
            else 
               pObject = pProfileInfo->pDsObjects.pOneLevel;

            for (; pObject!=NULL; pObject=pObject->Next) 
            {
               CString strRoot;
               strRoot = (LPCTSTR)pObject->Name;
               if (AREA_FILESTORE_ANALYSIS == type) 
               {
                  //
                  // We want c:\, not c: here.
                  //
                  strRoot += L"\\";
               }
               //
               // These are the roots of the objects.
               // They are always containers
               //

               if (SCE_STATUS_NO_ACL_SUPPORT == pObject->Status) 
               {
                  folder = CreateAndAddOneNode(pFolder,
                                              // pObject->Name,
                                               strRoot,
                                               pBuf,
                                               newType,
                                               FALSE,
                                               GT_COMPUTER_TEMPLATE,
                                               pObject,
                                               pObject->Status);
               } 
               else 
               {
                  folder = CreateAndAddOneNode(
                                              pFolder,       // Parent folder
                                           //   pObject->Name, // Name
                                              strRoot,
                                              pBuf,          // Description
                                              newType,       // Folder Type
                                              TRUE,          // Has Children?
                                              GT_COMPUTER_TEMPLATE, // INF File
                                              pObject,       // Extra Data: the object
                                              pObject->Status); // Status
               }

               if(folder)
                  folder->SetDesc( pObject->Status, pObject->Count );
            }
         }
         return S_OK;

      case REG_OBJECTS:
      case FILE_OBJECTS:
         if ( SadHandle == NULL ) 
         {

            //
            // We shouldn't be able to get this far without a SadHandle
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         if ( type == REG_OBJECTS)
            status = AREA_REGISTRY_SECURITY;
         else if ( type == FILE_OBJECTS )
            status = AREA_FILE_SECURITY;
         else 
         {
            ASSERT(FALSE);
            return E_FAIL;
         }

         //
         // get the next level objects
         //
         rc = SceGetObjectChildren(SadHandle,                   // hProfile
                                   SCE_ENGINE_SAP,              // Profile type
                                   (AREA_INFORMATION)status,    // Area
                                   (LPTSTR)(pFolder->GetName()),// Object prefix
                                   &ObjectList,                 // Object list [out]
                                   &ErrBuf);                    // Error list [out]
         if ( ErrBuf ) 
         { // rc != SCESTATUS_SUCCESS ) {
            MyFormatResMessage(rc, IDS_ERROR_GETTING_LAST_ANALYSIS, ErrBuf, StrErr);

            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }
         if ( rc == SCESTATUS_SUCCESS &&
              ObjectList ) 
         {
            BOOL bContainer = FALSE;
            //
            // add the objects
            //
            PSCE_OBJECT_CHILDREN_NODE *pObjNode = &(ObjectList->arrObject);

            for (DWORD i=0; i<ObjectList->nCount;i++) 
            {
               //
               // These are the next level objects
               //
               if ( pObjNode[i] == NULL ||
                    pObjNode[i]->Name == NULL ) 
               {
                   continue;
               }

               if (SCE_STATUS_NO_ACL_SUPPORT == pObjNode[i]->Status) 
               {
                  // No ACL support, so don't add sub objects
                  continue;
               }

               //
               // If there are any mismatched child objects then we know
               // that this is a container, otherwise we have to check the
               // object on the system to find out if it is a container
               //
               if ( pObjNode[i]->Count > 0 ) 
                  bContainer = TRUE;
               else 
               {
                  if (FILE_OBJECTS == type) 
                  {
                     //
                     // Check if a file object is a container
                     //
                     CString strPath;
                     DWORD dwAttr = 0;

                     strPath = pFolder->GetName();
                     if (strPath.Right(1) != L"\\") 
                     {
                        strPath += L"\\";
                     }
                     strPath += pObjNode[i]->Name;

                     dwAttr = GetFileAttributes(strPath);
                     if (0xFFFFFFFF == dwAttr) 
                        bContainer = FALSE;
                     else 
                        bContainer = dwAttr & FILE_ATTRIBUTE_DIRECTORY;
                  } 
                  else 
                  {
                     //
                     // Always treat Registry Keys and DS Objects as containers
                     //
                     bContainer = TRUE;
                  }
               }
               if (bContainer) 
               {
                  StrErr = pFolder->GetName();
                  if (StrErr.Right(1) != L"\\")
                     StrErr += L"\\";
                  
                  StrErr += pObjNode[i]->Name;
                  folder = CreateAndAddOneNode(
                                              pFolder,       // Parent folder
                                              (LPTSTR)((LPCTSTR)StrErr),  // Name
                                              pBuf,          // Description
                                              type,          // Folder Type
                                              TRUE,          // Has Children?
                                              GT_COMPUTER_TEMPLATE, // INF File
                                              NULL,
                                              pObjNode[i]->Status); // Object Status
                  if(folder)
                  {
                     folder->SetDesc( pObjNode[i]->Status,
                                      pObjNode[i]->Count );
                  }
               }
            }
         }

         if ( ObjectList )
            SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );

         return S_OK;

      case CONFIGURATION: 
         {
         //
         // enumerate profile locations in registry
         //
         CString strLocations;

         m_ConfigFolder = pFolder;
         nCount = 0;

         if (strLocations.LoadString(IDS_TEMPLATE_LOCATION_KEY)) 
         {
            //
            // Bug 375324 - Merge HKCU locations with HKLM locations
            //
            status = RegOpenKeyEx( HKEY_CURRENT_USER,
                                   strLocations,
                                   0, KEY_READ, &hKey);

            if ( NO_ERROR == status ) 
            {
               nCount += AddLocationsToFolderList(hKey,dwMode,FALSE,pPos);
               RegCloseKey(hKey);
            }

            if ( 0 == nCount ) 
            {
               //
               // Empty location list, so add a default
               //
               CString strDefLoc;
               CString strDefLocEx;
               strDefLoc.LoadString(IDS_DEFAULT_LOCATION);
               int iLen = strDefLoc.GetLength()+MAX_PATH;
               LPWSTR pBuffer = strDefLocEx.GetBuffer(iLen+1); //This is not a safe usage. Make sure pBuffer is terminated. Raid #553113, Yanggao. 
               if (ExpandEnvironmentStrings(strDefLoc, pBuffer, iLen)) 
               {
                   //
                   // must use pBuffer here since strDefLocEx has not been released
                   //
                   AddTemplateLocation(pFolder,pBuffer,FALSE,TRUE);
               } 
               else
                   AddTemplateLocation(pFolder,strDefLoc,FALSE,TRUE);
               
               strDefLocEx.ReleaseBuffer();
            }
         }

         if ( Count != NULL )
            *Count = nCount;

         return hr;
      }

      case LOCATIONS:
      {
         //
         // enumerate available profiles under the location (*.inf files)
         //

         //
         // pFolder is required in this case
         //
         if (!pFolder)
            return E_INVALIDARG;
         //This is not a sage usage. avoid using swprintf. Raid #555867. Yanggao.
         CString strBuf;
         strBuf.Format(L"%s\\*.inf", (LPTSTR)(pFolder->GetName()));
         bHasChildren = FALSE;

         hFile = _wfindfirst(strBuf.GetBuffer(0), &findData);
         strBuf.ReleaseBuffer();
         if ( hFile != -1) 
         {
            do {
                //
                // Don't add this item to the node if it is a subdirectory.
                //
                CString strDisplay;
                strDisplay.Format(
                   TEXT("%s\\%s"),
                   (LPCTSTR)(pFolder->GetName()),
                   findData.name);

                if( findData.attrib & _A_SUBDIR )
                   continue;

               //
               // get template's description
               //
               strDisplay = findData.name;
               //
               // GetLength has to be at least 4, since we searched on *.inf
               //
               strDisplay = strDisplay.Left(strDisplay.GetLength() - 4);
               //This is not a safe usage. avoid using swprintf. Raid #555867. Yanggao.
               strBuf.Format(
                        L"%s\\%s",
                        (LPTSTR)(pFolder->GetName()),
                        findData.name);
               if (! GetProfileDescription(strBuf, &Desc) ) 
                  Desc = NULL;
               else 
               {
                  //
                  // No problem; we just won't display a description
                  //
               }

               nCount++;
               folder = new CFolder();

               if (folder) 
               {
                  //
                  // Create the folder objects
                  // save full file name her
                  //
                  hr = folder->Create((LPCTSTR)strDisplay,         // Name
                                      Desc,                        // Description
                                      strBuf,                        // inf file name
                                      TEMPLATES_IDX,               // closed icon index
                                      TEMPLATES_IDX,               // open icon index
                                      PROFILE,                     // folder type
                                      bHasChildren,                // has children
                                      dwMode,                      // SCE Mode
                                      NULL);                       // Extra Data

                  if (SUCCEEDED(hr)) 
                  {
                     m_scopeItemList.AddTail(folder);

                     if ( nCount == 1 && NULL != pPos ) 
                     {
                        *pPos = m_scopeItemList.GetTailPosition();
                     }
                  } 
                  else 
                  {
                     delete folder;
                     folder = NULL;
                  }
               } 
               else
                  hr = E_OUTOFMEMORY;

               if (Desc) 
               {
                  LocalFree(Desc);
                  Desc = NULL;
               }
            } while ( _wfindnext(hFile, &findData) == 0 );
         }

         _findclose(hFile);

         if ( Count != NULL )
            *Count = nCount;

         return hr;
      }
      case PROFILE: 
         {
         TCHAR pszGPTPath[MAX_PATH*5];
         SCESTATUS scestatus = 0;
         //
         // enumerate security areas for this profile
         //

         if (ModeBits & MB_NO_NATIVE_NODES) 
         {
            //
            //
            //
            nStart = nCount = 0;
            break;
         }

         //
         // Find the path to the SCE template within the GPT template
         //
         if (ModeBits & MB_GROUP_POLICY) 
         {
            //
            // get GPT root path
            //
            hr = m_pGPTInfo->GetFileSysPath(GPO_SECTION_MACHINE,
                                            pszGPTPath,
                                            ARRAYSIZE(pszGPTPath));
            if (SUCCEEDED(hr)) 
            {
               if (NULL == m_szSingleTemplateName) 
               {
                  //
                  // Allocate memory for the pszGPTPath + <backslash> + GPTSCE_TEMPLATE + <trailing nul>
                  //
                  m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(pszGPTPath)+lstrlen(GPTSCE_TEMPLATE)+2)*sizeof(TCHAR));
               }
               if (NULL != m_szSingleTemplateName) 
               {
                  //This is a safe usage.
                  lstrcpy(m_szSingleTemplateName,pszGPTPath);
                  lstrcat(m_szSingleTemplateName,L"\\" GPTSCE_TEMPLATE);

                      PSCE_PROFILE_INFO spi = NULL;
                      //
                      // Create a new template there if there isn't one already
                      //
                      if (!CreateNewProfile(m_szSingleTemplateName,&spi)) 
                      {
                         hr = E_FAIL;
                      } 
                      else 
                      {
                         if (!GetTemplate(m_szSingleTemplateName) && spi) 
                         {
                            //
                            // bug 265996
                            //
                            // The first time a GPO's Security Settings are opened we create
                            // the file, but if it's on a remote machine it may not have been
                            // created yet when we try to open it
                            //
                            // Since we know what's going to be in it once it's created we
                            // can skip the open step and just shove our template into the
                            // cache

                            //
                            // Allocate space for key.
                            //
                            LPTSTR szKey = new TCHAR[ lstrlen( m_szSingleTemplateName ) + 1];
                            if(!szKey)
                            {
                                return NULL;
                            }
                            //This is a safe usage.
                            lstrcpy(szKey, m_szSingleTemplateName);
                            _wcslwr( szKey );

                            //
                            // Create a new CEditTemplate
                            //

                            CEditTemplate *pTemplateInfo = new CEditTemplate;
                            if (pTemplateInfo) 
                            {
                               pTemplateInfo->SetInfFile(m_szSingleTemplateName);
                               pTemplateInfo->SetNotificationWindow(m_pNotifier);
                               pTemplateInfo->pTemplate = spi;
                               //
                               // This is a brand new template; ergo everything's loaded
                               //
                               pTemplateInfo->AddArea(AREA_ALL);


                               //
                               // Stick it in the cache
                               //
                               m_Templates.SetAt(szKey, pTemplateInfo);

                               //
                               // expand registry value section based on registry values list on local machine
                               //
                               SceRegEnumAllValues(
                                                  &(pTemplateInfo->pTemplate->RegValueCount),
                                                  &(pTemplateInfo->pTemplate->aRegValues));
                            }

                            if (szKey) 
                               delete[] szKey;
                         }
                      }
               } 
               else
                  hr = E_OUTOFMEMORY;
            }
         }

         nStart = FIRST_PROFILE_FOLDER;

            //
            // Display all but the DS Objects folder
            //
            nCount = LAST_PROFILE_NODS_FOLDER - FIRST_PROFILE_FOLDER +1;


         bHasChildren = FALSE;
         tmpstr = pFolder->GetInfFile(); // inf file full path name
         //
         // If this folder is in a write-through mode then set that
         // on the template
         //
         PEDITTEMPLATE pie;
         pie = GetTemplate(tmpstr);
         if ( pie ) 
         {
            if (ModeBits & MB_WRITE_THROUGH) 
            {
               pie->SetWriteThrough(TRUE);
            }
         } 
         else 
         {
            //
            // Mark as bad template.
            //
            pFolder->SetState( CFolder::state_InvalidTemplate );
            nCount = 0;
         }
         break;
      }

      case LOCALPOL: 
         {
         nStart = FIRST_PROFILE_FOLDER;
         nCount = LAST_LOCALPOL_FOLDER - FIRST_PROFILE_FOLDER +1;
         bHasChildren = FALSE;
         pFolder->SetInfFile(GT_LOCAL_POLICY);
         break;
      }

      case POLICY_ACCOUNT:
         if (!pFolder) 
         {
            return E_INVALIDARG;
         } 
         else 
         {
            tmpstr = pFolder->GetInfFile();
         }
         // fall through;
      case LOCALPOL_ACCOUNT:
      case POLICY_ACCOUNT_ANALYSIS:
         nStart = FIRST_ACCOUNT_FOLDER;
         if (ModeBits & MB_DS_OBJECTS_SECTION) 
         {
            //
            // Include the DC Specific folders
            //
            nCount = LAST_ACCOUNT_FOLDER - FIRST_ACCOUNT_FOLDER + 1;
         } 
         else 
         {
            //
            // Display all but the DC Specific folders
            //
            nCount = LAST_ACCOUNT_NODS_FOLDER - FIRST_ACCOUNT_FOLDER +1;
         }
         bHasChildren = FALSE;
         break;

      case POLICY_LOCAL:
         if (!pFolder) 
         {
            return E_INVALIDARG;
         } 
         else 
         {
            tmpstr = pFolder->GetInfFile();
         }
         // fall through;
      case LOCALPOL_LOCAL:
      case POLICY_LOCAL_ANALYSIS:
         nStart = FIRST_LOCAL_FOLDER;
         nCount = LAST_LOCAL_FOLDER - FIRST_LOCAL_FOLDER +1;
         bHasChildren = FALSE;
         break;

      case POLICY_EVENTLOG:
         if (!pFolder)
            return E_INVALIDARG;
         else
            tmpstr = pFolder->GetInfFile();
         // fall through;
      case LOCALPOL_EVENTLOG:
      case POLICY_EVENTLOG_ANALYSIS:
         nStart = FIRST_EVENTLOG_FOLDER;
         nCount = LAST_EVENTLOG_FOLDER - FIRST_EVENTLOG_FOLDER +1;
         bHasChildren = FALSE;
         break;

      default:
         break;
   }


   if ( Count != NULL )
      *Count = nCount;

   CString cStrName;
   CString cStrDesc;


   for (int i=nStart; i < nStart+nCount; i++) 
   {
      folder = new CFolder();

      if (!folder) 
      {
         //
         // What about other folders that we've created?
         //
         return E_OUTOFMEMORY;
      }
      if (!cStrName.LoadString(SecmgrFolders[i].ResID) ||
          !cStrDesc.LoadString(SecmgrFolders[i].DescID)) 
      {
         delete folder;
         return E_FAIL;
      }

      //
      // Create the folder objects with static data
      //
      if (type == ANALYSIS ||
          type == AREA_POLICY_ANALYSIS ||
          type == POLICY_ACCOUNT_ANALYSIS ||
          type == POLICY_LOCAL_ANALYSIS ||
          type == POLICY_EVENTLOG_ANALYSIS ) 
      {
         if (m_bIsLocked) 
         {
            nCount = 0;


            delete folder;
            // Should display an "in use" message in result pane

            //
            // We're not adding anything, but we're not actually failing
            //
            return S_OK;
         }
         tmpstr = GT_COMPUTER_TEMPLATE;
         switch (SecmgrFolders[i].type) 
         {
            case AREA_POLICY:
               newType = AREA_POLICY_ANALYSIS;
               break;

            case AREA_PRIVILEGE:
               newType = AREA_PRIVILEGE_ANALYSIS;
               break;

            case AREA_GROUPS:
               newType = AREA_GROUPS_ANALYSIS;
               break;

            case AREA_SERVICE:
               newType = AREA_SERVICE_ANALYSIS;
               tmpstr = GT_COMPUTER_TEMPLATE;
               break;

            case AREA_REGISTRY:
               newType = AREA_REGISTRY_ANALYSIS;
               break;

            case AREA_FILESTORE:
               newType = AREA_FILESTORE_ANALYSIS;
               break;

            case POLICY_ACCOUNT:
               newType = POLICY_ACCOUNT_ANALYSIS;
               break;

            case POLICY_LOCAL:
               newType = POLICY_LOCAL_ANALYSIS;
               break;

            case POLICY_EVENTLOG:
               newType = POLICY_EVENTLOG_ANALYSIS;
               break;

            case POLICY_PASSWORD:
               newType = POLICY_PASSWORD_ANALYSIS;
               break;

            case POLICY_KERBEROS:
               newType = POLICY_KERBEROS_ANALYSIS;
               break;

            case POLICY_LOCKOUT:
               newType = POLICY_LOCKOUT_ANALYSIS;
               break;

            case POLICY_AUDIT:
               newType = POLICY_AUDIT_ANALYSIS;
               break;

            case POLICY_OTHER:
               newType = POLICY_OTHER_ANALYSIS;
               break;

            case POLICY_LOG:
               newType = POLICY_LOG_ANALYSIS;
               break;

            default:
               newType = SecmgrFolders[i].type;
               break;
         }

        int nImage = GetScopeImageIndex(newType);

        hr = folder->Create(cStrName.GetBuffer(2),    // Name
                            cStrDesc.GetBuffer(2),    // Description
                            tmpstr,                   // inf file name
                            nImage,                   // closed icon index
                            nImage,                   // open icon index
                            newType,                  // folder type
                            bHasChildren,             // has children
                            dwMode,                   // SCE Mode
                            NULL);                    // Extra Data
      } 
      else if (type == LOCALPOL ||
             type == AREA_LOCALPOL ||
             type == LOCALPOL_ACCOUNT ||
             type == LOCALPOL_LOCAL ||
             type == LOCALPOL_EVENTLOG ) 
      {
            if (m_bIsLocked) 
            {
               nCount = 0;

               delete folder;
               // Should display an "in use" message in result pane

               //
               // We're not adding anything, but we're not actually failing
               //
               return S_OK;
            }

            tmpstr = GT_LOCAL_POLICY;
            switch (SecmgrFolders[i].type) 
            {
               case AREA_POLICY:
                  newType = AREA_LOCALPOL;
                  break;

               case POLICY_ACCOUNT:
                  newType = LOCALPOL_ACCOUNT;
                  break;

               case POLICY_LOCAL:
                  newType = LOCALPOL_LOCAL;
                  break;

               case POLICY_EVENTLOG:
                  newType = LOCALPOL_EVENTLOG;
                  break;

               case POLICY_PASSWORD:
                  newType = LOCALPOL_PASSWORD;
                  break;

               case POLICY_KERBEROS:
                  newType = LOCALPOL_KERBEROS;
                  break;

               case POLICY_LOCKOUT:
                  newType = LOCALPOL_LOCKOUT;
                  break;

               case POLICY_AUDIT:
                  newType = LOCALPOL_AUDIT;
                  break;

               case POLICY_OTHER:
                  newType = LOCALPOL_OTHER;
                  break;

               case POLICY_LOG:
                  newType = LOCALPOL_LOG;
                  break;

               case AREA_PRIVILEGE:
                  newType = LOCALPOL_PRIVILEGE;
                  break;

               default:
                  newType = SecmgrFolders[i].type;
                  break;
            }

         int nImage = GetScopeImageIndex(newType);

         hr = folder->Create(cStrName.GetBuffer(2),    // Name
                             cStrDesc.GetBuffer(2),    // Description
                             tmpstr,                   // inf file name
                             nImage,                   // closed icon index
                             nImage,                   // open icon index
                             newType,                  // folder type
                             bHasChildren,             // has children
                             dwMode,                   // SCE Mode
                             NULL);                    // Extra Data
      } 
      else 
      {
         int nImage = GetScopeImageIndex(SecmgrFolders[i].type);

         hr = folder->Create(cStrName.GetBuffer(2),    // Name
                             cStrDesc.GetBuffer(2),    // Description
                             tmpstr,                   // inf file name
                             nImage,                   // closed icon index
                             nImage,                   // open icon index
                             SecmgrFolders[i].type,    // folder type
                             bHasChildren,             // has children
                             dwMode,                   // SCE Mode
                             NULL);                    // Extra Data

      }
      if (SUCCEEDED(hr)) 
      {
         m_scopeItemList.AddTail(folder);
         if ( i == nStart && NULL != pPos ) 
         {
            *pPos = m_scopeItemList.GetTailPosition();
         }
      } 
      else 
      {
         delete folder;
         return hr;
      }
   }

   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method:     EnumerateScopePane
//
//  Synopsis:   Add the child folders of cookie/pParent to MMC's scope pane tree
//
//  Arguments:  [cookie]  - The cookie representing the node's who we
//                          are enumerating
//              [pParent] - The id of the node we are enumerating
//              [dwMode]  - The mode SCE is operating under (only allowed for
//                                                           initial enumeration)
//
//  Returns:    none
//
//  Modifies:   m_ScopeItemList (via CreateFolderList)
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------

void CComponentDataImpl::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
   int i = 0;
   ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface
   if (NULL == m_pScope)
      return;



   m_bEnumerateScopePaneCalled = true;


   //
   // Enumerate the scope pane
   //

   // Note - Each cookie in the scope pane represents a folder.
   // A released product may have more then one level of children.
   // This sample assumes the parent node is one level deep.

   ASSERT(pParent != 0);
   if (0 == pParent)
      return;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (m_scopeItemList.GetCount() == 0 ) 
   {
      CreateFolderList(NULL, ROOT, NULL, NULL);
   }

   //
   // Enumerate the scope pane
   // return the folder object that represents the cookie
   // Note - for large list, use dictionary
   //
   CFolder* pThis = FindObject(cookie, NULL);
   if (NULL == pThis) 
      pThis = m_AnalFolder;

   ASSERT(pThis);
   if ( NULL == pThis ) 
      return;

   //
   // Note - Each cookie in the scope pane represents a folder.
   //

   //
   // If we've already enumerated this folder then don't do it again
   //
   if ( pThis->IsEnumerated() )
      return;

   POSITION pos = NULL;
   int nCount = 0;
   CFolder *pFolder = 0;


   //
   // the pParent is the enumerated node's item ID, not its parent ID
   //
   pThis->GetScopeItem()->ID = pParent;
   if (SUCCEEDED(CreateFolderList( pThis,
             pThis->GetType(),
             &pos,
             &nCount )))  
   {
      for (i=0; (i < nCount) && (pos != NULL); i++ ) 
      {
         pFolder = m_scopeItemList.GetNext(pos);

         ASSERT(NULL != pFolder);
         if ( pFolder == NULL ) 
         {
            continue;
         }
         LPSCOPEDATAITEM pScope;
         pScope = pFolder->GetScopeItem();

         ASSERT(NULL != pScope); //Validate pScope.
         if( !pScope ) //Raid #550912, yanggao.
         {
            break;
         }
         //
         // Set the parent
         //
         pScope->relativeID = pParent;

         //
         // Set the folder as the cookie
         //
         pScope->mask |= SDI_PARAM;
         pScope->lParam = reinterpret_cast<LPARAM>(pFolder);
         pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
         m_pScope->InsertItem(pScope);

         //
         // Note - On return, the ID member of 'm_pScopeItem'
         // contains the handle to the newly inserted item!
         //
         ASSERT(pScope->ID != NULL); //Bogus assertion
      }

      // This was commented out, but is needed to fix
      // 249158: SCE UI: Every time analysis is performed, another set of node appears
      // This flag will prevent the nodes from being re-enumerated.
      // If this doesn't work, then all the child nodes should be deleted before
      // reenumeration
      pThis->Set(TRUE);     // folder has been enumerated
   }
   else
   {
      //
      // Error creating folder list.  Make sure the folder isn't
      // marked as opened so that we can try to expand it again later
      //
      SCOPEDATAITEM item;

      ZeroMemory (&item, sizeof (item));
      item.mask = SDI_STATE;
      item.nState = 0;
      item.ID = pThis->GetScopeItem()->ID;
      //
      // Nothing else we can do if this returns a failure, so
      // don't worry about it
      //
      (void)m_pScope->SetItem (&item);
   }

}


/*------------------------------------------------------------------------------------------
CComponentDataImpl::GetColumnInfo

Synopsis:   Returns the column info for a folder type.

Arguments: [fType]  - The type of the CFolder item.

Returns:    a pointer to an int * where int[0] = the resource descritption into g_columnInfo.
                                        int[1] = the number of columns this array describes.
            NULL   - If there is no matching key.
------------------------------------------------------------------------------------------*/
PSCE_COLINFOARRAY CComponentDataImpl::GetColumnInfo( FOLDER_TYPES fType )
{
    PSCE_COLINFOARRAY pRet = NULL;
    if( m_mapColumns.Lookup(fType, pRet) )
    {
        return pRet;
    }
    return NULL;
}

/*------------------------------------------------------------------------------------------
CComponentDataImpl::SetColumnInfo

Synopsis:   Sets the column info for a certain type of folder.

Arguments: [fType]  - The type of the CFolder item.
           [pInfo]  - The new column info.
------------------------------------------------------------------------------------------*/
void CComponentDataImpl::SetColumnInfo( FOLDER_TYPES fType, PSCE_COLINFOARRAY pInfo)
{
    PSCE_COLINFOARRAY pCur = GetColumnInfo(fType);

    if(pCur)
    {
        LocalFree(pCur);
    }
    m_mapColumns.SetAt(fType, pInfo);
}

/*------------------------------------------------------------------------------------------
CComponentDataImpl::UpdateObjectStatus

Synopsis:   Updates the status of all objects under the child and parents if bUpdateThis
            is TRUE.

Arguments: [pParent]       - The Object to set status on
           [bUpdateThis]   - Weather to update the object or not.
------------------------------------------------------------------------------------------*/
DWORD CComponentDataImpl::UpdateObjectStatus(
   CFolder *pParent,
   BOOL bUpdateThis)
{
   if(!pParent)
      return ERROR_INVALID_PARAMETER;

   DWORD status = 0;
   TCHAR szBuf[50];

   switch(pParent->GetType())
   {
   case REG_OBJECTS:
      status = AREA_REGISTRY_SECURITY;
      break;

   case FILE_OBJECTS:
      status = AREA_FILE_SECURITY;
      break;

   default:
      return ERROR_INVALID_PARAMETER;
   }

   PSCE_OBJECT_CHILDREN     ObjectList  = NULL;
   PSCE_ERROR_LOG_INFO  ErrBuf      = NULL;
   SCESTATUS rc = 0;
   CString StrErr;
   SCOPEDATAITEM sci;

   HSCOPEITEM hItem = NULL;
   LONG_PTR pCookie = NULL;

   ZeroMemory(&sci, sizeof(SCOPEDATAITEM));
   sci.mask = SDI_STR | SDI_PARAM;

#define UPDATE_STATUS( X, O ) X->SetDesc( O->Status, O->Count );\
                           X->GetScopeItem()->nImage = GetScopeImageIndex( X->GetType(), O->Status);\
                           X->GetScopeItem()->nOpenImage = X->GetScopeItem()->nImage;

   LPCTSTR pszParent = NULL;
   if (bUpdateThis) 
   {
      CFolder *pCurrent = pParent;

      pParent->RemoveAllResultItems();
      m_pConsole->UpdateAllViews(NULL, (MMC_COOKIE)pParent, UAV_RESULTITEM_UPDATEALL);
      hItem = pCurrent->GetScopeItem()->ID;
      do {

         //
         // Walk up the items parent and update the items status.
         //
         if( m_pScope->GetParentItem( hItem, &hItem, &pCookie) == S_OK)
         {
            pszParent = (LPCTSTR)((CFolder *)pCookie)->GetName();
         } 
         else
            break;

         if(!pCookie)
            break;
         
         //
         // We are finished going up the parent.
         //

         switch( ((CFolder *)pCookie)->GetType() ) 
         {
            case AREA_REGISTRY_ANALYSIS:
            case AREA_FILESTORE_ANALYSIS:
               pszParent = NULL;
               break;

            default:
               break;
         }

         //
         // We have to get object information from the parent to the count parameter.
         //
         rc = SceGetObjectChildren(SadHandle,                   // hProfile
                                   SCE_ENGINE_SAP,              // Profile type
                                   (AREA_INFORMATION)status,    // Area
                                   (LPTSTR)pszParent,           // Object prefix
                                   &ObjectList,                 // Object list [out]
                                   &ErrBuf);
         if(ErrBuf)
         {
            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }

         if(SCESTATUS_SUCCESS != rc)
            break;

         //
         // Find object in link list.
         //
         DWORD i=0;

         sci.lParam = (LONG_PTR)pCurrent;
         GetDisplayInfo( &sci );

         PSCE_OBJECT_CHILDREN_NODE *pObjNode = &(ObjectList->arrObject);

         while(ObjectList && i<ObjectList->nCount)
         {
            if( pObjNode[i] &&
                pObjNode[i]->Name &&
                !lstrcmpi(sci.displayname, pObjNode[i]->Name) )
            {
               UPDATE_STATUS(pCurrent, pObjNode[i]);
               //
               // Update scopeItem.
               //
               m_pScope->SetItem(pCurrent->GetScopeItem());
               break;
            }
            i++;
         }

         if ( ObjectList ) 
         {
            SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );
            ObjectList = NULL;
         }

         pCurrent = (CFolder *)pCookie;
      } while( pszParent && hItem );
   }


   ObjectList = NULL;
   ErrBuf = NULL;

   //
   // Get Object children.
   //
   pszParent = pParent->GetName();
   rc = SceGetObjectChildren(SadHandle,                   // hProfile
                             SCE_ENGINE_SAP,              // Profile type
                             (AREA_INFORMATION)status,    // Area
                             (LPTSTR)pszParent,           // Object prefix
                             &ObjectList,                 // Object list [out]
                             &ErrBuf);
   //
   // Error list [out]
   //
   if ( ErrBuf ) 
   {
      MyFormatResMessage(rc, IDS_ERROR_GETTING_LAST_ANALYSIS, ErrBuf, StrErr);

      SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
      ErrBuf = NULL;
   }

   if ( SCESTATUS_SUCCESS == rc) 
   {
      //
      // Update all the children.
      //
      if( m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &hItem, &pCookie) == S_OK && pCookie)
      {
         sci.lParam = (LONG_PTR)pCookie;

         GetDisplayInfo(&sci);
         while(hItem)
         {
            pParent = reinterpret_cast<CFolder *>(pCookie);
            //
            // Find object in object list.
            //
            DWORD i=0;
            while( ObjectList && i<ObjectList->nCount )
            {
               if( (&(ObjectList->arrObject))[i] &&
                   (&(ObjectList->arrObject))[i]->Name &&
                   !lstrcmpi((&(ObjectList->arrObject))[i]->Name, (LPCTSTR)sci.displayname) )
               {
                  UPDATE_STATUS(pParent, (&(ObjectList->arrObject))[i]);
                  //
                  // Update this objects children.
                  //
                  UpdateObjectStatus( pParent, FALSE );

                  //
                  // Update the name space
                  //
                  pParent->RemoveAllResultItems();
                  m_pConsole->UpdateAllViews(NULL, (MMC_COOKIE)pParent, UAV_RESULTITEM_UPDATEALL);
                  m_pScope->SetItem(pParent->GetScopeItem());
                  break;
               }
               i++;
            }

            if(ObjectList == NULL || i >= ObjectList->nCount)
            {
               //
               // Couldn't find the item, so just stop.
               //
               break;
            }

            //
            // Next Scope item
            //
            if( m_pScope->GetNextItem(hItem, &hItem, &pCookie) != S_OK)
            {
               break;
            }
         }
      }
   }

   if ( ObjectList )
      SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );

   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\selfdeletingpropertypage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       SelfDeletingPropertyPage.h
//
//--------------------------------------------------------------------------
#ifndef __SELFDELETINGPROPERTYPAGE_H
#define __SELFDELETINGPROPERTYPAGE_H

class CSelfDeletingPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CSelfDeletingPropertyPage)

public:
    CSelfDeletingPropertyPage ();
    CSelfDeletingPropertyPage (UINT nIDTemplate, UINT nIDCaption = 0);
    CSelfDeletingPropertyPage (LPCTSTR lpszTemplateName, UINT nIDCaption = 0);
	virtual ~CSelfDeletingPropertyPage ();

private:
    static UINT CALLBACK PropSheetPageProc(
        HWND hwnd,	
        UINT uMsg,	
        LPPROPSHEETPAGE ppsp);

    // hook up the callback for C++ object destruction
    LPFNPSPCALLBACK m_pfnOldPropCallback;
};

#endif // __SELFDELETINGPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\servperm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ServPerm.h
//
//  Contents:   definition of CSecurityInfo
//
//----------------------------------------------------------------------------

#ifndef __SERVPERM_H_INCLUDED__
#define __SERVPERM_H_INCLUDED__

// #include "cookie.h"

#define CONFIG_SECURITY_PAGE_READ_ONLY      1
#define CONFIG_SECURITY_PAGE_NO_PROTECT     2
#define CONFIG_SECURITY_PAGE                3
#define CONFIG_SECURITY_PAGE_RO_NP          4
#define ANALYSIS_SECURITY_PAGE_READ_ONLY    5
#define ANALYSIS_SECURITY_PAGE_NO_PROTECT   6
#define ANALYSIS_SECURITY_PAGE              7
#define ANALYSIS_SECURITY_PAGE_RO_NP        8
#define SECURITY_PAGE                       9
#define SECURITY_PAGE_NO_PROTECT            10
#define SECURITY_PAGE_READ_ONLY             11 
#define SECURITY_PAGE_RO_NP                 12 

//Bug 424909, Yanggao, 6/29/2001
struct __declspec(uuid("965FC360-16FF-11d0-91CB-00AA00BBB723")) ISecurityInformation;

#ifdef _ATL_DEBUG
#define END_SEC_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} 
#else
#define END_SEC_COM_MAP() {NULL, 0, 0}}; return _entries;} 
#endif // _ATL_DEBUG

class CSecurityInfo : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInfo)
    BEGIN_COM_MAP(CSecurityInfo)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

private:
    CString m_strMachineName;
    CString m_strObjectName;
    SE_OBJECT_TYPE m_SeType;
    HINSTANCE m_hInstance;

protected:
//    CResult * m_pData;
    BOOL m_bIsContainer;
    int m_flag;
    PSECURITY_DESCRIPTOR *m_ppSD;
    SECURITY_INFORMATION *m_pSeInfo;

    HRESULT NewDefaultDescriptor(
        PSECURITY_DESCRIPTOR* ppsd,
        SECURITY_INFORMATION RequestedInformation);

    // this will throw a memory exception where appropriate
//    HRESULT MakeSelfRelativeCopy(
//        PSECURITY_DESCRIPTOR  psdOriginal,
//        PSECURITY_DESCRIPTOR* ppsdNew );

public:
//    void Initialize(CResult *pData, int flag);
//    void Initialize(CResult *pData, PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
    void Initialize(BOOL bIsContainer, PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
    void SetMachineName( LPCTSTR pszMachineName );
    void SetObjectName( LPCTSTR pszObjectName ) { m_strObjectName = pszObjectName; }
    void SetTypeInstance(SE_OBJECT_TYPE SeType, HINSTANCE hInstance)
    { m_SeType = SeType; m_hInstance = hInstance; }

    LPTSTR QueryMachineName()
    {
        return (m_strMachineName.IsEmpty())
            ? NULL
            : const_cast<LPTSTR>((LPCTSTR)m_strMachineName);
    }
    LPTSTR QueryObjectName()
    {
        return const_cast<LPTSTR>((LPCTSTR)m_strObjectName);
    }
};

class CDsSecInfo : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CDsSecInfo)
    BEGIN_COM_MAP(CDsSecInfo)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_SEC_COM_MAP()

public:
    CDsSecInfo()
    {
        m_dwRefCount = 0;
        m_pISecInfo = NULL;
    }
    virtual ~CDsSecInfo()
    {
        ASSERT(m_dwRefCount == 0); //bogus assertion.
        if (m_pISecInfo != NULL)
            m_pISecInfo->Release();
    }
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj)
    {
        return m_pISecInfo->QueryInterface(riid, ppvObj);
    }
    STDMETHOD_(ULONG,AddRef) ()
    {
        m_dwRefCount++;
        return m_pISecInfo->AddRef();
    }
    STDMETHOD_(ULONG,Release) ()
    {
        m_dwRefCount--;
        // this might be the last release on the page holder
        // which would cause the holder to delete itself and
        // "this" in the process (i.e. "this" no more valid when
        // returning from the m_pPageHolder->Release() call
        ISecurityInformation* pISecInfo = m_pISecInfo;

        return pISecInfo->Release();
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo )
    {
        return m_pISecInfo->GetObjectInformation(pObjectInfo);
    }
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess )
    {
        return m_pISecInfo->GetAccessRights(pguidObjectType,
                                            dwFlags,
                                            ppAccess,
                                            pcAccesses,
                                            piDefaultAccess);
    }
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask)
    {
        return m_pISecInfo->MapGeneric(pguidObjectType,
                                        pAceFlags,
                                        pMask);
    }
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes )
    {
        return m_pISecInfo->GetInheritTypes(ppInheritTypes,
                                            pcInheritTypes);
    }
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
    {
        return m_pISecInfo->PropertySheetPageCallback(hwnd, uMsg, uPage);
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );

private:
    DWORD m_dwRefCount;
    ISecurityInformation* m_pISecInfo;  // interface pointer to the wrapped interface

protected:
    int m_flag;
    PSECURITY_DESCRIPTOR *m_ppSD;
    SECURITY_INFORMATION *m_pSeInfo;

public:
//    void Initialize(CResult *pData, int flag);
    HRESULT Initialize(LPTSTR LdapName, PFNDSCREATEISECINFO pfnCreateDsPage,
                    PSECURITY_DESCRIPTOR *ppSeDescriptor=NULL, SECURITY_INFORMATION *pSeInfo=NULL, int flag=0);
};

typedef CDsSecInfo *LPDSSECINFO;

INT_PTR MyCreateSecurityPage2(
    BOOL bIsContainer, //CResult *pData,
    PSECURITY_DESCRIPTOR *ppSeDescriptor,
    SECURITY_INFORMATION *pSeInfo,
    LPCTSTR ObjectName,
    SE_OBJECT_TYPE SeType,
    int flag,
    HWND hwndParent,
    BOOL bModeless);

INT_PTR MyCreateDsSecurityPage(
    LPDSSECINFO *ppSI,
    PFNDSCREATEISECINFO pfnCreateDsPage,
    PSECURITY_DESCRIPTOR *ppSeDescriptor,
    SECURITY_INFORMATION *pSeInfo,
    LPCTSTR ObjectName,
    int flag,
    HWND hwndParent);

#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\servperm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       servperm.cpp
//
//  Contents:   implementation of CSecurityInfo
//
//----------------------------------------------------------------------------
#include "stdafx.h"

extern "C"
{
    #include <seopaque.h>   // RtlObjectAceSid, etc.
}
#include "resource.h"
#include "initguid.h"
#include "ServPerm.h"
#include "util.h"
#include "uithread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//extern "C"
//STDAPI
//DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
//                            LPCWSTR pwszObjectClass,
//                            DWORD dwFlags,
//                            LPSECURITYINFO *ppSI,
//                            PFNREADOBJECTSECURITY pfnReadSD,
//                            PFNWRITEOBJECTSECURITY pfnWriteSD,
//                            LPARAM lpContext);
//

/*
HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
*/
static HINSTANCE        g_hAclUiDll = NULL;
typedef HPROPSHEETPAGE  (WINAPI *PFNCSECPAGE)(LPSECURITYINFO);

#ifndef PERM_HEADER_DEFINED
#define PERM_HEADER_DEFINED

#define INHERIT_FULL        (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//For ntfs
//
// Treat SYNCHRONIZE specially. In particular, always allow SYNCHRONIZE and
// never Deny SYNCHRONIZE. Do this by removing it from the Generic Mapping,
// turning it off in all ACEs and SI_ACCESS entries, and then adding it to
// all Allow ACEs before saving a new ACL.
//Keep this in sync with ISecurityInfromation impl for FileSystem
#define FILE_GENERIC_READ_      (FILE_GENERIC_READ    & ~SYNCHRONIZE)
#define FILE_GENERIC_WRITE_     (FILE_GENERIC_WRITE   & ~(SYNCHRONIZE | READ_CONTROL))
#define FILE_GENERIC_EXECUTE_   (FILE_GENERIC_EXECUTE & ~SYNCHRONIZE)
#define FILE_GENERIC_ALL_       (FILE_ALL_ACCESS      & ~SYNCHRONIZE)

#define FILE_GENERAL_MODIFY     (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_ | DELETE)
#define FILE_GENERAL_PUBLISH    (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_DEPOSIT    (FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_READ_EX    (FILE_GENERIC_READ_  | FILE_GENERIC_EXECUTE_)



#define iFileDefAccess      2   // FILE_GEN_READ
#define iKeyDefAccess       2   // KEY_READ

#endif

#include <initguid.h>
DEFINE_GUID(GUID_A_NT_GROUP_MEMBERS,  0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2);
//
// define all access rights for files on general page and/or specific page
//
static SI_ACCESS siFileAccesses[] =
{
    { &GUID_NULL, FILE_GENERIC_ALL_,        MAKEINTRESOURCE(IDS_FILE_GEN_ALL),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_MODIFY,      MAKEINTRESOURCE(IDS_FILE_GEN_MODIFY),       SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX,     MAKEINTRESOURCE(IDS_FILE_GEN_READ),         SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX,     MAKEINTRESOURCE(IDS_FILE_GEN_LIST),         SI_ACCESS_CONTAINER | CONTAINER_INHERIT_ACE },
    { &GUID_NULL, FILE_GENERIC_READ_,       MAKEINTRESOURCE(IDS_FILE_GENERIC_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERIC_WRITE_,      MAKEINTRESOURCE(IDS_FILE_GENERIC_WRITE),    SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_EXECUTE,             MAKEINTRESOURCE(IDS_FILE_SPEC_EXECUTE),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_DATA,           MAKEINTRESOURCE(IDS_FILE_SPEC_READ_DATA),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_ATTRIBUTES,     MAKEINTRESOURCE(IDS_FILE_SPEC_READ_ATTR),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_EA,             MAKEINTRESOURCE(IDS_FILE_SPEC_READ_EA),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_DATA,          MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_DATA),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_APPEND_DATA,         MAKEINTRESOURCE(IDS_FILE_SPEC_APPEND_DATA), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_ATTRIBUTES,    MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_ATTR),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_EA,            MAKEINTRESOURCE(IDS_FILE_SPEC_WRITE_EA),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_DELETE_CHILD,        MAKEINTRESOURCE(IDS_FILE_SPEC_DELETE_CHILD),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
//    { &GUID_NULL, SYNCHRONIZE,            MAKEINTRESOURCE(IDS_STD_SYNCHRONIZE),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NONE),                  0 },
    { &GUID_NULL, FILE_GENERIC_EXECUTE_,    MAKEINTRESOURCE(IDS_FILE_GENERIC_EXECUTE),  0 },
    { &GUID_NULL, FILE_GENERAL_DEPOSIT,     MAKEINTRESOURCE(IDS_FILE_GENERAL_DEPOSIT),  0 },
    { &GUID_NULL, FILE_GENERAL_PUBLISH,     MAKEINTRESOURCE(IDS_FILE_GENERAL_PUBLISH),  0 },
};
//
// define all access rights for keys on general page and/or specific page
//
static SI_ACCESS siKeyAccesses[] =
{
   { &GUID_NULL, KEY_ALL_ACCESS,     MAKEINTRESOURCE(IDS_KEY_ALL_ACCESS),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE},
   { &GUID_NULL, KEY_READ,           MAKEINTRESOURCE(IDS_KEY_READ),                 SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE},   
   { &GUID_NULL, KEY_QUERY_VALUE,    MAKEINTRESOURCE(IDS_KEY_QUERY_VALUE),          SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_SET_VALUE,      MAKEINTRESOURCE(IDS_KEY_SET_VALUE),            SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_CREATE_SUB_KEY, MAKEINTRESOURCE(IDS_KEY_CREATE_SUB_KEY),       SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_ENUMERATE_SUB_KEYS,MAKEINTRESOURCE(IDS_KEY_ENUMERATE_SUB_KEYS),SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_NOTIFY,         MAKEINTRESOURCE(IDS_KEY_NOTIFY),               SI_ACCESS_SPECIFIC},
   { &GUID_NULL, KEY_CREATE_LINK,    MAKEINTRESOURCE(IDS_KEY_CREATE_LINK),          SI_ACCESS_SPECIFIC},
   { &GUID_NULL, DELETE,             MAKEINTRESOURCE(IDS_STD_DELETE),               SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE},
   { &GUID_NULL, READ_CONTROL,       MAKEINTRESOURCE(IDS_STD_READ_CONTROL),         SI_ACCESS_SPECIFIC },
   { &GUID_NULL, WRITE_DAC,          MAKEINTRESOURCE(IDS_STD_WRITE_DAC),            SI_ACCESS_SPECIFIC },
   { &GUID_NULL, WRITE_OWNER,        MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),          SI_ACCESS_SPECIFIC },
   { &GUID_NULL, 0,                  MAKEINTRESOURCE(IDS_NONE),                     0}
};
//
// define generic mapping for files
// This is consistent with the NETUI code
//
static GENERIC_MAPPING FileMap =
{
    FILE_GENERIC_READ_,
    FILE_GENERIC_WRITE_,
    FILE_GENERIC_EXECUTE_,
    FILE_GENERIC_ALL_
};
//
// define generic mapping for keys
//
static GENERIC_MAPPING KeyMap =
{
//    STANDARD_RIGHTS_READ     | 0x1,
//    STANDARD_RIGHTS_WRITE    | 0x2,
//    STANDARD_RIGHTS_EXECUTE  | 0x4,
//    STANDARD_RIGHTS_REQUIRED | 0x7F
    KEY_READ,
    KEY_WRITE,
    KEY_EXECUTE,
    KEY_ALL_ACCESS
};
//
// The following array defines the inheritance types for NTFS.
//
static SI_INHERIT_TYPE siFileInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_FILE_FOLDER),
    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_FILE_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_FILE_FOLDER_SUBFOLDER),
    &GUID_NULL, OBJECT_INHERIT_ACE,                                            MAKEINTRESOURCE(IDS_FILE_FOLDER_FILE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_FILE_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_FILE_SUBFOLDER_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,                         MAKEINTRESOURCE(IDS_FILE_FILE_ONLY)
};
//
// The following array defines the inheritance types for Registry.
//
//
// For Keys, objects and containers are the same, so no need for OBJECT_INHERIT_ACE
//
static SI_INHERIT_TYPE siKeyInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_KEY_FOLDER),
//    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBFOLDER),
//    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_KEY_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_KEY_SUBFOLDER_ONLY)
};
//
// constants for services
//
#define SERVICE_GENERIC_READ        (STANDARD_RIGHTS_READ |\
                                     SERVICE_QUERY_CONFIG |\
                                     SERVICE_QUERY_STATUS |\
                                     SERVICE_ENUMERATE_DEPENDENTS |\
                                     SERVICE_INTERROGATE |\
                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE |\
                                     SERVICE_START |\
                                     SERVICE_STOP |\
                                     SERVICE_PAUSE_CONTINUE)
//                                     SERVICE_INTERROGATE |\
//                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE |\
                                     SERVICE_CHANGE_CONFIG )
//
// access rights for services
//
static SI_ACCESS siServiceAccesses[] =
{
    { &GUID_NULL, SERVICE_ALL_ACCESS,        MAKEINTRESOURCE(IDS_SERVICE_ALL),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_GENERIC_READ,      MAKEINTRESOURCE(IDS_SERVICE_READ),         SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_GENERIC_EXECUTE,   MAKEINTRESOURCE(IDS_SERVICE_EXECUTE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_GENERIC_WRITE,     MAKEINTRESOURCE(IDS_SERVICE_WRITE),        SI_ACCESS_GENERAL },
    { &GUID_NULL, SERVICE_QUERY_CONFIG,      MAKEINTRESOURCE(IDS_SERVICE_QUERY_CONFIG), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_CHANGE_CONFIG,     MAKEINTRESOURCE(IDS_SERVICE_CHANGE_CONFIG),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_QUERY_STATUS,      MAKEINTRESOURCE(IDS_SERVICE_QUERY_STATUS), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_ENUMERATE_DEPENDENTS,MAKEINTRESOURCE(IDS_SERVICE_ENUMERATE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_START,             MAKEINTRESOURCE(IDS_SERVICE_START),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_STOP,              MAKEINTRESOURCE(IDS_SERVICE_STOP),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_PAUSE_CONTINUE,    MAKEINTRESOURCE(IDS_SERVICE_PAUSE),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_INTERROGATE,       MAKEINTRESOURCE(IDS_SERVICE_INTERROGATE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, SERVICE_USER_DEFINED_CONTROL,MAKEINTRESOURCE(IDS_SERVICE_USER_CONTROL),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,               MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,         MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,            MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,          MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                    MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iServiceDefAccess   2   // SERVICE_GEN_EXECUTE
//
// generic mapping for services
//
static GENERIC_MAPPING ServiceMap =
{
    SERVICE_GENERIC_READ,
    SERVICE_GENERIC_WRITE,
    SERVICE_GENERIC_EXECUTE,
    SERVICE_ALL_ACCESS
};

/*
// No need to define inherit type for service because there is no subfolders/items

#define DS_ACC_READ                 (STANDARD_RIGHTS_READ |\
                                     ACTRL_DS_LIST |\
                                     ACTRL_DS_READ_PROP )

#define DS_ACC_WRITE                (STANDARD_RIGHTS_WRITE    |\
                                     ACTRL_DS_WRITE_PROP |\
                                     ACTRL_DS_SELF)

#define DS_ACC_EXECUTE              (STANDARD_RIGHTS_EXECUTE  |\
                                     ACTRL_DS_LIST )

// generic all
#define DS_ACC_ALL                  ((STANDARD_RIGHTS_REQUIRED) |\
                                     (ACTRL_DS_CREATE_CHILD) |\
                                     (ACTRL_DS_DELETE_CHILD) |\
                                     (ACTRL_DS_READ_PROP) |\
                                     (ACTRL_DS_WRITE_PROP) |\
                                     (ACTRL_DS_LIST) |\
                                     (ACTRL_DS_SELF))

static SI_ACCESS siDsAccesses[] =
{
    { &GUID_NULL, DS_ACC_ALL,               MAKEINTRESOURCE(IDS_DS_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DS_ACC_READ,              MAKEINTRESOURCE(IDS_DS_READ),       SI_ACCESS_GENERAL },
    { &GUID_NULL, DS_ACC_WRITE,             MAKEINTRESOURCE(IDS_DS_WRITE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_DS_ACTRL_LIST),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_DS_ACTRL_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_DS_ACTRL_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_A_NT_GROUP_MEMBERS,ACTRL_DS_SELF,MAKEINTRESOURCE(IDS_DS_ACTRL_SELF),        SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_STD_DELETE),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_STD_READ_CONTROL),      SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_STD_WRITE_DAC),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_STD_WRITE_OWNER),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_DS_ACTRL_CREATE),       SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_DS_ACTRL_DELETE),       SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NONE),                  0 },

};
#define iDsDefAccess   1   // DS_ACC_READ
#define iDSProperties  4   // Read/Write properties


//
// Standard DS generic access rights mapping
//
static GENERIC_MAPPING DsMap =
{
    DS_ACC_READ,
    DS_ACC_WRITE,
    DS_ACC_EXECUTE,
    DS_ACC_ALL
};

// The following array defines the inheritance types common to all DS containers.
SI_INHERIT_TYPE siDsInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_FOLDER)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_FOLDER_SUBFOLDER) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBFOLDER_ONLY)      },
};
*/
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif


void CSecurityInfo::SetMachineName( LPCTSTR pszMachineName )
{
    if ( pszMachineName == NULL )
        m_strMachineName.Empty();
    else
        m_strMachineName = pszMachineName;
}

STDMETHODIMP
CSecurityInfo::GetAccessRights (
    IN const GUID* pguidObjectType,
    IN DWORD dwFlags,
    OUT PSI_ACCESS *ppAccess,
    OUT ULONG *pcAccesses,
    OUT ULONG *piDefaultAccess )
/*
Retrieve access rights array and the default element
*/
{
    ASSERT(ppAccess != NULL);
    ASSERT(pcAccesses != NULL);
    ASSERT(piDefaultAccess != NULL);

    if ( ppAccess == NULL || pcAccesses == NULL || piDefaultAccess == NULL ) {
        return E_FAIL;
    }

    switch (m_SeType ) {
    case SE_FILE_OBJECT:
        *ppAccess = siFileAccesses;
        *pcAccesses = ARRAYSIZE(siFileAccesses);
        *piDefaultAccess = iFileDefAccess;
        break;
    case SE_REGISTRY_KEY:
        *ppAccess = siKeyAccesses;
        *pcAccesses = ARRAYSIZE(siKeyAccesses);
        *piDefaultAccess = iKeyDefAccess;
        break;
    case SE_SERVICE:
        *ppAccess = siServiceAccesses;
        *pcAccesses = ARRAYSIZE(siServiceAccesses);
        *piDefaultAccess = iServiceDefAccess;
        break;
//    case SE_DS_OBJECT:
//        *ppAccess = siDsAccesses;
//        *pcAccesses = ARRAYSIZE(siDsAccesses);
//        *piDefaultAccess = iDsDefAccess;
        break;
    }
/*
    if (dwFlags & SI_EDIT_AUDITS) {
    } else {
    }
*/
    return S_OK;
}

STDMETHODIMP
CSecurityInfo::MapGeneric (
    IN const GUID *pguidObjectType,
    OUT UCHAR *pAceFlags,
    OUT ACCESS_MASK *pMask)
/*
Map generic rights to specific rights based on object type
*/
{
    ASSERT(pMask != NULL);

    if ( pMask == NULL ) {
        return E_FAIL;
    }

    switch(m_SeType) {
    case SE_FILE_OBJECT:
        MapGenericMask(pMask, &FileMap);
        *pMask = *pMask & (~SYNCHRONIZE); //Raid #340750, 4/12/2001
        break;
    case SE_REGISTRY_KEY:
        MapGenericMask(pMask, &KeyMap);
        break;
    case SE_SERVICE:
        MapGenericMask(pMask, &ServiceMap);
        break;
//    case SE_DS_OBJECT:
//        MapGenericMask(pMask, &DsMap);
        break;
    }

    return S_OK;
}

STDMETHODIMP
CSecurityInfo::GetInheritTypes (
    OUT PSI_INHERIT_TYPE *ppInheritTypes,
    OUT ULONG *pcInheritTypes )
/*
Retrieve inherit type array based on the object type
*/
{
    ASSERT(ppInheritTypes != NULL);
    ASSERT(pcInheritTypes != NULL);

    if ( !ppInheritTypes || !pcInheritTypes ) {
        return E_FAIL;
    }

    switch (m_SeType ) {
    case SE_FILE_OBJECT:
        *ppInheritTypes = siFileInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siFileInheritTypes);
        break;
    case SE_REGISTRY_KEY:
        *ppInheritTypes = siKeyInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siKeyInheritTypes);
        break;
//    case SE_DS_OBJECT:
//        *ppInheritTypes = siDsInheritTypes;
//        *pcInheritTypes = ARRAYSIZE(siDsInheritTypes);
//        break;
    case SE_SERVICE:
       *ppInheritTypes = NULL;
       *pcInheritTypes = NULL;

        break;
    }

    return S_OK;
}

STDMETHODIMP
CSecurityInfo::PropertySheetPageCallback(
    HWND hwnd,
    UINT uMsg,
    SI_PAGE_TYPE uPage )
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP
CSecurityInfo::GetObjectInformation (
    IN OUT PSI_OBJECT_INFO pObjectInfo )
/*
Retrieve information for the object to display
*/
{
    ASSERT(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo))); // Check the expression. 

    if ( pObjectInfo == NULL || IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo))) { //Raid #550912, yanggao.
        return E_FAIL;
    }
    //
    // query the edit flag dwFlags
    //
    pObjectInfo->dwFlags = SI_ADVANCED;

    switch ( m_SeType ) {
    case SE_FILE_OBJECT:
//        if ( m_pData->GetID() &&
//             ((PSCE_OBJECT_SECURITY)(m_pData->GetID()))->IsContainer )
//            pObjectInfo->dwFlags |= SI_CONTAINER;
        if ( m_bIsContainer ) {
            pObjectInfo->dwFlags |= SI_CONTAINER;
        }

        break;

    case SE_SERVICE:
        break;
    default:
        pObjectInfo->dwFlags |= SI_CONTAINER;
        break;
    }

    switch ( m_flag ) {
    case SECURITY_PAGE_READ_ONLY:
    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_READ_ONLY:
        pObjectInfo->dwFlags |= SI_READONLY;
        break;
    case SECURITY_PAGE_RO_NP:
    case CONFIG_SECURITY_PAGE_RO_NP:
    case ANALYSIS_SECURITY_PAGE_RO_NP:
        pObjectInfo->dwFlags |= (SI_READONLY | SI_NO_ACL_PROTECT);
        break;
    case CONFIG_SECURITY_PAGE_NO_PROTECT:
    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
    case SECURITY_PAGE_NO_PROTECT:
        if ( SE_SERVICE == m_SeType ) {
//           pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_NO_ACL_PROTECT );
            pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_EDIT_AUDITS | SI_NO_ACL_PROTECT );
        } else {
            pObjectInfo->dwFlags |= (SI_EDIT_ALL | SI_NO_ACL_PROTECT);
        }

        break;
    default:
        if ( SE_SERVICE == m_SeType ) {
            pObjectInfo->dwFlags |= (SI_EDIT_PERMS | SI_EDIT_AUDITS );
        } else {
            pObjectInfo->dwFlags |= SI_EDIT_ALL;
        }
    }

    pObjectInfo->hInstance = m_hInstance;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryObjectName();
    return S_OK;
}

STDMETHODIMP
CSecurityInfo::GetSecurity(
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN BOOL fDefault )
/*
Retrieve security descriptor for the requested security information to display
*/
{
    if (0 == RequestedInformation ) 
	{
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (fDefault)
        return E_NOTIMPL;

    if ( NULL == ppSecurityDescriptor ) 
	{
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    // should also check for SeInfo
    if ( m_ppSD != NULL && *m_ppSD != NULL ) 
	{
		// Added check for SECURITY_PAGE_RO_NP (read-only) because it was
		// preventing viewing of security information in RSOP
         if ( m_pSeInfo && SECURITY_PAGE_RO_NP != m_flag &&
              ( 0 == (RequestedInformation & (*m_pSeInfo)) ) ) 
		 {
             *ppSecurityDescriptor = NULL;
         } 
		 else 
		 {
            if ( !IsValidSecurityDescriptor(*m_ppSD)) 
			{
               ASSERT(FALSE);
               return E_INVALIDARG;
            }

            MyMakeSelfRelativeSD(*m_ppSD,ppSecurityDescriptor);
         }

    } 
	else 
	{
        *ppSecurityDescriptor = NULL;
    }

    return S_OK;

}

void
FixSynchronizeAccess(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    if (NULL != pSD && 0 != (si & DACL_SECURITY_INFORMATION))
    {
        BOOL bPresent;
        BOOL bDefault;
        PACL pDacl = NULL;

        GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);

        if (pDacl)
        {
            PACE_HEADER pAce;
            int i;

            for (i = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
                 i < pDacl->AceCount;
                 i++, pAce = (PACE_HEADER)NextAce(pAce))
            {
                if (ACCESS_ALLOWED_ACE_TYPE == pAce->AceType)
                    ((PKNOWN_ACE)pAce)->Mask |= SYNCHRONIZE;
            }
        }
    }
}


STDMETHODIMP CSecurityInfo::SetSecurity (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor )
/*
Save security descriptor for the SecurityInformation to your own storage

This method can be called multiple times for different security inforamtion.
Since SCE is saving the final security descriptor (combined) in m_ppSD,
this method must handle each component (Owner, Dacl, and Sacl) without overwritting
other components.
*/
{

   if ( pSecurityDescriptor == NULL || SecurityInformation == 0 )
      return S_OK;

   if ( m_flag == CONFIG_SECURITY_PAGE_READ_ONLY ||
        m_flag == ANALYSIS_SECURITY_PAGE_READ_ONLY ||
        m_flag == SECURITY_PAGE_READ_ONLY )
      return S_OK;

   if ( m_ppSD != NULL ) {
      //
      // only replace "SecurityInformation" part in m_ppSD
      //
      if ( m_pSeInfo && (SecurityInformation == *m_pSeInfo) ) {
         //
         // exactly same component
         //
         if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

         MyMakeSelfRelativeSD(pSecurityDescriptor, m_ppSD);

      } else {

         SECURITY_INFORMATION TempSeInfo;
         SECURITY_DESCRIPTOR_CONTROL sdcControl = 0;

         if ( m_pSeInfo )
            TempSeInfo = (*m_pSeInfo) & ~SecurityInformation;
         else
            TempSeInfo = 0x0F & ~SecurityInformation;

         PSID pOwner=NULL, pOwnerNew=NULL;
         PACL pDacl=NULL, pDaclNew=NULL;
         PACL pSacl=NULL, pSaclNew=NULL;
         BOOL bDefault, bPresent;

         //
         // save the other components first
         //
         SECURITY_DESCRIPTOR_CONTROL sdc = 0;
         DWORD dwRevision = 0;
         if ( *m_ppSD ) {
            GetSecurityDescriptorControl( *m_ppSD, &sdc, &dwRevision );                
            if ( TempSeInfo & OWNER_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               if ( !GetSecurityDescriptorOwner (
                                                *m_ppSD,
                                                &pOwner,
                                                &bDefault
                                                ) || bDefault )
                  pOwner = NULL;
               sdcControl |= (sdc & SE_OWNER_DEFAULTED);
            }
            if ( TempSeInfo & DACL_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               bPresent = FALSE;

               if ( !GetSecurityDescriptorDacl (
                                               *m_ppSD,
                                               &bPresent,
                                               &pDacl,
                                               &bDefault
                                               ) || !bPresent || bDefault )
                  pDacl = NULL;
               sdcControl |= (sdc & (SE_DACL_AUTO_INHERIT_REQ | 
                                     SE_DACL_AUTO_INHERITED | 
                                     SE_DACL_PROTECTED
                                    ));
            }

            if ( TempSeInfo & SACL_SECURITY_INFORMATION ) {
               bDefault = FALSE;
               bPresent = FALSE;

               if ( !GetSecurityDescriptorSacl (
                                               *m_ppSD,
                                               &bPresent,
                                               &pSacl,
                                               &bDefault
                                               ) || !bPresent || bDefault )
                  pSacl = NULL;
               sdcControl |= (sdc & (SE_SACL_AUTO_INHERIT_REQ | 
                                     SE_SACL_AUTO_INHERITED | 
                                     SE_SACL_PROTECTED
                                    ));
            }
         }

         //
         // check the new components
         //
         sdc = 0;
         dwRevision = 0;
         GetSecurityDescriptorControl( pSecurityDescriptor, &sdc, &dwRevision );
         if ( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            if ( !GetSecurityDescriptorOwner (
                                             pSecurityDescriptor,
                                             &pOwnerNew,
                                             &bDefault
                                             ) || bDefault )
               pOwnerNew = NULL;
            pOwner = pOwnerNew;
            sdcControl |= (sdc & SE_OWNER_DEFAULTED);
         }
         if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            bPresent = FALSE;
            if ( !GetSecurityDescriptorDacl (
                                            pSecurityDescriptor,
                                            &bPresent,
                                            &pDaclNew,
                                            &bDefault
                                            ) || !bPresent || bDefault )
               pDaclNew = NULL;
            pDacl = pDaclNew;
            sdcControl |= (sdc & (SE_DACL_AUTO_INHERIT_REQ | 
                                  SE_DACL_AUTO_INHERITED | 
                                  SE_DACL_PROTECTED
                                 ));
         }

         if ( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            bDefault = FALSE;
            bPresent = FALSE;

            if ( !GetSecurityDescriptorSacl (
                                            pSecurityDescriptor,
                                            &bPresent,
                                            &pSaclNew,
                                            &bDefault
                                            ) || !bPresent || bDefault )
               pSaclNew = NULL;
            pSacl = pSaclNew;
            sdcControl |= (sdc & (SE_SACL_AUTO_INHERIT_REQ | 
                                  SE_SACL_AUTO_INHERITED | 
                                  SE_SACL_PROTECTED
                                 ));
         }

         if ( m_pSeInfo )
            *m_pSeInfo |= SecurityInformation;

         //
         // build a temp security descriptor
         //
         SECURITY_DESCRIPTOR sd;

         //This is a safe usage.
         InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
         //This is a safe usage.
         if ( pOwner )
            SetSecurityDescriptorOwner (&sd, pOwner, FALSE);
         //This is a safe usage.
         if ( pDacl )
            SetSecurityDescriptorDacl (&sd, TRUE, pDacl, FALSE);
         //This is a safe usage.
         if ( pSacl )
            SetSecurityDescriptorSacl (&sd, TRUE, pSacl, FALSE);

         sd.Control |= sdcControl;
         //
         // re-create the final security descriptor
         //
         PSECURITY_DESCRIPTOR pTempSD=NULL;

         MyMakeSelfRelativeSD(&sd, &pTempSD);
         //
         // must free this after pTempSD is made, because sd is in absolute format
         //
         if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

         *m_ppSD = pTempSD;
      }
         //Treat Synchronize Specially
         if( m_SeType == SE_FILE_OBJECT )
         {
            FixSynchronizeAccess(SecurityInformation,*m_ppSD);
         }            

   } else {
      return E_INVALIDARG;
   }
   return S_OK;
}

//
// original code from \\marsslm\backup\src\ncpmgr\ncpmgr\shareacl.cxx
// ACL-wrangling templated from \net\ui\common\src\lmobj\lmobj\security.cxx
//
// caller must free using "release"
//
HRESULT CSecurityInfo::NewDefaultDescriptor(
    PSECURITY_DESCRIPTOR* ppsd,
    SECURITY_INFORMATION RequestedInformation
    )
{
    *ppsd = NULL;
    PSID psidWorld = NULL;
    PSID psidAdmins = NULL;
    ACCESS_ALLOWED_ACE* pace = NULL;
    ACL* pacl = NULL;
    SECURITY_DESCRIPTOR sd;
    HRESULT hr = S_OK;
    do { // false loop
        // build World SID
        SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
        if ( !::AllocateAndInitializeSid(
            &IDAuthorityWorld,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &psidWorld ) )
        {
            ASSERT( FALSE );
            break;
        }

        // build Admins SID
        SID_IDENTIFIER_AUTHORITY IDAuthorityNT = SECURITY_NT_AUTHORITY;
        if ( !::AllocateAndInitializeSid(
            &IDAuthorityNT,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,0,0,0,0,0,
            &psidAdmins ) )
        {
            ASSERT( FALSE );
            break;
        }

        // build ACE
        DWORD cbSid = ::GetLengthSid(psidWorld);
        if ( 0 == cbSid )
        {
            ASSERT( FALSE );
            hr = E_UNEXPECTED;
            break;
        }
        INT cbAce = sizeof(ACCESS_ALLOWED_ACE) + cbSid;
        pace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(new BYTE[ cbAce+10 ]);

        if ( pace ) {

            ::memset((BYTE*)pace,0,cbAce+10);
            pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;   // SetType()
            pace->Header.AceFlags = 0;                        // SetInheritFlags()
            pace->Header.AceSize = (WORD)cbAce;               // SetSize() (in SetSID())
            pace->Mask = GENERIC_ALL;                         // SetAccessMask()
            //This is a safe usage.
            ::memcpy( &(pace->SidStart), psidWorld, cbSid );  // SetSID()
        } else {
            ASSERT ( FALSE );
            hr = E_OUTOFMEMORY;
            break;
        }

        // build ACL
        DWORD cbAcl = sizeof(ACL) + cbAce + 10;
        pacl = reinterpret_cast<ACL*>(new BYTE[ cbAcl ]);

        if ( pacl ) {
            //This is a safe usage. yanggao.
            ::memset((BYTE*)pacl,0,cbAcl);
            if ( !::InitializeAcl( pacl, cbAcl, ACL_REVISION2 ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }
            if ( !::AddAce( pacl, ACL_REVISION2, 0, pace, cbAce ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            // build security descriptor in absolute format
            if ( !::InitializeSecurityDescriptor(
                &sd,
                SECURITY_DESCRIPTOR_REVISION ) )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }
            if (   !::SetSecurityDescriptorOwner( &sd, psidAdmins, FALSE )
                || !::SetSecurityDescriptorGroup( &sd, psidAdmins, FALSE )
                || !::SetSecurityDescriptorDacl(  &sd, TRUE, pacl, FALSE )
               )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            // convert security descriptor to self-relative format
            DWORD cbSD = 0;
            // this call should fail and set cbSD to the correct size
            if ( ::MakeSelfRelativeSD( &sd, NULL, &cbSD ) || 0 == cbSD )
            {
                ASSERT( FALSE );
                hr = E_UNEXPECTED;
                break;
            }

            *ppsd = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[ cbSD + 20 ]);

            if ( *ppsd ) {
                //This is a safe usage. yanggao.
                ::memset( (BYTE*)*ppsd, 0, cbSD + 20 );
                if ( !::MakeSelfRelativeSD( &sd, *ppsd, &cbSD ) )
                {
                    ASSERT( FALSE );
                    hr = E_UNEXPECTED;
                    break;
                }
            } else {

                ASSERT ( FALSE );
                hr = E_OUTOFMEMORY;
                break;
            }
        } else {

            ASSERT ( FALSE );
            hr = E_OUTOFMEMORY;
            break;
        }

    } while (FALSE); // false loop

    // clean up
    if ( NULL != psidWorld ) {
        (void)::FreeSid( psidWorld );
    }
    if ( NULL != psidAdmins ) {
        (void)::FreeSid( psidAdmins );
    }

    if ( pace )
        delete []pace;//Raid #Prefast

    if ( pacl )
        delete []pacl;//Raid #Prefast

    if ( FAILED(hr) && *ppsd ) {
        delete *ppsd;
        *ppsd = NULL;
    }

    return hr;
}

void CSecurityInfo::Initialize(BOOL bIsContainer,  //CResult *pData,
                               PSECURITY_DESCRIPTOR *ppSeDescriptor,
                               SECURITY_INFORMATION *pSeInfo,
                               int flag)
{
//    m_pData = pData;
    m_bIsContainer = bIsContainer;
    m_ppSD = ppSeDescriptor;
    m_pSeInfo = pSeInfo;
    m_flag = flag;
}


STDMETHODIMP CDsSecInfo::GetSecurity(
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
    if ( NULL == ppSecurityDescriptor ) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    *ppSecurityDescriptor = NULL;
    if (0 == RequestedInformation ) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
   if (fDefault)
        return E_NOTIMPL;

   HRESULT hr = S_OK;
    if ( m_ppSD != NULL && *m_ppSD != NULL ) {

        if ( !IsValidSecurityDescriptor(*m_ppSD)) {
           ASSERT(FALSE);
            hr = E_INVALIDARG;
        }
        else
            hr = MyMakeSelfRelativeSD(*m_ppSD,ppSecurityDescriptor);
    } else {
        hr = E_UNEXPECTED;
    }

    return hr;

}

STDMETHODIMP CDsSecInfo::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{

    if ( pSecurityDescriptor == NULL || SecurityInformation == 0 )
        return S_OK;

    if ( m_flag == CONFIG_SECURITY_PAGE_READ_ONLY ||
         m_flag == ANALYSIS_SECURITY_PAGE_READ_ONLY ||
         m_flag == SECURITY_PAGE_READ_ONLY )
        return S_OK;

    HRESULT hr = S_OK;
    if ( m_ppSD != NULL ) {

        if ( *m_ppSD != NULL )
            LocalFree(*m_ppSD);

        hr = MyMakeSelfRelativeSD(pSecurityDescriptor, m_ppSD);
        if (SUCCEEDED(hr) && m_pSeInfo )
            *m_pSeInfo = SecurityInformation;

    } else {
        hr = E_INVALIDARG;
    }

    return hr;

}

HRESULT CDsSecInfo::Initialize(
                           LPTSTR LdapName,
                           PFNDSCREATEISECINFO pfnCreateDsPage,
                           PSECURITY_DESCRIPTOR *ppSeDescriptor,
                           SECURITY_INFORMATION *pSeInfo,
                           int flag)
{
    if ( !LdapName || !pfnCreateDsPage ) {
        return E_INVALIDARG;
    }

    m_ppSD = ppSeDescriptor;
    m_pSeInfo = pSeInfo;
    m_flag = flag;

    BOOL bReadOnly;

    switch (flag ) {
       case SECURITY_PAGE_RO_NP:
    case SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_READ_ONLY:
    case CONFIG_SECURITY_PAGE_RO_NP:
    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
    case ANALYSIS_SECURITY_PAGE_RO_NP:
        bReadOnly = TRUE;
        break;
    default:
        bReadOnly = FALSE;
        break;
    }

    HRESULT hr=(*pfnCreateDsPage)(
                            LdapName,  //ObjectName,
                            NULL,
                            bReadOnly,
                            &m_pISecInfo,
                            NULL,
                            NULL,
                            0);
    return hr;

}

//-----------------------------------------------------------------------
// this function creates a SCE editor property page. If a modeless
// property sheet is desired, make sure that the creation code originates
// from your own thread. Search for usage of the function for sample.
//-----------------------------------------------------------------------
INT_PTR
MyCreateSecurityPage2(BOOL bIsContainer, //CResult *pData,
                      PSECURITY_DESCRIPTOR *ppSeDescriptor,
                      SECURITY_INFORMATION *pSeInfo,
                      LPCTSTR ObjectName,
                      SE_OBJECT_TYPE SeType,
                      int flag,
                      HWND hwndParent,
                      BOOL bModeless)
{

    INT_PTR nRet=-1;
    HRESULT hr;

    if (!g_hAclUiDll) {
        // This is a safe usage.
        g_hAclUiDll = LoadLibrary(TEXT("aclui.dll"));
    }

    if (!*ppSeDescriptor) {
       DWORD SDSize;

       if (SE_REGISTRY_KEY == SeType) {
          hr = GetDefaultRegKeySecurity(ppSeDescriptor,pSeInfo);
       } else {
          hr = GetDefaultFileSecurity(ppSeDescriptor,pSeInfo);
       }
       if (FAILED(hr))  // if access denied, return the invalid handle
           return nRet;
    }

    PFNCSECPAGE pfnCSecPage=NULL;
    if ( g_hAclUiDll) {
        pfnCSecPage = (PFNCSECPAGE)GetProcAddress(g_hAclUiDll,
                                                       "CreateSecurityPage");
        if ( pfnCSecPage ) {

            CComObject<CSecurityInfo>* psi = NULL;
            HPROPSHEETPAGE hPage=NULL;

            hr = CComObject<CSecurityInfo>::CreateInstance(&psi);

            if ( SUCCEEDED(hr) ) {
                psi->AddRef();

                psi->SetMachineName( NULL );
                psi->SetObjectName( ObjectName );
                psi->SetTypeInstance(SeType, AfxGetInstanceHandle() );

                psi->Initialize(bIsContainer, ppSeDescriptor, pSeInfo, flag);

                psi->AddRef();
                hPage = (*pfnCSecPage)((LPSECURITYINFO)psi); // in aclui.h. Raid #prefast
                psi->Release();

                if ( hPage ) {

                    // display this one
                    PROPSHEETHEADER psh;
                    HPROPSHEETPAGE hpsp[1];

                    hpsp[0] = hPage;

                    ZeroMemory(&psh,sizeof(psh));

                    psh.dwSize = sizeof(psh);
                    psh.dwFlags = PSH_DEFAULT;
                    if (bModeless) {
                       psh.dwFlags |= PSH_MODELESS;
                    }
                    psh.nPages = 1;
                    psh.phpage = hpsp;

                    CString str=_T("");

                    switch (flag) {

                    case CONFIG_SECURITY_PAGE_READ_ONLY:
                    case CONFIG_SECURITY_PAGE_NO_PROTECT:
                    case CONFIG_SECURITY_PAGE:
                    case CONFIG_SECURITY_PAGE_RO_NP:
                        str.LoadString(IDS_CONFIG_SECURITY_PAGE);
                        break;

                    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
                    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
                    case ANALYSIS_SECURITY_PAGE:
                    case ANALYSIS_SECURITY_PAGE_RO_NP:
                        str.LoadString(IDS_ANALYSIS_SECURITY_PAGE);
                        break;

                    default:
                        str.LoadString(IDS_SECURITY_PAGE);
                        break;
                    }

                    str+= ObjectName;
                    psh.pszCaption = (LPCTSTR)str;

                    psh.hwndParent = hwndParent;

                    if (bModeless) {
                       nRet = PropertySheet(&psh);

                    } else {
                       nRet = PropertySheet(&psh);
                       if (-1 == nRet) {
                          ErrorHandler();
                       }
                    }

                }
                psi->Release();
            }
        }
    }

    return nRet;
}


INT_PTR
MyCreateDsSecurityPage(
             LPDSSECINFO *ppSI,
             PFNDSCREATEISECINFO pfnCreateDsPage,
             PSECURITY_DESCRIPTOR *ppSeDescriptor,
             SECURITY_INFORMATION *pSeInfo,
             LPCTSTR ObjectName,
             int flag,
             HWND hwndParent)
{
    if ( !ObjectName || !ppSeDescriptor || !pfnCreateDsPage || !ppSI ) {
        // invalid parameter
        return -1;
    }

    INT_PTR nRet=-1;

    if (!g_hAclUiDll)
        //This is a safe usage.
        g_hAclUiDll = LoadLibrary(TEXT("aclui.dll"));

    PFNCSECPAGE pfnCSecPage=NULL;
    if ( g_hAclUiDll) {
        pfnCSecPage = (PFNCSECPAGE)GetProcAddress(g_hAclUiDll,
                                                       "CreateSecurityPage");
        if ( pfnCSecPage ) {
            //
            // get the address of CreateSecurityPage
            //
            HRESULT hr=S_OK;
            LPTSTR LdapName=NULL;

            if ( NULL == *ppSI ) {

                DWORD nLen = 8+wcslen(ObjectName);
                LdapName = (LPTSTR)LocalAlloc(0, nLen*sizeof(WCHAR));
                if ( LdapName ) {
                   //This is a safe usage.
                   swprintf(LdapName, L"LDAP://%s", ObjectName);
                } else
                    return -1;


                hr = CComObject<CDsSecInfo>::CreateInstance((CComObject<CDsSecInfo>**)ppSI);

                if ( SUCCEEDED(hr) ) {

                    (*ppSI)->AddRef();

                    hr = (*ppSI)->Initialize(LdapName, pfnCreateDsPage, ppSeDescriptor, pSeInfo, flag);
                }
            }
            if ( SUCCEEDED(hr) ) {
                (*ppSI)->AddRef();
                HPROPSHEETPAGE hPage = (*pfnCSecPage)((LPSECURITYINFO)(*ppSI));  // in aclui.h
                (*ppSI)->Release();

                if ( hPage ) {

                    // display this one
                    PROPSHEETHEADER psh;
                    HPROPSHEETPAGE hpsp[1];

                    hpsp[0] = hPage;

                    ZeroMemory(&psh,sizeof(psh));

                    psh.dwSize = sizeof(psh);
                    psh.dwFlags = PSH_DEFAULT;
                    psh.nPages = 1;
                    psh.phpage = hpsp;

                    CString str=_T("");

                    switch (flag) {

                    case CONFIG_SECURITY_PAGE_READ_ONLY:
                    case CONFIG_SECURITY_PAGE_NO_PROTECT:
                    case CONFIG_SECURITY_PAGE:
                        str.LoadString(IDS_CONFIG_SECURITY_PAGE);
                        break;

                    case ANALYSIS_SECURITY_PAGE_READ_ONLY:
                    case ANALYSIS_SECURITY_PAGE_NO_PROTECT:
                    case ANALYSIS_SECURITY_PAGE:
                        str.LoadString(IDS_ANALYSIS_SECURITY_PAGE);
                        break;

                    default:
                        str.LoadString(IDS_SECURITY_PAGE);
                        break;
                    }

                    str+= ObjectName;
                    psh.pszCaption = (LPCTSTR)str;

                    psh.hwndParent = hwndParent;

                    nRet = PropertySheet(&psh);

                    if (-1 == nRet) {
                       ErrorHandler();
                    }
                } else
                    hr = E_FAIL;
            }

            if ( LdapName )
                LocalFree(LdapName);
        }
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\snapmgr.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       snapmgr.cpp
//
//  Contents:   Core CComponentDataImpl and CSnapin routines for
//              Security Configuration Modules (Editor, Manager, Extension)
//
//  History:
//
//---------------------------------------------------------------------------



#include "stdafx.h"
#include "afxcmn.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "DataObj.h"
#include "resource.h"
#include "wrapper.h"
#include "util.h"
#include "RegDlg.h"
#include "savetemp.h"
#include "getuser.h"
#include "servperm.h"
#include "addobj.h"
#include "perfanal.h"
#include "newprof.h"
#include "AddGrp.h"
#include "dattrs.h"
#include "precpage.h"

#define INITGUID
#include "scesetup.h"
#include "userenv.h"
#undef INITGUID
#include <gpedit.h>
// #include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CF_MACHINE_NAME                     L"MMC_SNAPIN_MACHINE_NAME"

CList<CResult*, CResult*> CSnapin::m_PropertyPageList;

long CSnapin::lDataObjectRefCount = 0;
long CurrentSnapin = 0;

BOOL RegisterCheckListWndClass(void); // in chklist.cpp

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

static MMCBUTTON SnapinButtons[] =
{
   { 0, 1, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Folder"), _T("New Folder")},
   { 1, 2, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),  _T("Mail Inbox")},
   { 2, 3, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Outbox"), _T("Mail Outbox")},
   { 3, 4, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Send"),   _T("Send Message")},
   { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),      _T("")},
   { 4, 5, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Trash"),  _T("Trash")},
   { 5, 6, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Open"),   _T("Open Folder")},
   { 6, 7, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("News"),   _T("Today's News")},
   { 7, 8, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("INews"),  _T("Internet News")},

};

static MMCBUTTON SnapinButtons2[] =
{
   { 0, 10, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Compose"),   _T("Compose Message")},
   { 1, 20, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Print"),     _T("Print Message")},
   { 2, 30, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Find"),      _T("Find Message")},
   { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),         _T("")},
   { 3, 40, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),     _T("Inbox")},
   { 4, 50, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Smile"),     _T("Smile :-)")},
   { 5, 60, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply"),     _T("Reply")},
   { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP   , _T(" "),         _T("")},
   { 6, 70, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply All"), _T("Reply All")},

};

UINT cfSceAccountArea;
UINT cfSceEventLogArea;
UINT cfSceLocalArea;
UINT cfSceGroupsArea;
UINT cfSceRegistryArea;
UINT cfSceFileArea;
UINT cfSceServiceArea;
///////////////////////////////////////////////////////////////////////////////
// RESOURCES

BEGIN_MENU(CSecmgrNodeMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CAnalyzeNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_OPEN_PRIVATE_DB, 0, 0)
CTX_ENTRY(IDM_ANALYZE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_APPLY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_ASSIGN, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_GENERATE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_VIEW_LOGFILE, 0, CCM_INSERTIONPOINTID_PRIMARY_VIEW)
CTX_ENTRY(IDM_SECURE_WIZARD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_OPEN_DB)
RES_ENTRY(IDS_ANALYZE_PROFILE)
RES_ENTRY(IDS_APPLY_PROFILE)
RES_ENTRY(IDS_SAVE_PROFILE)
RES_ENTRY(IDS_ASSIGN_CONFIGURATION)
RES_ENTRY(IDS_GENERATE_PROFILE)
RES_ENTRY(IDS_VIEW_LOGFILE)
RES_ENTRY(IDS_SECURE_WIZARD)
END_RES
END_MENU


BEGIN_MENU(CConfigNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_LOC, 0, CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_LOCATION)
END_RES
END_MENU

BEGIN_MENU(CLocationNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_NEW, 0, CCM_INSERTIONPOINTID_PRIMARY_NEW)
//CTX_ENTRY(IDM_REMOVE, 0)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_DESCRIBE_LOCATION, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_NEW_PROFILE)
//RES_ENTRY(IDS_REMOVE_LOCATION)
RES_ENTRY(IDS_RELOAD_LOCATION)
RES_ENTRY(IDS_DESCRIBE)
END_RES
END_MENU

BEGIN_MENU(CSSProfileNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_IMPORT_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_EXPORT_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_IMPORT_POLICY)
RES_ENTRY(IDS_EXPORT_POLICY)
RES_ENTRY(IDS_REFRESH_TEMPLATE)
END_RES
END_MENU


BEGIN_MENU(CRSOPProfileNodeMenuHolder)
BEGIN_CTX
//CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
//RES_ENTRY(IDS_REFRESH_TEMPLATE)
END_RES
END_MENU

BEGIN_MENU(CLocalPolNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_IMPORT_LOCAL_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_EXPORT_LOCALPOLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_IMPORT_POLICY)
RES_ENTRY(IDS_EXPORT_POLICY)
RES_ENTRY(IDS_REFRESH_LOCALPOL)
END_RES
END_MENU

BEGIN_MENU(CProfileNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_DESCRIBE_PROFILE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVEAS, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_DESCRIBE_PROFILE) //Raid #496103, yanggao
RES_ENTRY(IDS_SAVE_PROFILE)
RES_ENTRY(IDS_SAVEAS_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileAreaMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileSubAreaMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CProfileSubAreaEventLogMenuHolder) //Raid #253209, Yang Gao, 3/27/2001
BEGIN_CTX
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileGroupsMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_GROUPS, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_GROUP)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileRegistryMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_REGISTRY, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_KEY)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileFilesMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_FOLDER, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_FILES_AND_FOLDERS)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeAreaMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CAnalyzeGroupsMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_GROUPS, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_GROUP)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeFilesMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_ANAL_FOLDER, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_FILES_AND_FOLDERS)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeRegistryMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_ANAL_KEY, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_KEY)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeObjectsMenuHolder)
BEGIN_CTX
//CTX_ENTRY(IDM_OBJECT_SECURITY,0,CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
//RES_ENTRY(IDS_SECURITY_MENU)
END_RES
END_MENU


////////////////////////////////////////////////////////////
// Implementation

template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf)
{
   ASSERT(lpDataObject != NULL);

   //Raid #202964, 4/17/2001
   if ( lpDataObject == NULL || (LPDATAOBJECT) MMC_MULTI_SELECT_COOKIE == lpDataObject )
   {
      return NULL;
   }
   TYPE* p = NULL;

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL};
   FORMATETC formatetc = {
      cf,
      NULL,
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   HRESULT hRet = S_OK;

   // Allocate memory for the stream
   stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(TYPE));

   // Attempt to get data from the object
   do {
      if (stgmedium.hGlobal == NULL)
         break;


   hRet = lpDataObject->GetDataHere(&formatetc, &stgmedium);
      //
      // So far there are only two conditions in which we want to check for a multi select
      // 1.  If the GetDataHere fails, then we should check to see if this is a mutli
      //     select case.
      // 2.  If GetDataHere succeeded but we got a specail cookie instead of a valid
      //     SCE cookie we again want to call GetData to see if we have mutli select data
      //     in the CDataObject.
      //

      if( FAILED(hRet) ||
         (formatetc.cfFormat == CDataObject::m_cfInternal &&
          IS_SPECIAL_COOKIE( ((INTERNAL *)stgmedium.hGlobal)->m_cookie) ) ) {

         GlobalFree(stgmedium.hGlobal);

         //
         // See if this data object is a mutli select.
         //
         ZeroMemory(&formatetc, sizeof(FORMATETC));

         formatetc.tymed = TYMED_HGLOBAL;
         formatetc.cfFormat = (CLIPFORMAT)::RegisterClipboardFormat( CCF_MULTI_SELECT_SNAPINS );
         stgmedium.hGlobal  = NULL;

         if( FAILED(hRet )){
            //
            // If get data here failed, then try to get the information by calling GetData.
            // In multi select mode we get a data object to the snapins that have the data objects.
            //
            if( SUCCEEDED( lpDataObject->GetData(&formatetc, &stgmedium) ) ){
               SMMCDataObjects *pObjects = (SMMCDataObjects *)GlobalLock( stgmedium.hGlobal );
               if(pObjects && pObjects->count){
                  lpDataObject = pObjects->lpDataObject[0];
                  GlobalUnlock( stgmedium.hGlobal );

                  if(lpDataObject){
                     ReleaseStgMedium( &stgmedium );
                     formatetc.cfFormat = (CLIPFORMAT)CDataObject::m_cfInternal;
                     stgmedium.hGlobal  = NULL;
                     lpDataObject->GetData(&formatetc, &stgmedium);
                  }
               }
            }
         } else {
            //
            // The data object is ours and a special cookie was recieved from GetDataHere.
            // this probably means that we have a mutli select, so look for it.
            //
            formatetc.cfFormat = (CLIPFORMAT)CDataObject::m_cfInternal;
            lpDataObject->GetData(&formatetc, &stgmedium);
         }

      }

      p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

      if (p == NULL)
         break;

   } while (FALSE);

   return p;
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
   return Extract<INTERNAL>(lpDataObject, (CLIPFORMAT) CDataObject::m_cfInternal);
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
   return Extract<GUID>(lpDataObject, (CLIPFORMAT)CDataObject::m_cfNodeType);
}

PWSTR ExtractMachineName(LPDATAOBJECT lpDataObject, CLIPFORMAT cf)
{
   if ( lpDataObject == NULL ) {
      return NULL;
   }

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL};
   FORMATETC formatetc = { cf, NULL,
      DVASPECT_CONTENT, -1, TYMED_HGLOBAL
   };
   //
   // Allocate memory for the stream
   //
   stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, (MAX_PATH+1)*sizeof(WCHAR));

   //
   // Attempt to get data from the object
   //
   HRESULT hr = S_FALSE;
   PWSTR p=NULL;

   do {
      if (stgmedium.hGlobal == NULL)
         break;

      if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium))) {
         GlobalFree(stgmedium.hGlobal);
         break;
      }

      p = reinterpret_cast<WCHAR*>(stgmedium.hGlobal);

      if (p == NULL)
         break;

   } while (FALSE);

   return p;
}
//Messagebox with the caption according to current snapin.
int AppMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType, int iSnapin)
{
   CString captiontext = lpCaption;
   if( NULL == lpCaption )
   {
      if( 0 == iSnapin )
         iSnapin = CurrentSnapin;
      switch(iSnapin)
      {
      case SCE_IMPL_TYPE_SCE: //Security Template snapin
         captiontext.LoadString(AFX_IDS_APP_TITLE);
         break;
      case SCE_IMPL_TYPE_SAV: //Configuration and Analysis snapin
         captiontext.LoadString(IDS_ANALYSIS_VIEWER_NAME);
         break;
      case SCE_IMPL_TYPE_RSOP: //RSOP snapin
      case SCE_IMPL_TYPE_EXTENSION: // Security Setting extension
         captiontext.LoadString(IDS_EXTENSION_NAME); 
         break;
      }
   }
   
   return MessageBox(hWnd, lpText, captiontext, uType);
}


/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation
//+--------------------------------------------------------------------------------------
// CSnapin::GetResultViewType
//
// Since we need to display an HTML file for the error message, we check for errors
// in this function.
//
// If there is some error, this function writes a temporary HTML file, and sets
// the view type to an HTML file.
//
// Arguments:  [cookie]       - The cookie associated with the scope pane item being
//                               displyaed.
//             [ppViewType]   - The type of view we want.
//             [pViewOptions] - The options for the view.
//
// Returns:    S_OK  - We want MMC to display the specifide view type.
//---------------------------------------------------------------------------------------
STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
                                        LONG* pViewOptions)
{
#define pComponentImpl reinterpret_cast<CComponentDataImpl *>(m_pComponentData)

   CFolder *pFolder = reinterpret_cast<CFolder *>(cookie);


   CString sHtmlFile;
   FOLDER_TYPES fType = STATIC;
   HRESULT hr=S_OK;

   //
   // Delete the old temporary file.
   //
   if( !pComponentImpl->m_strTempFile.IsEmpty() ){
      DeleteFile( pComponentImpl->m_strTempFile );
   }

   //
   // What kind of error do we want to display.
   //
   if( pFolder ){
      fType = pFolder->GetType();
   } else {
      switch( GetImplType() ){
      case  SCE_IMPL_TYPE_SAV:
         fType = ANALYSIS;
         break;
      }
   }

   //
   // Errors supported. We have to create an html file and set sHtmlFile to a
   // valid source if we want an error to be displayed.
   //

   CWriteHtmlFile ht;
   switch(fType){
   case LOCATIONS:
      //
      // Need to check Location areas for permissions, and to see if it exists at all.
      //
      pFolder->GetDisplayName( sHtmlFile, 0 );

      //
      // Set the current working directory.
      //
      if( !SetCurrentDirectory( sHtmlFile ) ){
         //
         // Get the error message and write the HTML file.
         //
         LPTSTR pszMsg;
         //This is a safe usage. Function is responsbile to allocate the memery.
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPTSTR)&pszMsg,
                        0,
                        NULL
                        );
         ht.Create();
         ht.Write(IDS_BAD_LOCATION);

         if(pszMsg){
            ht.Write(pszMsg);
            LocalFree(pszMsg);
         }
         pFolder->SetState( CFolder::state_InvalidTemplate );
      } else {
         pFolder->SetState( 0, ~CFolder::state_InvalidTemplate );
      }
      break;
   case LOCALPOL_ACCOUNT:
   case LOCALPOL_LOCAL:
   case LOCALPOL_EVENTLOG:
   case LOCALPOL_PASSWORD:
   case LOCALPOL_KERBEROS:
   case LOCALPOL_LOCKOUT:
   case LOCALPOL_AUDIT:
   case LOCALPOL_OTHER:
   case LOCALPOL_LOG:
   case LOCALPOL_PRIVILEGE:
      //
      // Load the sad info.
      //
      pComponentImpl->LoadSadInfo(FALSE);
      break;
   case PROFILE:
      //
      // Template error messages.
      //
      if(pFolder->GetModeBits() & MB_NO_NATIVE_NODES ){
         break;
      }

      if( pFolder->GetState() & CFolder::state_Unknown ){
         // We must load the template and find out if it is a valid
         // configuration template.
         if(!GetTemplate( pFolder->GetInfFile(), AREA_USER_SETTINGS)){
            pFolder->SetState( CFolder::state_InvalidTemplate, ~CFolder::state_Unknown );
         } else {
            pFolder->SetState( 0, ~CFolder::state_Unknown );
         }
      }

      if( pFolder->GetState() & CFolder::state_InvalidTemplate ){
         ht.Create();
         ht.Write( IDS_ERROR_CANT_OPEN_PROFILE );
      }
      break;
   case ANALYSIS:
      //
      // Analysis Error messages.
      //
      if( pComponentImpl->m_bIsLocked ){
         //
         // We are configuring or analyzing the database
         //
         ht.Create();
         ht.Write( IDS_ERROR_ANALYSIS_LOCKED );
      } else if( pComponentImpl->SadName.IsEmpty() ){
         //
         // Display the start screen.
         //
         ht.Create();
         ht.Write( IDS_HTML_OPENDATABASE );
      } else if( pComponentImpl->m_dwFlags & CComponentDataImpl::flag_showLogFile &&
                 pComponentImpl->GetErroredLogFile() ){
         //
         // Display the error log file.
         //
         ht.Create();
         ht.Write( L"<B>" );
         ht.Write( IDS_VIEW_LOGFILE_TITLE );
         ht.Write( pComponentImpl->GetErroredLogFile() );
         ht.Write( L"</B><BR>" );
         ht.CopyTextFile( pComponentImpl->GetErroredLogFile(), pComponentImpl->m_ErroredLogPos );
      } else if( SCESTATUS_SUCCESS != pComponentImpl->SadErrored  ){

         ht.Create();
         ht.Write( L"<B>%s</B><BR><BR>", (LPCTSTR)pComponentImpl->SadName );

         //
         // This block of code will be removed as soon the engine returns us
         // a more useful error message if the database does not contain sad info.
         //
         WIN32_FIND_DATA fd;
         HANDLE handle = FindFirstFile( pComponentImpl->SadName, &fd );

         if(handle != INVALID_HANDLE_VALUE){
            FindClose(handle);
            if( pComponentImpl->SadErrored == SCESTATUS_PROFILE_NOT_FOUND ){
               ht.Write( IDS_DBERR5_NO_ANALYSIS );
            } else {
               goto write_normal_error;
            }
         } else {
write_normal_error:
            CString str;
            FormatDBErrorMessage( pComponentImpl->SadErrored, NULL, str);
            ht.Write( str );
         }
      }
      break;
   }

   DWORD dwSize = ht.GetFileName(NULL, 0);
   if(dwSize){
      //
      // We want to display an HTML file.
      //
      *ppViewType = (LPOLESTR)CoTaskMemAlloc(sizeof(TCHAR) * (dwSize + 1)); //Raid #668551, yanggao, 8/26/2002
      if(!*ppViewType){
         ht.Close( TRUE );
         goto normal;
      }

      ht.GetFileName( (LPTSTR)*ppViewType, dwSize + 1);
      pComponentImpl->m_strTempFile = *ppViewType;
      *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
   } else {
normal:
      //
      // Normal list view.
      //
      *ppViewType = NULL;
      *pViewOptions = MMC_VIEW_OPTIONS_NONE;

      //
      // S_FALSE means normal list view, S_OK means HTML or OCX
      //
      hr = S_FALSE;

      if(pFolder) {
         //
         // For mutli select, just add, or remove the case to enable multi select for a folder
         //
         switch( pFolder->GetType() ){
         case AREA_REGISTRY:
         case AREA_FILESTORE:
         case AREA_GROUPS:
         case AREA_GROUPS_ANALYSIS:
            *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
            break;
         }
      }
   }
   return hr;
#undef pComponentImpl
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
   ASSERT(lpConsole != NULL); // Check the expression.
   if( !lpConsole ) //Raid #550912, yanggao.
      return E_FAIL;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Save the IConsole pointer
   m_pConsole = lpConsole;
   m_pConsole->AddRef();

   // Load resource strings
   LoadResources();

   // QI for a IHeaderCtrl
   HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                                           reinterpret_cast<void**>(&m_pHeader));

   // Give the console the header control interface pointer
   if (SUCCEEDED(hr)) {
      m_pConsole->SetHeader(m_pHeader);
   }
   if (!SUCCEEDED(m_pConsole->GetMainWindow(&m_hwndParent))) {
      m_pConsole->Release();
      return E_FAIL;
   }

   m_pConsole->QueryInterface(IID_IResultData,
                              reinterpret_cast<void**>(&m_pResult));

   hr = m_pConsole->QueryResultImageList(&m_pImageResult);
   ASSERT(hr == S_OK); // Check the expression.
   if( SUCCEEDED(hr) )//Raid #550912, yanggao.
   {
      hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
      ASSERT(hr == S_OK); // Bogus Assert. yanggao
   }

   return hr;
}

void CSnapin::GetHelpTopic(long itemID, CString& helpTopic) //Raid #510407, 2/24/2002, yanggao
{
   switch(itemID)
   {
   // Security Template result items
   // Password policy
   case IDS_PAS_UNIQUENESS:
      helpTopic.LoadString(IDS_PAS_UNIQUENESS_HTOPIC);
      break;
   case IDS_MAX_PAS_AGE:
      helpTopic.LoadString(IDS_MAX_PAS_AGE_HTOPIC);
      break;
   case IDS_MIN_PAS_AGE:
      helpTopic.LoadString(IDS_MIN_PAS_AGE_HTOPIC);
      break;
   case IDS_MIN_PAS_LEN:
      helpTopic.LoadString(IDS_MIN_PAS_LEN_HTOPIC);
      break;
   case IDS_PAS_COMPLEX:
      helpTopic.LoadString(IDS_PAS_COMPLEX_HTOPIC);
      break;
   case IDS_CLEAR_PASSWORD:
      helpTopic.LoadString(IDS_CLEAR_PASSWORD_HTOPIC);
      break;
   // Account Lockout policy
   case IDS_LOCK_DURATION:
      helpTopic.LoadString(IDS_LOCK_DURATION_HTOPIC);
      break;
   case IDS_LOCK_COUNT:
      helpTopic.LoadString(IDS_LOCK_COUNT_HTOPIC);
      break;
   case IDS_LOCK_RESET_COUNT:
      helpTopic.LoadString(IDS_LOCK_RESET_COUNT_HTOPIC);
      break;
   // Kerberos policy
   case IDS_KERBEROS_VALIDATE_CLIENT:
      helpTopic.LoadString(IDS_KERBEROS_VALIDATE_CLIENT_HTOPIC);
      break;
   case IDS_KERBEROS_MAX_SERVICE:
      helpTopic.LoadString(IDS_KERBEROS_MAX_SERVICE_HTOPIC);
      break;
   case IDS_KERBEROS_MAX_AGE:
      helpTopic.LoadString(IDS_KERBEROS_MAX_AGE_HTOPIC);
      break;
   case IDS_KERBEROS_RENEWAL:
      helpTopic.LoadString(IDS_KERBEROS_RENEWAL_HTOPIC);
      break;
   case IDS_KERBEROS_MAX_CLOCK:
      helpTopic.LoadString(IDS_KERBEROS_MAX_CLOCK_HTOPIC);
      break;
   // Audit policy
   case IDS_ACCOUNT_LOGON:
      helpTopic.LoadString(IDS_ACCOUNT_LOGON_HTOPIC);
      break;
   case IDS_ACCOUNT_MANAGE:
      helpTopic.LoadString(IDS_ACCOUNT_MANAGE_HTOPIC);
      break;
   case IDS_DIRECTORY_ACCESS:
      helpTopic.LoadString(IDS_DIRECTORY_ACCESS_HTOPIC);
      break;
   case IDS_LOGON_EVENT:
      helpTopic.LoadString(IDS_LOGON_EVENT_HTOPIC);
      break;
   case IDS_OBJECT_ACCESS:
      helpTopic.LoadString(IDS_OBJECT_ACCESS_HTOPIC);
      break;
   case IDS_POLICY_CHANGE:
      helpTopic.LoadString(IDS_POLICY_CHANGE_HTOPIC);
      break;
   case IDS_PRIVILEGE_USE:
      helpTopic.LoadString(IDS_PRIVILEGE_USE_HTOPIC);
      break;
   case IDS_PROCESS_TRACK:
      helpTopic.LoadString(IDS_PROCESS_TRACK_HTOPIC);
      break;
   case IDS_SYSTEM_EVENT:
      helpTopic.LoadString(IDS_SYSTEM_EVENT_HTOPIC);
      break;
   //User right assignment
   case IDS_COMPUTER_NET:
      helpTopic.LoadString(IDS_COMPUTER_NET_HTOPIC);
      break;
   case IDS_ACTAS_PART:
      helpTopic.LoadString(IDS_ACTAS_PART_HTOPIC);
      break;
   case IDS_ADD_WORKSTATION:
      helpTopic.LoadString(IDS_ADD_WORKSTATION_HTOPIC);
      break;
   case IDS_MEMORY_ADJUST:
      helpTopic.LoadString(IDS_MEMORY_ADJUST_HTOPIC);
      break;
   case IDS_LOG_TERMINAL:
      helpTopic.LoadString(IDS_LOG_TERMINAL_HTOPIC);
      break;
   case IDS_BACKUP_FILES:
      helpTopic.LoadString(IDS_BACKUP_FILES_HTOPIC);
      break;
   case IDS_BYPASS_CHECK:
      helpTopic.LoadString(IDS_BYPASS_CHECK_HTOPIC);
      break;
   case IDS_CHANGE_SYSTEMTIME:
      helpTopic.LoadString(IDS_CHANGE_SYSTEMTIME_HTOPIC);
      break;
   case IDS_CREATE_PAGEFILE:
      helpTopic.LoadString(IDS_CREATE_PAGEFILE_HTOPIC);
      break;
   case IDS_CREATE_TOKEN:
      helpTopic.LoadString(IDS_CREATE_TOKEN_HTOPIC);
      break;
   case IDS_CREATE_SHARED_OBJ:
      helpTopic.LoadString(IDS_CREATE_SHARED_OBJ_HTOPIC);
      break;
   case IDS_DEBUG_PROGRAM:
      helpTopic.LoadString(IDS_DEBUG_PROGRAM_HTOPIC);
      break;
   case IDS_DENY_COMPUTER_NET:
      helpTopic.LoadString(IDS_DENY_COMPUTER_NET_HTOPIC);
      break;
   case IDS_DENY_LOG_BATCH:
      helpTopic.LoadString(IDS_DENY_LOG_BATCH_HTOPIC);
      break;
   case IDS_DENY_LOG_SERVICE:
      helpTopic.LoadString(IDS_DENY_LOG_SERVICE_HTOPIC);
      break;
   case IDS_DENY_LOG_LOCALLY:
      helpTopic.LoadString(IDS_DENY_LOG_LOCALLY_HTOPIC);
      break;
   case IDS_DENY_LOG_TERMINAL:
      helpTopic.LoadString(IDS_DENY_LOG_TERMINAL_HTOPIC);
      break;
   case IDS_ENABLE_DELEGATION:
      helpTopic.LoadString(IDS_ENABLE_DELEGATION_HTOPIC);
      break;
   case IDS_FORCE_SHUTDOWN:
      helpTopic.LoadString(IDS_FORCE_SHUTDOWN_HTOPIC);
      break;
   case IDS_SECURITY_AUDIT:
      helpTopic.LoadString(IDS_SECURITY_AUDIT_HTOPIC);
      break;
   case IDS_INCREASE_PRIORITY:
      helpTopic.LoadString(IDS_INCREASE_PRIORITY_HTOPIC);
      break;
   case IDS_LOAD_DRIVER:
      helpTopic.LoadString(IDS_LOAD_DRIVER_HTOPIC);
      break;
   case IDS_LOCK_PAGE:
      helpTopic.LoadString(IDS_LOCK_PAGE_HTOPIC);
      break;
   case IDS_LOGON_BATCH:
      helpTopic.LoadString(IDS_LOGON_BATCH_HTOPIC);
      break;
   case IDS_LOGON_SERVICE:
      helpTopic.LoadString(IDS_LOGON_SERVICE_HTOPIC);
      break;
   case IDS_LOGON_LOCALLY:
      helpTopic.LoadString(IDS_LOGON_LOCALLY_HTOPIC);
      break;
   case IDS_MANAGE_LOG:
      helpTopic.LoadString(IDS_MANAGE_LOG_HTOPIC);
      break;
   case IDS_MODIFY_ENVIRONMENT:
      helpTopic.LoadString(IDS_MODIFY_ENVIRONMENT_HTOPIC);
      break;
   case IDS_MAITENANCE:
      helpTopic.LoadString(IDS_MAITENANCE_HTOPIC);
      break;
   case IDS_SINGLE_PROCESS:
      helpTopic.LoadString(IDS_SINGLE_PROCESS_HTOPIC);
      break;
   case IDS_SYS_PERFORMANCE:
      helpTopic.LoadString(IDS_SYS_PERFORMANCE_HTOPIC);
      break;
   case IDS_REMOVE_COMPUTER:
      helpTopic.LoadString(IDS_REMOVE_COMPUTER_HTOPIC);
      break;
   case IDS_PROCESS_TOKEN:
      helpTopic.LoadString(IDS_PROCESS_TOKEN_HTOPIC);
      break;
   case IDS_RESTORE_FILE:
      helpTopic.LoadString(IDS_RESTORE_FILE_HTOPIC);
      break;
   case IDS_SHUTDOWN:
      helpTopic.LoadString(IDS_SHUTDOWN_HTOPIC);
      break;
   case IDS_SYNC_DATA:
      helpTopic.LoadString(IDS_SYNC_DATA_HTOPIC);
      break;
   case IDS_TAKE_OWNERSHIP:
      helpTopic.LoadString(IDS_TAKE_OWNERSHIP_HTOPIC);
      break;
   // Security Options
   case IDS_ENABLE_ADMIN:
      helpTopic.LoadString(IDS_ENABLE_ADMIN_HTOPIC);
      break;
   case IDS_ENABLE_GUEST:
      helpTopic.LoadString(IDS_ENABLE_GUEST_HTOPIC);
      break;
   case IDS_NEW_ADMIN:
      helpTopic.LoadString(IDS_NEW_ADMIN_HTOPIC);
      break;
   case IDS_NEW_GUEST:
      helpTopic.LoadString(IDS_NEW_GUEST_HTOPIC);
      break;
   case IDS_LSA_ANON_LOOKUP:
      helpTopic.LoadString(IDS_LSA_ANON_LOOKUP_HTOPIC);
      break;
   case IDS_FORCE_LOGOFF:
      helpTopic.LoadString(IDS_FORCE_LOGOFF_HTOPIC);
      break;
   case IDS_LDAPSERVERINTEGRITY:
      helpTopic.LoadString(IDS_LDAPSERVERINTEGRITY_HTOPIC);
      break;
   case IDS_SIGNSECURECHANNEL:
      helpTopic.LoadString(IDS_SIGNSECURECHANNEL_HTOPIC);
      break;
   case IDS_SEALSECURECHANNEL:
      helpTopic.LoadString(IDS_SEALSECURECHANNEL_HTOPIC);
      break;
   case IDS_REQUIRESTRONGKEY:
      helpTopic.LoadString(IDS_REQUIRESTRONGKEY_HTOPIC);
      break;
   case IDS_REQUIRESIGNORSEAL:
      helpTopic.LoadString(IDS_REQUIRESIGNORSEAL_HTOPIC);
      break;
   case IDS_REFUSEPASSWORDCHANGE:
      helpTopic.LoadString(IDS_REFUSEPASSWORDCHANGE_HTOPIC);
      break;
   case IDS_MAXIMUMPASSWORDAGE:
      helpTopic.LoadString(IDS_MAXIMUMPASSWORDAGE_HTOPIC);
      break;
   case IDS_DISABLEPASSWORDCHANGE:
      helpTopic.LoadString(IDS_DISABLEPASSWORDCHANGE_HTOPIC);
      break;
   case IDS_LDAPCLIENTINTEGRITY:
      helpTopic.LoadString(IDS_LDAPCLIENTINTEGRITY_HTOPIC);
      break;
   case IDS_REQUIRESECURITYSIGNATURE:
      helpTopic.LoadString(IDS_REQUIRESECURITYSIGNATURE_HTOPIC);
      break;
   case IDS_ENABLESECURITYSIGNATURE:
      helpTopic.LoadString(IDS_ENABLESECURITYSIGNATURE_HTOPIC);
      break;
   case IDS_ENABLEPLAINTEXTPASSWORD:
      helpTopic.LoadString(IDS_ENABLEPLAINTEXTPASSWORD_HTOPIC);
      break;
   case IDS_RESTRICTNULLSESSACCESS:
      helpTopic.LoadString(IDS_RESTRICTNULLSESSACCESS_HTOPIC);
      break;
   case IDS_SERREQUIRESECURITYSIGNATURE:
      helpTopic.LoadString(IDS_SERREQUIRESECURITYSIGNATURE_HTOPIC);
      break;
   case IDS_NULLSESSIONSHARES:
      helpTopic.LoadString(IDS_NULLSESSIONSHARES_HTOPIC);
      break;
   case IDS_NULLSESSIONPIPES:
      helpTopic.LoadString(IDS_NULLSESSIONPIPES_HTOPIC);
      break;
   case IDS_SERENABLESECURITYSIGNATURE:
      helpTopic.LoadString(IDS_SERENABLESECURITYSIGNATURE_HTOPIC);
      break;
   case IDS_ENABLEFORCEDLOGOFF:
      helpTopic.LoadString(IDS_ENABLEFORCEDLOGOFF_HTOPIC);
      break;
   case IDS_AUTODISCONNECT:
      helpTopic.LoadString(IDS_AUTODISCONNECT_HTOPIC);
      break;
   case IDS_PROTECTIONMODE:
      helpTopic.LoadString(IDS_PROTECTIONMODE_HTOPIC);
      break;
   case IDS_CLEARPAGEFILEATSHUTDOWN:
      helpTopic.LoadString(IDS_CLEARPAGEFILEATSHUTDOWN_HTOPIC);
      break;
   case IDS_OBCASEINSENSITIVE:
      helpTopic.LoadString(IDS_OBCASEINSENSITIVE_HTOPIC);
      break;
   case IDS_MACHINE:
      helpTopic.LoadString(IDS_MACHINE_HTOPIC);
      break;
   case IDS_ADDPRINTERDRIVERS:
      helpTopic.LoadString(IDS_ADDPRINTERDRIVERS_HTOPIC);
      break;
   case IDS_SUBMITCONTROL:
      helpTopic.LoadString(IDS_SUBMITCONTROL_HTOPIC);
      break;
   case IDS_RESTRICTANONYMOUSSAM:
      helpTopic.LoadString(IDS_RESTRICTANONYMOUSSAM_HTOPIC);
      break;
   case IDS_RESTRICTANONYMOUS:
      helpTopic.LoadString(IDS_RESTRICTANONYMOUS_HTOPIC);
      break;
   case IDS_NOLMHASH:
      helpTopic.LoadString(IDS_NOLMHASH_HTOPIC);
      break;
   case IDS_NODEFAULTADMINOWNER:
      helpTopic.LoadString(IDS_NODEFAULTADMINOWNER_HTOPIC);
      break;
   case IDS_NTLMMINSERVERSEC:
      helpTopic.LoadString(IDS_NTLMMINSERVERSEC_HTOPIC);
      break;
   case IDS_NTLMMINCLIENTSEC:
      helpTopic.LoadString(IDS_NTLMMINCLIENTSEC_HTOPIC);
      break;
   case IDS_LMCOMPATIBILITYLEVEL:
      helpTopic.LoadString(IDS_LMCOMPATIBILITYLEVEL_HTOPIC);
      break;
   case IDS_LIMITBLANKPASSWORDUSE:
      helpTopic.LoadString(IDS_LIMITBLANKPASSWORDUSE_HTOPIC);
      break;
   case IDS_FULLPRIVILEGEAUDITING:
      helpTopic.LoadString(IDS_FULLPRIVILEGEAUDITING_HTOPIC);
      break;
   case IDS_FORCEGUEST:
      helpTopic.LoadString(IDS_FORCEGUEST_HTOPIC);
      break;
   case IDS_FIPSALGORITHMPOLICY:
      helpTopic.LoadString(IDS_FIPSALGORITHMPOLICY_HTOPIC);
      break;
   case IDS_EVERYONEINCLUDESANONYMOUS:
      helpTopic.LoadString(IDS_EVERYONEINCLUDESANONYMOUS_HTOPIC);
      break;
   case IDS_DISABLEDOMAINCREDS:
      helpTopic.LoadString(IDS_DISABLEDOMAINCREDS_HTOPIC);
      break;
   case IDS_CRASHONAUDITFAIL:
      helpTopic.LoadString(IDS_CRASHONAUDITFAIL_HTOPIC);
      break;
   case IDS_AUDITBASEOBJECTS:
      helpTopic.LoadString(IDS_AUDITBASEOBJECTS_HTOPIC);
      break;
   case IDS_UNDOCKWITHOUTLOGON:
      helpTopic.LoadString(IDS_UNDOCKWITHOUTLOGON_HTOPIC);
      break;
   case IDS_SHUTDOWNWITHOUTLOGON:
      helpTopic.LoadString(IDS_SHUTDOWNWITHOUTLOGON_HTOPIC);
      break;
   case IDS_SCFORCEOPTION:
      helpTopic.LoadString(IDS_SCFORCEOPTION_HTOPIC);
      break;
   case IDS_LEGALNOTICETEXT:
      helpTopic.LoadString(IDS_LEGALNOTICETEXT_HTOPIC);
      break;
   case IDS_LEGALNOTICECAPTION:
      helpTopic.LoadString(IDS_LEGALNOTICECAPTION_HTOPIC);
      break;
   case IDS_DONTDISPLAYLASTUSERNAME:
      helpTopic.LoadString(IDS_DONTDISPLAYLASTUSERNAME_HTOPIC);
      break;
   case IDS_DISABLECAD:
      helpTopic.LoadString(IDS_DISABLECAD_HTOPIC);
      break;
   case IDS_SCREMOVEOPTION:
      helpTopic.LoadString(IDS_SCREMOVEOPTION_HTOPIC);
      break;
   case IDS_PASSWORDEXPIRYWARNING:
      helpTopic.LoadString(IDS_PASSWORDEXPIRYWARNING_HTOPIC);
      break;
   case IDS_FORCEUNLOCKLOGON:
      helpTopic.LoadString(IDS_FORCEUNLOCKLOGON_HTOPIC);
      break;
   case IDS_CACHEDLOGONSCOUNT:
      helpTopic.LoadString(IDS_CACHEDLOGONSCOUNT_HTOPIC);
      break;
   case IDS_ALLOCATEFLOPPIES:
      helpTopic.LoadString(IDS_ALLOCATEFLOPPIES_HTOPIC);
      break;
   case IDS_ALLOCATEDASD:
      helpTopic.LoadString(IDS_ALLOCATEDASD_HTOPIC);
      break;
   case IDS_ALLOCATECDROMS:
      helpTopic.LoadString(IDS_ALLOCATECDROMS_HTOPIC);
      break;
   case IDS_SETCOMMAND:
      helpTopic.LoadString(IDS_SETCOMMAND_HTOPIC);
      break;
   case IDS_SECURITYLEVEL:
      helpTopic.LoadString(IDS_SECURITYLEVEL_HTOPIC);
      break;
   case IDS_REGPOLICY:
      helpTopic.LoadString(IDS_REGPOLICY_HTOPIC);
      break;
   case IDS_OPTIONAL: //Raid #652307, yanggao, 8/9/2002
      helpTopic.LoadString(IDS_OPTIONAL_HTOPIC);
      break;
   case IDS_AUTHENTICODEENABLED:
      helpTopic.LoadString(IDS_AUTHENTICODEENABLED_HTOPIC);
      break;
   case IDS_FORCEHIGHPROTECTION:
      helpTopic.LoadString(IDS_FORCEHIGHPROTECTION_HTOPIC);
      break;
   //Event Log
   case IDS_APP_LOG_MAX:
      helpTopic.LoadString(IDS_APP_LOG_MAX_HTOPIC);
      break;
   case IDS_SEC_LOG_MAX:
      helpTopic.LoadString(IDS_SEC_LOG_MAX_HTOPIC);
      break;
   case IDS_SYS_LOG_MAX:
      helpTopic.LoadString(IDS_SYS_LOG_MAX_HTOPIC);
      break;
   case IDS_APP_LOG_GUEST:
      helpTopic.LoadString(IDS_APP_LOG_GUEST_HTOPIC);
      break;
   case IDS_SEC_LOG_GUEST:
      helpTopic.LoadString(IDS_SEC_LOG_GUEST_HTOPIC);
      break;
   case IDS_SYS_LOG_GUEST:
      helpTopic.LoadString(IDS_SYS_LOG_GUEST_HTOPIC);
      break;
   case IDS_APP_LOG_DAYS:
      helpTopic.LoadString(IDS_APP_LOG_DAYS_HTOPIC);
      break;
   case IDS_SEC_LOG_DAYS:
      helpTopic.LoadString(IDS_SEC_LOG_DAYS_HTOPIC);
      break;
   case IDS_SYS_LOG_DAYS:
      helpTopic.LoadString(IDS_SYS_LOG_DAYS_HTOPIC);
      break;
   case IDS_APP_LOG_RET:
      helpTopic.LoadString(IDS_APP_LOG_RET_HTOPIC);
      break;
   case IDS_SEC_LOG_RET:
      helpTopic.LoadString(IDS_SEC_LOG_RET_HTOPIC);
      break;
   case IDS_SYS_LOG_RET:
      helpTopic.LoadString(IDS_SYS_LOG_RET_HTOPIC);
      break;
   //Restricted groups
   case IDS_RESTRICTED_GROUPS:
      helpTopic.LoadString(IDS_RESTRICTED_GROUPS_HTOPIC);
      break;
   //System Services
   case IDS_SYSTEM_SERVICES:
      helpTopic.LoadString(IDS_SYSTEM_SERVICES_HTOPIC);
      break;
   //Registry
   case IDS_REGISTRY_SETTING:
      helpTopic.LoadString(IDS_REGISTRY_SETTING_HTOPIC);
      break;
   //File System
   case IDS_FILESYSTEM_SETTING:
      helpTopic.LoadString(IDS_FILESYSTEM_SETTING_HTOPIC);
      break;
   default:
      helpTopic.Empty();
      break;
   }
}


STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   HRESULT hr = S_FALSE;
   MMC_COOKIE cookie;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (event == MMCN_PROPERTY_CHANGE) {
      hr = OnPropertyChange(lpDataObject);
   } else if (event == MMCN_VIEW_CHANGE) {
      hr = OnUpdateView(lpDataObject,arg,param);
   } else {
      INTERNAL* pInternal = NULL;

      switch (event) {
         case MMCN_COLUMNS_CHANGED:
            hr = S_FALSE;
            break;

         case MMCN_ACTIVATE:
            break;

         case MMCN_CLICK:
         case MMCN_DBLCLICK:
            break;

         case MMCN_SHOW:
            // pass a file name and file handle
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            hr = OnShow(lpDataObject,pInternal->m_cookie, arg, param);
            break;

         case MMCN_MINIMIZED:
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            hr = OnMinimize(pInternal->m_cookie, arg, param);
            break;

         case MMCN_SELECT:
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            HandleStandardVerbs(arg, lpDataObject);
            break;

         case MMCN_BTN_CLICK:
            break;

         case MMCN_ADD_IMAGES: {
            InitializeBitmaps(NULL);
            break;
         }

         case MMCN_SNAPINHELP:
         case MMCN_CONTEXTHELP: {
            CString strTopic;
            CString strPath;
            LPTSTR szPath;
            LPDISPLAYHELP pDisplayHelp;

            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }

            hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                                            reinterpret_cast<void**>(&pDisplayHelp));
            ASSERT(hr == S_OK);
            if (SUCCEEDED(hr)) {
               szPath = strPath.GetBuffer(MAX_PATH+1); //Raid #533113, yanggao
               if( ::GetWindowsDirectory(szPath,MAX_PATH) == 0 ) //Raid #prefast
               {
                  strPath.ReleaseBuffer();
                  break;
               }
               strPath.ReleaseBuffer();
               if( CCT_RESULT == pInternal->m_type ) //Raid #510407, 2/24/2002, yanggao
               {
                  GetHelpTopic(((CResult *)pInternal->m_cookie)->GethID(), strTopic);
               }
               else
               if( pInternal->m_cookie )
               {   
                  FOLDER_TYPES type = ((CFolder *)pInternal->m_cookie)->GetType(); //Yanggao  1/31/2001 Bug258658
                  switch(type)
                  {
                  case POLICY_PASSWORD_ANALYSIS:
                  case POLICY_PASSWORD:
                  case LOCALPOL_PASSWORD:
                     strTopic.LoadString(IDS_POLICY_PASSWORD_HTOPIC);
                     break;
                  case POLICY_LOCKOUT_ANALYSIS:
                  case POLICY_LOCKOUT:
                  case LOCALPOL_LOCKOUT:
                     strTopic.LoadString(IDS_POLICY_LOCKOUT_HTOPIC);
                     break;
                  case POLICY_KERBEROS_ANALYSIS:
                  case POLICY_KERBEROS:
                  case LOCALPOL_KERBEROS:
                     strTopic.LoadString(IDS_POLICY_KERBEROS_HTOPIC);
                     break;
                  case POLICY_AUDIT_ANALYSIS:
                  case POLICY_AUDIT:
                  case LOCALPOL_AUDIT:
                     strTopic.LoadString(IDS_POLICY_AUDIT_HTOPIC);
                     break;
                  case AREA_PRIVILEGE_ANALYSIS:
                  case AREA_PRIVILEGE:
                  case LOCALPOL_PRIVILEGE:
                     strTopic.LoadString(IDS_PRIVILEGE_HTOPIC);
                     break;
                  case POLICY_OTHER_ANALYSIS:
                  case POLICY_OTHER:
                  case LOCALPOL_OTHER:
                     strTopic.LoadString(IDS_POLICY_OTHER_HTOPIC);
                     break;
                  case REG_OBJECTS:
                     strTopic.LoadString(IDS_REGISTRY_SETTING_HTOPIC);
                     break;
                  case FILE_OBJECTS:
                     strTopic.LoadString(IDS_FILESYSTEM_SETTING_HTOPIC);
                     break;
                  default:                  
                     switch (((CComponentDataImpl*)m_pComponentData)->GetImplType())
                     {
                     case SCE_IMPL_TYPE_SCE:
                        strTopic.LoadString(IDS_HTMLHELP_SCE_TOPIC);
                        break;
                     case SCE_IMPL_TYPE_SAV:
                        strTopic.LoadString(IDS_HTMLHELP_SCM_TOPIC);
                        break;
                     case SCE_IMPL_TYPE_EXTENSION:{
                        // Raid #258658. 4/10/2001, Go to different .chm for security policy.
                        CFolder* pFolder = (CFolder *) pInternal->m_cookie;
                        DWORD tempmode = pFolder->GetMode();
                        if( SCE_MODE_LOCAL_COMPUTER == tempmode ||
                             SCE_MODE_LOCAL_USER == tempmode )
                        {
                           strTopic.LoadString(IDS_HTMLHELP_LPPOLICY_TOPIC);
                        }
                        else
                        {
                           strTopic.LoadString(IDS_HTMLHELP_POLICY_TOPIC);
                        }
                        break;
                     }
                     case SCE_IMPL_TYPE_LS:
                        strTopic.LoadString(IDS_HTMLHELP_LS_TOPIC);
                        break;
                     default:
                        strTopic.Empty();
                        break;
                     }
                     break;
                  }
               }
               else
               {  //Root node which is not expanded. Raid #611450, yanggao
                  switch (((CComponentDataImpl*)m_pComponentData)->GetImplType())
                  {
                  case SCE_IMPL_TYPE_SCE:
                     strTopic.LoadString(IDS_HTMLHELP_SCE_TOPIC);
                     break;
                  case SCE_IMPL_TYPE_SAV:
                     strTopic.LoadString(IDS_HTMLHELP_SCM_TOPIC);
                     break;
                  case SCE_IMPL_TYPE_LS:
                     strTopic.LoadString(IDS_HTMLHELP_LS_TOPIC);
                     break;
                  default:
                     strTopic.Empty();
                     break;
                  }
               }
               if( strTopic.IsEmpty() )
               {
                  break;
               }
               strPath += strTopic;
               szPath = (LPTSTR)CoTaskMemAlloc(sizeof(LPTSTR) * (strPath.GetLength()+1));
               if (szPath) {
                  //This is a safe usage.
                  lstrcpy(szPath,strPath);

                  hr = pDisplayHelp->ShowTopic(T2OLE((LPWSTR)(LPCWSTR)szPath));
               }
               pDisplayHelp->Release();
            }
            break;
         }

         case MMCN_DELETE:
            // add for delete operations
            // AfxMessageBox(_T("CSnapin::MMCN_DELETE"));
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }

            //Raid #483251, Yanggao, 10/19/2001
            if( CSnapin::m_PropertyPageList.GetCount() > 0)
            {
                //Raid #500199, yanggao, 11/30/2001
                //If there are more than one objects selected to be deleted. We should search every one to make sure that no
                //associated property page is opened right now.
                int iCnt = 0;
                if( pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE)
                {
                    iCnt = (int)pInternal->m_type;
                    pInternal++;
                }
                else
                {
                    iCnt = 1;
                }
                CFolder* pFolder = GetSelectedFolder();
                if( !pFolder )
                {
                    break;
                }
                CString szInfFile = pFolder->GetInfFile();
                szInfFile.MakeLower(); 
                POSITION newpos = CSnapin::m_PropertyPageList.GetHeadPosition();
                int nCount = (int)CSnapin::m_PropertyPageList.GetCount();
                CResult* pItem = NULL;

                INTERNAL* ptempInternal=NULL; //Raid #500199, yanggao. 11/30/2001
                int tempCnt=0;
                while( nCount > 0 && newpos )
                {
                    pItem = CSnapin::m_PropertyPageList.GetNext(newpos);
                    ptempInternal = pInternal;
                    tempCnt = iCnt;
                    while( tempCnt-- > 0 )
                    {
                        CResult* pData = (CResult *)ptempInternal->m_cookie;
                        if( pItem && pData )
                        {
                            CString msg;
                            //This is a safe usage.
                            msg.FormatMessage(IDS_NOT_DELETE_ITEM, pData->GetAttr());
                            pItem->m_strInfFile.MakeLower();  
                            if( pItem == pData ) //Deleted item is the item with this property page.
                            {
                                AfxMessageBox(msg, MB_OK|MB_ICONERROR); //Raid #491120, yanggao
                                tempCnt = 1;
                                break;
                            }
                            else if( pItem->GetType() == pData->GetType() &&
                                 _wcsicmp(pItem->GetAttr(), pData->GetAttr()) == 0 &&
                                 _wcsicmp(pItem->m_strInfFile, szInfFile) == 0 ) //Deleted item has the same attribute of the item with this property page.
                            {
                                AfxMessageBox(msg, MB_OK|MB_ICONERROR); //Raid #491120, yanggao
                                tempCnt = 1;
                                break;
                            }
                        }
                        ptempInternal++;
                    }
                    if( tempCnt > 0 )
                    {
                        break;
                    }
                    nCount--;
                }
                if( nCount == 0 )
                {
                    OnDeleteObjects(lpDataObject,
                            CCT_RESULT,
                            pInternal->m_cookie,
                            arg,
                            param);
                }
            }
            else
            {
                OnDeleteObjects(lpDataObject,
                            CCT_RESULT,
                            pInternal->m_cookie,
                            arg,
                            param);
            }
            break;

         case MMCN_RENAME:
            //AfxMessageBox(_T("CSnapin::MMCN_RENAME\n"));
            break;

         case MMCN_PASTE:
            //         OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());
            break;

         case MMCN_QUERY_PASTE:
            break;
            // Note - Future expansion of notify types possible
         default: {
            }
            hr = E_UNEXPECTED;
            break;
      }

      if (pInternal) {
         FREE_INTERNAL(pInternal);
      }
   }

   //  if (m_pResult)
   //     m_pResult->SetDescBarText(_T("hello world"));
   return hr;
}

STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DeleteList(FALSE);

   // Release the interfaces that we QI'ed
   if (m_pConsole != NULL) {
      // Tell the console to release the header control interface
      m_pConsole->SetHeader(NULL);
      SAFE_RELEASE(m_pHeader);

      SAFE_RELEASE(m_pResult);
      SAFE_RELEASE(m_pImageResult);

      // Release the IConsole interface last
      SAFE_RELEASE(m_pConsole);

      SAFE_RELEASE(m_pConsoleVerb);
   }
   if (g_hDsSecDll) {
      FreeLibrary(g_hDsSecDll);
      g_hDsSecDll = NULL;
   }
   return S_OK;
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                      LPDATAOBJECT* ppDataObject)
{
   HRESULT hr = E_FAIL;

   // Delegate it to the IComponentData
   int iCnt = 0;
   if( cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE ){
      RESULTDATAITEM ri;
      ZeroMemory( &ri, sizeof(RESULTDATAITEM));
      ri.mask = RDI_INDEX | RDI_STATE;
      ri.nIndex = -1;
      ri.nState = LVIS_SELECTED;

      BOOL bCreate = TRUE;
      while( m_pResult->GetNextItem(&ri) == S_OK){
         iCnt++;
         if( ri.bScopeItem ){
            //
            // will not allow actions to be performed on scope items.
            //
            bCreate = FALSE;
            break;
         }
      }

      if(bCreate){
         ri.nIndex = -1;

         if( m_pResult->GetNextItem(&ri) == S_OK){

            cookie = (MMC_COOKIE)ri.lParam;
            type   = CCT_RESULT;

            CComObject<CDataObject>* pObject;

            hr = CComObject<CDataObject>::CreateInstance(&pObject);
            if (!SUCCEEDED(hr)) {
               return hr;
            }
            ASSERT(pObject != NULL);
            if (NULL == pObject) {
               return E_FAIL;
            }

            pObject->SetClsid( reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->GetCoClassID() );

            if(m_pSelectedFolder){
               pObject->SetFolderType( m_pSelectedFolder->GetType() );
            }

            do {
               pObject->AddInternal( (MMC_COOKIE)ri.lParam, CCT_RESULT );
            } while( m_pResult->GetNextItem(&ri) == S_OK );

            return  pObject->QueryInterface(IID_IDataObject,
                                            reinterpret_cast<void**>(ppDataObject));
         }
      }

   }
   ASSERT(m_pComponentData != NULL); // Check the expression.
   if( m_pComponentData ) //Raid #550912, yanggao.
   {
      return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
   }
   else
   {
      return E_FAIL;
   }
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
{
   DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
   CSnapin::lDataObjectRefCount = 0;
   RegisterCheckListWndClass();
   Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
   ASSERT(dbg_cRef == 0);
#endif

   DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

   SAFE_RELEASE(m_pToolbar1);
   SAFE_RELEASE(m_pToolbar2);

   SAFE_RELEASE(m_pControlbar);
   SAFE_RELEASE(m_pConsoleVerb);
   SAFE_RELEASE(m_pImageResult);


   // Make sure the interfaces have been released
   ASSERT(m_pConsole == NULL); //Bogus assertion.
   ASSERT(m_pHeader == NULL); //Bogus Assertion.
   ASSERT(m_pToolbar1 == NULL); //Bogus Assertion.
   ASSERT(m_pToolbar2 == NULL); //Bogus Assertion.

   delete m_pbmpToolbar1;
   delete m_pbmpToolbar2;

   //Raid #464871, Yanggao, 10/09/2001
   SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

   if (m_szAnalTimeStamp) {
      LocalFree(m_szAnalTimeStamp);
      m_szAnalTimeStamp = NULL;
   }

   Construct();
   //If don't save template, CSnapin::lDataObjectRefCount will be 1 here.
   ASSERT(CSnapin::lDataObjectRefCount == 0 || CSnapin::lDataObjectRefCount == 1); //Useless.

}

void CSnapin::Construct()
{
#if DBG==1
   dbg_cRef = 0;
#endif

   m_pConsole = NULL;
   m_pHeader = NULL;

   m_pResult = NULL;
   m_pImageResult = NULL;
   m_pComponentData = NULL;
   m_pToolbar1 = NULL;
   m_pToolbar2 = NULL;
   m_pControlbar = NULL;

   m_pbmpToolbar1 = NULL;
   m_pbmpToolbar2 = NULL;

   m_pConsoleVerb = NULL;
   m_szAnalTimeStamp = NULL;

   m_pNotifier = NULL;
   m_hwndParent = 0;
   m_pSelectedFolder = NULL;
   m_nColumns = 0;
}

void CSnapin::LoadResources()
{
   // Load strings from resources
   m_colName.LoadString(IDS_NAME);
   m_colDesc.LoadString(IDS_DESC);
   m_colAttr.LoadString(IDS_ATTR);
   m_colBaseAnalysis.LoadString(IDS_BASE_ANALYSIS);
   m_colBaseTemplate.LoadString(IDS_BASE_TEMPLATE);
   m_colLocalPol.LoadString(IDS_LOCAL_POLICY_COLUMN);
   m_colSetting.LoadString(IDS_SETTING);
}


//+--------------------------------------------------------------------------
//
//  Function:   GetDisplayInfo
//
//  Synopsis:   Get the string or icon to be displayed for a given result item
//
//  Arguments:  [pResult] - the result item to get display info for and the
//                          type of information to be retrieved
//
//  Returns:    The information to be retrieved in the appropriate field of
//              pResult (str for strings, nImage for icons)
//
//---------------------------------------------------------------------------
STDMETHODIMP CSnapin::GetDisplayInfo(RESULTDATAITEM *pResult)
{
   CString str;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ASSERT(pResult != NULL);

   m_strDisplay.Empty();
   LPTSTR szAlloc = NULL;

   if (pResult) 
   {
      CString  tmpstr;
      int      npos = 0;
      CFolder* pFolder = 0;
      CString  strIndent;

      if (pResult->bScopeItem == TRUE) 
      {
         //
         // pResult is a scope item, not a result item
         //

         pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
         if( pResult->mask & RDI_STR)
         {
            if( pFolder->GetDisplayName( m_strDisplay, pResult->nCol ) == ERROR_SUCCESS)
            {
                pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
            }

         }

         if ( pResult->mask & RDI_IMAGE ) 
         {
            pResult->nImage = pFolder->GetScopeItem()->nImage;
         }
      } 
      else 
      {
         CResult* pData = reinterpret_cast<CResult*>(pResult->lParam);
         pFolder = m_pSelectedFolder; //(CFolder*)(pData->GetCookie());

         if (pResult->mask & RDI_IMAGE) 
         {
            //
            // queries the icon index
            //
            int nImage = GetResultImageIndex(pFolder,
                                             pData);
            if( (pFolder->GetModeBits() & MB_RSOP) == MB_RSOP ) //Raid #625279, Yanggao
            {
               nImage = GetRSOPImageIndex(nImage, pData);
            }
            pResult->nImage = nImage;
         }
         if( pResult->mask & RDI_STR ) 
         {
            if ( pFolder && pResult->nCol &&
               ( pFolder->GetType() == AREA_SERVICE ||
                 pFolder->GetType() == AREA_SERVICE_ANALYSIS) ) 
            {
                  //
                  // service node
                  //
                  GetDisplayInfoForServiceNode(pResult, pFolder, pData);
            } 
            else if ( pData->GetDisplayName( pFolder, m_strDisplay, pResult->nCol ) == ERROR_SUCCESS )
            {
                if( pData->GetID() == SCE_REG_DISPLAY_MULTISZ ) //Bug349000, Yang Gao, 2/23/2001
                {
                   MultiSZToDisp(m_strDisplay, m_multistrDisplay);
                   pResult->str = (LPOLESTR)(LPCTSTR)m_multistrDisplay;
                }
                else
                {
                   pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
                }
            }
         }
      }
   }
   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                   LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                   LONG* pInsertionAllowed)
{
   // if scope item, then call CComponentDataImpl.AddMenuItems
   // else build menu item here for result items.
   INTERNAL* pAllInternal = ExtractInternalFormat(pDataObject);
   INTERNAL* pInternal = NULL;

   CONTEXTMENUITEM cmi;
   HRESULT hr = S_OK;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   MMC_COOKIE cookie = NULL;
   DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;

   pInternal = pAllInternal;
   if (pAllInternal == NULL) {
      return S_OK;
   } else if(pAllInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE){

      //
      // Currently we do not support any options except for delete if there is a mutli select.
      // Remove the comment below to allow other menu items for the CCT_RESULT type.
      //pInternal++;
   }

   //Raid #502596, 12/11/2001, yanggao
   //If scope item has the focus then it will come here before pop up its context menu.
   if( pInternal->m_cookie && 
       (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE != pInternal->m_cookie && CCT_SCOPE == pInternal->m_type )
   {
      CFolder* pFolder = (CFolder*)pInternal->m_cookie;
      pFolder->SetShowViewMenu(TRUE);
   }

   if (CCT_RESULT == pInternal->m_type) {
#if defined(USE_SECURITY_VERB)
      CResult *pResult;
      //
      // In the result pane add the Security... menu item
      //
      pResult = (CResult *)pInternal->m_cookie;

      if (pResult && (pResult->GetType() != ITEM_OTHER)) {
         //
         // It's an editable type, so add the menu item
         //
         CString strSecurity;
         CString strSecurityDesc;

         strSecurity.LoadString(IDS_SECURITY_MENU_ITEM);
         strSecurityDesc.LoadString(IDS_SECURITY_MENU_ITEM_DESC);

         ZeroMemory(&cmi,sizeof(cmi));
         cmi.strName = strSecurity.GetBuffer(0);;
         cmi.strStatusBarText = strSecurityDesc.GetBuffer(0);

         cmi.lCommandID = MMC_VERB_OPEN;

         cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
         cmi.fFlags = MF_ENABLED|MF_STRING;
         cmi.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;

         hr = pContextMenuCallback->AddItem(&cmi);
      }
#endif

   } else if(CCT_SCOPE == pInternal->m_type && (*pInsertionAllowed) & CCM_INSERTIONALLOWED_NEW ) {
      //
      // Insert menus for the scope item.
      //
      hr = ((CComponentDataImpl*)m_pComponentData)->AddMenuItems(pDataObject,
                                                                 pContextMenuCallback, pInsertionAllowed);
   }

   FREE_INTERNAL(pAllInternal);
   return hr;
}

STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
   // if scope item, then call CComponentDataImpl.AddMenuItems
   // else build menu item here for result items.

   INTERNAL* pAllInternal = ExtractInternalFormat(pDataObject);
   INTERNAL* pInternal = NULL;
   HRESULT hr=S_OK;

   int iCnt = 1;
   pInternal = pAllInternal;
   if (pInternal == NULL) {
      // Actually looking for our extension
      return S_OK;
   } else if( pInternal->m_cookie == MMC_MULTI_SELECT_COOKIE ){
      iCnt = (int)pInternal->m_type;
      pInternal++;
   }

   while( iCnt-- ){
      hr = ((CComponentDataImpl*)m_pComponentData)->Command(nCommandID, pDataObject);
      pInternal++;
   }

   if (pAllInternal) {
      FREE_INTERNAL(pAllInternal);
   }
   return hr;
}
/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                          LONG_PTR handle,
                                          LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (!lpDataObject || !lpProvider || !handle) {
      return E_INVALIDARG;
   }
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
   if (!pInternal) 
   {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) 
   {
      return S_FALSE;
   } 
   else if (pInternal->m_type == CCT_RESULT) 
   {
      return AddAttrPropPages(lpProvider,(CResult*)pInternal->m_cookie,handle);
   }

   return S_FALSE;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpDataObject) {
      return E_INVALIDARG;
   }

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   if (!pInternal) {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) {
      //
      // Don't currently support properties for multiselect or anything
      //
      return S_FALSE;
   } else {
      RESULT_TYPES type = ((CResult *)pInternal->m_cookie)->GetType();
      if (ITEM_OTHER != type) {
         return S_OK;
      } else {
         return S_FALSE;
      }
   }
   return S_FALSE;
}

DWORD CComponentDataImpl::m_GroupMode = SCE_MODE_UNKNOWN;


///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl() :
    m_computerModeBits (0),
    m_userModeBits (0),
    m_bEnumerateScopePaneCalled (false)
{
   DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

   m_pScope = NULL;
   m_pConsole = NULL;
   m_bIsDirty = FALSE;
   m_bIsLocked = FALSE;
   m_AnalFolder = NULL;
   m_szSingleTemplateName = NULL;
   m_bDeleteSingleTemplate = FALSE;
   m_pUIThread = NULL;
   m_pNotifier = NULL;

   SadName.Empty();
   SadLoaded = FALSE;
   SadHandle = NULL;
   SadErrored = SCESTATUS_PROFILE_NOT_FOUND;
   SadTransStarted = FALSE;

   m_pszErroredLogFile = NULL;
   m_dwFlags = 0;

   m_pGPTInfo = NULL;
   m_pRSOPInfo = NULL;
   m_pWMIRsop = NULL;
   m_bCriticalSet = FALSE;

   cfSceAccountArea = RegisterClipboardFormat(CF_SCE_ACCOUNT_AREA);
   cfSceEventLogArea = RegisterClipboardFormat(CF_SCE_EVENTLOG_AREA);
   cfSceLocalArea = RegisterClipboardFormat(CF_SCE_LOCAL_AREA);
   cfSceGroupsArea = RegisterClipboardFormat(CF_SCE_GROUPS_AREA);
   cfSceRegistryArea = RegisterClipboardFormat(CF_SCE_REGISTRY_AREA);
   cfSceFileArea = RegisterClipboardFormat(CF_SCE_FILE_AREA);
   cfSceServiceArea = RegisterClipboardFormat(CF_SCE_SERVICE_AREA);
   //This is not a safe usage. Using InitializeCriticalSectionAndSpinCount. Raid #555887, yanggao.
   //Move into function Initialize().
   //InitializeCriticalSection(&csAnalysisPane);
}


CComponentDataImpl::~CComponentDataImpl()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

   ASSERT(m_pScope == NULL); //bogus assertion.
   //If don't save template, CSnapin::lDataObjectRefCount will be 1 here.
   ASSERT(CSnapin::lDataObjectRefCount == 0 || CSnapin::lDataObjectRefCount == 1); //bogus assertion.


   if( m_pszErroredLogFile )
   {
      LocalFree( m_pszErroredLogFile );
   }

   //
   // NT5 only
   //
   if (m_szSingleTemplateName) 
   {

      if (m_bDeleteSingleTemplate) 
	  {
         DeleteFile(m_szSingleTemplateName);
      }
      LocalFree(m_szSingleTemplateName);
   }

   // Delete templates.
   POSITION pos = m_Templates.GetStartPosition();
   PEDITTEMPLATE pTemplate;
   CString strKey;
   while (pos) 
   {
      m_Templates.GetNextAssoc(pos,strKey,pTemplate);
      if (pTemplate && pTemplate->pTemplate) 
	  {
         SceFreeProfileMemory(pTemplate->pTemplate);
         pTemplate->pTemplate = NULL;
      }
      if (NULL != pTemplate) 
	  {
         delete pTemplate;
      }
   }

   if (NULL != m_pUIThread) 
   {
      m_pUIThread->PostThreadMessage(WM_QUIT, (WPARAM)0, 0); //Raid #619921, yanggao, 5/14/2002
   }

   if( m_pNotifier ) //Memory leak, 4/27/2001
   {
      delete m_pNotifier;
   }
   // Delete column information structure.
   pos = m_mapColumns.GetStartPosition();
   FOLDER_TYPES fTypes;
   while(pos)
   {
       PSCE_COLINFOARRAY pCols;
       m_mapColumns.GetNextAssoc(pos, fTypes, pCols);
       if (pCols)
	   {
          LocalFree(pCols);
       }
   }
   m_mapColumns.RemoveAll();

   if (m_pWMIRsop) 
   {
      delete m_pWMIRsop;
   }
   if( m_bCriticalSet ) //Raid #555887, yanggao, 4/5/2002.
      DeleteCriticalSection(&csAnalysisPane);

   if ( m_pGPTInfo )
	   m_pGPTInfo->Release ();
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
   ASSERT(pUnknown != NULL); // Check the expression.
   if( NULL == pUnknown )//Raid #550912, yanggao.
   {
      return E_FAIL;
   }
   HRESULT hr;

   try //Raid #555887, yanggao, 4/5/2002.
   {
      InitializeCriticalSection(&csAnalysisPane);
      m_bCriticalSet = TRUE;
   }
   catch(...)
   {
      return E_FAIL;
   }

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   AfxInitRichEdit();

   m_pNotifier = new CHiddenWnd;
   if (NULL == m_pNotifier) {
      return E_FAIL;
   }


   // MMC should only call ::Initialize once!
   ASSERT(m_pScope == NULL); // Bogus Assertion.
   
   hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2,
                            reinterpret_cast<void**>(&m_pScope));
   if( !SUCCEEDED(hr) ) //Raid #550912, yanggao.
   {
      return hr;
   }
   // add the images for the scope tree
   CBitmap bmp16x16;
   CBitmap bmp32x32;
   LPIMAGELIST lpScopeImage;

   hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
   ASSERT(hr == S_OK); // Check hr. 
   if( !SUCCEEDED(hr) ) //Raid #550912, yanggao.
   {
      pUnknown->Release();
      return hr;
   }

   hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
   if( !SUCCEEDED(hr) ) //Raid #550912, yanggao.
   {
      pUnknown->Release();
      return hr;
   }
   //
   // Create the hidden notifications window.  This window is so that our
   // secondary UI thread can post messages to the main thread which can
   // then be forwarded on to the otherwise unmarshalled MMC COM interfaces.
   //
   //   if (!m_pNotifier->Create(NULL,L"SCE Notifications Window",WS_OVERLAPPED,CRect(0,0,0,0),NULL,0)) {
   if (!m_pNotifier->CreateEx(0,
                              AfxRegisterWndClass(0),
                              L"SCE Notifications Window",
                              0,
                              0,0,0,0,
                              0,
                              0,
                              0)) {
      m_pConsole->Release();
      pUnknown->Release();
      delete m_pNotifier;
      m_pNotifier = NULL;
      return E_FAIL;
   }
   m_pNotifier->SetConsole(m_pConsole);
   m_pNotifier->SetComponentDataImpl(this);

   ASSERT(hr == S_OK); //Check hr.

   // Load the bitmaps from the dll
   bmp16x16.LoadBitmap(IDB_ICON16 /*IDB_16x16 */);
   bmp32x32.LoadBitmap(IDB_ICON32 /*IDB_32x32 */);

   // Set the images
   lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                                   reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                                   0, RGB(255, 0, 255));

   lpScopeImage->Release();

   m_pUIThread = AfxBeginThread(RUNTIME_CLASS(CUIThread));

   m_fSvcNotReady = FALSE;
   m_nNewTemplateIndex = 0;

   //
   // Create the root folder list, If the root isn't created, then when the user
   // right clicks to choose a database the menu command is not executed.
   //
   //
   if(GetImplType() == SCE_IMPL_TYPE_SAV)
      CreateFolderList( NULL, ROOT, NULL, NULL);

   return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
   ASSERT(ppComponent != NULL); //Validate ppComponent.
   if( !ppComponent ) //Raid #550912, yanggao.
   {
      return E_FAIL;
   }
   CComObject<CSnapin>* pObject;

   HRESULT hr = CComObject<CSnapin>::CreateInstance(&pObject);
   if (!SUCCEEDED(hr))
      return hr;

   if (!SUCCEEDED(m_pConsole->GetMainWindow(&m_hwndParent))) 
   {
   }

   // Store IComponentData
   pObject->SetIComponentData(this);
   pObject->m_pUIThread = m_pUIThread;
   pObject->m_pNotifier = m_pNotifier;

   return  pObject->QueryInterface(IID_IComponent,
                                   reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   ASSERT(m_pScope != NULL); //Bogus assertion.
   HRESULT hr = S_FALSE;
   //   CFolder* pFolder = NULL;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   INTERNAL* pInternal = NULL;

   // Since it's my folder it has an internal format.
   // Design Note: for extension.  I can use the fact, that the data object doesn't have
   // my internal format and I should look at the node type and see how to extend it.
   if (event == MMCN_PROPERTY_CHANGE) {
      hr = OnProperties(param);
   } else {
      /*
            INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }

            long cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
      */
      switch (event) {
         case MMCN_DELETE:
            hr = OnDelete(lpDataObject, arg, param);
            break;

         case MMCN_RENAME:
            hr = OnRename(lpDataObject, arg, param);
            break;

         case MMCN_EXPAND:
            hr = OnExpand(lpDataObject, arg, param);
            break;

         case MMCN_CONTEXTMENU:
            hr = OnContextMenu(lpDataObject, arg, param);
            break;

         case MMCN_BTN_CLICK:
            break;

         case MMCN_SELECT: {
               break;
            }
         case MMCN_PASTE: {
            pInternal = ExtractInternalFormat(lpDataObject);
               if (pInternal) {
                  MMC_COOKIE cookie = pInternal->m_cookie;

                  if ( cookie ) {
                      CFolder *pFolder = (CFolder*)cookie;
                      OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());
                  }
               }
               break;
            }
         case MMCN_REMOVE_CHILDREN: {
            if (NULL != m_pNotifier) {
               m_pNotifier->DestroyWindow();
               delete m_pNotifier;
               m_pNotifier = NULL;
            }

            if( this->m_pWMIRsop != NULL ) //Raid #488156, #488066, Yanggao
            {
               delete m_pWMIRsop;
               m_pWMIRsop = NULL;

               CEditTemplate* pet;
               pet = GetTemplate(GT_RSOP_TEMPLATE);
               if(pet)
               {
                   DWORD dwErr = pet->RefreshTemplate(AREA_ALL);
                   if ( 0 != dwErr )
                   {  
                       CString strErr;

                       MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
                       AfxMessageBox(strErr);
                   }
                   
                   //Raid #522779, 2/23/2002, yanggao
                   pet->AddArea(AREA_ALL);

                   //
                   // expand registry value section based on registry values list on local machine
                   //
                   if ( pet->pTemplate )
                   {
                      SceRegEnumAllValues(
                            &(pet->pTemplate->RegValueCount),
                            &(pet->pTemplate->aRegValues)
                            );
                   }
               }
               RefreshAllFolders();
            }

            POSITION pos;
            pos = m_scopeItemPopups.GetStartPosition();
            LONG_PTR key;
            CDialog *pDlg;
            while (pos) {
               m_scopeItemPopups.GetNextAssoc(pos,key,pDlg);
               if(m_pUIThread){
                   m_pUIThread->PostThreadMessage(SCEM_DESTROY_DIALOG, (WPARAM)pDlg, 0);
               }
               m_scopeItemPopups.RemoveKey(key);

            }
            break;

         }
         default:
            break;
      }

   }

   return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
   // Delete enumerated scope items
   // close profile handle if it is open
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //
   // Free the account type name list.
   //
   CGetUser::GetAccountType(NULL);

   if(!m_strTempFile.IsEmpty()){
      DeleteFile( m_strTempFile );
   }

   {
      CSaveTemplates pSaveTemplate;
      POSITION pos;
      PEDITTEMPLATE pTemplate;
      CString strKey;
      int nDirty;

      //
      // Bug #197054:
      //
      // Offer to save dirty templates before reporting if the console
      // itself is dirty and giving users a chance to save that.  If
      // we only save the templates when we save the console then users
      // can unknowingly decide not to save changes to the console and
      // discard all of their changes to the templates
      //
      AFX_MANAGE_STATE(AfxGetStaticModuleState());

      nDirty = 0;

      if (GetModeBits() & MB_TEMPLATE_EDITOR) {
         pos = m_Templates.GetStartPosition();
         while (pos) {
            m_Templates.GetNextAssoc(pos,strKey,pTemplate);
            if (pTemplate->IsDirty() && !pTemplate->QueryNoSave()) {
               pSaveTemplate.AddTemplate(strKey,pTemplate);
               nDirty++;
            }
         }

         if (nDirty) 
         {
            CThemeContextActivator activator;
            if (-1 == pSaveTemplate.DoModal()) 
            {
               CString str;
               str.LoadString(IDS_ERROR_CANT_SAVE);
               AfxMessageBox(str);
            }
         }
      } else if (GetModeBits() & MB_ANALYSIS_VIEWER) {
         pTemplate = GetTemplate(GT_COMPUTER_TEMPLATE);
         if (pTemplate && pTemplate->IsDirty()) {
            if (IDYES == AfxMessageBox(IDS_SAVE_DATABASE,MB_YESNO)) {
               pTemplate->Save();
            }
         }
      }
   }

   DeleteList();

   SAFE_RELEASE(m_pScope);
   SAFE_RELEASE(m_pConsole);


   if ( SadHandle ) {

      if ( SadTransStarted ) {

         EngineRollbackTransaction();

         SadTransStarted = FALSE;
      }
      EngineCloseProfile(&SadHandle);

      SadHandle = NULL;
   }
   if (g_hDsSecDll) {

      FreeLibrary(g_hDsSecDll);
      g_hDsSecDll = NULL;
   }

   return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
   HRESULT hr;
   ASSERT(ppDataObject != NULL); // Validate ppDataObject.
   if( !ppDataObject ) //Raid #550912, yanggao.
      return E_FAIL;

   CComObject<CDataObject>* pObject;

   hr = CComObject<CDataObject>::CreateInstance(&pObject);
   if (!SUCCEEDED(hr)) {
      return hr;
   }
   if (NULL == pObject) {
      return E_FAIL;
   }

   CurrentSnapin = GetImplType();
   // Save cookie and type for delayed rendering
   CFolder *pFolder;
   LPSCESVCATTACHMENTDATA pAttachData;

   pObject->SetType(type);
   pObject->SetCookie(cookie);

   //
   // Store the coclass with the data object
   //
   pObject->SetClsid(GetCoClassID());


   if (cookie && (CCT_SCOPE == type)) {
      pFolder = (CFolder *) cookie;
      pObject->SetFolderType(pFolder->GetType());
      if ((AREA_SERVICE == pFolder->GetType()) ||
          (AREA_SERVICE_ANALYSIS == pFolder->GetType())) {
         InternalAddRef();
         pObject->SetSceSvcAttachmentData(this);
      }
      pObject->SetMode(pFolder->GetMode());
      pObject->SetModeBits(pFolder->GetModeBits());

      pObject->SetGPTInfo(m_pGPTInfo);
      pObject->SetRSOPInfo(m_pRSOPInfo);
   }
   return  pObject->QueryInterface(IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
   ASSERT(pClassID != NULL); // Validate pClassID.
   if( !pClassID ) //Raid #550912, yanggao.
      return E_FAIL;
   // Copy the CLSID for this snapin
   *pClassID = GetCoClassID();  // CLSID_Snapin;

   return E_NOTIMPL;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
   if (ThisIsDirty()) {
      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
// CComponentDataImpl::Load
//
// Loads configuration saved information from the MMC stream.
// SAD:{%s}          - The sad same, if any.
// LOGFILE:{%s}{%d}  - The log file last used for the database,
//                     and the position the was last written to by this
//                     remembered snapin.  If the user chooses not to save this
//                     information then, What is displayed will be out of date.
// SerializecolumnInfo() is called to create remembered column information.
//
// Arguments:  [pStm]   - The MMC stream to load from.
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
   ASSERT(pStm); // Validate pStm.
   if( !pStm ) //Raid #550912, yanggao.
   {
      return E_FAIL;
   }
   //
   // Read sad name.
   //
   LPTSTR szSadName = NULL;
   if (0 < ReadSprintf(pStm,L"SAD:{%s}",&szSadName)) {
      SadName = szSadName;
      LocalFree(szSadName);

      LoadSadInfo(TRUE);
   }

   //
   // Read log file used and last position it was viewed from.
   //
   DWORD nPos;
   if( 0 < ReadSprintf(pStm, L"LOGFILE:{%s}{%d}", &szSadName, &nPos) ){
      SetErroredLogFile( szSadName, nPos);
      LocalFree( szSadName );
   }

   SerializeColumnInfo( pStm, NULL, TRUE );
   return S_OK;
}

//+--------------------------------------------------------------------------
// CComponentDataImpl::Save
//
// Saves configuration file information.
// SAD:{%s}          - The sad same, if any.
// LOGFILE:{%s}{%d}  - The log file last used for the database,
//                     and the position the was last written to by this
//                     remembered snapin.  If the user chooses not to save this
//                     information then, What is displayed will be out of date.
// SerializecolumnInfo() is called to save column information.
//
// Arguments:  [pStm]   - The MMC stream to save to
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ASSERT(pStm); //Validate pStm.
   if( !pStm ) //Raid #550912, yanggao.
   {
      return E_FAIL;
   }
   if (!SadName.IsEmpty() && !IsSystemDatabase(SadName)) {
      WriteSprintf(pStm,L"SAD:{%s}",(LPCTSTR)SadName);
   }

   if ( GetErroredLogFile() ){
      LONG uPos = 0;
      WriteSprintf(pStm, L"LOGFILE:{%s}{%d}", GetErroredLogFile(&uPos), uPos);
   }

   SerializeColumnInfo( pStm, NULL, FALSE );

   if (fClearDirty) {
      ClearDirty();
   }

   return S_OK;
}


//+--------------------------------------------------------------------------
// CComponentDataImpl::GetSizeMax
//
// Don't have a clue what the size will be of the string we want to save.
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnAdd(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnRename(LPDATAOBJECT lpDataObject,LPARAM arg, LPARAM param)
{
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnExpand
//
//  Synopsis:   Expand a scope pane node and add its children folders
//
//  Arguments:  [lpDataObject]  - The data object for the node we're expanding
//              [arg] -    Whether or not initialize has been called
//              [param] -  The id of the node we're expanding
//
//
//  Modifies:
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------
HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject,
                                     LPARAM arg,
                                     LPARAM param)
{
   CString strName;
   CString strDesc;
   DWORD dwMode = 0;
   SCESTATUS scestatus = SCESTATUS_SUCCESS;

   ASSERT(lpDataObject);

   if ( lpDataObject == NULL ) 
      return E_FAIL;

   HRESULT hr = S_OK;

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   CFolder *pFolder = NULL;

   if (pInternal == NULL) 
   {
      //
      // The node doesn't have our internal format, so we must be extending
      // somebody else.  Figure out who we are extending and what mode we are in
      //
      GUID* nodeType = ExtractNodeType(lpDataObject);
      GUID guidMyComputer = structuuidNodetypeSystemTools;

      dwMode = SCE_MODE_UNKNOWN;
      if (!nodeType) 
      {
         //
         // This should never happen; nodeType should always be set here
         //
         ASSERT(FALSE);
         return E_FAIL;
      }

      //
      // MAX_PATH*5 is magic; GetDSPath and GetGPT path don't provide
      // a direct way to find out how long a path is needed
      //
      TCHAR pszDSPath[MAX_PATH*5];
      TCHAR pszGPTPath[MAX_PATH*5];

      if (::IsEqualGUID(*nodeType,NODEID_Machine) ||
          ::IsEqualGUID(*nodeType,NODEID_User)) 
      {
         //
         // GPE Extension
         //
         hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                           reinterpret_cast<void**>(&m_pGPTInfo));

         if (SUCCEEDED(hr)) 
         {
            //
            // get ds root path
            //
            DWORD dwSection = 0;
            GROUP_POLICY_HINT_TYPE gpHint;
            GROUP_POLICY_OBJECT_TYPE gpType;

            //
            // Give the GPT Information to the hidden notifications window so
            // it can keep calls to it on this thread
            //
            m_pNotifier->SetGPTInformation(m_pGPTInfo);

            hr = m_pGPTInfo->GetType(&gpType);

            if ( SUCCEEDED(hr) ) 
            {
               switch ( gpType ) 
               {
               case GPOTypeLocal:

                  //
                  // We're editing a this machine's Policy, not Global Policy
                  //
                  if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                  {
                     //
                     // LPE Machine Node type
                     //
                     dwMode = SCE_MODE_LOCAL_COMPUTER;
                     ASSERT(m_pNotifier); //Bogus assertion.

                  } 
                  else 
                  {
                     //
                     // LPE User Node type
                     //
                     dwMode = SCE_MODE_LOCAL_USER;
                  }
                  break;

               case GPOTypeRemote:
                  //
                  // We're editing a remote machine's Policy
                  //
                  if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                  {
                     //
                     // LPE Machine Node type
                     //
                     dwMode = SCE_MODE_REMOTE_COMPUTER;
                  } 
                  else 
                  {
                     //
                     // LPE User Node type
                     //
                     dwMode = SCE_MODE_REMOTE_USER;
                  }
                  break;

               default:
                  hr = m_pGPTInfo->GetHint(&gpHint);
                  if (SUCCEEDED(hr)) 
                  {
                     switch (gpHint) 
                     {
                     case GPHintMachine:
                     case GPHintUnknown:
                     case GPHintDomain:
                        //
                        // We're editing Global Domain Policy
                        //
                        if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                        {
                           //
                           // GPE Machine Node type
                           //
                           dwMode = SCE_MODE_DOMAIN_COMPUTER;
                        } 
                        else 
                        {
                           //
                           // GPE User Node type
                           //
                           dwMode = SCE_MODE_DOMAIN_USER;
                        }
                        break;

                     case GPHintSite:
                     case GPHintOrganizationalUnit:
                        //
                        // We're editing Global Domain Policy
                        //
                        if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                        {
                           //
                           // GPE Machine Node type
                           //
                           dwMode = SCE_MODE_OU_COMPUTER;
                        } 
                        else 
                        {
                           //
                           // GPE User Node type
                           //
                           dwMode = SCE_MODE_OU_USER;
                        }
                        break;

                     default:
                        //
                        // Should never get here
                        //
                        ASSERT(FALSE);
                        break;
                     }
                  }

                  break;
               }
               //
               // remember the root node's mode
               //
               m_Mode = dwMode;
               m_GroupMode = dwMode;

               switch (dwMode) 
               {
               case SCE_MODE_DOMAIN_COMPUTER:
               case SCE_MODE_OU_COMPUTER:
                  dwSection = GPO_SECTION_MACHINE;
                  break;

               case SCE_MODE_LOCAL_COMPUTER:
                  //
                  // For local use the policy database rather than a template
                  //
                  break;

               case SCE_MODE_REMOTE_COMPUTER:
               case SCE_MODE_REMOTE_USER:
               case SCE_MODE_LOCAL_USER:
               case SCE_MODE_DOMAIN_USER:
               case SCE_MODE_OU_USER:
                  //
                  // For now we don't support any native nodes in USER modes, so we
                  // don't need a template
                  //
                  break;

               default:
                  break;
               }
               //
               // Find the path to the SCE template within the GPT template
               //
               if (GPO_SECTION_MACHINE == dwSection) 
               {
                  //
                  // 156869  Default Domain and Default DC GPO's should only be modifiable on the FSMO PDC
                  //
                  TCHAR szGUID[MAX_PATH];
                  hr = m_pGPTInfo->GetName(szGUID,MAX_PATH);
                  if (SUCCEEDED(hr)) 
                  {
                     LPTSTR szDCGUID = TEXT("{") STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID TEXT("}");
                     LPTSTR szDomGUID = TEXT("{") STR_DEFAULT_DOMAIN_GPO_GUID TEXT("}");
                     if ((0 == lstrcmpi(szGUID, szDCGUID)) || (0 == lstrcmpi(szGUID, szDomGUID))) 
                     {
                        LPGROUPPOLICYOBJECT pGPO = NULL;

                        //
                        // Default Domain or Default DC GPO.  Make sure we're talking to the PDC
                        //
                        TCHAR szDCName[MAX_PATH];
                        hr = lpDataObject->QueryInterface(IID_IGroupPolicyObject,(LPVOID*)&pGPO);
                        if (SUCCEEDED(hr)) 
                        {
                           hr = pGPO->GetMachineName(szDCName,MAX_PATH);
                           pGPO->Release();
                        }
                        if (SUCCEEDED(hr)) 
                        {
                           DOMAIN_CONTROLLER_INFO *dci = 0;

                           if (NO_ERROR != DsGetDcName(szDCName,NULL,NULL,NULL,DS_PDC_REQUIRED,&dci))  
                           {
                              //
                              // We're not connected to the PDC (or we can't get info about who we're
                              // connected to, so assume the same
                              //
                              dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                           }
                           if(dci)
                              NetApiBufferFree(dci);
                        } 
                        else
                           dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                     }
                  } 
                  else 
                  {
                     //
                     // Can't get the name of the DC we're talking to, so assume it's not the PDC
                     //
                     dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                  }

                  //
                  // get GPT root path
                  //

                  hr = m_pGPTInfo->GetFileSysPath(dwSection,
                                                  pszGPTPath,
                                                  ARRAYSIZE(pszGPTPath));
                  if (SUCCEEDED(hr)) 
                  {
                     //
                     // Allocate memory for the pszGPTPath + <backslash> + GPTSCE_TEMPLATE + <trailing nul>
                     //
                     m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(pszGPTPath)+lstrlen(GPTSCE_TEMPLATE)+2)*sizeof(TCHAR));
                     if (NULL != m_szSingleTemplateName) 
                     {
                        //This is a safe usage.
                        lstrcpy(m_szSingleTemplateName,pszGPTPath);
                        lstrcat(m_szSingleTemplateName,L"\\" GPTSCE_TEMPLATE);
                     } 
                     else
                        hr = E_OUTOFMEMORY;
                  }
               } 
               else 
               {
                  //
                  // else user section
                  //
               }
            } 
            else 
            {
               //
               // can't get GPT path, error is in hr
               ASSERT(FALSE);
               //
            }
         } 
         else 
         {
            //
            // else error in hr
            //
         }
      } else if (::IsEqualGUID(*nodeType,NODEID_RSOPMachine) ||
                 ::IsEqualGUID(*nodeType,NODEID_RSOPUser)) 
      {
         //
         // RSOP Extension
         //
         if (::IsEqualGUID(*nodeType,NODEID_RSOPMachine)) 
         {
            //
            // GPE Machine Node type
            //
            dwMode = SCE_MODE_RSOP_COMPUTER;
            m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(GT_RSOP_TEMPLATE)+1)*sizeof(TCHAR));
            if (NULL != m_szSingleTemplateName)
               //This is a safe usage.
               lstrcpy(m_szSingleTemplateName,GT_RSOP_TEMPLATE);
            else
               hr = E_OUTOFMEMORY;
         } 
         else 
         {
            //
            // GPE User Node type
            //
            dwMode = SCE_MODE_RSOP_USER;
         }
         hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                           reinterpret_cast<void**>(&m_pRSOPInfo));

      } 
      else 
      {
         //
         // We should never get into this state
         //
         ASSERT(0);
         hr = E_FAIL;
      }

      //
      // free node type buffer
      //

      if (nodeType)
         GlobalFree(nodeType);

      if ( FAILED(hr) ) 
      {
         //
         // free template buffer if allocated
         //
         if ( m_szSingleTemplateName )
            LocalFree(m_szSingleTemplateName);
         m_szSingleTemplateName = NULL;

         return hr;
      }

      //
      // As an extension snapin, the secedit root node should be added
      //
      pFolder = new CFolder();

      ASSERT(pFolder);

      if ( pFolder ) 
      {
         if (!pFolder->SetMode(dwMode)) 
         {
            //
            // This should never happen; we should always have a valid dwMode by now
            //
            ASSERT(FALSE);

            //
            // remember to free the memory
            //

            delete pFolder;
            return E_FAIL;
         }

         FOLDER_TYPES RootType = STATIC;
         LPTSTR szInfFile = NULL;

         DWORD* pdwModeBits = 0;
         switch (m_Mode)
         {
         case SCE_MODE_DOMAIN_COMPUTER:
         case SCE_MODE_OU_COMPUTER:
         case SCE_MODE_LOCAL_COMPUTER:
         case SCE_MODE_REMOTE_COMPUTER:
            pdwModeBits = &m_computerModeBits;
            break;

         case SCE_MODE_REMOTE_USER:
         case SCE_MODE_LOCAL_USER:
         case SCE_MODE_DOMAIN_USER:
         case SCE_MODE_OU_USER:
            pdwModeBits = &m_userModeBits;
            break;

         default:
            pdwModeBits = &m_computerModeBits;
            break;
         }

         *pdwModeBits = pFolder->GetModeBits();
         if (*pdwModeBits & MB_ANALYSIS_VIEWER) 
         {
            strName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
            szInfFile = GT_COMPUTER_TEMPLATE;
            RootType = ANALYSIS;
         } 
         else if (*pdwModeBits & MB_TEMPLATE_EDITOR) 
         {
            strName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
            RootType = CONFIGURATION;
         } 
         else if (*pdwModeBits & MB_LOCAL_POLICY) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = LOCALPOL;
         } 
         else if (*pdwModeBits & MB_STANDALONE_NAME) 
         {
            strName.LoadString(IDS_NODENAME);
            RootType = STATIC;
         } 
         else if (*pdwModeBits & MB_SINGLE_TEMPLATE_ONLY) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = PROFILE;
            szInfFile = m_szSingleTemplateName;
         } 
         else if (*pdwModeBits & MB_NO_NATIVE_NODES) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = PROFILE;
         } 
         else 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
         }


         strDesc.LoadString(IDS_SECURITY_SETTING_DESC);  // only GPE extensions get here
         hr = pFolder->Create(strName,           // Name
                              strDesc,           // Description
                              szInfFile,         // inf file name
                              SCE_IMAGE_IDX,     // closed icon index
                              SCE_IMAGE_IDX,     // open icon index
                              RootType,          // folder type
                              TRUE,              // has children
                              dwMode,            // SCE Mode
                              NULL);             // Extra Data
         if (FAILED(hr)) 
         {
            delete pFolder;
            return hr;
         }

         m_scopeItemList.AddTail(pFolder);

         // Set the parent
         pFolder->GetScopeItem()->mask |= SDI_PARENT;
         pFolder->GetScopeItem()->relativeID = param;

         // Set the folder as the cookie
         pFolder->GetScopeItem()->mask |= SDI_PARAM;
         pFolder->GetScopeItem()->lParam = reinterpret_cast<LPARAM>(pFolder);
         pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));

         m_pScope->InsertItem(pFolder->GetScopeItem());
         //
         // Note - On return, the ID member of 'm_pScopeItem'
         // contains the handle to the newly inserted item!
         //
         ASSERT(pFolder->GetScopeItem()->ID != NULL); //Bogus assertion.

      } 
      else
         return E_OUTOFMEMORY;

      return S_OK;
   } 
   else 
   {
      //
      // Expanding one of our own nodes
      MMC_COOKIE cookie = pInternal->m_cookie;
      FREE_INTERNAL(pInternal);

      if (arg != FALSE) 
      {
         //
         // Did Initialize get called?
         // 
         ASSERT(m_pScope != NULL); //Bogus Assert. Yanggao.
         EnumerateScopePane(cookie, param);
      }
   }
   return S_OK;
}

HRESULT CComponentDataImpl::OnSelect(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CComponentDataImpl::OnContextMenu(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CComponentDataImpl::OnProperties(LPARAM param)
{
   if (param == NULL)
      return S_OK;
   
   ASSERT(param != NULL);


   return S_OK;
}

void CComponentDataImpl::DeleteList()
{
   POSITION pos = m_scopeItemList.GetHeadPosition();

   while (pos)
      delete m_scopeItemList.GetNext(pos);
}

CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie, POSITION* thePos)
{
   POSITION pos = m_scopeItemList.GetHeadPosition();
   POSITION curPos;
   CFolder* pFolder = NULL;

   while (pos) {
      curPos = pos;
      // pos is already updated to the next item after this call
      pFolder = m_scopeItemList.GetNext(pos);

      //
      // The first folder in the list belongs to cookie 0
      //
      if (!cookie || (pFolder == (CFolder *)cookie)) {
         if ( thePos ) {
            *thePos = curPos;
         }

         return pFolder;
      }
   }

   if ( thePos ) {
      *thePos = NULL;
   }

   return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
   ASSERT(pScopeDataItem != NULL);
   if (pScopeDataItem == NULL)
      return E_POINTER;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

   ASSERT(pScopeDataItem->mask & SDI_STR); //Bogus assert. Yanggao.

   // MMC does not supprot call back on scope node image
   if ( pScopeDataItem->mask & SDI_IMAGE ) {

      //int nImage = GetScopeImageIndex(pFolder->GetType());
      pScopeDataItem->nImage = pFolder->GetScopeItem()->nImage;
   }

   m_strDisplay.Empty();
   if(pFolder){
      pFolder->GetDisplayName(m_strDisplay, 0);
      m_Mode = pFolder->GetMode(); //YangGao #332852 fix.
   }
   pScopeDataItem->displayname = (LPOLESTR)(LPCTSTR)m_strDisplay;
   ASSERT(pScopeDataItem->displayname != NULL); //Bogus Aseert. Yanggao.

   return S_OK;
}


STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
   if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

   // Make sure both data object are mine
   HRESULT hr = S_FALSE;

   INTERNAL *pA = ExtractInternalFormat(lpDataObjectA);
   INTERNAL *pB = ExtractInternalFormat(lpDataObjectB);

   if (pA != NULL && pB != NULL)
      hr = (*pA == *pB) ? S_OK : S_FALSE;
	   
   FREE_INTERNAL(pA);
   FREE_INTERNAL(pB);

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                                     LONG_PTR handle,
                                                     LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpDataObject || !lpProvider || !handle) {
      return E_INVALIDARG;
   }
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
   if (!pInternal) {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) {
      return S_FALSE;
   } else if (pInternal->m_type == CCT_SCOPE) {
      return AddAttrPropPages(lpProvider,(CFolder*)(pInternal->m_cookie),handle);
   }

   return S_FALSE;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Look at the data object and see if it an item in the scope pane
   return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
   BOOL bResult = FALSE;
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   // taking out m_cookie == NULL, should check foldertype ???
   if (pInternal->m_type == CCT_SCOPE) {
      bResult = TRUE;
   }

   FREE_INTERNAL(pInternal);

   return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
BOOL LoadContextMenuResources(MENUMAP* pMenuMap)
{
   HINSTANCE hInstance = _Module.GetModuleInstance();
   for (int i = 0; pMenuMap->ctxMenu[i].strName; i++) {
      if (0 == ::LoadString(hInstance, pMenuMap->dataRes[i].uResID, pMenuMap->dataRes[i].szBuffer, MAX_CONTEXT_MENU_STRLEN*2))
         return FALSE;
      pMenuMap->ctxMenu[i].strName = pMenuMap->dataRes[i].szBuffer;
      for (WCHAR* pCh = pMenuMap->dataRes[i].szBuffer; (*pCh) != NULL; pCh++) {
         if ( (*pCh) == L'\n') {
            pMenuMap->ctxMenu[i].strStatusBarText = (pCh+1);
            (*pCh) = NULL;
            break;
         }
      }
   }
   return TRUE;
}

BOOL CComponentDataImpl::LoadResources()
{

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   return
   LoadContextMenuResources(CSecmgrNodeMenuHolder::GetMenuMap() ) &&
   LoadContextMenuResources(CAnalyzeNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CConfigNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CLocationNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CSSProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CRSOPProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CLocalPolNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileSubAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileSubAreaEventLogMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeGroupsMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeFilesMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeRegistryMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileGroupsMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileFilesMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileRegistryMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeObjectsMenuHolder::GetMenuMap());
}


STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG* pInsertionAllowed)
{
   HRESULT hr = S_OK;

   // Note - snap-ins need to look at the data object and determine
   // in what context, menu items need to be added.
   INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

   if (pInternal == NULL) 
   {
      //
      // Actually looking for our extension
      //
      return S_OK;
   }

   MMC_COOKIE cookie = pInternal->m_cookie;
   LPCONTEXTMENUITEM pContextMenuItem=NULL;

   CFolder *pFolder = NULL;
   if ( NULL == cookie ) 
   {
      //
      // root. IDS_ABOUT_SECMGR
      //

      //
      // either analysis node, or configuration node
      //
      if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_SAVSnapin) ) 
      {
          if ((NULL == SadHandle) && SadErrored != SCESTATUS_SUCCESS) 
          {
             LoadSadInfo(TRUE);
          }
          pContextMenuItem = CAnalyzeNodeMenuHolder::GetContextMenuItem();
      } 
      else if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_SCESnapin) ) 
          pContextMenuItem = CConfigNodeMenuHolder::GetContextMenuItem();
      else if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_LSSnapin) )
          pContextMenuItem = CLocalPolNodeMenuHolder::GetContextMenuItem();

   } 
   else 
   {
      pFolder = (CFolder *)cookie;

      FOLDER_TYPES type = pFolder->GetType(); //pInternal->m_foldertype;


      switch (type) 
      {
      case CONFIGURATION:
         // IDS_ADD_LOCATION
         pContextMenuItem = CConfigNodeMenuHolder::GetContextMenuItem();
         break;

      case LOCATIONS:
         // IDS_NEW_PROFILE,
         pContextMenuItem = CLocationNodeMenuHolder::GetContextMenuItem();
         break;

      case ANALYSIS:
         // IDS_PROFILE_INFO
         if ((NULL == SadHandle) && SadErrored != SCESTATUS_SUCCESS) 
            LoadSadInfo(TRUE);
         pContextMenuItem = CAnalyzeNodeMenuHolder::GetContextMenuItem();
         break;

      case LOCALPOL:
         if( !(pFolder->GetState() & CFolder::state_InvalidTemplate))
            pContextMenuItem = CLocalPolNodeMenuHolder::GetContextMenuItem();
         break;

      case PROFILE:
         //
         // If we're in a mode that doesn't want template (aka profile) verbs
         // Then don't add the save, save as & configure verbs here
         //
         if (pFolder->GetState() & CFolder::state_InvalidTemplate)
             break;
         else if (!(pFolder->GetModeBits() & MB_NO_TEMPLATE_VERBS))
            pContextMenuItem = CProfileNodeMenuHolder::GetContextMenuItem();
         else if (GetModeBits() & MB_READ_ONLY)
            pContextMenuItem = CRSOPProfileNodeMenuHolder::GetContextMenuItem();
         else
            pContextMenuItem = CSSProfileNodeMenuHolder::GetContextMenuItem();
         break;

      case AREA_POLICY:
      case AREA_SERVICE:
      case POLICY_ACCOUNT:
      case POLICY_LOCAL:
      case POLICY_EVENTLOG:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
             pContextMenuItem = CProfileAreaMenuHolder::GetContextMenuItem();
         break;

      case AREA_PRIVILEGE:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
      case POLICY_OTHER:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY) 
             pContextMenuItem = CProfileSubAreaMenuHolder::GetContextMenuItem();
         break;

      case POLICY_LOG: //Raid #253209, Yang Gao, 3/27/2001.
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY) 
             pContextMenuItem = CProfileSubAreaEventLogMenuHolder::GetContextMenuItem();
         break;

      case AREA_GROUPS:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
             pContextMenuItem = CProfileGroupsMenuHolder::GetContextMenuItem();
         break;

      case AREA_REGISTRY:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
            pContextMenuItem = CProfileRegistryMenuHolder::GetContextMenuItem();
         break;

      case AREA_FILESTORE:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
            pContextMenuItem = CProfileFilesMenuHolder::GetContextMenuItem();
         break;

      case AREA_POLICY_ANALYSIS:
      case AREA_PRIVILEGE_ANALYSIS:
      case AREA_SERVICE_ANALYSIS:
         // if under analysis info node, IDS_REFRESH_AREA
         pContextMenuItem = CAnalyzeAreaMenuHolder::GetContextMenuItem();
         break;

      case AREA_GROUPS_ANALYSIS:
         pContextMenuItem = CAnalyzeGroupsMenuHolder::GetContextMenuItem();
         break;
      case AREA_REGISTRY_ANALYSIS:
         pContextMenuItem = CAnalyzeRegistryMenuHolder::GetContextMenuItem();
         break;
      case AREA_FILESTORE_ANALYSIS:
         pContextMenuItem = CAnalyzeFilesMenuHolder::GetContextMenuItem();
         break;

      case REG_OBJECTS:
      case FILE_OBJECTS:
         pContextMenuItem = CAnalyzeObjectsMenuHolder::GetContextMenuItem();
         break;

      default:
         break;
      }
   }

   FREE_INTERNAL(pInternal);

   if ( NULL == pContextMenuItem ) 
      return hr;
   
   //
   // Loop through and add each of the menu items
   //
   PWSTR pstrWizardName = NULL;
   PWSTR pstrPathName=NULL;

   for ( LPCONTEXTMENUITEM m = pContextMenuItem; m->strName; m++) 
   {
      //
      // make a tempoary copy that can be modified
      //
      CONTEXTMENUITEM tempItem;
      //This is a safe usage.
      ::memcpy(&tempItem, m, sizeof(CONTEXTMENUITEM));
      //
      // check each command's state ?
      //
      CString strInf;
      PEDITTEMPLATE pTemp = 0;

      switch (tempItem.lCommandID ) 
      {
      case IDM_RELOAD:
      case IDM_DESCRIBE_LOCATION:
      case IDM_NEW:
         if(pFolder &&
            pFolder->GetType() == LOCATIONS &&
            pFolder->GetState() & CFolder::state_InvalidTemplate )
         {
            tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_EXPORT_POLICY:
         //
         // Grey out export if we can't open a database.
         //
         if(!SadHandle)
            tempItem.fFlags = MF_GRAYED;
         break;

      case IDM_EXPORT_LOCALPOLICY:
         break;
      case IDM_EXPORT_EFFECTIVE:
         if(!SadHandle)
         {
            //
            // Don't try to insert these items.
            continue;
         }
         //
         // Sub items of effective policy.
         //
         tempItem.lInsertionPointID = IDM_EXPORT_POLICY;
         break;

      case IDM_SECURE_WIZARD:
          //
          // check if there is a secure wizard registered
          //

          GetSecureWizardName(&pstrPathName, &pstrWizardName);

          if ( pstrPathName ) 
          {
              //
              // if PathName is returned, the secure wizard is registered
              // but the display name may not be defined in the resource
              // in which case, the default "Secure Wizard" string is used.
              //
              if ( pstrWizardName )
                  tempItem.strName = pstrWizardName;

              LocalFree(pstrPathName);

          } 
          else
              continue;
          break;

      case IDM_PASTE: 
         {
            UINT cf = 0;
            AREA_INFORMATION Area;

            if (cookie && GetFolderCopyPasteInfo(((CFolder*)cookie)->GetType(),&Area,&cf)) 
            {
               OpenClipboard(NULL);
               if (!::IsClipboardFormatAvailable(cf))
                  tempItem.fFlags = MF_GRAYED;
               
               CloseClipboard();
            }
         }
         break;

      case IDM_SAVE:
         {
            CFolder *pFolder2 = (CFolder *)cookie;

            if ( pFolder2 && ANALYSIS != pFolder2->GetType() )
               strInf = pFolder2->GetInfFile();
            else 
            {
               //
               // analysis
               //
               strInf = GT_COMPUTER_TEMPLATE;
            }
            if ( strInf ) 
            {
               pTemp= GetTemplate(strInf);
               if( pTemp && pFolder2 ) //212287, Yanggao, 3/20/2001
               {
                  LPCTSTR des = pFolder2->GetDesc();
                  if( des )
                  {
                     if( pTemp->GetDesc() )
                     {
                        if( !wcscmp(des, pTemp->GetDesc()) )
                           pTemp->SetDescription(des);
                     }
                     else
                        pTemp->SetDescription(des);
                  }
               }
               if (!pTemp || !pTemp->IsDirty())
                  tempItem.fFlags = MF_GRAYED;
            } 
            else
               tempItem.fFlags = MF_GRAYED;

            if (m_bIsLocked)
               tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_ASSIGN:
         //
         // For NT5 this menu item should be grayed if we don't have a sad handle and if analysis is locked.
         //
         if (m_bIsLocked || (!SadHandle && SadName.IsEmpty()) ||
             SadErrored == SCESTATUS_ACCESS_DENIED || SadErrored == SCESTATUS_SPECIAL_ACCOUNT) //Raid #601210, yanggao
         {
            tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_VIEW_LOGFILE:
         if(!GetErroredLogFile())
            tempItem.fFlags = MF_GRAYED;
         else if (m_dwFlags & flag_showLogFile )
            tempItem.fFlags = MF_CHECKED;
         break;

      case IDM_SET_DB:
      case IDM_OPEN_PRIVATE_DB:
         if ( m_bIsLocked )
            tempItem.fFlags = MF_GRAYED;
         break;

      case IDM_SUMMARY:
      case IDM_APPLY:
      case IDM_GENERATE:
      case IDM_ANALYZE: 
         {
            WIN32_FIND_DATA fd;
            HANDLE handle = 0;
            //
            // Bug #156375
            //
            // don't gray out if we have a database file.  we can't open the
            // database (and therefore get a SadHandle) unless the database has
            // already been analyzed, which gives a chicken & egg problem with
            // requiring the SadHandle to enable IDM_ANALYZE or IDM_APPLY....
            // (if we have a SadHandle already then everything's fine, of course)
            //
            // If the database is corrupt or invalid then the actual action will
            // fail and we'll display an error then.
            //
            if (m_bIsLocked) 
            {
               tempItem.fFlags = MF_GRAYED;
               //
               // If we have a SadHandle then we're ok
               //
            } 
            else if (!SadHandle) 
            {
               //
               // Bug #387406
               //
               // If we don't have a SadHandle we can't generate a template
               // even if the database file exists
               //
               if (IDM_GENERATE == tempItem.lCommandID )
                  tempItem.fFlags = MF_GRAYED;
               else 
               {
                  //
                  // With no database handle & no assigned configuration then let the
                  // menu option be selected so long as the database file exists.
                  //
                  if (SadName.IsEmpty() || SadErrored == SCESTATUS_ACCESS_DENIED ||
                      SadErrored == SCESTATUS_SPECIAL_ACCOUNT) //Raid #601210, yanggao
                     tempItem.fFlags = MF_GRAYED;
                  else 
                  {
                     handle = FindFirstFile(SadName,&fd);
                     if (INVALID_HANDLE_VALUE == handle) 
                        tempItem.fFlags = MF_GRAYED;
                     else
                        FindClose(handle);
                  }
               }
            }
         }
         break;

      case IDM_ADD_LOC:
         if ( !m_bEnumerateScopePaneCalled )
            tempItem.fFlags = MF_GRAYED;
         break;

      //Raid #502596, 12/11/2001, yanggao
      //If this scope item is not selected, then disable its "Add" menu item.
      case IDM_ADD_GROUPS:
         if( !pFolder->GetShowViewMenu() )
         {
            tempItem.fFlags = MF_GRAYED;
         }
         pFolder->SetShowViewMenu(FALSE);
         break;

      default:
         break;
      }

      hr = pContextMenuCallback->AddItem(&tempItem);
      if (FAILED(hr))
         break;
   }

   if ( pstrWizardName ) 
      LocalFree(pstrWizardName);

   return hr;
}

DWORD DeleteLocationFromReg2(HKEY hKey,LPCTSTR KeyStr) 
{
   DWORD rc = 0;

   // replace the "\" with "/" because registry does not take "\" in a single key
   CString tmpstr = KeyStr;
   int npos = tmpstr.Find(L'\\');
   while (npos > 0) {
      *(tmpstr.GetBuffer(1)+npos) = L'/';
      npos = tmpstr.Find(L'\\');
   }
   rc = RegDeleteKey( hKey, (LPCTSTR)tmpstr);

   RegCloseKey(hKey);

   return rc;
}

DWORD DeleteLocationFromReg(LPCTSTR KeyStr)
{
   // delete the location to registry

   BOOL bSuccess = FALSE;
   HKEY hKey=NULL;

   DWORD rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\secmgr",
                            0, KEY_READ | KEY_WRITE,
                            &hKey);
   if (ERROR_SUCCESS == rc) {
      bSuccess = TRUE;
      DeleteLocationFromReg2(hKey,KeyStr);
   }

   //
   // Bug 375324: Delete from both system & local keys if possible
   //
   rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\secmgr",
                      0, KEY_READ | KEY_WRITE,
                      &hKey);
   if (ERROR_SUCCESS == rc) {
      DeleteLocationFromReg2(hKey,KeyStr);
   }

   //
   // If we succeeded the first key then we don't care what happened
   // for the second (it'll probably fail since the key didn't exist
   // there anyway)
   //
   if (bSuccess) {
      return ERROR_SUCCESS;
   } else {
      return rc;
   }
}


//+--------------------------------------------------------------------------
//
//  Method:     CloseAnalysisPane
//
//  Synopsis:   Close up the Analysis Pane and free any memory for folders that
//              we aren't using any longer.
//
//  History:   a-mthoge 06-09-1998 - _NT4BACK_PORT item to reinsert the scope
//                             item back into the tree.
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::CloseAnalysisPane() {
   SCOPEDATAITEM item;

   if (m_AnalFolder && m_AnalFolder->IsEnumerated()) {
      DeleteChildrenUnderNode(m_AnalFolder);
      m_AnalFolder->Set(FALSE);


      if (m_AnalFolder->GetScopeItem()) {
         //
         // Mark item as unexpanded so we can re expand it later
         //
         ZeroMemory (&item, sizeof (item));
         item.mask = SDI_STATE;
         item.nState = 0;
         item.ID = m_AnalFolder->GetScopeItem()->ID;

         (void)m_pScope->SetItem (&item);
     }

   }
}



//+--------------------------------------------------------------------------
//
//  Method:     LockAnalysisPane
//
//  Synopsis:   Lock the Analysis Pane so that it closes and won't reopen
//
//  Arguments:  [bLock] - [in] TRUE to lock the pane, FALSE to unlock it
//
//  Returns:    TRUE if the pane ends up locked, FALSE if it ends up unlocked
//
//  History:   a-mthoge 06-09-1998 - Added _NT4BACKPORT and SelectScopeItem
//                             berfore enumeration.
//
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg) {
   TryEnterCriticalSection(&csAnalysisPane);
   m_bIsLocked = bLock;

   //
   // Close the Analysis Pane whichever way we're going
   // If we're locking then we want to close it to clear out any
   // now-invalid data.
   //
   // If we're unlocking then we want to make sure that the folder
   // is fresh and that MMC doesn't think it's already been expanded,
   // and refuse to expand it anew.
   //
   if (!bLock) {

      if (!m_AnalFolder) {
         goto ExitLockAnalysisPane;
      }

      if (!m_AnalFolder->GetScopeItem() ) {
         goto ExitLockAnalysisPane;
      }

      //
      // If we're unlocking it then enumerate its subfolders
      //
      RefreshSadInfo(fRemoveAnalDlg);
   }

ExitLockAnalysisPane:
   LeaveCriticalSection(&csAnalysisPane);

   return m_bIsLocked;
}

void CComponentDataImpl::RefreshSadInfo(BOOL fRemoveAnalDlg) 
{
   CPerformAnalysis *pPA = 0;

   UnloadSadInfo();

   LoadSadInfo( TRUE );


   //
   // No need to LoadSadInfo() since EnumerateScopePane will do it when it needs it
   //
   if(m_pConsole && m_AnalFolder)
   {
      EnumerateScopePane( (MMC_COOKIE)m_AnalFolder, m_AnalFolder->GetScopeItem()->ID );
      m_pConsole->SelectScopeItem(m_AnalFolder->GetScopeItem()->ID);
   }

   //
   // remove cached analysis popup since it has cached filenames
   //
   if (fRemoveAnalDlg) 
   {
       pPA = (CPerformAnalysis *) this->GetPopupDialog(IDM_ANALYZE);
       if (pPA != NULL) 
       {
          this->RemovePopupDialog(IDM_ANALYZE);
          delete(pPA);
       }
   }
}

void
CComponentDataImpl::UnloadSadInfo() {

   if (SadHandle) {

      if ( SadTransStarted ) {

         EngineRollbackTransaction();
         SadTransStarted = FALSE;

      }
      EngineCloseProfile(&SadHandle);
      //      SadName.Empty();
      SadDescription.Empty();
      SadAnalyzeStamp.Empty();
      SadConfigStamp.Empty();

      CloseAnalysisPane();
   }

   //
   // Dump our cached templates so they get reloaded with the
   // new Sad information when it is available
   //
   DeleteTemplate(GT_COMPUTER_TEMPLATE);
   DeleteTemplate(GT_LAST_INSPECTION);

   SadLoaded = FALSE;
   SadErrored = SCESTATUS_SUCCESS;
   SadTransStarted = FALSE;
   SadHandle = 0;
}

void CComponentDataImpl::LoadSadInfo(BOOL bRequireAnalysis)
{
   DWORD rc;

   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

   CWaitCursor wc;

   if (SadHandle) {
      return;
   }
   if (m_bIsLocked) {
      return;
   }

   //
   // get name again
   //
   LPWSTR FileName=NULL;
   LPWSTR FileDesc=NULL;
   LPWSTR FileStamp1=NULL;
   LPWSTR FileStamp2=NULL;
   DWORD RegType;

   if ( SadName.IsEmpty() && bRequireAnalysis) {

      //
      // SadName is required if Analysis is required, but not otherwise
      // as the engine will find the system database on its own if passed
      // a NULL file name
      //
      return;
   }

      SadErrored = EngineOpenProfile( (SadName.IsEmpty() ? NULL : (LPCTSTR)SadName),
                                      bRequireAnalysis ? OPEN_PROFILE_ANALYSIS : OPEN_PROFILE_LOCALPOL,
                                      &SadHandle );
     if (SadErrored == SCESTATUS_SUCCESS ) {

        EngineGetDescription( SadHandle, &FileDesc);
        if ( FileDesc ) {
        SadDescription = FileDesc;
          LocalFree(FileDesc);
        }

        SadLoaded = TRUE;
        SadTransStarted = TRUE;
        return;
      }

   if (FileName) {
     LocalFree(FileName);
   }
   SadTransStarted = FALSE;

   //
   // Bug #197052 - Should automatically analyze if no anal info is available
   //
   return;
}


//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   Callback procedure for File & Folder adding SHBrowseForFolder
//              to set the title bar appropriately
//
//  Arguments:  [hwnd]   - the hwnd of the browse dialog
//              [uMsg]   - the message from the dialog
//              [lParam] - message dependant
//              [pData]  - message dependant
//
//  Returns:    0
//
//---------------------------------------------------------------------------
int
BrowseCallbackProc(HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   switch(uMsg) {
      case BFFM_INITIALIZED: {
         CString strTitle;
         strTitle.LoadString(IDS_FILEFOLDER_BROWSE_TITLE);
         SetWindowText(hwnd,strTitle);
         break;
      }
      case BFFM_VALIDATEFAILED :{
         if( pData )
         {
            *(CString*)pData = (LPWSTR)(lParam);
            CString ptempstr = (LPWSTR)(lParam); //Raid #374069, 4/23/2001
            //Raid #684714, avoid incorrect path name, 8/26/2002
            if( -1 != ptempstr.Find(L"\\\\") )
            {
               CString err;
               err.FormatMessage(IDS_INVALID_FOLDER, ptempstr);
               AppMessageBox(NULL, err, NULL, MB_OK|MB_ICONSTOP);
               return 1;
            }
            if( ptempstr.ReverseFind(L':') != ptempstr.Find(L':') )
            {
               CString err;
               err.FormatMessage(IDS_INVALID_FOLDER, ptempstr);
               AppMessageBox(NULL, err, NULL, MB_OK|MB_ICONSTOP);
               return 1;
            }
            ptempstr.MakeLower(); //Raid #500184, yanggao, 11/29/2001
            CString pComp;
            pComp.LoadString(IDS_COMPUTER_FOLDER);
            if( 0 == ptempstr.CompareNoCase(pComp) )
            {
                CString err;
                err.FormatMessage(IDS_INVALID_FOLDER, pComp);
                AppMessageBox(NULL, err, NULL, MB_OK|MB_ICONSTOP);
                return 1;
            }
         }
         break;   
      }
      case BFFM_SELCHANGED: { //Raid #478763, yanggao
         if( lParam )
         {
            CString strPath;
            if( FALSE == SHGetPathFromIDList((LPCITEMIDLIST)lParam,strPath.GetBuffer(MAX_PATH)) )
            {
               ::SendMessage(hwnd, BFFM_ENABLEOK, 1, 0);
            }
         }
         break;
      }
      default:
         break;
   }
   return 0;
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
   // Note - snap-ins need to look at the data object and determine
   // in what context the command is being called.

   // Handle each of the commands.

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

   if (pInternal == NULL) {
      // Actually looking for our extension
      return S_OK;
   }


   MMC_COOKIE cookie = pInternal->m_cookie;
   CFolder* pFolder;

   if ( cookie) {
       pFolder = (CFolder*)cookie;
/*
       if( m_pConsole && nCommandID != IDM_OBJECT_SECURITY) {
          m_pConsole->SelectScopeItem(pFolder->GetScopeItem()->ID);
       }
*/
   } else {
       pFolder = FindObject(cookie, NULL);
       if ( pFolder == NULL ) {
           return S_OK;
       }
   }

   FREE_INTERNAL(pInternal);

   LPWSTR Name=NULL, Desc=NULL;

   //
   // initialize SadName, SadDescription, and SadDateTime
   //
   if ( !SadHandle && (nCommandID == IDM_SUMMARY ||
                       nCommandID == IDM_ANALYZE ||
                       nCommandID == IDM_APPLY ||
                       nCommandID == IDM_ASSIGN ||
                       nCommandID == IDM_GENERATE ||
                       IDM_IMPORT_LOCAL_POLICY == nCommandID) ) { //Raid #581438, #535198, yanggao
      if (pFolder->GetModeBits() & MB_LOCAL_POLICY) {
         LoadSadInfo(FALSE);
      } else {
         LoadSadInfo(TRUE);
      }
   }

   //
   // more variable definitions used inside case statements
   //
   PVOID pDlg;
   CString ResString, AreaString;
   CPropertySheet sheet;

   CString tmpstr;
   MMC_COOKIE FindCookie;
   struct _wfinddata_t findData;
   LONG    hFile;
   WCHAR   pBuf[MAX_PATH];
   HRESULT hr;
   HSCOPEITEM pItemChild;
   //   AREA_INFORMATION Area;

   switch (nCommandID) {
   case MMC_VERB_OPEN:
      break;

   case MMC_VERB_COPY:
   case  MMC_VERB_PASTE:
      break;

   case IDM_VIEW_LOGFILE:
      if (m_dwFlags & flag_showLogFile) {
         m_dwFlags &= ~flag_showLogFile;
      } else {
         m_dwFlags |= flag_showLogFile;
      }
      //
      // Force a repaint.
      //
      if( pFolder->GetScopeItem()->ID != NULL ) //Raid #668777, yanggao, 8/9/2002
         m_pConsole->SelectScopeItem( pFolder->GetScopeItem()->ID );
      break;

   case IDM_OPEN_SYSTEM_DB: {
      CString szSysDB;

      hr = GetSystemDatabase(&szSysDB); //Raid bug 261450, Yang Gao, 3/30/2001
      if (SUCCEEDED(hr)) {
         //
         // Don't change anything if nothing changes
         //
         if (SadName != szSysDB) {
            SadName = szSysDB;
            RefreshSadInfo();
         }
      }
      break;
   }

   case IDM_OPEN_PRIVATE_DB:
      hr = OnOpenDataBase();
      break;

   case IDM_NEW_DATABASE:
      hr = OnNewDatabase();
      break;

   case IDM_IMPORT_POLICY:
      hr = OnImportPolicy(pDataObject);
      break;

   case IDM_IMPORT_LOCAL_POLICY:
      hr = OnImportLocalPolicy(pDataObject);
      break;

   case IDM_EXPORT_LOCALPOLICY:
      hr = OnExportPolicy(FALSE);
      break;

   case IDM_EXPORT_EFFECTIVE:
      hr = OnExportPolicy(TRUE);
      break;

   case IDM_ANALYZE: {
      PEDITTEMPLATE pet;

      //
      // If the computer template has been changed then save it before we
      // can apply it so we don't lose any changes
      //
      pet = GetTemplate(GT_COMPUTER_TEMPLATE);
      if (pet && pet->IsDirty()) {
         pet->Save();
      }

      hr = OnAnalyze();

      break;
   }

   case IDM_DESCRIBE_PROFILE:
      m_pUIThread->PostThreadMessage(SCEM_DESCRIBE_PROFILE,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_DESCRIBE_LOCATION:
      m_pUIThread->PostThreadMessage(SCEM_DESCRIBE_LOCATION,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_NEW:
      m_pUIThread->PostThreadMessage(SCEM_NEW_CONFIGURATION,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_ADD_LOC: 
      {
         // add a location
         BROWSEINFO bi;
         LPMALLOC pMalloc = NULL;
         LPITEMIDLIST pidlLocation = NULL;
         CString strLocation;
         CString strTitle;
         BOOL bGotLocation = FALSE;
         HKEY hLocKey = NULL;
         HKEY hKey = NULL;
         DWORD dwDisp = 0;

         strTitle.LoadString(IDS_ADDLOCATION_TITLE);
         ZeroMemory(&bi,sizeof(bi));
         bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
         bi.lpszTitle = strTitle;
         bi.hwndOwner = m_hwndParent;
         pidlLocation = SHBrowseForFolder(&bi); //Is it safe?
         if (pidlLocation) 
         {
            bGotLocation = SHGetPathFromIDList(pidlLocation,strLocation.GetBuffer(MAX_PATH));
            strLocation.ReleaseBuffer();

            if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
            {
               pMalloc->Free(pidlLocation);
               pMalloc->Release();
            }

            if (bGotLocation) 
            {
               //If a drive such as D: is selected, path comes as D:\
               //Remove trailing backslash
               if( strLocation[ strLocation.GetLength() -1 ] == '\\' )
                  strLocation.SetAt(strLocation.GetLength() - 1, 0 );




               AddTemplateLocation(pFolder,  // the parent folder
                                   strLocation, // the location name
                                   FALSE, // strLocationKey is a file name ?
                                   FALSE  // refresh this location if it already exists ?
                                  );
            } 
            else
               AfxMessageBox(IDS_ADD_LOC_FAILED);
         }
         break;
      }

   case IDM_ADD_FOLDER: 
      {
         BROWSEINFO bi;
         LPMALLOC pMalloc = NULL;
         LPITEMIDLIST pidlRoot = NULL;
         LPITEMIDLIST pidlLocation = NULL;
         CString strCallBack;
         CString strPath;
         LPTSTR szPath = NULL;
         CString strDescription;
         CString strTitle;
         CString strLocationKey;
         bool fDuplicate = false;

         ULONG strleng = MAX_PATH;
         
         if( SHGetSpecialFolderLocation(m_hwndParent,CSIDL_DRIVES,&pidlRoot) != NOERROR ) //Raid #prefast
         {
            pidlRoot = NULL;
         }

         ZeroMemory(&bi,sizeof(bi));
         strTitle.LoadString(IDS_ADDFILESANDFOLDERS_TITLE);
         bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_BROWSEINCLUDEFILES | BIF_USENEWUI
                    | BIF_EDITBOX|BIF_VALIDATE |BIF_NEWDIALOGSTYLE;
         bi.lpfn = BrowseCallbackProc;

         bi.hwndOwner = m_hwndParent;
         bi.lpszTitle = strTitle;
         bi.pidlRoot = pidlRoot;
         bi.lParam = (LPARAM)&strCallBack;
         unsigned int i;

         pidlLocation = SHBrowseForFolder(&bi); //Is it safe?

         if( pidlLocation )
         {
            //Raid #374069, 6/13/2001, Yanggao
            if( FALSE == SHGetPathFromIDList(pidlLocation,strPath.GetBuffer(MAX_PATH)) )
            {
                strPath.ReleaseBuffer();
                strPath = strCallBack;
            }
            else
            {
                strPath.ReleaseBuffer();
                if(!strCallBack.IsEmpty()) //Raid #374069, 4/23/2001
                {
                    strCallBack.TrimLeft(); //Raid #523644, 2/25/2002, yanggao
                    strCallBack.TrimRight();
                    if( -1 != strCallBack.Find(L':') )
                    {
                        strPath = strCallBack;
                    }
                    else
                    {
                        if( L'\\' == strPath.GetAt(strPath.GetLength()-1) )
                        {
                            if( L'\\' == strCallBack.GetAt(0) )
                            {
                                strCallBack.Delete(0, 1);
                            }    
                        }
                        else
                        {
                            if( L'\\' != strCallBack.GetAt(0) )
                            {
                                strPath = strPath + L"\\";
                            }
                        }
                        strPath = strPath + strCallBack;
                        strCallBack.Empty();
                    }
                }
            }
         }
         else
         {
            strPath.Empty(); //Raid #684714, "pidlLocation = NULL" means that user presses cancel.
            strCallBack.Empty();
         }

         szPath = UnexpandEnvironmentVariables(strPath);
         if (szPath) {
            strPath = szPath;

            LocalFree(szPath);
            szPath = NULL;
         }

         if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
            pMalloc->Free(pidlLocation);
            pMalloc->Free(pidlRoot);
            pMalloc->Release();
         }

         if (!strPath) {
            break;
         }

         PEDITTEMPLATE pet;
         PSCE_OBJECT_ARRAY poa;

         pet = GetTemplate(pFolder->GetInfFile());

         //
         // Need to grow the template's PSCE_OBJECT_ARRAY and add the new file entry
         //
         if ( !pet || !pet->pTemplate ) {
            break;
         }

         poa = pet->pTemplate->pFiles.pAllNodes;

         if ( !poa ) {
            poa = (PSCE_OBJECT_ARRAY)LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY));
            if ( poa ) {
               poa->Count = 0;
               poa->pObjectArray = NULL;
            } else {
               break;
            }

            pet->pTemplate->pFiles.pAllNodes = poa;
         }

         //
         // Make sure this file isn't already in the list:
         //
         fDuplicate = false;
         for (i=0;i < poa->Count;i++) {
            if (lstrcmpi(poa->pObjectArray[i]->Name,strPath) == 0) {
               fDuplicate = true;
               break;
            }
         }
         if (fDuplicate) {
            break;
         }

         PSECURITY_DESCRIPTOR pSelSD;
         SECURITY_INFORMATION SelSeInfo;
         BYTE ConfigStatus;

         pSelSD=NULL;
         SelSeInfo=0;
         INT_PTR nRet;

         if( GetAddObjectSecurity(
                      m_hwndParent,
                      strPath,
                      TRUE,
                      SE_FILE_OBJECT,
                      pSelSD,
                      SelSeInfo,
                      ConfigStatus
              ) != S_OK ){
                 break;
         }

        if ( pSelSD && SelSeInfo ) {

           poa->Count++;

           PSCE_OBJECT_SECURITY *pCopy;

           pCopy = (PSCE_OBJECT_SECURITY *)LocalAlloc(LPTR,poa->Count*sizeof(PSCE_OBJECT_SECURITY));
           if (!pCopy) {
              poa->Count--;
              ErrorHandler();
              LocalFree(pSelSD);
              pSelSD = NULL;
              break;
           }

           for (i=0;i<(poa->Count -1);i++) {
              pCopy[i] = poa->pObjectArray[i];
           }
           if ( poa->pObjectArray ) {
              LocalFree(poa->pObjectArray);
           }
           poa->pObjectArray = pCopy;
           poa->pObjectArray[poa->Count-1] = (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
           if (poa->pObjectArray[poa->Count-1]) {
              poa->pObjectArray[poa->Count-1]->Name = (PWSTR) LocalAlloc(LPTR,(strPath.GetLength()+1)*sizeof(TCHAR));
              if (poa->pObjectArray[poa->Count-1]->Name) {
                 //This may not be a safe usage. poa->pObjectArray[poa->Count-1]->Name is a PWSTR. Consider fix.
                 lstrcpy(poa->pObjectArray[poa->Count-1]->Name,strPath);
                 poa->pObjectArray[poa->Count-1]->IsContainer = TRUE;
                 poa->pObjectArray[poa->Count-1]->Status = ConfigStatus;

                 poa->pObjectArray[poa->Count-1]->pSecurityDescriptor = pSelSD;
                 pSelSD = NULL;
                 poa->pObjectArray[poa->Count-1]->SeInfo = SelSeInfo;

                 pet->pTemplate->pFiles.pAllNodes = poa;
                 pet->SetDirty(AREA_FILE_SECURITY);


                 ((CFolder *)cookie)->RemoveAllResultItems();
                 m_pConsole->UpdateAllViews(NULL, cookie, UAV_RESULTITEM_UPDATEALL);
              } else {
                 //
                 // Couldn't allocate memory for the object's name,
                 // so remove the object from the count & array
                 //
                 LocalFree(poa->pObjectArray[poa->Count-1]);
                 poa->pObjectArray[poa->Count-1] = 0;
                 poa->Count--;
              }
           } else {
              //
              // Couldn't allocate the new object, so remove it from the count
              //
              poa->Count--;
           }

        }

         if ( pSelSD ) {
            LocalFree(pSelSD);
            pSelSD = NULL;
         }
         if (pet->pTemplate->pFiles.pAllNodes == NULL) {
            LocalFree(poa);
         }

         break;
      }

   case IDM_ADD_GROUPS: {
       PSCE_NAME_LIST pName = NULL;
       CWnd cWnd;

       cWnd.Attach( m_hwndParent );
       CGetUser gu;
       CSCEAddGroup dlg( &cWnd );

       if( (pFolder->GetModeBits() & MB_LOCAL_POLICY) ||
           (pFolder->GetModeBits() & MB_ANALYSIS_VIEWER) ){
             if (gu.Create(m_hwndParent, SCE_SHOW_BUILTIN | SCE_SHOW_ALIASES | SCE_SHOW_LOCALONLY |
                           SCE_SHOW_SCOPE_LOCAL )) {
                 pName = gu.GetUsers();
             }
       } else {
          dlg.m_dwFlags = SCE_SHOW_BUILTIN | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL;
          if (pFolder->GetModeBits() & MB_GROUP_POLICY) {
             //
             // Set the scope flags explicitely because we want to limit the added groups
             // here to ones from our own domain.  If we SetModeBits then CSCEADDGroup
             // will allow restricting groups that don't belong to us.
             //
             // Allow free-text groups to be added if the admin knows that a group will
             // exist on machines within the OU.
             //
             dlg.m_dwFlags |= SCE_SHOW_SCOPE_DOMAIN;
          } else {
             ASSERT(pFolder->GetModeBits() & MB_TEMPLATE_EDITOR); //Bogus assertion.
             //
             // Allow people to pick any group to restrict because we have no idea
             // where this template will be used.  It could conceivably be for a
             // GPO on another domain, etc.
             //
             dlg.m_dwFlags |= SCE_SHOW_SCOPE_ALL;
             // Raid #446849, Yang Gao, 7/30/2001
             // Allow people to input any group/name to restrict because this is a template. 
             if( pFolder->GetModeBits() & MB_TEMPLATE_EDITOR )
             {
                dlg.m_fCheckName = FALSE;
             }
          }
          CThemeContextActivator activator;
          if(dlg.DoModal() == IDOK)
          {
             if(dlg.GetUsers()->Name )
                pName = dlg.GetUsers();
          }
       }
       cWnd.Detach();

       if(pName){
             PSCE_GROUP_MEMBERSHIP pgm,pGroup,pgmBase,pgmProfile;
             PEDITTEMPLATE pTemplate;
             BOOL fDuplicate;
             BOOL fAnalysis = FALSE;

             if (pFolder->GetType() == AREA_GROUPS_ANALYSIS) {
                pTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                if (pTemplate) {
                   pgmBase = pTemplate->pTemplate->pGroupMembership;
                } else {
                   break;
                }
                pTemplate = GetTemplate(GT_LAST_INSPECTION,AREA_GROUP_MEMBERSHIP);
                if (pTemplate) {
                   pgmProfile = pTemplate->pTemplate->pGroupMembership;
                } else {
                   break;
                }
                fAnalysis = TRUE;
             } else {
                pTemplate = GetTemplate(pFolder->GetInfFile());
                if (!pTemplate) {
                   break;
                }
                pgm = pTemplate->pTemplate->pGroupMembership;
                fAnalysis = FALSE;
             }

             BOOL fNewGroup = FALSE;
             CString newGroups = L";";//Raid #474083, yanggao
             CString tempstr;
             while (pName) {
               //
               // Make sure this isn't a duplicate
               //
               if (fAnalysis) {
                  pGroup = pgmProfile;
               } else {
                  pGroup = pgm;
               }

               fDuplicate = false;
               while (pGroup) {
                  if (lstrcmpi(pGroup->GroupName,pName->Name) == 0) { //Raid #446846, Yang Gao, 7/31/2001
                     fDuplicate = true;
                     break;
                  }
                  pGroup = pGroup->Next;
               }

               if (false != fDuplicate) {
                  pName = pName->Next;
                  continue;
               }

               //Raid #474083, yanggao
               //newGroups is used to store all new groups user added. So we can pop up property page
               //for them.
               tempstr = pName->Name;
               newGroups = newGroups + tempstr + L";";
               fNewGroup = TRUE;
               pGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR,sizeof(SCE_GROUP_MEMBERSHIP));

               if ( pGroup ) {

                  pGroup->GroupName = (PWSTR) LocalAlloc(LPTR,(lstrlen(pName->Name)+1)*sizeof(TCHAR));
      
                  if ( pGroup->GroupName ) {
                     //This may not be a safe usage. pGroup->GroupName and pName->Name are both PWSTR. Consider fix.
                     lstrcpy(pGroup->GroupName,pName->Name);
                     pGroup->pMembers=NULL;
                     pGroup->pMemberOf=NULL;

                     if (fAnalysis) {

                        //
                        // First add the group to the LAST_INSPECTION area
                        //
                        pGroup->Next = pgmProfile;
                        pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED;
                        pgmProfile = pGroup;

                        //
                        // Also, add this group to the computer template in case a save is done at this point.
                        //
                        PEDITTEMPLATE pTemp = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                        pGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR,sizeof(SCE_GROUP_MEMBERSHIP));

                        if ( pTemp && pGroup ) {

                            pGroup->GroupName = (PWSTR) LocalAlloc(LPTR,(lstrlen(pName->Name)+1)*sizeof(TCHAR));

                            if ( pGroup->GroupName ) {
                                //This may not be a safe usage. pGroup->GroupName and pName->Name are both PWSTR. Consider fix.
                                lstrcpy(pGroup->GroupName,pName->Name);
                                pGroup->pMembers=NULL;
                                pGroup->pMemberOf=NULL;
                                pGroup->Next = pgmBase;
                                pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED;
                                pTemp->pTemplate->pGroupMembership = pGroup;
                            }
                            else {
                                //
                                // no memory
                                //
                                LocalFree(pGroup);
                                break;
                            }
                        } else {
                            //
                            // no memory
                            //
                            if (pGroup)
                                LocalFree(pGroup);
                            break;

                        }

                     } else {

                        pGroup->Status = 0;
                        pGroup->Next = pgm;
                        pgm = pGroup;
                     }
                  } else {
                     //
                     // no memory
                     //
                     LocalFree(pGroup);
                     break;
                  }
               } else {
                  break;
               }
               pName = pName->Next;

            }

            if( !fNewGroup ) //Raid #446846, Yang Gao, 7/31/2001
            {
               break;
            }

            if (fAnalysis)
            {
               //
               // add to the last inspection list with status
               // not analyzed
               //
               pTemplate->pTemplate->pGroupMembership = pgmProfile;
            }
            else
            {
               pTemplate->pTemplate->pGroupMembership = pgm;
            }

            //
            // Need to SetDirty AFTER making the changes, not before.
            // Otherwise modes which write the changes out immediately
            // won't have a chance at them. (Bug 396549)
            //
            if (pTemplate)
            {
               pTemplate->SetDirty(AREA_GROUP_MEMBERSHIP);
            }

            CString ObjName;
            pFolder->RemoveAllResultItems();
            pFolder->SetViewUpdate(TRUE);
            m_pConsole->UpdateAllViews(NULL, (LONG_PTR)pFolder,UAV_RESULTITEM_UPDATEALL);

            //Raid #258237, Yang Gao, 3/28/2001
            BOOL bGP = ( (GetModeBits() & MB_SINGLE_TEMPLATE_ONLY) == MB_SINGLE_TEMPLATE_ONLY );
            CAttribute* pAttr = NULL;
            CResult* pResult = NULL;
            HANDLE handle;
            POSITION pos = NULL;
            int tempcount = pFolder->GetResultListCount(); 
            pFolder->GetResultItemHandle ( &handle );
            if(!handle)
            {
               break;
            }
            pFolder->GetResultItem (handle, pos, &pResult);
            while(pResult)
            {
               tempstr = pResult->GetAttr(); //Raid #474083, yanggao
               tempstr = L";" + tempstr + L";";
               if( newGroups.Find(tempstr) >= 0 ) //new group
               {
                  if( pResult && (pResult->GetType() == ITEM_PROF_GROUP) )
                  {
                     ObjName = pResult->GetAttr(); 
                     if( bGP )
                        pAttr = new CDomainGroup;
                     else
                        pAttr = new CConfigGroup(0);
               
                     if( pAttr )
                     {
                        pAttr->SetSnapin(pResult->GetSnapin());
                        pAttr->Initialize(pResult);
                        pAttr->SetReadOnly(FALSE);
                        pAttr->SetTitle(pResult->GetAttrPretty());

                        HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);

                        PROPSHEETHEADER psh;
                        HPROPSHEETPAGE hpsp[1];

                        hpsp[0] = hPage;

                        ZeroMemory(&psh,sizeof(psh));

                        psh.dwSize = sizeof(psh);
                        psh.dwFlags = PSH_DEFAULT;
                        psh.nPages = 1;
                        psh.phpage = hpsp;

                        CString str=_T("");
                        str.LoadString(IDS_SECURITY_PROPERTIES);
                        ObjName = ObjName + str;

                        psh.pszCaption = (LPCTSTR)ObjName;

                        psh.hwndParent = pResult->GetSnapin()->GetParentWindow();  

                        int nRet = (int)PropertySheet(&psh);
                     }
                  }
               }
               if(!pos) //Raid #474083, yanggao
               {
                  //Find the last one;
                  break;
               }
               pFolder->GetResultItem(handle, pos, &pResult);
            }
            pFolder->ReleaseResultItemHandle (handle);
       }

       break;
       }
   case IDM_SAVEAS: {
         PEDITTEMPLATE pTemplate;
         CString strDefExt;
         CString strFilters;
         CString strNewfile;
         HWND hwndParent;
         SCESTATUS status;

         PSCE_ERROR_LOG_INFO ErrLog;

         pTemplate = GetTemplate(pFolder->GetInfFile());

         strDefExt.LoadString(IDS_LOGFILE_DEF_EXT);
         strFilters.LoadString(IDS_PROFILE_FILTER);

         m_pConsole->GetMainWindow(&hwndParent);
         // Translate filter into commdlg format (lots of \0)
         LPTSTR szFilter = strFilters.GetBuffer(0); // modify the buffer in place
         LPTSTR pch = szFilter;
         // MFC delimits with '|' not '\0'
         while ((pch = _tcschr(pch, '|')) != NULL)
            *pch++ = '\0';
          // do not call ReleaseBuffer() since the string contains '\0' characters

         strNewfile = pFolder->GetInfFile();

         OPENFILENAME ofn;
         ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
         ofn.lStructSize = sizeof(OPENFILENAME);
         ofn.lpstrFilter = szFilter;
         ofn.lpstrFile = strNewfile.GetBuffer(MAX_PATH),
         ofn.nMaxFile = MAX_PATH;
         ofn.lpstrDefExt = strDefExt,
         ofn.hwndOwner = m_hwndParent;
         ofn.Flags = OFN_HIDEREADONLY |
                     OFN_OVERWRITEPROMPT |
                     OFN_DONTADDTORECENT|
                     OFN_NOREADONLYRETURN |
                     OFN_PATHMUSTEXIST |
                     OFN_EXPLORER;

         if (GetSaveFileName(&ofn)) {
            strNewfile.ReleaseBuffer();

         //
         // No need to check if this is the same file or not since the
         // CEditTemplate::Save will handle that
         //
         if (!pTemplate->Save(strNewfile)) {
            MyFormatMessage(
                           SCESTATUS_ACCESS_DENIED,
                           0,
                           NULL,
                           strFilters
                           );

            strFilters += strNewfile;
            strNewfile.LoadString(IDS_SAVE_FAILED);
            ::MessageBox( hwndParent, strFilters, strNewfile, MB_OK );
         } 
         else 
         {
               //
               // At this point the new template has succesfully been written, so refresh
               // the template that was "save as'd" back to its original state.
               //
               if (0 != _wcsicmp(strNewfile, pTemplate->GetInfName())) 
               {
                   DWORD dwErr = pTemplate->RefreshTemplate(0);
                   if ( 0 != dwErr )
                   {
                       CString strErr;
 
                       MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
                       AfxMessageBox(strErr);
                       break;;
                   }
               }

               //
               // find the parent node and refresh locations.
               //
               if ( m_pScope ) 
               {
                  hr = m_pScope->GetParentItem(pFolder->GetScopeItem()->ID,
                                               &pItemChild,
                                               &FindCookie
                                              );

                  if ( SUCCEEDED(hr) ) 
                  {
                     //
                     // do not need to refresh the old location, just refresh the new location (maybe same)
                     //
                     int npos = strNewfile.ReverseFind(L'\\');
                     CString strOldfile = pFolder->GetInfFile();
                     int npos2 = strOldfile.ReverseFind(L'\\');

                     // TODO: check and see if npos should be compared to -1 here
                     if ( npos && (npos != npos2 ||
                                   _wcsnicmp((LPCTSTR)strNewfile,
                                             (LPCTSTR)strOldfile, npos) != 0) ) 
                     {
                        //
                        // a different location is specified
                        // find grand parent (in order to add the location)
                        //
                        HSCOPEITEM GrandParent;
                        MMC_COOKIE GrandCookie;

                        hr = m_pScope->GetParentItem(pItemChild,
                                                     &GrandParent,
                                                     &GrandCookie
                                                    );
                        if ( SUCCEEDED(hr) ) {

                           //
                           // check if a new location is specified,
                           // if it is, add the location to registry and scope pane
                           //
                           AddTemplateLocation((CFolder *)GrandCookie,
                                               strNewfile,
                                               TRUE, // this is a file name
                                               TRUE  // refresh this location if it already exists
                                              );

                        }
                     } else {
                        //
                        // a new template in the same location, refresh it
                        //
                        ReloadLocation((CFolder *)FindCookie);
                     }

                  }
               }
            }
         }
         break;
      }

   case IDM_SAVE: {

         PEDITTEMPLATE pTemplate;
         CString strInf;
         if ( ANALYSIS == pFolder->GetType() ) {
            //
            // analysis
            //
            strInf = GT_COMPUTER_TEMPLATE;
         } else {
            strInf = pFolder->GetInfFile();
         }

         pTemplate = GetTemplate(strInf);
         if (pTemplate && pTemplate->IsDirty()) {

            //               pTemplate->Save(pFolder->GetInfFile());
            pTemplate->Save(strInf);
         }
         break;
      }

   case IDM_ADD_REGISTRY:
   case IDM_ADD_ANAL_KEY: {
         // add a result entry
         CRegistryDialog rd;
         rd.SetConsole(m_pConsole);
         rd.SetComponentData(this);

         if ( IDM_ADD_REGISTRY == nCommandID ) {
            rd.SetProfileInfo(GetTemplate(pFolder->GetInfFile()),
                              pFolder->GetType() );
         } else {
            rd.SetProfileInfo(GetTemplate(GT_COMPUTER_TEMPLATE),
                              pFolder->GetType() );
            rd.SetHandle(SadHandle);
         }

         rd.SetCookie(cookie);
         CThemeContextActivator activator;
         rd.DoModal();

         break;
      }
   case IDM_ADD_ANAL_FILES:
   case IDM_ADD_ANAL_FOLDER:

      if ( IDM_ADD_ANAL_FILES == nCommandID ) {
         hr = AddAnalysisFilesToList(pDataObject, cookie,pFolder->GetType());

      } else if ( IDM_ADD_ANAL_FOLDER == nCommandID ) {
         hr = AddAnalysisFolderToList(pDataObject, cookie,pFolder->GetType());

      }
      if ( SUCCEEDED(hr) ) 
      {
         DeleteChildrenUnderNode(pFolder);
         if ( pFolder->IsEnumerated() ) 
         {
            pFolder->Set(FALSE);
            EnumerateScopePane(cookie,pFolder->GetScopeItem()->ID);
         }
      }

      break;

   case IDM_GENERATE:
         hr = OnSaveConfiguration();
         break;

   case IDM_ASSIGN:
         SCESTATUS sceStatus;
         if( S_OK == OnAssignConfiguration(&sceStatus) ) //Raid 668551, yanggao, 8/26/2002
         {
            RefreshSadInfo();
         }
         break;

   case IDM_SECURE_WIZARD: 
         hr = OnSecureWizard();
         break;

   case IDM_APPLY: 
      {
         //
         // If the computer template has been changed then save it before we
         // can apply it so we don't lose any changes
         //
         PEDITTEMPLATE pet = GetTemplate(GT_COMPUTER_TEMPLATE);
         if (pet && pet->IsDirty()) {
            pet->Save();
         }

         m_pUIThread->PostThreadMessage(SCEM_APPLY_PROFILE,(WPARAM)(LPCTSTR)SadName,(LPARAM)this);
         break;
      }
  case IDM_REMOVE:
      //
      // delete the location from registry
      //
      DeleteLocationFromReg(pFolder->GetName());
      // pFolder is not deleted after DeleteChildrenUnderNode
      DeleteChildrenUnderNode( pFolder );
      // set focus to the parent, then delete this node

      DeleteThisNode(pFolder);


      break;

   case IDM_DELETE: {
      tmpstr.LoadString(IDS_CONFIRM_DELETE_TEMPLATE);

      if ( IDNO == AfxMessageBox(tmpstr,MB_YESNO, 0) ) {
         return FALSE;
      }
      /*
          SHFILEOPSTRUCT sfo;
          TCHAR *szFile;

          // delete the file
          ZeroMemory(&sfo,sizeof(sfo));
          sfo.wFunc = FO_DELETE;
          sfo.fFlags = FOF_ALLOWUNDO;
          // Must be double NUL terminated;
          szFile = new TCHAR [ lstrlen(pFolder->GetName()) + 2 ];
          lstrcpy(szFile,pFolder->GetName());
          sfo.pFrom = szFile;
   */
      DeleteFile(pFolder->GetName());

      // SHFileOperation returns 0 on success
      //      if (!SHFileOperation(&sfo)) {
      // pFolder is not deleted after DeleteChildrenUnderNode
      DeleteChildrenUnderNode( pFolder );
      // set focus to the parent, then delete this node

      DeleteThisNode(pFolder);
      //      }

      //       delete[] szFile;
      break;
      }
   case IDM_RELOAD:
      if(pFolder->GetType() == LOCALPOL){
         //
         // Reload local policy.
         //
         UnloadSadInfo();

         DeleteTemplate( GT_LOCAL_POLICY );
         DeleteTemplate( GT_EFFECTIVE_POLICY );
         LoadSadInfo( FALSE );

         RefreshAllFolders();
      } else if (pFolder->GetType() == PROFILE) {
         //
         // bug 380290 - do the right thing when refreshing profiles
         //
         CEditTemplate *pet;
         int bSave;
         CString strSavep;
         pet = GetTemplate(pFolder->GetInfFile());
         if (pet->IsDirty()) {
            AfxFormatString1( strSavep, IDS_SAVE_P, pet->GetFriendlyName());
            bSave = AfxMessageBox(strSavep,MB_YESNOCANCEL|MB_ICONQUESTION);
            if (IDYES == bSave) {
               pet->Save();
            } else if (IDCANCEL == bSave) {
               break;
            }
         }
         
         DWORD dwErr = pet->RefreshTemplate(AREA_ALL);
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            break;
         }
         RefreshAllFolders();
      } else if (pFolder->GetType() == LOCATIONS) {
         //
         // Refresh location.
         //
         hr = ReloadLocation(pFolder);
      } else {
         //
         // Should never get here
         //
      }
      break;

   case IDM_COPY: {
      if (!SUCCEEDED(OnCopyArea(pFolder->GetInfFile(),pFolder->GetType()))) {
         AfxMessageBox(IDS_COPY_FAILED);
      }
      break;
   }

   case IDM_CUT:
      break;

   case IDM_PASTE:
      OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());

      //
      // after information is pasted, update all views related to the cookie
      //
      if ( m_pConsole ) {
         pFolder->RemoveAllResultItems();
         m_pConsole->UpdateAllViews(NULL , (LPARAM)pFolder, UAV_RESULTITEM_UPDATEALL);
      }

      break;

   default:
      ASSERT(FALSE); // Unknown command!
      break;
   }

   return S_OK;
}


//+------------------------------------------------------------------------------------------
// CComponentDataImpl::RefreshAllFolders
//
// Updates all folders that are enumerated and have result items.
//
// Returns: The number of folders updated, or -1 if there is an error.
//
//-------------------------------------------------------------------------------------------
int
CComponentDataImpl::RefreshAllFolders()
{
   if( !m_pScope ){
      return -1;
   }

   int icnt = 0;
   POSITION pos = m_scopeItemList.GetHeadPosition();
   while(pos){
      CFolder *pFolder = m_scopeItemList.GetNext(pos);
      if(pFolder && pFolder->GetResultListCount() ){
         pFolder->RemoveAllResultItems();
         m_pConsole->UpdateAllViews(NULL, (LPARAM)pFolder, UAV_RESULTITEM_UPDATEALL);
         icnt++;
      }
   }
   return icnt;
}

///////////////////////////////////////////////////////////////////////////
//  Method:     AddTemplateLocation
//
//  Synopsis:   Add a template location if it does not exist
//              and if requested, refresh the location if it exists.
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [NameStr]   - The display name of the new node
//              [theCookie] - the folder's cookie if it already exists, or NULL
//
//  Returns:    TRUE = the folder already exists
//              FALSE = the folder does not exist
//
////////////////////////////////////////////////////////////////////
BOOL
CComponentDataImpl::AddTemplateLocation(CFolder *pParent,
                                        CString szName,
                                        BOOL bIsFileName,
                                        BOOL bRefresh
                                       )
{

   int npos;

   if ( bIsFileName ) {
      npos = szName.ReverseFind(L'\\');

   } else {
      npos = szName.GetLength();
   }

   CString strTmp = szName.Left(npos);
   LPTSTR sz = strTmp.GetBuffer(MAX_PATH);

   //
   // Can't put '\' in the registry, so convert to '/'
   //
   while (sz = wcschr(sz,L'\\')) {
      *sz = L'/';
   }
   strTmp.ReleaseBuffer();

   CString strLocationKey;
   strLocationKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);

   BOOL bRet = FALSE;
   HKEY hLocKey = NULL;
   HKEY hKey = NULL;
   DWORD dwDisp = 0;
   DWORD rc = E_FAIL;

   //
   // Bug 119208: Store in HKCU rather than in HKLM
   //
   rc = RegCreateKeyEx(
                       HKEY_CURRENT_USER,
                       strLocationKey,
                       0,
                       L"",
                       0,
                       KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY  ,
                       NULL,
                       &hLocKey,
                       &dwDisp);

   if (ERROR_SUCCESS == rc) {
      if (ERROR_SUCCESS == RegCreateKeyEx(
                                         hLocKey,
                                         strTmp,
                                         0,
                                         L"",
                                         0,
                                         KEY_WRITE | KEY_CREATE_SUB_KEY,
                                         NULL,
                                         &hKey,
                                         &dwDisp)) {
         bRet = TRUE;
         RegCloseKey(hKey);
      }

      RegCloseKey(hLocKey);
   }

   if ( bRet ) {
      //
      // key is added to registry, create the node in scope pane
      //
      MMC_COOKIE FindCookie;

      CFolder *pNewParent;

      if (!pParent) {
         pNewParent = m_ConfigFolder;
      } else {
         pNewParent = pParent;
      }


      if (!IsNameInChildrenScopes(pNewParent, //pParent,
                                  szName.Left(npos),
                                  &FindCookie)) {
         CreateAndAddOneNode(pNewParent, //pParent,
                             (LPTSTR((LPCTSTR)(szName.Left(npos)))),
                             NULL,
                             LOCATIONS,
                             TRUE);
      }

      if ( FindCookie && bRefresh ) {

         ReloadLocation((CFolder *)FindCookie);

      }

   }

   return bRet;
}


///////////////////////////////////////////////////////////////////////////
//  Method:     IsNameInChildrenScopes
//
//  Synopsis:   detects if a node already exists under the subtree of this node.
//              The existence is determined by the folder name string comparison.
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [NameStr]   - The display name of the new node
//              [theCookie] - the folder's cookie if it already exists, or NULL
//
//  Returns:    TRUE = the folder already exists
//              FALSE = the folder does not exist
//
////////////////////////////////////////////////////////////////////
BOOL
CComponentDataImpl::IsNameInChildrenScopes(CFolder* pParent,
                                           LPCTSTR NameStr,
                                           MMC_COOKIE *theCookie)
{
   HSCOPEITEM        pItemChild=NULL;
   MMC_COOKIE        lCookie=NULL;
   CFolder*          pFolder = 0;
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   psdi = 0;
   HSCOPEITEM        hid = 0;

   if (pParent) 
   {
      psdi = pParent->GetScopeItem();
      if (psdi)
         hid = psdi->ID;
   }
   hr = m_pScope->GetChildItem(hid, &pItemChild, &lCookie);
   // find a child item
   while ( SUCCEEDED(hr) && pItemChild) //Raid 601259, yanggao, 04/15/2002.
   {
      pFolder = (CFolder*)lCookie;
      if ( pFolder ) 
      {
         if ( _wcsicmp(pFolder->GetName(), NameStr) == 0 ) 
         {
            if ( theCookie )
               *theCookie = lCookie;
            return TRUE;
         }
      }
      hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);
   }

   if ( theCookie )
      *theCookie = NULL;

   return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAndAddOneNode
//
//  Synopsis:   Creates and adds a folder to the scope pane
//
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [Name]      - The display name of the new node
//              [Desc]      - The description of the new node
//              [type]      - The folder type of the new node
//              [bChildren] - True if there are children folders under the new node
//              [szInfFile] - The name of the Inf file associated with the new node
//              [pData]     - A pointer to extra data
//
//  Returns:    The CFolder created if successful, NULL otherwise
//
//  History:
//
//---------------------------------------------------------------------------
CFolder*
CComponentDataImpl::CreateAndAddOneNode(CFolder* pParent,
                                        LPCTSTR Name,
                                        LPCTSTR Desc,
                                        FOLDER_TYPES type,
                                        BOOL bChildren,
                                        LPCTSTR szInfFile,
                                        LPVOID pData,
                                        DWORD status)
{
   DWORD dwMode;
   HRESULT hr;

   //
   // The new node inherits its parent's SCE mode
   //
   if (pParent) {
      dwMode = pParent->GetMode();
   } else {
      return NULL;
   }

   CFolder* folder = new CFolder();
   if (!folder) {
      return NULL;
   }

   //
   // Create the folder objects with static data
   //

   //
   // Find the icon index for the folder type
   //
   int nImage = GetScopeImageIndex(type, status);

   hr = folder->Create( Name,
                        Desc,
                        szInfFile,
                        nImage,
                        nImage,
                        type,
                        bChildren,
                        dwMode,
                        pData);
   if (FAILED(hr)) {
      delete folder;
      return NULL;
   }

   m_scopeItemList.AddTail(folder);

   HSCOPEITEM hItem = NULL;
   LONG_PTR pCookie;
   CString strThis, strNext;

   switch(type){
   case AREA_REGISTRY_ANALYSIS:
   case AREA_FILESTORE_ANALYSIS:
   case REG_OBJECTS:
   case FILE_OBJECTS:
      //
      // Insert items in alpha order.
      //
       if( m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &hItem, &pCookie) == S_OK && pCookie){

           folder->GetScopeItem()->lParam = (LPARAM)folder;
           folder->GetDisplayName( strThis, 0);
           folder->GetScopeItem()->mask &= ~(SDI_PARENT | SDI_PREVIOUS);

           while(hItem){
               reinterpret_cast<CFolder *>(pCookie)->GetDisplayName(strNext, 0);
               int i = lstrcmpi( strThis, strNext );
               if( i < 0  ){
                   folder->GetScopeItem()->relativeID = hItem;
                   folder->GetScopeItem()->mask |= SDI_NEXT;
                   break;
               }
               if( m_pScope->GetNextItem(hItem, &hItem, &pCookie) != S_OK){
                   hItem = NULL;
               }

           }

       }
       break;
   }
   if(hItem == NULL){
       folder->GetScopeItem()->mask &= ~(SDI_PREVIOUS | SDI_NEXT);
       folder->GetScopeItem()->mask |= SDI_PARENT;
       folder->GetScopeItem()->relativeID = pParent->GetScopeItem()->ID;
   }

   //
   // Set the folder as the cookie
   //
   folder->GetScopeItem()->displayname = MMC_CALLBACK;
   folder->GetScopeItem()->mask |= SDI_PARAM;
   folder->GetScopeItem()->lParam = reinterpret_cast<LPARAM>(folder);
   folder->SetCookie(reinterpret_cast<MMC_COOKIE>(folder));
   m_pScope->InsertItem(folder->GetScopeItem());

   folder->GetScopeItem()->relativeID = pParent->GetScopeItem()->ID;
   //
   // Note - On return, the ID member of 'GetScopeItem()'
   // contains the handle to the newly inserted item!
   //
   ASSERT(folder->GetScopeItem()->ID != NULL); //Bogus assertion.
   return folder;

}

void CComponentDataImpl::DeleteChildrenUnderNode(CFolder* pParent)
{
   HSCOPEITEM pItemChild=NULL;
   MMC_COOKIE lCookie=NULL;
   CFolder*   pFolder=NULL;


   pItemChild = NULL;
   HRESULT hr = E_FAIL;

   if (pParent && pParent->GetScopeItem()) {
      hr = m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &pItemChild, &lCookie);
   }
   // find a child item
   while ( pItemChild ) {
      pFolder = (CFolder*)lCookie;

      if ( pFolder )
         DeleteChildrenUnderNode(pFolder); // delete children first

      // get next pointer
      hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);

      // delete this node
      if ( pFolder)
         DeleteThisNode(pFolder);
   }
}

void CComponentDataImpl::DeleteThisNode(CFolder* pNode)
{
   ASSERT(pNode); //Validate pNode.
   if( !pNode ) //Raid #550912, yanggao.
   {
      return;
   }
   POSITION pos=NULL;

   // delete from the m_scopeItemList
   if ( FindObject((MMC_COOKIE)pNode, &pos) ) {
      if ( pos ) {
         m_scopeItemList.RemoveAt(pos);
      }
   }

   pos = NULL;
   LONG_PTR fullKey;
   CDialog *pDlg = MatchNextPopupDialog(
                        pos,
                        (LONG_PTR)pNode,
                        &fullKey
                        );
   while( pDlg ){
        m_scopeItemPopups.RemoveKey( fullKey );
        pDlg->ShowWindow(SW_HIDE);

        if(m_pUIThread){
            m_pUIThread->PostThreadMessage(
                            SCEM_DESTROY_DIALOG,
                            (WPARAM)pDlg,
                            (LPARAM)this
                            );
        }
        pDlg = NULL;
        if(!pos){
            break;
        }
        pDlg = MatchNextPopupDialog(
                        pos,
                        (LONG_PTR)pNode,
                        &fullKey
                        );

   }

   if (m_pScope && pNode && pNode->GetScopeItem()) {
      HRESULT hr = m_pScope->DeleteItem(pNode->GetScopeItem()->ID, TRUE);
   }

   // delete the node
   delete pNode;

}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//
STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{

   TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);
   return S_FALSE;
}

STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   HRESULT hr=S_FALSE;

   switch (event) {
      case MMCN_BTN_CLICK:
         TCHAR szMessage[MAX_PATH];
         //This is a safe usage.
         wsprintf(szMessage, _T("CommandID %ld"),param);
         AfxMessageBox(szMessage);

         break;

      default:
         ASSERT(FALSE); // Unhandle event
   }


   return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
   if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

   // Make sure both data object are mine
   HRESULT hr = S_FALSE;

   INTERNAL *pA = ExtractInternalFormat(lpDataObjectA);
   INTERNAL *pB = ExtractInternalFormat(lpDataObjectB);

   if (pA != NULL && pB != NULL) //Raid #597158, yanggao, 4/16/2002.
   {
      if( *pA == *pB )
		   hr = S_OK;
      else
      {
         if( pA->m_type == pB->m_type )
         {
            CResult* pAResult = (CResult*)pA->m_cookie;
            CResult* pBResult = (CResult*)pB->m_cookie;
            if( pAResult && pBResult )
            {
               if( _wcsicmp(pAResult->GetAttr(),pBResult->GetAttr()) == 0 &&
                  pAResult->GetType() == pBResult->GetType() )
               {
                  CFolder* pAF = (CFolder*)pAResult->GetCookie();
                  CFolder* pBF = (CFolder*)pBResult->GetCookie();
                  if( pAF && pBF && pAF->GetType()== pBF->GetType() )
                  {
                     PWSTR pAFile = NULL;
                     PWSTR pBFile = NULL;
                     switch( pAF->GetType())
                     {
                     case REG_OBJECTS:
                     case FILE_OBJECTS:
                        pAFile = pAF->GetName();
                        pBFile = pBF->GetName(); 
                        break;
                     default:
                        pAFile = pAF->GetInfFile();
                        pBFile = pBF->GetInfFile();
                        break;
                     }
                     if( pAFile && pBFile && _wcsicmp(pAFile, pBFile) == 0 )
                     {
                        hr = S_OK;
                     }
                  }
               }
            }
         }
      }
   }

   FREE_INTERNAL(pA);
   FREE_INTERNAL(pB);

   return hr;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assum sort is ascending when comparing.

STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
   if (pnResult == NULL) {
      ASSERT(FALSE);
      return E_POINTER;
   }

   // check col range
   int nCol = *pnResult;
   ASSERT(nCol >=0 && nCol< 3);

   *pnResult = 0;
   if ( nCol < 0 || nCol >= 3)
      return S_OK;

   CString strA;
   CString strB;
   RESULTDATAITEM rid;

   CResult* pDataA = reinterpret_cast<CResult*>(cookieA);
   CResult* pDataB = reinterpret_cast<CResult*>(cookieB);


   ASSERT(pDataA != NULL && pDataB != NULL); //Bogus assertion

   ZeroMemory(&rid,sizeof(rid));
   rid.mask = RDI_STR;
   rid.bScopeItem = FALSE;
   rid.nCol = nCol;

   rid.lParam = cookieA;
   GetDisplayInfo(&rid);
   strA = rid.str;
   
   rid.lParam = cookieB;
   GetDisplayInfo(&rid);
   strB = rid.str;

   if (strA.IsEmpty()) {
      *pnResult = strB.IsEmpty() ? 0 : 1;
   } else if (strB.IsEmpty()) {
      *pnResult = -1;
   } else {
      //
      // Compare in a locale dependant manner
      //
      // Subtract 2 from CS to make result equivalent to strcmp
      //
      *pnResult = CompareString(LOCALE_SYSTEM_DEFAULT,
                                NORM_IGNORECASE,
                                (LPCTSTR)strA,-1, (LPCTSTR)strB,-1) -2;
   }

   return S_OK;
}

void CSnapin::HandleStandardVerbs(LPARAM arg, LPDATAOBJECT lpDataObject)
{

   if (lpDataObject == NULL) {
      return;
   }
   INTERNAL* pAllInternal = ExtractInternalFormat(lpDataObject);
   INTERNAL* pInternal = pAllInternal;

   BOOL fMulti = FALSE; //Raid #463483, Yang Gao, 9/5/2001
   if(pAllInternal &&
      pAllInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE ){
      pInternal++;
      fMulti = TRUE;
   }

   BOOL bSelect = HIWORD(arg);
   BOOL bScope = LOWORD(arg);

   if (!bSelect) {
      m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,HIDDEN,TRUE);
      m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE,HIDDEN,TRUE);
      m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN,HIDDEN,TRUE);
      return;
   }

   // You should crack the data object and enable/disable/hide standard
   // commands appropriately.  The standard commands are reset everytime you get
   // called. So you must reset them back.

   // arg == TRUE -> Selection occured in the Scope view
   // arg == FALSE -> Selection occured in the Result view

   // add for delete operations
   if (m_pConsoleVerb && pInternal) {

      m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);

      if (pInternal->m_type == CCT_SCOPE) {
         MMC_COOKIE cookie = pInternal->m_cookie;
         if ( cookie ) {
            CFolder *pFolder = (CFolder*)cookie;
            if (pFolder->GetType() == REG_OBJECTS ||
                pFolder->GetType() == FILE_OBJECTS) {
               m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,ENABLED,TRUE);
               m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            } else {
               m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,HIDDEN,TRUE);
               m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            }
         }

         m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN,ENABLED,TRUE);
      }

      if ( pInternal->m_type == CCT_RESULT ) {


         if ( pInternal->m_cookie != NULL ) {

            RESULT_TYPES type = ((CResult *)pInternal->m_cookie)->GetType();
            if ( type == ITEM_PROF_GROUP ||
                 type == ITEM_PROF_REGSD ||
                 type == ITEM_PROF_FILESD
                 ) {
               m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
            }
            if (type != ITEM_OTHER) {
               if (pInternal->m_cookie != (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE && (!fMulti)) {
                  m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                  m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
               } else {
                  //
                  // Multi select properties not supported (yet)
                  //
                  m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
               }
            }
         }
      } else if ( pInternal->m_type == CCT_SCOPE ) {
         CFolder *pFolder = (CFolder *)pInternal->m_cookie;

         m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
         m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

         if( NONE == pInternal->m_foldertype && bSelect && bScope ) //Raid #257461, 4/19/2001
         {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN,TRUE);
         }
         //
         // for scope nodes, only the location and template are allowed to delete
         //
         if ( pFolder != NULL ) {
            FOLDER_TYPES fType = pFolder->GetType();

            //
            // do not expose 'delete' menu option in single template mode
            //
            if ( LOCATIONS == fType || // PROFILE == fType) {
                 ( fType == PROFILE &&
                   !( pFolder->GetModeBits() & MB_SINGLE_TEMPLATE_ONLY )) ) {

                if(fType == PROFILE && (pFolder->GetState() & CFolder::state_Unknown) ){
                    // We must load the template and find out if it is a valid
                    // configuration template.
                    if(!GetTemplate( pFolder->GetInfFile(), AREA_USER_SETTINGS)){
                        pFolder->SetState( CFolder::state_InvalidTemplate, ~CFolder::state_Unknown );
                    } else {
                        pFolder->SetState( 0, ~CFolder::state_Unknown );
                    }
                }

                if( fType != PROFILE || !(pFolder->GetState() & CFolder::state_InvalidTemplate) ) {
                    if (CAttribute::m_nDialogs == 0) {
                       m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                       m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
                    }
                }
            }
         }
      }
   }

   if (pAllInternal) {
      FREE_INTERNAL(pAllInternal);
   }
}

void CSnapin::AddPropertyPageRef(CResult* pData)
{
    pData->AddRef(); 
    pData->m_strInfFile = GetSelectedFolder()->GetInfFile(); 
    CSnapin::m_PropertyPageList.AddHead(pData);
    return;
}

void CSnapin::ReleasePropertyPage(CResult* pData)
{
    int nCount = (int)CSnapin::m_PropertyPageList.GetCount();
    POSITION newpos = CSnapin::m_PropertyPageList.GetHeadPosition();
    CResult* pResult = NULL;
    POSITION prevpos;

    while( nCount > 0 && newpos )
    {
       prevpos = newpos;
       pResult = CSnapin::m_PropertyPageList.GetNext(newpos);
       if( pResult == pData )
       {
          pData->m_strInfFile.Empty();
          CSnapin::m_PropertyPageList.RemoveAt(prevpos);
          break;
       }
       nCount--;
    }
    pData->Release();
    return;
}

//+--------------------------------------------------------------------------
//
//  Method:     GetTemplate
//
//  Synopsis:   Get the CEditTemplate for the given INF file, checking first
//              in the cache of loaded CEditTemplates or creating a new one
//              if the INF file has not yet been loaded.
//
//  Arguments:  [szInfFile] - The path and name of the INF file to retrieve
//              [aiArea]    - The SCE area that we're interested for the template
//             *[pErr]      - [out] a PDWORD to get error information
//
//  Returns:    A pointer to the CEditTemplate requested, or NULL if it's not
//              available.
//              *[pErr]  - the resource id of an error string, if an error occurs
//
//
//  History:
//
//---------------------------------------------------------------------------
PEDITTEMPLATE
CComponentDataImpl::GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiArea, DWORD *pErr)
{
   PEDITTEMPLATE pTemplateInfo = NULL;
   BOOL bNewTemplate = FALSE;
   PVOID pHandle = NULL;
   SCESTATUS rc=0;
   LPTSTR szKey;

   if (pErr) {
      *pErr = 0;
   }

   ASSERT(szInfFile);
   if (!szInfFile) {
      return NULL;
   }

   //
   // Allocate space for key.
   //
   szKey = new TCHAR[ lstrlen( szInfFile ) + 1];
   if(!szKey){
       return NULL;
   }
   //This is a safe usage.
   lstrcpy(szKey, szInfFile);
   _wcslwr( szKey );


   //
   // Find pTemplateInfo in our cache
   //
   m_Templates.Lookup(szKey, pTemplateInfo);

   //
   // If it's not there then create a new one
   //
   if (!pTemplateInfo) {
      bNewTemplate = TRUE;
      pTemplateInfo = new CEditTemplate;
      if (!pTemplateInfo) {
         if (pErr) {
            *pErr = IDS_ERROR_CANT_OPEN_PROFILE;
         }
         goto done;
      }
      pTemplateInfo->SetInfFile(szInfFile);
      pTemplateInfo->SetNotificationWindow(m_pNotifier);
      pTemplateInfo->pTemplate = NULL;
   }

   if (GetModeBits() & MB_WRITE_THROUGH) {
      pTemplateInfo->SetWriteThrough(TRUE);
   }

   //
   // Check that the pTemplateInfo has the area that we're looking for, otherwise
   // load that area
   //
   if (!pTemplateInfo->CheckArea(aiArea)) {
      //
      // Don't reload the areas we already have since they may be dirty and we'll have a
      // huge memory problem.
      //
      aiArea &= ~(pTemplateInfo->QueryArea());

      if ((lstrcmp(GT_COMPUTER_TEMPLATE,szInfFile) == 0) ||
          (lstrcmp(GT_LAST_INSPECTION,szInfFile) == 0)) {
         //
         // Analysis pane areas from jet database, not INF files
         //
         SCETYPE sceType;

         PSCE_ERROR_LOG_INFO perr = NULL;

         if (lstrcmp(GT_COMPUTER_TEMPLATE,szInfFile) == 0) {
            sceType = SCE_ENGINE_SMP;
         } else {
            sceType = SCE_ENGINE_SAP;
            pTemplateInfo->SetNoSave(TRUE);
         }
         pTemplateInfo->SetFriendlyName( SadName );
         pTemplateInfo->SetProfileHandle(SadHandle);
         pTemplateInfo->SetComponentDataImpl(this);
         rc = SceGetSecurityProfileInfo(SadHandle,                   // hProfile
                                        sceType,                     // Profile type
                                        aiArea,                      // Area
                                        &(pTemplateInfo->pTemplate), // SCE_PROFILE_INFO [out]
                                        &perr);                       // Error List [out]
         if (SCESTATUS_SUCCESS != rc) {
            if (bNewTemplate) {
               delete pTemplateInfo;
            }

            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            pTemplateInfo = NULL;
            goto done;
         }

      } else if ((lstrcmp(GT_LOCAL_POLICY,szInfFile) == 0) ||
          (lstrcmp(GT_EFFECTIVE_POLICY,szInfFile) == 0)) {
         //
         // Local Policy pane areas from jet database, not INF files
         //
         SCETYPE sceType;

         PSCE_ERROR_LOG_INFO perr = NULL;
         PVOID tempSad;

         tempSad = SadHandle;

         if (lstrcmp(GT_LOCAL_POLICY,szInfFile) == 0) {
            sceType = SCE_ENGINE_SYSTEM;
         } else {
            sceType = SCE_ENGINE_GPO;
         }
         pTemplateInfo->SetNoSave(TRUE);
         pTemplateInfo->SetProfileHandle(tempSad);
         pTemplateInfo->SetComponentDataImpl(this);
         rc = SceGetSecurityProfileInfo(tempSad,                   // hProfile
                                        sceType,                     // Profile type
                                        aiArea,                      // Area
                                        &(pTemplateInfo->pTemplate), // SCE_PROFILE_INFO [out]
                                        &perr);                       // Error List [out]

         if (SCESTATUS_SUCCESS != rc) {
            //
            // We don't really need the policy template, though it'd be nice
            // We'll be read-only as a non-admin anyway so they can't edit
            //
            // Likewise in a standalone machine the GPO won't be found so we
            // can just ignore that error as expected
            //

            if (sceType == SCE_ENGINE_GPO) {
               if (SCESTATUS_PROFILE_NOT_FOUND == rc) {
                  //
                  // No GPO, so we're on a standalone.  No need to give warnings
                  //
                  pTemplateInfo->SetTemplateDefaults();
                  rc = SCESTATUS_SUCCESS;
               } else if ((SCESTATUS_ACCESS_DENIED == rc) && pTemplateInfo->pTemplate) {
                  //
                  // We were denied in some sections, but not all.  Play on!
                  //
                  rc = SCESTATUS_SUCCESS;
               } else {
                  CString strMessage;
                  CString strFormat;
                  LPTSTR     lpMsgBuf=NULL;
                  //
                  // Real error of some sort.  Display a messagebox
                  //

                  //
                  // translate SCESTATUS into DWORD
                  //
                  DWORD win32 = SceStatusToDosError(rc);

                  //
                  // get error description of rc
                  //
                  //This is a safe usage. The function is responsible to allocate memery.
                  FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 win32,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                 (LPTSTR)(PVOID)&lpMsgBuf,
                                 0,
                                 NULL
                               );
                  if ( lpMsgBuf != NULL ) {
                     if (IsAdmin()) {
                        strFormat.LoadString(IDS_ADMIN_NO_GPO);
                     } else {
                        strFormat.LoadString(IDS_NON_ADMIN_NO_GPO);
                     }
                     strMessage.Format(strFormat,lpMsgBuf);
                     LocalFree(lpMsgBuf);
                     lpMsgBuf = NULL;
                     AfxMessageBox(strMessage,MB_ICONEXCLAMATION|MB_OK);
                  }
                  //
                  // Ok.  We've notified them of the error, but don't otherwise care
                  // so pretend we got a valid but empty buffer
                  //
                  pTemplateInfo->SetTemplateDefaults();
                  rc = SCESTATUS_SUCCESS;
               }
            }
         }


      } else if (lstrcmp(GT_LOCAL_POLICY_DELTA,szInfFile) == 0) {
         //
         // Local Policy Changes.  Initialize everything to not changed
         //
         SCE_PROFILE_INFO *ppi;
         CString strLocalPol;

         strLocalPol.LoadString(IDS_LOCAL_POLICY_FRIENDLY_NAME);
         pTemplateInfo->SetFriendlyName( strLocalPol );
         pTemplateInfo->SetWriteThrough(TRUE);
         pTemplateInfo->SetProfileHandle(SadHandle);
         pTemplateInfo->SetComponentDataImpl(this);
         if (NULL == pTemplateInfo->pTemplate) {
            pTemplateInfo->pTemplate = (SCE_PROFILE_INFO*)LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
         }

         ppi = pTemplateInfo->pTemplate;
         if (NULL == ppi) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            return NULL;
         }
         ppi->Type = SCE_ENGINE_SCP;

         VerifyKerberosInfo( ppi );
         if (aiArea & AREA_SECURITY_POLICY) {
            pTemplateInfo->SetTemplateDefaults();
         }
         //
         // Further processing depends on rc == SCESTATUS_SUCCESS,
         // even though we didn't actually call the engine here
         //
         rc = SCESTATUS_SUCCESS;

      } else if (lstrcmp(GT_DEFAULT_TEMPLATE,szInfFile) == 0 ||
                 lstrcmp(GT_RSOP_TEMPLATE,szInfFile) == 0) {
         pTemplateInfo->SetComponentDataImpl(this);
         if (pTemplateInfo->RefreshTemplate(AREA_ALL)) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            return NULL;
         }
         rc = SCESTATUS_SUCCESS;
      } else {
         if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_OPEN_PROFILE;
            }
            if (bNewTemplate) {
               delete pTemplateInfo;
            }
            pTemplateInfo = NULL;
            goto done;
         }
         ASSERT(pHandle); //Validate pHandle.
         if( !pHandle ) //Raid #550912, yanggao.
         {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_OPEN_PROFILE;
            }
            if (bNewTemplate) {
               delete pTemplateInfo;
            }
            pTemplateInfo = NULL;
            goto done;
         }
         if ((GetModeBits() & MB_GROUP_POLICY) == MB_GROUP_POLICY) {
            pTemplateInfo->SetPolicy(TRUE);
         }
         //
         // get information from this template
         //
         PSCE_ERROR_LOG_INFO errBuff;

         rc = SceGetSecurityProfileInfo(pHandle,
                                        SCE_ENGINE_SCP,
                                        aiArea,
                                        &(pTemplateInfo->pTemplate),
                                        &errBuff //NULL  // &ErrBuf do not care errors
                                       );

         SceCloseProfile(&pHandle);
         pHandle = NULL;
      }
      /*
            if do not care errors, no need to use this buffer

            if ( ErrBuf ) {
               SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
               ErrBuf = NULL;
            }
      */
      if (rc != SCESTATUS_SUCCESS) {
         if (pErr) {
            *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
         //
         // if we allocated pTemplateInfo then delete it.
         //
         if (bNewTemplate) {
            delete pTemplateInfo;
         }
         pTemplateInfo = NULL;
         goto done;

      }

      //
      // Set the area in the template
      //
      pTemplateInfo->AddArea(aiArea);

      //
      // add this template to the list
      //
      m_Templates.SetAt(szKey, pTemplateInfo);

      if ( aiArea & AREA_SECURITY_POLICY &&
           pTemplateInfo->pTemplate ) {
         //
         // expand registry value section based on registry values list on local machine
         //

         SceRegEnumAllValues(
                            &(pTemplateInfo->pTemplate->RegValueCount),
                            &(pTemplateInfo->pTemplate->aRegValues)
                            );
      }

   }


done:
   if(szKey){
       delete [] szKey;
   }
   return pTemplateInfo;
}

//+--------------------------------------------------------------------------
//
//  Method:     GetTemplate
//
//  Synopsis:   Get the CEditTemplate for the given INF file from the cache
//              maintained in m_pComponentData
//
//  Arguments:  [szInfFile] - The path and name of the INF file to retrieve
//              [aiArea]    - The SCE area that we're interested for the template
//             *[pErr]      - [out] a PDWORD to get error information
//
//  Returns:    A pointer to the CEditTemplate requested, or NULL if it's not
//              available.
//              *[pErr]  - the resource id of an error string, if an error occurs
//
//
//  History:
//
//---------------------------------------------------------------------------
PEDITTEMPLATE
CSnapin::GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiArea,DWORD *pErr) {
   return ((CComponentDataImpl *)m_pComponentData)->GetTemplate(szInfFile,aiArea,pErr);
}

HRESULT
CComponentDataImpl::ReloadLocation(CFolder * pFolder)
{
   PEDITTEMPLATE pTemplate;
   POSITION pos;
   CString strKey;
   HSCOPEITEM pItemChild=NULL;
   MMC_COOKIE lCookie=NULL;
   CFolder    *pChild;
   CString strName,strNotSaved;
   LPTSTR szDesc = 0,szLoc = 0;
   DWORD nLoc = 0;

   HRESULT hr = S_OK;

   if (!m_pScope) 
      return E_FAIL;
   
   // Clear out this node
   DeleteChildrenUnderNode(pFolder);
   // Call EnumerateScopePane to reload it
   // Do we need to worry about saving changed templates?
   //  No: since they're saved by name when the template is opened up it'll pick up the
   //      proper changed template
   //  Yes: what about changed templates where the file no longer exists (or never has,
   //       for new templates?)  These will still show up in the save templates dialog,
   //       but won't be accessable for editing until then.
   //     Maybe loop through the changed templates and if they fall under this location
   //     and don't otherwise have a save file then add a folder for them?

   //
   // Set the folder not to be enumerated
   //
   pFolder->Set(FALSE);

   EnumerateScopePane((MMC_COOKIE)pFolder,pFolder->GetScopeItem()->ID);

   bool bFoundFolder;

   szLoc = pFolder->GetName();
   nLoc = lstrlen(szLoc);
   pos = m_Templates.GetStartPosition();
   while (pos) {
      m_Templates.GetNextAssoc(pos,strKey,pTemplate);

      //
      // If the template hasn't been changed then we don't care about it
      //
      if ( !pTemplate->IsDirty()
                 ) {
         continue;
      }

      //
      // We only care about templates in the location we are reloading
      //
      if (_wcsnicmp(strKey,szLoc,nLoc)) {
         bFoundFolder = false;
         hr = m_pScope->GetChildItem(pFolder->GetScopeItem()->ID, &pItemChild, &lCookie);
         //
         // find a child item
         //
         while ( SUCCEEDED(hr) ) {
            pChild = (CFolder*)lCookie;
            if ( pChild ) {
               if ( _wcsicmp(pChild->GetInfFile(), strKey) == 0 ) {
                  //
                  // The template has a folder here already, so we don't need to do anything
                  //
                  bFoundFolder = true;
                  break;
               }
            }
            hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);
         }
         if (!bFoundFolder) {
            //
            // Raid #460891, Yang Gao, 8/28/2001.
            // We didn't find a folder for the template in current location, so try
            // to find it in other locations.
            //
            CFolder *pNewFolder = 0;
            int nCount = (int)(m_scopeItemList.GetCount());
            POSITION newpos = m_scopeItemList.GetHeadPosition();
            BOOL otherloc = FALSE;

            while( nCount > 0 && newpos )
            {
               pNewFolder = m_scopeItemList.GetNext(newpos);
               if( pNewFolder && (pNewFolder->GetInfFile()) )
               {
                  if( _wcsicmp(pNewFolder->GetInfFile(), strKey) == 0 )
                  {
                     otherloc = TRUE;
                     break;
                  }
               }
               nCount--;
            }

            //
            // If could not find the folder for the template, Add one in current location.
            // The folder's name is its file part, less ".inf"
            //
            if( !otherloc )
            {
               strName = strKey.Right(strName.GetLength() - nLoc);
               strName = strName.Left(strName.GetLength() - 4);
               // Since there's no file for this guy, mark it as not saved
               if (strNotSaved.LoadString(IDS_NOT_SAVED_SUFFIX)) {
                  strName += strNotSaved;
               }
               if (! GetProfileDescription((LPCTSTR)strKey, &szDesc) ) {
                  szDesc = NULL;
               }
               CreateAndAddOneNode(pFolder, (LPCTSTR)strName, szDesc, PROFILE, TRUE,strKey);
               if (szDesc) {
                  LocalFree(szDesc);
                  szDesc = NULL;
               }
            }
         }
      }
   }

   return S_OK;
}

DWORD
CSnapin::GetResultItemIDs(
   CResult *pResult,
   HRESULTITEM *pIDArray,
   int nIDArray
   )
{
   if(!m_pResult){
      return ERROR_NOT_READY;
   }

   if(!pResult || !pIDArray || nIDArray <= 0){
      return ERROR_INVALID_PARAMETER;
   }

   ZeroMemory( pIDArray, sizeof(RESULTDATAITEM) * nIDArray );

   if(S_OK == m_pResult->FindItemByLParam(
      (LPARAM)pResult,
      pIDArray
      ) ){
      RESULTDATAITEM rdi;
      ZeroMemory(&rdi, sizeof(RESULTDATAITEM));
      rdi.mask = RDI_PARAM | RDI_INDEX;
      rdi.lParam = (LPARAM)pResult;
      rdi.itemID = pIDArray[0];

      if( m_pResult->GetItem( &rdi ) == S_OK ){
         for(int i = 1; i < nIDArray; i++) {
            if( m_pResult->GetNextItem(&rdi) == S_OK){
               pIDArray[i] = rdi.itemID;
            } else {
               break;
            }
         }
      }
   }

   return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------------
//Method:       CSnapin::UpdateAnalysisInfo
//
//Synopsis:     This function updates only priviledge assingedto area.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CSnapin::UpdateAnalysisInfo(
    CResult *pResult,
    BOOL bDelete,
    PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
    LPCTSTR pszName
    )
{
    PEDITTEMPLATE pBaseTemplate;

    pBaseTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
    if (!pBaseTemplate) {
      return ERROR_FILE_NOT_FOUND;
    }

    DWORD dwRet;
    dwRet = pBaseTemplate->UpdatePrivilegeAssignedTo(
                bDelete,
                pInfo,
                pszName
                );

    if(dwRet == ERROR_SUCCESS){
        pBaseTemplate->SetDirty(AREA_PRIVILEGES);
        //
        // Update the result item.
        //
        LONG_PTR dwBase =(LONG_PTR)(*pInfo);
        if(!dwBase){
            dwBase = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
        }

        if(*pInfo &&
            pResult->GetSetting() &&
            pResult->GetSetting() != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)
        ){
            (*pInfo)->Value = ((PSCE_PRIVILEGE_ASSIGNMENT)pResult->GetSetting())->Value;
        }

        AddResultItem(
             NULL,                      // The name of the attribute being added
             (LONG_PTR)pResult->GetSetting(),
                                        // The last inspected setting of the attribute
             (LONG_PTR)dwBase,          // The template setting of the attribute
             ITEM_PRIVS,                // The type of of the attribute's data
             pResult->GetStatus(),      // The mismatch status of the attribute
             pResult->GetCookie(),      // The cookie for the result item pane
             FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
             NULL,                      // The units the attribute is set in
             pResult->GetID(),          // An id to let us know where to save this attribute
             pResult->GetBaseProfile(), // The template to save this attribute in
             NULL,                  // The data object for the scope note who owns the result pane
             pResult
             );
    }

    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetAnalysisInfo
//
//  Synopsis:   Set a single policy entry to a new value in the Analysis
//              template.
//
//  Arguments:  [dwItem] - the id of the item to set
//              [dwNew]  - the new setting for that item
//              [pResult]- Pointer to the result item which is being updated.
//
//  Returns:    The new mismatch status of the item:
//                 -1 if the item wasn't found
//                 SCE_STATUS_GOOD if the items now match
//                 SCE_STATUS_MISMATCH if they are now different
//
//
//  Modifies:
//
//  History:    12-12-1997   Robcap
//
//---------------------------------------------------------------------------
int
CSnapin::SetAnalysisInfo(ULONG_PTR dwItem, ULONG_PTR dwNew, CResult *pResult)
{
   CString str;
   PSCE_PROFILE_INFO pProfileInfo;
   PSCE_PROFILE_INFO pBaseInfo;
   PEDITTEMPLATE pBaseTemplate;
   PEDITTEMPLATE pProfileTemplate;
   int nRet;

   pBaseTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
   if (!pBaseTemplate) {
      return -1;
   }
   pBaseInfo = pBaseTemplate->pTemplate;

   pProfileTemplate = GetTemplate(GT_LAST_INSPECTION,AREA_SECURITY_POLICY);
   if (!pProfileTemplate) {
      return -1;
   }
   pProfileInfo = pProfileTemplate->pTemplate;

   // If the Last Inspect (pProfileInfo) setting was SCE_NO_VALUE, then it was a match,
   // so copy the actual value from the Template (pBaseInfo) setting
   // Then copy the new value into the Template setting
   // Compare them; if they are the same then we have a match, so the Last Inspect should
   // be set back to SCE_NO_VALUE (is this last part necessary?), otherwise it's a mismatch
#ifdef UPDATE_ITEM
#undef UPDATE_ITEM
#endif
#define UPDATE_ITEM(X) pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);\
                       if( SCE_NO_VALUE == pProfileInfo->X ){\
                          pProfileInfo->X = pBaseInfo->X;\
                       }\
                       pBaseInfo->X = PtrToUlong((PVOID)dwNew); \
                       if (SCE_NOT_ANALYZED_VALUE == pProfileInfo->X ){\
                          nRet = SCE_STATUS_NOT_ANALYZED;\
                       } else if (SCE_NO_VALUE == PtrToUlong((PVOID)dwNew)) { \
                          nRet =  SCE_STATUS_NOT_CONFIGURED; \
                       } else if (SCE_NO_VALUE == pProfileInfo->X ){\
                          pProfileInfo->X = SCE_NOT_ANALYZED_VALUE;\
                          nRet = SCE_STATUS_NOT_ANALYZED;\
                       } else if (pBaseInfo->X == pProfileInfo->X) { \
                          nRet =  SCE_STATUS_GOOD; \
                       } else { \
                          nRet = SCE_STATUS_MISMATCH;\
                       }\
                       if(pResult){\
                          pResult->SetSetting( pProfileInfo->X );\
                       }




   nRet = -1;
   switch (dwItem) {
      case IDS_MAX_PAS_AGE:
         UPDATE_ITEM(MaximumPasswordAge);
         break;
      case IDS_MIN_PAS_AGE:
         UPDATE_ITEM(MinimumPasswordAge);
         break;
      case IDS_MIN_PAS_LEN:
         UPDATE_ITEM(MinimumPasswordLength);
         break;
      case IDS_PAS_UNIQUENESS:
         UPDATE_ITEM(PasswordHistorySize);
         break;
      case IDS_PAS_COMPLEX:
         UPDATE_ITEM(PasswordComplexity);
         break;
      case IDS_REQ_LOGON:
         UPDATE_ITEM(RequireLogonToChangePassword);
         break;
      case IDS_LOCK_COUNT:
         UPDATE_ITEM(LockoutBadCount);
         break;
      case IDS_LOCK_RESET_COUNT:
         UPDATE_ITEM(ResetLockoutCount);
         break;
      case IDS_LOCK_DURATION:
         UPDATE_ITEM(LockoutDuration);
         break;
      case IDS_FORCE_LOGOFF:
         UPDATE_ITEM(ForceLogoffWhenHourExpire);
         break;
      case IDS_ENABLE_ADMIN:
         UPDATE_ITEM(EnableAdminAccount);
         break;
      case IDS_ENABLE_GUEST:
         UPDATE_ITEM(EnableGuestAccount);
         break;
      case IDS_NEW_ADMIN:
      //
      // First copy the name if the analysis info used to be a match.
      // Then copy the new name to the configuration buffer.
      // Then get the status of the item.
      //
      //Below two may not be safe usages. pProfileInfo->X and pBaseInfo->X are both PWSTR. Consider fix.
#define UPDATE_STRING( X ) if ( (pProfileInfo->X == (LPTSTR)ULongToPtr(SCE_NO_VALUE) ||\
                              pProfileInfo->X == NULL) &&\
                              (pBaseInfo->X != (LPTSTR)ULongToPtr(SCE_NO_VALUE) &&\
                              pBaseInfo->X != NULL) ) {\
                              pProfileInfo->X = (LPTSTR)LocalAlloc(0,  sizeof(TCHAR) * (lstrlen(pBaseInfo->X) + 1));\
                              if(pProfileInfo->X){\
                                 lstrcpy(pProfileInfo->X, pBaseInfo->X);\
                              }\
                           }\
                           if (pBaseInfo->X) {\
                              LocalFree(pBaseInfo->X);\
                           }\
                           if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {\
                              pBaseInfo->X =\
                                 (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));\
                              if (pBaseInfo->X) {\
                                 lstrcpy(pBaseInfo->X,(PWSTR)dwNew);\
                              } else {\
                                 return SCE_STATUS_NOT_CONFIGURED;\
                              }\
                           } else {\
                              pBaseInfo->X = NULL;\
                              return SCE_STATUS_NOT_CONFIGURED;\
                           }\
                           if (pProfileInfo->X &&\
                              _wcsicmp(pBaseInfo->X,pProfileInfo->X) == 0 ) {\
                              return SCE_STATUS_GOOD;\
                           } else {\
                              return SCE_STATUS_MISMATCH;\
                           }

         pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);
         UPDATE_STRING( NewAdministratorName );
         break;
      case IDS_NEW_GUEST:
         pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);
         UPDATE_STRING( NewGuestName );
         break;
      case IDS_SYS_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         break;
      case IDS_SYSTEM_EVENT:
         UPDATE_ITEM(AuditSystemEvents);
         break;
      case IDS_LOGON_EVENT:
         UPDATE_ITEM(AuditLogonEvents);
         break;
      case IDS_OBJECT_ACCESS:
         UPDATE_ITEM(AuditObjectAccess);
         break;
      case IDS_PRIVILEGE_USE:
         UPDATE_ITEM(AuditPrivilegeUse);
         break;
      case IDS_POLICY_CHANGE:
         UPDATE_ITEM(AuditPolicyChange);
         break;
      case IDS_ACCOUNT_MANAGE:
         UPDATE_ITEM(AuditAccountManage);
         break;
      case IDS_PROCESS_TRACK:
         UPDATE_ITEM(AuditProcessTracking);
         break;
      case IDS_DIRECTORY_ACCESS:
         UPDATE_ITEM(AuditDSAccess);
         break;
      case IDS_ACCOUNT_LOGON:
         UPDATE_ITEM(AuditAccountLogon);
         break;
      case IDS_SYS_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_APP]);
         break;
      case IDS_CLEAR_PASSWORD:
         UPDATE_ITEM(ClearTextPassword);
         break;

      case IDS_KERBEROS_MAX_SERVICE:
         UPDATE_ITEM(pKerberosInfo->MaxServiceAge);
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         UPDATE_ITEM(pKerberosInfo->MaxClockSkew);
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         UPDATE_ITEM(pKerberosInfo->TicketValidateClient);
         break;

      case IDS_KERBEROS_MAX_AGE:
         UPDATE_ITEM(pKerberosInfo->MaxTicketAge);
         break;
      case IDS_KERBEROS_RENEWAL:
         UPDATE_ITEM(pKerberosInfo->MaxRenewAge);
         break;
      default:
         break;
   }
#undef UPDATE_ITEM
#undef UPDATE_STRING
   return nRet;
}

//+----------------------------------------------------------------------------------
//Method:       CSnapin::UpdateLocalPolInfo
//
//Synopsis:     This function update the priviledge unsigned to area of local
//          Policy.
//          First the local policy is updated to the database,
//          Then the template used for display is updated.
//          Last the CResult item is updated.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CSnapin::UpdateLocalPolInfo(
    CResult *pResult,
    BOOL bDelete,
    PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
    LPCTSTR pszName
    )
{
   PEDITTEMPLATE pLocalPol;

   if (!pszName && (NULL != pInfo) && (NULL != *pInfo)){
      pszName = (*pInfo)->Name;
   }
   //
   // Update changes only for the saved local policy section
   //
   pLocalPol = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_PRIVILEGES);
   if (!pLocalPol) {
      return ERROR_FILE_NOT_FOUND;
   }

   //
   // For local policy delta section mark the node to be deleted by the
   // engine, don't actually delete it from the list.
   //

   // Create new link
   DWORD dwRet;

  

   if(pInfo && *pInfo){
      //
      // Save values of privilege buffer.
      //
      dwRet = (*pInfo)->Status;
      PSCE_PRIVILEGE_ASSIGNMENT pNext = (*pInfo)->Next;

      (*pInfo)->Next = NULL;
      if(bDelete){
         (*pInfo)->Status = SCE_DELETE_VALUE;
      }
      //
      // Update the engine.
      //
      pLocalPol->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo = *pInfo;
      pLocalPol->SetDirty(AREA_PRIVILEGES);

      (*pInfo)->Status = dwRet;
      (*pInfo)->Next = pNext;
   } else {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Update for the displayed Local Policy section
   //
   if( pInfo && ((!bDelete && !(*pInfo)) || (bDelete && *pInfo)) ){
      pLocalPol = GetTemplate(GT_LOCAL_POLICY,AREA_PRIVILEGES);
      if (!pLocalPol) {
        return ERROR_FILE_NOT_FOUND;
      }

      //
      // Only make a call to this function if we are updating the priviledge link list.
      //
      dwRet = pLocalPol->UpdatePrivilegeAssignedTo(
               bDelete,
               pInfo,
               pszName
               );
      pLocalPol->SetDirty(AREA_PRIVILEGES);
   }

    if(dwRet == ERROR_SUCCESS){
        //
        // Update the result item.
        //
        LONG_PTR dwBase;
        if( *pInfo )
        {
            dwBase =(LONG_PTR)(*pInfo); //Prefast warning: Dereferencing NULL pointer 'pInfo'. Comments: It is checked below.
        }
        else
        {
            dwBase = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
        }

        if(*pInfo &&
            pResult->GetSetting() &&
            pResult->GetSetting() != (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ){
            (*pInfo)->Value = ((PSCE_PRIVILEGE_ASSIGNMENT)pResult->GetSetting())->Value;
        }

        AddResultItem(
             NULL,                      // The name of the attribute being added
             (LONG_PTR)pResult->GetSetting(),
                                        // The last inspected setting of the attribute
             (LONG_PTR)dwBase,          // The template setting of the attribute
             ITEM_LOCALPOL_PRIVS,       // The type of of the attribute's data
             pResult->GetStatus(),      // The mismatch status of the attribute
             pResult->GetCookie(),      // The cookie for the result item pane
             FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
             NULL,                      // The units the attribute is set in
             pResult->GetID(),          // An id to let us know where to save this attribute
             pResult->GetBaseProfile(), // The template to save this attribute in
             NULL,                      // The data object for the scope note who owns the result pane
             pResult
             );
    }

    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetLocalPolInfo
//
//  Synopsis:   Set a single policy entry to a new value in the local policy
//              template.  Update both the displayed local policy buffer and
//              the changes-only local policy buffer
//
//  Arguments:  [dwItem] - the id of the item to set
//              [dwNew]  - the new setting for that item
//
//  Returns:    The new mismatch status of the item:
//                 SCE_STATUS_GOOD if the items now match
//                 SCE_STATUS_MISMATCH if they are now different
//                 SCE_STATUS_NOT_CONFIGURED if the item is now non-configured
//                 SCE_ERROR_VALUE if there was an error saving
//
//
//  Modifies:
//
//  History:    12-12-1997   Robcap
//
//---------------------------------------------------------------------------
int
CSnapin::SetLocalPolInfo(ULONG_PTR dwItem, ULONG_PTR dwNew)
{
   CString str;
   PSCE_PROFILE_INFO pLocalInfo;
   PSCE_PROFILE_INFO pLocalDeltaInfo;
   PSCE_PROFILE_INFO pEffectiveInfo;
   PEDITTEMPLATE pLocalTemplate;
   PEDITTEMPLATE pLocalDeltaTemplate;
   PEDITTEMPLATE pEffectiveTemplate;
   int nRet;
   ULONG_PTR dwSave;
   ULONG_PTR dwSaveDelta;

   pEffectiveTemplate = GetTemplate(GT_EFFECTIVE_POLICY,AREA_SECURITY_POLICY);
   if (!pEffectiveTemplate) {
      return SCE_ERROR_VALUE;
   }
   pEffectiveInfo = pEffectiveTemplate->pTemplate;

   pLocalTemplate = GetTemplate(GT_LOCAL_POLICY,AREA_SECURITY_POLICY);
   if (!pLocalTemplate) {
      return SCE_ERROR_VALUE;
   }
   pLocalInfo = pLocalTemplate->pTemplate;
   if (!pLocalInfo) {
      return SCE_ERROR_VALUE;
   }

   pLocalDeltaTemplate = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
   if (!pLocalDeltaTemplate) {
      return SCE_ERROR_VALUE;
   }
   if ( !pLocalDeltaTemplate->IsLockedWriteThrough() )
       pLocalDeltaTemplate->SetTemplateDefaults();

   pLocalDeltaInfo = pLocalDeltaTemplate->pTemplate;
   if (!pLocalDeltaInfo) {
      return SCE_ERROR_VALUE;
   }


   // Compare them; if they are the same then we have a match, so the Last Inspect should
   // be set back to SCE_NO_VALUE (is this last part necessary?), otherwise it's a mismatch
   //
   // If the new value is different from the old value then call SetDirty after the changes
   // have been made, otherwise we may save things before that
   // Once the dirty bit has been set (causing the delta template to be immediately saved)
   // reset the changed item back to SCE_STATUS_NOT_CONFIGURED in that template
   //
   // If the SetDirty fails then undo the changes and return SCE_ERROR_VALUE
   //
#ifdef UPDATE_ITEM
#undef UPDATE_ITEM
#endif

#define UPDATE_ITEM(X) dwSave = pLocalInfo->X; \
                       dwSaveDelta = pLocalDeltaInfo->X; \
                       pLocalInfo->X = (DWORD)PtrToUlong((PVOID)dwNew); \
                       pLocalDeltaInfo->X = (DWORD)PtrToUlong((PVOID)dwNew); \
                       if (SCE_NO_VALUE == (DWORD)PtrToUlong((PVOID)dwNew)) { \
                          pLocalDeltaInfo->X = SCE_DELETE_VALUE; \
                          nRet = SCE_STATUS_NOT_CONFIGURED; \
                       } else if (pEffectiveInfo->X == pLocalInfo->X) { \
                          nRet = SCE_STATUS_GOOD; \
                       } else { \
                          nRet = SCE_STATUS_MISMATCH; \
                       } \
                       if (dwSave != (DWORD)PtrToUlong((PVOID)dwNew) && \
                           !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY)) { \
                          pLocalInfo->X = (DWORD)PtrToUlong((PVOID)dwSave); \
                          nRet = SCE_ERROR_VALUE; \
                       } \
                       if ( !pLocalDeltaTemplate->IsLockedWriteThrough() ) \
                           pLocalDeltaInfo->X = SCE_NO_VALUE;
// In order to batch dependent settings together (for write through mode), the delta info
// buffer should not be reset to "no value" since it may not be set in the SetDirty call
   CString oldstrName; //Yanggao 1/31/2001 Bug211219. For keeping original name.

   nRet = SCE_ERROR_VALUE;
   switch (dwItem) {
   case IDS_MAX_PAS_AGE:
         UPDATE_ITEM(MaximumPasswordAge);
         break;
      case IDS_MIN_PAS_AGE:
         UPDATE_ITEM(MinimumPasswordAge);
         break;
      case IDS_MIN_PAS_LEN:
         UPDATE_ITEM(MinimumPasswordLength);
         break;
      case IDS_PAS_UNIQUENESS:
         UPDATE_ITEM(PasswordHistorySize);
         break;
      case IDS_PAS_COMPLEX:
         UPDATE_ITEM(PasswordComplexity);
         break;
      case IDS_REQ_LOGON:
         UPDATE_ITEM(RequireLogonToChangePassword);
         break;
      case IDS_LOCK_COUNT:
         UPDATE_ITEM(LockoutBadCount);
         break;
      case IDS_LOCK_RESET_COUNT:
         UPDATE_ITEM(ResetLockoutCount);
         break;
      case IDS_LOCK_DURATION:
         UPDATE_ITEM(LockoutDuration);
         break;
      case IDS_FORCE_LOGOFF:
         UPDATE_ITEM(ForceLogoffWhenHourExpire);
         break;
      case IDS_ENABLE_ADMIN:
         UPDATE_ITEM(EnableAdminAccount);
         break;
      case IDS_ENABLE_GUEST:
         UPDATE_ITEM(EnableGuestAccount);
         break;
      case IDS_NEW_ADMIN:
         pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
         if (pLocalInfo->NewAdministratorName)
         {
            // Yanggao 1/31/2001. Bug211219.
            oldstrName = (LPCTSTR)(pLocalInfo->NewAdministratorName);
			LocalFree(pLocalInfo->NewAdministratorName);
            pLocalInfo->NewAdministratorName = NULL;
         }
         pLocalDeltaInfo->NewAdministratorName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);

         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
         {
            pLocalInfo->NewAdministratorName =
               (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));
            if (pLocalInfo->NewAdministratorName)
            {
               //This may not be a safe usage. pLocalInfo->NewAdministratorName and dwNew are both PWSTR. Consider fix.
               lstrcpy(pLocalInfo->NewAdministratorName,(PWSTR)dwNew);
               pLocalDeltaInfo->NewAdministratorName = pLocalInfo->NewAdministratorName;
            }
         }

         if( !pLocalInfo->NewAdministratorName )
         {
            nRet = SCE_STATUS_NOT_CONFIGURED;
         }
         else
         {
            if (pEffectiveInfo->NewAdministratorName &&
             _wcsicmp(pLocalInfo->NewAdministratorName,
                      pEffectiveInfo->NewAdministratorName) == 0 ) 
            {
                nRet = SCE_STATUS_GOOD;
            }
            else
            {
                nRet = SCE_STATUS_MISMATCH;
            }
         }
		 
         //Yanggao 1/31/2001 Bug211219. Recover original name if save failed.
         if( !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) &&
              SCE_STATUS_MISMATCH == nRet )
         {
             pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
             if (pLocalInfo->NewAdministratorName)
             {
                LocalFree(pLocalInfo->NewAdministratorName);
                pLocalInfo->NewAdministratorName = NULL;
             }
             pLocalDeltaInfo->NewAdministratorName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);
             LONG_PTR dwOld = (LONG_PTR)(LPCTSTR)oldstrName;
             if (dwOld && (dwOld != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
             {
                pLocalInfo->NewAdministratorName =
                   (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwOld)+1));
                if (pLocalInfo->NewAdministratorName)
                {
                   //This may not be a safe usage. pLocalInfo->NewAdministratorName and dwOld are both PWSTR. Consider fix.
                   lstrcpy(pLocalInfo->NewAdministratorName,(PWSTR)dwOld);
                   pLocalDeltaInfo->NewAdministratorName = pLocalInfo->NewAdministratorName;
                }
             } 
             pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY);
         }
          
         break;
      case IDS_NEW_GUEST:
         pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
         if (pLocalInfo->NewGuestName)
         {
            //Yanggao 3/15/2001 Bug211219. Recover original name if save failed.
            oldstrName = (LPCTSTR)(pLocalInfo->NewGuestName);
			LocalFree(pLocalInfo->NewGuestName);
            pLocalInfo->NewGuestName = NULL;
         }
         pLocalDeltaInfo->NewGuestName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);

         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
         {
            pLocalInfo->NewGuestName =
               (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));
            if (pLocalInfo->NewGuestName)
            {
               //This may not be a safe usage. pLocalInfo->NewGuestName and dwNew are both PWSTR. Consider fix.
               lstrcpy(pLocalInfo->NewGuestName,(PWSTR)dwNew);
               pLocalDeltaInfo->NewGuestName = pLocalInfo->NewGuestName;
            }
         } 

         if( !pLocalInfo->NewGuestName )
         {
            nRet = SCE_STATUS_NOT_CONFIGURED;
         }
         else
         {
            if (pEffectiveInfo->NewGuestName &&
             _wcsicmp(pLocalInfo->NewGuestName,pEffectiveInfo->NewGuestName) == 0 )
            {
               nRet = SCE_STATUS_GOOD;
            }
            else
            {
               nRet = SCE_STATUS_MISMATCH;
            }
         }

         //Yanggao 3/15/2001 Bug211219. Recover original name if save failed.
         if( !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) &&
              SCE_STATUS_MISMATCH == nRet )
         {
             pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
             if (pLocalInfo->NewGuestName)
             {
                LocalFree(pLocalInfo->NewGuestName);
                pLocalInfo->NewGuestName = NULL;
             }
             pLocalDeltaInfo->NewGuestName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);
             LONG_PTR dwOld = (LONG_PTR)(LPCTSTR)oldstrName;
             if (dwOld && (dwOld != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
             {
                pLocalInfo->NewGuestName =
                   (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwOld)+1));
                if (pLocalInfo->NewGuestName)
                {
                   //This may not be a safe usage. pLocalInfo->NewGuestName and dwOld are both PWSTR. Consider fix.
                   lstrcpy(pLocalInfo->NewGuestName,(PWSTR)dwOld);
                   pLocalDeltaInfo->NewGuestName = pLocalInfo->NewGuestName;
                }
             } 
             pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY);
         }

         break;
      case IDS_SYS_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         }
         break;
      case IDS_SYS_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         }
         break;
      case IDS_SEC_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         }
         break;
      case IDS_APP_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         break;
      case IDS_SYSTEM_EVENT:
         UPDATE_ITEM(AuditSystemEvents);
         break;
      case IDS_LOGON_EVENT:
         UPDATE_ITEM(AuditLogonEvents);
         break;
      case IDS_OBJECT_ACCESS:
         UPDATE_ITEM(AuditObjectAccess);
         break;
      case IDS_PRIVILEGE_USE:
         UPDATE_ITEM(AuditPrivilegeUse);
         break;
      case IDS_POLICY_CHANGE:
         UPDATE_ITEM(AuditPolicyChange);
         break;
      case IDS_ACCOUNT_MANAGE:
         UPDATE_ITEM(AuditAccountManage);
         break;
      case IDS_PROCESS_TRACK:
         UPDATE_ITEM(AuditProcessTracking);
         break;
      case IDS_DIRECTORY_ACCESS:
         UPDATE_ITEM(AuditDSAccess);
         break;
      case IDS_ACCOUNT_LOGON:
         UPDATE_ITEM(AuditAccountLogon);
         break;
      case IDS_SYS_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_APP]);
         break;
      case IDS_CLEAR_PASSWORD:
         UPDATE_ITEM(ClearTextPassword);
         break;
      case IDS_KERBEROS_MAX_AGE:
#define CHECK_KERBEROS if( !pLocalInfo->pKerberosInfo ||\
                           !pLocalDeltaInfo->pKerberosInfo ||\
                           !pEffectiveInfo->pKerberosInfo ){\
                              break;\
                       }



         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxTicketAge);
         break;
      case IDS_KERBEROS_RENEWAL:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxRenewAge);
         break;
      case IDS_KERBEROS_MAX_SERVICE:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxServiceAge);
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxClockSkew);
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->TicketValidateClient);
         break;
      case IDS_LSA_ANON_LOOKUP: //Raid #324250, 4/5/2001
         UPDATE_ITEM(LSAAnonymousNameLookup);
         break;
#undef CHECK_KERBEROS
      default:
         break;
   }

   return nRet;
}


//+------------------------------------------------------------------------------
// GetImageOffset
//
// Returns the offset in the image index depending on the status of the item.
//
// Returns
//    Image offset, there is no error.
//-------------------------------------------------------------------------------
int
GetImageOffset(
   DWORD status
   )
{
   int nImage = 0;
   switch (status) {
      case SCE_STATUS_GOOD:
         nImage = IMOFFSET_GOOD;
         break;
      case SCE_STATUS_MISMATCH:
         nImage = IMOFFSET_MISMATCH;
         break;
      case SCE_STATUS_NOT_ANALYZED:
         nImage = IMOFFSET_NOT_ANALYZED;
         break;
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
         nImage = IMOFFSET_ERROR;
         break;
   }

   return nImage;
}

int
GetScopeImageIndex(
                  FOLDER_TYPES type,
                  DWORD status
                  )
/*
Get the right image icon for scope items based on the folder type
*/
{
   int nImage;

   switch ( type ) {
      case ROOT:
      case STATIC:
         nImage = SCE_IMAGE_IDX;
         break;
      case ANALYSIS:
         nImage = LAST_IC_IMAGE_IDX;
         break;
      case PROFILE:
         nImage = TEMPLATES_IDX;
         break;
      case CONFIGURATION:
      case LOCATIONS:
         nImage = CONFIG_FOLDER_IDX;
         break;
      case POLICY_ACCOUNT:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
         nImage = CONFIG_ACCOUNT_IDX;
         break;
      case POLICY_ACCOUNT_ANALYSIS:
      case POLICY_PASSWORD_ANALYSIS:
      case POLICY_KERBEROS_ANALYSIS:
      case POLICY_LOCKOUT_ANALYSIS:
         nImage = CONFIG_ACCOUNT_IDX;
         break;
      case POLICY_LOCAL:
      case POLICY_EVENTLOG:
      case POLICY_AUDIT:
      case POLICY_OTHER:
      case POLICY_LOG:
      case AREA_PRIVILEGE:
         nImage = CONFIG_LOCAL_IDX;
         break;
      case POLICY_LOCAL_ANALYSIS:
      case POLICY_EVENTLOG_ANALYSIS:
      case POLICY_AUDIT_ANALYSIS:
      case POLICY_OTHER_ANALYSIS:
      case POLICY_LOG_ANALYSIS:
      case AREA_PRIVILEGE_ANALYSIS:
         nImage = CONFIG_LOCAL_IDX;
         break;
      case REG_OBJECTS:
         nImage = CONFIG_REG_IDX + GetImageOffset( status & 0xF );

         break;
      case FILE_OBJECTS:
         nImage = FOLDER_IMAGE_IDX + GetImageOffset( status & 0xF );

         break;
      default:
         nImage = CONFIG_FOLDER_IDX;
         break;
   }

   return nImage;
}

int
GetResultImageIndex(
                   CFolder* pFolder,
                   CResult* pResult
                   )
/*
Get the image icon for the result item, based on where the
result item belongs to (which folder), the type of the result item,
and the status of the result item
*/
{
   RESULT_TYPES rsltType;

   int nImage;
   BOOL bCheck = TRUE;

   if (!pFolder || !pResult ) {
      // don't know which scope it belongs to ?
      // should not occur
      nImage = BLANK_IMAGE_IDX;

   } else {
      rsltType = pResult->GetType();
      PSCE_GROUP_MEMBERSHIP pGroup;

      int ista;
      if ( pResult->GetStatus() == -1 ) {
         ista = -1;
      } else {
         ista = pResult->GetStatus() & 0x0F;
      }

      //
      // Get base image index.
      //
      switch ( pFolder->GetType() ) {
         case POLICY_KERBEROS:
         case POLICY_PASSWORD:
         case POLICY_LOCKOUT:
         case POLICY_PASSWORD_ANALYSIS:
         case POLICY_KERBEROS_ANALYSIS:
         case POLICY_LOCKOUT_ANALYSIS:
         case LOCALPOL_KERBEROS:
         case LOCALPOL_PASSWORD:
         case LOCALPOL_LOCKOUT:
            nImage = CONFIG_POLICY_IDX;
            break;
         case POLICY_AUDIT:
         case POLICY_LOG:
         case POLICY_OTHER:
         case AREA_PRIVILEGE:
         case POLICY_AUDIT_ANALYSIS:
         case POLICY_LOG_ANALYSIS:
         case POLICY_OTHER_ANALYSIS:
         case AREA_PRIVILEGE_ANALYSIS:
         case LOCALPOL_AUDIT:
         case LOCALPOL_LOG:
         case LOCALPOL_OTHER:
         case LOCALPOL_PRIVILEGE:
            nImage = CONFIG_POLICY_IDX;
            break;
         case AREA_GROUPS:
            nImage = CONFIG_GROUP_IDX;
            break;
         case AREA_SERVICE:
         case AREA_SERVICE_ANALYSIS:
            nImage = CONFIG_SERVICE_IDX;
            break;
         case AREA_FILESTORE:
         case AREA_FILESTORE_ANALYSIS:
            // container or file ???
            nImage = FOLDER_IMAGE_IDX;
            break;
         case AREA_REGISTRY:
         case AREA_REGISTRY_ANALYSIS:
            nImage = CONFIG_REG_IDX;
            break;
         case REG_OBJECTS:
            nImage = CONFIG_REG_IDX;
            break;
         case FILE_OBJECTS:
            nImage = CONFIG_FILE_IDX;
            break;
         case AREA_GROUPS_ANALYSIS:
            if ( rsltType == ITEM_GROUP ) {
               nImage = CONFIG_GROUP_IDX;
            } else {
               //
               // the members or memberof record
               //
               bCheck = FALSE;
               if ( SCE_STATUS_GOOD == ista ) {
                  nImage = SCE_OK_IDX;
               } else if ( SCE_STATUS_MISMATCH == ista ) {
                  nImage = SCE_CRITICAL_IDX;
               } else {
                  nImage = BLANK_IMAGE_IDX;
               }

            }
            break;
         default:
            bCheck = FALSE;
            nImage = BLANK_IMAGE_IDX;
            break;
      }

      //
      // Find the status icon.  The image map garentees the order of these images.
      // We don't need to check the status if we are in MB_TEMPLATE_EDITOR.
      //
      if( bCheck ){

         if( pFolder->GetModeBits() & (MB_ANALYSIS_VIEWER) ){
            nImage += GetImageOffset( ista );
         } else if( SCE_STATUS_ERROR_NOT_AVAILABLE == ista ){
            nImage = SCE_CRITICAL_IDX;
         }
      }

      if ((pFolder->GetModeBits() & MB_LOCALSEC) == MB_LOCALSEC) {
          if (pResult->GetType() == ITEM_LOCALPOL_REGVALUE) {
             SCE_REGISTRY_VALUE_INFO *pRegValue;
             pRegValue = (PSCE_REGISTRY_VALUE_INFO)pResult->GetSetting();
             if (!pRegValue || pRegValue->Status != SCE_STATUS_NOT_CONFIGURED) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if (pResult->GetType() == ITEM_LOCALPOL_SZ) {
             if (pResult->GetSetting()) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if (pResult->GetType() == ITEM_LOCALPOL_PRIVS) {
             //
             // If there is a setting it's a pointer; if not, it is NULL
             //
             if (pResult->GetSetting()) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != pResult->GetSetting()) {
             nImage = LOCALSEC_POLICY_IDX;
          }
      }

   }

   if ( nImage < 0 ) {
      nImage = BLANK_IMAGE_IDX;
   }
   return nImage;
}

//+--------------------------------------------------------------------------
//
//  Method:    GetPopupDialog
//
//  Synopsis:  Retrieve a popup dialog from the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//
//  Returns:   The dialog if it exists, NULL otherwise
//
//  History:
//
//---------------------------------------------------------------------------
CDialog *
CComponentDataImpl::GetPopupDialog(LONG_PTR nID) {
   CDialog *pDlg = NULL;
   if (m_scopeItemPopups.Lookup(nID,pDlg)) {
      return pDlg;
   } else {
      return NULL;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    AddPopupDialog
//
//  Synopsis:  Set a popup dialog into the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//             [pDlg]    - The dialog
//
//  History:
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::AddPopupDialog(LONG_PTR nID,CDialog *pDlg) {
   if (pDlg) {
      m_scopeItemPopups.SetAt(nID,pDlg);
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    RemovePopupDialog
//
//  Synopsis:  Removes a popup dialog from the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//
//  History:
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::RemovePopupDialog(LONG_PTR nID) {
   CDialog *pDlg = NULL;
   if (m_scopeItemPopups.Lookup(nID,pDlg)) {
      m_scopeItemPopups.RemoveKey(nID);
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    EngineTransactionStarted
//
//  Synopsis:  Start transaction in the jet engine if one is not started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineTransactionStarted()
{
   if ( !SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      if ( SCESTATUS_SUCCESS == SceStartTransaction(SadHandle) ) {

         SadTransStarted = TRUE;
      }
   }

   return SadTransStarted;
}

//+--------------------------------------------------------------------------
//
//  Method:    EngineCommitTransaction
//
//  Synopsis:  Commit transaction in the jet engine if one is started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineCommitTransaction()
{

   if ( SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      if ( SCESTATUS_SUCCESS == SceCommitTransaction(SadHandle) ) {

         SadTransStarted = FALSE;
         return TRUE;
      }
   }

   return FALSE;
}
//+--------------------------------------------------------------------------
//
//  Method:    GetLinkedTopics
//
//  Synopsis:  Return full path of help file.
//
//  History:   Raid #258658, 4/10/2001
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR *lpCompiledHelpFiles)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if ( lpCompiledHelpFiles )
    {
        CString strLinkedTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strLinkedTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strLinkedTopic.ReleaseBuffer();
        if ( nLen )
        {
            CString strFile;

            if( SCE_MODE_LOCAL_COMPUTER == m_GroupMode || SCE_MODE_LOCAL_USER == m_GroupMode )
            {
                strFile.LoadString(IDS_HTMLHELP_LPPOLICY_TOPIC);
                strFile.Replace(L':', L'\0'); 
            }
            else
            {
                strFile.LoadString(IDS_HTMLHELP_POLICY_TOPIC);
                strFile.Replace(L':', L'\0');
            }

            strLinkedTopic = strLinkedTopic + strFile;
            *lpCompiledHelpFiles = reinterpret_cast<LPOLESTR>
                    (CoTaskMemAlloc((strLinkedTopic.GetLength() + 1)* sizeof(wchar_t)));

            if ( *lpCompiledHelpFiles )
            {
                //This is a safe usage.
                wcscpy(*lpCompiledHelpFiles, (PWSTR)(PCWSTR)strLinkedTopic);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }
    else
        return E_POINTER;


    return hr;
}
//+--------------------------------------------------------------------------
//
//  Method:    EngineRollbackTransaction
//
//  Synopsis:  Rollback transaction in the jet engine if one is started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineRollbackTransaction()
{

   if ( SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      SceRollbackTransaction(SadHandle);
      SadTransStarted = FALSE;

      return TRUE;
   }

   return FALSE;
}


CDialog *
CComponentDataImpl::MatchNextPopupDialog(
    POSITION &pos,
    LONG_PTR priKey,
    LONG_PTR *fullPos
    )
{
    if(pos == NULL){
        pos = m_scopeItemPopups.GetStartPosition();
    }

    LONG_PTR key;
    CDialog *pDlg = NULL;

    while(pos){
        m_scopeItemPopups.GetNextAssoc(pos, key, pDlg);

        if( DLG_KEY_PRIMARY(priKey) == DLG_KEY_PRIMARY(key) ){
            if(fullPos){
                *fullPos = key;
            }
            return pDlg;
        }
        pDlg = NULL;
    }

    return pDlg;
}

//+--------------------------------------------------------------------------
//
//  Method:    CheckEngineTransaction
//
//  Synopsis:  From CSnapin to check/start transaction in the jet engine
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CSnapin::CheckEngineTransaction()
{
   return ((CComponentDataImpl*)m_pComponentData)->EngineTransactionStarted();
}



//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//             szFile - [in] the file name of the help file for this snapin
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile, LPCTSTR szFile)
{
   CString sPath;
   LPTSTR szPath;

   if (lpCompiledHelpFile == NULL) {
      return E_POINTER;
   }

   szPath = sPath.GetBuffer(MAX_PATH+1); //Raid #533113, yanggao
   if (!szPath) {
      return E_OUTOFMEMORY;
   }
   if (!GetWindowsDirectory(szPath,MAX_PATH)) {
      return E_FAIL;
   }
   sPath.ReleaseBuffer();
   sPath += szFile;

   *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>
                         (CoTaskMemAlloc((sPath.GetLength() + 1)* sizeof(wchar_t)));

   if (*lpCompiledHelpFile == NULL) {
      return E_OUTOFMEMORY;
   }
   USES_CONVERSION;

   //This is a safe usage.
   wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)sPath));

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Method:    CComponentDataImpl::SetErroredLogFile
//
//  Synopsis:  Sets the log file created by the engine.  We can then display
//             this log file later on, if there was an error performing the
//             analysis or configuration.
//
//  Arguments: [pszFileName]     - The file name to set.  This can be NULL.
//             [dwPosLow]        - The starting pos of the file. only supports files less then a
//                                  gigabyte.
//
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::SetErroredLogFile( LPCTSTR pszFileName, LONG dwPosLow)
{
   if(m_pszErroredLogFile){
      LocalFree( m_pszErroredLogFile );
   }

   m_ErroredLogPos = dwPosLow;
   m_pszErroredLogFile = NULL;
   if(pszFileName ){
      DWORD dwRet = 0;

      __try {
         dwRet = lstrlen(pszFileName);
      } __except( EXCEPTION_CONTINUE_EXECUTION ){
         return;
      }

      m_pszErroredLogFile = (LPTSTR)LocalAlloc(0, sizeof(TCHAR) * (dwRet + 1) );
      if( !m_pszErroredLogFile ){
         return;
      }
      //This is a safe usage.
      lstrcpy( m_pszErroredLogFile, pszFileName );
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataSCEImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_SCE);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataSAVImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_SAV);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}
//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataLSImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_LS);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataRSOPImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_RSOP);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}


//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataExtensionImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //Raid #258658, 4/10/2001. If currently security setting node is not expanded, we
   //won't give them any helptopic. So after it is expanded, this function will be called
   //because it is only allowed calling one time.
   DWORD tempmode = CComponentDataImpl::GetGroupMode();
   if( SCE_MODE_UNKNOWN != tempmode )
   {
        if( SCE_MODE_LOCAL_COMPUTER == tempmode || 
            SCE_MODE_LOCAL_USER == tempmode )
            sFile.LoadString(IDS_HELPFILE_LOCAL_EXTENSION);
        else
            sFile.LoadString(IDS_HELPFILE_EXTENSION);
   }
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}


//+--------------------------------------------------------------------------
//
//  Method:    GetAnalTimeStamp
//
//  Synopsis:  Return the time of the last analysis
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
CSnapin::GetAnalTimeStamp() {
   PVOID SadHandle;
   CString strFormat;
   CString strTimeStamp;
   LPTSTR szAnalTimeStamp = NULL;


   //
   // Should cache this, but then we can't refresh it easily
   // when the system is re-analyzed.
   //
   if (m_szAnalTimeStamp) {
      LocalFree(m_szAnalTimeStamp);
      m_szAnalTimeStamp = NULL;

//      return m_szAnalTimeStamp;
   }

   SadHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
   if (!SadHandle) {
      return 0;
   }

   if (SCESTATUS_SUCCESS == SceGetTimeStamp(SadHandle,NULL,&szAnalTimeStamp)) {
      if (szAnalTimeStamp) {
      strFormat.LoadString(IDS_ANALTIMESTAMP);
      strTimeStamp.Format(strFormat,szAnalTimeStamp);
      m_szAnalTimeStamp = (LPTSTR) LocalAlloc(LPTR,(1+strTimeStamp.GetLength())*sizeof(TCHAR));
      if (m_szAnalTimeStamp) {
         //This is a safe usage.
         lstrcpy(m_szAnalTimeStamp,strTimeStamp);
      }
         LocalFree(szAnalTimeStamp);
      }
   }

   return m_szAnalTimeStamp;
}

DWORD CComponentDataImpl::GetGroupMode()
{
    return m_GroupMode; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\snapmgr.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef WSECMGR_SNAPMGR_H
#define WSECMGR_SNAPMGR_H

#include "resource.h"       // main symbols
#include "attr.h"

#ifdef INITGUID
#undef INITGUID
#endif
#include <gpedit.h>

#include "uithread.h"
#include "hidwnd.h"
#include "wmihooks.h"
#include "cookie.h"


#define MAX_CONTEXT_MENU_STRLEN 128

struct MENUDATARES
{
    WCHAR szBuffer[MAX_CONTEXT_MENU_STRLEN*2];
    UINT uResID;
};

struct MENUMAP
{
    MENUDATARES* dataRes;
    CONTEXTMENUITEM* ctxMenu;
};


#define DECLARE_MENU(theClass) \
class theClass \
{ \
public: \
    static LPCONTEXTMENUITEM GetContextMenuItem() { return GetMenuMap()->ctxMenu; }; \
    static MENUMAP* GetMenuMap(); \
};

#define BEGIN_MENU(theClass) \
     MENUMAP* theClass::GetMenuMap() {

#define BEGIN_CTX static CONTEXTMENUITEM ctx[] = {

#define CTX_ENTRY(cmdID, fFlags, fInsert) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TOP /*| fInsert*/, fFlags, 0 },

#define END_CTX { NULL, NULL, 0, 0, 0, 0} };

#define BEGIN_RES  static MENUDATARES dataRes[] = {

#define RES_ENTRY(resID) {L"", resID},

#define END_RES   { NULL, 0 }   };


#define END_MENU \
        static MENUMAP menuMap = { dataRes, ctx }; \
        return &menuMap; }

enum
{
    // Identifiers for each of the commands to be inserted into the context menu.
   IDM_ABOUT,
   IDM_ADD_ENTRY,
   IDM_ADD_FILES,
   IDM_ADD_GROUPS,
   IDM_ADD_REGISTRY,
   IDM_ADD_LOC,
   IDM_ANALYZE,
   IDM_APPLY,
   IDM_CUT,
   IDM_COPY,
   IDM_DELETE,
   IDM_GENERATE,
   IDM_NEW,
   IDM_PASTE,
   IDM_REAPPLY,
   IDM_REFRESH,
   IDM_RELOAD,
   IDM_REMOVE,
   IDM_REVERT,
   IDM_SAVE,
   IDM_SAVEAS,
   IDM_SUMMARY,
   IDM_ADD_FOLDER,
   IDM_ADD_ANAL_FILES,
   IDM_ADD_ANAL_FOLDER,
   IDM_ADD_ANAL_KEY,
   IDM_ASSIGN,
   IDM_SET_DB,
   IDM_NEW_DATABASE,
   IDM_OPEN_SYSTEM_DB,
   IDM_OPEN_PRIVATE_DB,
   IDM_OBJECT_SECURITY,
   IDM_DESCRIBE_LOCATION,
   IDM_DESCRIBE_PROFILE,
   IDM_IMPORT_POLICY,
   IDM_IMPORT_LOCAL_POLICY,
   IDM_EXPORT_POLICY,
   IDM_EXPORT_LOCALPOLICY,
   IDM_EXPORT_EFFECTIVE,
   IDM_VIEW_LOGFILE,
   IDM_SECURE_WIZARD,
   IDM_WHAT_ISTHIS
};


static HINSTANCE        g_hDsSecDll = NULL;

DECLARE_MENU(CSecmgrNodeMenuHolder)
DECLARE_MENU(CAnalyzeNodeMenuHolder)
DECLARE_MENU(CConfigNodeMenuHolder)
DECLARE_MENU(CLocationNodeMenuHolder)
DECLARE_MENU(CRSOPProfileNodeMenuHolder)
DECLARE_MENU(CSSProfileNodeMenuHolder)
DECLARE_MENU(CLocalPolNodeMenuHolder)
DECLARE_MENU(CProfileNodeMenuHolder)
DECLARE_MENU(CProfileAreaMenuHolder)
DECLARE_MENU(CProfileSubAreaMenuHolder)
DECLARE_MENU(CProfileSubAreaEventLogMenuHolder)
DECLARE_MENU(CAnalyzeAreaMenuHolder)
DECLARE_MENU(CAnalyzeGroupsMenuHolder)
DECLARE_MENU(CAnalyzeRegistryMenuHolder)
DECLARE_MENU(CAnalyzeFilesMenuHolder)
DECLARE_MENU(CProfileGroupsMenuHolder)
DECLARE_MENU(CProfileRegistryMenuHolder)
DECLARE_MENU(CProfileFilesMenuHolder)
DECLARE_MENU(CAnalyzeObjectsMenuHolder)

BOOL LoadContextMenuResources(MENUMAP* pMenuMap);


#define UAV_RESULTITEM_ADD        0x0001
#define UAV_RESULTITEM_REMOVE     0x0002
#define UAV_RESULTITEM_UPDATE     0x0004
#define UAV_RESULTITEM_UPDATEALL    0x0008
#define UAV_RESULTITEM_REDRAWALL 0x0010
class CFolder;

typedef struct _tag_SCE_COLUMNINFO {
    int colID;      // The column id.
    int nCols;      // Number of columns
    int nWidth;     // The width of the column
} SCE_COLUMNINFO, *PSCE_COLUMNINFO;

typedef struct _tag_SCE_COLINFOARRAY {
    int iIndex;
    int nCols;
    int nWidth[1];
} SCE_COLINFOARRAY, *PSCE_COLINFOARRAY;

/////////////////////////////////////////////////////////////////////////////
// Snapin

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);
int AppMessageBox(HWND hWnd, 
                  LPCTSTR lpText,
                  LPCTSTR lpCaption=NULL,
                  UINT uType=MB_OK|MB_ICONEXCLAMATION,
                  int iSnapin=0);

class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public ISceSvcAttachmentData,
    public ISnapinHelp2,
    public CComObjectRoot
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISceSvcAttachmentData)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()
   
    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    virtual ~CComponentDataImpl();
public:

    static DWORD m_GroupMode;

    virtual const CLSID& GetCoClassID() = 0; // for both primary and extension implementation
    virtual const int GetImplType() = 0;     // for both primary and extension implementation

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

// ISceSvcAttachmentData
    STDMETHOD(GetData)(SCESVC_HANDLE sceHandle,
                       SCESVC_INFO_TYPE sceType,
                       PVOID *ppvData,
                       PSCE_ENUMERATION_CONTEXT psceEnumHandle);
    STDMETHOD(Initialize)(LPCTSTR ServiceName,
                          LPCTSTR TemplateName,
                          LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
                          SCESVC_HANDLE *sceHandle);
    STDMETHOD(FreeBuffer)(PVOID pvData);
    STDMETHOD(CloseHandle)(SCESVC_HANDLE sceHandle);

// ISnapinHelp2 helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)=0;
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile,LPCTSTR szFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// Notify handler declarations
private:
    HRESULT OnAdd(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnRename(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

    HRESULT OnCopyArea(LPCTSTR szTemplate,FOLDER_TYPES ft);
    HRESULT OnPasteArea(LPCTSTR szTemplate,FOLDER_TYPES ft);
    HRESULT OnOpenDataBase();
    HRESULT OnNewDatabase();
    HRESULT OnAssignConfiguration( SCESTATUS *pSceStatus);
    HRESULT OnSecureWizard();
    HRESULT OnSaveConfiguration();
    HRESULT OnImportPolicy(LPDATAOBJECT);
    HRESULT OnImportLocalPolicy(LPDATAOBJECT);
    HRESULT OnExportPolicy(BOOL bEffective);
    HRESULT OnAnalyze();
    BOOL GetFolderCopyPasteInfo(FOLDER_TYPES Folder,AREA_INFORMATION *Area, UINT *cf);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    CFolder* FindObject(MMC_COOKIE cookie, POSITION* thePos );
    HRESULT CreateFolderList(CFolder* pFolder, FOLDER_TYPES type, POSITION *pPos, INT *Count);
    INT CComponentDataImpl::AddLocationsToFolderList(HKEY hkey, DWORD dwMode, BOOL bCheckForDupes, POSITION *pPos);
    BOOL AddTemplateLocation(CFolder *pParent, CString szName, BOOL bIsFileName, BOOL bRefresh);
    BOOL IsNameInChildrenScopes(CFolder* pParent, LPCTSTR NameStr, MMC_COOKIE *theCookie);
    CFolder* CreateAndAddOneNode(CFolder* pParent, LPCTSTR Name, LPCTSTR Desc,
                             FOLDER_TYPES type, BOOL bChildren, LPCTSTR szInfFile = NULL,
                             PVOID pData = NULL,DWORD status = 0);
    void DeleteChildrenUnderNode(CFolder* pParent);
    void DeleteThisNode(CFolder* pNode);
    HRESULT DeleteOneTemplateNodes(MMC_COOKIE cookie);
    void DeleteList();
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    DWORD GetModeBits() 
    { 
        switch (m_Mode)
        {
            case SCE_MODE_DOMAIN_COMPUTER:
            case SCE_MODE_OU_COMPUTER:
            case SCE_MODE_LOCAL_COMPUTER:
            case SCE_MODE_REMOTE_COMPUTER:
                return m_computerModeBits;
                break;

            case SCE_MODE_REMOTE_USER:
            case SCE_MODE_LOCAL_USER:
            case SCE_MODE_DOMAIN_USER:
            case SCE_MODE_OU_USER:
                return m_userModeBits;
                break;

            default:
                return m_computerModeBits;
                break;
        }
    };

public:
    PEDITTEMPLATE GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiAirea = AREA_ALL, DWORD *idErr = NULL);
    BOOL RemovePolicyEntries(PEDITTEMPLATE pet);
    HRESULT ReloadLocation(CFolder *pFolder);
    void DeleteTemplate(CString infFile);
    static BOOL LoadResources();
    void LoadSadInfo(BOOL bRequireAnalysis);
    void UnloadSadInfo();
    void RefreshSadInfo(BOOL fRemoveAnalDlg = TRUE);
    BOOL GetSadLoaded() { return SadLoaded; };
    PVOID GetSadHandle() { return SadHandle; };
    BOOL GetSadTransStarted() { return SadTransStarted; };
    void SetSadTransStarted(BOOL bTrans) { SadTransStarted = bTrans; };
    BOOL EngineTransactionStarted();
    BOOL EngineCommitTransaction();
    BOOL EngineRollbackTransaction();
    HRESULT AddDsObjectsToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType, LPTSTR InfFile);
    HRESULT AddAnalysisFilesToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType);
    HRESULT AddAnalysisFolderToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType);
    HRESULT UpdateScopeResultObject(LPDATAOBJECT pDataObj,MMC_COOKIE cookie, AREA_INFORMATION area);

    void AddPopupDialog(LONG_PTR nID, CDialog *pDlg);
    CDialog *GetPopupDialog(LONG_PTR nID);
    void RemovePopupDialog(LONG_PTR nID);

    CDialog *
    MatchNextPopupDialog(
        POSITION &pos,
        LONG_PTR priKey,
        LONG_PTR *thisPos
        );

    PSCE_COLINFOARRAY GetColumnInfo( FOLDER_TYPES pType );
    void SetColumnInfo( FOLDER_TYPES pType, PSCE_COLINFOARRAY pInfo);
    DWORD SerializeColumnInfo(IStream *pStm, ULONG *pTotalWrite, BOOL bRead);
    void CloseAnalysisPane();
    BOOL LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg = TRUE);
    HWND GetParentWindow() { return m_hwndParent; }
    LPNOTIFY GetNotifier() { return m_pNotifier; }

    DWORD UpdateObjectStatus( CFolder *pParent, BOOL bUpdateThis = FALSE );

    int
    RefreshAllFolders();

public:
   //
   // Information functions.
   //
   CFolder *GetAnalFolder()
      { return m_AnalFolder; };

   LPCONSOLENAMESPACE GetNameSpace()
      { return m_pScope; };

   DWORD GetComponentMode()
      { return m_Mode; };

   LPCONSOLE GetConsole()
      { return m_pConsole; };

   CWMIRsop * GetWMIRsop() {
      if (!m_pWMIRsop) {
         m_pWMIRsop = new CWMIRsop(m_pRSOPInfo);
      }
      return m_pWMIRsop;
   }

   void
   SetErroredLogFile( LPCTSTR pszFileName, LONG dwPosLow = 0);

   LPCTSTR GetErroredLogFile( LONG *dwPosLow = NULL)
      { if(dwPosLow) *dwPosLow = m_ErroredLogPos; return m_pszErroredLogFile; };

   void SetFlags( DWORD dwFlags, DWORD dwMask = -1)
      { m_dwFlags = dwFlags | (dwMask & m_dwFlags); };
public:
   //
   // UI add function helpers
   //
   HRESULT
   GetAddObjectSecurity(                  // Gets valid object security settings
      HWND hwndParent,
      LPCTSTR strFile,
      BOOL bContainer,
      SE_OBJECT_TYPE SeType,
      PSECURITY_DESCRIPTOR &pSelSD,
      SECURITY_INFORMATION &SelSeInfo,
      BYTE &ConfigStatus
      );

   BOOL GetWorkingDir(
      GWD_TYPES uIDDir,
      LPTSTR *pStr,
      BOOL bSet   = FALSE,
      BOOL bFile  = FALSE
      );
public:
    DWORD GetGroupMode();
   enum {
      flag_showLogFile  = 0x00000001
   };
   LPRSOPINFORMATION m_pRSOPInfo;

private:
    bool                   m_bEnumerateScopePaneCalled;
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;

    BOOL                    m_bIsDirty;
    BOOL                    m_bIsLocked;

    CString                 SadName;
    CString                 SadDescription;
    CString                 SadAnalyzeStamp;
    CString                 SadConfigStamp;
    BOOL                    SadLoaded;
    SCESTATUS               SadErrored;
    PVOID                   SadHandle;
    BOOL                    SadTransStarted;
    DWORD                   m_nNewTemplateIndex;
    DWORD                   m_Mode;         // The Mode we are in
    DWORD                   m_computerModeBits;     // Bits describing functionality changes in this mode
    DWORD                   m_userModeBits;     // Bits describing functionality changes in this mode
    // The name of the template file for MB_SINGLE_TEMPLATE_ONLY modes
    LPTSTR                  m_szSingleTemplateName;
    BOOL                    m_bDeleteSingleTemplate; // True if we need to delete the template on exit

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
    void AddScopeItemToResultPane(MMC_COOKIE cookie);
    HRESULT AddAttrPropPages(LPPROPERTYSHEETCALLBACK lpProvider,CFolder *pFolder,LONG_PTR handle);
    BOOL m_bComputerTemplateDirty;
    CMap<CString, LPCTSTR, PEDITTEMPLATE, PEDITTEMPLATE&> m_Templates;
    BOOL m_fSvcNotReady;
    HWND m_hwndParent;
    CHiddenWnd *m_pNotifier;

    CFolder * m_AnalFolder;
    CFolder * m_ConfigFolder;
    CList<CFolder*, CFolder*> m_scopeItemList;
    CMap<LONG_PTR, LONG_PTR, CDialog *, CDialog *&> m_scopeItemPopups;
    LPGPEINFORMATION m_pGPTInfo;
    CWinThread *m_pUIThread;  // The thread that creates dialog boxes for this component data item

    CString m_strDisplay;     // The static display string used for GetDisplayInfo
    CString m_strTempFile;    // The temporary file name to delete for HTML error pages
    LPTSTR  m_pszErroredLogFile;        // Error log.
    LONG    m_ErroredLogPos;            // The last write position of the error log file.
    DWORD   m_dwFlags;

    CMap<FOLDER_TYPES, FOLDER_TYPES, PSCE_COLINFOARRAY, PSCE_COLINFOARRAY&> m_mapColumns;
    CMap<UINT, UINT, LPTSTR, LPTSTR&> m_aDirs;
    CWMIRsop *m_pWMIRsop;

    CRITICAL_SECTION csAnalysisPane;
    BOOL m_bCriticalSet;
};

//
// define classes for differnt class IDs
//
#define SCE_IMPL_TYPE_EXTENSION     1
#define SCE_IMPL_TYPE_SCE           2
#define SCE_IMPL_TYPE_SAV           3
#define SCE_IMPL_TYPE_LS            4
#define SCE_IMPL_TYPE_RSOP          4

// extension snapin implementation
class CComponentDataExtensionImpl : public CComponentDataImpl,
                                   // public ISnapinHelp,
                                    public CComCoClass<CComponentDataExtensionImpl, &CLSID_Snapin>
{
//BEGIN_COM_MAP(CComponentDataExtensionImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.Extension.1"), _T("Wsecedit.Extension"), IDS_EXTENSION_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_EXTENSION; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// RSOP extension snapin implementation
class CComponentDataRSOPImpl : public CComponentDataImpl,
                                    public CComCoClass<CComponentDataRSOPImpl, &CLSID_RSOPSnapin>
{
//BEGIN_COM_MAP(CComponentDataRSOPImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.RSOP.1"), _T("Wsecedit.RSOP"), IDS_RSOP_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_RSOPSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_RSOP; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};


// SCE standalone snapin implementation
class CComponentDataSCEImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataSCEImpl, &CLSID_SCESnapin>
{
//BEGIN_COM_MAP(CComponentDataSCEImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.SCE.1"), _T("Wsecedit.SCE"), IDS_SCE_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_SCESnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_SCE; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// SAV standalone snapin implementation
class CComponentDataSAVImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataSAVImpl, &CLSID_SAVSnapin>
{
//BEGIN_COM_MAP(CComponentDataSAVImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.SAV.1"), _T("Wsecedit.SAV"), IDS_SAV_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_SAVSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_SAV; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// LS standalone snapin implementation
class CComponentDataLSImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataLSImpl, &CLSID_LSSnapin>
{
//BEGIN_COM_MAP(CComponentDataLSImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.LS.1"), _T("Wsecedit.LS"), IDS_LS_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_LSSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_LS; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};


class CSnapin :
    public IComponent,
    public IExtendContextMenu,   // Step 3
    public IExtendPropertySheet,
    public IExtendControlbar,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
    CSnapin();
    virtual ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    friend class CComponentDataImpl;
    static long lDataObjectRefCount;
    static CList<CResult*, CResult*> m_PropertyPageList;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, LONG* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, MMC_COOKIE arg, MMC_COOKIE param);

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);
    int GetImplType()
    {
        CComponentDataImpl *pData =
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->GetImplType();

        return 0;
    }

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(LPDATAOBJECT pDataObj, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject,LPARAM data, LPARAM hint);
    HRESULT OnDeleteObjects(LPDATAOBJECT lpDataObject,DATA_OBJECT_TYPES cctType, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
// IExtendContextMenu
public:
    PEDITTEMPLATE GetTemplate(LPCTSTR szInfFile, AREA_INFORMATION aiArea = AREA_ALL,DWORD *idErr = NULL);
    PSCE_PROFILE_INFO GetBaseInfo(PSCE_PROFILE_INFO *pBaseInfo, DWORD dwArea, PSCE_ERROR_LOG_INFO *ErrBuf =NULL );
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helper functions
protected:
    CResult* FindResult(MMC_COOKIE cookie, POSITION* thePos);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    void EnumerateResultPane(MMC_COOKIE cookie, HSCOPEITEM pParent, LPDATAOBJECT pDataObj);
    void CreateProfileResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj);
    void CreateLocalPolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pLocal, PEDITTEMPLATE pEffective,LPDATAOBJECT pDataObj);
    void CreateObjectResultList(MMC_COOKIE cookie, FOLDER_TYPES type, AREA_INFORMATION Area,
                               PSCE_OBJECT_CHILDREN pObjList, PVOID pHandle,
                               LPDATAOBJECT pDataObj );
    void CreateProfServiceResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisServiceResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,
                                   LPDATAOBJECT pDataObj );

    void DeleteServiceResultList(MMC_COOKIE);
    HRESULT EditThisService(CResult *pData, MMC_COOKIE cookie, RESULT_TYPES rsltType, HWND hwndParent);
    HRESULT GetDisplayInfoForServiceNode(RESULTDATAITEM *pResult, CFolder *pFolder, CResult *pData);
    void DeleteList(BOOL bDeleteResultItem);

    void CreateProfilePolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisPolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj );
    void CreateProfileRegValueList(MMC_COOKIE cookie, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj );
    void CreateAnalysisRegValueList(MMC_COOKIE cookie, PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj,RESULT_TYPES type );
    HRESULT EditThisRegistryValue(CResult *pData, MMC_COOKIE cookie, RESULT_TYPES rsltType);
    HRESULT AddAttrPropPages(LPPROPERTYSHEETCALLBACK lpProvider,CResult *pResult,LONG_PTR handle);

// Result pane helpers
public:
    void SetupLinkServiceNodeToBase(BOOL bAdd, LONG_PTR theNode);
    void AddServiceNodeToProfile(PSCE_SERVICES pNode);
    int SetAnalysisInfo(ULONG_PTR dwItem, ULONG_PTR dwNew, CResult *pResult = NULL);
    int SetLocalPolInfo(ULONG_PTR dwItem, ULONG_PTR dwNew);
    void TransferAnalysisName(LONG_PTR dwItem);
    BOOL UpdateLocalPolRegValue( CResult * );
    LPTSTR GetAnalTimeStamp();

    CResult * AddResultItem(LPCTSTR Attrib, LONG_PTR setting, LONG_PTR base,
                       RESULT_TYPES type, int status,MMC_COOKIE cookie,
                       BOOL bVerify = FALSE, LPCTSTR unit = NULL, LONG_PTR nID = -1,
                       PEDITTEMPLATE pBaseInfo = NULL,
                       LPDATAOBJECT pDataObj = NULL,
                       CResult *pResult = NULL,
                       long hID = 0);

    CResult * AddResultItem(UINT rID, LONG_PTR setting, LONG_PTR base,
                       RESULT_TYPES type, int status, MMC_COOKIE cookie,
                       BOOL bVerify = FALSE, PEDITTEMPLATE pBaseInfo = NULL,
                       LPDATAOBJECT pDataObj = NULL, long hID = 0);

    void AddResultItem(LPCTSTR szName,PSCE_GROUP_MEMBERSHIP grpTemplate,
                       PSCE_GROUP_MEMBERSHIP grpInspect,MMC_COOKIE cookie,
                       LPDATAOBJECT pDataObj);

    HRESULT InitializeBitmaps(MMC_COOKIE cookie);
    HWND GetParentWindow() { return m_hwndParent; }

    BOOL CheckEngineTransaction();

// UI Helpers
    void HandleStandardVerbs(LPARAM arg, LPDATAOBJECT lpDataObject);

    void GetHelpTopic(long itemID, CString& helpTopic);

public:
    LPCONSOLE
    GetConsole()
        { return m_pConsole; };

    DWORD
    UpdateAnalysisInfo(                        // Effects priviledge areas only.
        CResult *pResult,
        BOOL bDelete,
        PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
        LPCTSTR pszName = NULL
        );
   DWORD
    UpdateLocalPolInfo(                        // Effects priviledge areas only.
        CResult *pResult,
        BOOL bDelete,
        PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
        LPCTSTR pszName = NULL
        );

   DWORD
   GetResultItemIDs(
      CResult *pResult,
      HRESULTITEM *pIDArray,
      int nIDArray
      );

   LPRESULTDATA
   GetResultPane()
      { return m_pResult; };

    CFolder* GetSelectedFolder()
    { 
       return m_pSelectedFolder; 
    };

    DWORD GetModeBits() 
    {
        switch (((CComponentDataImpl *)m_pComponentData)->m_Mode)
        {
            case SCE_MODE_DOMAIN_COMPUTER:
            case SCE_MODE_OU_COMPUTER:
            case SCE_MODE_LOCAL_COMPUTER:
            case SCE_MODE_REMOTE_COMPUTER:
                return ((CComponentDataImpl *)m_pComponentData)->m_computerModeBits;
                break;

            case SCE_MODE_REMOTE_USER:
            case SCE_MODE_LOCAL_USER:
            case SCE_MODE_DOMAIN_USER:
            case SCE_MODE_OU_USER:
                return ((CComponentDataImpl *)m_pComponentData)->m_userModeBits;
                break;

            default:
                return ((CComponentDataImpl *)m_pComponentData)->m_computerModeBits;
                break;
        }
    }

   CWMIRsop* GetWMIRsop() 
   {
      return ((CComponentDataImpl *)m_pComponentData)->GetWMIRsop();
   }

   LPCONSOLEVERB GetConsoleVerb() {return m_pConsoleVerb;};
   void AddPropertyPageRef(CResult* pData);
   void ReleasePropertyPage(CResult* pData);
   long GetUserRightAssignmentItemID(LPCWSTR szItem);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LPTSTR              m_szAnalTimeStamp;

    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_multistrDisplay;
    CString m_colName;      // Name
    CString m_colDesc;      // Description
    CString m_colAttr;      // Attribute
    CString m_colBaseAnalysis;      // Baseline setting for Analysis
    CString m_colBaseTemplate;      // Baseline setting for Template
    CString m_colLocalPol; // Local policy setting
    CString m_colSetting;   // Current Setting

// result data
private:
    HINSTANCE hinstAclUI;
    //CList<CResult*, CResult*> m_resultItemList;
    CMap<LONG_PTR, LONG_PTR, CAttribute *, CAttribute *&> m_resultItemPopups;
    CMap<LONG_PTR, LONG_PTR, CPropertySheet *, CPropertySheet *&> m_resultItemPropSheets;
    MMC_COOKIE m_ShowCookie;
    CWinThread *m_pUIThread;
    HWND m_hwndParent;
    CHiddenWnd *m_pNotifier;

   HANDLE   m_resultItemHandle;
   CFolder *m_pSelectedFolder;

   CString m_strDisplay;
   int m_nColumns;
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData); //Validate pData and m_pComponentData.
    ASSERT(m_pComponentData == NULL);
    if( !pData ) //Raid #550912, yanggao.
    {
       return;
    }
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));
    ASSERT(hr == S_OK);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);


void ConvertNameListToString(PSCE_NAME_LIST pList, LPTSTR *sz, BOOL fReverse=FALSE);
int GetScopeImageIndex( FOLDER_TYPES type, DWORD status = -1 );
int GetResultImageIndex( CFolder* pFolder, CResult* pResult );

// Cliboard Types
// Policy Area includes the Privileges Area
#define CF_SCE_ACCOUNT_AREA TEXT("CF_SCE_ACCOUNT_AREA")
#define CF_SCE_EVENTLOG_AREA TEXT("CF_SCE_EVENTLOG_AREA")
#define CF_SCE_LOCAL_AREA TEXT("CF_SCE_LOCAL_AREA")
#define CF_SCE_GROUPS_AREA TEXT("CF_SCE_GROUPS_AREA")
#define CF_SCE_REGISTRY_AREA TEXT("CF_SCE_REGISTRY_AREA")
#define CF_SCE_FILE_AREA TEXT("CF_SCE_FILE_AREA")
#define CF_SCE_SERVICE_AREA TEXT("CF_SCE_SERVICE_AREA")

extern UINT cfSceAccountArea;           // in snapmgr.cpp
extern UINT cfSceEventLogArea;           // in snapmgr.cpp
extern UINT cfSceLocalArea;           // in snapmgr.cpp
extern UINT cfSceGroupsArea;           // in snapmgr.cpp
extern UINT cfSceRegistryArea;         // in snapmgr.cpp
extern UINT cfSceFileArea;             // in snapmgr.cpp
extern UINT cfSceServiceArea;          // in snapmgr.cpp

extern SCE_COLUMNINFO g_columnInfo[];   // Default column information.

#define MB_NO_NATIVE_NODES       0x00000001
#define MB_SINGLE_TEMPLATE_ONLY  0x00000002
#define MB_DS_OBJECTS_SECTION    0x00000004
#define MB_NO_TEMPLATE_VERBS     0x00000008
#define MB_STANDALONE_NAME       0x00000010
#define MB_WRITE_THROUGH         0x00000020
#define MB_ANALYSIS_VIEWER       0x00000040
#define MB_TEMPLATE_EDITOR       0x00000080
#define MB_LOCAL_POLICY          0x00000100
#define MB_GROUP_POLICY          0x00000200
#define MB_LOCALSEC              0x00000400
#define MB_READ_ONLY             0x00000800
#define MB_RSOP                  0x00001000

#define GT_COMPUTER_TEMPLATE (TEXT("[[ Computer Template (not for display) ]]"))
#define GT_LAST_INSPECTION (TEXT("[[ Last Inspected Template (not for display) ]]"))
#define GT_LOCAL_POLICY (TEXT("[[ Local Policy Template (not for display) ]]"))
#define GT_LOCAL_POLICY_DELTA (TEXT("[[ Local Policy Template Changes (not for display) ]]"))
#define GT_EFFECTIVE_POLICY (TEXT("[[ Effective Policy Template (not for display) ]]"))
#define GT_DEFAULT_TEMPLATE (TEXT("[[ Default Template (not for display) ]]"))
#define GT_RSOP_TEMPLATE (TEXT("[[ RSOP Template (not for display) ]]"))

#define SCE_REGISTRY_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit")
#define SCE_REGISTRY_DEFAULT_TEMPLATE TEXT("DefaultTemplate")

#define DEFAULT_LOCATIONS_KEY SCE_REGISTRY_KEY TEXT("\\DefaultLocations")
#define CONFIGURE_LOG_LOCATIONS_KEY TEXT("ConfigureLog")
#define ANALYSIS_LOG_LOCATIONS_KEY TEXT("AnalysisLog")
#define OPEN_DATABASE_LOCATIONS_KEY TEXT("Database")
#define IMPORT_TEMPLATE_LOCATIONS_KEY TEXT("ImportTemplate")
#define EXPORT_TEMPLATE_LOCATIONS_KEY TEXT("ExportTemplate")

#endif // !WSECMGR_SNAPMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef STDAFX_H
#define STDAFX_H

#pragma warning(push,3)

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <atlbase.h>
#include <afxdlgs.h>
#include <afxole.h>
#include <shlobj.h>
#include <tchar.h>
#include "resource.h"
//#include <xstring>
#include <list>
#include <vector>
#include <algorithm>
#include <functional>
#include <string>

#include <dsgetdc.h>
#include <sceattch.h>
#include <io.h>
#include <basetsd.h>
#include <lm.h>
#include <shlwapi.h>
#include <shlwapip.h>

using namespace std;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

/* Bug 424909, Yanggao, 6/29/2001
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>

extern"C" {

#include <wtypes.h>
#include <ntsecapi.h>
#include <secedit.h>
#include "edittemp.h"
#include <scesvc.h>
#include <compuuid.h> // UUIDS for computer management

#include "hlpids.h"
#include "hlparray.h"

#include <stdlib.h>
#include <wbemidl.h>
#include <aclapi.h>
#include <activeds.h>
#include <sddl.h>
#include <winldap.h>
#include <afxmt.h>

}
#include <comdef.h>
#include <accctrl.h>
#include <dssec.h>
#include <gpedit.h>
#include <objsel.h>
#include <aclui.h>

// for theme-enabling
#include <shfusion.h>

#include "debug.h"

#pragma warning(pop)

const long UNINITIALIZED = -1;

// This should be in secedit.h, but isn't
// is now! const SCE_FOREVER_VALUE = -1;

// Security Area types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
    ROOT,
    ANALYSIS,
    CONFIGURATION,
    LOCATIONS,
    PROFILE,
    LOCALPOL,
    AREA_POLICY,
    POLICY_ACCOUNT,
    POLICY_LOCAL,
    POLICY_EVENTLOG,
    POLICY_PASSWORD,
    POLICY_KERBEROS,
    POLICY_LOCKOUT,
    POLICY_AUDIT,
    POLICY_OTHER,
    POLICY_LOG,
    AREA_PRIVILEGE,
    AREA_GROUPS,
    AREA_SERVICE,
    AREA_DS, //Raid 463177, Yang Gao, This is not used in XP. But it is for compatibility with W2K.
    AREA_REGISTRY,
    AREA_FILESTORE,
    AREA_POLICY_ANALYSIS,
    POLICY_ACCOUNT_ANALYSIS,
    POLICY_LOCAL_ANALYSIS,
    POLICY_EVENTLOG_ANALYSIS,
    POLICY_PASSWORD_ANALYSIS,
    POLICY_KERBEROS_ANALYSIS,
    POLICY_LOCKOUT_ANALYSIS,
    POLICY_AUDIT_ANALYSIS,
    POLICY_OTHER_ANALYSIS,
    POLICY_LOG_ANALYSIS,
    AREA_PRIVILEGE_ANALYSIS,
    AREA_GROUPS_ANALYSIS,
    AREA_SERVICE_ANALYSIS ,
    AREA_DS_ANALYSIS, //Raid 463177, Yang Gao, This is not used in XP. But it is for compatibility with W2K.
    AREA_REGISTRY_ANALYSIS,
    AREA_FILESTORE_ANALYSIS ,
    REG_OBJECTS,
    FILE_OBJECTS,
    DS_OBJECTS, //Raid 463177, Yang Gao, This is not used in XP. But it is for compatibility with W2K.
    AREA_LOCALPOL,
    LOCALPOL_ACCOUNT,
    LOCALPOL_LOCAL,
    LOCALPOL_EVENTLOG,
    LOCALPOL_PASSWORD,
    LOCALPOL_KERBEROS,
    LOCALPOL_LOCKOUT,
    LOCALPOL_AUDIT,
    LOCALPOL_OTHER,
    LOCALPOL_LOG,
    LOCALPOL_PRIVILEGE,
    LOCALPOL_LAST,
    AREA_LAST,
    NONE = 0xFFFF
};

enum RESULT_TYPES
{
    ITEM_FIRST_POLICY = 0x8000,
    ITEM_BOOL,
    ITEM_DW,
    ITEM_SZ,
    ITEM_RET,
    ITEM_BON,
    ITEM_B2ON,
    ITEM_REGCHOICE,
    ITEM_REGFLAGS,
    ITEM_REGVALUE,

    ITEM_PROF_BOOL,
    ITEM_PROF_DW,
    ITEM_PROF_SZ,
    ITEM_PROF_RET,
    ITEM_PROF_BON,
    ITEM_PROF_B2ON,
    ITEM_PROF_REGCHOICE,
    ITEM_PROF_REGFLAGS,
    ITEM_PROF_REGVALUE,

    ITEM_LOCALPOL_BOOL,
    ITEM_LOCALPOL_DW,
    ITEM_LOCALPOL_SZ,
    ITEM_LOCALPOL_RET,
    ITEM_LOCALPOL_BON,
    ITEM_LOCALPOL_B2ON,
    ITEM_LOCALPOL_REGCHOICE,
    ITEM_LOCALPOL_REGFLAGS,
    ITEM_LOCALPOL_REGVALUE,
    ITEM_LAST_POLICY,

    ITEM_LOCALPOL_PRIVS,
    ITEM_PROF_PRIVS,
    ITEM_PRIVS,

    ITEM_GROUP,
    ITEM_GROUP_MEMBERS,
    ITEM_GROUP_MEMBEROF,
    ITEM_GROUPSTATUS,
    ITEM_PROF_GROUP,
    ITEM_PROF_GROUPSTATUS,

    ITEM_REGSD,
    ITEM_PROF_REGSD,

    ITEM_FILESD,
    ITEM_PROF_FILESD,

    ITEM_PROF_SERV,
    ITEM_ANAL_SERV,

    ITEM_OTHER = 0xFFFF
};

enum EVENT_TYPES
{
   EVENT_TYPE_SYSTEM = 0,
   EVENT_TYPE_SECURITY = 1,
   EVENT_TYPE_APP = 2,
};

enum POLICY_SETTINGS {
   AUDIT_SUCCESS = 1,
   AUDIT_FAILURE = 2,
};

enum RETENTION {
   SCE_RETAIN_AS_NEEDED = 0,
   SCE_RETAIN_BY_DAYS = 1,
   SCE_RETAIN_MANUALLY = 2,
};

enum GWD_TYPES {
   GWD_CONFIGURE_LOG = 1,
   GWD_ANALYSIS_LOG,
   GWD_OPEN_DATABASE,
   GWD_IMPORT_TEMPLATE,
   GWD_EXPORT_TEMPLATE
};

// Note - This is the offset in my image list that represents the folder
#define IMOFFSET_MISMATCH     1
#define IMOFFSET_GOOD         2
#define IMOFFSET_NOT_ANALYZED 3
#define IMOFFSET_ERROR        4

const CONFIG_LOCAL_IDX        = 0;
const MISMATCH_LOCAL_IDX      = 1;
const MATCH_LOCAL_IDX         = 2;
const CONFIG_ACCOUNT_IDX      = 5;
const MISMATCH_ACCOUNT_IDX    = 6;
const MATCH_ACCOUNT_IDX       = 7;
const CONFIG_FILE_IDX         = 10;
const MISMATCH_FILE_IDX       = 11;
const MATCH_FILE_IDX          = 12;
const FOLDER_IMAGE_IDX        = 15;
const MISMATCH_FOLDER_IDX     = 16;
const MATCH_FOLDER_IDX        = 17;
const CONFIG_GROUP_IDX        = 20;
const MISMATCH_GROUP_IDX      = 21;
const MATCH_GROUP_IDX         = 22;
const CONFIG_REG_IDX          = 25;
const MISMATCH_REG_IDX        = 26;
const MATCH_REG_IDX           = 27;
const CONFIG_SERVICE_IDX      = 30;
const MISMATCH_SERVICE_IDX    = 31;
const MATCH_SERVICE_IDX       = 32;
const CONFIG_POLICY_IDX       = 35;
const MISMATCH_POLICY_IDX     = 36;
const MATCH_POLICY_IDX        = 37;
const BLANK_IMAGE_IDX         = 45;
const SCE_OK_IDX              = 46;
const SCE_CRITICAL_IDX        = 47;
const SCE_IMAGE_IDX           = 50;
const CONFIG_FOLDER_IDX       = 51;
const TEMPLATES_IDX           = 52;
const LAST_IC_IMAGE_IDX       = 53;
const OPEN_FOLDER_IMAGE_IDX   = 54;
const LOCALSEC_POLICY_IDX     = CONFIG_ACCOUNT_IDX;
const LOCALSEC_LOCAL_IDX      = CONFIG_LOCAL_IDX;

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

// security settings (extension of GPE)
extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// security settings (extension of RSOP)
extern const CLSID CLSID_RSOPSnapin;    // In-Proc server GUID
extern const GUID cRSOPNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszRSOPNodeType; // Main NodeType GUID on string format

// SCE (standalone)
extern const CLSID CLSID_SCESnapin;    // In-Proc server GUID
extern const GUID cSCENodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszSCENodeType; // Main NodeType GUID on string format

// SAV (standalone)
extern const CLSID CLSID_SAVSnapin;    // In-Proc server GUID
extern const GUID cSAVNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszSAVNodeType; // Main NodeType GUID on string format

// Local security (standalone)
extern const CLSID CLSID_LSSnapin;     // In-Proc server GUID
extern const GUID cLSNodeType;         // Main NodeType GUID on numeric format
extern const wchar_t*  cszLSNodeType;  // Main NodeType GUID on string format

extern const CLSID CLSID_SCEAbout;
extern const CLSID CLSID_SCMAbout;
extern const CLSID CLSID_SSAbout;
extern const CLSID CLSID_LSAbout;
extern const CLSID CLSID_RSOPAbout;

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

EXTERN_C const TCHAR SNAPINS_KEY[];
EXTERN_C const TCHAR NODE_TYPES_KEY[];
EXTERN_C const TCHAR g_szExtensions[];
EXTERN_C const TCHAR g_szNameSpace[];

struct INTERNAL
{
    INTERNAL() 
    { 
       m_type = CCT_UNINITIALIZED; 
       m_cookie = -1; 
       m_foldertype = NONE; 
    };
    virtual ~INTERNAL() 
    {
    }

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    FOLDER_TYPES        m_foldertype;
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_foldertype = rhs.m_foldertype;
        //This is a safe usage.
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_cookie == m_cookie;
    }

};

typedef struct {
   LPTSTR TemplateName;
   LPTSTR ServiceName;
} SCESVCP_HANDLE, *PSCESVCP_HANDLE;

typedef struct RegChoiceList{
   LPTSTR szName;
   DWORD dwValue;
   struct RegChoiceList *pNext;
} REGCHOICE, *PREGCHOICE, REGFLAGS, *PREGFLAGS;

// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    CString buf;
    //This is not a safe usage. Avoid using wsprintf. Raid #555867. Yanggao.
    buf.Format("%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif

// For theme-enabling
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#define SCE_MODE_DOMAIN_COMPUTER_ERROR 9999999

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif // STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include <atlimpl.cpp>

//const CLSID CLSID_Snapin = {0x18731372,0x1D79,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on numeric format
//const GUID cNodeType = {0x44092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on string format
//const wchar_t*  cszNodeType = L"{44092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"WSECMGR_INTERNAL";

const CLSID CLSID_Snapin = { 0x803e14a0, 0xb4fb, 0x11d0, { 0xa0, 0xd0, 0x0, 0xa0, 0xc9, 0xf, 0x57, 0x4b } };

// Main NodeType GUID on numeric format
const GUID cNodeType = { 0x803e14a1, 0xb4fb, 0x11d0, { 0xa0, 0xd0, 0x0, 0xa0, 0xc9, 0xf, 0x57, 0x4b } };

// Main NodeType GUID on string format
const wchar_t*  cszNodeType = L"{803E14A1-B4FB-11d0-A0D0-00A0C90F574B}";


//
// class IDs for RSOP extenstion
//

// {FE883157-CEBD-4570-B7A2-E4FE06ABE626}
const CLSID CLSID_RSOPSnapin = 
{ 0xfe883157, 0xcebd, 0x4570, { 0xb7, 0xa2, 0xe4, 0xfe, 0x6, 0xab, 0xe6, 0x26 } };


// {F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}
const GUID cRSOPNodeType = 
//{ 0xf2e29987, 0x59e0, 0x47d0, { 0xb6, 0xd1, 0x4e, 0xcd, 0x9d, 0xfb, 0xcb, 0x20 } };
cNodeType;

// {F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}
const wchar_t* cszRSOPNodeType =  //L"{F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}";
cszNodeType;

//
// class IDs for SCE (standalone)
//
const CLSID CLSID_SCESnapin = { 0x5adf5bf6, 0xe452, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SCE NodeType GUID on numeric format
const GUID cSCENodeType = { 0xe10db5c6, 0xe450, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SCE NodeType GUID on string format
const wchar_t*  cszSCENodeType = L"{E10DB5C6-E450-11D1-945A-00C04FB984F9}";

// {2AABFCD0-1797-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SCEAbout =
{ 0x2aabfcd0, 0x1797, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {5C0786ED-1847-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SCMAbout =
{ 0x5c0786ed, 0x1847, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {5C0786EE-1847-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SSAbout =
{ 0x5c0786ee, 0x1847, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {2E8EA1E5-F406-46f5-AF10-661FD6539F28}
const GUID CLSID_LSAbout =
{ 0x2e8ea1e5, 0xf406, 0x46f5, { 0xaf, 0x10, 0x66, 0x1f, 0xd6, 0x53, 0x9f, 0x28 } };

// {1B6FC61A-648A-4493-A303-A1A22B543F01}
const GUID CLSID_RSOPAbout = 
{ 0x1b6fc61a, 0x648a, 0x4493, { 0xa3, 0x3, 0xa1, 0xa2, 0x2b, 0x54, 0x3f, 0x1 } };


//
// class IDs for SAV (standalone)
//
const CLSID CLSID_SAVSnapin = { 0x011be22d, 0xe453, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SAV NodeType GUID on numeric format
const GUID cSAVNodeType = { 0xbd7d80a8, 0xe452, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SAV NodeType GUID on string format
const wchar_t*  cszSAVNodeType = L"{BD7D80A8-E452-11D1-945A-00C04FB984F9}";

//
// class IDs for Local Security Settings (standalone)
//
// {CFF49D53-EE51-49f2-A807-7E3DF4EA36E3}
const CLSID CLSID_LSSnapin = 
{ 0xcff49d53, 0xee51, 0x49f2, { 0xa8, 0x7, 0x7e, 0x3d, 0xf4, 0xea, 0x36, 0xe3 } };

const wchar_t* cszLSNodeType = L"{C935FE05-7181-4926-B5E0-7A14477F98CC}";

const GUID cLSNodeType = 
{ 0xc935fe05, 0x7181, 0x4926, { 0xb5, 0xe0, 0x7a, 0x14, 0x47, 0x7f, 0x98, 0xcc } };

const TCHAR SNAPINS_KEY[]               = TEXT("Software\\Microsoft\\MMC\\SnapIns");
const TCHAR NODE_TYPES_KEY[]            = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR g_szExtensions[]            = TEXT("Extensions");
const TCHAR g_szNameSpace[]             = TEXT("NameSpace");

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize); //This is a safe usage. PROPSHEETPAGE_V3 contains a AFX_OLDPROPSHEETPAGE member.
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\svcattch.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       svcattch.cpp
//
//  Contents:   implementation of CComponentDataImpl
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "snapmgr.h"
#include <scesvc.h>

#define TEMPLATE_MAGIC_NUMBER (DWORD)-1

/*-------------------------------------------------------------------------------
This is a private structure used for SceSvcQueryInfo it expects the handle to
be one step above what it is now.
-------------------------------------------------------------------------------*/
typedef struct _tag_SCEP_HANDLE
{
    LPVOID hProfile;    // SCE_HANDLE
    PWSTR ServiceName;      // Service name.
} SCEP_HANDLE, *LPSCEP_HANDLE;


STDMETHODIMP
CComponentDataImpl::GetData (SCESVC_HANDLE sceHandle,
                             SCESVC_INFO_TYPE sceType,
                  PVOID *ppvData,
                  PSCE_ENUMERATION_CONTEXT psceEnumHandle) {
   SCESTATUS status;
   SCESVCP_HANDLE *scesvcHandle;

//   if (m_fSvcNotReady) {
//      return E_PENDING;
//   }

   if (!sceHandle) {
      return E_INVALIDARG;
   }

   if (!ppvData) {
      return E_POINTER;
   }

   scesvcHandle = (SCESVCP_HANDLE *) sceHandle;
   if (!scesvcHandle->ServiceName) {
      return E_INVALIDARG;
   }

   if (scesvcHandle->TemplateName &&
       lstrcmp(GT_COMPUTER_TEMPLATE, scesvcHandle->TemplateName) != 0 ) {

      if (psceEnumHandle &&
          *psceEnumHandle == TEMPLATE_MAGIC_NUMBER) {
         *ppvData = NULL;
         status = SCESTATUS_SUCCESS;
      } else {
         if (psceEnumHandle) {
            *psceEnumHandle = TEMPLATE_MAGIC_NUMBER;
         }
         status = SceSvcGetInformationTemplate(scesvcHandle->TemplateName,
                                            scesvcHandle->ServiceName,
                                            0,
                                            (PSCESVC_CONFIGURATION_INFO *) ppvData);
      }
   } else {
       //
       // This structure needs to be sent to SceSvcQueryInfo;
       //
       SCEP_HANDLE hScep;
       ZeroMemory(&hScep, sizeof(SCEP_HANDLE));
       hScep.hProfile = SadHandle;
       hScep.ServiceName = scesvcHandle->ServiceName;

       status = SceSvcQueryInfo((SCE_HANDLE)&hScep,sceType,0,0,ppvData,psceEnumHandle);
   }

   if (SCESTATUS_SUCCESS == status) {
      return S_OK;
   } else {
      return E_FAIL;
   }
}

STDMETHODIMP
CComponentDataImpl::Initialize(LPCTSTR ServiceName,
                    LPCTSTR TemplateName,
                    LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
                    SCESVC_HANDLE *sceHandle) {
   SCESVCP_HANDLE *scesvcHandle;
   CEditTemplate *pET;

   ASSERT(ServiceName);
   ASSERT(lpSceSvcPersistInfo);
   ASSERT(sceHandle);

   if (!ServiceName || !lpSceSvcPersistInfo || !sceHandle) {
      return E_POINTER;
   }

   *sceHandle = NULL;

   //
   // Cache Service & Template -> lpUnknown.
   //
   if (TemplateName && lstrlen(TemplateName)) {
      //
      // If TemplateName is not NULL then find the template and store it there
      //
      pET = GetTemplate(TemplateName);
      if (!pET) {
         return E_FAIL;
      }
      pET->AddService(ServiceName,lpSceSvcPersistInfo);
   } else {
      return E_INVALIDARG;
   }

   // Open & retrieve SCE_HANDLE
   scesvcHandle = new SCESVCP_HANDLE;
   if (!scesvcHandle) {
      return E_OUTOFMEMORY;
   }
   scesvcHandle->ServiceName = new TCHAR [ lstrlen(ServiceName)+1 ];
   if (!scesvcHandle->ServiceName) {
      delete scesvcHandle;
      return E_OUTOFMEMORY;
   }
   //This is a safe usage.
   lstrcpy(scesvcHandle->ServiceName,ServiceName);
   if (TemplateName) {
      scesvcHandle->TemplateName = new TCHAR [ lstrlen(TemplateName)+1 ];
      if (!scesvcHandle->TemplateName) {
         delete [] scesvcHandle->ServiceName;
         delete scesvcHandle;
         return E_OUTOFMEMORY;
      }
      //This is a safe usage.
      lstrcpy(scesvcHandle->TemplateName,TemplateName);
   } else {
      scesvcHandle->TemplateName = NULL;
   }
   *sceHandle = (SCESVC_HANDLE *) scesvcHandle;

   return S_OK;
}

STDMETHODIMP
CComponentDataImpl::FreeBuffer(PVOID pvData) {
   HRESULT hr;

   if (!pvData) {
      hr =  E_POINTER;
   } else if (SCESTATUS_SUCCESS == SceSvcFree(pvData)) {
      hr = S_OK;
   } else {
      hr = E_FAIL;
   }

   return hr;
}

STDMETHODIMP
CComponentDataImpl::CloseHandle(SCESVC_HANDLE sceHandle) {
   HRESULT hr;
   PSCESVCP_HANDLE pHandle;

   if (sceHandle) {
      pHandle = (PSCESVCP_HANDLE) sceHandle;
      // Free the handle
      if (pHandle->TemplateName) {
         delete[] pHandle->TemplateName;
      }
      delete[] pHandle->ServiceName;
      delete pHandle;
      hr =  S_OK;
   } else {
      hr =  E_INVALIDARG;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\uithread.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       uithread.cpp
//
//  Contents:   implementation of CUIThread
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include <accctrl.h>
#include "servperm.h"
#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "UIThread.h"
#include "attr.h"
#include "aaudit.h"
#include "aenable.h"
#include "AMember.h"
#include "anumber.h"
#include "AObject.h"
#include "ARet.h"
#include "ARight.h"
#include "aservice.h"
#include "astring.h"
#include "CAudit.h"
#include "CEnable.h"
#include "CGroup.h"
#include "CName.h"
#include "CNumber.h"
#include "cobject.h"
#include "CPrivs.h"
#include "CRet.h"
#include "cservice.h"
#include "regvldlg.h"
#include "perfanal.h"
#include "applcnfg.h"
#include "wrapper.h"
#include "locdesc.h"
#include "profdesc.h"
#include "newprof.h"
#include "laudit.h"
#include "lenable.h"
#include "lret.h"
#include "lnumber.h"
#include "lstring.h"
#include "lright.h"
#include "achoice.h"
#include "cchoice.h"
#include "lchoice.h"
#include "dattrs.h"
#include "lflags.h"
#include "aflags.h"
#include "multisz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUIThread

IMPLEMENT_DYNCREATE(CUIThread, CWinThread)

CUIThread::CUIThread()
{
}

CUIThread::~CUIThread()
{
}

BOOL CUIThread::InitInstance()
{
   // TODO:  perform and per-thread initialization here
   return TRUE;
}

int CUIThread::ExitInstance()
{
   // TODO:  perform any per-thread cleanup here
   return CWinThread::ExitInstance();
}

BEGIN_MESSAGE_MAP(CUIThread, CWinThread)
   //{{AFX_MSG_MAP(CUIThread)
      // NOTE - the ClassWizard will add and remove mapping macros here.
   //}}AFX_MSG_MAP
   ON_THREAD_MESSAGE( SCEM_APPLY_PROFILE, OnApplyProfile)
   ON_THREAD_MESSAGE( SCEM_ANALYZE_PROFILE, OnAnalyzeProfile)
   ON_THREAD_MESSAGE( SCEM_DESCRIBE_PROFILE, OnDescribeProfile)
   ON_THREAD_MESSAGE( SCEM_DESCRIBE_LOCATION, OnDescribeLocation)
   ON_THREAD_MESSAGE( SCEM_DESTROY_DIALOG,    OnDestroyDialog)
   ON_THREAD_MESSAGE( SCEM_NEW_CONFIGURATION, OnNewConfiguration)
   ON_THREAD_MESSAGE( SCEM_ADD_PROPSHEET, OnAddPropSheet)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUIThread message handlers

//+--------------------------------------------------------------------------
//
//  Method:     DefaultLogFile
//
//  Synopsis:   Find the default log file for the inf file last applied
//  pass back the log file via the out parameter strLogFile
//
//---------------------------------------------------------------------------
void
CUIThread::DefaultLogFile(CComponentDataImpl *pCDI,GWD_TYPES LogID,LPCTSTR szBase, CString& strLogFile)
{
   //
   // Base log file on the db passed in
   //
   CString strDefExt;
   strDefExt.LoadString(IDS_LOGFILE_DEF_EXT);
   // make sure that the extension includes '.'
   if (strDefExt.GetLength() > 0 && strDefExt[0] != L'.')
   {
	   CString	tempExt = strDefExt;
	   strDefExt = L'.';
	   strDefExt += tempExt;
   }

   CString strInfFile = szBase;

   //
   // Get the default working directory
   //
   LPTSTR szDir = NULL;
   if (pCDI->GetWorkingDir(LogID,
                       &szDir,
                       FALSE,
                       FALSE)) {
      strLogFile = szDir;
      LocalFree(szDir);
      szDir = NULL;
   }

   if (strLogFile.Right(1) != TEXT("\\")) {
      strLogFile += L"\\";
   }

   if ( strInfFile.GetLength() < 5) {
     //
     // The default log file.
     //
     strLogFile += TEXT("SceStus") + strDefExt;
   } else {
      int nFilePartIndex = 0;
      int nFilePartCount = 0;
      //
      // +1 to change index base from 0 to 1 for the Mid
      //
      nFilePartIndex = strInfFile.ReverseFind(L'\\') +1;
      nFilePartCount = strInfFile.ReverseFind(L'.') - nFilePartIndex;
      strLogFile += strInfFile.Mid(nFilePartIndex,nFilePartCount) + strDefExt;
   }
}
//+--------------------------------------------------------------------------
//
//  Method:     OnApplyProfile
//
//  Synopsis:   Create and display a dialog for applying a profile to the
//              system
//
//  Arguments:  [uParam] - A string with the name of the database to assign to
//              [lParam] - A pointer to the CComponentDataImpl
//
//---------------------------------------------------------------------------
void
CUIThread::OnApplyProfile(WPARAM uParam, LPARAM lParam) {
   CComponentDataImpl *pCDI = NULL;
   CApplyConfiguration *pAP = NULL;
   CWnd cwndParent;

   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pAP = (CApplyConfiguration *)pCDI->GetPopupDialog(IDM_APPLY);
   if (NULL == pAP) {
      pAP = new CApplyConfiguration;
      if (NULL == pAP) {
         return;
      }
      pCDI->AddPopupDialog(IDM_APPLY,pAP);
   }

   pAP->m_strDataBase = reinterpret_cast<LPCTSTR>(uParam);
   DefaultLogFile(pCDI,GWD_CONFIGURE_LOG, pAP->m_strDataBase, pAP->m_strLogFile);
   pAP->SetComponentData(pCDI);

   if (!pAP->GetSafeHwnd()) 
   {
      cwndParent.Attach(pCDI->GetParentWindow());

      CThemeContextActivator activator;
      pAP->Create(IDD_APPLY_CONFIGURATION,&cwndParent);
      cwndParent.Detach();
   }

   pAP->UpdateData(FALSE);
   pAP->BringWindowToTop();
   pAP->ShowWindow(SW_SHOWNORMAL);
}

//+--------------------------------------------------------------------------
//
//  Method:     OnAnalyzeProfile
//
//  Synopsis:   Create and display a dialog for applying a profile to the
//              system
//
//  Arguments:  [uParam] - A string with the name of the database to assign to
//              [lParam] - A pointer to the CComponentDataImpl
//
//---------------------------------------------------------------------------
void
CUIThread::OnAnalyzeProfile(WPARAM uParam, LPARAM lParam) {
   CComponentDataImpl *pCDI = NULL;
   CPerformAnalysis *pPA = NULL;
   CWnd cwndParent;

   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pPA = (CPerformAnalysis *)pCDI->GetPopupDialog(IDM_ANALYZE);
   if (NULL == pPA) {
      pPA = new CPerformAnalysis (0, 0);
      if (NULL == pPA) {
         return;
      }

      pPA->m_strDataBase = reinterpret_cast<LPCTSTR>(uParam);
      DefaultLogFile(pCDI,GWD_ANALYSIS_LOG, pPA->m_strDataBase, pPA->m_strLogFile);
      pPA->SetComponentData(pCDI);

      pCDI->AddPopupDialog(IDM_ANALYZE,pPA);
   }

   if (!pPA->GetSafeHwnd()) 
   {
      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pPA->Create(IDD_PERFORM_ANALYSIS,&cwndParent);
      cwndParent.Detach();
   }

   pPA->BringWindowToTop();
   pPA->ShowWindow(SW_SHOWNORMAL);
}


//+--------------------------------------------------------------------------
//
//  Method:     OnDescribeProfile
//
//  Synopsis:   Create and display a dialog for editing a profile's description
//
//  Arguments:  [uParam] - A pointer to the CFolder for the object
//              [lParam] - The CComponentDataImpl owning the scope pane
//
//---------------------------------------------------------------------------
void
CUIThread::OnDescribeProfile(WPARAM uParam, LPARAM lParam) 
{
   CSetProfileDescription *pSPD;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CSetProfileDescription::IDD);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pSPD = (CSetProfileDescription *)pCDI->GetPopupDialog( dwKey );
   if (NULL == pSPD) {
      pSPD = new CSetProfileDescription;
      if (NULL == pSPD) {
         return;
      }

      pCDI->AddPopupDialog( dwKey, pSPD);
   }



   if (!pSPD->GetSafeHwnd()) 
   {
      if (GetProfileDescription(pFolder->GetInfFile(),&szDesc))
         pSPD->m_strDesc = szDesc;

      pSPD->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pSPD->Create(IDD_SET_DESCRIPTION,&cwndParent);
      cwndParent.Detach();
   }

   pSPD->UpdateData(FALSE);
   pSPD->BringWindowToTop();
   pSPD->ShowWindow(SW_SHOWNORMAL);

}



//+--------------------------------------------------------------------------
//
//  Method:     OnDescribeLocation
//
//  Synopsis:   Create and display a dialog for editing a Location's description
//
//  Arguments:  [uParam] - A pointer to the CFolder for the object
//              [lParam] - The CComponentDataImpl owning the scope pane
//
//---------------------------------------------------------------------------
void
CUIThread::OnDescribeLocation(WPARAM uParam, LPARAM lParam) {
   CSetLocationDescription *pSPD;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CSetLocationDescription::IDD);


   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pSPD = (CSetLocationDescription *)pCDI->GetPopupDialog( dwKey );
   if (NULL == pSPD) {
      pSPD = new CSetLocationDescription;
      if (NULL == pSPD) {
         return;
      }
      pCDI->AddPopupDialog(dwKey ,pSPD);
   }

//   pSPD->Initialize(pFolder,pCDI);


   if (!pSPD->GetSafeHwnd()) 
   {
      pSPD->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pSPD->Create(IDD_SET_DESCRIPTION,&cwndParent);
      pSPD->SetWindowText(pFolder->GetName());
      cwndParent.Detach();
   }

   pSPD->UpdateData(FALSE);
   pSPD->BringWindowToTop();
   pSPD->ShowWindow(SW_SHOWNORMAL);

}

/*-----------------------------------------------------------------------------------
Method:     OnDestroyDialog

Synopsis:   Destroys and deletes the CAttribute object associated with [pDlg]

Arguments:  [pDlg]   - Is a pointer to the object to delete.

Histroy:
-----------------------------------------------------------------------------------*/
void CUIThread::OnDestroyDialog(WPARAM pDlg, LPARAM)
{
   if(pDlg){
      CAttribute *pAttr = reinterpret_cast<CAttribute *>(pDlg);

      delete pAttr;
   }
}


//+--------------------------------------------------------------------------
//
//  Method:     OnNewConfiguration
//
//  Synopsis:   Create and display a dialog for adding a new configuration file
//
//  Arguments:  [uParam] - A pointer to the CFolder parent of the new config file
//              [lParam] - A pointer to the CComponentDataItem
//
//---------------------------------------------------------------------------
void
CUIThread::OnNewConfiguration(WPARAM uParam, LPARAM lParam)
{
   CNewProfile *pNP;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CNewProfile::IDD);


   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pNP = (CNewProfile *)pCDI->GetPopupDialog( dwKey);
   if (NULL == pNP) {
      pNP = new CNewProfile;
      if (NULL == pNP) {
         return;
      }
      pCDI->AddPopupDialog( dwKey, pNP);
   }

//   pNP->Initialize(pFolder,pCDI);


   if (!pNP->GetSafeHwnd()) {
      pNP->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());

      CThemeContextActivator activator;
      pNP->Create(IDD_NEW_PROFILE,&cwndParent);
      pNP->SetWindowText(pFolder->GetName());
      cwndParent.Detach();
   }

   pNP->UpdateData(FALSE);
   pNP->BringWindowToTop();
   pNP->ShowWindow(SW_SHOWNORMAL);

}

//+--------------------------------------------------------------------------
// Method:     OnAddPropsheet
//
// Synopsis:   Adds a property sheet to the list of sheets to which to pass messages
//             in PreTranslateMessage
//
// Arguments:  [wParam] - HWND of the added property sheet
//             [lParam] - unused
//
//---------------------------------------------------------------------------
void CUIThread::OnAddPropSheet(WPARAM wParam, LPARAM lParam)
{
   if (IsWindow((HWND)wParam)) {
      m_PSHwnds.AddHead((HWND)wParam);
   }
}


BOOL CUIThread::PreTranslateMessage(MSG* pMsg)
{
   //
   // check PropSheet_GetCurrentPageHwnd to see if we need to destroy
   // one of our modeless property sheets
   //

   POSITION pos;
   POSITION posCur;
   HWND hwnd;

   pos= m_PSHwnds.GetHeadPosition();
   while (pos) {
      posCur = pos;
      hwnd = m_PSHwnds.GetNext(pos);

      if (!IsWindow(hwnd)) {
         m_PSHwnds.RemoveAt(posCur);
      } else if (NULL == PropSheet_GetCurrentPageHwnd(hwnd)) {
         //
         // hwnd is a closed property sheet.  destroy it and remove it from the list
         //
         DestroyWindow(hwnd);
         m_PSHwnds.RemoveAt(posCur);
      }

      if (PropSheet_IsDialogMessage(hwnd,pMsg)) {
         //
         // Message has been handled, so don't do anything else with it
         //
         return TRUE;
      }
   }

   return CWinThread::PreTranslateMessage(pMsg);
}

/////////////////////////////////////////////////////////////////////////////
// CModelessDlgUIThread implementation

IMPLEMENT_DYNCREATE(CModelessDlgUIThread, CUIThread)

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CModelessDlgUIThread::CModelessDlgUIThread()
{
    m_hReadyForMsg = ::CreateEvent(NULL, TRUE, FALSE, NULL); //This is a safe usage. It creates a unnamed event.
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CModelessDlgUIThread::~CModelessDlgUIThread()
{
    if (NULL != m_hReadyForMsg)
        ::CloseHandle(m_hReadyForMsg);
}

BEGIN_MESSAGE_MAP(CModelessDlgUIThread, CUIThread)
    //{{AFX_MSG_MAP(CModelessDlgUIThread)
       // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
    ON_THREAD_MESSAGE( SCEM_CREATE_MODELESS_SHEET, OnCreateModelessSheet)
    ON_THREAD_MESSAGE( SCEM_DESTROY_WINDOW, OnDestroyWindow)
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
int CModelessDlgUIThread::Run()
{
    if (m_hReadyForMsg)
        ::SetEvent(m_hReadyForMsg);

    return CWinThread::Run();
}

//------------------------------------------------------------------------------
// wparam is PMLSHEET_DATA, and lparam is not used and can be used in the future
// for telling what property sheet is to be created (right now, it only works
// for ACL editor)
//------------------------------------------------------------------------------
void CModelessDlgUIThread::OnCreateModelessSheet(WPARAM wparam, LPARAM lparam)
{
    PMLSHEET_DATA pSheetData = (PMLSHEET_DATA)wparam;
    if (pSheetData)
    {
        HWND hSheet = (HWND)MyCreateSecurityPage2(pSheetData->bIsContainer,
                                                pSheetData->ppSeDescriptor,
                                                pSheetData->pSeInfo,
                                                pSheetData->strObjectName,
                                                pSheetData->SeType,
                                                pSheetData->flag,
                                                pSheetData->hwndParent,
                                                TRUE);
        *(pSheetData->phwndSheet) = hSheet;

        OnAddPropSheet((WPARAM)hSheet, 0);
    }
}

//------------------------------------------------------------------------------
// wparam is the window handle and lparam is not used at this time
// Since destroying a window must happen on the thread where it is contructed,
// this is necessary. Basic window management rules must be followed, e.g.,
// don't ask this thread to destroy windows that is not created by it
//------------------------------------------------------------------------------
void CModelessDlgUIThread::OnDestroyWindow(WPARAM wparam, LPARAM lparam)
{
    if (::IsWindow((HWND)wparam))
    {
        DestroyWindow((HWND)wparam);
    }
}

//------------------------------------------------------------------------------
// immediately after this thread object is created, creating thread needs to
// wait by calling this function so that the newly created thread has a chance
// to be scheduled to run.
//------------------------------------------------------------------------------
void CModelessDlgUIThread::WaitTillRun()
{
    if (NULL != m_hReadyForMsg)
    {
        // $UNDONE:shawnwu I found that MMC runs at THREAD_PRIORITY_ABOVE_NORMAL (or higher) priority
        // becaues only when I run this UI thread at THREAD_PRIORITY_HIGHEST will this thread schedule to run.
        // But running at that level of priority makes me feel a little bit nervous. I thus
        // leave this sleep(10) code here. Up to the UI team to decide.
        ::Sleep(10);
        ::WaitForSingleObject(m_hReadyForMsg, INFINITE);        // don't care about result of this waiting
        // now the event is useless. To reduce resource overhead, close the handle
        ::CloseHandle(m_hReadyForMsg);
        m_hReadyForMsg = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\uithread.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       uithread.h
//
//  Contents:   definition of CUIThread
//
//----------------------------------------------------------------------------
#if !defined(AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "attr.h"

/////////////////////////////////////////////////////////////////////////////
// CUIThread thread
#define DLG_KEY_PRIMARY(x)   ( (PtrToUlong((PVOID)(x))) & 0x00FFFFFF )
#define DLG_KEY_SECONDARY(x) ( (PtrToUlong((PVOID)(x)) << 24 ) & 0xFF000000 )
#define DLG_KEY( x, y ) (LONG_PTR)( DLG_KEY_PRIMARY( x ) | DLG_KEY_SECONDARY(y) )

class CUIThread : public CWinThread
{
   DECLARE_DYNCREATE(CUIThread)
protected:
   CUIThread();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CUIThread)
   public:
   virtual BOOL InitInstance();
   virtual int ExitInstance();
   virtual BOOL PreTranslateMessage(MSG* pMsg);
   //}}AFX_VIRTUAL

// Implementation
protected:
   virtual ~CUIThread();

   // Generated message map functions
   //{{AFX_MSG(CUIThread)
      // NOTE - the ClassWizard will add and remove member functions here.
   //}}AFX_MSG
   afx_msg void OnApplyProfile( WPARAM, LPARAM );
   afx_msg void OnAssignProfile( WPARAM, LPARAM );
   afx_msg void OnAnalyzeProfile( WPARAM, LPARAM );
   afx_msg void OnDescribeProfile( WPARAM, LPARAM );
   afx_msg void OnDescribeLocation( WPARAM, LPARAM );
   afx_msg void OnDestroyDialog(WPARAM, LPARAM);
   afx_msg void OnNewConfiguration(WPARAM, LPARAM);
   afx_msg void OnAddPropSheet(WPARAM, LPARAM);
   DECLARE_MESSAGE_MAP()

   void DefaultLogFile(CComponentDataImpl *pCDI,GWD_TYPES LogType,LPCTSTR szBase, CString& strLogFile);


private:
   CList<HWND,HWND> m_PSHwnds;
};

// this class is created for modeless dialog's thread inside MMC
class CModelessDlgUIThread : public CUIThread
{
    DECLARE_DYNCREATE(CModelessDlgUIThread)
protected:
    CModelessDlgUIThread();  // protected constructor used by dynamic creation

// Operations
public:
    virtual ~CModelessDlgUIThread();
    void WaitTillRun();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CModelessDlgUIThread)
    public:
    virtual int Run( );
    //}}AFX_VIRTUAL

    // Generated message map functions
    //{{AFX_MSG(CModelessDlgUIThread)
       // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    afx_msg void OnCreateModelessSheet(WPARAM, LPARAM);
    afx_msg void OnDestroyWindow(WPARAM, LPARAM);
    DECLARE_MESSAGE_MAP()

private:
    HANDLE  m_hReadyForMsg;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#define SCEM_APPLY_PROFILE     (WM_APP+2)
#define SCEM_ASSIGN_PROFILE    (WM_APP+3)
#define SCEM_ANALYZE_PROFILE   (WM_APP+4)
#define SCEM_DESCRIBE_PROFILE  (WM_APP+6)
#define SCEM_DESCRIBE_LOCATION (WM_APP+7)
#define SCEM_DESTROY_DIALOG    (WM_APP+8)
#define SCEM_NEW_CONFIGURATION (WM_APP+9)
#define SCEM_ADD_PROPSHEET     (WM_APP+10)
#define SCEM_DESTROY_SCOPE_DIALOG (WM_APP+11)
#define SCEM_CREATE_MODELESS_SHEET  (WM_APP+12)
#define SCEM_DESTROY_WINDOW         (WM_APP+13)
#endif // !defined(AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\util.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       util.cpp
//
//  Contents:   Miscellaneous utility functions
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "util.h"
#include "wrapper.h"
#include "defvals.h"
#include "resource.h"
#include <io.h>
#include "snapmgr.h"
extern "C" {
#include "getuser.h"
}


#define ILLEGAL_FILENAME_CHARS   L"\"+,;<=>"
#define ILLEGAL_FILENAME_CHARS1  L"\\\\ \\/ // /\\"
#define ILLEGAL_FILENAME_CHARS2  L"\\ /"
//////////////////////////////////////////////////////////////////////////////////////////
// CWriteHmtlFile body.
//

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::CWriteHtmlFile
//
// Initialize the class.
//
//--------------------------------------------------------------------------------------------
CWriteHtmlFile::CWriteHtmlFile()
{
   m_hFileHandle = INVALID_HANDLE_VALUE;
   m_bErrored = FALSE;
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::~CWriteHtmlFile
//
// Write the end of the html file and close the handle.
//
//--------------------------------------------------------------------------------------------
CWriteHtmlFile::~CWriteHtmlFile()
{
   //
   // Close the file handle, but don't delete the HTML file, unless there was an
   // error during some write proccess.
   //
   Close(m_bErrored);
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Close
//
// Closes the HTML file handle, if [bDelete] is true then the file is deleted.
//
// Arguments:  [bDelete]  - Close and delete the file.
//
// Returns:    ERROR_SUCCESS;
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Close( BOOL bDelete )
{
   if(m_hFileHandle == INVALID_HANDLE_VALUE){
      return ERROR_SUCCESS;
   }

   if(bDelete){
      CloseHandle(m_hFileHandle);
      DeleteFile(m_strFileName );
   } else {
      Write( IDS_HTMLERR_END );
      CloseHandle( m_hFileHandle );
   }

   m_hFileHandle = INVALID_HANDLE_VALUE;
   return ERROR_SUCCESS;
}



//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::GetFileName
//
// Copies the file name associated with this class to [pstrFileName].
//
// Arguments:  [pstrFileName] - A CString object which will contain the file name
//                               on return.
//
// Returns:    0   - If Create has not been called, or the HTML file is invalid for
//                   some reason.  This could be caused by a bad write.
//             The size in characters of the file name.
//
//--------------------------------------------------------------------------------------------
int CWriteHtmlFile::GetFileName( LPTSTR pszFileName, UINT nSize )
{
   if(m_strFileName.IsEmpty() || m_hFileHandle == INVALID_HANDLE_VALUE || m_bErrored){
      return 0;
   }

   if(pszFileName && (int)nSize > m_strFileName.GetLength()){
      //This is a safe usage.
      lstrcpy(pszFileName, m_strFileName);
   }

   return m_strFileName.GetLength();
}


//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Write
//
// Writes a string resource to the html file at the current file position.
//
// Arguments:  [uRes] - The String resource to load and write to the html.
//
// Returns:    If the string can't be loaded then an error will be returned.
//             See CWriteHtmlFile::Write( LPCTSTR ) for other errors.
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Write( UINT uRes )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CString str;
   if( !str.LoadString(uRes) ){
      return GetLastError();
   }

#if defined(UNICODE) || defined(_UNICODE)
   if ( uRes == IDS_HTMLERR_HEADER ){
      WCHAR wszByteOrderMark[2] = {0xFEFF, 0x0000};
      CString strByteOrderMark = wszByteOrderMark;
      return Write( strByteOrderMark + str );
   } else
#endif
   return Write( str );
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Write
//
// Writes a string to an html file.
//
// Arguments:  [pszString] - The string to write.
//
// Returns:    ERROR_NOT_READ    - if Create has not been called, or the file could not
//                                  not be created.
//             Other errors returned by WriteFile();
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Write(LPCTSTR pszString, ... )
{
   if(m_hFileHandle == INVALID_HANDLE_VALUE)
   {
      return ERROR_NOT_READY;
   }

   CString szWrite;

   va_list marker;
   va_start(marker, pszString);

   //This is not a safe usage. Avoid using vswprintf(). Raid #555867. Yanggao.
   szWrite.FormatV(pszString, marker);

   va_end(marker);

   DWORD dwRight;
   if( !WriteFile( m_hFileHandle, szWrite, sizeof(TCHAR) * szWrite.GetLength(), &dwRight, NULL) )
   {
      //
      // Check the error state of the right.  Set m_bErrored if there was something wrong
      // with the write.
      //
      dwRight = GetLastError();
      if(dwRight != ERROR_SUCCESS)
      {
         m_bErrored = TRUE;
      }
   } 
   else
   {
      dwRight = ERROR_SUCCESS;
   }

   return dwRight;
}

DWORD
CWriteHtmlFile::CopyTextFile(
   LPCTSTR pszFile,
   DWORD dwPosLow,
   BOOL bInterpret
   )
{
   HANDLE handle;

   //
   // Try to open the file for reading.
   //
   handle = ExpandAndCreateFile( pszFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
   if(handle == INVALID_HANDLE_VALUE)
   {
      return GetLastError();
   }

   LONG dwPosHigh = 0;
   WCHAR szText[256];
   char szRead[256];

   BOOL IsMulti;
   DWORD isUnicode;

   //
   // Determine if the file is a unicode text file.
   //
   if( ReadFile(handle, szText, 100 * sizeof(WCHAR), (DWORD *)&dwPosHigh, NULL ) == 0 ) //Raid #prefast
   {
      CloseHandle(handle );
      return GetLastError();
   }
   if(dwPosHigh )
   {
      isUnicode = IsTextUnicode( szText, dwPosHigh, NULL );
   }

   //
   // Set the pos we want to start from
   //
   dwPosHigh = 0;
   SetFilePointer( handle, dwPosLow, &dwPosHigh, FILE_BEGIN );
   if( GetLastError() != ERROR_SUCCESS )
   {
      CloseHandle(handle );
      return GetLastError();
   }

   DWORD dwErr = ERROR_SUCCESS;
   do 
   {
start:
      //
      // Read 254 total bytes from the file.  We don't care about the error returned
      // by read, as long as read does not set dwPosHigh to something.
      //
      dwPosHigh = 0;
      if( ReadFile( handle, szRead, 254, (DWORD *)&dwPosHigh, NULL ) == 0 || dwPosHigh == 0) //Raid #prefast
      {
         CloseHandle(handle );
         return GetLastError();
      }

      //
      // If the file is not considered unicode then convert it to a unicode file.
      //
      ZeroMemory(szText, sizeof(WCHAR) * 256);
      if(!isUnicode)
      {
         //This is a safe usage.
         dwPosHigh = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szRead, dwPosHigh, szText, 255 );
      }
      else
      {
         //
         // Just copy the text to the szText buffer and get the number of UNICODE
         // characters.
         //
         //This is a safe usage.
         memcpy(szText, szRead, dwPosHigh);
         dwPosHigh = wcslen(szText);
      }

      PWSTR pszWrite = szText;
      LONG i = 0;
      if( bInterpret )
      {
         //
         // Write out line breaks.
         //
         for(;i < dwPosHigh; i++)
         {
            //Bug 141526, Yanggao, 3/20/2001
            if( L'<' == szText[i] )
            {
               szText[i] = 0;
               Write(pszWrite);
               Write(L"&lt");
               pszWrite = &(szText[i + 1]);
            }
            if( L'%' == szText[i] ) //Raid #624384,Yanggao
            {
               szText[i] = 0;
               Write(pszWrite);
               Write(L"%%");
               pszWrite = &(szText[i + 1]);
            }

            if( L'\r' == szText[i] || L'\n' == szText[i] )
            {
               if( i + 1 >= dwPosHigh )
               {
                  szText[i] = 0;
                  Write(pszWrite);

                  SetFilePointer( handle, -(isUnicode ? 2:1), NULL, FILE_CURRENT);
                  //
                  // Read once again.
                  //
                  goto start;
               }

               //
               // Check to see if this is a valid line break
               //
               i++;
               if( L'\r' == szText[i] || L'\n' == szText[i] &&
                  szText[i] != szText[i - 1] )
               {
                  szText[i - 1] = 0;

                  dwErr = Write( pszWrite );
                  if( dwErr != ERROR_SUCCESS)
                  {
                     break;
                  }
                  dwErr = Write( L"<BR>" );
                  if( dwErr != ERROR_SUCCESS)
                  {
                     break;
                  }

                  pszWrite = &(szText[i + 1]);
               }
               else
               {
                  //
                  // This is not a valid line break, contintue with check with next character
                  //
                  i--;
               }
            }
         }
      }

      //
      // Write the rest of the text.
      //
      if(dwErr == ERROR_SUCCESS)
      {
         Write( pszWrite );
      }
      else
      {
         break;
      }

   } while( dwPosHigh );

   CloseHandle(handle );
   return ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Create
//
// Creates an html file, and starts the write proccess.  If [pszFile] is null, then
// this function creates a temporary file in the GetTempPath() directory with a name
// like SCE###.HTM
//
// Arguments:  [pszFile] - Optional parameter for file name
//
// returns:    ERROR_SUCCESS  - If creating the file was successful.
//             If the file exists then ERROR_FILE_EXISTS is returned.
//
//--------------------------------------------------------------------------------------------
DWORD CWriteHtmlFile::Create(LPCTSTR pszFile )
{
   if(!pszFile){
      //
      // Create a temporary file name.
      //
      DWORD dwSize = GetTempPath(0, NULL);
      if(dwSize){
         TCHAR szTempFile[512];

         //
         // Get the temp path.
         //
         LPTSTR pszPath = (LPTSTR)LocalAlloc( 0, (dwSize + 1) * sizeof(TCHAR));
         if(!pszPath){
            return ERROR_OUTOFMEMORY;
         }
         GetTempPath( dwSize + 1, pszPath );

         pszPath[dwSize - 1] = 0;
         if( GetTempFileName( pszPath, TEXT("SCE"), 0, szTempFile) ){ //This is not safe usage. Raid #555912, yanggao.
            LocalFree(pszPath);

            //
            // Create the temporary file.
            //
            DeleteFile( szTempFile );
            int i = lstrlen(szTempFile);
            while(i--){
               if( szTempFile[i] == L'.' ){
                  break;
               }
            }

            if(i + 3 >= lstrlen(szTempFile)){
               return ERROR_OUTOFMEMORY;
            }

            //
            // We want to create an html file.
            //
            i++;
            szTempFile[i]     = L'h';
            szTempFile[i + 1] = L't';
            szTempFile[i + 2] = L'm';

            m_strFileName = szTempFile;
         } else {
            LocalFree(pszPath);
         }
      }
   } else {
      m_strFileName = pszFile;
   }

   if(m_strFileName.IsEmpty()){
      return ERROR_FILE_NOT_FOUND;
   }

   //
   // Open the file for writing
   //
   m_hFileHandle  = ExpandAndCreateFile( m_strFileName,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         CREATE_ALWAYS,
                                         FILE_ATTRIBUTE_TEMPORARY,
                                         NULL
                                         );
   if(m_hFileHandle  == INVALID_HANDLE_VALUE){
      return GetLastError();
   }

   //
   // Write HTML header
   //
   return Write( IDS_HTMLERR_HEADER );
}



//+--------------------------------------------------------------------------
//
//  Function:   MyRegQueryValue
//
//  Synopsis:  Reads a registry value into [*Value]
//
//
//  Arguments:  [hKeyRoot] -
//              [SubKey]  -
//              [ValueName]  -
//              [Value]  -
//              [pRegType]  -
//
//  Modifies:   *[Value]
//              *[pRegType]
//
//  History:
//
//---------------------------------------------------------------------------

DWORD MyRegQueryValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       PVOID *Value,
                       LPDWORD pRegType )
{
   DWORD   Rcode;
   DWORD   dSize=0;
   HKEY    hKey=NULL;
   BOOL    FreeMem=FALSE;

   if (( Rcode = RegOpenKeyEx(hKeyRoot, SubKey, 0,
                              KEY_READ, &hKey )) == ERROR_SUCCESS ) {
      //This is a safe usage. It only queries data type.
      if (( Rcode = RegQueryValueEx(hKey, ValueName, 0,
                                    pRegType, NULL,
                                    &dSize )) == ERROR_SUCCESS ) {
         switch (*pRegType) {
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:
               //This is a safe usage. The data type is not REG_SZ.
               Rcode = RegQueryValueEx(hKey, ValueName, 0,
                                       pRegType, (BYTE *)(*Value),
                                       &dSize );
               if ( Rcode != ERROR_SUCCESS ) {

                  if ( *Value != NULL )
                     *((BYTE *)(*Value)) = 0;
               }
               break;

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
               if ( *Value == NULL ) {
                  *Value = (PVOID)LocalAlloc( LPTR, (dSize+1)*sizeof(TCHAR));
                  FreeMem = TRUE;
               }

               if ( *Value == NULL ) {
                  Rcode = ERROR_NOT_ENOUGH_MEMORY;
               } else {
                  //This is not a safe usage. make sure *Value is terminated. Raid #555873. yanggao.
                  Rcode = RegQueryValueEx(hKey,ValueName,0,
                                          pRegType,(BYTE *)(*Value),
                                          &dSize );

                  if ( (Rcode != ERROR_SUCCESS) && FreeMem ) {
                     LocalFree(*Value);
                     *Value = NULL;
                  }
               }

               break;
            default:

               Rcode = ERROR_INVALID_DATATYPE;

               break;
         }
      }
   }

   if ( hKey ) {
      RegCloseKey( hKey );
   }

   return(Rcode);
}


//+--------------------------------------------------------------------------
//
//  Function:   MyRegSetValue
//
//  Synopsis:  Writes a registry value into [*Value]
//
//
//  Arguments:  [hKeyRoot] -
//              [SubKey]  -
//              [ValueName]  -
//              [Value]  -
//              [cbValue]  -
//              [pRegType]  -
//
//
//  History:
//
//---------------------------------------------------------------------------

DWORD MyRegSetValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       const BYTE *Value,
                       const DWORD cbValue,
                       const DWORD pRegType )
{
   DWORD   Rcode=0;
   HKEY    hKey=NULL;
   BOOL    FreeMem=FALSE;


   if (( Rcode = RegCreateKeyEx(hKeyRoot,
                                SubKey,
                                0,
                                0,
                                                                0,
                                                                KEY_READ|KEY_SET_VALUE|KEY_CREATE_SUB_KEY,
                                NULL,
                                                                &hKey,
                                                                NULL)) == ERROR_SUCCESS ) {
      Rcode = RegSetValueEx(hKey,
                            ValueName,
                            0,
                            pRegType,
                            Value,
                            cbValue );
   }

   if ( hKey ) {
      RegCloseKey( hKey );
   }

   return(Rcode);
}

BOOL FilePathExist(LPCTSTR Name, BOOL IsPath, int Flag)
// Flag = 0 - check file, Flag = 1 - check path
{
   // TODO:
   struct _wfinddata_t FileInfo;
   intptr_t        hFile;
   BOOL            bExist = FALSE;

   if ( (IsPath && Flag == 1) ||
        (!IsPath && Flag == 0) ) {
      // must be exact match
      hFile = _wfindfirst((LPTSTR)Name, &FileInfo);
      if ( hFile != -1 ) {// find it
         if ( FileInfo.attrib & _A_SUBDIR ) {
            if ( Flag == 1)
               bExist = TRUE;
         } else if ( Flag == 0 )
            bExist = TRUE;
      }
      _findclose(hFile);
      return bExist;
   }

   if ( IsPath && Flag == 0 ) {
      // invalid parameter
      return bExist;
   }

   // IsPath = FALSE and Flag == 1 (a file name is passed in and search for its path)
   CString tmpstr = CString(Name);
   int nPos = tmpstr.ReverseFind(L'\\');

   if ( nPos > 2 ) {
      hFile = _wfindfirst(tmpstr.GetBufferSetLength(nPos), &FileInfo);
      if ( hFile != -1 && FileInfo.attrib & _A_SUBDIR )
         bExist = TRUE;

      _findclose(hFile);
   } else if ( nPos == 2 && Name[1] == L':')
      bExist = TRUE;

   return bExist;
}


//+--------------------------------------------------------------------------
//
//  Function:   MyFormatResMessage
//
//  Synopsis:   Creates an error message combining a description of an error
//              returned from an SCE function (in rc), the extended description
//              of that error (in errBuf), and a custom error message
//              (in residMessage)
//
//  Arguments:  [rc]      - The return code of an SCE function
//              [residMessage] - the resource id of the base error message
//              [errBuf]  - Extended error info returned from an SCE function
//              [strOut]  - A CString to hold the formatted message
//
//  Modifies:   [strOut]
//
//  History:
//
//---------------------------------------------------------------------------
void
MyFormatResMessage(SCESTATUS rc,              // in
                   UINT residMessage,         // in
                   PSCE_ERROR_LOG_INFO errBuf,// in, optional
                   CString& strOut)           // out
{
   CString strMessage;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //
   // If the LoadResource fails then strMessage will be empty
   // It'll still be better to format the rest of the message than
   // to return an empty strOut.
   //
   strMessage.LoadString(residMessage);

   MyFormatMessage(rc,strMessage,errBuf,strOut);
}


//+--------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Creates an error message combining a description of an error
//              returned from an SCE function (in rc), the extended description
//              of that error (in errBuf), and a custom error message (in mes)
//
//  Arguments:  [rc]      - The return code of an SCE function
//              [mes]     - The base message
//              [errBuf]  - Extended error info returned from an SCE function
//              [strOut]  - A CString to hold the formatted message
//
//  Modifies:   [strOut]
//
//  History:
//
//---------------------------------------------------------------------------
void
MyFormatMessage(SCESTATUS rc,                 // in
                LPCTSTR mes,                  // in
                PSCE_ERROR_LOG_INFO errBuf,   // in, optional
                CString& strOut)              // out
{
   LPVOID     lpMsgBuf=NULL;

   if ( rc != SCESTATUS_SUCCESS ) {

      //
      // translate SCESTATUS into DWORD
      //
      DWORD win32 = SceStatusToDosError(rc);

      //
      // get error description of rc
      //
      //This is a safe usage. The function is responsible to allocate memery.
      FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                     NULL,
                     win32,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                     (LPTSTR)&lpMsgBuf,
                     0,
                     NULL
                   );
   }

   if ( lpMsgBuf != NULL ) {
      strOut = (LPTSTR)lpMsgBuf;
      LocalFree(lpMsgBuf);
      lpMsgBuf = NULL;
   } else {
      strOut.Empty();
   }

   CString strEx; //Raid #485372, yanggao, 11/30/2001
   switch(rc)
   {
      case SCESTATUS_INVALID_PARAMETER:
      case SCESTATUS_RECORD_NOT_FOUND:
      case SCESTATUS_INVALID_DATA:
      case SCESTATUS_OBJECT_EXIST:
      case SCESTATUS_PROFILE_NOT_FOUND:
         strEx.LoadString(IDS_OBJECT_FAILED_NOTE);
         break;
      case SCESTATUS_ACCESS_DENIED:
      case SCESTATUS_CANT_DELETE:
         strEx.LoadString(IDS_SAVE_FAILED_NOTE);
         break;
      case SCESTATUS_PREFIX_OVERFLOW:
      case SCESTATUS_ALREADY_RUNNING:
      case SCESTATUS_OTHER_ERROR:
      case SCESTATUS_BUFFER_TOO_SMALL:
      case SCESTATUS_BAD_FORMAT:
      case SCESTATUS_NOT_ENOUGH_RESOURCE:
      default:
         strEx.Empty();
         break;
   }

   if( strEx.IsEmpty() )
   {
      strOut += mes;
   }
   else
   {
      strOut = strOut + mes + L" " + strEx;
   }
   strOut += L"\n";

   //
   // Loop through the error buffers and append each of them to strOut
   //
   for (PSCE_ERROR_LOG_INFO pErr = errBuf;
       pErr != NULL;
       pErr = pErr->next) {

      if (NULL == pErr) {
         continue;
      }
      if ( pErr->rc != NO_ERROR) {
         //This is a safe usage. The function is responsible to allocate memery.
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        pErr->rc,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR)&lpMsgBuf,
                        0,
                        NULL
                      );
         if ( lpMsgBuf ) {
            strOut += (LPTSTR)lpMsgBuf;
            LocalFree(lpMsgBuf);
            lpMsgBuf = NULL;
         }
      }
      if (pErr->buffer) {
         strOut += pErr->buffer;
         strOut += L"\n";
      }

   }
}

DWORD
FormatDBErrorMessage(
   SCESTATUS sceStatus,
   LPCTSTR pszDatabase,
   CString &strOut
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   UINT    uErr    = 0;

   switch (sceStatus) {
   case SCESTATUS_SUCCESS:
      return ERROR_INVALID_PARAMETER;
   case SCESTATUS_INVALID_DATA:
      uErr = IDS_DBERR_INVALID_DATA;
      break;
   case SCESTATUS_PROFILE_NOT_FOUND:
      uErr = IDS_DBERR5_PROFILE_NOT_FOUND;
      break;
   case SCESTATUS_BAD_FORMAT:
      uErr = IDS_DBERR_BAD_FORMAT;
      break;
   case SCESTATUS_BUFFER_TOO_SMALL:
   case SCESTATUS_NOT_ENOUGH_RESOURCE:
      uErr = IDS_DBERR_NOT_ENOUGH_RESOURCE;
      break;
   case SCESTATUS_ACCESS_DENIED:
      uErr = IDS_DBERR5_ACCESS_DENIED;
      break;
   case SCESTATUS_NO_TEMPLATE_GIVEN:
      uErr = IDS_DBERR_NO_TEMPLATE_GIVEN;
      break;
   case SCESTATUS_SPECIAL_ACCOUNT: //Raid #589139, DCR, yanggao, 4/10/2002.
      uErr = IDS_ERR_PRIVILEGE; //.Net use IDS_ERR_PRIVILEGE instead of IDS_DBERR5_ACCESS_DENIED which is used for XPSP1.
      break;
   case ERROR_NONE_MAPPED: //Raid #625342
      uErr = IDS_NO_ACCOUNT_MAP;
      break;
   default:
      uErr = IDS_DBERR_OTHER_ERROR;
   }

   if ( strOut.LoadString(uErr) ) {
      return ERROR_SUCCESS;
   }
   return ERROR_INVALID_PARAMETER;
}

DWORD SceStatusToDosError(SCESTATUS SceStatus)
{
   switch (SceStatus) {

      case SCESTATUS_SUCCESS:
         return(NO_ERROR);

      case SCESTATUS_OTHER_ERROR:
         return(ERROR_EXTENDED_ERROR);

      case SCESTATUS_INVALID_PARAMETER:
         return(ERROR_INVALID_PARAMETER);

      case SCESTATUS_RECORD_NOT_FOUND:
         return(ERROR_RESOURCE_DATA_NOT_FOUND);

      case SCESTATUS_INVALID_DATA:
         return(ERROR_INVALID_DATA);

      case SCESTATUS_OBJECT_EXIST:
         return(ERROR_FILE_EXISTS);

      case SCESTATUS_BUFFER_TOO_SMALL:
         return(ERROR_INSUFFICIENT_BUFFER);

      case SCESTATUS_PROFILE_NOT_FOUND:
         return(ERROR_FILE_NOT_FOUND);

      case SCESTATUS_BAD_FORMAT:
         return(ERROR_BAD_FORMAT);

      case SCESTATUS_NOT_ENOUGH_RESOURCE:
         return(ERROR_NOT_ENOUGH_MEMORY);

      case SCESTATUS_ACCESS_DENIED:
      case SCESTATUS_SPECIAL_ACCOUNT: //Raid #589139, DCR, yanggao, 4/10/2002.
         return(ERROR_ACCESS_DENIED);

      case SCESTATUS_CANT_DELETE:
         return(ERROR_CURRENT_DIRECTORY);

      case SCESTATUS_PREFIX_OVERFLOW:
         return(ERROR_BUFFER_OVERFLOW);

      case SCESTATUS_ALREADY_RUNNING:
         return(ERROR_SERVICE_ALREADY_RUNNING);

      default:
         return(ERROR_EXTENDED_ERROR);
   }
}


//+--------------------------------------------------------------------------
//
//  Function:   CreateNewProfile
//
//  Synopsis:   Create a new tempate with default values in the ProfileName location
//
//  Returns:  TRUE if a template ends up in the ProfileName file
//            FALSE otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL CreateNewProfile(CString ProfileName,PSCE_PROFILE_INFO *ppspi)
{
   SCESTATUS status;
   SCE_PROFILE_INFO *pTemplate;
   //
   // profile name must end with .inf
   //
   int	nLen = ProfileName.GetLength ();
   // start searching at the last 4 position
   if ( ProfileName.Find (L".inf", nLen-4) != nLen-4 ) 
   {
      return FALSE;
   }

   //
   // if the profile already exists then we don't need to do anything
   //
   if ( FilePathExist( (LPCTSTR)ProfileName, FALSE, 0) ) {
      return TRUE;
   }

   //
   // Make sure the directory for the profile exists
   //
   status = SceCreateDirectory(ProfileName,FALSE,NULL);
   if (SCESTATUS_SUCCESS != status) {
      return FALSE;
   }

   pTemplate = (SCE_PROFILE_INFO*)LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
   if (!pTemplate) {
      return FALSE;
   }

#ifdef FILL_WITH_DEFAULT_VALUES
   SCE_PROFILE_INFO *pDefault = GetDefaultTemplate();
   //
   // Fill with default values
   //
   pTemplate->Type = SCE_ENGINE_SCP;

#define CD(X) pTemplate->X = pDefault->X;
#else // !FILL_WITH_DEFAULT_VALUES
#define CD(X) pTemplate->X = SCE_NO_VALUE;
#endif // !FILL_WITH_DEFAULT_VALUES

   CD(MinimumPasswordAge);
   CD(MaximumPasswordAge);
   CD(MinimumPasswordLength);
   CD(PasswordComplexity);
   CD(PasswordHistorySize);
   CD(LockoutBadCount);
   CD(ResetLockoutCount);
   CD(LockoutDuration);
   CD(RequireLogonToChangePassword);
   CD(ForceLogoffWhenHourExpire);
   CD(EnableAdminAccount);
   CD(EnableGuestAccount);

   // These members aren't declared in NT4
   CD(ClearTextPassword);
   CD(AuditDSAccess);
   CD(AuditAccountLogon);
   CD(LSAAnonymousNameLookup);

   CD(MaximumLogSize[0]);
   CD(MaximumLogSize[1]);
   CD(MaximumLogSize[2]);
   CD(AuditLogRetentionPeriod[0]);
   CD(AuditLogRetentionPeriod[1]);
   CD(AuditLogRetentionPeriod[2]);
   CD(RetentionDays[0]);
   CD(RetentionDays[1]);
   CD(RetentionDays[2]);
   CD(RestrictGuestAccess[0]);
   CD(RestrictGuestAccess[1]);
   CD(RestrictGuestAccess[2]);
   CD(AuditSystemEvents);
   CD(AuditLogonEvents);
   CD(AuditObjectAccess);
   CD(AuditPrivilegeUse);
   CD(AuditPolicyChange);
   CD(AuditAccountManage);
   CD(AuditProcessTracking);

#ifdef FILL_WITH_DEFAULT_VALUES
   //
   // These two are strings rather than DWORDs
   //
   if (pDefault->NewAdministratorName) {
      pTemplate->NewAdministratorName =
         (LPTSTR) LocalAlloc(LPTR,(lstrlen(pDefault->NewAdministratorName)+1)*sizeof(TCHAR));
      if (pTemplate->NewAdministratorName) {
         //This may not be a safe usage. pTemplate->NewAdministratorName and pDefault->NewAdministratorName are both PWSTR. Consider fix.
         lstrcpy(pTemplate->NewAdministratorName,
                 pDefault->NewAdministratorName);
      }
   }
   if (pDefault->NewGuestName) {
      pTemplate->NewGuestName =
         (LPTSTR) LocalAlloc(LPTR,(lstrlen(pDefault->NewGuestName)+1)*sizeof(TCHAR));
      if (pTemplate->NewGuestName) {
         //This may not be a safe usage. pTemplate->NewGuestName and pDefault->NewGuestName are both PWSTR. Consider fix.
         lstrcpy(pTemplate->NewGuestName,
                 pDefault->NewGuestName);
      }
   }
#endif // FILL_WITH_DEFAULT_VALUES

#undef CD
   status = SceWriteSecurityProfileInfo(ProfileName,
                                        AREA_ALL,
                                        pTemplate,
                                        NULL);
   if (ppspi) {
      *ppspi = pTemplate;
   } else {
      SceFreeProfileMemory(pTemplate);
   }

   return (SCESTATUS_SUCCESS == status);
}

BOOL
VerifyKerberosInfo(PSCE_PROFILE_INFO pspi) {
   if (pspi->pKerberosInfo) {
      return TRUE;
   }
   pspi->pKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)
                         LocalAlloc(LPTR,sizeof(SCE_KERBEROS_TICKET_INFO));

   if (pspi->pKerberosInfo) {
       pspi->pKerberosInfo->MaxTicketAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxRenewAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxServiceAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxClockSkew = SCE_NO_VALUE;
       pspi->pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;
      return TRUE;
   }
   return FALSE;
}

BOOL
SetProfileInfo(LONG_PTR dwItem,LONG_PTR dwNew,PEDITTEMPLATE pEdit) {
   if (!pEdit) {
      return FALSE;
   }
   pEdit->SetDirty(AREA_SECURITY_POLICY);

   switch (dwItem) {
      case IDS_MAX_PAS_AGE:
         pEdit->pTemplate->MaximumPasswordAge = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_MIN_PAS_AGE:
         pEdit->pTemplate->MinimumPasswordAge = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_MIN_PAS_LEN:
         pEdit->pTemplate->MinimumPasswordLength = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PAS_UNIQUENESS:
         pEdit->pTemplate->PasswordHistorySize = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PAS_COMPLEX:
         pEdit->pTemplate->PasswordComplexity = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_REQ_LOGON:
         pEdit->pTemplate->RequireLogonToChangePassword = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_COUNT:
         pEdit->pTemplate->LockoutBadCount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_RESET_COUNT:
         pEdit->pTemplate->ResetLockoutCount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_DURATION:
         pEdit->pTemplate->LockoutDuration = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_FORCE_LOGOFF:
         pEdit->pTemplate->ForceLogoffWhenHourExpire = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ENABLE_ADMIN:
         pEdit->pTemplate->EnableAdminAccount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ENABLE_GUEST:
         pEdit->pTemplate->EnableGuestAccount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LSA_ANON_LOOKUP:
         pEdit->pTemplate->LSAAnonymousNameLookup = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_NEW_ADMIN:
         if (pEdit->pTemplate->NewAdministratorName) {
            LocalFree(pEdit->pTemplate->NewAdministratorName);
         }
         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {
            pEdit->pTemplate->NewAdministratorName = (PWSTR)LocalAlloc(LPTR,(lstrlen((PWSTR)dwNew)+1)*sizeof(WCHAR));
            if (pEdit->pTemplate->NewAdministratorName) {
               //This may not be a safe usage. pTemplate->NewAdministratorName and dwNew are both PWSTR. Consider fix.
               lstrcpy(pEdit->pTemplate->NewAdministratorName,(PWSTR)dwNew);
            }
         } else {
            pEdit->pTemplate->NewAdministratorName = NULL;
         }
         break;
      case IDS_NEW_GUEST:
         if (pEdit->pTemplate->NewGuestName) {
            LocalFree(pEdit->pTemplate->NewGuestName);
         }
         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {
            pEdit->pTemplate->NewGuestName = (PWSTR)LocalAlloc(LPTR,(lstrlen((PWSTR)dwNew)+1)*sizeof(WCHAR));
            if (pEdit->pTemplate->NewGuestName) {
               //This may not be a safe usage. pTemplate->NewGuestName and dwNew are both PWSTR. Consider fix.
               lstrcpy(pEdit->pTemplate->NewGuestName,(PWSTR)dwNew);
            }
         } else {
            pEdit->pTemplate->NewGuestName = NULL;
         }
         break;
      case IDS_SYS_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYSTEM_EVENT:
         pEdit->pTemplate->AuditSystemEvents = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOGON_EVENT:
         pEdit->pTemplate->AuditLogonEvents = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_OBJECT_ACCESS:
         pEdit->pTemplate->AuditObjectAccess = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PRIVILEGE_USE:
         pEdit->pTemplate->AuditPrivilegeUse = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_POLICY_CHANGE:
         pEdit->pTemplate->AuditPolicyChange = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ACCOUNT_MANAGE:
         pEdit->pTemplate->AuditAccountManage = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PROCESS_TRACK:
         pEdit->pTemplate->AuditProcessTracking = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_DIRECTORY_ACCESS:
         pEdit->pTemplate->AuditDSAccess = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ACCOUNT_LOGON:
         pEdit->pTemplate->AuditAccountLogon = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_CLEAR_PASSWORD:
         pEdit->pTemplate->ClearTextPassword = (DWORD)PtrToUlong((PVOID)dwNew);
         break;

      case IDS_KERBEROS_MAX_SERVICE:
         if (VerifyKerberosInfo(pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxServiceAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxClockSkew = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->TicketValidateClient = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;

      case IDS_KERBEROS_MAX_AGE:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxTicketAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_RENEWAL:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxRenewAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      default:
         return FALSE;
   }
   return TRUE;

}


//
//  FUNCTION:   ErrorHandlerEx(WORD, LPSTR)
//
//  PURPOSE:    Calls GetLastError() and uses FormatMessage() to display the
//              textual information of the error code along with the file
//              and line number.
//
//  PARAMETERS:
//      wLine    - line number where the error occured
//      lpszFile - file where the error occured
//
//  RETURN VALUE:
//      none
//
//  COMMENTS:
//      This function has a macro ErrorHandler() which handles filling in
//      the line number and file name where the error occured.  ErrorHandler()
//      is always used instead of calling this function directly.
//

void ErrorHandlerEx( WORD wLine, LPTSTR lpszFile )
{
   LPVOID lpvMessage;
   DWORD  dwError;
   CString szBuffer;

   // The the text of the error message
   //This is a safe usage.
   dwError = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           GetLastError(),
                           MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                           (LPTSTR)&lpvMessage,
                           0,
                           NULL);

   // Check to see if an error occured calling FormatMessage()
   if (0 == dwError) {
      //This is not a safe usage. avoid using wsprintf. Raid #555867. Yanggao.
      szBuffer.Format(TEXT("An error occured calling FormatMessage().")
               TEXT("Error Code %d"), GetLastError());
      MessageBox(NULL, szBuffer, TEXT("Security Configuration Editor"), MB_ICONSTOP |
                 MB_ICONEXCLAMATION);
      return;
   }

   // Display the error message
   //This is not a safe usage. avoid using wsprinf. Raid #555867. Yanggao.
   szBuffer.Format(TEXT("Generic, Line=%d, File=%s"), wLine, lpszFile);
   MessageBox(NULL, (LPTSTR)lpvMessage, szBuffer, MB_ICONEXCLAMATION | MB_OK);

   return;
}

BOOL
GetSceStatusString(SCESTATUS status, CString *strStatus) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
   if (!strStatus || (status > SCESTATUS_SERVICE_NOT_SUPPORT)) {
      return false;
   }
   return strStatus->LoadString(status + IDS_SCESTATUS_SUCCESS);
}


//+---------------------------------------------------------------------------------------------
// EnumLangProc
//
// Creates the lanuage ID for the resource attached to the DLL. The function only enumerates
// on lanuage.
//
// Arguments:  - See help on EnumResLangProc in the SDK Doc.
//
// Returns:    - Returns FALSE because we only want the very first lanuage enumerated.
//
//+---------------------------------------------------------------------------------------------
BOOL CALLBACK EnumLangProc(
                  HMODULE hMod,
                  LPCTSTR pszType,
                  LPCTSTR pszName,
                  WORD wIDLanguage,
                  LONG_PTR lParam
                  )
{
   //
   // We only want the very first enumerated type, so create the language ID
   // and exit this enumeration.
   //
   *((DWORD *)lParam) = wIDLanguage;
   return FALSE;
}

bool
GetRightDisplayName(LPCTSTR szSystemName, LPCTSTR szName, LPTSTR szDisp, LPDWORD lpcbDisp) {
   LPTSTR szLCName;
   DWORD dwLang;
   int i;

   if (!szDisp || !szName) {
      return false;
   }

   //
   // Enumerate our resource to find out what language the resource is in.
   //
   DWORD dwDefaultLang;

   dwDefaultLang = GetUserDefaultUILanguage();
   LCID localeID = MAKELCID(dwDefaultLang, SORT_DEFAULT);

   LCID langDefault = GetThreadLocale();
   SetThreadLocale( localeID );

   *lpcbDisp = dwDefaultLang;

   DWORD cBufSize=*lpcbDisp;
   BOOL bFound;

   bFound = LookupPrivilegeDisplayName(szSystemName,szName,szDisp,lpcbDisp,&dwLang);
   if ( bFound && dwDefaultLang != dwLang && szSystemName ) {
      // not the language I am looking for
      // search on local system
      *lpcbDisp = cBufSize;
      bFound = LookupPrivilegeDisplayName(NULL,szName,szDisp,lpcbDisp,&dwLang);
   }
   SetThreadLocale(langDefault);

   //Prefast warning 400: Using 'lstrcmpiW' to perform a case-insensitive compare to constant string.
   //Yields unexpected result in non-English locales. Currently they are always English locale.
   if (!bFound) {
      if (0 == _wcsicmp(szName,L"senetworklogonright")) { 
         LoadString(AfxGetInstanceHandle(),IDS_SE_NETWORK_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"seinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_INTERACTIVE_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sebatchlogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_BATCH_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"seservicelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_SERVICE_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sedenyinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_LOCALLY,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sedenynetworklogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_NETWORK,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sedenyservicelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_SERVICE,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sedenybatchlogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_BATCH,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"sedenyremoteinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_REMOTE_INTERACTIVE_LOGON,szDisp,*lpcbDisp);
      } else if (0 == _wcsicmp(szName,L"seremoteinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_REMOTE_INTERACTIVE_LOGON,szDisp,*lpcbDisp);
      } else {
         //This is not a safe usage. Make sure szDisp is terminated. Raid #553113, yanggao
         lstrcpyn(szDisp,szName,*lpcbDisp-1);
      }
   }
   return true;
}

#define DPI(X) {str.Format(L"%S: %d\n",#X,pInfo->X);OutputDebugString(str);}
void DumpProfileInfo(PSCE_PROFILE_INFO pInfo) {
   CString str;
   PSCE_PRIVILEGE_ASSIGNMENT ppa;
   PSCE_NAME_LIST pName;
   PSCE_GROUP_MEMBERSHIP pgm;

   if (!pInfo) {
      return;
   }

   DPI(MinimumPasswordAge);
   DPI(MaximumPasswordAge);
   DPI(MinimumPasswordLength);
   DPI(PasswordComplexity);
   DPI(PasswordHistorySize);
   DPI(LockoutBadCount);
   DPI(ResetLockoutCount);
   DPI(LockoutDuration);
   DPI(RequireLogonToChangePassword);
   DPI(ForceLogoffWhenHourExpire);
   DPI(EnableAdminAccount);
   DPI(EnableGuestAccount);
   DPI(ClearTextPassword);
   DPI(AuditDSAccess);
   DPI(AuditAccountLogon);
   DPI(LSAAnonymousNameLookup);
   //    DPI(EventAuditingOnOff);
   DPI(AuditSystemEvents);
   DPI(AuditLogonEvents);
   DPI(AuditObjectAccess);
   DPI(AuditPrivilegeUse);
   DPI(AuditPolicyChange);
   DPI(AuditAccountManage);
   DPI(AuditProcessTracking);

   if (pInfo->NewGuestName) {
      OutputDebugString(L"NewGuestName: ");
      if ((DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == (DWORD_PTR)pInfo->NewGuestName) {
         OutputDebugString(L"[[undefined]]");
      } else {
         OutputDebugString(pInfo->NewGuestName);
      }
      OutputDebugString(L"\n");
   } else {
      OutputDebugString(L"NewGuestName: [[absent]]\n");
   }
   if (pInfo->NewAdministratorName) {
      OutputDebugString(L"NewAdministratorName: ");
      if ((DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == (DWORD_PTR)pInfo->NewAdministratorName) {
         OutputDebugString(L"[[undefined]]");
      } else {
         OutputDebugString(pInfo->NewAdministratorName);
      }
      OutputDebugString(L"\n");
   } else {
      OutputDebugString(L"NewGuestName: [[absent]]\n");
   }


   OutputDebugString(L"\n");

   switch(pInfo->Type) {
      case SCE_ENGINE_SCP:
         ppa = pInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SAP:
         ppa = pInfo->OtherInfo.sap.pPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SMP:
         ppa = pInfo->OtherInfo.smp.pPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SYSTEM:
         ppa = NULL;
         break;
      default:
         OutputDebugString(L"!!!Unknown Template Type!!!\n");
         ppa = NULL;
         break;
   }
   while(ppa) {
      OutputDebugString(ppa->Name);
      OutputDebugString(L":");
      pName = ppa->AssignedTo;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      ppa = ppa->Next;
      OutputDebugString(L"\n");
   }
   OutputDebugString(L"\n");

   PSCE_REGISTRY_VALUE_INFO    aRegValues;
   for(DWORD i = 0; i< pInfo->RegValueCount;i++) {
      OutputDebugString(pInfo->aRegValues[i].FullValueName);
      OutputDebugString(L":");
      switch(pInfo->aRegValues[i].ValueType) {
         case SCE_REG_DISPLAY_STRING:
            OutputDebugString(pInfo->aRegValues[i].Value);
            break;
         default:
            str.Format(L"%d",(ULONG_PTR)pInfo->aRegValues[i].Value);
            OutputDebugString(str);
      }
      OutputDebugString(L"\n");
   }
   OutputDebugString(L"\n");

   pgm = pInfo->pGroupMembership;
   while(pgm) {
      OutputDebugString(L"\nGROUP: ");
      OutputDebugString(pgm->GroupName);
      OutputDebugString(L"\nMembers: ");
      pName = pgm->pMembers;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      OutputDebugString(L"\nMember Of: ");
      pName = pgm->pMemberOf;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      OutputDebugString(L"\n");
      pgm = pgm->Next;
   }
   OutputDebugString(L"\nGROUP: ");
}

HRESULT MyMakeSelfRelativeSD(
                            PSECURITY_DESCRIPTOR  psdOriginal,
                            PSECURITY_DESCRIPTOR* ppsdNew )
{
   ASSERT( NULL != psdOriginal );

   if ( NULL == psdOriginal || NULL == ppsdNew ) {
      return E_INVALIDARG;
   }

   // we have to find out whether the original is already self-relative
   SECURITY_DESCRIPTOR_CONTROL sdc = 0;
   DWORD dwRevision = 0;
   if ( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
      ASSERT( FALSE );
      DWORD err = GetLastError();
      return HRESULT_FROM_WIN32( err );
   }

   DWORD cb = GetSecurityDescriptorLength( psdOriginal ) + 20;
   PSECURITY_DESCRIPTOR psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_ZEROINIT, cb );
   if (NULL == psdSelfRelativeCopy) {
      return E_UNEXPECTED; // just in case the exception is ignored
   }

   if ( sdc & SE_SELF_RELATIVE )
   // the original is in self-relative format, just byte-copy it
   {
      //This is a safe usage.
      memcpy( psdSelfRelativeCopy, psdOriginal, cb - 20 );
   } else if ( !MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) )
   // the original is in absolute format, convert-copy it
   {
      ASSERT( FALSE );
      VERIFY( NULL == LocalFree( psdSelfRelativeCopy ) );
      DWORD err = GetLastError();
      return HRESULT_FROM_WIN32( err );
   }
   *ppsdNew = psdSelfRelativeCopy;
   return S_OK;
}

PSCE_NAME_STATUS_LIST
MergeNameStatusList(PSCE_NAME_LIST pTemplate, PSCE_NAME_LIST pInspect)
{
   PSCE_NAME_LIST pTemp1;
   PSCE_NAME_STATUS_LIST plMerge=NULL, pTemp2;
   SCESTATUS rc=SCESTATUS_SUCCESS;

   for ( pTemp1=pTemplate; pTemp1; pTemp1=pTemp1->Next ) {

      rc = SceAddToNameStatusList(&plMerge, pTemp1->Name, 0, MERGED_TEMPLATE );
      if ( SCESTATUS_SUCCESS != rc )
         break;
   }
   if ( SCESTATUS_SUCCESS == rc ) {
      for ( pTemp1=pInspect; pTemp1; pTemp1=pTemp1->Next ) {

         for ( pTemp2=plMerge; pTemp2 != NULL ; pTemp2=pTemp2->Next ) {
            if ( pTemp2->Status & MERGED_INSPECT ) {
               // this one is processed
               continue;
            } else if ( _wcsicmp(pTemp1->Name, pTemp2->Name) == 0 ) {
               // find a match
               pTemp2->Status = MERGED_TEMPLATE | MERGED_INSPECT;
               break;
            }
         }
         if ( !pTemp2 ) {
            // did not find the match, add this one in
            rc = SceAddToNameStatusList(&plMerge, pTemp1->Name, 0, MERGED_INSPECT );
            if ( SCESTATUS_SUCCESS != rc )
               break;
         }
      }
   }
   if ( SCESTATUS_SUCCESS == rc ) {
      return plMerge;
   } else {
      SceFreeMemory(plMerge, SCE_STRUCT_NAME_STATUS_LIST);
      return NULL;
   }
}


SCESTATUS
ConvertMultiSzToDelim(
                     IN PWSTR pValue,
                     IN DWORD Len,
                     IN WCHAR DelimFrom,
                     IN WCHAR Delim
                     )
/*
Convert the multi-sz delimiter \0 to space
*/
{
   DWORD i;

   for ( i=0; i<Len && pValue; i++) {
      //        if ( *(pValue+i) == L'\0' && *(pValue+i+1) != L'\0') {
      if ( *(pValue+i) == DelimFrom && i+1 < Len &&
           *(pValue+i+1) != L'\0' ) {
         //
         // a NULL delimiter is encounted and it's not the end (double NULL)
         //
         *(pValue+i) = Delim;
      }
   }

   return(SCESTATUS_SUCCESS);
}

DWORD
SceRegEnumAllValues(
                   IN OUT PDWORD  pCount,
                   IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
                   )
/*
*/
{
   DWORD   Win32Rc;
   HKEY    hKey=NULL;
   PSCE_NAME_STATUS_LIST pnsList=NULL;
   DWORD   nAdded=0;


   Win32Rc = RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         SCE_ROOT_REGVALUE_PATH,
                         0,
                         KEY_READ,
                         &hKey
                         );

   DWORD cSubKeys = 0;
   DWORD nMaxLen;

   if ( Win32Rc == ERROR_SUCCESS ) {

      //
      // enumerate all subkeys of the key
      //

      Win32Rc = RegQueryInfoKey (
                                hKey,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                &nMaxLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
   }

   if ( Win32Rc == ERROR_SUCCESS && cSubKeys > 0 ) {

      PWSTR   szName = (PWSTR)LocalAlloc(0, (nMaxLen+2)*sizeof(WCHAR));

      if ( !szName ) {
         Win32Rc = ERROR_NOT_ENOUGH_MEMORY;

      } else {

         DWORD   BufSize;
         DWORD   index = 0;
         DWORD   RegType;

         do {

            BufSize = nMaxLen+1;
            Win32Rc = RegEnumKeyEx(
                                  hKey,
                                  index,
                                  szName,
                                  &BufSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

            if ( ERROR_SUCCESS == Win32Rc ) {

               index++;

               //
               // get the full registry key name and Valuetype
               //
               cSubKeys = REG_SZ;
               PDWORD pType = &cSubKeys;

               //
               // query ValueType, if error, default REG_SZ
               //
               MyRegQueryValue( hKey,
                                szName,
                                SCE_REG_VALUE_TYPE,
                                (PVOID *)&pType,
                                &RegType );

               if ( cSubKeys < REG_SZ || cSubKeys > REG_MULTI_SZ ) {
                  cSubKeys = REG_SZ;
               }

               //
               // convert the path name
               //
               ConvertMultiSzToDelim(szName, BufSize, L'/', L'\\');

               //
               // compare with the input array, if not exist,
               // add it
               //
               for ( DWORD i=0; i<*pCount; i++ ) {
                  if ( (*paRegValues)[i].FullValueName &&
                       _wcsicmp(szName, (*paRegValues)[i].FullValueName) == 0 ) {
                     break;
                  }
               }

               if ( i >= *pCount ) {
                  //
                  // did not find a match, add it
                  //
                  if ( SCESTATUS_SUCCESS != SceAddToNameStatusList(&pnsList,
                                                                   szName,
                                                                   BufSize,
                                                                   cSubKeys) ) {

                     Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
                  nAdded++;
               }

            } else if ( ERROR_NO_MORE_ITEMS != Win32Rc ) {
               break;
            }

         } while ( Win32Rc != ERROR_NO_MORE_ITEMS );

         if ( Win32Rc == ERROR_NO_MORE_ITEMS ) {
            Win32Rc = ERROR_SUCCESS;
         }


         //
         // free the enumeration buffer
         //
         LocalFree(szName);
      }
   }

   if ( hKey ) {

      RegCloseKey(hKey);
   }


   if ( ERROR_SUCCESS == Win32Rc ) {
      //
      // add the name list to the output arrays
      //
      DWORD nNewCount = *pCount + nAdded;
      PSCE_REGISTRY_VALUE_INFO aNewArray;

      if ( nNewCount ) {

         aNewArray = (PSCE_REGISTRY_VALUE_INFO)LocalAlloc(0, nNewCount*sizeof(SCE_REGISTRY_VALUE_INFO));
         if ( aNewArray ) {
            ZeroMemory(aNewArray, nNewCount * sizeof(SCE_REGISTRY_VALUE_INFO));
            //This is a safe usage.
            memcpy( aNewArray, *paRegValues, *pCount * sizeof( SCE_REGISTRY_VALUE_INFO ) );
            DWORD i;

            i=0;
            for ( PSCE_NAME_STATUS_LIST pns=pnsList;
                pns; pns=pns->Next ) {

               if ( pns->Name && i < nAdded ) {

                  aNewArray[*pCount+i].FullValueName = pns->Name;
                  pns->Name = NULL;
                  aNewArray[*pCount+i].Value = NULL;
                  aNewArray[*pCount+i].ValueType = pns->Status;
                  aNewArray[*pCount+i].Status = SCE_STATUS_NOT_CONFIGURED;
                  i++;

               }
            }

            //
            // free the original array
            // all components in the array are already transferred to the new array
            //
            LocalFree(*paRegValues);
            *pCount = nNewCount;
            *paRegValues = aNewArray;

         } else {

            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   //
   // free the name status list
   //
   SceFreeMemory(pnsList, SCE_STRUCT_NAME_STATUS_LIST);

   return( Win32Rc );

}


DWORD
GetGroupStatus(
              DWORD status,
              int flag
              )
{

   DWORD NewStatus;

   switch ( flag ) {
      case STATUS_GROUP_RECORD:
         if (status & SCE_GROUP_STATUS_NC_MEMBERS) {

            NewStatus = SCE_STATUS_NOT_CONFIGURED;

         } else if ( (status & SCE_GROUP_STATUS_MEMBERS_MISMATCH) ||
                     (status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH)) {

            NewStatus = SCE_STATUS_MISMATCH;

         } else if (status & SCE_GROUP_STATUS_NOT_ANALYZED) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;

         } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {

            NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;

         } else {
            NewStatus = SCE_STATUS_GOOD;
         }
         break;

      case STATUS_GROUP_MEMBERS:

         if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;  //do not display any status;

         } else {
            if ( status & SCE_GROUP_STATUS_NC_MEMBERS ) {

               NewStatus = SCE_STATUS_NOT_CONFIGURED;

            } else if ( status & SCE_GROUP_STATUS_MEMBERS_MISMATCH ) {
               NewStatus = SCE_STATUS_MISMATCH;
            } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {
                NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;

            } else {
               NewStatus = SCE_STATUS_GOOD;
            }
         }
         break;

      case STATUS_GROUP_MEMBEROF:

         if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;  // do not display any status;

         } else {
            if ( status & SCE_GROUP_STATUS_NC_MEMBEROF ) {

               NewStatus = SCE_STATUS_NOT_CONFIGURED;

            } else if ( status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH ) {
               NewStatus = SCE_STATUS_MISMATCH;
            } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {
               NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;
            } else {
               NewStatus = SCE_STATUS_GOOD;
            }
         }
         break;
      default:
         NewStatus = 0;
         break;
   }

   return NewStatus;
}


//+--------------------------------------------------------------------------
//
//  Function: AllocGetTempFileName
//
//  Synopsis: Allocate and return a string with a temporary file name.
//
//  Returns:  The temporary file name, or 0 if a temp file can't be found
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
AllocGetTempFileName() {
   DWORD dw;
   CString strPath;
   CString strFile;
   LPTSTR szPath;
   LPTSTR szFile;

   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );

   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return 0;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
      return 0;
   }
   strFile.ReleaseBuffer();

   szFile = (LPTSTR)LocalAlloc(LPTR,(strFile.GetLength()+1)*sizeof(TCHAR));
   if (!szFile) {
      return 0;
   }
   //This is a safe usage.
   lstrcpy(szFile,(LPCTSTR)strFile);
   return szFile;
}

//  If the given environment variable exists as the first part of the path,
//  then the environment variable is inserted into the output buffer.
//
//  Returns TRUE if pszResult is filled in.
//
//  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SYSTEMROOT%
//            Output -- %SYSTEMROOT%\SYSTEM32\FOO.TXT

BOOL UnExpandEnvironmentString(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
   TCHAR szEnvVar[MAX_PATH];
   if( !pszPath || !pszEnvVar || !pszResult ) //Raid #553113, yanggao.
      return FALSE;
   //This is not a safe usage. Make sure szEnvVar is terminated. Raid #553113, Yanggao.
   memset(szEnvVar, '\0', (MAX_PATH)*sizeof(TCHAR));
   DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)) - 1; // don't count the NULL

   if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                     szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) {
      if (lstrlen(pszPath) + dwEnvVar < cbResult) {
         //This is not a safe usage. validate pszPath, dwEnvVar, pszResult.
         lstrcpy(pszResult, pszEnvVar);
         lstrcat(pszResult, pszPath + dwEnvVar);
         return TRUE;
      }
   }
   return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Function: UnexpandEnvironmentVariables
//
//  Synopsis: Given a path, contract any leading members to use matching
//            environment variables, if any
//
//  Arguments:
//            [szPath] - The path to expand
//
//  Returns:  The newly allocated path (NULL if no changes are made)
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
UnexpandEnvironmentVariables(LPCTSTR szPath) {
   UINT   cbNew;
   LPTSTR szNew;
   LPTSTR mszEnvVars;
   LPTSTR szEnvVar;
   DWORD  dwEnvType;
   BOOL   bExpanded;
   CString strKey;
   CString strValueName;

   CString str;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (!strKey.LoadString(IDS_SECEDIT_KEY) ||
       !strValueName.LoadString(IDS_ENV_VARS_REG_VALUE)) {
      return NULL;
   }

   //
   // Allocate memory for the new path
   //
   cbNew = lstrlen(szPath)+MAX_PATH+1;
   szNew = (LPTSTR) LocalAlloc(LPTR,cbNew * sizeof(TCHAR));
   if (!szNew) {
      return NULL;
   }


   //
   // Get Vars to expand from the registry
   //
   mszEnvVars = NULL;
   if (ERROR_SUCCESS != MyRegQueryValue(HKEY_LOCAL_MACHINE,     // hKeyRoot
                                        strKey,                 // SubKey
                                        strValueName,           // ValueName
                                        (LPVOID *)&mszEnvVars,  // Value
                                        &dwEnvType)) {          // Reg Type
      //
      // Can't get any variables to expand
      //
      LocalFree(szNew);
      return NULL;
   }

   //
   // We need a multi-sz with the variables to replace in it
   //
   if (REG_MULTI_SZ != dwEnvType || mszEnvVars == NULL) //Bug350194, Yang Gao, 3/23/2001
   {
      LocalFree(szNew);
      return NULL;
   }

   bExpanded = FALSE;

   //
   // Start at the beginning of the multi-sz block
   //
   szEnvVar = mszEnvVars;
   while (*szEnvVar) {
      if (UnExpandEnvironmentString(szPath,szEnvVar,szNew,cbNew)) {
         //
         // We can only unexpand (successfully) once
         //
         bExpanded = TRUE;
         break;
      }
      //
      // Advance szEnvVar to the end of this string
      //
      while (*szEnvVar) {
         szEnvVar++;
      }
      //
      // And the beginning of the next
      //
      szEnvVar++;
   }


   if (mszEnvVars) {
      LocalFree(mszEnvVars);
   }

   if (!bExpanded) {
      LocalFree(szNew);
      szNew = NULL;
   }


   return szNew;
}



//+--------------------------------------------------------------------------
//
//  Function: IsSystemDatabase
//
//  Synopsis: Determine if a specific databse is the system database or a private one
//
//  Arguments:
//            [szDBPath] - The database path to check
//
//  Returns:  True if szDBPath is the system database, false otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
IsSystemDatabase(LPCTSTR szDBPath) {
   CString szSysDB;
   BOOL bIsSysDB;
   DWORD rc;
   DWORD RegType;

   if (!szDBPath) {
      return FALSE;
   }

   //Raid bug 261450, Yang Gao, 3/30/2001
   if (FAILED(GetSystemDatabase(&szSysDB))) {
      return FALSE;
   }

   //
   // We found an appropriate szSysDB, so compare it with szDBPath
   //
   if (lstrcmp(szDBPath,szSysDB) == 0) {
      bIsSysDB = TRUE;
   } else {
      bIsSysDB = FALSE;
   }

   return bIsSysDB;
}

//+--------------------------------------------------------------------------
//
//  Function: GetSystemDatabase
//
//  Synopsis: Get the name of the current system database
//
//  Arguments:
//            [szDBPath] - [in/out] a pointer for the name of the system database
//                               The caller is responsible for freeing it.
//
//
//  Returns:  S_OK if the system database is found, otherwise an error
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
GetSystemDatabase(CString *szDBPath) 
{
   if (!szDBPath) 
   {
      return E_INVALIDARG;
   }

   //Raid bug 261450, Yang Gao, 3/30/2001
   CString sAppend;
   sAppend.LoadString( IDS_DB_DEFAULT );

   PWSTR pszPath = (LPTSTR)LocalAlloc( 0, (MAX_PATH +  sAppend.GetLength() + 1) * sizeof(WCHAR));
   if ( pszPath == NULL ) //Raid bug 427956, Yanggao, 7/2/2001
   {
      return E_FAIL;
   }
   if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_WINDOWS, NULL, 0, pszPath)))
   {
      //This is a safe usage.
      wcscpy( &(pszPath[lstrlen(pszPath)]), sAppend );
      *szDBPath = pszPath;
      if (pszPath)
      {
         LocalFree(pszPath);
         pszPath = NULL;
      }
      return S_OK;
   }

   if (pszPath) 
   {
      LocalFree(pszPath);
      pszPath = NULL;
   }
   return E_FAIL;
}


//+--------------------------------------------------------------------------
//
//  Function: ObjectStatusToString
//
//  Synopsis: Convert an object status value to a printable string
//
//  Arguments:
//            [status] - [in]  The status value to convert
//            [str]    - [out] The string to store the value in
//
//
//---------------------------------------------------------------------------
UINT
ObjectStatusToString(DWORD status, CString *strStatus) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if ( status & SCE_STATUS_PERMISSION_MISMATCH ) {
      status = IDS_MISMATCH;
   } else if (status & SCE_STATUS_AUDIT_MISMATCH) {
      status = IDS_MISMATCH;
   } else {
      status &= 0x0F;
      switch(status){
      case SCE_STATUS_NOT_ANALYZED:
         status = IDS_NOT_ANALYZED;
         break;
      case SCE_STATUS_GOOD:
         status = IDS_OK ;
         break;
      case SCE_STATUS_MISMATCH:
         status = IDS_MISMATCH;
         break;
      case SCE_STATUS_NOT_CONFIGURED:
         //
         // BUG 119215: The Analysis UI should never show "Not Defined"
         //             for the security of existing system objects
         //
         status = IDS_NOT_ANALYZED;
         break;
      case SCE_STATUS_CHILDREN_CONFIGURED:
         status = IDS_CHILDREN_CONFIGURED;
         break;
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
         status = IDS_NOT_AVAILABLE;
         break;
      case SCE_STATUS_NEW_SERVICE:
         status = IDS_NEW_SERVICE;
         break;
      default:
         //
         // We shouldn't get here, but for some reason we keep doing so
         //
         status = IDS_MISMATCH;
         break;
      }
   }

   if(strStatus){
      strStatus->LoadString(status);
   }
   return status;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsSecurityTemplate
//
//  Synopsis:   Validates a file to see if the file is a security template.
//
//  Arguments:  [pszFileName]   - The full path to the file to check.
//
//  Returns:    FALSE if the file does not exist or is not a valid
//                              security template.
//
//                              TRUE if successful.
//  History:
//
//---------------------------------------------------------------------------
BOOL
IsSecurityTemplate(
        LPCTSTR pszFileName
        )
{
        if(!pszFileName){
                return FALSE;
        }

        HANDLE hProfile;
        SCESTATUS rc;

        //
        // Open the profile.
        //
        rc = SceOpenProfile(
                                        pszFileName,
                                        SCE_INF_FORMAT,
                                        &hProfile
                                        );
        if(rc == SCESTATUS_SUCCESS && hProfile){

                PSCE_PROFILE_INFO ProfileInfo = NULL;
                PSCE_ERROR_LOG_INFO ErrBuf    = NULL;

                //
                // The profile will be validated by trying to load all the security areas.
                //
                rc = SceGetSecurityProfileInfo(hProfile,
                              SCE_ENGINE_SCP,
                              AREA_ALL,
                              &ProfileInfo,
                                      &ErrBuf);
                if(ErrBuf){
                        rc = SCESTATUS_INVALID_DATA;
                }

                //
                // Free up the memory.
                //
                SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
        ErrBuf = NULL;

        if ( ProfileInfo != NULL ) {
            SceFreeMemory((PVOID)ProfileInfo, AREA_ALL);
            LocalFree(ProfileInfo);
        }
        SceCloseProfile(&hProfile);

                //
                // return TRUE if everything is successful.
                //
                if(rc != SCESTATUS_INVALID_DATA){
                        return TRUE;
                }

        }

        return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Function:   WriteSprintf
//
//  Synopsis:   Writes formated [pszStr] to [pStm].
//
//  Arguments:  [pStm]      - Stream to write to.
//              [pszStr]    - Format string to write.
//              [...]       - printf formating
//
//  Returns:    The total number of bytes written.
//
//  History:
//
//---------------------------------------------------------------------------
int WriteSprintf( IStream *pStm, LPCTSTR pszStr, ...)
{
    TCHAR szWrite[512];
    va_list marker;
    va_start(marker, pszStr);

    vswprintf(szWrite, pszStr, marker);
    va_end(marker);

    ULONG nBytesWritten;
    int iLen = lstrlen(szWrite);

    if(pStm){
        pStm->Write( szWrite, iLen * sizeof(TCHAR), &nBytesWritten );
        return nBytesWritten;
    }
    return iLen;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadSprintf
//
//  Synopsis:   Reads formated [pszStr] from [pStm].
//              supported character switches are
//              'd' - integer pointer.
//
//  Arguments:  [pStm]      - Stream to read from.
//              [pszStr]    - Format string to test.
//              [...]       - pointer to the types defined by format
//                              specification types.
//
//  Returns:    Total number of bytes read from the stream
//
//  History:
//
//---------------------------------------------------------------------------
int
ReadSprintf( IStream *pStm, LPCTSTR pszStr, ...)
{

    if(!pStm || !pszStr){
        return -1;
    }

    va_list marker;
    va_start(marker, pszStr);

    TCHAR szRead[256];
    TCHAR szConv[512];
    ULONG uRead = 0;

    int i = 0;
    LPCTSTR pszNext = szRead;
    int iTotalRead = 0;

    // Get the current seek position.
    ULARGE_INTEGER liBack = { 0 };
    LARGE_INTEGER liCur = { 0 };
    pStm->Seek( liCur, STREAM_SEEK_CUR, &liBack);

#define INCBUFFER(sz)\
    if(uRead){\
        (sz)++;\
        uRead--;\
    } else {\
        pStm->Read(szRead, 256 * sizeof(TCHAR), &uRead);\
        uRead = uRead/sizeof(TCHAR);\
        (sz) = szRead;\
    }\
    iTotalRead++;

    while(*pszStr){
        if(!uRead){
            // Read information into buffer.
            pStm->Read( szRead, 256 * sizeof(TCHAR), &uRead);
            pszNext = szRead;

            uRead = uRead/sizeof(TCHAR);
            if(!uRead){
                iTotalRead = -1;
                break;
            }
        }

        if(*pszStr == '%'){
            pszStr++;
            switch( *pszStr ){
            case 'd':
                // read integer.
                pszStr++;
                i = 0;

                // copy number to our own buffer.
                while( (*pszNext >= L'0' && *pszNext <= L'9') ){
                    szConv[i++] = *pszNext;
                    INCBUFFER( pszNext );
                }

                szConv[i] = 0;

                // convert string to integer.
                *(va_arg(marker, int *)) = _wtol(szConv);
                continue;
               case 's':
                pszStr++;
                i = 0;
                // we have to have some kind of terminating character se we will use the
                // next value in pszStr.
                while( *pszNext && (*pszNext != *pszStr) ){
                    szConv[i++] = *pszNext;

                    INCBUFFER( pszNext );
                }

                if(*pszNext == *pszStr){
                    INCBUFFER( pszNext );
                }

                // copy the string value.
                szConv[i] = 0;
                if( i ){
                    LPTSTR pNew = (LPTSTR)LocalAlloc(0, sizeof(TCHAR) * (i + 1));
                    if(NULL != pNew){
                        //This is a safe usage.
                        lstrcpy(pNew, szConv);
                    }

                    LPTSTR *pArg;
                    pArg = (va_arg(marker, LPTSTR *));
                    if (pArg) {
                       *pArg = pNew;
                    }
                } else {
                    LPTSTR *pArg = va_arg(marker, LPTSTR *); //Prefast warning 269: Incorrect order of operations:  dereference ignored. Comments: It is not necessary.
                }
                pszStr++;
                continue;
            }
        }
        // check to make sure we are at the correct position in the file.
        if(*pszStr != *pszNext){
            iTotalRead = -1;
            break;
        }
        pszStr++;

        // increment buffer pointer.
        INCBUFFER( pszNext );
    }

    va_end(marker);

    // Reset streem seek pointer.
    liCur.LowPart  = liBack.LowPart;
    if(iTotalRead >= 0){
        liCur.LowPart += iTotalRead * sizeof(TCHAR);
    }
    liCur.HighPart = liBack.HighPart;
    pStm->Seek(liCur, STREAM_SEEK_SET, NULL);

    return iTotalRead;
#undef INCBUFFER
}


//+--------------------------------------------------------------------------------
// FileCreateError
//
// This function tries to create a new file use [pszFile].  It will display a
// message to the user if the file cannot be created.
//
// Arguments:  [pszFile]   - Full path of file to create.
//             [dwFlags]   - Flags
//                           FCE_IGNORE_FILEEXISTS - Ignore File exists error, and
//                                                   delete the file.
//
// Returns:    IDYES the file can be created
//             IDNo  The file cannot be created
DWORD
FileCreateError(
   LPCTSTR pszFile,
   DWORD dwFlags
   )
{
   if(!pszFile){
      return ERROR_INVALID_PARAMETER;
   }
   HANDLE hFile;
   DWORD dwErr = IDNO;
   //
   // Try to create the file.
   //
   hFile = ExpandAndCreateFile(
                            pszFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_ARCHIVE,
                            NULL
                            );
   if(hFile == INVALID_HANDLE_VALUE){
      //
      // Post error message to user.
      //
      dwErr = GetLastError();
      LPTSTR pszErr;
      CString strErr;
      //This is a safe usage.
      FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER |
         FORMAT_MESSAGE_FROM_SYSTEM,
         NULL,
         dwErr,
         0,
         (LPTSTR)&pszErr,
         0,
         NULL
         );

      strErr = pszErr;
      strErr += pszFile;

      if(pszErr){
         LocalFree(pszErr);
      }

      switch(dwErr){
      case ERROR_ALREADY_EXISTS:
      case ERROR_FILE_EXISTS:
         if( dwFlags & FCE_IGNORE_FILEEXISTS ){
            dwErr = IDYES;
            break;
         }
         //
         // Confirm overwrite.
         //
         strErr.Format(IDS_FILE_EXISTS_FMT, pszFile);
         dwErr = AfxMessageBox(
                  strErr,
                  MB_YESNO
                  );
         break;
      default:
         //
         // The file cannot be created.
         //
         AfxMessageBox(
                  strErr,
                  MB_OK
                  );
         dwErr = IDNO;
         break;
      }

   } else {
      //
      // It's OK to create the file.
      //
      ::CloseHandle( hFile );
      DeleteFile(pszFile);

      dwErr = IDYES;
   }

   return dwErr;
}


//+--------------------------------------------------------------------------
//
//  Function:  IsDBCSPath
//
//  Synopsis:  Check if a path contains DBCS characters
//
//  Arguments: [pszFile] - [in]  The path to check
//
//  Returns:   TRUE if pszFile contains characters that can't be
//                  represented by a LPSTR
//
//             FALSE if pszFile only contains characters that can
//                   be represented by a LPSTR
//
//
//+--------------------------------------------------------------------------
BOOL
IsDBCSPath(LPCTSTR szWideFile) {
   while(*szWideFile) {
      if (*szWideFile >= 256) {
         return TRUE;
      }
      szWideFile++;
   }
   return FALSE;

/*
   LPSTR szMBFile;
   int nMBFile;
   BOOL bUsedDefaultChar = FALSE;

   nMBFile = sizeof(LPSTR)*(lstrlen(szWideFile));
   szMBFile = (LPSTR)LocalAlloc(LPTR,nMBFile+1);

   if (szMBFile) {
      WideCharToMultiByte( CP_ACP,
                           0,
                           szWideFile,
                           -1,
                           szMBFile,
                           nMBFile,
                           NULL,
                           &bUsedDefaultChar);

      LocalFree(szMBFile);
   }

   return bUsedDefaultChar;
*/
}

//+--------------------------------------------------------------------------
//
//  Function:  GetSeceditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetSeceditHelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH); //Bogus assert. Yanggao.
       helpFileName.ReleaseBuffer ();

       helpFileName += L"\\help\\wsecedit.hlp";
   }

   return helpFileName;
}

//+--------------------------------------------------------------------------
//
//  Function:  GetGpeditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetGpeditHelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH); //Bogus Assert. Yanggao.
       helpFileName.ReleaseBuffer ();

       helpFileName += L"\\help\\gpedit.hlp";
   }

   return helpFileName;
}
//+--------------------------------------------------------------------------
//
//  Function:  ExpandEnvironmentStringWrapper
//
//  Synopsis:  Takes an LPTSTR and expands the enviroment variables in it
//
//  Arguments: Pointer to the string to expand.
//
//  Returns:   a CString containing the fully expanded string.
//
//+--------------------------------------------------------------------------
CString ExpandEnvironmentStringWrapper(LPCTSTR psz)
{
    LPTSTR  pszBuffer = NULL;
    DWORD   dwExpanded = 0;
    CString sz;

    dwExpanded = ExpandEnvironmentStrings(psz, NULL, 0);

    pszBuffer = sz.GetBuffer(dwExpanded);
    ExpandEnvironmentStrings(psz, pszBuffer, dwExpanded);
    sz.ReleaseBuffer();

    return (sz);
}

//+--------------------------------------------------------------------------
//
//  Function:  ExpandAndCreateFile
//
//  Synopsis:  Just does a normal CreateFile(), but expands the filename before
//             creating the file.
//
//  Arguments: Same as CreateFile().
//
//  Returns:   HANDLE to the created file.
//
//+--------------------------------------------------------------------------
HANDLE WINAPI ExpandAndCreateFile (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HANDLE  hRet = INVALID_HANDLE_VALUE;
    CString sz;

    sz = ExpandEnvironmentStringWrapper(lpFileName);
    //This is a safe usage. sz is full path.
    return (CreateFile(
                sz,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile));
}

   //**********************************************************************
   //
   //  FUNCTION:     IsAdmin - This function checks the token of the
   //                calling thread to see if the caller belongs to
   //                the Administrators group.
   //
   //  PARAMETERS:   none
   //
   //  RETURN VALUE: TRUE if the caller is an administrator on the local
   //                machine.  Otherwise, FALSE.
   //
   //**********************************************************************

   BOOL IsAdmin(void) {

      HANDLE        hAccessToken = NULL;
      PTOKEN_GROUPS ptgGroups    = NULL;
      DWORD         cbGroups     = 0;
      PSID          psidAdmin    = NULL;
      UINT          i;

      SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

      // assume the caller is not an administrator
      BOOL bIsAdmin = FALSE;

      __try {

         if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
               &hAccessToken)) {

            if (GetLastError() != ERROR_NO_TOKEN)
               __leave;

            // retry against process token if no thread token exists
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
                  &hAccessToken))
               __leave;
         }

         // determine required size of buffer for token information
         if (GetTokenInformation(hAccessToken, TokenGroups, NULL, 0,
               &cbGroups)) {

            // call should have failed due to zero-length buffer
            __leave;

         } else {

            // call should have failed due to zero-length buffer
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
               __leave;
         }

         // allocate a buffer to hold the token groups
         ptgGroups = (PTOKEN_GROUPS) HeapAlloc(GetProcessHeap(), 0,
            cbGroups);
         if (!ptgGroups)
            __leave;

         // call GetTokenInformation() again to actually retrieve the groups
         if (!GetTokenInformation(hAccessToken, TokenGroups, ptgGroups,
               cbGroups, &cbGroups))
            __leave;

         // create a SID for the local administrators group
         // This is a safe usage.
         if (!AllocateAndInitializeSid(&siaNtAuthority, 2,
               SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0, &psidAdmin))
            __leave;

         // scan the token's groups and compare the SIDs to the admin SID
         for (i = 0; i < ptgGroups->GroupCount; i++) {
            //This is a safe usage. psidAdmin is a local admin SID.
            if (EqualSid(psidAdmin, ptgGroups->Groups[i].Sid)) {
               bIsAdmin = TRUE;
               break;
            }
         }

      } __finally {

         // free resources
         if (hAccessToken)
            CloseHandle(hAccessToken);

         if (ptgGroups)
            HeapFree(GetProcessHeap(), 0, ptgGroups);

         if (psidAdmin)
            FreeSid(psidAdmin);
      }

      return bIsAdmin;
   }



//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToSZ
//
//  Synopsis:  Converts a multiline string to a comma delimited normal string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR MultiSZToSZ(PCWSTR sz)
{
   PWSTR szOut = NULL;

   ASSERT(sz);
   if (!sz)
   {
      return NULL;
   }
   //Bug 349000, Yang Gao, 3/23/2001 
   long i = 0;
   long j = 0;
   while( L'\0' != sz[i] )
   {
      if( L',' == sz[i] )
         j++;
      i++;
   }

   szOut = (PWSTR) LocalAlloc(LPTR,(lstrlen(sz)+j*2+1)*sizeof(wchar_t)); //Raid #376228, 4/25/2001
   if (!szOut)
   {
      return NULL;
   }

   BOOL newline = FALSE; //raid #464335, Yang Gao, 9/7/2001
   for(i=0,j=0; sz[i] != L'\0'; i++)
   {
      if( L'\n' == sz[i] )
      {
         if( newline )
         {
            szOut[j++] = MULTISZ_DELIMITER;
         }
         newline = FALSE;
         continue;
      } 
      
      if( L'\r' == sz[i] ) 
      {
         continue;   // ignore it
      } 
      
      if( L' ' == sz[i] && !newline ) //raid #464335, Yang Gao, 9/7/2001
      {
         continue; //delete it if it occurs before any char of each line.
      }
      newline = TRUE;

      if( L',' == sz[i] )
      {
         szOut[j++] = MULTISZ_QUOTE;
         szOut[j++] = sz[i];
         szOut[j++] = MULTISZ_QUOTE;
         continue;
      }

      szOut[j++] = sz[i];
   }

   return szOut;
}

//+--------------------------------------------------------------------------
//
//  Function:  SZToMultiSZ
//
//  Synopsis:  Converts a comma delimited string to a multiline string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR SZToMultiSZ(PCWSTR sz) 
{
   PWSTR szOut = NULL;

   ASSERT(sz);
   if (!sz)
   {
      return NULL;
   }
   //
   // Calculate the length of the expanded string
   //
   int cSZ = 0;
   for (int i = 0;sz[i] != L'\0'; i++)
   {
      if (MULTISZ_DELIMITER == sz[i])
      {
         //
         // Delimiter expands into an extra character so count it twice
         //
         cSZ++;
      }
      cSZ++;
   }

   szOut = (PWSTR) LocalAlloc(LPTR,(cSZ+1)*sizeof(wchar_t));
   if (!szOut)
   {
      return NULL;
   }

   BOOL qflag = FALSE;
   for(int i=0, c=0; sz[i] != L'\0'; i++)
   {
      //Bug 349000, Yang Gao, 3/23/2001
      if( MULTISZ_QUOTE == sz[i] && MULTISZ_DELIMITER == sz[i+1] )
      {
         qflag = TRUE;
         continue;
      }
      if( MULTISZ_DELIMITER == sz[i] && MULTISZ_QUOTE == sz[i+1] && qflag )
      {
         szOut[c++] = sz[i];
         i++;
         qflag = FALSE;
         continue;
      }
      qflag = FALSE;
      if (MULTISZ_DELIMITER == sz[i])
      {
         szOut[c++] = L'\r';
         szOut[c++] = L'\n';
      }
      else
      {
         szOut[c++] = sz[i];
      }
   }

   return szOut;
}

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToDisp
//
//  Synopsis:  Converts a comma delimited multiline string to a display string
//
//  Returns:   The converted string
//  Bug 349000, Yang Gao, 3/23/2001
//+--------------------------------------------------------------------------
void MultiSZToDisp(PCWSTR sz, CString &pszOut)
{

   ASSERT(sz);
   if (!sz)
   {
      return;
   }
   //
   // Calculate the length of the expanded string
   //
   int cSZ = 0;
   for (int i = 0;sz[i] != L'\0'; i++)
   {
      if (MULTISZ_DELIMITER == sz[i])
      {
         //
         // Delimiter expands into an extra character so count it twice
         //
         cSZ++;
      }
      cSZ++;
   }

   PWSTR szOut;
   szOut = (PWSTR) LocalAlloc(LPTR,(cSZ+1)*sizeof(wchar_t));
   if (!szOut)
   {
      return;
   }

   BOOL qflag = FALSE;
   for(int i=0, c=0; sz[i] != L'\0'; i++)
   {
      if( MULTISZ_QUOTE == sz[i] && MULTISZ_DELIMITER == sz[i+1] )
      {
         qflag = TRUE;
         continue;
      }
      if( MULTISZ_DELIMITER == sz[i] && MULTISZ_QUOTE == sz[i+1] && qflag )
      {
         szOut[c++] = sz[i];
         i++;
         qflag = FALSE;
         continue;
      }
      qflag = FALSE;
      szOut[c++] = sz[i];
   }

   pszOut = szOut;
   LocalFree(szOut);
   
   return;
}

SCE_PROFILE_INFO *g_pDefaultTemplate = NULL;

SCE_PROFILE_INFO *
GetDefaultTemplate() {
   SCE_PROFILE_INFO *pspi = NULL;
   DWORD RegType = 0;
   SCESTATUS rc = 0;
   LPTSTR szInfFile = NULL;
   PVOID pHandle = NULL;

   if (g_pDefaultTemplate) {
      return g_pDefaultTemplate;
   }

   rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                   SCE_REGISTRY_KEY,
                   SCE_REGISTRY_DEFAULT_TEMPLATE,
                   (PVOID *)&szInfFile,
                   &RegType );

   if (ERROR_SUCCESS != rc) {
      if (szInfFile) {
         LocalFree(szInfFile);
         szInfFile = NULL;
      }
      return NULL;
   }
   if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
      LocalFree(szInfFile);
      szInfFile = NULL;
      return NULL;
   }
   LocalFree(szInfFile);
   szInfFile = NULL;
   rc = SceGetSecurityProfileInfo(pHandle,
                                  SCE_ENGINE_SCP,
                                  AREA_ALL,
                                  &pspi,
                                  NULL
                                 );

   SceCloseProfile(&pHandle);
   if (SCESTATUS_SUCCESS != rc) {
      //
      // expand registry value section based on registry values list on local machine
      //

      SceRegEnumAllValues(
                         &(pspi->RegValueCount),
                         &(pspi->aRegValues)
                         );


#define PD(X,Y) if (pspi->X == SCE_NO_VALUE) { pspi->X = Y; }
      PD(MaximumPasswordAge,MAX_PASS_AGE_DEFAULT)
      PD(MinimumPasswordAge,MIN_PASS_AGE_DEFAULT)
      PD(MinimumPasswordLength,MIN_PASS_LENGTH_DEFAULT)
      PD(PasswordHistorySize,PASS_HISTORY_SIZE_DEFAULT)
      PD(PasswordComplexity,PASS_COMPLEXITY_DEFAULT)
      PD(RequireLogonToChangePassword,REQUIRE_LOGIN_DEFAULT)
      PD(LockoutBadCount,LOCKOUT_BAD_COUNT_DEFAULT)
      PD(ResetLockoutCount,RESET_LOCKOUT_COUNT_DEFAULT)
      PD(LockoutDuration,LOCKOUT_DURATION_DEFAULT)
      PD(AuditSystemEvents,AUDIT_SYSTEM_EVENTS_DEFAULT)
      PD(AuditLogonEvents,AUDIT_LOGON_EVENTS_DEFAULT)
      PD(AuditObjectAccess,AUDIT_OBJECT_ACCESS_DEFAULT)
      PD(AuditPrivilegeUse,AUDIT_PRIVILEGE_USE_DEFAULT)
      PD(AuditPolicyChange,AUDIT_POLICY_CHANGE_DEFAULT)
      PD(AuditAccountManage,AUDIT_ACCOUNT_MANAGE_DEFAULT)
      PD(AuditProcessTracking,AUDIT_PROCESS_TRACKING_DEFAULT)
      PD(AuditDSAccess,AUDIT_DS_ACCESS_DEFAULT)
      PD(AuditAccountLogon,AUDIT_ACCOUNT_LOGON_DEFAULT)
      PD(ForceLogoffWhenHourExpire,FORCE_LOGOFF_DEFAULT)
      PD(EnableAdminAccount,ENABLE_ADMIN_DEFAULT)
      PD(EnableGuestAccount,ENABLE_GUEST_DEFAULT)
      PD(LSAAnonymousNameLookup,LSA_ANON_LOOKUP_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_SYSTEM],SYS_MAX_LOG_SIZE_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_APP],APP_MAX_LOG_SIZE_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_SECURITY],SEC_MAX_LOG_SIZE_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM],SYS_LOG_RETENTION_PERIOD_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_APP],APP_LOG_RETENTION_PERIOD_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY],SEC_LOG_RETENTION_PERIOD_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_APP],APP_LOG_RETENTION_DAYS_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_SYSTEM],SYS_LOG_RETENTION_DAYS_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_SECURITY],SEC_LOG_RETENTION_DAYS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_APP],APP_RESTRICT_GUEST_ACCESS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_SYSTEM],SYS_RESTRICT_GUEST_ACCESS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_SECURITY],SEC_RESTRICT_GUEST_ACCESS_DEFAULT)

      if (pspi->pFiles.pAllNodes->Count == 0) {
         DWORD SDSize = 0;
         pspi->pFiles.pAllNodes->Count = 1;
         pspi->pFiles.pAllNodes->pObjectArray[0] =
            (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
         if (pspi->pFiles.pAllNodes->pObjectArray[0]) {
            SceSvcConvertTextToSD (
               FILE_SYSTEM_SECURITY_DEFAULT,
               &(pspi->pFiles.pAllNodes->pObjectArray[0]->pSecurityDescriptor),
               &SDSize,
               &(pspi->pFiles.pAllNodes->pObjectArray[0]->SeInfo)
               );
         }
      }

      if (pspi->pRegistryKeys.pAllNodes->Count == 0) {
         DWORD SDSize = 0;
         pspi->pRegistryKeys.pAllNodes->Count = 1;
         pspi->pRegistryKeys.pAllNodes->pObjectArray[0] =
            (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
         if (pspi->pRegistryKeys.pAllNodes->pObjectArray[0]) {
            SceSvcConvertTextToSD (
               REGISTRY_SECURITY_DEFAULT,
               &(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->pSecurityDescriptor),
               &SDSize,
               &(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->SeInfo)
               );
         }
      }

      if (pspi->pServices->General.pSecurityDescriptor == NULL) {
         DWORD SDSize = 0;
         SceSvcConvertTextToSD (
               SERVICE_SECURITY_DEFAULT,
               &(pspi->pServices->General.pSecurityDescriptor),
               &SDSize,
               &(pspi->pServices->SeInfo)
               );
      }
   }
   g_pDefaultTemplate = pspi;
   return pspi;
}


HRESULT
GetDefaultFileSecurity(PSECURITY_DESCRIPTOR *ppSD,
                       SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pFiles.pAllNodes) {
      return E_FAIL;
   }
   if (pspi->pFiles.pAllNodes->Count == 0) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pFiles.pAllNodes->pObjectArray[0]->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pFiles.pAllNodes->pObjectArray[0]->pSecurityDescriptor,
                             ppSD);
}

HRESULT
GetDefaultRegKeySecurity(PSECURITY_DESCRIPTOR *ppSD,
                         SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pRegistryKeys.pAllNodes) {
      return E_FAIL;
   }
   if (pspi->pRegistryKeys.pAllNodes->Count == 0) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->pSecurityDescriptor,
                             ppSD);
}

HRESULT
GetDefaultServiceSecurity(PSECURITY_DESCRIPTOR *ppSD,
                          SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pServices) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pServices->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pServices->General.pSecurityDescriptor,
                             ppSD);
}


BOOL
GetSecureWizardName(
    OUT LPTSTR *ppstrPathName OPTIONAL,
    OUT LPTSTR *ppstrDisplayName OPTIONAL
    )
{
    BOOL b=FALSE;

    if ( ppstrPathName == NULL && ppstrDisplayName == NULL) return FALSE;

    if ( ppstrPathName )
        *ppstrPathName = NULL;

    if ( ppstrDisplayName )
        *ppstrDisplayName = NULL;


#define SCE_WIZARD_PATH     SCE_ROOT_PATH TEXT("\\Wizard")

    DWORD rc;
    DWORD RegType;
    LPVOID pValue=NULL;
    PWSTR pPathName = NULL;

    rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                         SCE_WIZARD_PATH,
                         TEXT("Path"),
                         &pValue,
                         &RegType
                        );

    if ( ERROR_SUCCESS == rc && pValue &&
         (RegType == REG_SZ ||
          RegType == REG_EXPAND_SZ) ) {


        if ( RegType == REG_EXPAND_SZ ) {
            //
            // Expand the environment variable
            //
            DWORD dSize = ExpandEnvironmentStrings((LPTSTR)pValue, NULL, 0);

            if ( dSize > 0 ) {
                pPathName = (PWSTR)LocalAlloc(LPTR, (dSize+1)*sizeof(WCHAR));

                if ( pPathName ) {

                    ExpandEnvironmentStrings((LPTSTR)pValue, pPathName, dSize);

                } else {
                    LocalFree(pValue);
                    return FALSE;
                }

            } else {

                LocalFree(pValue);
                return FALSE;
            }

        } else {

            //
            // just simply take the string
            //
            pPathName = (LPTSTR)pValue;
            pValue = NULL;
        }

        if ( ppstrDisplayName ) {
            //
            // now query the display name (menu name) from the binary
            // binary name is stored in pPathName (can't be NULL)
            //
            DWORD dwHandle=0;

            DWORD dwSize = GetFileVersionInfoSize(pPathName, &dwHandle);

            if ( dwSize > 0 ) {

                LPVOID pBuffer = (LPVOID)LocalAlloc(LPTR, dwSize+1);

                if ( pBuffer ) {
                    if ( GetFileVersionInfo(pPathName, 0, dwSize, pBuffer) ) {

                        PVOID   lpInfo = 0;
                        UINT    cch = 0;
                        CString key;
                        WCHAR   szBuffer[10];
                        CString keyBase;
                        //This is a safe usage.
                        wsprintf (szBuffer, L"%04X", GetUserDefaultLangID ());
                        wcscat (szBuffer, L"04B0");

                        keyBase = L"\\StringFileInfo\\";
                        keyBase += szBuffer;
                        keyBase += L"\\";


                        key = keyBase + L"FileDescription";
                        if ( VerQueryValue (pBuffer, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) ) {

                            *ppstrDisplayName = (PWSTR)LocalAlloc(LPTR,(cch+1)*sizeof(WCHAR));
                            if ( *ppstrDisplayName ) {
                                //This may not be a safe usage. ppstrDisplayName is PTSTR. Consider fix.
                                wcscpy(*ppstrDisplayName, (PWSTR)lpInfo);

                                b=TRUE;
                            }
                        }
                    }

                    LocalFree(pBuffer);

                }
            }
        }

        //
        // get the binary name
        //
        if ( ppstrPathName ) {
            *ppstrPathName = pPathName;
            pPathName = NULL;

            b=TRUE;
        }

    }

    if ( pPathName && (pPathName != pValue ) ) {
        LocalFree(pPathName);
    }

    if ( pValue ) {
        LocalFree(pValue);
    }

    return b;
}

BOOL IsValidFileName(CString& str)
{
    CString text;
    CString charsWithSpaces;
    UINT nIndex = 0;

    PCWSTR szInvalidCharSet = ILLEGAL_FILENAME_CHARS; 
    
    if( str == L'.' || str == L"..") //Raid #617915, Yanggao
       return FALSE;

    if( -1 != str.FindOneOf(szInvalidCharSet) )
    {
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        //This is a sage usage.
        text.FormatMessage (IDS_INVALID_FILENAME, charsWithSpaces);

        AfxMessageBox(text, MB_OK|MB_ICONEXCLAMATION);
  
        return FALSE;
    }

    //Raid 484084, Yanggao, 10/24/2001
    int strlength = str.GetLength(); 
    if( 1==strlength && (str.GetAt(0) == L'/' || str.GetAt(0) == L'\\') )
    {
        szInvalidCharSet = ILLEGAL_FILENAME_CHARS2; //Raid #526397, 2/26/2002, yanggao
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        //This is a safe usage.
        text.FormatMessage (IDS_INVALID_FILENAMEPATH, charsWithSpaces);
        AfxMessageBox(text, MB_OK|MB_ICONEXCLAMATION);
        return FALSE;
    }
    int pos1 = str.Find(L"\\\\");
    int pos2 = str.Find(L"//");
    int pos3 = str.Find(L"\\/");
    int pos4 = str.Find(L"/\\");
    if( pos1>=0 || pos2>=0 || pos3>=0 || pos4>=0 ) //Raid #498480, yanggao, do not accept "\\".
    {
        szInvalidCharSet = ILLEGAL_FILENAME_CHARS1;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        //This is a safe usage.
        text.FormatMessage (IDS_INVALID_FILENAME, charsWithSpaces);
        AfxMessageBox(text, MB_OK|MB_ICONEXCLAMATION);
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//Raid #533432, yanggao, 4/3/2002
//Currently pextension should include '.'
///////////////////////////////////////////////////////////////////
#define IsDigit(c) ((c) >= L'0' && c <= L'9') 
BOOL IsNameReserved(LPCWSTR pszName, LPCWSTR pextension)
{
    static const WCHAR *rgszPorts3[] =  { 
        TEXT("NUL"),
        TEXT("PRN"),
        TEXT("CON"),
        TEXT("AUX"),
    };

    static const WCHAR *rgszPorts4[] =  { 
        TEXT("LPT"),  // LPT#
        TEXT("COM"),  // COM#
    };

    if( !pszName || !pextension )
       return FALSE;

    CString sz = pszName;
    CString tempsz = pextension;
    if( _wcsicmp(sz.Right(tempsz.GetLength()), tempsz) == 0 ) //Remove extension
    {
       tempsz = sz.Left(sz.GetLength() - tempsz.GetLength());
    }
    else
    {
       tempsz = sz;
    }

    int cch = tempsz.ReverseFind(L'\\'); //Remove path
    int iMax = tempsz.ReverseFind(L'/');
    if( cch < iMax )
    {
       cch = iMax;
    }
    if( cch >= 0 )
    {
       cch = tempsz.GetLength() - cch - 1;
       sz = tempsz.Right(cch);
    }
    else
    {
       sz = tempsz;
    }

    LPCTSTR* rgszPorts = rgszPorts3;
    cch = sz.GetLength();
    tempsz = sz;

    iMax = ARRAYSIZE(rgszPorts3);
    if (cch == 4 && IsDigit(sz.GetAt(3)))
    {
        //  if 4 chars start with LPT checks
        //  need to filter out:
        //      COM1, COM2, etc.  LPT1, LPT2, etc
        //  but not:
        //      COM or LPT or LPT10 or COM10
        //  COM == 1 and LPT == 0

        iMax = ARRAYSIZE(rgszPorts4);
        rgszPorts = rgszPorts4;
        sz.SetAt(3, L'\0');
        cch = 3;
    }

    if (cch == 3)
    {
        int i = 0;
        for (i; i < iMax; i++)
        {
            if (!lstrcmpi(rgszPorts[i], sz))
            {
                break;
            }
        }
        if( i != iMax )
        {
            sz.FormatMessage(IDS_RESERVED_NAME, tempsz);
            AfxMessageBox(sz, MB_OK|MB_ICONEXCLAMATION);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       util.h
//
//  Contents:   definition of CWriteHtmlFile
//
//----------------------------------------------------------------------------
#ifndef __SECMGR_UTIL__
#define __SECMGR_UTIL__

#define MULTISZ_DELIMITER L','
#define MULTISZ_QUOTE L'"'

#define DIALOG_TYPE_ANALYZE     0
#define DIALOG_TYPE_APPLY       1
#define DIALOG_DEFAULT_ANALYZE  2
#define DIALOG_TYPE_REAPPLY     3
#define DIALOG_TYPE_ADD_LOCATION    4
#define DIALOG_FULLPATH_PROFILE     5
#define DIALOG_TYPE_PROFILE     6
#define DIALOG_SAVE_PROFILE     7


#define DW_VALUE_FOREVER    1
#define DW_VALUE_NEVER      2
#define DW_VALUE_NOZERO     4
#define DW_VALUE_OFF        8

#define MERGED_TEMPLATE 1
#define MERGED_INSPECT  2

#define INVALID_DESC_CHARS  L";"
/////////////////////////////////////////////////////////////////////////////////////////
// CWriteHtmlFile
// Class for writting an html file.
//
// Call Create to create an html file.  If [pszFile] is NULL then, a temporary SCE###.htm
// file is created in the GetTempPath() directory.
//
// After Create has been called, Call Write to write the body of the HTML.
// After the class has been destroyed, the file will be closed.
//
// Get the file name of the HTML by called GetFileName().
class CWriteHtmlFile
{
public:
   CWriteHtmlFile();
   virtual ~CWriteHtmlFile();
   DWORD Create(LPCTSTR pszFile = NULL);
   DWORD Write( LPCTSTR pszString, ... );
   DWORD Write( UINT uRes );
   DWORD CopyTextFile( LPCTSTR pszFile, DWORD dwPosLow = 0, BOOL gInterpret = TRUE);
   DWORD Close( BOOL bDelete );
public:
   int GetFileName( LPTSTR pszFileName, UINT nSize );

protected:
   HANDLE m_hFileHandle;      // The handle of the file.
   BOOL   m_bErrored;         // This is true if an operation fails.
   CString m_strFileName;     // The file name.
};


DWORD MyRegSetValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       const BYTE *Value,
                       const DWORD cbValue,
                       const DWORD pRegType );

DWORD MyRegQueryValue( HKEY hKeyRoot, LPCTSTR SubKey,
                 LPCTSTR ValueName, PVOID *Value, LPDWORD pRegType );
BOOL FilePathExist(LPCTSTR Name, BOOL IsPath, int Flag);

void MyFormatResMessage(SCESTATUS rc, UINT residMessage, PSCE_ERROR_LOG_INFO errBuf,
                     CString& strOut);
void MyFormatMessage(SCESTATUS rc, LPCTSTR mes, PSCE_ERROR_LOG_INFO errBuf,
                     CString& strOut);
DWORD SceStatusToDosError(SCESTATUS SceStatus);

BOOL CreateNewProfile(CString ProfileName, PSCE_PROFILE_INFO *ppspi = NULL);
BOOL SetProfileInfo(LONG_PTR,LONG_PTR,PEDITTEMPLATE);


BOOL GetSceStatusString(SCESTATUS status, CString *strStatus);

void ErrorHandlerEx(WORD, LPTSTR);
#define ErrorHandler() ErrorHandlerEx(__LINE__,TEXT( __FILE__))

bool GetRightDisplayName(LPCTSTR szSystemName, LPCTSTR szName, LPTSTR szDisp, LPDWORD cbDisp);

void DumpProfileInfo(PSCE_PROFILE_INFO pInfo);

HRESULT MyMakeSelfRelativeSD(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew );

PSCE_NAME_STATUS_LIST
MergeNameStatusList(PSCE_NAME_LIST pTemplate, PSCE_NAME_LIST pInspect);

BOOL VerifyKerberosInfo(PSCE_PROFILE_INFO pspi);

DWORD
SceRegEnumAllValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    );

#define STATUS_GROUP_MEMBERS    1
#define STATUS_GROUP_MEMBEROF   2
#define STATUS_GROUP_RECORD     3

#define MY__SCE_MEMBEROF_NOT_APPLICABLE  (DWORD)-100

DWORD
GetGroupStatus(
    DWORD status,
    int flag
    );


//+--------------------------------------------------------------------------
//
//  Function: AllocGetTempFileName
//
//  Synopsis: Allocate and return a string with a temporary file name.
//
//  Returns:  The temporary file name, or 0 if a temp file can't be found
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR AllocGetTempFileName();


//+--------------------------------------------------------------------------
//
//  Function: UnexpandEnvironmentVariables
//
//  Synopsis: Given a path, contract any leading members to use matching
//            environment variables, if any
//
//  Arguments:
//            [szPath] - The path to expand
//
//  Returns:  The newly allocated path (NULL if it can't allocate memory)
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR UnexpandEnvironmentVariables(LPCTSTR szPath);

//
// change system database reg value from "DefaultProfile" to "SystemDatabase"
// temporarily - until UI design change is checked in.
//
#define SYSTEM_DB_REG_VALUE     TEXT("DefaultProfile")

//+--------------------------------------------------------------------------
//
//  Function: IsSystemDatabase
//
//  Synopsis: Determine if a specific databse is the system database or a private one
//
//  Arguments:
//            [szDBPath] - The database path to check
//
//  Returns:  True if szDBPath is the system database, false otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL IsSystemDatabase(LPCTSTR szDBPath);


//+--------------------------------------------------------------------------
//
//  Function: GetSystemDatabase
//
//  Synopsis: Get the name of the current system database
//
//  Arguments:
//            [szDBPath] - [in/out] a pointer for the name of the system database
//                               The caller is responsible for freeing it.
//
//
//  Returns:  S_OK if the system database is found, otherwise an error
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT GetSystemDatabase(CString *szDBPath);



//+--------------------------------------------------------------------------
//
//  Function: ObjectStatusToString
//
//  Synopsis: Convert an object status value to a printable string
//
//  Arguments:
//            [status] - [in]  The status value to convert
//            [str]    - [out] The string to store the value in
//
//
//---------------------------------------------------------------------------
UINT ObjectStatusToString(DWORD status, CString *str);

BOOL
IsSecurityTemplate(                             // Returns TRUE if [pszFileName] is a valid security template
        LPCTSTR pszFileName
        );

DWORD
FormatDBErrorMessage(                   // Returns the string error message for a database return code
        SCESTATUS sceStatus,
        LPCTSTR pszDatabase,
        CString &strOut
        );


int
WriteSprintf(                           // Write format string to file
    IStream *pStm,
    LPCTSTR pszStr,
    ...
    );

int
ReadSprintf(                            // Read format string from IStream
    IStream *pStm,
    LPCTSTR pszStr,
    ...
    );

#define FCE_IGNORE_FILEEXISTS 0x0001   // Ignore file exists problem and delete the
                                       // the file.
DWORD
FileCreateError(
   LPCTSTR pszFile,
   DWORD dwFlags
   );



//+--------------------------------------------------------------------------
//
//  Function:  IsDBCSPath
//
//  Synopsis:  Check if a path contains DBCS characters
//
//  Arguments: [pszFile] - [in]  The path to check
//
//  Returns:   TRUE if pszFile contains characters that can't be
//                  represented by a LPSTR
//
//             FALSE if pszFile only contains characters that can
//                   be represented by a LPSTR
//
//
//+--------------------------------------------------------------------------
BOOL
IsDBCSPath(LPCTSTR pszFile);


//+--------------------------------------------------------------------------
//
//  Function:  GetSeceditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString
GetSeceditHelpFilename();

//+--------------------------------------------------------------------------
//
//  Function:  GetGpeditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetGpeditHelpFilename();

//+--------------------------------------------------------------------------
//
//  Function:  ExpandEnvironmentStringWrapper
//
//  Synopsis:  Takes an LPTSTR and expands the enviroment variables in it
//
//  Arguments: Pointer to the string to expand.
//
//  Returns:   a CString containing the fully expanded string.
//
//+--------------------------------------------------------------------------
CString ExpandEnvironmentStringWrapper(LPCTSTR psz);

//+--------------------------------------------------------------------------
//
//  Function:  ExpandAndCreateFile
//
//  Synopsis:  Just does a normal CreateFile(), but expands the filename before
//             creating the file.
//
//  Arguments: Same as CreateFile().
//
//  Returns:   HANDLE to the created file.
//
//+--------------------------------------------------------------------------
HANDLE WINAPI ExpandAndCreateFile (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );



//+--------------------------------------------------------------------------
//
//  Function:  GetDefault
//
//  Synopsis:  Find the default values for undefined policies
//
//  Arguments: The IDS_* for the name of the policy
//
//  Returns:   The DWORD to assign as the default value for the policy.
//
//+--------------------------------------------------------------------------
DWORD GetDefault(DWORD dwPolicy);


//+--------------------------------------------------------------------------
//
//  Function:  GetRegDefault
//
//  Synopsis:  Free the default values for undefined policies
//
//  Arguments: The PSCE_REGISTRY_VALUE to find the default for
//
//  Returns:   The DWORD to assign as the default value for the policy.
//
//+--------------------------------------------------------------------------
DWORD GetRegDefault(PSCE_REGISTRY_VALUE_INFO pRV);

//+--------------------------------------------------------------------------
//
//  Function:  IsAdmin
//
//  Synopsis:  Detects if the process is being run in an admin context
//
//  Returns:   TRUE if an admin, FALSE otherwise
//
//+--------------------------------------------------------------------------
BOOL IsAdmin(void);

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToSZ
//
//  Synopsis:  Converts a multiline string to a comma delimited normal string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR MultiSZToSZ(PCWSTR sz);

//+--------------------------------------------------------------------------
//
//  Function:  SZToMultiSZ
//
//  Synopsis:  Converts a comma delimited string to a multiline string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR SZToMultiSZ(PCWSTR sz);

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToDisp
//
//  Synopsis:  Converts a comma delimited multiline string to a display string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
void MultiSZToDisp(PCWSTR sz, CString &pszOut);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultTemplate
//
//  Synopsis:  Retrieves the default template from the system
//
//  Returns:   The template
//
//+--------------------------------------------------------------------------
SCE_PROFILE_INFO *GetDefaultTemplate();

//+--------------------------------------------------------------------------
//
//  Function:  IsValidFileName
//
//  Synopsis:  check invalid chars in a file name.
//
//  Returns:   BOOL
//
//+--------------------------------------------------------------------------
BOOL IsValidFileName(CString& str);

BOOL IsNameReserved(LPCWSTR pszName, LPCWSTR pextension);
//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultFileSecurity
//
//  Synopsis:  Retrieves the default file security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultFileSecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultRegKeySecurity
//
//  Synopsis:  Retrieves the default registry key security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultRegKeySecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultserviceSecurity
//
//  Synopsis:  Retrieves the default service security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultServiceSecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);


BOOL
LookupRegValueProperty(
    IN LPTSTR RegValueFullName,
    OUT LPTSTR *pDisplayName,
    OUT PDWORD displayType,
    OUT LPTSTR *pUnits OPTIONAL,
    OUT PREGCHOICE *pChoices OPTIONAL,
    OUT PREGFLAGS *pFlags OPTIONAL
    );

BOOL
GetSecureWizardName(
    OUT LPTSTR *ppstrPathName OPTIONAL,
    OUT LPTSTR *ppstrDisplayName OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wmihooks.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wmihooks.h
//
//  Contents:   definition of CWMIRsop
//
//----------------------------------------------------------------------------
#ifndef WMIHOOKS_H
#define WMIHOOKS_H

using namespace std;
#define MAX_REG_VALUE_NUM 100

typedef struct _RSOP_INFO
{
    ULONG precedence;
    ULONG status;
    ULONG error;
    LPWSTR pszGPOID;
}RSOP_INFO, *PRSOP_INFO;

VOID FreeRI(PRSOP_INFO ptr);

typedef struct _WMI_SCE_PROFILE_INFO: public SCE_PROFILE_INFO
{
    PRSOP_INFO   pInfo;

    PRSOP_INFO   pRIMinimumPasswordAge;
    PRSOP_INFO   pRIMaximumPasswordAge;
    PRSOP_INFO   pRIMinimumPasswordLength;
    PRSOP_INFO   pRIPasswordComplexity;
    PRSOP_INFO   pRIPasswordHistorySize;
    PRSOP_INFO   pRILockoutBadCount;
    PRSOP_INFO   pRIResetLockoutCount;
    PRSOP_INFO   pRILockoutDuration;
    PRSOP_INFO   pRIRequireLogonToChangePassword;
    PRSOP_INFO   pRIForceLogoffWhenHourExpire;
    PRSOP_INFO   pRIEnableAdminAccount;
    PRSOP_INFO   pRIEnableGuestAccount;
    PRSOP_INFO   pRILSAAnonymousNameLookup;
    PRSOP_INFO   pRINewAdministratorName;
    PRSOP_INFO   pRINewGuestName;
    PRSOP_INFO   pRISecureSystemPartition;
    PRSOP_INFO   pRIClearTextPassword;
    //RSOPINFO for pKerberosInfo
    PRSOP_INFO   pRIMaxTicketAge;
    PRSOP_INFO   pRIMaxRenewAge;
    PRSOP_INFO   pRIMaxServiceAge;
    PRSOP_INFO   pRIMaxClockSkew;
    PRSOP_INFO   pRITicketValidateClient;
    //This is a link list. corresponding to  pInfPrivilegeAssignedTo
    //in otherinfo
    list<PRSOP_INFO> listRIInfPrivilegeAssignedTo;
    list<PRSOP_INFO> listRIGroupMemebership;
    list<PRSOP_INFO> listRIServices;
    vector<PRSOP_INFO> vecRIFiles;
    vector<PRSOP_INFO> vecRIReg;
    PRSOP_INFO   pRIAuditSystemEvents;
    PRSOP_INFO   pRIAuditLogonEvents;
    PRSOP_INFO   pRIAuditObjectAccess;
    PRSOP_INFO   pRIAuditPrivilegeUse;
    PRSOP_INFO   pRIAuditPolicyChange;
    PRSOP_INFO   pRIAuditAccountManage;
    PRSOP_INFO   pRIAuditProcessTracking;
    PRSOP_INFO   pRIAuditDSAccess;
    PRSOP_INFO   pRIAuditAccountLogon;
    PRSOP_INFO   pRICrashOnAuditFull;
    vector<PRSOP_INFO> vecRIRegValues;

    // Event Log Numeric
    PRSOP_INFO   pRIMaximumLogSize[3];
    PRSOP_INFO   pRIAuditLogRetentionPeriod[3];
    PRSOP_INFO   pRIRetentionDays[3];

    // Event Log Boolean
    PRSOP_INFO   pRIRestrictGuestAccess[3];
}WMI_SCE_PROFILE_INFO, *PWMI_SCE_PROFILE_INFO;

VOID InitWMI_SEC_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo);

VOID FreeList(list<PRSOP_INFO> * li);

VOID FreeVector(vector<PRSOP_INFO> * li);

VOID FreeWMI_SCE_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo);

class CWMIRsop
{
public:
    CWMIRsop(LPRSOPINFORMATION pRSOP):
                     m_cRegValueSize(MAX_REG_VALUE_NUM),
                     m_cFileSize(MAX_REG_VALUE_NUM),
                     m_cRegArrayCount(MAX_REG_VALUE_NUM),
                     m_pSvc(NULL),
                     m_vecAllRSOPCache(NULL),
                     m_pRSOPInformation(pRSOP)
    {};
    virtual ~CWMIRsop();

    HRESULT GetPrecedenceOneRSOPInfo(PWMI_SCE_PROFILE_INFO* ppProfileInfo);
    HRESULT GetAllRSOPInfo(vector<PWMI_SCE_PROFILE_INFO> *vecInfo);
    HRESULT GetGPOFriendlyName (LPTSTR lpGPOID, PWSTR *pGPOName);
private:
    IWbemServices *m_pSvc;
    LPRSOPINFORMATION m_pRSOPInformation;
    vector<PWMI_SCE_PROFILE_INFO> *m_vecAllRSOPCache;

    ULONG m_cRegValueSize;  //current capacity of array aRegValues
    ULONG m_cFileSize;      //current capacity of array in pFiles
    ULONG m_cRegArrayCount; //current capacity of array in pRegistryKeys

    //Connect to WMI and Get IWbemServices
    HRESULT Initialize();
    HRESULT EnumeratePrecedenceOne(IEnumWbemClassObject **ppEnum);
    HRESULT EnumerateAll(IEnumWbemClassObject **ppEnum);
    HRESULT GetNextInstance(IEnumWbemClassObject *pEnum,
                            IWbemClassObject** rsopInstance);
    HRESULT GetRSOPInfo(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo);

    HRESULT GetClass(IWbemClassObject* rsopInstance,
                     LPWSTR *ppClass);
    HRESULT AddInstance(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo,
                        PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddNumericSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddEventLogNumericSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddBooleanSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddEventLogBooleanSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddAuditSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddUserRightSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddRegValSetting(IWbemClassObject *rsopInstance,
                             PRSOP_INFO pInfo,
                             PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddRestrictedGroupSetting(IWbemClassObject *rsopInstance,
                                      PRSOP_INFO pInfo,
                                      PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddServiceSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddFileSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddRegSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddStringSetting (IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    
};

#endif // WMIHOOKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wrapper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wrapper.h
//
//----------------------------------------------------------------------------
#ifndef _SECMGR_WRAPPER_H
#define _SECMGR_WRAPPER_H

DWORD ApplyTemplate(LPCWSTR szProfile,LPCWSTR szDatabase, LPCWSTR szLogFile, AREA_INFORMATION Area);

DWORD InspectSystem(LPCWSTR szProfile,LPCWSTR szDatabase, LPCWSTR szLogFile, AREA_INFORMATION Area);
SCESTATUS AssignTemplate(LPCWSTR szTemplate, LPCWSTR szDatabase, BOOL bIncremental);

SCESTATUS EngineOpenProfile(LPCWSTR FileName, int format, PVOID* hProfile);
void EngineCloseProfile(PVOID* hProfile);
BOOL EngineGetDescription(PVOID hProfile, LPWSTR* Desc);

#define ENGINE_DEFAULT_PROFILE      0  // Template being used.
#define ENGINE_DEFAULT_DATABASE     1  // Database being used.

BOOL GetProfileDescription(LPCTSTR ProfileName, LPWSTR* Description);
BOOL IsDomainController( LPCTSTR pszServer = NULL);
extern CRITICAL_SECTION csOpenDatabase;


#define OPEN_PROFILE_ANALYSIS  0
#define OPEN_PROFILE_LOCALPOL  1
#define OPEN_PROFILE_CONFIGURE 2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wrapper.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wrapper.cpp
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "util.h"
#include "resource.h"
#include "winreg.h"
#include "areaprog.h"
#include "wrapper.h"

#include "dsgetdc.h"

typedef DWORD  (WINAPI *PFNDSGETDCNAME)(LPCWSTR, LPCWSTR, GUID *, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW *);

typedef struct {
   LPCWSTR szProfile;
   LPCWSTR szDatabase;
   LPCWSTR szLog;
   AREA_INFORMATION Area;
   LPVOID  *pHandle;
   PSCE_AREA_CALLBACK_ROUTINE pCallback;
   HANDLE hWndCallback;
   DWORD   dwFlags;
} ENGINEARGS;

BOOL
PostProgressArea(
   IN HANDLE CallbackHandle,
   IN AREA_INFORMATION Area,
   IN DWORD TotalTicks,
   IN DWORD CurrentTicks
   );

static BOOL bRangeSet=FALSE;

CRITICAL_SECTION csOpenDatabase;
#define OPEN_DATABASE_TIMEOUT INFINITE

//
// Helper functions to call the engine from a secondary thread:
//
DWORD WINAPI
InspectSystemEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc;
   ea = (ENGINEARGS *)lpv;

   DWORD dWarning=0;
   rc = SceAnalyzeSystem(NULL,
                         ea->szProfile,
                         ea->szDatabase,
                         ea->szLog,
                         SCE_UPDATE_DB|SCE_VERBOSE_LOG,
                         ea->Area,
                         ea->pCallback,
                         ea->hWndCallback,
                         &dWarning  // this is required (by RPC)
                         );
   return rc;
}

//
// call to SCE engine to apply the template
//

DWORD WINAPI
ApplyTemplateEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc;
   ea = (ENGINEARGS *)lpv;

   rc = SceConfigureSystem(NULL,
                           ea->szProfile,
                           ea->szDatabase,
                           ea->szLog,
                           SCE_OVERWRITE_DB|SCE_VERBOSE_LOG,
                           ea->Area,
                           ea->pCallback,
                           ea->hWndCallback,
                           NULL
                           );

   return rc;
}


WINBASEAPI
BOOL
WINAPI
TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

/*------------------------------------------------------------------------------
Method:     OpenDatabaseEx

Synopsis:   open database on a separate thread

Arugments:

Returns:

History: a-mthoge 06-09-1998 - Added the _NT4BACK_PORT compile condition.
------------------------------------------------------------------------------*/
DWORD
WINAPI
OpenDatabaseEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc=0;


   if (TryEnterCriticalSection(&csOpenDatabase)) {
      ea = (ENGINEARGS *)lpv;

      rc = SceOpenProfile(ea->szProfile,
                          (SCE_FORMAT_TYPE) ea->dwFlags,  // SCE_JET_FORMAT || SCE_JET_ANALYSIS_REQUIRED
                          ea->pHandle
                          );

      LeaveCriticalSection(&csOpenDatabase);
   } else {
      rc = SCESTATUS_OTHER_ERROR;
   }
   return rc;
}

//
// Assign a template to the system without configuring it
//
SCESTATUS
AssignTemplate(LPCWSTR szTemplate,
               LPCWSTR szDatabase,
               BOOL bIncremental) {
   SCESTATUS rc;

   rc = SceConfigureSystem(NULL,
                           szTemplate,
                           szDatabase,
                           NULL,
                           (bIncremental ? SCE_UPDATE_DB : SCE_OVERWRITE_DB) | SCE_NO_CONFIG | SCE_VERBOSE_LOG,
                           AREA_ALL,
                           NULL,
                           NULL,
                           NULL
                           );

   return rc;
}

//
// apply a template to the system
//
DWORD
ApplyTemplate(
    LPCWSTR szProfile,
    LPCWSTR szDatabase,
    LPCWSTR szLogFile,
    AREA_INFORMATION Area
    )
{
   // Spawn a thread to call the engine & apply the profile, since this can
   // take a while and we want to stay responsive & have a change to provide
   // feedback.

   ENGINEARGS ea;
   HANDLE hThread=NULL;

   ea.szProfile = szProfile;
   ea.szDatabase = szDatabase;
   ea.szLog = szLogFile;
   ea.Area = Area;

   //
   // this is the progress call back dialog which
   // will be passed to SCE client stub for progress
   // callback
   //
   AreaProgress *ap = new AreaProgress;
   if ( ap ) {

       CString strTitle;
       CString strVerb;
       strTitle.LoadString(IDS_CONFIGURE_PROGRESS_TITLE);
       strVerb.LoadString(IDS_CONFIGURE_PROGRESS_VERB);

       ap->Create(IDD_ANALYZE_PROGRESS);
       ap->SetWindowText(strTitle);
       ap->SetDlgItemText(IDC_VERB,strVerb);
       ap->ShowWindow(SW_SHOW);
       bRangeSet = FALSE;
   }

   ea.pCallback = (PSCE_AREA_CALLBACK_ROUTINE)PostProgressArea;
   ea.hWndCallback = (HANDLE)ap;

   hThread = CreateThread(NULL,0,ApplyTemplateEx,&ea,0,NULL);

   DWORD dw=0;
   if ( hThread ) {

       MSG msg;

       DWORD dwTotalTicks=100;
       do {

          dw = MsgWaitForMultipleObjects(1,&hThread,0,INFINITE,QS_ALLINPUT);
          while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
          }
       } while (WAIT_OBJECT_0 != dw);

       GetExitCodeThread(hThread,&dw);

       CloseHandle(hThread);

   } else {

       dw = GetLastError();

       CString str;
       str.LoadString(IDS_CANT_CREATE_THREAD);
       AfxMessageBox(str);
   }

   //
   // free the dialog if it's created
   //
   if ( ap ) {
       if ( ap->GetSafeHwnd() )
           ap->DestroyWindow();
       delete ap;
   }

   return dw;
}

//
// post progress
//
BOOL
PostProgressArea(
   IN HANDLE CallbackHandle,
   IN AREA_INFORMATION Area,
   IN DWORD TotalTicks,
   IN DWORD CurrentTicks
   )
{
   if ( CallbackHandle ) {

       AreaProgress *ap = (AreaProgress *)CallbackHandle;

       ap->ShowWindow(SW_SHOW);

       if ( !bRangeSet ) {
           ap->SetMaxTicks(TotalTicks);
           bRangeSet = TRUE;
       }
       ap->SetCurTicks(CurrentTicks);
       ap->SetArea(Area);

       return TRUE;

   } else {

       return FALSE;
   }
}

//
// inspect a system
//
DWORD
InspectSystem(
    LPCWSTR szProfile,
    LPCWSTR szDatabase,
    LPCWSTR szLogFile,
    AREA_INFORMATION Area
    )
{
   // Spawn a thread to call the engine & inspect the system, since this can
   // take a while and we want to stay responsive & have a change to provide
   // feedback.

    ENGINEARGS ea;
    HANDLE hThread=NULL;

    ea.szProfile = szProfile;
    ea.szDatabase = szDatabase;
    ea.szLog = szLogFile;
    ea.Area = Area;

   AreaProgress *ap = new AreaProgress;
   if ( ap ) {

       ap->Create(IDD_ANALYZE_PROGRESS);
       ap->ShowWindow(SW_SHOW);
       bRangeSet = FALSE;
   }

   ea.pCallback = (PSCE_AREA_CALLBACK_ROUTINE)PostProgressArea;
   ea.hWndCallback = (HANDLE)ap;


  // return InspectSystemEx(&ea);


   hThread = CreateThread(NULL,0,InspectSystemEx,&ea,0,NULL);
   if (!hThread) {
       DWORD rc = GetLastError();

       CString str;
       str.LoadString(IDS_CANT_CREATE_THREAD);
       AfxMessageBox(str);
      // Display an error

      if ( ap ) {
          if ( ap->GetSafeHwnd() )
               ap->DestroyWindow();
          delete ap;
      }
      return rc;
   }

   MSG msg;
   DWORD dw=0;

   DWORD dwTotalTicks=100;
   int n = 0;
   do {
      dw = MsgWaitForMultipleObjects(1,&hThread,0,100,QS_ALLINPUT);
      while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }

   } while (WAIT_OBJECT_0 != dw);

   GetExitCodeThread(hThread,&dw);

   CloseHandle(hThread);

   if ( ap ) {
       if ( ap->GetSafeHwnd() )
            ap->DestroyWindow();
       delete ap;
   }

   return dw;

}

BOOL GetProfileDescription(LPCTSTR ProfileName, LPWSTR* Description)
// Description must be freed by LocalFree
// This should only be called for INF format profiles
{
   PVOID hProfile=NULL;
   SCESTATUS rc;

   if (EngineOpenProfile(ProfileName,OPEN_PROFILE_CONFIGURE,&hProfile) == SCESTATUS_SUCCESS) {
      rc = SceGetScpProfileDescription(
                 hProfile,
                 Description);

      SceCloseProfile(&hProfile);

      if ( rc == SCESTATUS_SUCCESS ) {
         return(TRUE);
      } else {
         return(FALSE);
      }
   } else {
       return FALSE;
   }
}

SCESTATUS
EngineOpenProfile(
        LPCWSTR FileName OPTIONAL,
        int format,
        PVOID* hProfile
        )
{
   SCESTATUS status;
   ENGINEARGS ea;
   DWORD dw;
   HANDLE hThread=NULL;
   CString str;

   if ( !hProfile ) {  // do not check !FileName because it's optional now
     return SCESTATUS_PROFILE_NOT_FOUND;
   }

   if ( (OPEN_PROFILE_LOCALPOL != format) &&
        !FileName ) {
       return SCESTATUS_PROFILE_NOT_FOUND;
   }

   ZeroMemory(&ea, sizeof( ENGINEARGS ) );

   // This is multithreaded for responsiveness, since a
   // crashed jet database can take forever and a day to open.

   // If we can open it quickly (where quickly is defined as within
   // OPEN_DATABASE_TIMEOUT milliseconds then
   if ( (OPEN_PROFILE_ANALYSIS == format) ||
        (OPEN_PROFILE_LOCALPOL == format)) {// JET {
      ea.szProfile = FileName;
      ea.pHandle = hProfile;
      if (OPEN_PROFILE_LOCALPOL == format) {
         ea.dwFlags = SCE_JET_FORMAT;
      } else {
         ea.dwFlags = SCE_JET_ANALYSIS_REQUIRED;
      }

#if SPAWN_OPEN_DATABASE_THREAD
      hThread = CreateThread(NULL,0,OpenDatabaseEx,&ea,0,NULL);

      if ( hThread ) {

          dw = MsgWaitForMultipleObjects(1,&hThread,0,OPEN_DATABASE_TIMEOUT,0);
          if (WAIT_TIMEOUT == dw) {
             status = SCESTATUS_OTHER_ERROR;
          } else {
             GetExitCodeThread(hThread,&status);
          }

          CloseHandle(hThread);

      } else {
          status = GetLastError();
      }
#else
      status = OpenDatabaseEx(&ea);
#endif
      if( status != SCESTATUS_SUCCESS && *hProfile ){
          status = SCESTATUS_INVALID_DATA;
      }

   } else {    // INF
      status = SceOpenProfile( FileName, SCE_INF_FORMAT, hProfile );
   }

   if ( status != SCESTATUS_SUCCESS ){
      *hProfile = NULL;
   }

   return status;
}

void EngineCloseProfile(PVOID* hProfile)
{
    if ( hProfile ) {
        SceCloseProfile(hProfile);
    }
}

BOOL EngineGetDescription(PVOID hProfile, LPWSTR* Desc)
{
    if ( SceGetScpProfileDescription( hProfile, Desc) != SCESTATUS_SUCCESS ) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL IsDomainController( LPCTSTR pszComputer )
{
    //
    // for remote computers, connect to the remote registry
    // currently this api only works for local computer
    //
    SCE_SERVER_TYPE ServerType = SCESVR_UNKNOWN;
        SCESTATUS rc = SceGetServerProductType((LPTSTR)pszComputer, &ServerType);
    return ( (SCESTATUS_SUCCESS == rc) && (SCESVR_DC_WITH_DS == ServerType) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wmihooks.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wmihooks.cpp
//
//  Contents:   implementation of CWMIRsop
//
//----------------------------------------------------------------------------
#include <stdafx.h>
#include <wmihooks.h>
#include "util.h"

WCHAR const QUERY_LANG[]            = L"WQL";
WCHAR const WMI_CLASS[]             = L"__CLASS";
WCHAR const RSOP_NAME_SPACE[]       = L"root\\rsop\\computer";
WCHAR const RSOP_PREC_ONE_QUERY[]   = L"select * from RSOP_SecuritySettings where precedence=1";
WCHAR const RSOP_ALL_QUERY[]        = L"select * from RSOP_SecuritySettings";
WCHAR const RSOP_STATUS[]           = L"Status";
WCHAR const RSOP_ERROR[]            = L"ErrorCode";
WCHAR const RSOP_PRECEDENCE[]       = L"precedence";
WCHAR const RSOP_GPOID[]            = L"GPOID";
WCHAR const RSOP_KEYNAME[]          = L"KeyName";
WCHAR const RSOP_SETTING[]          = L"Setting";
WCHAR const RSOP_USERRIGHT[]        = L"UserRight";
WCHAR const RSOP_ACCOUNTLIST[]      = L"AccountList";
WCHAR const RSOP_EVENTLOG_TYPE[]    = L"Type";

//String Constants for RSOP_classNames
WCHAR const RSOP_SEC_NUM[]          = TEXT("RSOP_SecuritySettingNumeric");
WCHAR const RSOP_SEC_BOOL[]         = TEXT("RSOP_SecuritySettingBoolean");
WCHAR const RSOP_SCE_STRING[]       = TEXT("RSOP_SecuritySettingString");
WCHAR const RSOP_AUDIT[]            = TEXT("RSOP_AuditPolicy");
WCHAR const RSOP_EVENT_NUM[]        = TEXT("RSOP_SecurityEventLogSettingNumeric");
WCHAR const RSOP_EVENT_BOOL[]       = TEXT("RSOP_SecurityEventLogSettingBoolean");
WCHAR const RSOP_REG_VAL[]          = TEXT("RSOP_RegistryValue");
WCHAR const RSOP_USER_RIGHT[]       = TEXT("RSOP_UserPrivilegeRight");
WCHAR const RSOP_RGROUPS[]          = TEXT("RSOP_RestrictedGroup");
WCHAR const RSOP_SERVICE[]          = TEXT("RSOP_SystemService");
WCHAR const RSOP_FILE[]             = TEXT("RSOP_File");
WCHAR const RSOP_REG[]              = TEXT("RSOP_RegistryKey");

//KeyNames
WCHAR const MIN_PASS_AGE[]          = TEXT("MinimumPasswordAge");
WCHAR const MAX_PASS_AGE[]          = TEXT("MaximumPasswordAge");
WCHAR const MIN_PASS_LEN[]          = TEXT("MinimumPasswordLength");
WCHAR const PASS_HIS_SIZE[]         = TEXT("PasswordHistorySize");
WCHAR const REQUIRE_LOGON_TO_CHANGE_PASS[] = TEXT("RequireLogonToChangePassword");
WCHAR const LOCKOUT_COUNT[]         = TEXT("LockoutBadCount");
WCHAR const RESET_LOCKOUT_COUNT[]   = TEXT("ResetLockoutCount");
WCHAR const LOCKOUT_DURATION[]      = TEXT("LockoutDuration");
WCHAR const MAX_TICKET_AGE[]        = TEXT("MaxTicketAge");
WCHAR const MAX_RENEW_AGE[]         = TEXT("MaxRenewAge");
WCHAR const MAX_SERVICE_AGE[]       = TEXT("MaxServiceAge");
WCHAR const MAX_CLOCK_SKEW[]        = TEXT("MaxClockSkew");
WCHAR const VALIDATE_CLIENT[]       = TEXT("TicketValidateClient");
WCHAR const PASS_COMPLEX[]          = TEXT("PasswordComplexity");
WCHAR const FORCE_LOGOFF[]          = TEXT("ForceLogOffWhenHourExpire");
WCHAR const ENABLE_ADMIN[]         = TEXT("EnableAdminAccount");
WCHAR const ENABLE_GUEST[]         = TEXT("EnableGuestAccount");
WCHAR const LSA_ANON_LOOKUP[]       = TEXT("LSAAnonymousNameLookup");
WCHAR const CLEAR_TEXT_PASS[]       = TEXT("ClearTextPassword");
WCHAR const AUDIT_SYSTEM_EVENTS[]   = TEXT("AuditSystemEvents");
WCHAR const AUDIT_LOGON_EVENTS[]    = TEXT("AuditLogonEvents");
WCHAR const AUDIT_OBJECT_ACCESS[]   = TEXT("AuditObjectAccess");
WCHAR const AUDIT_PRIVILEGE_USE[]   = TEXT("AuditPrivilegeUse");
WCHAR const AUDIT_POLICY_CHANGE[]   = TEXT("AuditPolicyChange");
WCHAR const AUDIT_ACCOUNT_MANAGE[]  = TEXT("AuditAccountManage");
WCHAR const AUDIT_PROCESS_TRAKING[] = TEXT("AuditProcessTracking");
WCHAR const AUDIT_DS_ACCESS[]       = TEXT("AuditDSAccess");
WCHAR const AUDIT_ACCOUNT_LOGON[]   = TEXT("AuditAccountLogon");

WCHAR const MAX_LOG_SIZE[]          = TEXT("MaximumLogSize");
WCHAR const AUDIT_LOG_RETENTION_PERIOD[] = TEXT ("AuditLogRetentionPeriod");
WCHAR const RETENTION_DAYS[]        = TEXT ("RetentionDays");
WCHAR const RESTRICT_GUEST_ACCESS[] = TEXT ("RestrictGuestAccess");
WCHAR const NEW_GUEST_NAME[]        = TEXT ("NewGuestName");
WCHAR const NEW_ADMINISTRATOR_NAME[] = TEXT ("NewAdministratorName");

VOID FreeRI(PRSOP_INFO ptr)
{
    if(ptr)
    {
        if(ptr->pszGPOID)
            LocalFree(ptr->pszGPOID);
        LocalFree(ptr);
    }
}


VOID InitWMI_SEC_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    memset(pProfileInfo,0,sizeof(SCE_PROFILE_INFO));
    pProfileInfo->MinimumPasswordAge = SCE_NO_VALUE;
    pProfileInfo->MaximumPasswordAge = SCE_NO_VALUE;
    pProfileInfo->MinimumPasswordLength = SCE_NO_VALUE;
    pProfileInfo->PasswordComplexity = SCE_NO_VALUE;
    pProfileInfo->PasswordHistorySize = SCE_NO_VALUE;
    pProfileInfo->LockoutBadCount = SCE_NO_VALUE;
    pProfileInfo->ResetLockoutCount = SCE_NO_VALUE;
    pProfileInfo->LockoutDuration = SCE_NO_VALUE;
    pProfileInfo->RequireLogonToChangePassword = SCE_NO_VALUE;
    pProfileInfo->ForceLogoffWhenHourExpire = SCE_NO_VALUE;
    pProfileInfo->NewAdministratorName = 0;
    pProfileInfo->NewGuestName = 0;
    pProfileInfo->EnableAdminAccount = SCE_NO_VALUE;
    pProfileInfo->EnableGuestAccount = SCE_NO_VALUE;
    pProfileInfo->LSAAnonymousNameLookup = SCE_NO_VALUE;
    pProfileInfo->ClearTextPassword = SCE_NO_VALUE;
    pProfileInfo->AuditDSAccess = SCE_NO_VALUE;
    pProfileInfo->AuditAccountLogon = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[0] = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[1] = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[2] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[0] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[1] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[2] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[0] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[1] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[2] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[0] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[1] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[2] = SCE_NO_VALUE;
    pProfileInfo->AuditSystemEvents = SCE_NO_VALUE;
    pProfileInfo->AuditLogonEvents = SCE_NO_VALUE;
    pProfileInfo->AuditObjectAccess = SCE_NO_VALUE;
    pProfileInfo->AuditPrivilegeUse = SCE_NO_VALUE;
    pProfileInfo->AuditPolicyChange = SCE_NO_VALUE;
    pProfileInfo->AuditAccountManage = SCE_NO_VALUE;
    pProfileInfo->AuditProcessTracking = SCE_NO_VALUE;

    pProfileInfo->pInfo=NULL;
    pProfileInfo->pRIMinimumPasswordAge=NULL;
    pProfileInfo->pRIMaximumPasswordAge=NULL;
    pProfileInfo->pRIMinimumPasswordLength=NULL;
    pProfileInfo->pRIPasswordComplexity=NULL;
    pProfileInfo->pRIPasswordHistorySize=NULL;
    pProfileInfo->pRILockoutBadCount=NULL;
    pProfileInfo->pRIResetLockoutCount=NULL;
    pProfileInfo->pRILockoutDuration=NULL;
    pProfileInfo->pRIRequireLogonToChangePassword=NULL;
    pProfileInfo->pRIForceLogoffWhenHourExpire=NULL;
    pProfileInfo->pRIEnableAdminAccount=NULL;
    pProfileInfo->pRIEnableGuestAccount=NULL;
    pProfileInfo->pRILSAAnonymousNameLookup=NULL;
    pProfileInfo->pRINewAdministratorName=NULL;
    pProfileInfo->pRINewGuestName=NULL;
    pProfileInfo->pRIClearTextPassword=NULL;
    pProfileInfo->pRIMaxTicketAge=NULL;
    pProfileInfo->pRIMaxRenewAge=NULL;
    pProfileInfo->pRIMaxServiceAge=NULL;
    pProfileInfo->pRIMaxClockSkew=NULL;
    pProfileInfo->pRITicketValidateClient=NULL;
    pProfileInfo->pRIAuditSystemEvents=NULL;
    pProfileInfo->pRIAuditLogonEvents=NULL;
    pProfileInfo->pRIAuditObjectAccess=NULL;
    pProfileInfo->pRIAuditPrivilegeUse=NULL;
    pProfileInfo->pRIAuditPolicyChange=NULL;
    pProfileInfo->pRIAuditAccountManage=NULL;
    pProfileInfo->pRIAuditProcessTracking=NULL;
    pProfileInfo->pRIAuditDSAccess=NULL;
    pProfileInfo->pRIAuditAccountLogon=NULL;
    pProfileInfo->pRIMaximumLogSize[0]=NULL;
    pProfileInfo->pRIMaximumLogSize[1]=NULL;
    pProfileInfo->pRIMaximumLogSize[2]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[0]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[1]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[2]=NULL;
    pProfileInfo->pRIRetentionDays[0]=NULL;
    pProfileInfo->pRIRetentionDays[1]=NULL;
    pProfileInfo->pRIRetentionDays[2]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[0]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[1]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[2]=NULL;
}

VOID FreeList(list<PRSOP_INFO> * li)
{
    for(list<PRSOP_INFO>::iterator i = li->begin();
                                               i != li->end();
                                               ++i )
    {
        FreeRI(*i);
    }
    li->erase(li->begin(),li->end());
}

VOID FreeVector(vector<PRSOP_INFO> * li)
{
    for(vector<PRSOP_INFO>::iterator i = li->begin();
                                               i != li->end();
                                               ++i )
    {
        FreeRI(*i);
    }
    li->erase(li->begin(),li->end());
}

VOID FreeWMI_SCE_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo)
{
   if (!pProfileInfo) {
      return;
   }
    //TODO
    //Use the code to Free SCE_PROFILE_INFO
    FreeRI(pProfileInfo->pInfo);
    FreeRI(pProfileInfo->pRIMinimumPasswordAge);
    FreeRI(pProfileInfo->pRIMaximumPasswordAge);
    FreeRI(pProfileInfo->pRIMinimumPasswordLength);
    FreeRI(pProfileInfo->pRIPasswordComplexity);
    FreeRI(pProfileInfo->pRIPasswordHistorySize);
    FreeRI(pProfileInfo->pRILockoutBadCount);
    FreeRI(pProfileInfo->pRIResetLockoutCount);
    FreeRI(pProfileInfo->pRILockoutDuration);
    FreeRI(pProfileInfo->pRIRequireLogonToChangePassword);
    FreeRI(pProfileInfo->pRIForceLogoffWhenHourExpire);
    FreeRI(pProfileInfo->pRIEnableAdminAccount);
    FreeRI(pProfileInfo->pRIEnableGuestAccount);
    FreeRI(pProfileInfo->pRILSAAnonymousNameLookup);
    FreeRI(pProfileInfo->pRINewAdministratorName);
    FreeRI(pProfileInfo->pRINewGuestName);
    FreeRI(pProfileInfo->pRIClearTextPassword);
    FreeRI(pProfileInfo->pRIMaxTicketAge);
    FreeRI(pProfileInfo->pRIMaxRenewAge);
    FreeRI(pProfileInfo->pRIMaxServiceAge);
    FreeRI(pProfileInfo->pRIMaxClockSkew);
    FreeRI(pProfileInfo->pRITicketValidateClient);
    FreeRI(pProfileInfo->pRIAuditSystemEvents);
    FreeRI(pProfileInfo->pRIAuditLogonEvents);
    FreeRI(pProfileInfo->pRIAuditObjectAccess);
    FreeRI(pProfileInfo->pRIAuditPrivilegeUse);
    FreeRI(pProfileInfo->pRIAuditPolicyChange);
    FreeRI(pProfileInfo->pRIAuditAccountManage);
    FreeRI(pProfileInfo->pRIAuditProcessTracking);
    FreeRI(pProfileInfo->pRIAuditDSAccess);
    FreeRI(pProfileInfo->pRIAuditAccountLogon);
    FreeRI(pProfileInfo->pRIMaximumLogSize[0]);
    FreeRI(pProfileInfo->pRIMaximumLogSize[1]);
    FreeRI(pProfileInfo->pRIMaximumLogSize[2]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[0]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[1]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[2]);
    FreeRI(pProfileInfo->pRIRetentionDays[0]);
    FreeRI(pProfileInfo->pRIRetentionDays[1]);
    FreeRI(pProfileInfo->pRIRetentionDays[2]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[0]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[1]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[2]);

    FreeList(&(pProfileInfo->listRIInfPrivilegeAssignedTo));
    FreeList(&(pProfileInfo->listRIGroupMemebership));
    FreeList(&(pProfileInfo->listRIServices));
    FreeVector(&(pProfileInfo->vecRIFiles));
    FreeVector(&(pProfileInfo->vecRIReg));

    SceFreeProfileMemory(pProfileInfo);
}

CWMIRsop::~CWMIRsop() {
   if (m_vecAllRSOPCache) {
      for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = m_vecAllRSOPCache->begin();
                                                  i != m_vecAllRSOPCache->end();
                                                  ++i )
      {
         PWMI_SCE_PROFILE_INFO pProfileInfo = *i;
         FreeWMI_SCE_PROFILE_INFO(pProfileInfo);
      }
   }

   delete m_vecAllRSOPCache;
   m_vecAllRSOPCache = NULL;    // be extra carefull because the old code is not to delete it at all.

   if (m_pSvc) {
      m_pSvc->Release();
   }
}

HRESULT CWMIRsop::Initialize()
{
    HRESULT hr = S_OK;
    IWbemLocator *pLoc = NULL;

    //Already initialized
    if(m_pSvc)
        return hr;

    if (!m_pRSOPInformation) 
    {
       return E_FAIL;
    }

    //This is a safe usage.
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLoc);
    if (FAILED(hr))
    {
        return hr;
    }


    const int cchMaxLength = 512;
    WCHAR szNameSpace[cchMaxLength];//LPOLESTR pszNameSpace = (LPOLESTR) LocalAlloc (LPTR, cchMaxLength * sizeof (WCHAR));

    hr = m_pRSOPInformation->GetNamespace (
               GPO_SECTION_MACHINE,
               szNameSpace,
               cchMaxLength);
    szNameSpace[cchMaxLength - 1] = L'\0';

       if (SUCCEEDED(hr)) 
       {
          BSTR bstrNameSpace = SysAllocString (szNameSpace);
          if (bstrNameSpace) 
          {
             hr = pLoc->ConnectServer(bstrNameSpace,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL,
                                      0,
                                      0,
                                      &m_pSvc
                                      );

             SysFreeString(bstrNameSpace);
          }
          else
              hr = E_OUTOFMEMORY;
       }

    if (SUCCEEDED(hr))
    {
        // Set the proxy so that impersonation of the client occurs.
        hr = CoSetProxyBlanket(m_pSvc,
                          RPC_C_AUTHN_WINNT,
                          RPC_C_AUTHZ_NONE,
                          NULL,
                          RPC_C_AUTHN_LEVEL_CALL,
                          RPC_C_IMP_LEVEL_IMPERSONATE,
                          NULL,
                          EOAC_NONE);
    }

    pLoc->Release();
    return hr;   // Program successfully completed.
}

HRESULT CWMIRsop::EnumeratePrecedenceOne(IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = m_pSvc->ExecQuery(_bstr_t(QUERY_LANG),
                           _bstr_t(RSOP_PREC_ONE_QUERY),
                           WBEM_FLAG_FORWARD_ONLY,
                           NULL,
                           ppEnum);

    return hr;
}

HRESULT CWMIRsop::EnumerateAll(IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = m_pSvc->ExecQuery(_bstr_t(QUERY_LANG),
                           _bstr_t(RSOP_ALL_QUERY),
                           WBEM_FLAG_FORWARD_ONLY,
                           NULL,
                           ppEnum);

    return hr;
}

HRESULT CWMIRsop::GetNextInstance(IEnumWbemClassObject *pEnum,
                          IWbemClassObject** rsopInstance)
{
    HRESULT hr = (HRESULT)WBEM_S_FALSE; //Prefast warning: Implicit cast between semantically different integer types. Comments: It is expected.
    ULONG returnedNum = 0;
    if(pEnum)
    {
        hr = pEnum->Next(WBEM_INFINITE,
                         1,
                         rsopInstance,
                         &returnedNum);
        if( FAILED(hr) )
            return hr;

        if (returnedNum == 0)
            hr = (HRESULT)WBEM_S_FALSE; //Prefast warning: Implicit cast between semantically different integer types. Comments: It is expected.
    }
    return hr;
}

HRESULT CWMIRsop::GetClass(IWbemClassObject* rsopInstance,
                   LPWSTR *ppClass)
{
    PTSTR pszClassName;
    VARIANT value;

    HRESULT hr = rsopInstance->Get(_bstr_t(WMI_CLASS),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr) || value.vt != VT_BSTR || value.bstrVal == NULL)
        return hr;

    pszClassName = (PTSTR) V_BSTR(&value);
    ULONG uLen = wcslen(pszClassName);
    *ppClass = (LPWSTR)LocalAlloc(LPTR, (uLen + 1) * sizeof(WCHAR));
    if( *ppClass == NULL )
    {
       VariantClear(&value);
       return E_OUTOFMEMORY;
    }
    //This may not be a safe usage. pszClassName is PTSTR. Consider fix.
    wcscpy(*ppClass,pszClassName);
    VariantClear(&value);
    return hr;
}

HRESULT CWMIRsop::GetRSOPInfo(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo)
{

    HRESULT hr = S_OK;
    PTSTR pszGPOID = 0;
    UINT status = 0;
    UINT precedence = 0;
    VARIANT value;

    //Get Status
    hr = rsopInstance->Get(_bstr_t(RSOP_STATUS),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr))
        return hr;

    pInfo->status = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get Error
    hr = rsopInstance->Get(_bstr_t(RSOP_ERROR),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr))
        return hr;

    pInfo->error = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get Precedence
    hr = rsopInstance->Get(_bstr_t(RSOP_PRECEDENCE),
                    0,
                    &value,
                    NULL,
                    NULL);

    if(FAILED(hr))
        return hr;

    pInfo->precedence = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get GPOID
    hr =    rsopInstance->Get(_bstr_t(RSOP_GPOID),
                              0,
                              &value,
                              NULL,
                              NULL);

    if(FAILED(hr) || value.vt != VT_BSTR || (value.vt == VT_BSTR && value.bstrVal == NULL) )
        return hr;

    pszGPOID = (PTSTR) V_BSTR(&value);
    ULONG uLen = wcslen(pszGPOID);
    pInfo->pszGPOID = (LPWSTR)LocalAlloc(LPTR, (uLen + 1) * sizeof(WCHAR));
    if( pInfo->pszGPOID == NULL )
    {
       VariantClear(&value);
       return E_OUTOFMEMORY;
    }
    //This may not be a safe usage. pszGPOID is PTSTR. Consider fix.
    wcscpy(pInfo->pszGPOID, pszGPOID);
    VariantClear(&value);

    return hr;
}

HRESULT CWMIRsop::GetPrecedenceOneRSOPInfo(PWMI_SCE_PROFILE_INFO *ppProfileInfo)
{
    HRESULT hr = S_OK;
    IWbemClassObject *rsopInstance = NULL;
    IEnumWbemClassObject *pEnumObject = NULL;
    PWMI_SCE_PROFILE_INFO pTempProfileInfo = NULL;
    PRSOP_INFO pInfo = NULL;

    hr = Initialize();
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = EnumeratePrecedenceOne(&pEnumObject);
    if( FAILED(hr) )
        goto exit_gracefully;

    pTempProfileInfo = new WMI_SCE_PROFILE_INFO;
    if( !pTempProfileInfo )
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    InitWMI_SEC_PROFILE_INFO(pTempProfileInfo);

    //Get each instance
    //Prefast warning: Implicit cast between semantically different integer types. Comments: It is expected.
    while( ((hr = GetNextInstance(pEnumObject, &rsopInstance)) != (HRESULT)WBEM_S_FALSE) && !FAILED(hr) )
    {
        pInfo = (PRSOP_INFO)LocalAlloc(LPTR, sizeof(RSOP_INFO));
        if(pInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        //Get RSOP_INFO
        hr = GetRSOPInfo(rsopInstance, pInfo);
        if( FAILED(hr) )
            goto exit_gracefully;

        hr = AddInstance(rsopInstance,
                         pInfo,
                         pTempProfileInfo);
        if( FAILED(hr) )
            goto exit_gracefully;
        rsopInstance->Release();
        rsopInstance = NULL;
        pInfo = NULL;
    }


exit_gracefully:
    if(FAILED(hr))
    {
        if (rsopInstance)
            rsopInstance->Release();    // if while loop somehow terminate to here, rsopInstance is never released there
        if(pEnumObject)
            pEnumObject->Release();

        FreeRI(pInfo);
        //Free pTempProfileInfo
        FreeWMI_SCE_PROFILE_INFO(pTempProfileInfo);
        pTempProfileInfo = NULL;
    }
    *ppProfileInfo = pTempProfileInfo;
    return hr;
}

PWMI_SCE_PROFILE_INFO SearchProfileInList(vector<PWMI_SCE_PROFILE_INFO> *vecInfo,
                                          PRSOP_INFO pInfo)
{

    for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
    {
        PWMI_SCE_PROFILE_INFO pProfileInfo = *i;
        if(_wcsicmp(pProfileInfo->pInfo->pszGPOID,pInfo->pszGPOID) == 0 )
            return pProfileInfo;
    }
    return NULL;
}

//Function Object Used for sorting vector
struct less_mag : public binary_function<PWMI_SCE_PROFILE_INFO, PWMI_SCE_PROFILE_INFO, bool> {
    bool operator()(PWMI_SCE_PROFILE_INFO x, PWMI_SCE_PROFILE_INFO y)
    { return x->pInfo->precedence < y->pInfo->precedence; }
};

HRESULT CWMIRsop::GetAllRSOPInfo(vector<PWMI_SCE_PROFILE_INFO> *vecInfo)
{
    HRESULT hr = S_OK;
    IWbemClassObject *rsopInstance = NULL;
    IEnumWbemClassObject *pEnumObject = NULL;
    PRSOP_INFO pInfo = NULL;
    PWMI_SCE_PROFILE_INFO pProfileInfo = NULL;

    if (NULL == vecInfo) {
       return E_INVALIDARG;
    }

    //
    // If we've alrady cached the info from WMI then just return it
    // don't try and get it again
    //
    if (m_vecAllRSOPCache) 
    {
       for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = m_vecAllRSOPCache->begin();
                                               i != m_vecAllRSOPCache->end();
                                               ++i )
       {
          vecInfo->push_back(*i);
       }
       return S_OK;
    }

    hr = Initialize();
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = EnumerateAll(&pEnumObject);
    if( FAILED(hr) )
        goto exit_gracefully;

    //Get each instance
    //Prefast warning: Implicit cast between semantically different integer types. Comments: It is expected.
    while( ((hr = GetNextInstance(pEnumObject, &rsopInstance)) != (HRESULT)WBEM_S_FALSE) && !FAILED(hr) )
    {
        pInfo = (PRSOP_INFO)LocalAlloc(LPTR, sizeof(RSOP_INFO));
        if(pInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        //Get RSOP_INFO
        hr = GetRSOPInfo(rsopInstance, pInfo);
        if( FAILED(hr) )
            goto exit_gracefully;

        pProfileInfo = SearchProfileInList(vecInfo,pInfo);
        if(!pProfileInfo)
        {
            pProfileInfo = new WMI_SCE_PROFILE_INFO;
            if(!pProfileInfo)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            InitWMI_SEC_PROFILE_INFO(pProfileInfo);
            pProfileInfo->pInfo = (PRSOP_INFO)LocalAlloc(LPTR,sizeof(RSOP_INFO));
            if(!pProfileInfo->pInfo)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            pProfileInfo->pInfo->pszGPOID = (LPWSTR)LocalAlloc(LPTR, (wcslen(pInfo->pszGPOID)+1)*sizeof(WCHAR));
            if(!pProfileInfo->pInfo->pszGPOID)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            //This is a safe usage.
            wcscpy(pProfileInfo->pInfo->pszGPOID,pInfo->pszGPOID);
            vecInfo->push_back(pProfileInfo);
        }

        if( pProfileInfo->pInfo->precedence < pInfo->precedence )
            pProfileInfo->pInfo->precedence = pInfo->precedence;

        hr = AddInstance(rsopInstance,
                         pInfo,
                         pProfileInfo);
        if(FAILED(hr))
            goto exit_gracefully;
        rsopInstance->Release();
        rsopInstance = NULL;
        pInfo = NULL;
    }

    sort(vecInfo->begin(),vecInfo->end(),less_mag());

    m_vecAllRSOPCache = new vector<PWMI_SCE_PROFILE_INFO>;
    if (m_vecAllRSOPCache) 
    {
       for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
       {
          m_vecAllRSOPCache->push_back(*i);
       }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        FreeRI(pInfo);
        //Free the vector
        for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
        {
            PWMI_SCE_PROFILE_INFO pProfileInfoLoc = *i; //Raid #prefast
            FreeWMI_SCE_PROFILE_INFO(pProfileInfoLoc);
        }
    }
    if(pEnumObject)
        pEnumObject->Release();
    if(rsopInstance)
        rsopInstance->Release();

    return hr;
}

HRESULT CWMIRsop::AddNumericSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT bSettingValue;
    DWORD settingValue;

   _TRACE (1, L"Entering CWMIRsop::AddNumericSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    settingValue = V_UINT(&bSettingValue);

    if(!_wcsicmp(keyName, MIN_PASS_AGE))
    {
        pProfileInfo->MinimumPasswordAge = settingValue;
        pProfileInfo->pRIMinimumPasswordAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_PASS_AGE))
    {
        pProfileInfo->MaximumPasswordAge = settingValue;
        pProfileInfo->pRIMaximumPasswordAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MIN_PASS_LEN))
    {
        pProfileInfo->MinimumPasswordLength = settingValue;
        pProfileInfo->pRIMinimumPasswordLength = pInfo;
    }
    else if(!_wcsicmp(keyName, PASS_HIS_SIZE))
    {
        pProfileInfo->PasswordHistorySize = settingValue;
        pProfileInfo->pRIPasswordHistorySize = pInfo;
    }
    else if(!_wcsicmp(keyName, LOCKOUT_COUNT))
    {
        pProfileInfo->LockoutBadCount = settingValue;
        pProfileInfo->pRILockoutBadCount = pInfo;
    }
    else if(!_wcsicmp(keyName, RESET_LOCKOUT_COUNT))
    {
        pProfileInfo->ResetLockoutCount = settingValue;
        pProfileInfo->pRIResetLockoutCount = pInfo;
    }
    else if(!_wcsicmp(keyName, LOCKOUT_DURATION))
    {
        pProfileInfo->LockoutDuration = settingValue;
        pProfileInfo->pRILockoutDuration = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_TICKET_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxTicketAge = settingValue;
        pProfileInfo->pRIMaxTicketAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_RENEW_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxRenewAge = settingValue;
        pProfileInfo->pRIMaxRenewAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_SERVICE_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxServiceAge = settingValue;
        pProfileInfo->pRIMaxServiceAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_CLOCK_SKEW))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxClockSkew = settingValue;
        pProfileInfo->pRIMaxClockSkew = pInfo;
    }
    else
    {
        _ASSERT (FALSE); // key name not accounted for
    }


exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);

   _TRACE (-1,L"Leaving CWMIRsop::AddNumericSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddEventLogNumericSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bKeyName;
    VARIANT bSettingValue;
    VARIANT bType;

   _TRACE (1, L"Entering CWMIRsop::AddEventLogNumericSetting\n");
    HRESULT hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_EVENTLOG_TYPE,
                          0,
                          &bType,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


   PTSTR keyName = V_BSTR(&bKeyName);
   DWORD settingValue = V_UINT(&bSettingValue);
   PTSTR typeValue = V_BSTR(&bType);

   unsigned long ulType = wcstoul (typeValue, L'\0', 10);
	ASSERT (ulType <= 2);
	if ( ulType <= 2 )
	{
      if ( !_wcsicmp(keyName, MAX_LOG_SIZE) )
      {
			pProfileInfo->MaximumLogSize[ulType] = settingValue;
			pProfileInfo->pRIMaximumLogSize[ulType] = pInfo;
		}
      else if ( !_wcsicmp(keyName, AUDIT_LOG_RETENTION_PERIOD) )
      {
			pProfileInfo->AuditLogRetentionPeriod[ulType] = settingValue;
			pProfileInfo->pRIAuditLogRetentionPeriod[ulType] = pInfo;
		}
      else if ( !_wcsicmp(keyName, RETENTION_DAYS) )
      {
         //Raid 599943, yanggao.
         //if RetentionDays is 0xffffffff then the retention method is "don't overwrite ..." and RetentionDays setting is not defined.
         //if RetentionDays is 0 then retention method is "overwrite as needed ..." and RetentionDays setting is not defined.
         //if RetentionDays has another value then retention method is "by days" and the number of days is the value for RetentionDays setting.
         //pProfileInfo->RetentionDays[ulType] = settingValue;
         //pProfileInfo->pRIRetentionDays[ulType] = pInfo;
         //Set related method setting.
         PRSOP_INFO pMethodInfo = NULL;
         pMethodInfo = (PRSOP_INFO)LocalAlloc(LPTR, sizeof(RSOP_INFO));
         if(pMethodInfo == NULL)
         {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
         }
         hr = GetRSOPInfo(rsopInstance, pMethodInfo);
         if( FAILED(hr) )
         {
            FreeRI(pMethodInfo);
            goto exit_gracefully;
         }
         switch(settingValue)
         {
         case 0:
	         pProfileInfo->AuditLogRetentionPeriod[ulType] = SCE_RETAIN_AS_NEEDED;
            FreeRI(pInfo);
            break;
         case SCE_FOREVER_VALUE:
            pProfileInfo->AuditLogRetentionPeriod[ulType] = SCE_RETAIN_MANUALLY;
            FreeRI(pInfo);
            break;
         default:
            pProfileInfo->AuditLogRetentionPeriod[ulType] = SCE_RETAIN_BY_DAYS;
            pProfileInfo->RetentionDays[ulType] = settingValue;
            pProfileInfo->pRIRetentionDays[ulType] = pInfo;
            break;
         }
         pProfileInfo->pRIAuditLogRetentionPeriod[ulType] = pMethodInfo;
         pMethodInfo = NULL;
      }
      else
      {
         _ASSERT (FALSE); // key name not accounted for
      }
   }
   else
      hr = E_FAIL;

exit_gracefully:
    VariantClear (&bKeyName);
    VariantClear (&bSettingValue);
    VariantClear (&bType);
   _TRACE (-1,L"Leaving CWMIRsop::AddEventLogNumericSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddEventLogBooleanSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PTSTR keyName = 0;
    VARIANT bSettingValue;
   DWORD settingValue;
    BOOL boolVal = FALSE;
    VARIANT bType;
    PTSTR   typeValue = 0;

   _TRACE (1, L"Entering CWMIRsop::AddEventLogBooleanSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_EVENTLOG_TYPE,
                          0,
                          &bType,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    boolVal = V_BOOL(&bSettingValue);
    settingValue = (boolVal)? 1:0;
    typeValue = V_BSTR(&bType);


   unsigned long ulType = wcstoul (typeValue, L'\0', 10);
	ASSERT (ulType <= 2);
	if ( ulType <= 2 )
	{
      if ( !_wcsicmp(keyName, RESTRICT_GUEST_ACCESS) )
      {
			pProfileInfo->RestrictGuestAccess[ulType] = settingValue;
			pProfileInfo->pRIRestrictGuestAccess[ulType] = pInfo;
		}
      else
      {
         _ASSERT (FALSE); // key name not accounted for
      }
   }
	else
	   hr = E_FAIL;

exit_gracefully:
    VariantClear (&bKeyName);
    VariantClear (&bSettingValue);
    VariantClear (&bType);
   _TRACE (-1,L"Leaving CWMIRsop::AddEventLogBooleanSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddBooleanSetting(IWbemClassObject *rsopInstance,
                          PRSOP_INFO pInfo,
                          PWMI_SCE_PROFILE_INFO pProfileInfo)
{

    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT bSettingValue;
    BOOL boolVal;
    DWORD settingValue;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddBooleanSetting\n");

    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                           0,
                           &bKeyName,
                           NULL,
                           NULL);
    if(FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                           0,
                           &bSettingValue,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;

    keyName = (PTSTR) V_BSTR(&bKeyName);

    boolVal = V_BOOL(&bSettingValue);

    settingValue = (boolVal)? 1:0;

    if(!_wcsicmp(keyName, PASS_COMPLEX))
    {
        pProfileInfo->PasswordComplexity = settingValue;
        pProfileInfo->pRIPasswordComplexity = pInfo;
    }
    else if(!_wcsicmp(keyName, FORCE_LOGOFF))
    {
        pProfileInfo->ForceLogoffWhenHourExpire = settingValue;
        pProfileInfo->pRIForceLogoffWhenHourExpire = pInfo;
    }
    else if(!_wcsicmp(keyName, ENABLE_ADMIN))
    {
        pProfileInfo->EnableAdminAccount = settingValue;
        pProfileInfo->pRIEnableAdminAccount = pInfo;
    }
    else if(!_wcsicmp(keyName, ENABLE_GUEST))
    {
        pProfileInfo->EnableGuestAccount = settingValue;
        pProfileInfo->pRIEnableGuestAccount = pInfo;
    }
    else if(!_wcsicmp(keyName, LSA_ANON_LOOKUP))
    {
        pProfileInfo->LSAAnonymousNameLookup = settingValue;
        pProfileInfo->pRILSAAnonymousNameLookup = pInfo;
    }
    else if(!_wcsicmp(keyName, CLEAR_TEXT_PASS))
    {
        pProfileInfo->ClearTextPassword = settingValue;
        pProfileInfo->pRIClearTextPassword = pInfo;
    }
    else if (!_wcsicmp(keyName, REQUIRE_LOGON_TO_CHANGE_PASS))
    {
        pProfileInfo->RequireLogonToChangePassword = settingValue;
        pProfileInfo->pRIRequireLogonToChangePassword = pInfo;
    }
    else if(!_wcsicmp(keyName, VALIDATE_CLIENT))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->TicketValidateClient = settingValue;
        pProfileInfo->pRITicketValidateClient = pInfo;
    }
    else
    {
       _ASSERT (FALSE); // key name not accounted for
    }
exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);
   _TRACE (-1,L"Leaving CWMIRsop::AddBooleanSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddAuditSetting(IWbemClassObject *rsopInstance,
                          PRSOP_INFO pInfo,
                          PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bCategoryName;
    PTSTR categoryName;
    VARIANT vSuccessVal;
    VARIANT vFailVal;
    BOOL successVal;
    BOOL failVal;
    DWORD settingVal = 0;
    HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddAuditSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("Category")),
                0,
                &bCategoryName,
                NULL,
                NULL
                );

    if(FAILED(hr) || bCategoryName.vt != VT_BSTR || bCategoryName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Success")),
                0,
                &vSuccessVal,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Failure")),
            0,
            &vFailVal,
            NULL,
            NULL
            );
    if(FAILED(hr))
        goto exit_gracefully;



    categoryName = (PTSTR) V_BSTR(&bCategoryName);

    successVal = V_BOOL(&vSuccessVal);

    failVal = V_BOOL(&vFailVal);

    if (successVal) 
        settingVal |= 1;
    if (failVal) 
        settingVal |= 2;

    if(!_wcsicmp(categoryName, AUDIT_SYSTEM_EVENTS))
    {
        pProfileInfo->AuditSystemEvents = settingVal;
        pProfileInfo->pRIAuditSystemEvents = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_LOGON_EVENTS))
    {
        pProfileInfo->AuditLogonEvents = settingVal;
        pProfileInfo->pRIAuditLogonEvents = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_OBJECT_ACCESS))
    {
        pProfileInfo->AuditObjectAccess = settingVal;
        pProfileInfo->pRIAuditObjectAccess = pInfo;
    }
    else if (!_wcsicmp(categoryName, AUDIT_PRIVILEGE_USE))
    {
        pProfileInfo->AuditPrivilegeUse = settingVal;
        pProfileInfo->pRIAuditPrivilegeUse = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_POLICY_CHANGE))
    {
        pProfileInfo->AuditPolicyChange = settingVal;
        pProfileInfo->pRIAuditPolicyChange = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_ACCOUNT_MANAGE))
    {
        pProfileInfo->AuditAccountManage = settingVal;
        pProfileInfo->pRIAuditAccountManage = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_PROCESS_TRAKING))
    {
        pProfileInfo->AuditProcessTracking = settingVal;
        pProfileInfo->pRIAuditProcessTracking = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_DS_ACCESS))
    {
        pProfileInfo->AuditDSAccess = settingVal;
        pProfileInfo->pRIAuditDSAccess = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_ACCOUNT_LOGON))
    {
        pProfileInfo->AuditAccountLogon = settingVal;
        pProfileInfo->pRIAuditAccountLogon = pInfo;
    }
    else
    {
      _ASSERT (FALSE); // key name not accounted for
    }

exit_gracefully:

    VariantClear(&bCategoryName);
    VariantClear(&vSuccessVal);
    VariantClear(&vFailVal);
   _TRACE (-1,L"Leaving CWMIRsop::AddAuditSetting\n");

    return hr;
}


HRESULT CWMIRsop::AddUserRightSetting(
                    IWbemClassObject *rsopInstance,
                    PRSOP_INFO pInfo,
                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bUserRight;
    PTSTR userRight = NULL;
    VARIANT vAccountList;
   HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddUserRightSetting\n");

    hr = rsopInstance->Get(_bstr_t(RSOP_USERRIGHT),
                      0,
                      &bUserRight,
                      NULL,
                      NULL);
    if( FAILED(hr) || bUserRight.vt != VT_BSTR || bUserRight.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(RSOP_ACCOUNTLIST),
                      0,
                      &vAccountList,
                      NULL,
                      NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    DWORD len;
    len  = wcslen((PTSTR) V_BSTR(&bUserRight));
     userRight = (PTSTR) LocalAlloc(LPTR, (len+1) * sizeof(WCHAR) );
    if(!userRight)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This may not be a safe usage. userRight is PTSTR. Consider fix.
    wcscpy(userRight, (PTSTR) V_BSTR(&bUserRight));



    PSCE_PRIVILEGE_ASSIGNMENT head;
    head = pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo;

    if (!head)
    {
        head = (pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo =
            (PSCE_PRIVILEGE_ASSIGNMENT) LocalAlloc(LPTR, sizeof(SCE_PRIVILEGE_ASSIGNMENT)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_PRIVILEGE_ASSIGNMENT current;
        current = (PSCE_PRIVILEGE_ASSIGNMENT) LocalAlloc(LPTR, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        current->Next = head;
        head = current;
        pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo = head;
    }

    head->Name = userRight;
    userRight = NULL;

    if(V_VT(&vAccountList) != VT_NULL)
    {
        SAFEARRAY* ptempArray;
        ptempArray = NULL;
        BSTR tempString;
        long lowerBoundray=0, upperBoundray=0, loopCount=0;
        ptempArray = V_ARRAY(&vAccountList);

        if ( FAILED(SafeArrayGetLBound(ptempArray, 1, &lowerBoundray)) ) lowerBoundray = 0;
        if ( FAILED(SafeArrayGetUBound(ptempArray, 1, &upperBoundray)) ) upperBoundray = 0;

        PSCE_NAME_LIST nameHead = head->AssignedTo;
        for (loopCount = lowerBoundray; loopCount <= upperBoundray; loopCount++)
        {
            hr = SafeArrayGetElement(ptempArray,
                                    &loopCount,
                                    &tempString);

            if ( FAILED(hr) ) goto exit_gracefully;

            if(!nameHead)
            {
                nameHead =
                    (head->AssignedTo = (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST)));
                if(!nameHead)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
            }
            else
            {
                PSCE_NAME_LIST currentName =
                    (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST));
                if(!currentName)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }

                currentName->Next = nameHead;
                nameHead = currentName;
                head->AssignedTo = nameHead;
            }

            DWORD nameLen = wcslen((PTSTR) tempString);
            nameHead->Name = (PTSTR) LocalAlloc(LPTR, (nameLen+1) *sizeof(WCHAR) );
            if(!nameHead->Name)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            //This may not be a safe usage. nameHead->Name is PWSTR. Consider fix.
            wcscpy(nameHead->Name, (PTSTR) tempString);
        }
    }

        //Set other info
    pProfileInfo->listRIInfPrivilegeAssignedTo.push_front(pInfo);


exit_gracefully:
    if(FAILED(hr) && (userRight != NULL))
    {
        LocalFree(userRight);
    }
    VariantClear(&bUserRight);
    VariantClear(&vAccountList);
   _TRACE (-1,L"Leaving CWMIRsop::AddUserRightSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddRegValSetting(IWbemClassObject *rsopInstance,
                           PRSOP_INFO pInfo,
                           PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT vSettingValue;
    VARIANT vType;
    PTSTR settingValue;
    DWORD type;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddRegValSetting\n");

    hr  = rsopInstance->Get(_bstr_t(TEXT("Path")),
                            0,
                            &bKeyName,
                            NULL,
                            NULL);
    if(FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Data")),
                            0,
                            &vSettingValue,
                            NULL,
                            NULL);
    if(FAILED(hr) || vSettingValue.vt != VT_BSTR || vSettingValue.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Type")),
                            0,
                            &vType,
                            NULL,
                            NULL);
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bKeyName));
    keyName = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!keyName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This is not a safe usage.
    wcscpy(keyName,(PTSTR) V_BSTR(&bKeyName));

    len = wcslen((PTSTR) V_BSTR(&vSettingValue));
    settingValue = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!settingValue)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This is a safe usage.
    wcscpy(settingValue,(PTSTR) V_BSTR(&vSettingValue));

    type = (DWORD) V_I4(&vType);


    DWORD arrayIndex;
    if ((arrayIndex = pProfileInfo->RegValueCount) == 0)
    {
        pProfileInfo->aRegValues =
            (PSCE_REGISTRY_VALUE_INFO) LocalAlloc(LPTR, sizeof(SCE_REGISTRY_VALUE_INFO)* m_cRegValueSize);
        if(!pProfileInfo->aRegValues)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }

    //double the array preserving the content
    if( arrayIndex >= m_cRegValueSize )
    {
        PSCE_REGISTRY_VALUE_INFO temp = (PSCE_REGISTRY_VALUE_INFO) LocalAlloc(LPTR, sizeof(SCE_REGISTRY_VALUE_INFO)* m_cRegValueSize * 2);
        if(!temp || pProfileInfo->aRegValues == NULL) //Raid #553113, yanggao.
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        //This is not a safe usage. arrayIndex should not be greater than m_cRegValueSize*2 and pProfileInfo->aRegValues need to be validated. Raid #571332. yanggao.
        memcpy(temp,pProfileInfo->aRegValues,sizeof(SCE_REGISTRY_VALUE_INFO)*arrayIndex);
        LocalFree(pProfileInfo->aRegValues);
        pProfileInfo->aRegValues = temp;
        m_cRegValueSize *= 2;
    }

    pProfileInfo->aRegValues[arrayIndex].FullValueName = keyName;
    pProfileInfo->aRegValues[arrayIndex].Value = settingValue;
    pProfileInfo->aRegValues[arrayIndex].ValueType = type;
    pProfileInfo->RegValueCount += 1;

        //Store RSOP_INFO
    pProfileInfo->vecRIRegValues.push_back(pInfo);


exit_gracefully:

    VariantClear(&bKeyName);
    VariantClear(&vSettingValue);
    VariantClear(&vType);

   _TRACE (-1,L"Leaving CWMIRsop::AddRegValSetting\n");
    return hr;

}

HRESULT CWMIRsop::AddRestrictedGroupSetting(IWbemClassObject *rsopInstance,
                                    PRSOP_INFO pInfo,
                                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bRGroup;
    PTSTR RGroup;
    VARIANT vMembers;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddRestrictedGroupSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("GroupName")),
                0,
                &bRGroup,
                NULL,
                NULL
                );
    if(FAILED(hr) || bRGroup.vt != VT_BSTR || bRGroup.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Members")),
                0,
                &vMembers,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bRGroup));
    RGroup = (PTSTR) LocalAlloc(LPTR, (len+1) * sizeof(WCHAR));
    if(!RGroup)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This is a safe usage.
    wcscpy(RGroup, (PTSTR) V_BSTR(&bRGroup));

    PSCE_GROUP_MEMBERSHIP head;
    head = pProfileInfo->pGroupMembership;

    if (!head)
    {
        head = (pProfileInfo->pGroupMembership =
            (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR, sizeof(SCE_GROUP_MEMBERSHIP)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_GROUP_MEMBERSHIP current =
            (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR, sizeof(SCE_GROUP_MEMBERSHIP));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        current->Next = head;
        head = current;
        pProfileInfo->pGroupMembership = head;
    }

    head->GroupName = RGroup;

    if(V_VT(&vMembers) != VT_NULL)
    {
        SAFEARRAY* ptempArray = NULL;
        BSTR tempString;
        long lowerBoundray=0, upperBoundray=0, loopCount=0;
        ptempArray = V_ARRAY(&vMembers);

        if ( FAILED(SafeArrayGetLBound(ptempArray, 1, &lowerBoundray)) ) lowerBoundray = 0;
        if ( FAILED(SafeArrayGetUBound(ptempArray, 1, &upperBoundray)) ) upperBoundray = 0;

        PSCE_NAME_LIST nameHead = head->pMembers;
        for (loopCount = lowerBoundray; loopCount <= upperBoundray; loopCount++){

            hr = SafeArrayGetElement(ptempArray,
                                &loopCount,
                                &tempString);

            if ( FAILED(hr) ) goto exit_gracefully;

            if(!nameHead)
            {
                nameHead =
                    (head->pMembers = (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST)));
                if(!nameHead)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
            }
            else
            {
                PSCE_NAME_LIST currentName =
                    (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST));
                if(!currentName)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
                currentName->Next = nameHead;
                nameHead = currentName;
                head->pMembers = nameHead;
            }

            DWORD nameLen = wcslen((PTSTR) tempString);
            nameHead->Name = (PTSTR) LocalAlloc(LPTR, (nameLen+1) *sizeof(WCHAR) );
            if ( !(nameHead->Name) ) {

                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            //This may not be a safe usage. nameHead->Name is PWSTR. Consider fix.
            wcscpy(nameHead->Name, (PTSTR) tempString);
        }
    }

        //Add RSOP info
    pProfileInfo->listRIGroupMemebership.push_front(pInfo);


exit_gracefully:
    VariantClear(&bRGroup);
    VariantClear(&vMembers);
   _TRACE (-1,L"Leaving CWMIRsop::AddRestrictedGroupSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddServiceSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bServiceName;
    PTSTR serviceName;
    VARIANT vSDDL;
    VARIANT vStartup;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD startup;
    HRESULT hr = S_OK;


   _TRACE (1, L"Entering CWMIRsop::AddServiceSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("Service")),
                           0,
                           &bServiceName,
                           NULL,
                           NULL);
    if(FAILED(hr) || bServiceName.vt != VT_BSTR || bServiceName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("SDDLString")),
                           0,
                           &vSDDL,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("StartupMode")),
                           0,
                           &vStartup,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bServiceName));
    serviceName = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!serviceName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This is a safe usage.
    wcscpy(serviceName,(PTSTR) V_BSTR(&bServiceName));

    ULONG sdLen;
    sdLen = 0;
    // This is a safe usage. vSDDL comes from WMI.
    if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
        (PTSTR) V_BSTR(&vSDDL),
        SDDL_REVISION_1,
        &SDDL,
        &sdLen
        ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit_gracefully;
    }


    startup = (DWORD) V_I4(&vStartup);


    PSCE_SERVICES head;
    head = pProfileInfo->pServices;

    if (!head)
    {
        head = (pProfileInfo->pServices =
            (PSCE_SERVICES) LocalAlloc(LPTR, sizeof(SCE_SERVICES)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_SERVICES current =
            (PSCE_SERVICES) LocalAlloc(LPTR, sizeof(SCE_SERVICES));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        current->Next = head;
        head = current;
        pProfileInfo->pServices = head;
    }

    head->ServiceName = serviceName;
    head->General.pSecurityDescriptor = SDDL;
    head->Startup = (BYTE) startup; //no data loss value is <= 4

    //Add RSOP info
    pProfileInfo->listRIServices.push_front(pInfo);

exit_gracefully:
    VariantClear(&bServiceName);
    VariantClear(&vSDDL);
    VariantClear(&vStartup);
   _TRACE (-1,L"Leaving CWMIRsop::AddServiceSetting\n");

    return hr;
}

HRESULT CWMIRsop::AddFileSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bFileName;
    PTSTR fileName = NULL;
    VARIANT vSDDL;
    VARIANT vMode;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD mode = 0;

   _TRACE (1, L"Entering CWMIRsop::AddFileSetting\n");

    HRESULT hr = S_OK;


    hr = rsopInstance->Get((BSTR)(TEXT("Path")),
                0,
                &bFileName,
                NULL,
                NULL
                );
    if(FAILED(hr) || bFileName.vt != VT_BSTR || bFileName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("Mode")),
                0,
                &vMode,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("SDDLString")),
                0,
                &vSDDL,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bFileName));
    fileName = (PTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR) + 2);
    if(!fileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This may not be a safe usage. fileName is PTSTR. Consider fix.
    wcscpy(fileName, (PTSTR) V_BSTR(&bFileName));


    mode = (DWORD) V_I4(&vMode);


    if (mode != 1)
    {

        ULONG sdLen = 0;
        //This is a safe usage. vSDDL comes from WMI.
        if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            (PTSTR) V_BSTR(&vSDDL),
            SDDL_REVISION_1,
            &SDDL,
            &sdLen
            ))
        {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit_gracefully;
        }
    }


    PSCE_OBJECT_ARRAY head;
    head = pProfileInfo->pFiles.pAllNodes;

    if(!head)
    {
        head =  (pProfileInfo->pFiles.pAllNodes =
            (PSCE_OBJECT_ARRAY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cFileSize);
        if(!head->pObjectArray)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else if(head->Count >= m_cFileSize)
    {
        PSCE_OBJECT_SECURITY* temp = (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cFileSize*2);
        if(!temp || head->pObjectArray == NULL) //Raid #553113, yanggao.
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        //This is not a safe usage. head->Count should not be greater than m_cFileSize*2 and head->pObjectArray need to be validated. Raid #571332. yanggao.
        memcpy(temp,head->pObjectArray,head->Count *sizeof(PSCE_OBJECT_SECURITY));
        LocalFree(head->pObjectArray);
        head->pObjectArray = temp;
        m_cFileSize *=2;
    }

    DWORD index;
    index = head->Count;

    head->pObjectArray[index] =
        (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_SECURITY));
    if(!head->pObjectArray[index])
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    head->pObjectArray[index]->Name = fileName;
    head->pObjectArray[index]->pSecurityDescriptor = SDDL;
    head->pObjectArray[index]->Status = (BYTE) mode;
    head->Count++;

    //SET RSOP INFO
    pProfileInfo->vecRIFiles.push_back(pInfo);

exit_gracefully:
    VariantClear(&bFileName);
    VariantClear(&vMode);
    if(mode != 1){
        VariantClear(&vSDDL);
    }
   _TRACE (-1,L"Leaving CWMIRsop::AddFileSetting\n");

    return hr;
}


HRESULT CWMIRsop::AddRegSetting(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo,
                        PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    PTSTR gpoID = NULL;
    VARIANT bFileName;
    PTSTR fileName = NULL;
    VARIANT vSDDL;
    VARIANT vMode;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD mode = 0;
    static DWORD multiplier = 1;

    HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddRegSetting\n");

    hr = rsopInstance->Get((BSTR)(TEXT("Path")),
                0,
                &bFileName,
                NULL,
                NULL
                );
    if(FAILED(hr) || bFileName.vt != VT_BSTR || bFileName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("Mode")),
                0,
                &vMode,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("SDDLString")),
                0,
                &vSDDL,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;



    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bFileName));
    fileName = (PTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR) + 2);
    if(!fileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    //This may not be a safe usage. fileName is PTSTR. Consider fix.
    wcscpy(fileName, (PTSTR) V_BSTR(&bFileName));

    mode = (DWORD) V_I4(&vMode);


    if (mode != 1)
    {

        ULONG sdLen = 0;
        // This is a safe usage. vSDDL comes from WMI.
        if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            (PTSTR) V_BSTR(&vSDDL),
            SDDL_REVISION_1,
            &SDDL,
            &sdLen
            ))
        {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit_gracefully;
        }
    }


    PSCE_OBJECT_ARRAY head;
    head = pProfileInfo->pRegistryKeys.pAllNodes;

    if(!head){
        head = (pProfileInfo->pRegistryKeys.pAllNodes =
            (PSCE_OBJECT_ARRAY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cRegArrayCount);
        if(!head->pObjectArray)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else if(head->Count >= m_cRegArrayCount){
        PSCE_OBJECT_SECURITY* temp = head->pObjectArray;
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cRegArrayCount*2);
        if(!head->pObjectArray || !temp) //Raid #553113, yanggao.
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        //This is not a safe usage. temp need to be validated and head->Count should not be greater than m_cRegArrayCount*2. Raid #571332. yanggao.
        memcpy(head->pObjectArray,temp,head->Count *sizeof(PSCE_OBJECT_SECURITY));
        LocalFree(temp);
        m_cRegArrayCount *= 2;
    }

   //
   // Can't initialize at declaration since this is skipped by gotos
   //
    DWORD index;
   index = head->Count;

    head->pObjectArray[index] =
        (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_SECURITY));
   if (head->pObjectArray[index]) {
    head->pObjectArray[index]->Name = fileName;
    head->pObjectArray[index]->pSecurityDescriptor = SDDL;
    head->pObjectArray[index]->Status = (BYTE) mode;
    head->Count++;
   }
    //add rsop info
    pProfileInfo->vecRIReg.push_back(pInfo);


exit_gracefully:
    VariantClear(&bFileName);
    VariantClear(&vMode);
    if(mode != 1){
        VariantClear(&vSDDL);
    }

   _TRACE (-1, L"Leaving CWMIRsop::AddRegSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddStringSetting (IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PWSTR   keyName = 0;
    VARIANT bSettingValue;
    PWSTR   settingValue = 0;

   _TRACE (1, L"Entering CWMIRsop::AddStringSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) || bSettingValue.vt != VT_BSTR || bSettingValue.bstrVal == NULL)
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    settingValue = V_BSTR(&bSettingValue);

    if (!_wcsicmp(keyName, NEW_GUEST_NAME))
    {
        if ( 0 != pProfileInfo->NewGuestName )
        {
            LocalFree (pProfileInfo->NewGuestName);
            pProfileInfo->NewGuestName = 0;
        }

        size_t len = wcslen (settingValue);
        pProfileInfo->NewGuestName = (PWSTR) LocalAlloc (LPTR, (len + 1) * sizeof (TCHAR));
        if ( pProfileInfo->NewGuestName )
        {
            //This may not be a safe usage. Using WCHAR in LocalAlloc() instead of TCHAR. Consider fix.
            wcscpy (pProfileInfo->NewGuestName, settingValue);
        }
        else
            hr = E_OUTOFMEMORY;

        pProfileInfo->pRINewGuestName = pInfo;
    }
    else if (!_wcsicmp(keyName, NEW_ADMINISTRATOR_NAME))
    {
        if ( 0 != pProfileInfo->NewAdministratorName )
        {
            LocalFree (pProfileInfo->NewAdministratorName);
            pProfileInfo->NewAdministratorName = 0;
        }

        size_t len = wcslen (settingValue);
        pProfileInfo->NewAdministratorName = (PWSTR) LocalAlloc (LPTR, (len + 1) * sizeof (TCHAR));
        if ( pProfileInfo->NewAdministratorName )
        {
            //This may not be a safe usage. Using WCHAR in LocalAlloc() instead of TCHAR. Consider fix.
            wcscpy (pProfileInfo->NewAdministratorName, settingValue);
        }
        else
            hr = E_OUTOFMEMORY;

        pProfileInfo->pRINewAdministratorName = pInfo;
    }
    else
    {
       _ASSERT (FALSE); // key name not accounted for
    }


exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);

   _TRACE (-1,L"Leaving CWMIRsop::AddStringSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddInstance(IWbemClassObject *rsopInstance,
                    PRSOP_INFO pInfo,
                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    LPWSTR className = NULL;

    _TRACE (1, L"Entering CWMIRsop::AddInstance\n");

    //Get RSOP_Class Name
    hr = GetClass(rsopInstance, &className);
    if( FAILED(hr) )
        goto exit_gracefully;


    if(!_wcsicmp(className, RSOP_SEC_NUM))
    {
        hr = AddNumericSetting(rsopInstance,
                               pInfo,
                               pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SEC_BOOL))
    {
        hr = AddBooleanSetting(rsopInstance,
                               pInfo,
                               pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SCE_STRING))
    {
       hr = AddStringSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_AUDIT))
    {
        hr = AddAuditSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_EVENT_NUM))
    {
        hr = AddEventLogNumericSetting (rsopInstance, pInfo, pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_EVENT_BOOL))
    {
        hr = AddEventLogBooleanSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_REG_VAL))
    {
        hr = AddRegValSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_USER_RIGHT))
    {
        hr = AddUserRightSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_RGROUPS))
    {
        hr = AddRestrictedGroupSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SERVICE))
    {
        hr = AddServiceSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_FILE))
    {
        hr = AddFileSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_REG))
    {
        hr = AddRegSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else
    {
        _ASSERT (FALSE); // class not accounted for
    }
exit_gracefully:
    _TRACE (-1,L"Exiting CWMIRsop::AddInstance\n");
    LocalFree(className);
return hr;
}

HRESULT
CWMIRsop::GetGPOFriendlyName (PWSTR lpGPOID, PWSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;

    //
    // Set the default
    //

    *pGPOName = NULL;

    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for unicode query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }
    //This is a safe usage.
    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
       _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = m_pSvc->ExecQuery (_bstr_t(QUERY_LANG), pQuery,
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL, &pEnum);


    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to query for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    VariantInit(&varGPOName);
    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for GPO Name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }
    //This may not be a safe usage. pGPOName is PWSTR, using WCHAR in LocalAlloc() instead of TCHAR. Consider fix.
    lstrcpy (*pGPOName, varGPOName.bstrVal);

    hr = S_OK;

Exit:
    VariantClear (&varGPOName);

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wsecmgr.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f Snapinps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cookie.h"
#include <scesvc.h>
#include "Snapmgr.h"
#include "wrapper.h"
#include "sceattch.h"
#include "about.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Snapin, CComponentDataExtensionImpl)
    OBJECT_ENTRY(CLSID_SCESnapin, CComponentDataSCEImpl)
    OBJECT_ENTRY(CLSID_SAVSnapin, CComponentDataSAVImpl)
    OBJECT_ENTRY(CLSID_LSSnapin, CComponentDataLSImpl)
    OBJECT_ENTRY(CLSID_RSOPSnapin, CComponentDataRSOPImpl)
    OBJECT_ENTRY(CLSID_SCEAbout, CSCEAbout)
    OBJECT_ENTRY(CLSID_SCMAbout, CSCMAbout)
    OBJECT_ENTRY(CLSID_SSAbout, CSSAbout)
    OBJECT_ENTRY(CLSID_LSAbout, CLSAbout)
    OBJECT_ENTRY(CLSID_RSOPAbout, CRSOPAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pSnapinAboutGUID,
                       const int nNameResource,
//                       LPCTSTR lpszNameStringNoValueName,
                        LPCTSTR lpszVersion,
                       BOOL bExtension);
HRESULT RegisterSnapin(LPCTSTR lpszSnapinClassID,
                        LPCTSTR lpszStaticNodeGuid,
                       LPCTSTR lpszSnapingAboutGuid,
                       const int nNameResource,
                       LPCTSTR lpszVersion,
                       BOOL bExtension);

HRESULT UnregisterSnapin(const GUID* pSnapinCLSID);
HRESULT UnregisterSnapin(LPCTSTR lpszSnapinClassID);

HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription);

HRESULT UnregisterNodeType(const GUID* pGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid);

HRESULT RegisterDefaultTemplate(LPCTSTR lpszTemplateDir);
HRESULT RegisterEnvVarsToExpand();

class CSnapinApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
private:
    BOOL m_bCriticalSet;
};

CSnapinApp theApp;
const int iStrGuidLen = 128;

BOOL CSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    if (!CComponentDataImpl::LoadResources())
        return FALSE;

    //This is not a safe usage. consider using InitializeCriticalSectionAndSpinCount. Raid #555887, yanggao.
    m_bCriticalSet = FALSE;
    try
    {
       InitializeCriticalSection(&csOpenDatabase);
       m_bCriticalSet = TRUE;
    }
    catch(...)
    {
       return FALSE;
    }

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
    SHFusionUninitialize();

    if( m_bCriticalSet ) //Raid #555887, yanggao, 4/5/2002.
       DeleteCriticalSection(&csOpenDatabase); //Raid #379167, 4/27/2001

    _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{

   // registers object, but not typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CString str;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //
    // unregister some nodes then re-register
    // because some are changed here
    //

    hr = UnregisterSnapin(&CLSID_Snapin);

// not an extension of computer management
    hr = UnregisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin);

    //
    // register the snapin into the console snapin list as SCE
    hr = RegisterSnapin(&CLSID_SCESnapin, &cSCENodeType, &CLSID_SCEAbout,
                        IDS_TEMPLATE_EDITOR_NAME, _T("1.0"), FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    //
    // register the snapin into the console snapin list as SAV
    hr = RegisterSnapin(&CLSID_SAVSnapin, &cSAVNodeType, &CLSID_SCMAbout,
                        IDS_ANALYSIS_VIEWER_NAME, _T("1.0"), FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    hr = RegisterSnapin(&CLSID_Snapin, &cNodeType, &CLSID_SSAbout,
                        IDS_EXTENSION_NAME, _T("1.0"), TRUE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    hr = RegisterSnapin(&CLSID_RSOPSnapin, &cRSOPNodeType, &CLSID_RSOPAbout,
                        IDS_EXTENSION_NAME, _T("1.0"), TRUE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

#ifdef USE_SEPARATE_LOCALSEC
    hr = RegisterSnapin(&CLSID_LSSnapin, &cLSNodeType, &CLSID_LSAbout,
                        IDS_LOCAL_SECURITY_NAME, _T("1.0"), FALSE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
#endif
    // no need to register as extension of computer management snapin
//    str.LoadString(IDS_ANALYSIS_VIEWER_NAME);
//    hr = RegisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin, (LPCTSTR)str);

    //
    // register GPE extension
    // register the snapin as an extension of GPT's Machine node
    //
    OLECHAR szGuid[iStrGuidLen];

    if (0 != ::StringFromGUID2(NODEID_Machine,szGuid,iStrGuidLen))
	{
		str.LoadString(IDS_EXTENSION_NAME);
		hr = RegisterNodeType(szGuid, &CLSID_Snapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    // register the snapin as an extension of GPT's User node
    if (0 != ::StringFromGUID2(NODEID_User,szGuid,iStrGuidLen))
	{
		hr = RegisterNodeType(szGuid, &CLSID_Snapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    if (0 != ::StringFromGUID2(NODEID_RSOPMachine,szGuid,iStrGuidLen))
	{
		str.LoadString(IDS_EXTENSION_NAME);
		hr = RegisterNodeType(szGuid, &CLSID_RSOPSnapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    // register the snapin as an extension of GPT's User node
    if (0 != ::StringFromGUID2(NODEID_RSOPUser,szGuid,iStrGuidLen))
	{
		hr = RegisterNodeType(szGuid, &CLSID_RSOPSnapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

   //
   // register the default template path
   //
   CString str2;
   LPTSTR sz;
   sz = str.GetBuffer(MAX_PATH+1); //Raid #533113, yanggao
   if ( 0 == GetWindowsDirectory(sz,MAX_PATH) ) sz[0] = L'\0';
   str.ReleaseBuffer();
   str2.LoadString(IDS_DEFAULT_TEMPLATE_DIR);
   str += str2;

   sz=str.GetBuffer(str.GetLength());
   // Can't put '\' in the registry, so convert to '/'
   while(sz = wcschr(sz,L'\\')) {
      *sz = L'/';
   }
   str.ReleaseBuffer();

   str2.LoadString(IDS_TEMPLATE_LOCATION_KEY);
   str2 += L"\\";
   str2 += str;
   hr = RegisterDefaultTemplate(str2);

   if (FAILED(hr)) {
      return hr;
   }

   hr = RegisterEnvVarsToExpand();
   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    OLECHAR szGuid[iStrGuidLen];

    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    // unregister the snapin extension nodes

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_SCESnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_SAVSnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_Snapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_LSSnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_RSOPSnapin);

    // unregister the SCE snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceTemplateServices);

    // unregister the SAV snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceAnalysisServices);

    // unregister the snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceTemplate);

// not an extension of computer management
//    hr = UnregisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin);

    ::StringFromGUID2(NODEID_Machine,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_Snapin);
    ::StringFromGUID2(NODEID_User,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_Snapin);

    ::StringFromGUID2(NODEID_RSOPMachine,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_RSOPSnapin);
    ::StringFromGUID2(NODEID_RSOPUser,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_RSOPSnapin);
/*
/*
    // unregister the SCE snapin nodes
    hr = UnregisterNodeType(&cSCENodeType);
    ASSERT(SUCCEEDED(hr));

    // unregister the SAV snapin nodes
    hr = UnregisterNodeType(&cSAVNodeType);
    ASSERT(SUCCEEDED(hr));

    // unregister the snapin nodes
    hr = UnregisterNodeType(&cNodeType);
    ASSERT(SUCCEEDED(hr));
*/

    return S_OK;
}

HRESULT RegisterSnapin(const GUID* pSnapinCLSID, const GUID* pStaticNodeGUID,
                       const GUID* pSnapinAboutGUID,
                       const int nNameResource,
                      // LPCTSTR lpszNameString,
                       LPCTSTR lpszVersion, BOOL bExtension)
{
    USES_CONVERSION;
    OLECHAR szSnapinClassID[iStrGuidLen], szStaticNodeGuid[iStrGuidLen], szSnapinAboutGuid[iStrGuidLen];

    if (0 != ::StringFromGUID2(*pSnapinCLSID, szSnapinClassID, iStrGuidLen)			&&
		0 != ::StringFromGUID2(*pStaticNodeGUID, szStaticNodeGuid, iStrGuidLen)		&&
		0 != ::StringFromGUID2(*pSnapinAboutGUID, szSnapinAboutGuid, iStrGuidLen)		)
	{

		return RegisterSnapin(szSnapinClassID,
							  szStaticNodeGuid,
							  szSnapinAboutGuid,
							  nNameResource,
							  // lpszNameString,
							  lpszVersion,
							  bExtension);
	}
	else
		return E_OUTOFMEMORY;
}

////////////////////////////////////////////////////////////////////////
//
// Registry SCE related reg keys under MMC snapins key
//
//
////////////////////////////////////////////////////////////////////////
HRESULT
RegisterSnapin(LPCTSTR lpszSnapinClassID,
               LPCTSTR lpszStaticNodeGuid,
               LPCTSTR lpszSnapinAboutGuid,
               const int nNameResource,
               LPCTSTR lpszVersion,
               BOOL    bExtension)
{
    //
    // open the MMC Snapins root key
    //

    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE,
                                   SNAPINS_KEY);

    if (lRes != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRes); // failed to open
    }

    //
    // create SCE subkey, if already exist, just open it
    //

    CRegKey regkeyThisSnapin;
    lRes = regkeyThisSnapin.Create(regkeySnapins,
                                   lpszSnapinClassID);

    if (lRes == ERROR_SUCCESS) {

        //
        // set values for SCE root key
        //

       //
       // 97068 MUI:MMC:Security:Security Configuration and Analysis Snap-in store its information in the registry
       // 99392 MUI:MMC:Security:Security Templates Snap-in store its information in the registry
       // 97167 MUI:GPE:GPE Extension: Group policy Secuirty snap-in ext name string is stored in the registry
       //
       // MMC now supports NameStringIndirect
       //
       TCHAR achModuleFileName[MAX_PATH+20];
       if (0 < ::GetModuleFileName(
                 AfxGetInstanceHandle(),
                 achModuleFileName,
                 sizeof(achModuleFileName)/sizeof(TCHAR) ))
       {
          CString strNameIndirect;
          strNameIndirect.Format( _T("@%s,-%d"),
                            achModuleFileName,
                            nNameResource);
          lRes = regkeyThisSnapin.SetValue(strNameIndirect,
                                   TEXT("NameStringIndirect"));
       }

        lRes = regkeyThisSnapin.SetValue(lpszStaticNodeGuid,
                                  TEXT("NodeType"));

        lRes = regkeyThisSnapin.SetValue(lpszSnapinAboutGuid,
                                  TEXT("About"));

        lRes = regkeyThisSnapin.SetValue(_T("Microsoft"),
                                  _T("Provider"));

        lRes = regkeyThisSnapin.SetValue(lpszVersion,
                                  _T("Version"));


        //
        // create "NodeTypes" subkey
        //

        CRegKey regkeyNodeTypes;
        lRes = regkeyNodeTypes.Create(regkeyThisSnapin,
                                      TEXT("NodeTypes"));

        if (lRes == ERROR_SUCCESS) {

            //
            // create subkeys for all node types supported by SCE
            //
            // including: services under configuration,
            //            services under analysis
            //            GPT extensions
            //

            lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceTemplateServices,
                                               TEXT("SCE Service Template Extensions"));
            if (lRes == ERROR_SUCCESS) {

                lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceAnalysisServices,
                                                   TEXT("SCE Service Inspection Extensions"));

            }

            if ( bExtension &&
                 lRes == ERROR_SUCCESS ) {

                //
                // NOTE: standalone snapin do not support public key extensions
                //
                // node type for one template in SCE standalone mode,
                // or the root node of SCE under GPE
                //
                CString str;
                str.LoadString(IDS_EXTENSION_NAME);
                lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceTemplate,
                                                   (LPCTSTR)str);
                if (lRes == ERROR_SUCCESS) {

                    lRes = RegisterNodeType(lstruuidNodetypeSceTemplate,
                                            (LPCTSTR)str);
                }
            } else if (lRes == ERROR_SUCCESS) {
                //
                // create "Standalone" subkey
                //

                CRegKey regkeyStandalone;
                lRes = regkeyStandalone.Create(regkeyThisSnapin,
                                               TEXT("Standalone"));
                if ( lRes == ERROR_SUCCESS ) {
                    regkeyStandalone.Close();
                }
            }

            //
            // register supported node types to MMC NodeTypes key
            // including all the above node types
            //

            if ( lRes == ERROR_SUCCESS ) {
                lRes = RegisterNodeType(lstruuidNodetypeSceTemplateServices,
                                    TEXT("SCE Service Template Extensions"));
                if (lRes == ERROR_SUCCESS) {

                    lRes = RegisterNodeType(lstruuidNodetypeSceAnalysisServices,
                                            TEXT("SCE Service Analysis Extensions"));
                }
            }

            regkeyNodeTypes.Close();

        }

        regkeyThisSnapin.Close();
    }

    regkeySnapins.Close();

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterSnapin(const GUID* pSnapinCLSID)
{
    USES_CONVERSION;
    OLECHAR szSnapinClassID[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,iStrGuidLen))
		return UnregisterSnapin(szSnapinClassID);
	else
		return E_INVALIDARG;
}

HRESULT UnregisterSnapin(LPCTSTR lpszSnapinClassID)
{
    //
    // open MMC Snapins key
    //
    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE,
                                   SNAPINS_KEY);

    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    //
    // delete SCE sub key (and all related subkeys under SCE)
    //
    lRes = regkeySnapins.RecurseDeleteKey(lpszSnapinClassID);

    regkeySnapins.Close();

    if ( lRes == ERROR_FILE_NOT_FOUND )
        return S_OK;

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return RegisterNodeType(OLE2T(szGuid), lpszNodeDescription);
	else
		return E_INVALIDARG;
}


HRESULT RegisterNodeType(LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    CRegKey regkeyThisNodeType;
    lRes = regkeyThisNodeType.Create(regkeyNodeTypes, lpszNodeGuid);
    ASSERT(lRes == ERROR_SUCCESS);

    if (lRes == ERROR_SUCCESS) {

        lRes = regkeyThisNodeType.SetValue(lpszNodeDescription);

        regkeyThisNodeType.Close();
    }

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT RegisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return RegisterNodeType(lpszNodeType, OLE2T(szGuid), lpszNodeDescription);
	else
		return E_INVALIDARG;
}


HRESULT RegisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription)
{

    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    if (lRes == ERROR_SUCCESS) {

        CRegKey regkeyThisNodeType;
        lRes = regkeyThisNodeType.Create(regkeyNodeTypes, lpszNodeType );

        if (lRes == ERROR_SUCCESS) {

            CRegKey regkeyExtensions;

            lRes = regkeyExtensions.Create(regkeyThisNodeType, g_szExtensions);

            if ( lRes == ERROR_SUCCESS ) {

                CRegKey regkeyNameSpace;

                lRes = regkeyNameSpace.Create(regkeyExtensions, g_szNameSpace);

                if ( lRes == ERROR_SUCCESS ) {

                    lRes = regkeyNameSpace.SetValue( lpszNodeDescription, lpszNodeGuid );

                    regkeyNameSpace.Close();
                }
                regkeyExtensions.Close();
            }

            regkeyThisNodeType.Close();
        }

        regkeyNodeTypes.Close();

    }
    ASSERT(lRes == ERROR_SUCCESS);

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(const GUID* pGuid)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return UnregisterNodeType(OLE2T(szGuid));
	else
		return E_INVALIDARG;
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeGuid)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    lRes = regkeyNodeTypes.RecurseDeleteKey(lpszNodeGuid);

    regkeyNodeTypes.Close();

    if ( lRes == ERROR_FILE_NOT_FOUND )
        return S_OK;

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterDefaultTemplate(LPCTSTR lpszTemplateDir)
{
   CRegKey regkeyTemplates;
   CString strKey;
   LONG lRes;

   strKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);

   /*
   lRes = regkeyTemplates.Open(HKEY_LOCAL_MACHINE, strKey);
   ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open
    */
   lRes = regkeyTemplates.Create(HKEY_LOCAL_MACHINE,lpszTemplateDir);
    ASSERT(lRes == ERROR_SUCCESS);
    return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return UnregisterNodeType(lpszNodeType, OLE2T(szGuid));
	else
		return E_INVALIDARG;
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );

    if (lRes == ERROR_SUCCESS) {

        CRegKey regkeyThisNodeType;
        lRes = regkeyThisNodeType.Open(regkeyNodeTypes, lpszNodeType );

        if (lRes == ERROR_SUCCESS) {

            CRegKey regkeyExtensions;

            lRes = regkeyExtensions.Open(regkeyThisNodeType, g_szExtensions);

            if ( lRes == ERROR_SUCCESS ) {

                CRegKey regkeyNameSpace;

                lRes = regkeyNameSpace.Open(regkeyExtensions, g_szNameSpace);

                if ( lRes == ERROR_SUCCESS ) {

                    lRes = regkeyNameSpace.DeleteValue( lpszNodeGuid );

                    regkeyNameSpace.Close();
                }
                regkeyExtensions.Close();
            }

            regkeyThisNodeType.Close();
        }

        regkeyNodeTypes.Close();


    }

    if ( lRes == ERROR_FILE_NOT_FOUND ) {
        return S_OK;

    } else
        return HRESULT_FROM_WIN32(lRes);

}

HRESULT
RegisterEnvVarsToExpand() {
   CString strKey;
   CString strValue;
   CString strEnvVars;
   TCHAR *pch;
   HRESULT hr;
   HKEY hKey;
   LONG status;

   if (!strKey.LoadString(IDS_SECEDIT_KEY)) {
      return E_FAIL;
   }
   if (!strValue.LoadString(IDS_ENV_VARS_REG_VALUE)) {
      return E_FAIL;
   }
   if (!strEnvVars.LoadString(IDS_DEF_ENV_VARS)) {
      return E_FAIL;
   }

   //
   // Convert strEnvVars' | to '\0' to be a proper multi-sz
   //
   for (int i = 0; i < strEnvVars.GetLength(); i++)
   {
	   if (strEnvVars[i] == L'|')
		   strEnvVars.SetAt(i, L'\0');
   }

   //
   // Open up the key we keep our Environment Variables in
   //
   status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         strKey,
                         0,      // Reserved
                         NULL,   // Class
                         0,      // Options
                         KEY_WRITE,
                         NULL,   // Security
                         &hKey,
                         NULL);

   if (ERROR_SUCCESS != status) {
      return HRESULT_FROM_WIN32(status);
   }

   int iLenth = strEnvVars.GetLength();
   BYTE* pbBufEnvVars = (BYTE*)(strEnvVars.GetBuffer(iLenth));
   status = RegSetValueEx(hKey,
                          strValue,
                          NULL,
                          REG_MULTI_SZ,
                          pbBufEnvVars,
                          iLenth * sizeof(WCHAR));

   strEnvVars.ReleaseBuffer();

   if (ERROR_SUCCESS != status) {
      return HRESULT_FROM_WIN32(status);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\wsecmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
 */
/* Compiler settings for Snapin.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#pragma warning(push,3)

#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif  /* __IComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IComponent : public IUnknown
    {
    public:
    };

#else   /* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IComponent __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IComponent __RPC_FAR * This);

        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)    \
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif  /* C style interface */




#endif  /* __IComponent_INTERFACE_DEFINED__ */



#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SNAPINLib
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_SNAPINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Snapin;
EXTERN_C const CLSID CLSID_LSSnapin;
EXTERN_C const CLSID CLSID_SCESnapin;
EXTERN_C const CLSID CLSID_SAVSnapin;

class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}

#endif
#pragma warning(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\additionalfuncpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       AdditionalFuncPage.cxx
//
//  History:    29-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "chklist.h"
#include "AdditionalFuncPage.h"

////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
AdditionalFuncPage::AdditionalFuncPage()
                             :
   SecCfgWizardPage(
      IDD_ADDITIONAL_FUNC_SEL,
      IDS_ADDITIONAL_FUNC_SEL_PAGE_TITLE,
      IDS_ADDITIONAL_FUNC_SEL_PAGE_SUBTITLE)
{
   LOG_CTOR(AdditionalFuncPage);
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
AdditionalFuncPage::~AdditionalFuncPage()
{
   LOG_DTOR(AdditionalFuncPage);
}
void
AdditionalFuncPage::OnInit()
{
   LOG_FUNCTION(AdditionalFuncPage::OnInit);

}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   /*int next = PSWIZB_NEXT;

   if (Win::IsDlgButtonChecked(dialog, IDC_EDIT_CFG_RADIO))
   {
      next = !Win::GetTrimmedDlgItemText(dialog, IDC_EXISTING_CFG_EDIT).empty()
         ?  PSWIZB_NEXT : 0;
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);*/
}



bool
AdditionalFuncPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    /* controlIDFrom */ ,
   unsigned    /* code */ )
{
   LOG_FUNCTION(AdditionalFuncPage::OnCommand);

   // State& state = State::GetInstance();

   /*switch (controlIDFrom)
   {
   
   }*/

   return false;
}



bool
AdditionalFuncPage::OnSetActive()
{
   LOG_FUNCTION(AdditionalFuncPage::OnSetActive);
   
   enable(hwnd);

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      return FALSE;
   }
   Win::SendMessage(hWnd, CLM_RESETCONTENT,0,0);

   State& state = State::GetInstance();

   //Add Roles

   HRESULT hr = S_OK;
   RoleObject * pRole;

   for (long i = 0; i < state.GetNumRoles(); i++)
   {
      pRole = NULL;

      //Get Question services from Main.XML

      //if it is a client role

      if (FAILED(hr) || !pRole)
      {
         return true;
      }

      int nIndex = (int) Win::SendMessage(hWnd,
                                          CLM_ADDITEM,
                                          (WPARAM)pRole->getDisplayName(),
                                          (LPARAM)0);
      if (nIndex != -1)
      {
         BOOL bSet;
   
         //First column setting
         bSet = CLST_CHECKED;
         Win::SendMessage(hWnd,
                          CLM_SETSTATE,
                          MAKELONG(nIndex,1),
                          bSet ? CLST_CHECKED : CLST_UNCHECKED);
      
         // Second column setting if there is
         //bSet = CLST_UNCHECKED;
         //Win::SendMessage(hWnd,
         //                 CLM_SETSTATE,
         //                 MAKELONG(nIndex,2),
         //                 CLST_DISABLED | (bSet ? CLST_CHECKED : CLST_UNCHECKED));
      }
      // role objects should be saved as item data rather than being deleted here:
      delete pRole;
   }

   return true;
}


   
int
AdditionalFuncPage::Validate()
{
   LOG_FUNCTION(AdditionalFuncPage::Validate);

   int nextPage = IDD_SERVICEDISABLE_METHOD; 

   // State& state = State::GetInstance();

   // HRESULT hr = S_OK;
   DWORD dw = 0;

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      ;//error
   }
   else
   {
      int nItems = (int) Win::SendMessage(hWnd,CLM_GETITEMCOUNT,0,0);
      for (int i=0;i<nItems;i++) 
      {
         dw = (DWORD)Win::SendMessage(hWnd,CLM_GETSTATE,MAKELONG(i,1),0);
         if (CLST_CHECKED == dw)
         {
            ;//selected
         }
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\additionalfuncpage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       AdditionalFuncPage.h
//
//  History:    29-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#ifndef ADDITIONALFUNCPAGE_H_INCLUDED
#define ADDITIONALFUNCPAGE_H_INCLUDED

#include "page.h"

class AdditionalFuncPage : public SecCfgWizardPage
{
   public:

   AdditionalFuncPage();

   protected:

   virtual ~AdditionalFuncPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   AdditionalFuncPage(const AdditionalFuncPage&);
   const AdditionalFuncPage& operator=(const AdditionalFuncPage&);
};

#endif   // ADDITIONALFUNCPAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\chklist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-2001           **/
/**********************************************************************/

/*

    CHKLIST.CPP

    This file contains the implementation of the CheckList control.

*/
#include "pch.h"
#include "chklist.h"
#include <assert.h>
#include <windowsx.h>


#define TraceLeaveVoid() { return; }
#define TraceEnter(dwMask, fn) { ; }
#define TraceAssert(x) assert(x)
#define TraceLeaveValue(value)  { return(value); }
//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    32
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8

//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


typedef struct _USERDATA_STRUCT_LABEL
{
    LPARAM      lParam;
    int         nLabelHeight;
    int         itemIndex;
} USERDATA_STRUCT_LABEL, *LPUSERDATA_STRUCT_LABEL;

class CheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;

    int m_nDefaultVerticalSpace;
    int m_nDefaultItemHeight;
    int m_nNewItemYPos;

    HWND m_hwndCheckFocus;

    BOOL m_fInMessageEnable;

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CheckList(HWND hWnd, LPCREATESTRUCT lpcs);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd, LONG *pnAmountObscured = NULL);
    void SetTopIndex(HWND hWnd, LONG nIndex);
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);

public:
    HWND m_hWnd;
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};

BOOL RegisterCheckListWndClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    //AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    wc.hInstance        = hInstance; //AfxGetInstanceHandle(); //hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CheckList::g_ucScrollLines = (UINT)-1;


CheckList::CheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_fInMessageEnable(FALSE), m_cWheelDelta(0)
{
    assert(hWnd != NULL);
    assert(lpcs != NULL);

    m_hWnd = hWnd;
    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    // for wsecedit only
    if ( m_cSubItems > 3 ) {
        m_cSubItems = 3;
    }

    if( lpcs->style & CLS_LEFTALIGN ) //if checkbox is at the left of text only 1 checkbox is allowed.
    {
        m_cSubItems = 1;
    }

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    m_nDefaultVerticalSpace = rc.top;
    m_nDefaultItemHeight = rc.bottom - rc.top;
    m_nNewItemYPos = rc.top;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}


LRESULT
CheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case EN_SETFOCUS:
        {
            // Make the focus go to one of the checkboxes
            POINT pt;
            DWORD dwPos = GetMessagePos();
            pt.x = GET_X_LPARAM(dwPos);
            pt.y = GET_Y_LPARAM(dwPos);
            MapWindowPoints(NULL, hWnd, &pt, 1);
            MsgButtonDown(hWnd, 0, pt.x, pt.y);
        }
        break;

    case BN_CLICKED:
        {
            LPUSERDATA_STRUCT_LABEL lpUserData = NULL;
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            HRESULT hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                                GWLP_USERDATA, (LONG_PTR&)lpUserData);
            //lpUserData = (LPUSERDATA_STRUCT_LABEL)
            //        Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
            //                                    GWLP_USERDATA);
            if (SUCCEEDED(hr) && lpUserData)
            {
               nmc.dwItemData = lpUserData->lParam;
            }

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);

        }
        break;

    case BN_SETFOCUS:
        if (GetFocus() != hwndCtrl)
        {
            // This causes another BN_SETFOCUS
            SetFocus(hwndCtrl);
        }
        else
        {
            if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
            {
                // Remember where the focus is
                m_hwndCheckFocus = hwndCtrl;

                // Make sure the row is scrolled into view
                EnsureVisible(hWnd, GET_ITEM(idCmd));
            }
            // Always draw the focus rect
            DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        }
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    //if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    long winlong = 0;
    Win::GetWindowLong(hWnd, GWL_STYLE, winlong);
    if (WS_VSCROLL & winlong)
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int xPos, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    if (nItemIndex == -1)
    {
        return;
    }
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    if( hWnd == m_hWnd ) //Raid #387542, 5/9/2001
    {
        POINT pos = {xPos,yPos};
        HWND ChildhWnd = ::ChildWindowFromPointEx(hWnd, pos, CWP_SKIPINVISIBLE|CWP_SKIPDISABLED);
        if( ChildhWnd )
        {
            LPUSERDATA_STRUCT_LABEL pUserData = NULL;
            HRESULT hr = Win::GetWindowLongPtr(ChildhWnd, GWLP_USERDATA, (LONG_PTR&)pUserData);
            //LPUSERDATA_STRUCT_LABEL pUserData = (LPUSERDATA_STRUCT_LABEL)GetWindowLongPtr(ChildhWnd, GWLP_USERDATA);
            if (SUCCEEDED(hr) && pUserData)
            {
                nItemIndex = pUserData->itemIndex;
            }
            else
            {
                return;
            }
        }
    }

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        int id = MAKE_CTRL_ID(nItemIndex, j);
        HWND hwndCheck = GetDlgItem(hWnd, id);
        if (IsWindowEnabled(hwndCheck))
        {
            // Don't just SetFocus here.  We sometimes call this during
            // EN_SETFOCUS, and USER doesn't like it when you mess with
            // focus during a focus change.
            //
            //SetFocus(hwndCheck);
            PostMessage(hWnd,
                        WM_COMMAND,
                        GET_WM_COMMAND_MPS(id, hwndCheck, BN_SETFOCUS));
            break;
        }
    }
}


void
CheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    HWND hwndCurrentCheck;
    BOOL fCheckEnabled = FALSE;

    if (!m_fInMessageEnable)
    {
        m_fInMessageEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                hwndCurrentCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(i, j));
                //fCheckEnabled =   (BOOL) GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA);
                Win::GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA, (LONG_PTR&)fCheckEnabled);

                //
                // If the user of the checklist control is disabling the control
                // altogether, or the current checkbox has been disabled singularly
                // then disable the checkbox
                //
                if (!fEnabled || !fCheckEnabled)
                {
                    EnableWindow(hwndCurrentCheck, FALSE);
                }
                else
                {
                    EnableWindow(hwndCurrentCheck, TRUE);
                }
            }
        }
        // Note that the main chklist window must remain enabled
        // for scrolling to work while "disabled".
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);

        m_fInMessageEnable = FALSE;
    }
}


void
CheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_nNewItemYPos - 1;
        si.nPage = nHeight;

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}

LONG CheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND                    hwndPrev = 0;
    LPUSERDATA_STRUCT_LABEL lpUserData = 0;

    TraceEnter(TRACE_CHECKLIST, "CheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));
    if ( !hWnd || !pszLabel || IsBadStringPtr(pszLabel, MAX_PATH) )
        return -1;

    lpUserData = new (USERDATA_STRUCT_LABEL);
    if ( lpUserData )
    {
        SCROLLINFO  si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS;
        si.nPos = 0;
        GetScrollInfo(hWnd, SB_VERT, &si);

        // Set the initial label height extra big so the control can wrap the text,
        // then reset it after creating the control.
        RECT    rc;
        GetClientRect(hWnd, &rc);
        LONG    nLabelHeight = rc.bottom;

        //AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
        HMODULE hModule = GetResourceModuleHandle(); //AfxGetInstanceHandle();

        // Create a new label control
        HWND hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 TEXT("edit"),
                                 pszLabel,
                                 WS_CHILD | WS_VISIBLE | WS_GROUP | ES_MULTILINE | ES_READONLY | ES_LEFT,// | WS_GROUP,
                                 m_rcItemLabel.left,
                                 m_nNewItemYPos - si.nPos,
                                 m_rcItemLabel.right - m_rcItemLabel.left,
                                 nLabelHeight,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                                 hModule,
                                 NULL);
        if ( hwndNew )
        {
            HWND hwndEdit = hwndNew;
            //
            // Reset window height after word wrap has been done.
            //
            LONG nLineCount = (LONG) SendMessage(hwndNew, EM_GETLINECOUNT, 0, (LPARAM) 0);
            nLabelHeight = nLineCount * m_nDefaultItemHeight;
            SetWindowPos(hwndNew,
                         NULL,
                         0,
                         0,
                         m_rcItemLabel.right - m_rcItemLabel.left,
                         nLabelHeight,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

            //
            // Save item data
            //
            lpUserData->lParam = lParam;
            lpUserData->nLabelHeight = nLabelHeight;
            lpUserData->itemIndex = m_cItems; //Raid #387542

            SetLastError(0);
            //SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) lpUserData); //Raid #286697, 4/4/2001
            HRESULT hr = Win::SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LONG_PTR)lpUserData);
            if (SUCCEEDED(hr)) // 0 == GetLastError() )
            {
                // Set the font
                SendMessage(hwndNew,
                            WM_SETFONT,
                            SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                            0);

                // Set Z-order position just after the last checkbox. This keeps
                // tab order correct.
                if (m_cItems > 0)
                {
                    hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                }

                // Create new checkboxes
                DWORD dwCheckStyle = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX;
                for (LONG j = 0; j < m_cSubItems; j++)
                {
                    hwndPrev = hwndNew;
                    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                             TEXT("BUTTON"),
                                             NULL,
                                             dwCheckStyle,
                                             m_nCheckPos[j],
                                             m_nNewItemYPos - si.nPos,
                                             m_cxCheckBox,
                                             m_rcItemLabel.bottom - m_rcItemLabel.top,
                                             hWnd,
                                             (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                             hModule,
                                             NULL);
                    if (!hwndNew)
                    {
                        while (j >= 0)
                        {
                            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                            j--;
                        }

                        DestroyWindow (hwndEdit);
                        delete lpUserData;
                        TraceLeaveValue(-1);
                    }

                    // Set Z-order position just after the last checkbox. This keeps
                    // tab order correct.
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                    //
                    // Default "enabled" to TRUE
                    //
                    //SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) TRUE);
                    hr = Win::SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LONG_PTR)TRUE);

                    // Only want this style on the first checkbox
                    dwCheckStyle &= ~WS_GROUP;
                }

                // We now officially have a new item
                m_cItems++;

                // calculate Y pos for next item to be inserted
                m_nNewItemYPos += nLabelHeight + m_nDefaultVerticalSpace;

                //
                // The last thing is to set the scroll range
                //
                GetClientRect(hWnd, &rc);
                si.cbSize = sizeof(si);
                si.fMask = SIF_PAGE | SIF_RANGE;
                si.nMin = 0;
                si.nMax = m_nNewItemYPos - 1;
                si.nPage = rc.bottom;

                SetScrollInfo(hWnd, SB_VERT, &si, FALSE);
            }
            else
            {
               delete lpUserData;
               DestroyWindow(hwndNew);
            }
        }
        else
            delete lpUserData;
    }

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    HWND hwndCtrl;

    TraceEnter(TRACE_CHECKLIST, "CheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    if (iSubItem > 0)
    {
        hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
        if (hwndCtrl != NULL)
        {
            //SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LPARAM) !(lState & CLST_DISABLED));
            Win::SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LONG_PTR)!(lState & CLST_DISABLED));
            SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
            EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
        }
    }

    TraceLeaveVoid();
}


LONG
CheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG                    j;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    LONG                    nLabelHeight;

    TraceEnter(TRACE_CHECKLIST, "CheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    long dwChkListStyle = 0;
    Win::GetWindowLong(hWnd, GWL_STYLE, dwChkListStyle);
    if (m_cSubItems > 0)
    {
        if ( dwChkListStyle & CLS_LEFTALIGN )
		{
			// Put the checkboxes at the left of the text
			int xSubItem = m_rcItemLabel.left;
			for (j = 0; j < m_cSubItems; j++, xSubItem += cxColumn)
				m_nCheckPos[j] = xSubItem;
			m_rcItemLabel.left = xSubItem - (cxColumn + m_cxCheckBox)/2;
			m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;
        }
		else
        {
            m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

            for (j = m_cSubItems - 1; j > 0; j--)
                m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

            //              (leftmost check pos) - (horz margin)
            m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
        }
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
        //                                GWLP_USERDATA);
        HRESULT hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (SUCCEEDED(hr) && pUserData != NULL)
        {
            nLabelHeight = pUserData->nLabelHeight;
        }
        else
        {
            nLabelHeight = nBottom - nTop;
        }

        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nLabelHeight,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += nLabelHeight + m_nDefaultVerticalSpace;
        nBottom += nLabelHeight + m_nDefaultVerticalSpace;
    }

    TraceLeaveVoid();
}


void
CheckList::ResetContent(HWND hWnd)
{
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    HWND                    hwndCurrentLabel;

    for (LONG i = 0; i < m_cItems; i++)
    {
        hwndCurrentLabel = GetDlgItem(hWnd, MAKE_LABEL_ID((int)i));
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   hwndCurrentLabel,
        //                                GWLP_USERDATA);
        HRESULT hr = Win::GetWindowLongPtr(   hwndCurrentLabel,
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (SUCCEEDED(hr) && pUserData != NULL)
        {
            delete(pUserData);
        }
        DestroyWindow(hwndCurrentLabel);

        for (LONG j = 1; j <= m_cSubItems; j++)
        {
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));
        }
    }

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CheckList::GetVisibleCount(HWND hWnd)
{
    LONG                    nCount = 0;
    RECT                    rc;
    LONG                    nTopIndex;
    LONG                    nAmountShown = 0;
    LONG                    nAmountObscured = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;

    if (!GetClientRect(hWnd, &rc))
    {
        return 1;
    }

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return 1;
    }

    while ((nTopIndex < m_cItems) && (nAmountShown < rc.bottom))
    {
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
        //                                GWLP_USERDATA);
        HRESULT hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (SUCCEEDED(hr) && pUserData)
        {
            nAmountShown += (m_nDefaultVerticalSpace + pUserData->nLabelHeight - nAmountObscured);
        }
        nAmountObscured = 0;    // nAmountObscured only matters for the first iteration where
                                // the real top index's amount shown is being calculated
        nCount++;
        nTopIndex++;
    }

    //
    // since that last one may be obscured see if we need to adjust nCount
    //
    if (nAmountShown > rc.bottom)
    {
        nCount--;
    }

    return max(1, nCount);
}

LONG
CheckList::GetTopIndex(HWND hWnd, LONG *pnAmountObscured)
{
    LONG                    nIndex = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    SCROLLINFO              si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    //
    // initialize
    //
    if (pnAmountObscured != NULL)
    {
        *pnAmountObscured = 0;
    }

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
    {
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
        //                                GWLP_USERDATA);
        HRESULT hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        //
        // if there are no items get out
        //
        if (FAILED(hr) || pUserData == NULL)
        {
            return -1;
        }

        while (si.nPos >= (m_nDefaultVerticalSpace + pUserData->nLabelHeight))
        {
            si.nPos -= (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
            nIndex++;
            //pUserData = (LPUSERDATA_STRUCT_LABEL)
            //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
            //                                GWLP_USERDATA);
            hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                            GWLP_USERDATA, (LONG_PTR&)pUserData);
        }

        if (pnAmountObscured != NULL)
        {
            *pnAmountObscured = si.nPos;
        }
    }

    return nIndex;
}

void
CheckList::SetTopIndex(HWND hWnd, LONG nIndex)
{
    int                     i;
    int                     nPos = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;

    for (i=0; i<nIndex; i++)
    {
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
        //                                GWLP_USERDATA);
        HRESULT hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (SUCCEEDED(hr) && pUserData)
        {
            nPos += (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
        }
    }

    m_cWheelDelta = 0;
    MsgVScroll(hWnd, SB_THUMBPOSITION, nPos);
}


void
CheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG                    nAmountObscured = 0;
    LONG                    nTopIndex;
    RECT                    rc;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return;
    }

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else if (nItemIndex == nTopIndex)
    {
        if (nAmountObscured != 0)
        {
            SetTopIndex(hWnd, nItemIndex);
        }
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
        {
            if (!GetClientRect(hWnd, &rc))
            {
                //
                // This is just best effort
                //
                SetTopIndex(hWnd, nItemIndex - nVisible + 1);
            }
            else
            {
                //
                // Calculate what the top index should be to allow
                // nItemIndex to be fully visible
                //
                nTopIndex = nItemIndex + 1;
                HRESULT hr = S_OK;
                do
                {
                    nTopIndex--;
                    //pUserData = (LPUSERDATA_STRUCT_LABEL)
                    //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                    //                                GWLP_USERDATA);
                    hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                                    GWLP_USERDATA, (LONG_PTR&)pUserData);
                    if (SUCCEEDED(hr) && pUserData != NULL)
                    {
                        rc.bottom -= (pUserData->nLabelHeight + m_nDefaultVerticalSpace);
                        if (rc.bottom < 0)
                        {
                            nTopIndex++;
                        }
                    }
                    else
                    {
                        //
                        // Should not hit this, just added to make things safe
                        //
                        rc.bottom = 0;
                        nTopIndex = 0;
                    }
                } while (rc.bottom > 0);

                SetTopIndex(hWnd, nTopIndex);
            }
        }
    }
}


void
CheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;

    TraceEnter(TRACE_CHECKLIST, "CheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    HDC hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}

LRESULT
CALLBACK
CheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                 lResult = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    CheckList *pThis = NULL; //(CheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    HRESULT hr = Win::GetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR&)pThis);
    if (FAILED(hr))
    {
       TraceAssert(false);
       return 0;
    }

    TraceEnter(TRACE_CHECKLIST, "CheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            //SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            hr = Win::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_DESTROY:
        pThis->ResetContent(hWnd);
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND: 
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
        //                                GWLP_USERDATA);
        hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (pUserData != NULL)
            pUserData->lParam = lParam;
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        //pUserData = (LPUSERDATA_STRUCT_LABEL)
        //            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
        //                                GWLP_USERDATA);
        hr = Win::GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA, (LONG_PTR&)pUserData);
        if (pUserData != NULL)
            lResult = pUserData->lParam;
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            lResult = TRUE;
            break;
        }
    // Fall Through
    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\chklist.h ===
//-----------------------------------------------------------------------------
//
// chklist.h - Definitions and prototypes for the checklist pseudo-control
//
// Copyright 1996-2001, Microsoft Corporation
//
//
//-----------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_SSR"

//BOOL RegisterCheckListWndClass(void);


//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f
#define CLS_LEFTALIGN       0x0010		// Align the checkboxes at the left of the text (default = right)

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_CLICK           (0U-1000U)      // lparam = PNM_CHECKLIST

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
} NM_CHECKLIST, *PNM_CHECKLIST;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\clientroleselpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ClientRoleSelPage.cxx
//
//  Contents:   Client Server Role Configuration Page.
//
//  History:    25-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "ClientRoleSelPage.h"
#include "chklist.h"
#include "otherpages.h"

ClientRoleSelPage::ClientRoleSelPage()
   :
   SecCfgWizardPage(
      IDD_CLIENT_ROLE_SEL,
      IDS_CLIENT_ROLE_SEL_PAGE_TITLE,
      IDS_CLIENT_ROLE_SEL_PAGE_SUBTITLE)
{
   LOG_CTOR(ClientRoleSelPage);
}



ClientRoleSelPage::~ClientRoleSelPage()
{
   LOG_DTOR(ClientRoleSelPage);
}



void
ClientRoleSelPage::OnInit()
{
   LOG_FUNCTION(ClientRoleSelPage::OnInit);

}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   /*int next = PSWIZB_NEXT;

   if (Win::IsDlgButtonChecked(dialog, IDC_EDIT_CFG_RADIO))
   {
      next = !Win::GetTrimmedDlgItemText(dialog, IDC_EXISTING_CFG_EDIT).empty()
         ?  PSWIZB_NEXT : 0;
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);*/
}



bool
ClientRoleSelPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code)
{
   LOG_FUNCTION(ClientRoleSelPage::OnCommand);

   // State& state = State::GetInstance();

   switch (controlIDFrom)
   {
      case IDC_ADDITIONALE_ROLE:
      {
         if (code == BN_CLICKED)
         {
             AdditionalRolesPage* pDlg = new AdditionalRolesPage();
             if( IDOK == pDlg->ModalExecute(hwnd) )
             {
                 ;
             }
             return true;
         }
         break;
      }
   }

   return false;
}



bool
ClientRoleSelPage::OnSetActive()
{
   LOG_FUNCTION(ClientRoleSelPage::OnSetActive);
   
   enable(hwnd);

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      return FALSE;
   }
   Win::SendMessage(hWnd, CLM_RESETCONTENT,0,0);

   State& state = State::GetInstance();

   //Add Roles

   HRESULT hr = S_OK;
   RoleObject * pRole;

   for (long i = 0; i < state.GetNumRoles(); i++)
   {
      pRole = NULL;

      hr = state.GetRole(i, &pRole);

      //if it is a client role

      if (FAILED(hr) || !pRole)
      {
         return true;
      }

      int nIndex = (int) Win::SendMessage(hWnd,
                                          CLM_ADDITEM,
                                          (WPARAM)pRole->getDisplayName(),
                                          (LPARAM)0);
      if (nIndex != -1)
      {
         BOOL bSet;
   
         //First column setting
         bSet = CLST_CHECKED;
         Win::SendMessage(hWnd,
                          CLM_SETSTATE,
                          MAKELONG(nIndex,1),
                          bSet ? CLST_CHECKED : CLST_UNCHECKED);
      
         // Second column setting if there is
         //bSet = CLST_UNCHECKED;
         //Win::SendMessage(hWnd,
         //                 CLM_SETSTATE,
         //                 MAKELONG(nIndex,2),
         //                 CLST_DISABLED | (bSet ? CLST_CHECKED : CLST_UNCHECKED));
      }
      // role objects should be saved as item data rather than being deleted here:
      delete pRole;
   }

   return true;
}


   
int
ClientRoleSelPage::Validate()
{
   LOG_FUNCTION(ClientRoleSelPage::Validate);

   int nextPage = IDD_ADDITIONAL_FUNC_SEL;

   // State& state = State::GetInstance();

   // HRESULT hr = S_OK;
   DWORD dw = 0;

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      ;//error
   }
   else
   {
      int nItems = (int) Win::SendMessage(hWnd,CLM_GETITEMCOUNT,0,0);
      for (int i=0;i<nItems;i++) 
      {
         dw = (DWORD)Win::SendMessage(hWnd,CLM_GETSTATE,MAKELONG(i,1),0);
         if (CLST_CHECKED == dw)
         {
            ;//selected
         }
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\clientroleselpage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ClientRoleSelPage.h
//
//  History:    25-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#ifndef CLIENTROLESELPAGE_H_INCLUDED
#define CLIENTROLESELPAGE_H_INCLUDED

#include "page.h"

class ClientRoleSelPage : public SecCfgWizardPage
{
   public:

   ClientRoleSelPage();

   protected:

   virtual ~ClientRoleSelPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ClientRoleSelPage(const ClientRoleSelPage&);
   const ClientRoleSelPage& operator=(const ClientRoleSelPage&);
};

#endif   // CLIENTROLESELPAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\finish.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       finish.cxx
//
//  Contents:   Finish Page.
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "finish.h"


FinishPage::FinishPage()
   :
   WizardPage(
      IDD_FINISH,
      IDS_FINISH_PAGE_TITLE,
      IDS_FINISH_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(FinishPage);
}



FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}



void
FinishPage::OnInit()
{
   LOG_FUNCTION(FinishPage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);
   Win::PropSheet_CancelToClose(Win::GetParent(hwnd));
}



bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_FINISH);

   return true;
}



bool
FinishPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   UNREFERENCED_PARAMETER(code);
   UNREFERENCED_PARAMETER(controlIdFrom);
   UNREFERENCED_PARAMETER(windowFrom);
/*   
   switch (controlIdFrom)
   {
      case IDCANCEL:
      {
         // multi-line edit control eats escape keys.  This is a workaround
         // from ericb, to forward the message to the prop sheet.

         Win::SendMessage(
            Win::GetParent(hwnd),
            WM_COMMAND,
            MAKEWPARAM(controlIdFrom, code),
            (LPARAM) windowFrom);
         break;   
      }
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, -1, -1);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2001/07/02-sburns

               // CODEWORK: There are several instances of this code so far;
               // looks like it merits a common base class.
   
               HWND propSheet = Win::GetParent(hwnd);
               int defaultButtonId =
                  Win::Dialog_GetDefaultButtonId(propSheet);
   
               // we expect that there is always a default button on the prop sheet
                  
               ASSERT(defaultButtonId);
   
               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);
   
               result = true;
               break;
            }
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }
*/
   return result;
}


            
bool
FinishPage::OnWizFinish()
{
   LOG_FUNCTION(FinishPage::OnWizFinish);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\finish.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       finish.h
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef FINISH_H_INCLUDED
#define FINISH_H_INCLUDED

//#include "MultiLineEditBoxThatForwardsEnterKey.hpp"

class FinishPage : public WizardPage
{
   public:

   FinishPage();

   protected:

   virtual ~FinishPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   virtual
   bool
   OnWizFinish();

   private:

//   bool needToKillSelection;
//   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;

   // not defined; no copying allowed
   
   FinishPage(const FinishPage&);
   const FinishPage& operator=(const FinishPage&);
};



#endif   // FINISH_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\misc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       misc.cxx
//
//  Contents:   Security Configuration wizard.
//
//  History:    13-Sep-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"

//+----------------------------------------------------------------------------
//
// Function:   InitFonts
//
// Creates the fonts for setLargeFonts().
//
// hDialog - handle to a dialog to be used to retrieve a device
// context.
//
// bigBoldFont - receives the handle of the big bold font created.
//-----------------------------------------------------------------------------
void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);

      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}

//+----------------------------------------------------------------------------
//
// Function:   SetLargeFont
//
// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
//
// dialog - handle to the dialog that is the parent of the control
//
// bigBoldResID - resource id of the control to change
//-----------------------------------------------------------------------------
void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}

//+----------------------------------------------------------------------------
//
// Function:   GetNodeText
//
// Returns the text value for the named node that is a child of the passed in
// Node. Returns S_FALSE if the named node cannot be found or contains no text.
// Will only return the first instance of a child node with the given name.
//
//-----------------------------------------------------------------------------
HRESULT
GetNodeText(IXMLDOMNode * pNode, PCWSTR pwzNodeName, String & strText)
{
   HRESULT hr = S_OK;
   IXMLDOMNode * pNameNode = NULL;

   hr = pNode->selectSingleNode(CComBSTR(pwzNodeName), &pNameNode);

   if (FAILED(hr))
   {
      LOG(String::format(L"Getting named node %1 failed with error %2!x!",
          pwzNodeName, hr));
      return hr;
   }

   DOMNodeType NodeType;

   hr = pNameNode->get_nodeType(&NodeType);

   if (NODE_ELEMENT != NodeType)
   {
      ASSERT(false);
      return S_FALSE;
   }

   IXMLDOMNode * pNameText = NULL;

   hr = pNameNode->get_firstChild(&pNameText);

   pNameNode->Release();

   if (S_FALSE == hr || !pNameText)
   {
      LOG(L"No name node value!");
      return S_FALSE;
   }
   if (FAILED(hr))
   {
      LOG(String::format(L"Getting node child failed with error %1!x!", hr));
      return hr;
   }

   CComVariant var;

   hr = pNameText->get_nodeValue(&var);

   pNameText->Release();

   if (S_FALSE == hr)
   {
      LOG(L"No name node value!");
      return hr;
   }
   if (FAILED(hr))
   {
      LOG(String::format(L"Getting node value failed with error %1!x!", hr));
      return hr;
   }

   ASSERT(var.vt == VT_BSTR);

   strText = var.bstrVal;

   strText.strip(String::BOTH, L' ');

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\misc.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       misc.h
//
//  Contents:   Miscelaneous helper functions.
//
//  History:    4-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef MISC_H_GUARD
#define MISC_H_GUARD

//+----------------------------------------------------------------------------
//
// Function:   SetLargeFont
//
// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
//
// dialog - handle to the dialog that is the parent of the control
//
// bigBoldResID - resource id of the control to change
//-----------------------------------------------------------------------------
void
SetLargeFont(HWND dialog, int bigBoldResID);

//+----------------------------------------------------------------------------
//
// Function:   GetNodeText
//
// Returns the text value for the named node. Returns S_FALSE if the named
// node cannot be found or contains no text. Will only return the first instance
// of a node with the given name.
//
//-----------------------------------------------------------------------------
HRESULT
GetNodeText(IXMLDOMNode * pNode, PCWSTR pwzNodeName, String & strText);

#endif // MISC_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\page.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       Page.cxx
//
//  Contents:   Wizard Page class definition.
//
//  History:    3-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "page.h"


SecCfgWizardPage::SecCfgWizardPage(
   int   dialogResID,
   int   titleResID,
   int   subtitleResID,   
   bool  isInteriorPage)
   :
   WizardPage(dialogResID, titleResID, subtitleResID, isInteriorPage)
{
   LOG_CTOR(SecCfgWizardPage);
}

   

SecCfgWizardPage::~SecCfgWizardPage()
{
   LOG_DTOR(SecCfgWizardPage);
}



bool
SecCfgWizardPage::OnWizNext()
{
   LOG_FUNCTION(SecCfgWizardPage::OnWizNext);

   GetWizard().SetNextPageID(hwnd, Validate());
   return true;
}


/*
bool
SecCfgWizardPage::OnQueryCancel()
{
   LOG_FUNCTION(SecCfgWizardPage::OnQueryCancel);

   State& state = State::GetInstance();

   int id = IDS_CONFIRM_CANCEL;
   switch (state.GetRunContext())
   {
      case State::BDC_UPGRADE:
      case State::PDC_UPGRADE:
      {
         id = IDS_CONFIRM_UPGRADE_CANCEL;
         break;
      }
      case State::NT5_DC:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      default:
      {
         // do nothing
         break;
      }
   }

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
         (popup.MessageBox(hwnd, id, MB_YESNO | MB_DEFBUTTON2) == IDYES)
      ?  FALSE
      :  TRUE);

   return true;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\otherpages.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       OtherPages.cxx
//  Comments:   This file inlcudes Secuirty Level page and Pre-Process page.
//
//  History:    22-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//Security Level Page
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "otherpages.h"
#include "chklist.h"
#include "ServiceSelPage.h"

SecurityLevelPage::SecurityLevelPage()
   :
   SecCfgWizardPage(
      IDD_SECURITY_LEVEL,
      IDS_SECURITY_LEVEL_PAGE_TITLE,
      IDS_SECURITY_LEVEL_PAGE_SUBTITLE)
{
   LOG_CTOR(SecurityLevelPage);
}



SecurityLevelPage::~SecurityLevelPage()
{
   LOG_DTOR(SecurityLevelPage);
}



void
SecurityLevelPage::OnInit()
{
   LOG_FUNCTION(SecurityLevelPage::OnInit);

}

static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   /*int next = PSWIZB_NEXT;

   if (Win::IsDlgButtonChecked(dialog, IDC_EDIT_CFG_RADIO))
   {
      next = !Win::GetTrimmedDlgItemText(dialog, IDC_EXISTING_CFG_EDIT).empty()
         ?  PSWIZB_NEXT : 0;
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);*/
}



bool
SecurityLevelPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    /* controlIDFrom */ ,
   unsigned    /* code */ )
{
   LOG_FUNCTION(SecurityLevelPage::OnCommand);

   // State& state = State::GetInstance();

   /*switch (controlIDFrom)
   {
   
   }*/

   return false;
}



bool
SecurityLevelPage::OnSetActive()
{
   LOG_FUNCTION(SecurityLevelPage::OnSetActive);
   
   enable(hwnd);

   //get default security level.
   Win::CheckDlgButton(hwnd, IDC_MAXIMUM_LEVEL, BST_CHECKED);

   return true;
}


   
int
SecurityLevelPage::Validate()
{
   LOG_FUNCTION(SecurityLevelPage::Validate);

   int nextPage = IDD_PRE_PROCESSING; //IDD_SERVER_ROLE_SEL; 

   // State& state = State::GetInstance();

   // get security level result here.
   if( Win::IsDlgButtonChecked(hwnd, IDC_MAXIMUM_LEVEL)==BST_CHECKED )
   {
       ;//level is Maximum
   }
   else
   {
       ;//level is typical
   }
   
   return nextPage;
}

//////////////////////////////////////////////////////////////////////////////////
// Pre-Process Page
//
//////////////////////////////////////////////////////////////////////////////////
PreProcessPage::PreProcessPage()
   :
   SecCfgWizardPage(
      IDD_PRE_PROCESSING,
      IDS_PRE_PROCESSING_PAGE_TITLE,
      IDS_PRE_PROCESSING_PAGE_SUBTITLE)
{
   LOG_CTOR(PreProcessPage);
}



PreProcessPage::~PreProcessPage()
{
   LOG_DTOR(PreProcessPage);
}

void
PreProcessPage::OnInit()
{
   LOG_FUNCTION(PreProcessPage::OnInit);
}

bool
PreProcessPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    /* controlIDFrom */ ,
   unsigned    /* code */ )
{
   LOG_FUNCTION(PreProcessPage::OnCommand);

   // Interact with engine to get real time process info and display it.

   /*switch (controlIDFrom)
   {
   
   }*/

   return false;
}



bool
PreProcessPage::OnSetActive()
{
   LOG_FUNCTION(PreProcessPage::OnSetActive);
   
   enable(hwnd);

   // Set the range and increment of the progress bar.
   HWND hwndPB = Win::GetDlgItem(hwnd, IDC_PROGRESS_PROCESS);
   Win::SendMessage(hwndPB, PBM_SETRANGE, 0, MAKELPARAM(0, 100)); 
   Win::SendMessage(hwndPB, PBM_SETSTEP, (WPARAM) 1, 0);
 
   //get pre-process info sample
   String strDes = String::format(IDS_DESCRIPTION_PROCESS, L"ssrmain.xml",L"Microsoft",L"10/20/2001",L"Maximum",L"DC.XML");
   Win::SetDlgItemText(hwnd, IDC_DES_PROCESS, strDes);

   int i;
   for(i=0; i<100; i++)
   {
        // Advance the current position of the progress bar 
        // by the increment. 
       Win::SendMessage(hwndPB, PBM_STEPIT, 0, 0);
   }

   return true;
}


   
int
PreProcessPage::Validate()
{
   LOG_FUNCTION(PreProcessPage::Validate);

   int nextPage = IDD_SERVER_ROLE_SEL; 

   // State& state = State::GetInstance();

   // get security level result here.
   
   return nextPage;
}


//////////////////////////////////////////////////////////////////////////////////
// Additional Roles Page
//
//////////////////////////////////////////////////////////////////////////////////
AdditionalRolesPage::AdditionalRolesPage()
   :
   Dialog(IDD_ADDITIONAL_ROLE_SEL, 0) //no help map
{
   LOG_CTOR(AdditionalRolesPage);
}



AdditionalRolesPage::~AdditionalRolesPage()
{
   LOG_DTOR(AdditionalRolesPage);
}

void
AdditionalRolesPage::OnInit()
{
   LOG_FUNCTION(AdditionalRolesPage::OnInit);

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      return;
   }
   Win::SendMessage(hWnd, CLM_RESETCONTENT,0,0);
}

bool
AdditionalRolesPage::OnCommand(
   HWND         /*windowFrom*/,
   unsigned     controlIDFrom,
   unsigned     /*code*/)
{
   LOG_FUNCTION(AdditionalRolesPage::OnCommand);

   // State& state = State::GetInstance();

   switch (controlIDFrom)
   {
   case IDOK:
       Win::EndDialog(hwnd, IDOK);
       return true;
   case IDCANCEL:
       Win::EndDialog(hwnd, IDCANCEL);
       return true;
   default:
       break;
   }

   return false;
}

bool
AdditionalRolesPage::OnMessage(
      UINT     message,
      WPARAM   /*wparam*/,
      LPARAM   /*lparam*/)
{
   LOG_FUNCTION(AdditionalRolesPage::OnMessage);

   switch (message)
   {
      case WM_COMMAND:
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}

/////////////////////////////////////////////////////////////////////////////////
//
// ServiceDisable Method Page
//
//////////////////////////////////////////////////////////////////////////////////

ServiceDisableMethodPage::ServiceDisableMethodPage()
   :
   SecCfgWizardPage(
      IDD_SERVICEDISABLE_METHOD,
      IDD_SERVICEDISABLE_METHOD_PAGE_TITLE,
      IDD_SERVICEDISABLE_METHOD_PAGE_SUBTITLE)
{
   LOG_CTOR(ServiceDisableMethodPage);
}



ServiceDisableMethodPage::~ServiceDisableMethodPage()
{
   LOG_DTOR(ServiceDisableMethodPage);
}



void
ServiceDisableMethodPage::OnInit()
{
   LOG_FUNCTION(ServiceDisableMethodPage::OnInit);

}

bool
ServiceDisableMethodPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    /*controlIDFrom*/,
   unsigned    /*code*/)
{
   LOG_FUNCTION(ServiceDisableMethodPage::OnCommand);

   // State& state = State::GetInstance();

   /*switch (controlIDFrom)
   {
      ;
   }*/

   return false;
}

bool
ServiceDisableMethodPage::OnNotify(
   HWND     /*windowFrom*/,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /*lParam*/)
{
   switch (controlIDFrom)
   {
      case IDC_ENABLED_SERVICES:
      {
         if (code == NM_CLICK || code == NM_RETURN )
         {
             ServiceEnabledPage* pDlg = new ServiceEnabledPage();
             if( IDOK == pDlg->ModalExecute(hwnd) )
             {
                 ;
             }
             return true;
         }
         break;
      }
      case IDC_DISABLED_SERVICES:
      {
         ;
      }
   }
   return false;
}

bool
ServiceDisableMethodPage::OnSetActive()
{
   LOG_FUNCTION(ServiceDisableMethodPage::OnSetActive);
   
   enable(hwnd);

   //get service disablement method.
   Win::CheckDlgButton(hwnd, IDC_IMPLICIT_METHOD, BST_CHECKED);

   return true;
}


   
int
ServiceDisableMethodPage::Validate()
{
   LOG_FUNCTION(ServiceDisableMethodPage::Validate);

   int nextPage = IDD_FINISH; //IDD_SERVER_ROLE_SEL; 

   // State& state = State::GetInstance();

   // get security level result here.
   if( Win::IsDlgButtonChecked(hwnd, IDC_IMPLICIT_METHOD)==BST_CHECKED )
   {
       ;//Method is Implicit
   }
   else
   {
       ;//Method is Explicit
   }
   
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\otherpages.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       Otherpages.h
//
//  History:    22-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#ifndef OTHERPAGES_H_INCLUDED
#define OTHERPAGES_H_INCLUDED

#include "page.h"

class SecurityLevelPage : public SecCfgWizardPage
{
   public:

   SecurityLevelPage();

   protected:

   virtual ~SecurityLevelPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   SecurityLevelPage(const SecurityLevelPage&);
   const SecurityLevelPage& operator=(const SecurityLevelPage&);
};


class PreProcessPage : public SecCfgWizardPage
{
   public:

   PreProcessPage();

   virtual ~PreProcessPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   PreProcessPage(const PreProcessPage&);
   const PreProcessPage& operator=(const PreProcessPage&);
};


class AdditionalRolesPage : public Dialog
{
   public:

   AdditionalRolesPage();

   protected:

   virtual ~AdditionalRolesPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   virtual
   void
   OnInit();

   private:

   // not defined; no copying allowed

   AdditionalRolesPage(const AdditionalRolesPage&);
   const AdditionalRolesPage& operator=(const AdditionalRolesPage&);
};


class ServiceDisableMethodPage : public SecCfgWizardPage
{
   public:

   ServiceDisableMethodPage();

   virtual ~ServiceDisableMethodPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ServiceDisableMethodPage(const ServiceDisableMethodPage&);
   const ServiceDisableMethodPage& operator=(const ServiceDisableMethodPage&);
};
#endif   // OTHERPAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\page.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       page.h
//
//  Contents:   Wizard page class declaration.
//
//  History:    4-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef PAGE_H_INCLUDED
#define PAGE_H_INCLUDED



class SecCfgWizardPage : public WizardPage
{
   public:

   virtual
   bool
   OnWizNext();

   protected:

   SecCfgWizardPage(
      int   dialogResID,
      int   titleResID,
      int   subtitleResID,   
      bool  isInteriorPage = true);

   virtual ~SecCfgWizardPage();

   // PropertyPage overrides

   //virtual
   //bool
   //OnQueryCancel();

   virtual
   int
   Validate() = 0;

   private:

   // not defined: no copying allowed
   SecCfgWizardPage(const SecCfgWizardPage&);
   const SecCfgWizardPage& operator=(const SecCfgWizardPage&);
};



#endif   // PAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\pch.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       pch.h
//
//  Contents:   precompiled includes
//
//  History:    13-Sep-01 EricB created
//
//-----------------------------------------------------------------------------
#ifndef _pch_h
#define _pch_h

#include <burnslib.hpp>
#include <atlbase.h>
extern CComModule _Module;
#define LookupPrivilegeValue LookupPrivilegeValueW
#include <atlcom.h> // CComPtr et al
#undef LookupPrivilegeValue
#include <commctrl.h>
#include <msxml.h>

#include "strings.h"

extern Popup popup;

#pragma hdrstop

#endif // _pch_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\roleobj.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       RoleObj.cxx
//
//  History:    15-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#ifndef ROLEOBJ_H_INCLUDED
#define ROLEOBJ_H_INCLUDED

#include "ServiceObj.h"

class RoleObject;

typedef std::list<RoleObject*, Burnslib::Heap::Allocator<RoleObject*> > ROLELIST;

class RoleObject
{
public:
    RoleObject(void);
    RoleObject(String& xRoleName);
    virtual ~RoleObject();

private:

protected:
    SERVICELIST     servicesList;
    bool            selected;
    bool            satisfiable;
    String          roleName;
    String          _strRoleDisplayName;
    String          roleDescription;

public:
    bool addService(ServiceObject* pobj);
    bool removeService(String str);
    ServiceObject* findService(String str);
    DWORD getServiceCount();
    void setSelected(bool fSelected) {selected = fSelected;};
    void setSatisfiable(bool fSatistfiable) {satisfiable = fSatistfiable;};
    void setDescritption(String& desStr) {roleDescription = desStr;};
    HRESULT InitFromXmlNode(IXMLDOMNode * pRoleNode);
    HRESULT SetLocalizedNames(IXMLDOMNode * pDoc);
    PCWSTR getName(void) {return roleName.c_str();};
    PCWSTR getDisplayName(void);
};

#endif //ROLEOBJ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by secwiz.rc
//
#define IDI_SECWIZ_ICON                 1
#define IDS_WIZARD_TITLE                2
#define IDD_SSRWIZ_INTRO                3
#define IDB_BANNER16                    4
#define IDB_BANNER256                   5
#define IDB_WATERMARK16                 6
#define IDB_WATERMARK256                7
#define IDS_PROP_SHEET_FAILED           8
#define IDS_COMMAND_LINE_HELP           9
#define IDS_WELCOME_PAGE_TITLE          10
#define IDS_WELCOME_PAGE_SUBTITLE       11
#define IDS_BIG_BOLD_FONT_NAME          12
#define IDS_BIG_BOLD_FONT_SIZE          13
#define IDS_FINISH_PAGE_TITLE           14
#define IDS_FINISH_PAGE_SUBTITLE        15
#define IDS_SELECTCFG_NAME_PAGE_TITLE   16
#define IDS_SELECTCFG_NAME_PAGE_SUBTITLE 17
#define IDS_INVALID_EXISTING_INPUT_FILE 18
#define IDS_INVALID_INPUT_FILE          19
#define IDS_ROLLBACK_FAILED             20
#define IDS_SERVER_ROLE_SEL_PAGE_TITLE  21
#define IDS_SERVER_ROLE_SEL_PAGE_SUBTITLE   22
#define IDS_INPUT_FILE_NOT_FOUND        23
#define IDS_SECURITY_LEVEL_PAGE_TITLE   24
#define IDS_SECURITY_LEVEL_PAGE_SUBTITLE    25
#define IDS_PRE_PROCESSING_PAGE_TITLE   26
#define IDS_PRE_PROCESSING_PAGE_SUBTITLE    27
#define IDS_DESCRIPTION_PROCESS         28
#define IDS_RESULT_PROCESS              29
#define IDS_CLIENT_ROLE_SEL_PAGE_TITLE  30
#define IDS_CLIENT_ROLE_SEL_PAGE_SUBTITLE   31
#define IDS_ADDITIONAL_FUNC_SEL_PAGE_TITLE  32
#define IDS_ADDITIONAL_FUNC_SEL_PAGE_SUBTITLE   33
#define IDD_SERVICEDISABLE_METHOD_PAGE_TITLE    34
#define IDD_SERVICEDISABLE_METHOD_PAGE_SUBTITLE 35
#define IDD_WELCOME                     101
#define IDI_BULLET                      102
#define IDD_FINISH                      103
#define IDD_SELECTCFG_NAME              104
#define IDD_SERVER_ROLE_SEL             105
#define IDD_SECURITY_LEVEL              106
#define IDD_PRE_PROCESSING              107
#define IDD_CLIENT_ROLE_SEL             108
#define IDD_ADDITIONAL_ROLE_SEL         109
#define IDD_ADDITIONAL_FUNC_SEL         110
#define IDD_SERVICEDISABLE_METHOD       111
#define IDD_SERVICE_ENABLED             112
#define IDC_BIG_BOLD_TITLE              1000
#define IDC_NEW_CFG_RADIO               1001
#define IDC_EDIT_CFG_RADIO              1002
#define IDC_EXISTING_CFG_EDIT           1003
#define IDC_BROWSE_FOR_CFG_BTN          1004
#define IDC_ROLLBACK_CFG_RADIO          1005
#define IDC_ADDITIONALE_ROLE            1006
#define IDC_CHECKBOX                    1007
#define IDC_MAXIMUM_LEVEL               1008
#define IDC_TYPICAL_LEVEL               1009
#define IDC_DES_PROCESS                 1010
#define IDC_PROGRESS_PROCESS            1011
#define IDC_RESULT_PROCESS              1012
#define IDC_IMPLICIT_METHOD             1013
#define IDC_EXPLICIT_METHOD             1014
#define IDC_ENABLED_SERVICES            1015
#define IDC_DISABLED_SERVICES           1016
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\roleobj.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       RoleObj.cxx
//
//  History:    15-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#include "pch.h"
#include "RoleObj.h"
#include "misc.h"

////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
RoleObject::RoleObject(String& xmlroleName) :
   satisfiable(false),
   selected(false)
{
   roleName = xmlroleName;
}

RoleObject::RoleObject(void) :
   satisfiable(false),
   selected(false)
{
}

////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
RoleObject::~RoleObject()
{
   LOG_DTOR(RoleObject);

   SERVICELIST::iterator i;
   
   for(i=servicesList.begin(); i!=servicesList.end(); i++)
   {
      servicesList.erase(i);
   }
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
bool RoleObject::addService(ServiceObject* pobj)
{
   servicesList.push_back(pobj);
   return true;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
bool RoleObject::removeService(String str)
{
   SERVICELIST::iterator i = servicesList.begin();
   for(i=servicesList.begin(); i!=servicesList.end(); i++)
   {
      if(((ServiceObject*)(*i))->serviceName.icompare(str) == 0)
      {
         servicesList.erase(i);
         return true;
      }
   }
   return false;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
ServiceObject* RoleObject::findService(String str)
{
   SERVICELIST::iterator i = servicesList.begin();
   for(i=servicesList.begin(); i!=servicesList.end(); i++)
   {
      if(((ServiceObject*)(*i))->serviceName.icompare(str) == 0)
      {
         return (*i);
      }
   }
   return NULL;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD RoleObject::getServiceCount()
{
   return (DWORD)servicesList.size();
}

//+----------------------------------------------------------------------------
//
// Method:  RoleObject::getDisplayName
//
// If set, return the display name. Otherwise return the internal name.
//
//-----------------------------------------------------------------------------
PCWSTR
RoleObject::getDisplayName(void)
{
   return _strRoleDisplayName.empty() ?
      roleName.c_str() : _strRoleDisplayName.c_str();
}

//+----------------------------------------------------------------------------
//
// Method:  RoleObject::InitFromXmlNode
//
// Initialize the object from its main.xml node.
//
//-----------------------------------------------------------------------------
HRESULT
RoleObject::InitFromXmlNode(IXMLDOMNode * pRoleNode)
{
   LOG_FUNCTION(RoleObject::InitFromXmlNode);
   HRESULT hr = S_OK;

   hr = GetNodeText(pRoleNode, g_wzName, roleName);

   if (FAILED(hr) || S_FALSE == hr)
   {
      LOG(String::format(L"Getting role name failed with error %1!x!", hr));
      return hr;
   }

   LOG(String::format(L"Role name is '%1'", roleName.c_str()));

   return hr;
}

//+----------------------------------------------------------------------------
//
// Method:  RoleObject::InitFromXmlNode
//
// Initialize the object from its main.xml node.
//
//-----------------------------------------------------------------------------
HRESULT
RoleObject::SetLocalizedNames(IXMLDOMNode * pSSRNode)
{
   LOG_FUNCTION(RoleObject::SetLocalizedNames);
   if (roleName.empty())
   {
      ASSERT(FALSE);
      return E_FAIL;
   }
   HRESULT hr = S_OK;
   IXMLDOMNode * pRoleLocNode = NULL;

   hr = pSSRNode->selectSingleNode(CComBSTR(g_wzRoleLocalization), &pRoleLocNode);

   if (FAILED(hr))
   {
      LOG(String::format(L"Select of RoleLocalization node failed with error %1!x!", hr));
      return hr;
   }

   ASSERT(pRoleLocNode);
   IXMLDOMNodeList * pRoleList = NULL;

   hr = pRoleLocNode->selectNodes(CComBSTR(g_wzRole), &pRoleList);

   pRoleLocNode->Release();

   if (FAILED(hr))
   {
      LOG(String::format(L"Select of RoleLocalization child nodes failed with error %1!x!", hr));
      return hr;
   }

   ASSERT(pRoleList);
   long nRoleNodes = 0;

   hr = pRoleList->get_length(&nRoleNodes);

   if (FAILED(hr))
   {
      LOG(String::format(L"Getting the size of the RoleLocalization Node list failed with error %1!x!", hr));
      return hr;
   }

   IXMLDOMNode * pRole;

   for (long i = 0; i < nRoleNodes; i++)
   {
      pRole = NULL;

      hr = pRoleList->get_item(i, &pRole);

      if (FAILED(hr))
      {
         LOG(String::format(L"Getting a RoleLocalization Node list item failed with error %1!x!", hr));
         pRoleList->Release();
         return hr;
      }

      ASSERT(pRole);
      String strName;

      hr = GetNodeText(pRole, g_wzName, strName);

      if (FAILED(hr))
      {
         LOG(String::format(L"Getting a RoleLocalization Node list item name failed with error %1!x!", hr));
         pRoleList->Release();
         return hr;
      }

      if (strName.icompare(roleName) == 0)
      {
         // Found the right one.
         //
         GetNodeText(pRole, g_wzDisplayName, _strRoleDisplayName);
         GetNodeText(pRole, g_wzDescription, roleDescription);
         pRole->Release();
         pRoleList->Release();
         return S_OK;
      }

      pRole->Release();
   }

   pRoleList->Release();

   LOG(String::format(L"Did not find the RoleLocalization Node item for role %1", roleName.c_str()));

   return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\selectinputcfgpage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       SelectInputCfgPage.h
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef SELECTINPUTCFGPAGE_H_INCLUDED
#define SELECTINPUTCFGPAGE_H_INCLUDED

#include "page.h"

class SelectInputCfgPage : public SecCfgWizardPage
{
   public:

   SelectInputCfgPage();

   protected:

   virtual ~SelectInputCfgPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   SelectInputCfgPage(const SelectInputCfgPage&);
   const SelectInputCfgPage& operator=(const SelectInputCfgPage&);
};

#endif   // SELECTINPUTCFGPAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\selectinputcfgpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       SelectInputCfgPage.cxx
//
//  Contents:   Select Input Configuration Page.
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "SelectInputCfgPage.h"

SelectInputCfgPage::SelectInputCfgPage()
   :
   SecCfgWizardPage(
      IDD_SELECTCFG_NAME,
      IDS_SELECTCFG_NAME_PAGE_TITLE,
      IDS_SELECTCFG_NAME_PAGE_SUBTITLE)
{
   LOG_CTOR(SelectInputCfgPage);
}



SelectInputCfgPage::~SelectInputCfgPage()
{
   LOG_DTOR(SelectInputCfgPage);
}



void
SelectInputCfgPage::OnInit()
{
   LOG_FUNCTION(SelectInputCfgPage::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_EXISTING_CFG_EDIT), MAX_PATH);

   Win::CheckDlgButton(hwnd, IDC_NEW_CFG_RADIO, BST_CHECKED);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_EXISTING_CFG_EDIT), false);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE_FOR_CFG_BTN), false);
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next = PSWIZB_NEXT;

   if (Win::IsDlgButtonChecked(dialog, IDC_EDIT_CFG_RADIO))
   {
      next = !Win::GetTrimmedDlgItemText(dialog, IDC_EXISTING_CFG_EDIT).empty()
         ?  PSWIZB_NEXT : 0;
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
SelectInputCfgPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(SelectInputCfgPage::OnCommand);

   State& state = State::GetInstance();

   switch (controlIDFrom)
   {
      case IDC_EDIT_CFG_RADIO:
      {
         if (code == BN_CLICKED)
         {
            Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_EXISTING_CFG_EDIT), true);
            Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE_FOR_CFG_BTN), true);
            enable(hwnd);
            state.SetInputType(State::OpenExisting);
         }
         break;
      }
      case IDC_NEW_CFG_RADIO:
      case IDC_ROLLBACK_CFG_RADIO:
      {
         if (code == BN_CLICKED)
         {
            Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_EXISTING_CFG_EDIT), false);
            Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE_FOR_CFG_BTN), false);
            enable(hwnd);
            state.SetInputType(controlIDFrom == IDC_NEW_CFG_RADIO ?
               State::CreateNew : State::Rollback);
         }
         break;
      }
      case IDC_EXISTING_CFG_EDIT:
      {
         if (code == EN_CHANGE)
         {
            enable(hwnd);
         }
         break;
      }
      case IDC_BROWSE_FOR_CFG_BTN:
      {
         if (code == BN_CLICKED)
         {
            String str(L"placeholder for file open dialog");
            popup.Info(hwnd, str);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
SelectInputCfgPage::OnSetActive()
{
   LOG_FUNCTION(SelectInputCfgPage::OnSetActive);
   
   enable(hwnd);

   return true;
}


   
int
SelectInputCfgPage::Validate()
{
   LOG_FUNCTION(SelectInputCfgPage::Validate);

   int nextPage = IDD_SECURITY_LEVEL;//IDD_SERVER_ROLE_SEL; //IDD_FINISH; 

   State& state = State::GetInstance();

   HRESULT hr = S_OK;

   switch (state.GetInputType())
   {
   case State::OpenExisting:
      state.SetInputFileName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_EXISTING_CFG_EDIT));
      hr = state.ParseInputFile();
      if (FAILED(hr))
      {
         popup.Error(hwnd,
            hr, IDS_INVALID_EXISTING_INPUT_FILE);
         nextPage = -1;
      }
      break;

   case State::CreateNew:
      hr = state.ParseInputFile();
      if (FAILED(hr))
      {
         if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
         {
            popup.Gripe(hwnd,
               String::load(IDS_INPUT_FILE_NOT_FOUND, hResourceModuleHandle));
         }
         else
         {
            popup.Error(hwnd, hr, IDS_INVALID_INPUT_FILE);
         }
         // nextPage = ?; now what?
      }
      break;

   case State::Rollback:
      hr = state.DoRollback();
      if (FAILED(hr))
      {
         popup.Error(hwnd, hr, IDS_ROLLBACK_FAILED);
         // nextPage = ?; now what?
      }
      break;

   default:
      ASSERT(false);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\secwiz.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       SecWiz.cxx
//
//  Contents:   Security Configuration wizard.
//
//  History:    13-Sep-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "WelcomePage.h"
#include "SelectInputCfgPage.h"
#include "finish.h"
#include "ServerRoleSelPage.h"
#include "otherpages.h"
#include "ClientRoleSelPage.h"
#include "AdditionalFuncPage.h"

HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

const wchar_t* RUNTIME_NAME = L"SecWiz";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;


// a system modal popup thingy
Popup popup(IDS_WIZARD_TITLE, true);


BOOL RegisterCheckListWndClass(HINSTANCE hInstance); //in chklist.cxx

// these are the valid exit codes returned from the ssrwiz.exe process

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,
};


ExitCode
RunWizard()
{
   LOG_FUNCTION(RunWizard);

   // this is necessary to use the hotlink-style static text control.
// // 
// //    BOOL b = LinkWindow_RegisterClass();
// //    ASSERT(b);

   Wizard wiz(
      IDS_WIZARD_TITLE,
      IDB_BANNER16,
      IDB_BANNER256,
      IDB_WATERMARK16,
      IDB_WATERMARK256);

   // Welcome must be first
   
   wiz.AddPage(new WelcomePage());

   // These are not in any particular order...

   wiz.AddPage(new SelectInputCfgPage());
   wiz.AddPage(new FinishPage());
   wiz.AddPage(new SecurityLevelPage());
   wiz.AddPage(new PreProcessPage());
   wiz.AddPage(new ServerRoleSelPage());
   wiz.AddPage(new ClientRoleSelPage());
   wiz.AddPage(new AdditionalFuncPage());
   wiz.AddPage(new ServiceDisableMethodPage());

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   switch (wiz.ModalExecute(Win::GetDesktopWindow()))
   {
      case -1:
      {
         popup.Error(
            Win::GetDesktopWindow(),
            E_FAIL,
            IDS_PROP_SHEET_FAILED);
         break;
      }
      default:
      {
         // do nothing.
         break;
      }
   }

   return exitCode;
}


void
ShowCommandLineHelp()
{
   // CODEWORK: replace this with WinHelp, someday

   popup.MessageBox(Win::GetDesktopWindow(), IDS_COMMAND_LINE_HELP, MB_OK);
}



int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   HRESULT hr = S_OK;

   RegisterCheckListWndClass(hInstance);

   {
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      INITCOMMONCONTROLSEX icc;
      icc.dwSize = sizeof(icc);      
      icc.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

      BOOL init = ::InitCommonControlsEx(&icc);
      ASSERT(init);

      State::Init();

      if (State::GetInstance().NeedsCommandLineHelp())
      {
         ShowCommandLineHelp();
      }
      else
      {
         exitCode = RunWizard();
      }

      State::Destroy();
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serverroleselpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServerRoleSelPage.cxx
//
//  Contents:   Select Server Role Configuration Page.
//
//  History:    04-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "ServerRoleSelPage.h"
#include "chklist.h"
#include "otherpages.h"

ServerRoleSelPage::ServerRoleSelPage()
   :
   SecCfgWizardPage(
      IDD_SERVER_ROLE_SEL,
      IDS_SERVER_ROLE_SEL_PAGE_TITLE,
      IDS_SERVER_ROLE_SEL_PAGE_SUBTITLE)
{
   LOG_CTOR(ServerRoleSelPage);
}



ServerRoleSelPage::~ServerRoleSelPage()
{
   LOG_DTOR(ServerRoleSelPage);
}



void
ServerRoleSelPage::OnInit()
{
   LOG_FUNCTION(ServerRoleSelPage::OnInit);

}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   /*int next = PSWIZB_NEXT;

   if (Win::IsDlgButtonChecked(dialog, IDC_EDIT_CFG_RADIO))
   {
      next = !Win::GetTrimmedDlgItemText(dialog, IDC_EXISTING_CFG_EDIT).empty()
         ?  PSWIZB_NEXT : 0;
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);*/
}



bool
ServerRoleSelPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code)
{
   LOG_FUNCTION(ServerRoleSelPage::OnCommand);

   // State& state = State::GetInstance();

   switch (controlIDFrom)
   {
      case IDC_ADDITIONALE_ROLE:
      {
         if (code == BN_CLICKED)
         {
             AdditionalRolesPage* pDlg = new AdditionalRolesPage();
             if( IDOK == pDlg->ModalExecute(hwnd) )
             {
                 ;
             }
             return true;
         }
         break;
      }
   }

   return false;
}



bool
ServerRoleSelPage::OnSetActive()
{
   LOG_FUNCTION(ServerRoleSelPage::OnSetActive);
   
   enable(hwnd);

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      return FALSE;
   }
   Win::SendMessage(hWnd, CLM_RESETCONTENT,0,0);

   State& state = State::GetInstance();

   //Add Roles

   HRESULT hr = S_OK;
   RoleObject * pRole;

   for (long i = 0; i < state.GetNumRoles(); i++)
   {
      pRole = NULL;

      hr = state.GetRole(i, &pRole);

      if (FAILED(hr) || !pRole)
      {
         return true;
      }

      int nIndex = (int) Win::SendMessage(hWnd,
                                          CLM_ADDITEM,
                                          (WPARAM)pRole->getDisplayName(),
                                          (LPARAM)0);
      if (nIndex != -1)
      {
         BOOL bSet;
   
         //First column setting
         bSet = CLST_CHECKED;
         Win::SendMessage(hWnd,
                          CLM_SETSTATE,
                          MAKELONG(nIndex,1),
                          bSet ? CLST_CHECKED : CLST_UNCHECKED);
      
         // Second column setting if there is
         //bSet = CLST_UNCHECKED;
         //Win::SendMessage(hWnd,
         //                 CLM_SETSTATE,
         //                 MAKELONG(nIndex,2),
         //                 CLST_DISABLED | (bSet ? CLST_CHECKED : CLST_UNCHECKED));
      }
      // role objects should be saved as item data rather than being deleted here:
      delete pRole;
   }

   return true;
}


   
int
ServerRoleSelPage::Validate()
{
   LOG_FUNCTION(ServerRoleSelPage::Validate);

   int nextPage = IDD_CLIENT_ROLE_SEL; //IDD_FINISH; 

   // State& state = State::GetInstance();

   // HRESULT hr = S_OK;
   DWORD dw = 0;

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      ;//error
   }
   else
   {
      int nItems = (int) Win::SendMessage(hWnd,CLM_GETITEMCOUNT,0,0);
      for (int i=0;i<nItems;i++) 
      {
         dw = (DWORD)Win::SendMessage(hWnd,CLM_GETSTATE,MAKELONG(i,1),0);
         if (CLST_CHECKED == dw)
         {
            ;//selected
         }
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serverroleselpage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServerRoleSelPage.h
//
//  History:    04-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------

#ifndef SERVERROLESELPAGE_H_INCLUDED
#define SERVERROLESELPAGE_H_INCLUDED

#include "page.h"

class ServerRoleSelPage : public SecCfgWizardPage
{
   public:

   ServerRoleSelPage();

   protected:

   virtual ~ServerRoleSelPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ServerRoleSelPage(const ServerRoleSelPage&);
   const ServerRoleSelPage& operator=(const ServerRoleSelPage&);
};

#endif   // SERVERROLESELPAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serviceobj.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServiceObj.cxx
//
//  History:    12-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#include "pch.h"
#include "ServiceObj.h"

////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
ServiceObject::ServiceObject(String& xmlserviceName,
                             bool xmlinstalled, 
                             DWORD xmlstartupCurrent,
                             DWORD xmlstartupDefault) :
    _fRequired(false),
    _fSelect(false),
    _fInstalled(false)
{
   installed = xmlinstalled;
   startupCurrent = xmlstartupCurrent;
   startupDefault = xmlstartupDefault;
   serviceName = xmlserviceName;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
ServiceObject::~ServiceObject()
{
   LOG_DTOR(ServiceObject);

   SERVICELIST::iterator i;
   
   for(i=dependenceList.begin(); i!=dependenceList.end(); i++)
   {
       dependenceList.erase(i);
   }
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
bool ServiceObject::addDependent(ServiceObject* pobj)
{
   dependenceList.push_back(pobj);
   return true;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
bool ServiceObject::removeDependent(String str)
{
   SERVICELIST::iterator i = dependenceList.begin();
   for(i=dependenceList.begin(); i!=dependenceList.end(); i++)
   {
      if(((ServiceObject*)(*i))->serviceName.icompare(str) == 0)
      {
         dependenceList.erase(i);
         return true;
      }
   }
   return false;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
ServiceObject* ServiceObject::findDependent(String str)
{
   SERVICELIST::iterator i = dependenceList.begin();
   for(i=dependenceList.begin(); i!=dependenceList.end(); i++)
   {
      if(((ServiceObject*)(*i))->serviceName.icompare(str) == 0)
      {
         return (*i);
      }
   }
   return NULL;
}
////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD ServiceObject::getDependentCount()
{
   return (DWORD)dependenceList.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serviceobj.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServiceObj.h
//
//  History:    12-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#ifndef SERVICEOBJ_H_INCLUDED
#define SERVICEOBJ_H_INCLUDED

class ServiceObject;

typedef std::list<ServiceObject*, Burnslib::Heap::Allocator<ServiceObject*> > SERVICELIST;

class ServiceObject
{
public:
    ServiceObject(String& xmlserviceName,
                  bool xmlinstalled = false, 
                  DWORD xmlstartupCurrent = 0,
                  DWORD xmlstartupDefault = 0);

    virtual ~ServiceObject();

private:

protected:
    SERVICELIST     dependenceList;
    bool            installed;
    DWORD           startupCurrent;
    DWORD           startupDefault;
    String          _strDescription;
    bool            _fRequired;
    bool            _fSelect;
    bool            _fInstalled;

public:
    String          serviceName;

    bool addDependent(ServiceObject* pobj);
    bool removeDependent(String str);
    ServiceObject* findDependent(String str);
    DWORD getDependentCount();
};

#endif //SERVICEOBJ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serviceselpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServiceSelPage.cxx
//
//  History:    30-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "chklist.h"
#include "ServiceSelPage.h"

//////////////////////////////////////////////////////////////////////////////////
// Service Enabled Page
//
//////////////////////////////////////////////////////////////////////////////////
ServiceEnabledPage::ServiceEnabledPage()
   :
   Dialog(IDD_SERVICE_ENABLED, 0) //no help map
{
   LOG_CTOR(ServiceEnabledPage);
}



ServiceEnabledPage::~ServiceEnabledPage()
{
   LOG_DTOR(ServiceEnabledPage);
}

void
ServiceEnabledPage::OnInit()
{
   LOG_FUNCTION(ServiceEnabledPage::OnInit);

   HWND hWnd = Win::GetDlgItem(hwnd, IDC_CHECKBOX);
   if (!hWnd) {
      return;
   }
   Win::SendMessage(hWnd, CLM_RESETCONTENT,0,0);
   //get enabled services and add them into the checklist box.

   /*HRESULT hr = S_OK;
   ServiceObject * pService;

   int nIndex = (int) Win::SendMessage(hWnd,
                                       CLM_ADDITEM,
                                       (WPARAM)pService->serviceName,
                                       (LPARAM)0);
   if (nIndex != -1)
   {
      BOOL bSet;
   
      //First column setting
      bSet = CLST_CHECKED;
      Win::SendMessage(hWnd,
                       CLM_SETSTATE,
                       MAKELONG(nIndex,1),
                       bSet ? CLST_CHECKED : CLST_UNCHECKED);
      
   }*/
}

bool
ServiceEnabledPage::OnCommand(
   HWND         /*windowFrom*/,
   unsigned     controlIDFrom,
   unsigned     /*code*/)
{
   LOG_FUNCTION(ServiceEnabledPage::OnCommand);

   // State& state = State::GetInstance();

   switch (controlIDFrom)
   {
   case IDOK:
       Win::EndDialog(hwnd, IDOK);
       return true;
   case IDCANCEL:
       Win::EndDialog(hwnd, IDCANCEL);
       return true;
   default:
       break;
   }

   return false;
}

bool
ServiceEnabledPage::OnMessage(
      UINT     message,
      WPARAM   /*wparam*/,
      LPARAM   /*lparam*/)
{
   LOG_FUNCTION(ServiceEnabledPage::OnMessage);

   switch (message)
   {
      case WM_COMMAND:
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\state.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       state.h
//
//  Contents:   Wizard state object declaration.
//
//  History:    4-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef STATE_H_INCLUDED
#define STATE_H_INCLUDED

#include "RoleObj.h"
#include "ServiceObj.h"

class State
{
   public:

   // call from WinMain to init the global instance

   static
   void
   Init();

   // call from WinMain to delete the global instance

   static
   void
   Destroy();

   static
   State&
   GetInstance();

   bool
   NeedsCommandLineHelp() const {return _fNeedsCommandLineHelp;};

   void
   SetInputFileName(String & FileName);

   PCWSTR
   GetInputFileName(void) const {return _strInputFile.c_str();};

   enum InputType
   {
      CreateNew,
      OpenExisting,
      Rollback
   };

   void
   SetInputType(InputType type) {_InputType = type;};

   InputType
   GetInputType(void) const {return _InputType;};

   HRESULT
   ParseInputFile(void);

   long
   GetNumRoles(void) const {return _NumRoles;};

   HRESULT
   GetRole(long index, RoleObject ** ppRole);

   HRESULT
   DoRollback(void);

   private:

   // can only be created/destroyed by Init/Destroy

   State();

   ~State() {};

   bool                             _fNeedsCommandLineHelp;
   String                           _strInputFile;
   InputType                        _InputType;
   SmartInterface<IXMLDOMNode>      _siXmlMainNode;
   SmartInterface<IXMLDOMNodeList>  _siXmlRoleNodeList;
   long                             _NumRoles;

   // not defined: no copying.

   State(const State&);
   State& operator=(const State&);
};



#endif   // STATE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\state.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       state.cxx
//
//  Contents:   Wizard state object definition.
//
//  History:    4-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"

static State* stateInstance;

State::State() :
   _fNeedsCommandLineHelp(false),
   _InputType(CreateNew),
   _strInputFile(),
   _NumRoles(0)
{
   RegistryKey keyDefFile;
   if (SUCCEEDED(keyDefFile.Open(HKEY_LOCAL_MACHINE,
                                 L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SSR")))
   {
      if (SUCCEEDED(keyDefFile.GetValue(L"MainXml", _strInputFile)))
      {
         LOG(String::format(L"Main XML input file is %1", _strInputFile.c_str()));
      }
   }
}

void
State::Init()
{
   ASSERT(!stateInstance);

   stateInstance = new State;
}

void
State::Destroy()
{
   delete stateInstance;
};

State&
State::GetInstance()
{
   ASSERT(stateInstance);

   return *stateInstance;
}
   
void
State::SetInputFileName(String & strName)
{
   ASSERT(!strName.empty());
   _strInputFile = strName;
}

//+----------------------------------------------------------------------------
//
// Method:  State::ParseInputFile
//
// Loads the main.xml input file and parses it.
//
//-----------------------------------------------------------------------------
HRESULT
State::ParseInputFile(void)
{
   LOG_FUNCTION(State::ParseInputFile);
   HRESULT hr = S_OK;
   SmartInterface<IXMLDOMDocument> siXmlMain;

   hr = siXmlMain.AcquireViaCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_SERVER);

   if (FAILED(hr))
   {
      LOG(String::format(L"Creation of CLSID_DOMDocument failed with error %1!x!", hr));
      return hr;
   }

   VARIANT varInput;
   AutoBstr bstr(_strInputFile);

   VariantInit(&varInput);

   varInput.bstrVal = bstr;
   varInput.vt = VT_BSTR;

   VARIANT_BOOL fSuccess;

   hr = siXmlMain->load(varInput, &fSuccess);

   if (fSuccess == VARIANT_FALSE)
   {
      LOG(String::format(L"Load of %1 failed",
          _strInputFile.c_str()));
      return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
   }

   if (FAILED(hr))
   {
      LOG(String::format(L"Load of %1 failed with error %2!x!",
          _strInputFile.c_str(), hr));
      return hr;
   }

   LOG(String::format(L"Load of %1 succeeded", _strInputFile.c_str()));

   IXMLDOMNode * pSSRNode = NULL, * pRolesNode = NULL;

   hr = siXmlMain->selectSingleNode(CComBSTR(g_wzSSRUIData), &pSSRNode);

   if (FAILED(hr) || !pSSRNode)
   {
      LOG(String::format(L"Select of SSRUIData Node in %1 failed with error %2!x!",
          _strInputFile.c_str(), hr));
      return hr;
   }

   _siXmlMainNode.Acquire(pSSRNode);

   hr = pSSRNode->selectSingleNode(CComBSTR(g_wzRoles), &pRolesNode);

   if (FAILED(hr) || !pRolesNode)
   {
      LOG(String::format(L"Select of Roles Node in %1 failed with error %2!x!",
          _strInputFile.c_str(), hr));
      return hr;
   }

   IXMLDOMNodeList * pList = NULL;

   hr = pRolesNode->selectNodes(CComBSTR(g_wzRole), &pList);

   if (FAILED(hr))
   {
      LOG(String::format(L"Search for Role Nodes in %1 failed with error %2!x!",
          _strInputFile.c_str(), hr));
      return hr;
   }

   _siXmlRoleNodeList.Acquire(pList);

   pRolesNode->Release();

   hr = _siXmlRoleNodeList->get_length(&_NumRoles);

   if (FAILED(hr))
   {
      LOG(String::format(L"Calling get_length on the Role Node list failed with error %1!x!",
          hr));
      return hr;
   }

   LOG(String::format(L"Number of Role nodes is %1!d!", _NumRoles));

   return hr;
}

//+----------------------------------------------------------------------------
//
// Method:  State::GetRole
//
// Returns the role object for the indicated role.
//
//-----------------------------------------------------------------------------
HRESULT
State::GetRole(long index, RoleObject ** ppRole)
{
   LOG_FUNCTION(State::GetRole);

   if (GetNumRoles() == 0)
   {
      ASSERT(false);
      return E_FAIL;
   }
   if (GetNumRoles() <= index || IsBadWritePtr(ppRole, sizeof(RoleObject *)))
   {
      ASSERT(false);
      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;
   IXMLDOMNode * pRoleNode = NULL;

   hr = _siXmlRoleNodeList->get_item(index, &pRoleNode);

   if (FAILED(hr))
   {
      LOG(String::format(L"Getting role node %1!d! failed with error %1!x!",
          index, hr));
      return hr;
   }

   *ppRole = new RoleObject;

   if (!*ppRole)
   {
      pRoleNode->Release();
      return E_OUTOFMEMORY;
   }

   hr = (*ppRole)->InitFromXmlNode(pRoleNode);

   pRoleNode->Release();

   if (SUCCEEDED(hr))
   {
      hr = (*ppRole)->SetLocalizedNames(_siXmlMainNode);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
// Method:  State::DoRollback
//
// 
//
//-----------------------------------------------------------------------------
HRESULT
State::DoRollback(void)
{
   LOG_FUNCTION(State::DoRollback);
   HRESULT hr = S_OK;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\strings.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       strings.cxx
//
//  Contents:   Security Configuration wizard.
//
//  History:    16-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

PCWSTR g_wzSSRUIData = L"SSRUIData";
PCWSTR g_wzRole = L"Role";
PCWSTR g_wzRoles = L"Roles";
PCWSTR g_wzRoleLocalization = L"RoleLocalization";
PCWSTR g_wzName = L"Name";
PCWSTR g_wzDisplayName = L"DisplayName";
PCWSTR g_wzDescription = L"Description";
PCWSTR g_wzType = L"Type";
PCWSTR g_wzSelected = L"Selected";
PCWSTR g_wzServices = L"Services";
PCWSTR g_wzService = L"Service";
PCWSTR g_wzRequired = L"Required";
PCWSTR g_wzSelect = L"Select";
PCWSTR g_wzSatisfiable = L"Satisfiable";
PCWSTR g_wzInstalled = L"Installed";
PCWSTR g_wzStartupCurrent = L"Startup_Current";
PCWSTR g_wzStartupDefault = L"Startup_Default";
PCWSTR g_wzDependencies = L"Dependencies";
PCWSTR g_wzAncestors = L"Ancestors";
PCWSTR g_wzProgeny = L"Progeny";
PCWSTR g_wzTrue = L"TRUE";
PCWSTR g_wzIndependent = L"Independent";
PCWSTR g_wzServer = L"Server";
PCWSTR g_wzClient = L"Client";
PCWSTR g_wzSecurityLevel = L"SecurityLevel";
PCWSTR g_wzQuestions = L"Questions";
PCWSTR g_wzQuestion = L"Question";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\serviceselpage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       ServiceSelPage.h
//
//  History:    30-Oct-01 Yanggao created
//
//-----------------------------------------------------------------------------
#ifndef SERVICESELPAGE_H_INCLUDED
#define SERVICESELPAGE_H_INCLUDED

#include "page.h"

class ServiceEnabledPage : public Dialog
{
   public:

   ServiceEnabledPage();

   protected:

   virtual ~ServiceEnabledPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   virtual
   void
   OnInit();

   private:

   // not defined; no copying allowed

   ServiceEnabledPage(const ServiceEnabledPage&);
   const ServiceEnabledPage& operator=(const ServiceEnabledPage&);
};
#endif   // SERVICESELPAGE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\strings.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       strings.h
//
//  Contents:   Non-localized strings.
//
//  History:    16-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef STRINGS_H_GUARD
#define STRINGS_H_GUARD

extern PCWSTR g_wzSSRUIData;
extern PCWSTR g_wzRole;
extern PCWSTR g_wzRoles;
extern PCWSTR g_wzRoleLocalization;
extern PCWSTR g_wzName;
extern PCWSTR g_wzDisplayName;
extern PCWSTR g_wzDescription;
extern PCWSTR g_wzType;
extern PCWSTR g_wzSelected;
extern PCWSTR g_wzServices;
extern PCWSTR g_wzService;
extern PCWSTR g_wzRequired;
extern PCWSTR g_wzSelect;
extern PCWSTR g_wzSatisfiable; 
extern PCWSTR g_wzInstalled;
extern PCWSTR g_wzStartupCurrent;
extern PCWSTR g_wzStartupDefault;
extern PCWSTR g_wzDependencies;
extern PCWSTR g_wzAncestors;
extern PCWSTR g_wzProgeny;
extern PCWSTR g_wzTrue;
extern PCWSTR g_wzIndependent;
extern PCWSTR g_wzServer;
extern PCWSTR g_wzClient;
extern PCWSTR g_wzSecurityLevel;
extern PCWSTR g_wzQuestions;
extern PCWSTR g_wzQuestion;

#endif // STRINGS_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\welcomepage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       WelcomePage.cxx
//
//  Contents:   Welcome Page.
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "misc.h"
#include "state.h"
#include "WelcomePage.h"

WelcomePage::WelcomePage()
   :
   SecCfgWizardPage(
      IDD_WELCOME,
      IDS_WELCOME_PAGE_TITLE,
      IDS_WELCOME_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(WelcomePage);
}



WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}



void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));
}



bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);

   return true;
}



int
WelcomePage::Validate()
{
   LOG_FUNCTION(WelcomePage::Validate);

   return IDD_SELECTCFG_NAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\finpic.cpp ===
// FinPic.cpp : implementation file
//

#include "stdafx.h"
#include "lcwiz.h"
#include "FinPic.h"
#include "transbmp.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture

CFinalPicture::CFinalPicture()
{
}

CFinalPicture::~CFinalPicture()
{
}


BEGIN_MESSAGE_MAP(CFinalPicture, CStatic)
	//{{AFX_MSG_MAP(CFinalPicture)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture message handlers

void CFinalPicture::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	CTransBmp transbmp;

	transbmp.LoadBitmap(IDB_END_FLAG);
	transbmp.DrawTrans(&dc, 0, 0);

	// Do not call CStatic::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\ssrui\welcomepage.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Secure Server Roles Security Configuration Wizard
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       WelcomePage.h
//
//  History:    2-Oct-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef WELCOMEPAGE_HPP_INCLUDED
#define WELCOMEPAGE_HPP_INCLUDED

#include "page.h"

class WelcomePage : public SecCfgWizardPage
{
   public:

   WelcomePage();

   protected:

   virtual ~WelcomePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   WelcomePage(const WelcomePage&);
   const WelcomePage& operator=(const WelcomePage&);
};

#endif   // WELCOMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwiz.h ===
// LCWiz.h : main header file for the LCWIZ application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __LCWIZ_H__
#define __LCWIZ_H__

#include <winreg.h>
#include "resource.h"		// main symbols

typedef struct tagTREEINFO
{
	HTREEITEM	hTreeItem;
	DWORD		dwBufSize;
	CObject*	pTree;
	BOOL		bExpand;
}
TREEINFO, *PTREEINFO;

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp:
// See LCWiz.cpp for the implementation of this class
//

class CLicCompWizApp : public CWinApp
{
public:
	void OnWizard();
	CLicCompWizApp();
	~CLicCompWizApp();
	void NotifyLicenseThread(BOOL bExit);
	void ExitThreads();

// Data members
public:
	CString m_strEnterprise;
	CWinThread* m_pLicenseThread;
	BOOL m_bExitLicenseThread;
	CEvent m_event;
	CString m_strDomain, m_strEnterpriseServer, m_strUser;
	int m_nRemote;

protected:
	HANDLE m_hMutex;

// Attributes
public:
	inline int& IsRemote() {return m_nRemote;}

protected:
	BOOL GetRegString(CString& strIn, UINT nSubKey, UINT nValue, HKEY hHive = HKEY_LOCAL_MACHINE);

// Constants
	enum
	{
		BUFFER_SIZE = 256
	};

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CLicCompWizApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif __LCWIZ_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwiz.cpp ===
// LCWiz.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "LCWiz.h"
#include "LCWizSht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp

BEGIN_MESSAGE_MAP(CLicCompWizApp, CWinApp)
	//{{AFX_MSG_MAP(CLicCompWizApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	//ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global variables

TCHAR pszMutex[] = _T("LicenseMutex");
TCHAR pszLicenseEvent[] = _T("LicenseThread");
TCHAR pszTreeEvent[] =  _T("TreeThread");

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp construction

CLicCompWizApp::CLicCompWizApp()
: m_pLicenseThread(NULL), m_bExitLicenseThread(FALSE), 
  m_event(TRUE, TRUE, pszLicenseEvent), m_nRemote(0)
{
	m_strEnterprise.Empty();
	m_strDomain.Empty();
	m_strEnterpriseServer.Empty();
	m_strUser.Empty();

	// Create a mutex object for use when checking for
	// multiple instances.
	m_hMutex = ::CreateMutex(NULL, TRUE, pszMutex);

	// Place all significant initialization in InitInstance
}

CLicCompWizApp::~CLicCompWizApp()
{
	::ReleaseMutex(m_hMutex);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLicCompWizApp object

CLicCompWizApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp initialization

BOOL CLicCompWizApp::InitInstance()
{
	// Make sure we're running on the correct OS version.
	OSVERSIONINFO  os;

	os.dwOSVersionInfoSize = sizeof(os);
	::GetVersionEx(&os);

	if (os.dwMajorVersion < 4 || os.dwPlatformId != VER_PLATFORM_WIN32_NT)
	{
		AfxMessageBox(IDS_BAD_VERSION, MB_OK | MB_ICONSTOP);
		return FALSE;
	}

	// If there's an instance already running, bring it to the 
	// top and exit.
	if (::WaitForSingleObject(m_hMutex, 0) != WAIT_OBJECT_0)
	{
		CString strWindow;

		strWindow.LoadString(AFX_IDS_APP_TITLE);
		HWND hwnd = ::FindWindow(NULL, (LPCTSTR)strWindow);

		if (hwnd != NULL)
			::SetForegroundWindow(hwnd);
		else
		{
			TRACE(_T("%lu: FindWindow\n"), ::GetLastError());
		}

		return FALSE;
	}

#ifdef OLE_AUTO
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}
#endif // OLE_AUTO

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

#ifdef OLE_AUTO
	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	COleObjectFactory::UpdateRegistryAll();

#endif // OLE_AUTO

	PLLS_CONNECT_INFO_0 pllsci;

	// Get the default domain and license server.
	NTSTATUS status = ::LlsEnterpriseServerFind(NULL, 0, (LPBYTE*)&pllsci);

	if (NT_SUCCESS(status))
	{
		m_strDomain = pllsci->Domain;
		m_strEnterpriseServer = pllsci->EnterpriseServer;

		// Free embedded pointers.
		//::LlsFreeMemory(pllsci->Domain);
		//::LlsFreeMemory(pllsci->EnterpriseServer);
		::LlsFreeMemory(pllsci);
	}
	else
	{
		// There is no license server if this is a workstation
		// so get the local computer name instead.
	
		DWORD dwBufSize = BUFFER_SIZE;
		LPTSTR pszTemp = m_strEnterpriseServer.GetBuffer(dwBufSize);
		::GetComputerName(pszTemp, &dwBufSize);
		m_strDomain.ReleaseBuffer();

		// Get the default domain name from the registry.
		GetRegString(m_strDomain, IDS_SUBKEY, IDS_REG_VALUE);
	}
	
	CString strDomain, strUser;

	// Get the user's name and domain.
	GetRegString(strDomain, IDS_SUBKEY, IDS_REG_VALUE_DOMAIN);
	GetRegString(strUser, IDS_SUBKEY, IDS_REG_VALUE_USER);

	m_strUser.Format(IDS_DOMAIN_USER, strDomain, strUser);

	// Launch the wizard.
	OnWizard();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

void CLicCompWizApp::OnWizard()
{
	// The property sheet attached to your project
	// via this function is not hooked up to any message
	// handler.  In order to actually use the property sheet,
	// you will need to associate this function with a control
	// in your project such as a menu item or tool bar button.

	CLicCompWizSheet propSheet;
	m_pMainWnd = &propSheet;

	propSheet.DoModal();

	// This is where you would retrieve information from the property
	// sheet if propSheet.DoModal() returned IDOK.  We aren't doing
	// anything for simplicity.
}

BOOL CLicCompWizApp::GetRegString(CString& strIn, UINT nSubKey, UINT nValue, HKEY hHive /* = HKEY_LOCAL_MACHINE */)
{
	BOOL bReturn = FALSE;
	HKEY hKey;
	LPTSTR pszTemp;
	DWORD dwBufSize = BUFFER_SIZE;
	CString strSubkey;
	strSubkey.LoadString(nSubKey);

	if (::RegOpenKeyEx(hHive, (LPCTSTR)strSubkey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType = REG_SZ;
		CString strValue;
		strValue.LoadString(nValue);

		pszTemp = strIn.GetBuffer(dwBufSize);
		::RegQueryValueEx(hKey, (LPCTSTR)strValue, NULL, &dwType, (LPBYTE)pszTemp, &dwBufSize);
		::RegCloseKey(hKey);
		strIn.ReleaseBuffer();

		bReturn = TRUE;
	}

	return bReturn;
}

int CLicCompWizApp::ExitInstance() 
{
	ExitThreads();
		
	return CWinApp::ExitInstance();
}

void CLicCompWizApp::NotifyLicenseThread(BOOL bExit)
{
	CCriticalSection cs;

	if (cs.Lock())
	{
		m_bExitLicenseThread = bExit;
		cs.Unlock();
	}
}

void CLicCompWizApp::ExitThreads()
{
	// Make sure the license thread knows it's supposed to quit.
	if (m_pLicenseThread != NULL)
		NotifyLicenseThread(TRUE);

	// Create a lock object for the event object.
	CSingleLock lock(&m_event);

	// Lock the lock object and make the main thread wait for the
	// threads to signal their event objects.
	lock.Lock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\finpic.h ===
// FinPic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture window

class CFinalPicture : public CStatic
{
// Construction
public:
	CFinalPicture();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFinalPicture)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFinalPicture();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFinalPicture)
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwizpgs.h ===
// LCWizPgs.h : header file
//

#ifndef __LCWIZPGS_H__
#define __LCWIZPGS_H__

#include "NetTree.h"
#include "FinPic.h"

#define HORZ_MARGIN 1		// Inches
#define VERT_MARGIN 1.25	// Inches


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 dialog

class CLicCompWizPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage1)

// Construction
public:
	CLicCompWizPage1();
	~CLicCompWizPage1();

// Dialog Data

	CFont m_fontBold;

	//{{AFX_DATA(CLicCompWizPage1)
	enum { IDD = IDD_PROPPAGE1 };
	CStatic	m_wndWelcome;
	int		m_nRadio;
	CString	m_strText;
	//}}AFX_DATA

// Constants
	enum
	{
		BOLD_WEIGHT = 300
	};


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage1)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage1)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 dialog

class CLicCompWizPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage3)

// Construction
public:
	CLicCompWizPage3();
	~CLicCompWizPage3();

// Dialog Data
protected:
	BOOL m_bExpandedOnce;

	//{{AFX_DATA(CLicCompWizPage3)
	enum { IDD = IDD_PROPPAGE3 };
	CStatic	m_wndTextSelectDomain;
	CStatic	m_wndTextDomain;
	CEdit	m_wndEnterprise;
	CNetTreeCtrl	m_wndTreeNetwork;
	//}}AFX_DATA

	// Constants
	enum
	{
		BUFFER_SIZE = 0x100
	};


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	inline CEdit& GetEnterpriseEdit() {return m_wndEnterprise;}

protected:

	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage3)
	afx_msg void OnSelChangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditEnterprise();
	afx_msg void OnNetworkTreeOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage4 dialog

class CLicCompWizPage4 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage4)

// Construction
public:
	CLicCompWizPage4();
	~CLicCompWizPage4();

// Dialog Data
protected:
	CFont m_fontNormal, m_fontHeader, m_fontFooter, m_fontHeading;
	TEXTMETRIC m_tmNormal, m_tmHeader, m_tmFooter, m_tmHeading;
	CPoint m_ptPrint, m_ptOrg, m_ptExt;
	LONG m_nHorzMargin, m_nVertMargin;
	LPINT m_pTabs;
	CString m_strCancel;
	CSize m_sizeSmallText, m_sizeLargeText;

	//{{AFX_DATA(CLicCompWizPage4)
	enum { IDD = IDD_PROPPAGE4 };
	CFinalPicture	m_wndPicture;
	CButton	m_wndPrint;
	CStatic	m_wndUnlicensedProducts;
	CListCtrl	m_wndProductList;
	//}}AFX_DATA

	// Constants
	enum
	{
		LLS_PREFERRED_LENGTH = 500,

		COLUMNS = 2,
		PRINT_COLUMNS = 4,
		TAB_WIDTH = 3,

		BUFFER_SIZE =  0x100,

		FONT_SIZE = 100,
		FONT_SIZE_HEADING = 140,
		FONT_SIZE_FOOTER = 80,
	};

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage4)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL FillListCtrl(LPTSTR pszProduct, WORD wInUse, WORD wPurchased);
	static UINT GetLicenseInfo(LPVOID pParam);

protected:
	BOOL PrintReport(CDC& dc);
	BOOL PrintPages(CDC& dc, UINT nStart);
	BOOL PrepareForPrinting(CDC& dc);
	BOOL PrintPageHeader(CDC& dc);
	BOOL PrintPageFooter(CDC& dc, USHORT nPage);
	BOOL CalculateTabs(CDC& dc);
	void TruncateText(CDC& dc, CString& strText);
	void PumpMessages();

	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage4)
	virtual BOOL OnInitDialog();
	afx_msg void OnPrintButton();
	afx_msg void OnListProductsOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif // __LCWIZPGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwizpgs.cpp ===
// LCWizPgs.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "LCWizPgs.h"
#include "LCWiz.h"
#include "LCWizSht.h"
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLicCompWizPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CLicCompWizPage3, CPropertyPage)
IMPLEMENT_DYNCREATE(CLicCompWizPage4, CPropertyPage)


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 property page

CLicCompWizPage1::CLicCompWizPage1() : CPropertyPage(CLicCompWizPage1::IDD)
{
	//{{AFX_DATA_INIT(CLicCompWizPage1)
	m_nRadio = 0;
	m_strText = _T("");
	//}}AFX_DATA_INIT
}

CLicCompWizPage1::~CLicCompWizPage1()
{
}

void CLicCompWizPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage1)
	DDX_Control(pDX, IDC_WELCOME, m_wndWelcome);
	DDX_Radio(pDX, IDC_RADIO_LOCAL_COMPUTER, m_nRadio);
	DDX_Text(pDX, IDC_TEXT, m_strText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 property page

BOOL CLicCompWizPage1::OnSetActive() 
{
	((CLicCompWizSheet*)GetParent())->SetWizardButtons(PSWIZB_NEXT);
	
	return CPropertyPage::OnSetActive();
}

BOOL CLicCompWizPage1::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	m_strText.LoadString(IDS_TEXT_PAGE1);
	
	// Get the font for the welcome static control and make the font bold.
	CFont* pFont = m_wndWelcome.GetFont();

	// Get the default GUI font if GetFont() fails.
	if (pFont == NULL)
		pFont = CFont::FromHandle((HFONT)::GetStockObject(DEFAULT_GUI_FONT));

	LOGFONT lf;

	if (pFont != NULL && pFont->GetLogFont(&lf))
	{
		// Add to the font weight to make it bold.
		lf.lfWeight += BOLD_WEIGHT;

		if (m_fontBold.CreateFontIndirect(&lf))
		{
			// Set the font for the static control.
			m_wndWelcome.SetFont(&m_fontBold);
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CLicCompWizPage1::OnWizardNext() 
{
	UpdateData();

	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	pApp->IsRemote() = m_nRadio;

	pApp->m_strEnterprise.Empty();

	if (m_nRadio == 0)
	{
		if (::IsWindow(pSheet->m_Page3.m_hWnd))
		{
			pSheet->m_Page3.GetEnterpriseEdit().SetWindowText(_T(""));
		}

		return IDD_PROPPAGE4;
	}
	else
		return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 property page

CLicCompWizPage3::CLicCompWizPage3()
: CPropertyPage(CLicCompWizPage3::IDD), m_bExpandedOnce(FALSE)
{
	//{{AFX_DATA_INIT(CLicCompWizPage3)
	//}}AFX_DATA_INIT
}

CLicCompWizPage3::~CLicCompWizPage3()
{
}

void CLicCompWizPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage3)
	DDX_Control(pDX, IDC_TEXT_SELECT_DOMAIN, m_wndTextSelectDomain);
	DDX_Control(pDX, IDC_TEXT_DOMAIN, m_wndTextDomain);
	DDX_Control(pDX, IDC_EDIT_ENTERPRISE, m_wndEnterprise);
	DDX_Control(pDX, IDC_TREE_NETWORK, m_wndTreeNetwork);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage3)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE_NETWORK, OnSelChangedTree)
	ON_EN_CHANGE(IDC_EDIT_ENTERPRISE, OnChangeEditEnterprise)
	ON_NOTIFY(NM_OUTOFMEMORY, IDC_TREE_NETWORK, OnNetworkTreeOutOfMemory)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 message handlers

BOOL CLicCompWizPage3::OnSetActive() 
{
	BOOL bReturn = CPropertyPage::OnSetActive();

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Do the default domain expansion only once.
	if (!m_bExpandedOnce)
	{
		m_bExpandedOnce = TRUE;
		m_wndTreeNetwork.PopulateTree();
	}

	pSheet->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	return bReturn;
}

void CLicCompWizPage3::OnSelChangedTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	ASSERT(pNMTreeView->itemNew.mask & TVIF_PARAM);

	// Copy the remote name for the selected item into the edit control.
	if (pNMTreeView->itemNew.mask & TVIF_PARAM)
	{
		CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

		int nImage, nSelectedImage;

		nImage = nSelectedImage = 0;

		m_wndTreeNetwork.GetItemImage(m_wndTreeNetwork.GetSelectedItem(), nImage, nSelectedImage);

		// Set the enterprise name in the App object.
		if (nImage == CNetTreeCtrl::IMG_ROOT)
			pApp->m_strEnterprise.Empty();
		else
			pApp->m_strEnterprise = ((LPNETRESOURCE)pNMTreeView->itemNew.lParam)->lpRemoteName;

		// Set the text in the edit control.
		m_wndEnterprise.SetWindowText(pApp->m_strEnterprise);

		// Select the text in the edit control.
		m_wndEnterprise.SetSel(0, -1);
	}

	*pResult = 0;
}

void CLicCompWizPage3::OnChangeEditEnterprise() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	m_wndEnterprise.GetWindowText(pApp->m_strEnterprise);
}

void CLicCompWizPage3::OnNetworkTreeOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult) 
{
    UNREFERENCED_PARAMETER(pNMHDR);

	m_wndTreeNetwork.NotifyThread(TRUE);

	AfxMessageBox(IDS_MEM_ERROR, MB_OK | MB_ICONSTOP);

	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 functions


/////////////////////////////////////////////////////////////////////////////
// Global variables

extern TCHAR pszLicenseEvent[];

/////////////////////////////////////////////////////////////////////////////
// Static member functions

UINT CLicCompWizPage4::GetLicenseInfo(LPVOID pParam)
{
	// Create an event object to match that in the application object.
	CEvent event(TRUE, TRUE, pszLicenseEvent);
	
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CLicCompWizPage4* pPage = (CLicCompWizPage4*)pParam;
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)pPage->GetParent();
	CWaitCursor wc;
	NTSTATUS status = STATUS_ACCESS_DENIED;

	try
	{
		CString strText;
		
		// Unsignal the event object.
		event.ResetEvent();

		// Reset the exit flag.
		pApp->NotifyLicenseThread(FALSE);

		// Disable the Back and Next buttons while the thread is running.
		pSheet->SetWizardButtons(0);

		LPBYTE lpbBuf = NULL;
		LLS_HANDLE hLls = NULL;
		DWORD dwTotalEntries, dwResumeHandle;

		dwTotalEntries = dwResumeHandle = 0;

		// Save the machine or domain name that the user typed.
		CString strFocus = pApp->m_strEnterprise;

		// Display a message indicating what the wizard is doing.
		strText.LoadString(IDS_WORKING);
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);
		strText.Empty();  // Avoids a memory leak.

		// Connect to the license server.
		status = ::LlsConnectEnterprise(const_cast<LPTSTR>((LPCTSTR)pApp->m_strEnterprise),
												 &hLls, 0, &lpbBuf);

		if (NT_ERROR(status))
			goto ErrorMessage;

		// It's OK for the user to click the Back button now, so enable it.
		pSheet->SetWizardButtons(PSWIZB_BACK);

		if (lpbBuf != NULL)
		{
			PLLS_CONNECT_INFO_0 pllsci = (PLLS_CONNECT_INFO_0)lpbBuf;

			// Reset the domain and enterprise server names.
			pApp->m_strDomain = pllsci->Domain;
			pApp->m_strEnterpriseServer = pllsci->EnterpriseServer;

			// Free embedded pointers
			//::LlsFreeMemory(pllsci->Domain);
			//::LlsFreeMemory(pllsci->EnterpriseServer);

			// Free memory allocated by the LLS API.
			status = ::LlsFreeMemory(lpbBuf);
			lpbBuf = NULL;
		}

		if (NT_SUCCESS(status))
		{
			// Display a message indicating what the wizard is doing.
			strText.LoadString(IDS_ENUM_PRODUCTS);
			pPage->m_wndUnlicensedProducts.SetWindowText(strText);
			strText.Empty();  // Avoids a memory leak.

			USHORT nProductCount = 0;
			DWORD dwEntriesRead, dwTotalEntriesRead;

			dwEntriesRead = dwTotalEntriesRead = 0;

			// Build a list of all the products.
			do
			{	
				// Check the exit thread flag.  The user may have clicked the Back button.
				if (pApp->m_bExitLicenseThread)
					goto ExitThread;

				status = ::LlsProductEnum(hLls, 1, &lpbBuf, CLicCompWizPage4::LLS_PREFERRED_LENGTH,
										  &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);

				if (!NT_SUCCESS(status))
					goto ErrorMessage;

				dwTotalEntriesRead += dwEntriesRead;

				PLLS_PRODUCT_INFO_1 pllspi = (PLLS_PRODUCT_INFO_1)lpbBuf;

				while (dwEntriesRead--)
				{
					// Check the exit thread flag.  The user may have clicked the Back button.
					if (pApp->m_bExitLicenseThread)
						goto ExitThread;

					if ((LONG)pllspi->InUse > (LONG)pllspi->Purchased)
					{
						pPage->FillListCtrl(pllspi->Product, (WORD)pllspi->InUse, (WORD)pllspi->Purchased);

						// Increment the unlicensed products counter.
						nProductCount++;
					}

					// Free embedded pointer.
					::LlsFreeMemory(pllspi->Product);

					pllspi++;
				}

				// Free memory allocated by the LLS API.
				status = ::LlsFreeMemory(lpbBuf);
				lpbBuf = NULL;

				ASSERT(NT_SUCCESS(status));
			}
			while (dwTotalEntries);

			// Close the LLS handle.
			status = ::LlsClose(hLls);

			// Check the exit thread flag.  The user may have clicked the Back button.
			if (pApp->m_bExitLicenseThread)
				goto ExitThread;

			ASSERT(NT_SUCCESS(status));

			// Show the user how many unlicensed products were found.
			if (nProductCount)
			{
				strText.Format(IDS_UNLICENSED_PRODUCTS, pApp->m_strEnterpriseServer);
				pPage->m_wndUnlicensedProducts.SetWindowText(strText);

				// Make the static text box the appropriate size.
				pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
															pPage->m_sizeSmallText.cx, 
															pPage->m_sizeSmallText.cy, 
														    SWP_NOMOVE | SWP_NOZORDER);

				// Make sure the list control is visible.
				pPage->m_wndProductList.ShowWindow(SW_SHOW);

				// Make sure the print button is visible.
				pPage->m_wndPrint.ShowWindow(SW_SHOW);
			}
			else
			{
				// Make the static text box the appropriate size.
				pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
															pPage->m_sizeLargeText.cx, 
															pPage->m_sizeLargeText.cy, 
														    SWP_NOMOVE | SWP_NOZORDER);

				// Display a message if no unlicensed products were found.
				strText.LoadString(IDS_NO_UNLICENSED_PRODUCTS);
				pPage->m_wndUnlicensedProducts.SetWindowText(strText);
			}

			// Enable the Back button.
			pSheet->SetWizardButtons(PSWIZB_BACK);

			CString strFinished;
			CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);

			// Change the text on the cancel button to "Done."
			strFinished.LoadString(IDS_DONE);
			pCancel->SetWindowText(strFinished);

			// Signal the event object.
			event.SetEvent();

			// Reset the pointer to the license thread.
			pApp->m_pLicenseThread = NULL;

			// Restore the normal cursor.
			pPage->PostMessage(WM_SETCURSOR);
		}

		return 0;

	ErrorMessage:
		// Check the exit thread flag.  The user may have clicked the Back button.
		if (pApp->m_bExitLicenseThread)
			goto ExitThread;

		// Make the static text box the appropriate size.
		pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
													pPage->m_sizeLargeText.cx, 
													pPage->m_sizeLargeText.cy, 
													SWP_NOMOVE | SWP_NOZORDER);

		// Create an error message based on the return value from LlsConnectEnterprise().
		switch (status)
		{
			case STATUS_NO_SUCH_DOMAIN:
				if (pApp->IsRemote())
					strText.Format(IDS_BAD_DOMAIN_NAME, strFocus);
				else
					strText.LoadString(IDS_UNAVAILABLE);
				break;

			case STATUS_ACCESS_DENIED:
				if (pApp->IsRemote())
					strText.Format(IDS_ACCESS_DENIED, strFocus);
				else
					strText.LoadString(IDS_LOCAL_ACCESS_DENIED);
				break;

			case RPC_NT_SERVER_UNAVAILABLE:
				strText.Format(IDS_SERVER_UNAVAILABLE);
				break;

			default:
				if (pApp->IsRemote())
					strText.Format(IDS_NO_LICENSE_INFO_REMOTE, strFocus);
				else
					strText.LoadString(IDS_NO_LICENSE_INFO_LOCAL);
		}

		// Display an error message if LlsProductEnum() fails.
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);

		// Enable the Back button.
		pSheet->SetWizardButtons(PSWIZB_BACK);

		// Signal the event object.
		event.SetEvent();

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		// Restore the normal cursor.
		pPage->PostMessage(WM_SETCURSOR);

		return 1;

	ExitThread:
		// Signal the event object.
		event.SetEvent();

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		return 2;
	}
	catch(...)
	{
		// Signal the event object.
		event.SetEvent();

		CString strText;

		// Display an error message.
		strText.LoadString(IDS_GENERIC_ERROR);
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		// Restore the normal cursor.
		pPage->PostMessage(WM_SETCURSOR);

		return 3;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage4 property page

CLicCompWizPage4::CLicCompWizPage4()
: CPropertyPage(CLicCompWizPage4::IDD), m_ptPrint(0, 0), m_nHorzMargin(0), 
m_nVertMargin(0),m_ptOrg(0, 0), m_ptExt(0, 0), m_sizeSmallText(0, 0), 
m_sizeLargeText(0, 0)
{
	//{{AFX_DATA_INIT(CLicCompWizPage4)
	//}}AFX_DATA_INIT
	
	m_strCancel.Empty();
	m_pTabs = new INT[PRINT_COLUMNS];
}

CLicCompWizPage4::~CLicCompWizPage4()
{
	if (m_pTabs != NULL)
		delete[] m_pTabs;
}

void CLicCompWizPage4::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage4)
	DDX_Control(pDX, IDC_FLAG_BMP, m_wndPicture);
	DDX_Control(pDX, IDC_BUT_PRINT, m_wndPrint);
	DDX_Control(pDX, IDC_TEXT_UNCOMP_PRODUCTS, m_wndUnlicensedProducts);
	DDX_Control(pDX, IDC_LIST_PRODUCTS, m_wndProductList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage4, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage4)
	ON_BN_CLICKED(IDC_BUT_PRINT, OnPrintButton)
	ON_NOTIFY(NM_OUTOFMEMORY, IDC_LIST_PRODUCTS, OnListProductsOutOfMemory)
	ON_WM_DESTROY()
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CLicCompWizPage4::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;

	try
	{
		// Handle dialog messages
		while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
		  if(!IsDialogMessage(&msg))
		  {
			TranslateMessage(&msg);
			DispatchMessage(&msg);  
		  }
		}
	}
	catch(...)
	{
		TRACE(_T("Exception in CLicCompWizPage4::PumpMessages()\n"));
	}

}

BOOL CLicCompWizPage4::FillListCtrl(LPTSTR pszProduct, WORD wInUse, WORD wPurchased)
{
	TCHAR pszLicenses[BUFFER_SIZE];

	::wsprintf(pszLicenses, _T("%u"), wInUse - wPurchased);

	USHORT nIndex;
	LV_ITEM lvi;

	lvi.mask = LVIF_TEXT | LVIF_PARAM;
	lvi.iItem = 0;
	lvi.iSubItem = 0;
	lvi.lParam = MAKELONG(wInUse, wPurchased);
	lvi.pszText = pszProduct;

	if ((nIndex = (USHORT)m_wndProductList.InsertItem(&lvi)) != (USHORT)-1)
	{
		m_wndProductList.SetItemText(nIndex, 1, pszLicenses);
	}

	return TRUE;
}

BOOL CLicCompWizPage4::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// Set the header text for the list control.
	CRect rcList;

	m_wndProductList.GetWindowRect(&rcList);

	CString strColumnTitle;
	LV_COLUMN lvc;

	lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvc.fmt = LVCFMT_LEFT;

	USHORT nColumns = COLUMNS;
	UINT uStringID[COLUMNS] = {IDS_PRODUCTS_LIST, IDS_LICENSES_LIST};

	for (USHORT i = 0; i < nColumns; i++)
	{
		strColumnTitle.LoadString(uStringID[i]);
		lvc.pszText = strColumnTitle.GetBuffer(strColumnTitle.GetLength());
		lvc.cx = rcList.Width() / COLUMNS;

		m_wndProductList.InsertColumn(i, &lvc);

		strColumnTitle.ReleaseBuffer();
	}

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Store the text on the cancel button.
	CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);
	pCancel->GetWindowText(m_strCancel);

	CRect rcText;

	// Create the large and small extents for the static text control.
	m_wndUnlicensedProducts.GetWindowRect(&rcText);

	m_sizeSmallText.cx = rcText.right - rcText.left;
	m_sizeSmallText.cy = rcText.bottom - rcText.top;

	// Make the large extents match those for the list control.
	m_sizeLargeText.cx = rcList.right - rcList.left;
	m_sizeLargeText.cy = rcList.bottom - rcList.top;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLicCompWizPage4::OnListProductsOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult) 
{
    UNREFERENCED_PARAMETER(pNMHDR);

	AfxMessageBox(IDS_MEM_ERROR, MB_OK | MB_ICONSTOP);
	
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Let the license thread know it's supposed to quit.
	pApp->NotifyLicenseThread(TRUE);

	*pResult = 0;
}

void CLicCompWizPage4::OnPrintButton() 
{
	CDC dc;
	CPrintDialog dlg(FALSE, 
					 PD_ALLPAGES | PD_USEDEVMODECOPIESANDCOLLATE | 
					 PD_NOPAGENUMS | PD_HIDEPRINTTOFILE | 
					 PD_NOSELECTION, 
					 this);

	if (dlg.DoModal() == IDOK)
	{
		CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
		m_wndPrint.RedrawWindow();

		DOCINFO di;
		CString strDocName;

		strDocName.Format(IDS_DOC_NAME, pApp->m_strEnterpriseServer);

		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = strDocName.GetBuffer(BUFFER_SIZE);
		di.lpszOutput = NULL;

		if (dc.Attach(dlg.GetPrinterDC()))
		{
			PrepareForPrinting(dc);
			dc.StartDoc(&di);
			PrintReport(dc);
			dc.EndDoc();
			dc.DeleteDC();
			::GlobalFree(dlg.m_pd.hDevNames);
			::GlobalFree(dlg.m_pd.hDevMode);
		}
	}
}

BOOL CLicCompWizPage4::PrepareForPrinting(CDC& dc)
{
	// Create various fonts...
	CString strFont;

	// Create a heading font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontHeading.CreatePointFont(FONT_SIZE_HEADING, strFont, &dc);

	// Create a bold, underlined header font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontHeader.CreatePointFont(FONT_SIZE, strFont, &dc);

	LOGFONT lf;
	m_fontHeader.GetLogFont(&lf);
	m_fontHeader.DeleteObject();
	lf.lfUnderline = TRUE;
	m_fontHeader.CreateFontIndirect(&lf);

	// Create a footer font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontFooter.CreatePointFont(FONT_SIZE_FOOTER, strFont, &dc);

	// Create a default font.
	strFont.LoadString(IDS_FONT);
	m_fontNormal.CreatePointFont(FONT_SIZE, strFont, &dc);

	// Get the text metrics for each font.
	CFont* pOldFont = dc.SelectObject(&m_fontHeading);
	dc.GetTextMetrics(&m_tmHeading);

	dc.SelectObject(&m_fontHeader);
	dc.GetTextMetrics(&m_tmHeader);

	dc.SelectObject(&m_fontFooter);
	dc.GetTextMetrics(&m_tmFooter);

	dc.SelectObject(&m_fontNormal);
	dc.GetTextMetrics(&m_tmNormal);

	// Select the original font back in to the device context.
	dc.SelectObject(pOldFont);

	// Set the horizontal and vertical margins.
	m_nHorzMargin = (LONG)(dc.GetDeviceCaps(LOGPIXELSX) * HORZ_MARGIN);
	m_nVertMargin = (LONG)(dc.GetDeviceCaps(LOGPIXELSY) * VERT_MARGIN);

	// Get the printable page offsets for the origin.
	m_ptOrg.x = dc.GetDeviceCaps(PHYSICALOFFSETX);
	m_ptOrg.y = dc.GetDeviceCaps(PHYSICALOFFSETY);

	dc.SetWindowOrg(m_ptOrg);

	m_ptOrg.x += m_nHorzMargin;
	m_ptOrg.y += m_nVertMargin;

	// Get the printable page offsets for the page extents.
	m_ptExt.x = dc.GetDeviceCaps(PHYSICALWIDTH) -  m_ptOrg.x;
	m_ptExt.y = dc.GetDeviceCaps(PHYSICALHEIGHT) - m_ptOrg.y;

	dc.SetViewportOrg(m_ptOrg);

	CalculateTabs(dc);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintReport(CDC& dc)
{
	// Set the starting point for printing.
	m_ptPrint.x = m_ptPrint.y = 0;

	// Prepare to print a heading.
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CString strHeading;

	CFont* pOldFont = dc.SelectObject(&m_fontHeading);
	strHeading.Format(IDS_DOC_NAME, pApp->m_strEnterpriseServer);

	dc.StartPage();

	CRect rc(m_ptPrint.x, m_ptPrint.y, m_ptExt.x - m_ptOrg.x, m_tmHeading.tmHeight);

	// Calculate the size of the rectangle needed to draw the text.
	m_ptPrint.y += dc.DrawText(strHeading, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	// Normalize the rectangle.
	rc.NormalizeRect();
	
	// Add a blank line below the heading.
	m_ptPrint.y += m_tmHeading.tmHeight;

	// Move the right side of the rectangle out to the right margin so text is properly centered.
	rc.right = m_ptExt.x - m_ptOrg.x;

	// Draw the text in the rectangle.
	dc.DrawText(strHeading, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	dc.SelectObject(pOldFont);

	PrintPages(dc, 100);

	// Delete the fonts.
	m_fontNormal.DeleteObject();
	m_fontHeader.DeleteObject();
	m_fontFooter.DeleteObject();
	m_fontHeading.DeleteObject();

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPageHeader(CDC& dc)
{
	CFont* pOldFont = dc.SelectObject(&m_fontHeader);

	dc.StartPage();

	CString strHeader, strProducts, strLicenses, strPurchased, strUsed;
	strProducts.LoadString(IDS_PRODUCTS);
	strLicenses.LoadString(IDS_LICENSES);
	strPurchased.LoadString(IDS_PURCHASED);
	strUsed.LoadString(IDS_USED);
	strHeader.Format(_T("%s\t%s\t%s\t%s"), strProducts, strLicenses,
										   strPurchased, strUsed);

	dc.TabbedTextOut(m_ptPrint.x, m_ptPrint.y, strHeader, PRINT_COLUMNS, m_pTabs, 0);

	m_ptPrint.y += ((m_tmHeader.tmHeight + m_tmHeader.tmExternalLeading) * 2);

	dc.SelectObject(pOldFont);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPageFooter(CDC& dc, USHORT nPage)
{
	CFont* pOldFont = dc.SelectObject(&m_fontFooter);

	CString strFooter;
	CTime time(CTime::GetCurrentTime());

	strFooter.Format(IDS_PAGE_DATE, nPage, time.Format(IDS_FMT_DATE));

	CRect rc(m_ptPrint.x, m_ptExt.y - m_nVertMargin, m_ptOrg.x, m_tmFooter.tmHeight);

	// Calculate the size of the rectangle needed to draw the text.
	m_ptPrint.y += dc.DrawText(strFooter, &rc, DT_CALCRECT | DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	// Move the right side of the rectangle out to the right margin so text is properly centered.
	rc.right = m_ptExt.x - m_ptOrg.x;

	// Draw the text in the rectangle.
	dc.DrawText(strFooter, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	dc.EndPage();

	dc.SelectObject(pOldFont);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPages(CDC& dc, UINT nStart)
{
	CFont* pOldFont = dc.SelectObject(&m_fontNormal);

    UNREFERENCED_PARAMETER(nStart);

	USHORT nPage = 1;
	UINT nItems = m_wndProductList.GetItemCount();

	// Print the initial header.
	PrintPageHeader(dc);

	DWORD dwParam = 0;
	CString strTextOut;

	for (UINT i = 0; i < nItems; i++)
	{
		dwParam = (DWORD)m_wndProductList.GetItemData(i);

		CString strProduct = m_wndProductList.GetItemText(i, 0);

		CSize sizeProduct = dc.GetTextExtent(strProduct);

		if (sizeProduct.cx > m_pTabs[0] - (m_tmNormal.tmAveCharWidth * TAB_WIDTH))
			TruncateText(dc, strProduct);

		// Format the output text.
		strTextOut.Format(_T("%s\t%s\t%u\t%u"), strProduct,
												m_wndProductList.GetItemText(i, 1),
												HIWORD(dwParam), LOWORD(dwParam));

		dc.TabbedTextOut(m_ptPrint.x, m_ptPrint.y, strTextOut, PRINT_COLUMNS, m_pTabs, 0);

		// Calculate the vertical position for the next line of text.
		m_ptPrint.y += m_tmNormal.tmHeight + m_tmNormal.tmExternalLeading;

		if ((m_ptPrint.y + m_ptOrg.y) >= m_ptExt.y)
		{
			PrintPageFooter(dc, nPage++);

			// Reset the printing position.
			m_ptPrint.y = 0;

			PrintPageHeader(dc);
		}
	}

	// Print the final footer.
	PrintPageFooter(dc, (USHORT)nPage);

	dc.SelectObject(pOldFont);

	return TRUE;
}

void CLicCompWizPage4::TruncateText(CDC& dc, CString& strInput)
{
	CString strText, strEllipsis;

	USHORT nLen, nChars = 0;
	UINT nMaxWidth = m_pTabs[0] - (m_tmNormal.tmAveCharWidth * TAB_WIDTH);
	nLen = (USHORT)strInput.GetLength();

	strEllipsis.LoadString(IDS_ELLIPSIS);

	CSize sizeText = dc.GetTextExtent(strInput);

	// Keep lopping off characters until the string is short enough.
	while ((UINT)sizeText.cx > nMaxWidth)
	{
		strText = strInput.Left(nLen - nChars++);
		sizeText = dc.GetTextExtent(strText);
	}

	// Remove the last characters and replace them with an ellipsis.
	ASSERT(strText.GetLength() > strEllipsis.GetLength());
	strInput = strText.Left(strText.GetLength() - strEllipsis.GetLength()) + strEllipsis;
}

BOOL CLicCompWizPage4::CalculateTabs(CDC& dc)
{
	INT nTotalExt = 0;
	INT nTabSize = TAB_WIDTH * m_tmHeader.tmAveCharWidth;

	UINT uStrIds[] = {IDS_LICENSES, IDS_PURCHASED, IDS_USED};

	m_pTabs[0] = 0;

	for (USHORT i = 1; i < PRINT_COLUMNS; i++)
	{
		CString strText;

		strText.LoadString(uStrIds[i - 1]);
		// Get the text extent for each string.
		m_pTabs[i] = dc.GetTextExtent(strText).cx;
		// Keep a running total of the extents.
		nTotalExt += m_pTabs[i];
	}

	// Add tab space between columns.
	nTotalExt += nTabSize * (PRINT_COLUMNS - 2);

	// The second column will begin at the difference between the right
	// margin and the total extent.
	m_pTabs[0] = m_ptExt.x - m_ptOrg.x - nTotalExt;

	// Now set the actual tab positions in the array.
	for (i = 1; i < PRINT_COLUMNS; i++)
	{
		m_pTabs[i] += m_pTabs[i - 1] + nTabSize;
	}

	return TRUE;
}

LRESULT CLicCompWizPage4::OnWizardBack() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Let the license thread know it's time to quit.
	pApp->NotifyLicenseThread(TRUE);

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Set the cancel button text back to "Cancel."
	CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);
	pCancel->SetWindowText(m_strCancel);

	if (pSheet->m_Page1.m_nRadio == 0)
		return IDD_PROPPAGE1;
	else
		return CPropertyPage::OnWizardBack();
}

void CLicCompWizPage4::OnDestroy() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	pApp->NotifyLicenseThread(TRUE);
	PumpMessages();

	CPropertyPage::OnDestroy();
}

BOOL CLicCompWizPage4::OnSetActive() 
{
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	pSheet->SetWizardButtons(PSWIZB_BACK);

	// Hide the list control and clear it.
	m_wndProductList.ShowWindow(SW_HIDE);
	m_wndProductList.DeleteAllItems();

	// Hide the print button.
	m_wndPrint.ShowWindow(SW_HIDE);

	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Make sure the last thread has terminated before starting a new one.
	if (pApp->m_pLicenseThread != NULL)
	{
		pApp->NotifyLicenseThread(TRUE);

		CEvent event(TRUE, TRUE, pszLicenseEvent);
		CSingleLock lock(&event);

		lock.Lock();
	}

	// Keep a pointer to the thread so we can find out if it's still running.
	pApp->m_pLicenseThread = AfxBeginThread((AFX_THREADPROC)GetLicenseInfo, (LPVOID)this);

	return CPropertyPage::OnSetActive();
}

LRESULT CLicCompWizPage3::OnWizardNext() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	m_wndEnterprise.GetWindowText(pApp->m_strEnterprise);

	// Trim off any white space in the enterprise name.
	pApp->m_strEnterprise.TrimLeft();
	pApp->m_strEnterprise.TrimRight();

	if (pApp->m_strEnterprise.IsEmpty() ||
		pApp->m_strEnterprise.Find(_T("\\\\")) != -1)
	{
		AfxMessageBox(IDS_SPECIFY_DOMAIN, MB_OK | MB_ICONEXCLAMATION);
		return IDD;
	}
	
	return CPropertyPage::OnWizardNext();
}

BOOL CLicCompWizPage4::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	if (pApp->m_pLicenseThread == NULL)	
	{
		return CPropertyPage::OnSetCursor(pWnd, nHitTest, message);
	}
	else
	{
		// Restore the wait cursor if the thread is running.
		RestoreWaitCursor();

		return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwizsht.cpp ===
// LCWizSht.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "LCWizSht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet

IMPLEMENT_DYNAMIC(CLicCompWizSheet, CPropertySheet)

CLicCompWizSheet::CLicCompWizSheet(CWnd* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the 
	// active one is to call SetActivePage().

	AddPage(&m_Page1);
	AddPage(&m_Page3);
	AddPage(&m_Page4);

	SetWizardMode();
}

CLicCompWizSheet::~CLicCompWizSheet()
{
}


BEGIN_MESSAGE_MAP(CLicCompWizSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CLicCompWizSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet message handlers


BOOL CLicCompWizSheet::OnInitDialog() 
{
	if ((m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME)) != NULL)
	{
		::SetClassLongPtr(m_hWnd, GCLP_HICON, (LONG_PTR)m_hIcon);
		::SetClassLongPtr(m_hWnd, GCLP_HICONSM, (LONG_PTR)m_hIcon);
	}

	return CPropertySheet::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\lcwizsht.h ===
// LCWizSht.h : header file
//
// This class defines custom modal property sheet 
// CLicCompWizSheet.
 
#ifndef __LCWIZSHT_H__
#define __LCWIZSHT_H__

#include "LCWizPgs.h"

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet

class CLicCompWizSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CLicCompWizSheet)

// Construction
public:
	CLicCompWizSheet(CWnd* pParentWnd = NULL);

// Data members
public:
	CLicCompWizPage1 m_Page1;
	CLicCompWizPage3 m_Page3;
	CLicCompWizPage4 m_Page4;
	HICON m_hIcon;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLicCompWizSheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CLicCompWizSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __LCWIZSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsapi.h

Abstract:

    License logging server's RPC API's.

Author:

    Arthur Hanson (arth) 21-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;


typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;


typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;


typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;



#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#define LlsConnect LlsConnectW
#else
#define LlsConnect LlsConnectA
#endif

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );


NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif
//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif


#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")

#define REG_VALUE_NAME   TEXT("DisplayName")
#define REG_VALUE_MODE   TEXT("Mode")
#define REG_VALUE_FLIP   TEXT("FlipAllow")
#define REG_VALUE_LIMIT  TEXT("ConcurrentLimit")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LCWiz.rc
//
#define IDP_OLE_INIT_FAILED             100
#define IDD_LCWIZ_DIALOG                102
#define IDS_PROPSHT_CAPTION             103
#define IDS_TEXT_PAGE1                  104
#define IDS_TEXT_PAGE2                  105
#define IDS_NET_ERROR                   106
#define IDS_NET_NO_SERVERS              107
#define IDS_PRODUCTS                    108
#define IDS_LICENSES                    109
#define IDS_FONT                        110
#define IDS_FONT_BOLD                   111
#define IDS_UNLICENSED_PRODUCTS         112
#define IDS_FMT_DATE                    113
#define IDS_NO_LICENSE_INFO             114
#define IDS_NO_LICENSE_INFO_LOCAL       114
#define IDS_DONE                        115
#define IDS_ERROR                       116
#define IDS_TREE_ROOT                   117
#define IDS_WORKING                     118
#define IDS_DOC_NAME                    119
#define IDS_PAGE_DATE                   120
#define IDS_PURCHASED                   121
#define IDS_USED                        122
#define IDS_PRODUCTS_LIST               123
#define IDS_LICENSES_LIST               124
#define IDS_ENUM_PRODUCTS               125
#define IDS_WELCOME                     126
#define IDS_MEM_ERROR                   127
#define IDR_MAINFRAME                   128
#define IDS_NO_UNLICENSED_PRODUCTS      128
#define IDD_PROPPAGE1                   129
#define IDS_ELLIPSIS                    129
#define IDD_PROPPAGE2                   130
#define IDS_SUBKEY                      130
#define IDD_PROPPAGE3                   131
#define IDS_REG_VALUE                   131
#define IDD_PROPPAGE4                   132
#define IDS_BAD_DOMAIN_NAME             132
#define IDS_SERVER_UNAVAILABLE          133
#define IDB_NET_TREE                    134
#define IDS_NO_LICENSE_INFO_REMOTE      134
#define IDB_PAGE_ART                    135
#define IDS_ACCESS_DENIED               135
#define IDS_GENERIC_ERROR               136
#define IDS_REG_VALUE_USER              137
#define IDS_REG_VALUE_DOMAIN            138
#define IDS_DOMAIN_USER                 139
#define IDB_END_FLAG                    140
#define IDS_ADMIN                       140
#define IDS_LOCAL_ACCESS_DENIED         141
#define IDS_UNAVAILABLE                 142
#define IDS_SERVER_UNAVAILABLE_LOCAL    143
#define IDS_SPECIFY_DOMAIN              144
#define IDS_BAD_VERSION                 145
#define IDC_PAINT_BOX                   1000
#define IDC_TEXT                        1003
#define IDC_TREE_NETWORK                1007
#define IDC_CHECK_LOCAL_COMPUTER        1008
#define IDC_EDIT_ENTERPRISE             1018
#define IDC_LIST_PRODUCTS               1019
#define IDC_TEXT_COMP_PRODUCTS          1023
#define IDC_TEXT_UNCOMP_PRODUCTS        1024
#define IDC_BUT_PRINT                   1025
#define IDC_RADIO_LOCAL_COMPUTER        1026
#define IDC_RADIO_DOMAIN                1027
#define IDC_TEXT_DOMAIN                 1028
#define IDC_TEXT_SELECT_DOMAIN          1029
#define IDC_WELCOME                     1031
#define IDC_FLAG_BMP                    1033

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        141
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	LCWiz.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\nettree.cpp ===
// NetTree.cpp : implementation file
//

#include "stdafx.h"
#include "NetTree.h"

#include <strsafe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global variables

extern TCHAR pszTreeEvent[];


/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl

CNetTreeCtrl::CNetTreeCtrl()
: m_pThread(NULL), m_bExitThread(FALSE), m_event(TRUE, TRUE, pszTreeEvent)
{
	// Get a handle to the process heap
	m_hHeap = ::GetProcessHeap();

	ASSERT(m_hHeap != NULL);
}

CNetTreeCtrl::~CNetTreeCtrl()
{
	// Make sure the thread knows it's time to terminate.
	NotifyThread(TRUE);

	// Create an event object to match the tree thread event object.
	CEvent event(TRUE, TRUE, pszTreeEvent);
	
	// Create a lock object for the event object.
	CSingleLock lock(&event);

	// Lock the lock object and make the main thread wait for the
	// threads to signal their event objects.
	lock.Lock();

	// Free all of the pointers to LPTSTRs in the list
	POSITION pos = m_ptrlistStrings.GetHeadPosition();

	while (pos != NULL)
	{
		// Memory deallocation fails if there's a null char
		// at the end of the string.
		LPTSTR psz = m_ptrlistStrings.GetNext(pos);
		*(::_tcslen(psz) + psz) = (TCHAR)0xFD;
		delete[] psz;
	}

	// Free all of the pointers to NETRESOURCE structs in the list
	pos = m_ptrlistContainers.GetHeadPosition();

	while (pos != NULL)
	{
		delete m_ptrlistContainers.GetNext(pos);
	}
}


BEGIN_MESSAGE_MAP(CNetTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CNetTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
	ON_WM_SETCURSOR()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Static member functions

UINT CNetTreeCtrl::FillTree(LPVOID pParam)
{
	CEvent event(TRUE, TRUE, pszTreeEvent);
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	PTREEINFO pti = (PTREEINFO)pParam;
	CNetTreeCtrl* pTree = (CNetTreeCtrl*)pti->pTree;
	BOOL bResult = FALSE;
	DWORD dwEntries = 0xFFFFFFFF;
	LPVOID lpvBuffer = NULL;
	HANDLE hEnum = NULL;

	// Because this function may call itself, keep a usage count
	// so that pti is freed only when the first instance returns.
	static USHORT uUsage = 0;

	// Keep a handle to the heap in case the CNetTreeCtrl object
	// goes away before the thread ends.
	HANDLE hHeap = pTree->m_hHeap;
	DWORD dwResult;
	LPNETRESOURCE pnrRoot;
	HTREEITEM hTreeItem, hTreeExpand;

    HRESULT hr;

	hTreeItem = hTreeExpand = NULL;

	try
	{
		// Unsignal the event object.
		event.ResetEvent();

		// Show the wait cursor
		pTree->BeginWaitCursor();

		// Exit if the handle to the heap is invalid.
		if (hHeap == NULL)
			goto ExitFunction;

		if (pti->hTreeItem == TVI_ROOT)
		{
			pnrRoot = NULL;
			if (pTree->m_imagelist.Create(IDB_NET_TREE, 16, 3, CNetTreeCtrl::IMG_MASK))
			{
				pTree->SetImageList(&(pTree->m_imagelist), TVSIL_NORMAL);
				pTree->m_imagelist.SetBkColor(CLR_NONE);
			}
		}
		else
			pnrRoot = (LPNETRESOURCE)pTree->GetItemData(pti->hTreeItem);

		// Get an enumeration handle.
		if ((dwResult = ::WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 
								  RESOURCEUSAGE_CONTAINER, pnrRoot, &hEnum)) != NO_ERROR)
		{
			// Exit if WNetOpenEnum fails.
			dwResult = ::GetLastError();
			goto ExitFunction;
		}

		// Allocate a buffer for enumeration.
		if ((lpvBuffer = ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, pti->dwBufSize)) == NULL)
			// Exit if memory allocation failed
			goto ExitFunction;

		// Retrieve a block of network entries.
		while ((dwResult = ::WNetEnumResource(hEnum, &dwEntries, lpvBuffer, &(pti->dwBufSize))) != ERROR_NO_MORE_ITEMS)
		{
			// See if it's time to exit.
			if (pTree->m_bExitThread)
			{
				pTree->NotifyThread(FALSE);
				bResult = TRUE;
				goto ExitFunction;
			}

			// Exit if WNetEnumResource failed.
			if (dwResult != NO_ERROR)
			{
				dwResult = ::GetLastError();
				goto ExitFunction;
			}

			LPNETRESOURCE pnrLeaf = (LPNETRESOURCE)lpvBuffer;
			TV_INSERTSTRUCT tviLeaf;

			// Fill in the TV_INSERTSTRUCT members.
			tviLeaf.hParent = pti->hTreeItem;
			tviLeaf.hInsertAfter = TVI_SORT;
			tviLeaf.item.hItem = NULL;
			tviLeaf.item.state = 0;
			tviLeaf.item.stateMask = 0;
			tviLeaf.item.cchTextMax = 0;
			tviLeaf.item.iSelectedImage = 0;

			// Set the correct image for the leaf.
			switch (pnrLeaf->dwDisplayType)
			{
				case RESOURCEDISPLAYTYPE_DOMAIN:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_DOMAIN;
					break;
					
				case RESOURCEDISPLAYTYPE_SERVER:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_SERVER;
					break;

				default:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_ROOT;
			}

			// Fool the tree into thinking that this leaf has children
			// since we don't know initially.
#if 0
			if (pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
#else
			if (pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_DOMAIN ||
				pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
#endif
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 0;
			}
			else
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 1;
			}

			// Add leaves to the branch.
			for (DWORD i = 0; i < dwEntries; i++)
			{
				// See if it's time to exit.
				if (pTree->m_bExitThread)
				{
					pTree->NotifyThread(FALSE);
					bResult = TRUE;
					goto ExitFunction;
				}

				// Create a permanent NETRESOURCE struct for later use.
				LPNETRESOURCE pnrTemp = new NETRESOURCE;
				pTree->m_ptrlistContainers.AddTail(pnrTemp);

				::CopyMemory(pnrTemp, pnrLeaf, sizeof(NETRESOURCE));

				// Initialize members.
				pnrTemp->lpLocalName = NULL; 
				pnrTemp->lpRemoteName = NULL; 
				pnrTemp->lpComment = NULL; 
				pnrTemp->lpProvider = NULL; 

				if (pnrLeaf->lpRemoteName != NULL)
				{
                    size_t  cch = ::_tcslen(pnrLeaf->lpRemoteName) + 1;
					pnrTemp->lpRemoteName = new TCHAR[cch];
                    if (NULL == pnrTemp->lpRemoteName)
                        goto ExitFunction;
					hr = StringCchCopy(pnrTemp->lpRemoteName, cch, pnrLeaf->lpRemoteName);
                    if (FAILED(hr))
                        goto ExitFunction;
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpRemoteName);
				}

				if (pnrLeaf->lpProvider != NULL)
				{
                    size_t  cch = ::_tcslen(pnrLeaf->lpProvider) + 1;
					pnrTemp->lpProvider = new TCHAR[cch];
                    if (NULL == pnrTemp->lpProvider)
                        goto ExitFunction;
					hr = StringCchCopy(pnrTemp->lpProvider, cch, pnrLeaf->lpProvider);
                    if (FAILED(hr))
                        goto ExitFunction;
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpProvider);
				}

				// Increment the buffer pointer.
				pnrLeaf++;

				// Use "Enterprise" as the item text if this is the root.
				if (pti->hTreeItem == TVI_ROOT)
				{
					CString strRoot;
                    DWORD   cch;

					strRoot.LoadString(IDS_TREE_ROOT);
                    cch = strRoot.GetLength() + 1;
					tviLeaf.item.pszText = new TCHAR[cch];
                    if (NULL == tviLeaf.item.pszText)
                        goto ExitFunction;
					hr = StringCchCopy(tviLeaf.item.pszText, cch, (LPCTSTR)strRoot);
                    if (FAILED(hr))
                        goto ExitFunction;
				}
				else if (pnrTemp->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
				{
					// Skip the initial backslashes before adding the server
					// name to the tree.
					tviLeaf.item.pszText = pnrTemp->lpRemoteName + 2;
				}
				else
					tviLeaf.item.pszText = pnrTemp->lpRemoteName;

				tviLeaf.item.lParam = (LPARAM)(LPVOID)pnrTemp;

				// Make sure the pointer to the tree control is still valid.
				if (::IsWindow(pTree->m_hWnd))
				{
					hTreeItem = pTree->InsertItem(&tviLeaf);
				}
				else	// Otherwise, exit the thread.
				{
					bResult = TRUE;
					goto ExitFunction;
				}

				// Delete the string allocated for the root node text.
				if (pti->hTreeItem == TVI_ROOT)
					delete tviLeaf.item.pszText;

				// See if the lpRemoteName member is equal to the default domain
				// name.
#if 0
				if (!_tcscmp(pnrTemp->lpRemoteName, pApp->m_strDomain) ||
#else
				if (
#endif
					pti->hTreeItem == TVI_ROOT)
				{
					// Store the handle.
					hTreeExpand = hTreeItem;
				}

				// Select the name of the license server in the tree.
#if 0
				if (!_tcsicmp(pnrTemp->lpRemoteName, pApp->m_strEnterpriseServer))
#else
				if (!_tcsicmp(pnrTemp->lpRemoteName, pApp->m_strDomain))
#endif
				{
					pTree->SelectItem(hTreeItem);
					pTree->EnsureVisible(hTreeItem);
					pTree->SetFocus();
				}
			}

			// Everything went all right.
			bResult = TRUE;
		}

		// Expand the branch but only if it isn't the root.
		// The root item thinks it has children, but really doesn't the first time through.
		if (pti->hTreeItem != TVI_ROOT && pTree->ItemHasChildren(pti->hTreeItem))
		{
			// Indicate that the branch has been expanded once.
			pTree->SetItemState(pti->hTreeItem, TVIS_EXPANDEDONCE, TVIS_EXPANDEDONCE);
			pTree->Expand(pti->hTreeItem, TVE_EXPAND);
		}

		// Fill the branch for the current domain if the bExpand member is TRUE.
		if (hTreeExpand != NULL && pti->bExpand)
		{
			TREEINFO ti;

			ti.hTreeItem = hTreeExpand;
			ti.dwBufSize = pti->dwBufSize;
			ti.pTree = pti->pTree;
			ti.bExpand = TRUE;

			// Increment the usage count.
			uUsage++;

			FillTree((LPVOID)&ti);

			// Decrement the usage count.
			uUsage--;
		}
		
	ExitFunction:
		// Display a message if an error occurred.
		if (!bResult)
			pTree->ErrorHandler(dwResult);

		// Close the enumeration handle.
		if (hEnum != NULL)
			if (FALSE == (bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer only if the usage count is zero.
		if (uUsage == 0)
			delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Make sure the tree control still exists before posting a message.
		if (::IsWindow(pTree->m_hWnd))
			pTree->PostMessage(WM_SETCURSOR);

		// Signal the event object.
		if (uUsage == 0)
			event.SetEvent();

		return (UINT)!bResult;
	}
	catch(...)
	{
		// Close the enumeration handle.
		if (hEnum != NULL)
			if (FALSE == (bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer
		delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Signal the event object.
		event.SetEvent();

		return (UINT)2;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl member functions

BOOL CNetTreeCtrl::PopulateTree(BOOL bExpand /* = TRUE */, const HTREEITEM hParentBranch /* = TVI_ROOT */, 
								DWORD dwBufSize /* = BUFFER_SIZE */)
{
	PTREEINFO pti = new TREEINFO;

	pti->hTreeItem = hParentBranch;
	pti->dwBufSize = dwBufSize;
	pti->pTree = this;
	pti->bExpand = bExpand;

	// Don't begin a new thread until the last one has ended.
	if (m_pThread != NULL)
	{
		NotifyThread(TRUE);

		CEvent event(TRUE, TRUE, pszTreeEvent);
		CSingleLock lock(&event);

		// Wait.
		lock.Lock();
	}

	m_pThread = AfxBeginThread((AFX_THREADPROC)FillTree, (LPVOID)pti);

	return TRUE;
}

void CNetTreeCtrl::ErrorHandler(const DWORD dwCode)
{
	CString strError;
	BOOL bNetError = FALSE;

    UNREFERENCED_PARAMETER(dwCode);

#ifdef _DEBUG
	switch (dwCode)
	{
		case ERROR_MORE_DATA:
			strError = "ERROR_MORE_DATA";
			break;

		case ERROR_INVALID_HANDLE:
			strError = "ERROR_INVALID_HANDLE";
			break;

		case ERROR_NOT_CONTAINER:
			strError = "ERROR_NOT_CONTAINER";
			break;

		case ERROR_INVALID_PARAMETER:
			strError = "ERROR_INVALID_PARAMETER";
			break;

		case ERROR_NO_NETWORK:
			strError = "ERROR_NO_NETWORK";
			break;

		case ERROR_EXTENDED_ERROR:
			strError = "ERROR_EXTENDED_ERROR";
			break;

		default:
		{
#endif // _DEBUG
			DWORD dwErrCode;
			CString strErrDesc, strProvider;
			LPTSTR pszErrDesc = strErrDesc.GetBuffer(MAX_STRING);
			LPTSTR pszProvider = strProvider.GetBuffer(MAX_STRING);

			if (::WNetGetLastError(&dwErrCode, pszErrDesc, MAX_STRING,
								   pszProvider, MAX_STRING) == NO_ERROR)
			{
				strErrDesc.ReleaseBuffer();
				strProvider.ReleaseBuffer();

				CString strErrMsg;

				// Don't display the WNetGetLastError message if dwErrCode == 0.
				if (dwErrCode)
				{	
					// Trim of any leading or trailing white space.
					strProvider.TrimRight();
					strProvider.TrimLeft();
					strErrDesc.TrimRight();
					strErrDesc.TrimLeft();
					strErrMsg.Format(IDS_NET_ERROR, strProvider, strErrDesc);
				}
				else
					strErrMsg.LoadString(IDS_NET_NO_SERVERS);
				
				MessageBox(strErrMsg, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);

				bNetError = TRUE;
			}
			else
				strError.LoadString(IDS_ERROR);
#ifdef _DEBUG
		}
	}
#endif // _DEBUG

	if (!bNetError)
		AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl functions

void CNetTreeCtrl::NotifyThread(BOOL bExit)
{
	CCriticalSection cs;

	if (cs.Lock())
	{
		m_bExitThread = bExit;
		cs.Unlock();
	}
}

void CNetTreeCtrl::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;

	try
	{
		// Handle dialog messages
		while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
		  if(!IsDialogMessage(&msg))
		  {
			TranslateMessage(&msg);
			DispatchMessage(&msg);  
		  }
		}
	}
	catch(...)
	{
		TRACE(_T("Exception in CNetTreeCtrl::PumpMessages()\n"));
	}

}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl message handlers

void CNetTreeCtrl::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	// Exit and stop expansion if the thread is running.
	if (m_pThread != NULL)
	{
		*pResult = TRUE;
		return;
	}

	// Exit if this branch has been expanded once.
	if (!(pNMTreeView->itemNew.state & TVIS_EXPANDEDONCE))
	{
		// Add new leaves to the branch.
		if (pNMTreeView->itemNew.mask & TVIF_HANDLE)
		{
			PopulateTree(FALSE, pNMTreeView->itemNew.hItem);
			pNMTreeView->itemNew.mask |= TVIS_EXPANDEDONCE;
		}
	}
	
	*pResult = FALSE;
}

BOOL CNetTreeCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	if (m_pThread == NULL && pApp->m_pLicenseThread == NULL)	
	{
		return CTreeCtrl::OnSetCursor(pWnd, nHitTest, message);
	}
	else
	{
		// Restore the wait cursor if the thread is running.
		RestoreWaitCursor();

		return TRUE;
	}
}

void CNetTreeCtrl::OnDestroy() 
{
	NotifyThread(TRUE);
	PumpMessages();

	CTreeCtrl::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef ASSERT
#  undef ASSERT
#endif
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxtempl.h>		// MFC template classes
#include <afxmt.h>			// MFC synchronization classes
#include <winnetwk.h>
#include <llsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\nettree.h ===
// NetTree.h : header file
//

#include "lcwiz.h"

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl window

class CNetTreeCtrl : public CTreeCtrl
{
// Construction
public:
	CNetTreeCtrl();
	virtual ~CNetTreeCtrl();

// Data members
public:
	enum 
	{
		ROOT_LEVEL = 0x0,
		DOMAIN_LEVEL = 0x1,
		SERVER_LEVEL = 0x2,

		BUFFER_SIZE = 0x4000,
		MAX_STRING = 0x100,

		IMG_ROOT = 0,
		IMG_DOMAIN = 1,
		IMG_SERVER = 2,

		IMG_SIZE = 16,
		IMG_GROW = 3,
		IMG_MASK = RGB(0xFF, 0xFF, 0xFF)
	};

public:
	HANDLE m_hHeap;
	CImageList m_imagelist;
	CTypedPtrList<CPtrList, LPNETRESOURCE> m_ptrlistContainers;
	CTypedPtrList<CPtrList, LPTSTR> m_ptrlistStrings;
	CWinThread* m_pThread;
	CEvent m_event;
	BOOL m_bExitThread;

// Attributes
public:

// Operations
public:
	BOOL PopulateTree(BOOL bExpand= TRUE, const HTREEITEM hParentBranch = TVI_ROOT, DWORD dwBufSize = BUFFER_SIZE);
	void ErrorHandler(const DWORD dwCode);
	void NotifyThread(BOOL bExit);
	static UINT FillTree(LPVOID pParam);

protected:
	void CNetTreeCtrl::PumpMessages();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CNetTreeCtrl)
	afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\transbmp.cpp ===
// transbmp.cpp : implementation of the CTransBmp class
//
// support for transparent CBitmap objects. Used in the CUserList class.
// Based on a class from MSDN 7/95
#include "stdafx.h"
#include "transbmp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Colors
#define rgbWhite RGB(255,255,255)
// Raster op codes
#define DSa     0x008800C6L
#define DSx     0x00660046L


/////////////////////////////////////////////////////////////////////////////
// CTransBmp construction/destruction

CTransBmp::CTransBmp()
{
    m_iWidth = 0;
    m_iHeight = 0;
	m_hbmMask = NULL;
}

CTransBmp::~CTransBmp()
{
	if (m_hbmMask != NULL) delete m_hbmMask;
}

void CTransBmp::GetMetrics()
{
    // Get the width and height
    BITMAP bm;
    GetObject(sizeof(bm), &bm);
    m_iWidth = bm.bmWidth;
    m_iHeight = bm.bmHeight;
}


int CTransBmp::GetWidth()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iWidth;
}

int CTransBmp::GetHeight()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iHeight;
}


void CTransBmp::CreateMask(CDC* pDC)
{
	m_hbmMask = new CBitmap;    
// Nuke any existing mask
    if (m_hbmMask) m_hbmMask->DeleteObject();

// Create memory DCs to work with
	CDC* hdcMask = new CDC;
	CDC* hdcImage = new CDC;

    hdcMask->CreateCompatibleDC(pDC);
    hdcImage->CreateCompatibleDC(pDC);

// Create a monochrome bitmap for the mask
    m_hbmMask->CreateBitmap(GetWidth(),
                               GetHeight(),
                               1,
                               1,
                               NULL);
// Select the mono bitmap into its DC
    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);
// Select the image bitmap into its DC
    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

// Set the transparency color to be the top-left pixel
    hdcImage->SetBkColor(hdcImage->GetPixel(0, 0));
// Make the mask
    hdcMask->BitBlt(0, 0,
             GetWidth(), GetHeight(),
             hdcImage,
             0, 0,
             SRCCOPY);
// clean up
    hdcMask->SelectObject(hbmOldMask);
    hdcImage->SelectObject(hbmOldImage);
    delete hdcMask;
    delete hdcImage;
}

// draw the transparent bitmap using the created mask
void CTransBmp::DrawTrans(CDC* pDC, int x, int y)
{
    if (m_hbmMask == NULL) CreateMask(pDC);

    int dx = GetWidth();
    int dy = GetHeight();

// Create a memory DC to do the drawing to
	CDC* hdcOffScr = new CDC;
	hdcOffScr->CreateCompatibleDC(pDC);

// Create a bitmap for the off-screen DC that is really
// color compatible with the destination DC.
	CBitmap hbmOffScr;
	hbmOffScr.CreateBitmap(dx, dy, 
						pDC->GetDeviceCaps(PLANES),
						pDC->GetDeviceCaps(BITSPIXEL),
						NULL);
                             
// Select the buffer bitmap into the off-screen DC
    HBITMAP hbmOldOffScr = (HBITMAP)hdcOffScr->SelectObject(hbmOffScr);

// Copy the image of the destination rectangle to the
// off-screen buffer DC so we can play with it
    hdcOffScr->BitBlt(0, 0, dx, dy, pDC, x, y, SRCCOPY);

// Create a memory DC for the source image
	CDC* hdcImage = new CDC;
	hdcImage->CreateCompatibleDC(pDC);

    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

    // Create a memory DC for the mask
    CDC* hdcMask = new CDC;
	hdcMask->CreateCompatibleDC(pDC);

    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);

    // XOR the image with the destination
    hdcOffScr->SetBkColor(rgbWhite);
    hdcOffScr->BitBlt(0, 0, dx, dy ,hdcImage, 0, 0, DSx);
    // AND the destination with the mask
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcMask, 0,0, DSa);
    // XOR the destination with the image again
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcImage, 0, 0, DSx);

    // Copy the resultant image back to the screen DC
    pDC->BitBlt(x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

    // Tidy up
    hdcOffScr->SelectObject(hbmOldOffScr);
    hdcImage->SelectObject(hbmOldImage);
    hdcMask->SelectObject(hbmOldMask);

	delete hdcOffScr;
	delete hdcImage;
	delete hdcMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\liccomp\transbmp.h ===
// transbmp.h : interface of the CTransBitmap class
//
/////////////////////////////////////////////////////////////////////////////

class CTransBmp : public CBitmap
{
public:
    CTransBmp();
    ~CTransBmp();
    void Draw(HDC hDC, int x, int y);
    void Draw(CDC* pDC, int x, int y);
    void DrawTrans(HDC hDC, int x, int y);
    void DrawTrans(CDC* pDC, int x, int y);
    int GetWidth();
    int GetHeight();

private:
    int m_iWidth;
    int m_iHeight;
    CBitmap* m_hbmMask;    // handle to mask bitmap

    void GetMetrics();
    void CreateMask(HDC hDC);
	void CreateMask(CDC* pDC);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\aclpage.cpp ===
// AclPage.cpp : Implementation of ISecurityInformation and IDataObject

#include "stdafx.h"
#include "AclPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////
// class CPermEntry

CPermEntry::CPermEntry()
: m_dwAccessMask(0),
  m_pSid(NULL),
  m_bWellKnownSid(FALSE)
{
}

CPermEntry::~CPermEntry()
{
  if (m_pSid)
    if (m_bWellKnownSid)
      FreeSid(m_pSid);
    else
      LocalFree((HLOCAL)m_pSid);
}

HRESULT
CPermEntry::Initialize(
    IN LPCTSTR  lpszSystem,
    IN LPCTSTR  lpszAccount,
    IN DWORD    dwAccessMask
)
{
  m_cstrSystem = lpszSystem;
  m_cstrAccount = lpszAccount;
  m_dwAccessMask = dwAccessMask;
  
  return GetAccountSID(m_cstrSystem, m_cstrAccount, &m_pSid, &m_bWellKnownSid);
}

UINT
CPermEntry::GetLengthSid()
{
  return (m_pSid ? ::GetLengthSid(m_pSid) : 0);
}

HRESULT
CPermEntry::AddAccessAllowedAce(OUT PACL pACL)
{
  if ( !::AddAccessAllowedAce(pACL, ACL_REVISION, m_dwAccessMask, m_pSid) )
    return HRESULT_FROM_WIN32(GetLastError());
  return S_OK;
}

// NOTE: caller needs to call LocalFree() on the returned SD
HRESULT
BuildSecurityDescriptor(
    IN  CPermEntry            *pPermEntry, // an array of CPermEntry
    IN  UINT                  cEntries,    // number of entries in the array
    OUT PSECURITY_DESCRIPTOR  *ppSelfRelativeSD // return a security descriptor in self-relative form
)
{
  if (!pPermEntry || !cEntries || !ppSelfRelativeSD)
    return E_INVALIDARG;

  if (*ppSelfRelativeSD)
  {
      LocalFree((HLOCAL)*ppSelfRelativeSD);
      *ppSelfRelativeSD = NULL;
  }

  HRESULT               hr = S_OK;
  PSECURITY_DESCRIPTOR  pAbsoluteSD = NULL;
  PACL 			            pACL = NULL;
  
  do { // false loop

    UINT        i = 0;
    CPermEntry *pEntry = NULL;
    DWORD       cbACL = sizeof(ACL);

    // Initialize a new ACL
    for (pEntry=pPermEntry, i=0; i<cEntries; pEntry++, i++)
      cbACL += sizeof(ACCESS_ALLOWED_ACE) + pEntry->GetLengthSid() - sizeof(DWORD);

    if ( !(pACL = (PACL)LocalAlloc(LPTR, cbACL)) ||
         !InitializeAcl(pACL, cbACL, ACL_REVISION))
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }

    // Add Ace
    for (pEntry=pPermEntry, i=0; SUCCEEDED(hr) && i<cEntries; pEntry++, i++)
      hr = pEntry->AddAccessAllowedAce(pACL);
    if (FAILED(hr))
      break;

    // Note: this is a new object, set Dacl only.
    // Initialize a new security descriptor in absolute form and add the new ACL to it
    if ( !(pAbsoluteSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH)) ||
         !InitializeSecurityDescriptor(pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION) ||
         !SetSecurityDescriptorDacl(pAbsoluteSD, TRUE, pACL, FALSE) )
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }

    // transform into a self-relative form
    DWORD dwSDSize = 0;
    MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize);
    if ( !(*ppSelfRelativeSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDSize)) ||
         !MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize) )
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }
  } while (0);

  if (FAILED(hr))
  {
    if (*ppSelfRelativeSD)
    {
      LocalFree((HLOCAL)*ppSelfRelativeSD);
      *ppSelfRelativeSD = NULL;
    }
  }

  if (pACL)
    LocalFree((HLOCAL)pACL);
  if (pAbsoluteSD)
    LocalFree((HLOCAL)pAbsoluteSD);

  return hr;
}

#define MAX_DOMAIN_NAME_LENGTH    1024

// NOTE: caller needs to call FreeSid()/LocalFree() on the returned SID
// NOTE: this function only handles limited well-known SIDs.
HRESULT
GetAccountSID(
    IN  LPCTSTR lpszSystem,    // system where the account belongs to 
    IN  LPCTSTR lpszAccount,   // account
    OUT PSID    *ppSid,        // return SID of the account
    OUT BOOL    *pbWellKnownSID // return a BOOL, caller needs to call FreeSid() on a well-known SID
)
{
  if (!lpszAccount || !*lpszAccount || !ppSid || !pbWellKnownSID)
    return E_INVALIDARG;

  ASSERT(!*ppSid); // prevent memory leak
  *ppSid = NULL;

  SID_IDENTIFIER_AUTHORITY  SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
  SID_IDENTIFIER_AUTHORITY  SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
  PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority = NULL;
  DWORD dwRet = ERROR_SUCCESS;
  BYTE  Count = 0;
  DWORD dwRID[8];
  ZeroMemory(dwRID, sizeof(dwRID));

  *pbWellKnownSID = TRUE;

  CString cstrAccount = lpszAccount;
  cstrAccount.MakeLower();
  if ( ACCOUNT_ADMINISTRATORS == cstrAccount ) {
    // Administrators group
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 2;
    dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
    dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
  } else if ( ACCOUNT_EVERYONE == cstrAccount ) {
    // Everyone
    pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
    Count = 1;
    dwRID[0] = SECURITY_WORLD_RID;
  } else if ( ACCOUNT_SYSTEM == cstrAccount ) {
    // SYSTEM
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 1;
    dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
  } else if ( ACCOUNT_INTERACTIVE == cstrAccount ) {
    // INTERACTIVE
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 1;
    dwRID[0] = SECURITY_INTERACTIVE_RID;
  } else {
    *pbWellKnownSID = FALSE;
  }

  if (*pbWellKnownSID) {
    if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, Count, 
		                        dwRID[0], dwRID[1], dwRID[2], dwRID[3], 
		                        dwRID[4], dwRID[5], dwRID[6], dwRID[7], ppSid) )
    {
      dwRet = GetLastError();
    }
  } else {
    // get regular account sid
    DWORD        dwSidSize = 0;
    TCHAR        refDomain[MAX_DOMAIN_NAME_LENGTH];
    DWORD        refDomainSize = MAX_DOMAIN_NAME_LENGTH;
    SID_NAME_USE snu;

    LookupAccountName (lpszSystem, lpszAccount, *ppSid, &dwSidSize,
                       refDomain, &refDomainSize, &snu);
    dwRet = GetLastError();

    if (ERROR_INSUFFICIENT_BUFFER == dwRet)
    {
      dwRet = ERROR_SUCCESS;
      if ( !(*ppSid = (PSID)LocalAlloc(LPTR, dwSidSize)) )
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
      else
      {
        refDomainSize = MAX_DOMAIN_NAME_LENGTH;
        if (!LookupAccountName (lpszSystem, lpszAccount, *ppSid, &dwSidSize,
                                refDomain, &refDomainSize, &snu))
          dwRet = GetLastError();
      }
    }
  }

  if (ERROR_SUCCESS != dwRet)
  {
    if (*ppSid)
    {
      if (*pbWellKnownSID)
        FreeSid(*ppSid);
      else
        LocalFree((HLOCAL)*ppSid);
      *ppSid = NULL;
    }
  }

  return HRESULT_FROM_WIN32(dwRet);
}

///////////////////////////////////////////////////////
// class CShareSecurityInformation

CShareSecurityInformation::CShareSecurityInformation(PSECURITY_DESCRIPTOR pSelfRelativeSD)
: m_cRef(1), m_pDefaultDescriptor(pSelfRelativeSD)
{
  m_bDefaultSD = !pSelfRelativeSD;
}

CShareSecurityInformation::~CShareSecurityInformation()
{
  TRACE(_T("CShareSecurityInformation::~CShareSecurityInformation m_cRef=%d\n"), m_cRef);
  if (m_bDefaultSD && m_pDefaultDescriptor)
    LocalFree((HLOCAL)m_pDefaultDescriptor);
}

void 
CShareSecurityInformation::Initialize(
    IN LPCTSTR lpszComputerName,
    IN LPCTSTR lpszShareName,
    IN LPCTSTR lpszPageTitle
)
{
  m_cstrComputerName = lpszComputerName;
  m_cstrShareName = lpszShareName;
	m_cstrPageTitle = lpszPageTitle;
}

////////////////////////////////
// IUnknown methods
////////////////////////////////
STDMETHODIMP
CShareSecurityInformation::QueryInterface(REFIID riid, LPVOID *ppv)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
  {
    *ppv = this;
    m_cRef++;
    return S_OK;
  } else
  {
    *ppv = NULL;
    return E_NOINTERFACE;
  }
}

STDMETHODIMP_(ULONG)
CShareSecurityInformation::AddRef()
{
  return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CShareSecurityInformation::Release()
{
  if (--m_cRef == 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

////////////////////////////////
// ISecurityInformation methods
////////////////////////////////
STDMETHODIMP
CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo
)
{
  ASSERT(pObjectInfo);
  ASSERT(!IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

  pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_PAGE_TITLE | SI_RESET;
  pObjectInfo->hInstance = AfxGetResourceHandle();
  pObjectInfo->pszServerName = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrComputerName));
  pObjectInfo->pszObjectName = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrShareName));
  pObjectInfo->pszPageTitle = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrPageTitle));

  return S_OK;
}

STDMETHODIMP
CShareSecurityInformation::GetSecurity (
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    BOOL fDefault
)
{
  ASSERT(DACL_SECURITY_INFORMATION == RequestedInformation);
  ASSERT(ppSecurityDescriptor);
  TRACE(_T("GetSecurity RequestedInformation=%d fDefault=%d\n"), RequestedInformation, fDefault);

  *ppSecurityDescriptor = NULL;

  if (NULL == m_pDefaultDescriptor)
  {
    HRESULT hr = GetDefaultSD(&m_pDefaultDescriptor);
    if (FAILED(hr))
      return hr;
  }

  // We have to pass back a LocalAlloc'ed copy of the SD
  return MakeSelfRelativeCopy(m_pDefaultDescriptor, ppSecurityDescriptor);
}

STDMETHODIMP
CShareSecurityInformation::SetSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
)
{
  ASSERT(DACL_SECURITY_INFORMATION == SecurityInformation);
  TRACE(_T("SetSecurity SecurityInformation=%d\n"), SecurityInformation);

  PSECURITY_DESCRIPTOR pNewSD = NULL;
  HRESULT hr = MakeSelfRelativeCopy(pSecurityDescriptor, &pNewSD);
  if (SUCCEEDED(hr))
    ((CShrwizApp *)AfxGetApp())->SetSecurity(pNewSD);
  return hr;
}

SI_ACCESS siShareAccesses[] =
{
  { &GUID_NULL, 
    FILE_ALL_ACCESS, 
    MAKEINTRESOURCE(IDS_SHAREPERM_ALL), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_CHANGE), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_READ), 
    SI_ACCESS_GENERAL }
};

#define iShareDefAccess       2   // index of value in array siShareAccesses
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)          (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP
CShareSecurityInformation::GetAccessRights(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
)
{
  ASSERT(ppAccess);
  ASSERT(pcAccesses);
  ASSERT(piDefaultAccess);

  *ppAccess = siShareAccesses;
  *pcAccesses = ARRAYSIZE(siShareAccesses);
  *piDefaultAccess = iShareDefAccess;

  return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
  FILE_GENERIC_READ,
  FILE_GENERIC_WRITE,
  FILE_GENERIC_EXECUTE,
  FILE_ALL_ACCESS
};

STDMETHODIMP
CShareSecurityInformation::MapGeneric(
    const GUID  *pguidObjectType,
    UCHAR       *pAceFlags,
    ACCESS_MASK *pMask
)
{
  ASSERT(pMask);

  MapGenericMask(pMask, &ShareMap);

  return S_OK;
}

STDMETHODIMP 
CShareSecurityInformation::GetInheritTypes (
    PSI_INHERIT_TYPE  *ppInheritTypes,
    ULONG             *pcInheritTypes
)
{
  return E_NOTIMPL;
}

STDMETHODIMP 
CShareSecurityInformation::PropertySheetPageCallback(
    HWND          hwnd, 
    UINT          uMsg, 
    SI_PAGE_TYPE  uPage
)
{
  return S_OK;
}

HRESULT 
CShareSecurityInformation::GetDefaultSD(
    OUT PSECURITY_DESCRIPTOR  *ppsd
)
{
  CPermEntry permEntry;
  HRESULT hr = permEntry.Initialize(NULL, ACCOUNT_EVERYONE, SHARE_PERM_READ_ONLY);
  if (SUCCEEDED(hr))
    hr = BuildSecurityDescriptor(&permEntry, 1, ppsd);
  return hr;
}

HRESULT 
CShareSecurityInformation::MakeSelfRelativeCopy(
    IN  PSECURITY_DESCRIPTOR  psdOriginal,
    OUT PSECURITY_DESCRIPTOR  *ppsdNew
)
{
  ASSERT(psdOriginal);
  ASSERT(ppsdNew);

  *ppsdNew = NULL;

  DWORD dwErr = 0;
  PSECURITY_DESCRIPTOR psdSelfRelative = NULL;

  do { // false loop

    DWORD cbSD = ::GetSecurityDescriptorLength(psdOriginal);
    if ( !(psdSelfRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, cbSD)) )
    {
      dwErr = ::GetLastError();
      break;
    }

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL sdc = 0;
    DWORD dwRevision = 0;
    if ( !::GetSecurityDescriptorControl(psdOriginal, &sdc, &dwRevision) )
    {
      dwErr = ::GetLastError();
      break;
    }

    if (sdc & SE_SELF_RELATIVE)
    {
      ::memcpy(psdSelfRelative, psdOriginal, cbSD);
    } else if ( !::MakeSelfRelativeSD(psdOriginal, psdSelfRelative, &cbSD) )
    {
      dwErr = ::GetLastError();
      break;
    }

    *ppsdNew = psdSelfRelative;

  } while (FALSE);

  if (dwErr && psdSelfRelative)
    LocalFree((HLOCAL)psdSelfRelative);
 
  return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}

///////////////////////////////////////////////////////
// class CFileSecurityDataObject

CFileSecurityDataObject::CFileSecurityDataObject()
: m_cRef(1)
{
}

CFileSecurityDataObject::~CFileSecurityDataObject()
{
  TRACE(_T("CFileSecurityDataObject::~CFileSecurityDataObject m_cRef=%d\n"), m_cRef);
}

void
CFileSecurityDataObject::Initialize(
    IN LPCTSTR lpszComputerName,
    IN LPCTSTR lpszFolder
)
{
  m_cstrComputerName = lpszComputerName;
  m_cstrFolder = lpszFolder;

  GetFullPath(lpszComputerName, lpszFolder, m_cstrPath);

  m_cfIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
}

////////////////////////////////
// IUnknown methods
////////////////////////////////
STDMETHODIMP
CFileSecurityDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
  {
    *ppv = this;
    m_cRef++;
    return S_OK;
  } else
  {
    *ppv = NULL;
    return E_NOINTERFACE;
  }
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::AddRef()
{
  return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::Release()
{
  if (--m_cRef == 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

STDMETHODIMP
CFileSecurityDataObject::GetData(
    FORMATETC __RPC_FAR * pFormatEtcIn,
    STGMEDIUM __RPC_FAR * pMedium
)
{
  ASSERT(pFormatEtcIn);
  ASSERT(pMedium);

  if (m_cfIDList != pFormatEtcIn->cfFormat)
    return DV_E_FORMATETC;

  LPITEMIDLIST      pidl = NULL;
  LPITEMIDLIST      pidlR = NULL;
  HRESULT           hr = GetFolderPIDList(&pidl);
  if (SUCCEEDED(hr))
  {
    pidlR = ILClone(ILFindLastID(pidl));  // relative IDList
    ILRemoveLastID(pidl);                 // folder IDList

    int  cidl = 1;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbFolder = ILGetSize(pidl);
    UINT cbRelative = ILGetSize(pidlR);
    UINT cbTotal = offset + cbFolder + cbRelative;

    HGLOBAL hGlobal = ::GlobalAlloc (GPTR, cbTotal);
    if ( hGlobal )
    {
      LPIDA pida = (LPIDA)hGlobal;

      pida->cidl = cidl;
      pida->aoffset[0] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidl, cbFolder);

      offset += cbFolder;
      pida->aoffset[1] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidlR, cbRelative);

      pMedium->hGlobal = hGlobal;
    } else
    {
      hr = E_OUTOFMEMORY;
    }

    if (pidl)
      ILFree(pidl);
    if (pidlR)
      ILFree(pidlR);
  }

  return hr;
}

HRESULT
CFileSecurityDataObject::GetFolderPIDList(
    OUT LPITEMIDLIST *ppidl
)
{
  ASSERT(!m_cstrPath.IsEmpty());
  ASSERT(ppidl);
  ASSERT(!*ppidl);  // prevent memory leak

  *ppidl = ILCreateFromPath(m_cstrPath);

  return ((*ppidl) ? S_OK : E_FAIL);
}

///////////////////////////////////////////////
// File security

// Security Shell extension CLSID - {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_ShellExtSecurity =
 {0x1F2E5C40, 0x9550, 0x11CE, {0x99, 0xD2, 0x0, 0xAA, 0x0, 0x6E, 0x08, 0x6C}};

BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM lParam)
{
  // pass out the created page handle
  *((HPROPSHEETPAGE *)lParam) = hPage;

  return TRUE;
}

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
)
{
  ASSERT(phOutPage);
  ASSERT(pDataObject);

  IShellExtInit *piShellExtInit = NULL;
  HRESULT hr = CoCreateInstance(CLSID_ShellExtSecurity,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IShellExtInit,
                        (void **)&piShellExtInit);
  if (SUCCEEDED(hr))
  {
    hr = piShellExtInit->Initialize(NULL, pDataObject, 0);
    if (SUCCEEDED(hr))
    {
      IShellPropSheetExt *piSPSE = NULL;
      hr = piShellExtInit->QueryInterface(IID_IShellPropSheetExt, (void **)&piSPSE);
      if (SUCCEEDED(hr))
      {
        hr = piSPSE->AddPages(AddPageProc, (LPARAM)phOutPage);
        piSPSE->Release();
      }
    }
    piShellExtInit->Release();
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\sfm.h ===
#ifndef _SFM_H_
#define _SFM_H_

BOOL
SFMShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
);

DWORD
SFMCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN HINSTANCE              hLib
);

#endif // _SFM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shrwiz.rc
//
#define IDS_WIZARD_TITLE                1
#define IDS_CANNOT_GET_LOCAL_COMPUTER   2
#define IDS_CANNOT_CONTACT_COMPUTER     3
#define IDS_APP_USAGE                   4
#define IDS_TEXT_REQUIRED               5
#define IDS_INVALID_FOLDER              6
#define IDS_DUPLICATE_SHARENAME         7
#define IDS_FAILED_TO_VALIDATE_FOLDER   8
#define IDS_CLIENT_REQUIRED             9
#define IDS_BROWSE_FOLDER               10
#define IDS_CANNOT_BROWSE_FOLDER        11
#define IDS_FAILED_TO_GET_SD            12
#define IDS_INVALID_SHARENAME           13
#define IDS_SMB_CLIENTS                 14
#define IDS_DUPLICATE_SMB_SHARENAME     15
#define IDS_DUPLICATE_SFM_SHARENAME     16
#define IDS_ISDOSDEVICENAME             17
#define IDS_BROWSE_FOLDER_INVALID       18
#define IDS_PATH_NOT_FOLDER             20
#define IDS_CREATE_NEW_DIR              21
#define IDS_FAILED_TO_CREATE_NEW_DIR    22
#define IDS_SHAREPERM_ALL               24
#define IDS_SHAREPERM_CHANGE            25
#define IDS_SHAREPERM_READ              26
#define IDS_SHARE_PERMISSIONS           27
#define IDS_FAILED_TO_CREATE_ACLUI      28
#define IDS_CUSTOM_PERM                 29
#define IDS_CMDLINE_PARAMS              30
#define IDS_FOLDER_LABEL                31
#define IDS_SHARENAME_LABEL             32
#define IDS_MACSHARENAME_LABEL          33
#define IDS_INVALID_DRIVE               34
#define IDS_FAILED_TO_GETINFO_FOLDER    35
#define IDS_CSC_MANUAL                  37
#define IDS_CSC_AUTOMATIC               38
#define IDS_CSC_NOCACHING               39
#define IDS_NEW_FINISHBUTTONTEXT        40
#define IDS_HEADERTITLE_FOLDER          41
#define IDS_HEADERSUBTITLE_FOLDER       42
#define IDS_HEADERTITLE_CLIENT          43
#define IDS_HEADERSUBTITLE_CLIENT       44
#define IDS_HEADERTITLE_PERM            45
#define IDS_HEADERSUBTITLE_PERM         46
#define IDS_WARNING_WHOLE_VOLUME        47
#define IDS_SUMMARY_NOMAC               48
#define IDS_SUMMARY_ONLYSMB             49
#define IDS_SUMMARY_ONLYSFM             50
#define IDS_SUMMARY_BOTH                51
#define IDS_TITLE_SUCCESS               52
#define IDS_TITLE_PARTIAL_FAILURE       53
#define IDS_TITLE_FAILURE               54
#define IDS_STATUS_SUCCESS              55
#define IDS_STATUS_PARTIAL_FAILURE_SFM  56
#define IDS_STATUS_PARTIAL_FAILURE_SMB  57
#define IDS_STATUS_FAILURE_NOMAC        58
#define IDS_STATUS_FAILURE_ONLYSMB      59
#define IDS_STATUS_FAILURE_ONLYSFM      60
#define IDS_STATUS_FAILURE_BOTH         61
#define IDS_SBS_PERM2                   62
#define IDS_SBS_PERM3                   63
#define IDD_SHRWIZ_COMPUTER             101
#define IDD_SHRWIZ_FOLDER0              102
#define IDD_SHRWIZ_FOLDER               103
#define IDD_SHRWIZ_PERM                 104
#define IDR_MAINFRAME                   128
#define IDD_NO_SHARE_PERMISSIONS        129
#define IDB_WATERMARK                   131
#define IDB_HEADER                      132
#define IDD_WELCOME                     134
#define IDD_FINISH                      135
#define IDC_COMPUTER                    1000
#define IDC_FOLDER                      1001
#define IDC_SHARENAME                   1002
#define IDC_SHAREDESCRIPTION            1003
#define IDC_CHECK_MS                    1004
#define IDC_CHECK_MAC                   1006
#define IDC_MACSHARENAME                1007
#define IDC_BROWSEFOLDER                1008
#define IDC_RADIO_PERM1                 1009
#define IDC_RADIO_PERM2                 1010
#define IDC_RADIO_PERM3                 1011
#define IDC_RADIO_PERM4                 1012
#define IDC_PERM_CUSTOM                 1013
#define IDC_WELCOME                     1016
#define IDC_UNC                         1017
#define IDC_CSC_LABEL                   1018
#define IDC_CSC                         1019
#define IDC_CSC_CHANGE                  1020
#define IDC_PERM_HELPLINK               1021
#define IDC_FINISH_TITLE                1025
#define IDC_FINISH_STATUS               1026
#define IDC_FINISH_SUMMARY              1027
#define IDC_MORE_SHARES                 1028

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\aclpage.h ===
#ifndef __ACLPAGE_H__
#define __ACLPAGE_H__

#include "aclui.h"

#define DONT_WANT_SHELLDEBUG
#include "shlobj.h"     // LPITEMIDLIST
#include "shlobjp.h"

#define SHARE_PERM_FULL_CONTROL       FILE_ALL_ACCESS
#define SHARE_PERM_READ_ONLY          (FILE_GENERIC_READ | FILE_EXECUTE)
#define SHARE_PERM_READ_WRITE         (FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE)
#define ACCOUNT_EVERYONE              _T("everyone")
#define ACCOUNT_ADMINISTRATORS        _T("administrators")
#define ACCOUNT_SBSFOLDEROPERATORS    _T("SBS Folder Operators") // non-localizable according to SBS dev AaronN
#define ACCOUNT_SYSTEM                _T("system")
#define ACCOUNT_INTERACTIVE           _T("interactive")

/////////////////////////////////////////////////////////////////////////////
// CPermEntry

class CPermEntry
{
public:
  CPermEntry();
  ~CPermEntry();
  HRESULT Initialize(
      IN LPCTSTR  lpszSystem,
      IN LPCTSTR  lpszAccount,
      IN DWORD    dwAccessMask
  );
  UINT GetLengthSid();
  HRESULT AddAccessAllowedAce(OUT PACL pACL);

protected:
  CString m_cstrSystem;
  CString m_cstrAccount;
  DWORD   m_dwAccessMask;
  PSID    m_pSid;
  BOOL    m_bWellKnownSid;
};

HRESULT
BuildSecurityDescriptor(
    IN  CPermEntry            *pPermEntry, // an array of CPermEntry
    IN  UINT                  cEntries,    // number of entries in the array
    OUT PSECURITY_DESCRIPTOR  *ppSelfRelativeSD // return a security descriptor in self-relative form
);

HRESULT
GetAccountSID(
    IN  LPCTSTR lpszSystem,    // system where the account belongs to 
    IN  LPCTSTR lpszAccount,   // account
    OUT PSID    *ppSid,        // return SID of the account
    OUT BOOL    *pbWellKnownSID // return a BOOL, caller needs to call FreeSid() on a well-known SID
);

/////////////////////////////////////////////////////////////////////////////
// CShareSecurityInformation

class CShareSecurityInformation : public ISecurityInformation
{
private:
  ULONG   m_cRef; 
	CString m_cstrComputerName;
	CString m_cstrShareName;
  CString m_cstrPageTitle;
  PSECURITY_DESCRIPTOR m_pDefaultDescriptor;
  BOOL    m_bDefaultSD;

public:
  CShareSecurityInformation(PSECURITY_DESCRIPTOR pSelfRelativeSD);
  ~CShareSecurityInformation();

  void Initialize(
      IN LPCTSTR lpszComputerName,
      IN LPCTSTR lpszShareName,
      IN LPCTSTR lpszPageTitle
  );

  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
  STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                          PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                          BOOL fDefault );
  STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                          PSECURITY_DESCRIPTOR pSecurityDescriptor );
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  );

protected:
  HRESULT GetDefaultSD(
      OUT PSECURITY_DESCRIPTOR  *ppsd
  );

  HRESULT MakeSelfRelativeCopy(
      IN  PSECURITY_DESCRIPTOR  psdOriginal,
      OUT PSECURITY_DESCRIPTOR  *ppsdNew
  );
};

/////////////////////////////////////////////////////////////////////////////
// CFileSecurityDataObject

class CFileSecurityDataObject: public IDataObject
{
protected:
  UINT m_cRef;
  CString m_cstrComputerName;
  CString m_cstrFolder;
  CString m_cstrPath;
  CLIPFORMAT m_cfIDList;

public:
  CFileSecurityDataObject();
  ~CFileSecurityDataObject();
  void Initialize(
      IN LPCTSTR lpszComputerName,
      IN LPCTSTR lpszFolder
  );

  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // *** IDataObject methods ***
  STDMETHOD(GetData)(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
  inline STDMETHOD(GetDataHere)(LPFORMATETC pFE, LPSTGMEDIUM pSTM) {return E_NOTIMPL;}
  inline STDMETHOD(QueryGetData)(LPFORMATETC pFE) {return E_NOTIMPL;}
  inline STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pFEIn, LPFORMATETC pFEOut) {return E_NOTIMPL;}
  inline STDMETHOD(SetData)(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease) {return E_NOTIMPL;}
  inline STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnum) {return E_NOTIMPL;}
  inline STDMETHOD(DAdvise)(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink, LPDWORD pdwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(DUnadvise)(DWORD dwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnum) {return E_NOTIMPL;}

  HRESULT GetFolderPIDList(OUT LPITEMIDLIST *ppidl);
};

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
);

#endif // __ACLPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\sfm.cpp ===
// sfm.cpp : Implementation of shares for Apple Macintosh

#include "stdafx.h"
#include <macfile.h>

#define FUNCNAME_AFPADMINCONNECT        "AfpAdminConnect"
#define FUNCNAME_AFPADMINDISCONNECT     "AfpAdminDisconnect"
#define FUNCNAME_AFPADMINVOLUMEGETINFO  "AfpAdminVolumeGetInfo"
#define FUNCNAME_AFPADMINVOLUMEADD      "AfpAdminVolumeAdd"
#define FUNCNAME_AFPADMINBUFFERFREE     "AfpAdminBufferFree"

typedef DWORD (CALLBACK *PAFPADMINCONNECT)(LPTSTR, PAFP_SERVER_HANDLE);
typedef VOID  (CALLBACK *PAFPADMINDISCONNECT)(AFP_SERVER_HANDLE);
typedef DWORD (CALLBACK *PAFPADMINVOLUMEGETINFO)(AFP_SERVER_HANDLE, LPWSTR, LPBYTE*);
typedef DWORD (CALLBACK *PAFPADMINVOLUMEADD)(AFP_SERVER_HANDLE, LPBYTE);
typedef DWORD (CALLBACK *PAFPADMINBUFFERFREE)(LPVOID);

BOOL
SFMShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
)
{
  BOOL                  bReturn = FALSE;
  DWORD                 dwRet = NERR_Success;
  PAFPADMINCONNECT       pAfpAdminConnect = NULL;
  PAFPADMINVOLUMEGETINFO pAfpAdminVolumeGetInfo = NULL;
  PAFPADMINBUFFERFREE    pAfpAdminBufferFree = NULL;
  PAFPADMINDISCONNECT    pAfpAdminDisconnect = NULL;

  if ( (pAfpAdminConnect = (PAFPADMINCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINCONNECT)) &&
       (pAfpAdminVolumeGetInfo = (PAFPADMINVOLUMEGETINFO)GetProcAddress(hLib, FUNCNAME_AFPADMINVOLUMEGETINFO)) &&
       (pAfpAdminBufferFree = (PAFPADMINBUFFERFREE)GetProcAddress(hLib, FUNCNAME_AFPADMINBUFFERFREE)) &&
       (pAfpAdminDisconnect = (PAFPADMINDISCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINDISCONNECT)) )
  {
    AFP_SERVER_HANDLE hAfpServerHandle = NULL;
    dwRet = (*pAfpAdminConnect)(
                const_cast<LPTSTR>(lpszServerName), 
                &hAfpServerHandle);
    if (NERR_Success == dwRet)
    {
      PAFP_VOLUME_INFO pInfo = NULL;
      dwRet = (*pAfpAdminVolumeGetInfo)(
                    hAfpServerHandle, 
                    const_cast<LPTSTR>(lpszShareName), 
                    (LPBYTE*)&pInfo);

      if (NERR_Success == dwRet)
      {
        bReturn = TRUE;
        (*pAfpAdminBufferFree)(pInfo);
      }

      (*pAfpAdminDisconnect)(hAfpServerHandle);
    }
  }

  return bReturn;
}

DWORD
SFMCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN HINSTANCE              hLib
)
{
  DWORD                dwRet = NERR_Success;
  PAFPADMINCONNECT     pAfpAdminConnect = NULL;
  PAFPADMINDISCONNECT  pAfpAdminDisconnect = NULL;
  PAFPADMINVOLUMEADD   pAfpAdminVolumeAdd = NULL;

  if (!(pAfpAdminConnect = (PAFPADMINCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINCONNECT)) ||
      !(pAfpAdminDisconnect = (PAFPADMINDISCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINDISCONNECT)) ||
      !(pAfpAdminVolumeAdd = (PAFPADMINVOLUMEADD)GetProcAddress(hLib, FUNCNAME_AFPADMINVOLUMEADD)))
  {
    dwRet = GetLastError();
  } else
  {
    AFP_SERVER_HANDLE   hAfpServerHandle = NULL;
    dwRet = (*pAfpAdminConnect)(
                const_cast<LPTSTR>(lpszServer), 
                &hAfpServerHandle);
    if (NERR_Success == dwRet)
    {
      AFP_VOLUME_INFO   AfpVolumeInfo;
      ZeroMemory(&AfpVolumeInfo, sizeof(AfpVolumeInfo));
      AfpVolumeInfo.afpvol_name = const_cast<LPTSTR>(lpszShareName);
      AfpVolumeInfo.afpvol_max_uses = AFP_VOLUME_UNLIMITED_USES;
      AfpVolumeInfo.afpvol_props_mask = AFP_VOLUME_READONLY;
      AfpVolumeInfo.afpvol_path = const_cast<LPTSTR>(lpszSharePath);

      dwRet = (*pAfpAdminVolumeAdd)(hAfpServerHandle, (LPBYTE)&AfpVolumeInfo);

      (*pAfpAdminDisconnect)(hAfpServerHandle);
    }
  }

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\shrwiz.cpp ===
// shrwiz.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wizFirst.h"
#include "wizDir.h"
#include "wizClnt.h"
#include "wizPerm.h"
#include "wizLast.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp

BEGIN_MESSAGE_MAP(CShrwizApp, CWinApp)
	//{{AFX_MSG_MAP(CShrwizApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
//	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp construction

CShrwizApp::CShrwizApp()
{
  m_hTitleFont = NULL;

  // filled in by initialization routine in shrwiz.cpp
  m_cstrTargetComputer.Empty();
  m_cstrUNCPrefix.Empty();
  m_bIsLocal = FALSE;
  m_bServerSBS = FALSE;
  m_bServerSFM = FALSE;
  m_bCSC = FALSE;
  m_hLibNTDLL = NULL;
  m_pfnIsDosDeviceName = NULL;
  m_hLibSFM = NULL;
  m_pWizard = NULL;

  // filled in by the folder page
  m_cstrFolder.Empty();

  // filled in by the client page
  m_cstrShareName.Empty();
  m_cstrShareDescription.Empty();
  m_cstrMACShareName.Empty();
  m_bSMB = TRUE;
  m_bSFM = FALSE;
  m_dwCSCFlag = CSC_CACHE_MANUAL_REINT;

  // filled in by the permission page
  m_pSD = NULL;
  m_cstrFinishTitle.Empty();
  m_cstrFinishStatus.Empty();
  m_cstrFinishSummary.Empty();

  m_bFolderPathPageInitialized = FALSE;
  m_bShareNamePageInitialized = FALSE;
  m_bPermissionsPageInitialized = FALSE;
}

CShrwizApp::~CShrwizApp()
{
  TRACE(_T("CShrwizApp::~CShrwizApp\n"));

  if (m_hLibNTDLL)
    FreeLibrary(m_hLibNTDLL);

  if (m_hLibSFM)
    FreeLibrary(m_hLibSFM);

  if (m_pSD)
    LocalFree((HLOCAL)m_pSD);
}

void
CShrwizApp::Reset()
{
  // filled in by the folder page
  m_cstrFolder.Empty();

  // filled in by the client page
  m_cstrShareName.Empty();
  m_cstrShareDescription.Empty();
  m_cstrMACShareName.Empty();
  m_bSMB = TRUE;
  m_bSFM = FALSE;
  m_dwCSCFlag = CSC_CACHE_MANUAL_REINT;

  // filled in by the permission page
  if (m_pSD)
  {
    LocalFree((HLOCAL)m_pSD);
    m_pSD = NULL;
  }
  m_cstrFinishTitle.Empty();
  m_cstrFinishStatus.Empty();

  m_bFolderPathPageInitialized = FALSE;
  m_bShareNamePageInitialized = FALSE;
  m_bPermissionsPageInitialized = FALSE;

  m_pWizard->PostMessage(PSM_SETCURSEL, 1);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CShrwizApp object

CShrwizApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp initialization

BOOL CShrwizApp::InitInstance()
{
    InitCommonControls();         // use XP theme-aware common controls

	Enable3dControls();			// Call this when using MFC in a shared DLL

    if (!GetTargetComputer())
        return FALSE;

    m_pMainWnd = NULL;

    HBITMAP hbmWatermark = NULL;
    HBITMAP hbmHeader = NULL;

    do {
        hbmWatermark = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_WATERMARK), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
        if (!hbmWatermark)
            break;

        hbmHeader = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_HEADER), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
        if (!hbmHeader)
            break;

        m_pWizard = new CPropertySheetEx(IDS_WIZARD_TITLE, NULL, 0, hbmWatermark, NULL, hbmHeader);
        if (!m_pWizard)
            break;

        CWizWelcome welcomePage;
        CWizFolder  folderPage;
        CWizClient0 clientPage0;
        CWizClient  clientPage;
        CWizPerm    permPage;
        CWizFinish  finishPage;

        //Set up the font for the titles on the welcome page
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        lstrcpy(TitleLogFont.lfFaceName, _T("Verdana Bold"));

        HDC hdc = GetDC(NULL); //gets the screen DC
        INT FontSize = 12;
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
        m_hTitleFont = CreateFontIndirect(&TitleLogFont);
        ReleaseDC(NULL, hdc);

        if (!m_hTitleFont)
            break;

        // add wizard pages
        m_pWizard->AddPage(&welcomePage);
        m_pWizard->AddPage(&folderPage);
        if (m_bServerSFM)
            m_pWizard->AddPage(&clientPage);
        else
            m_pWizard->AddPage(&clientPage0);
        m_pWizard->AddPage(&permPage);
        m_pWizard->AddPage(&finishPage);

        m_pWizard->SetWizardMode();

        (m_pWizard->m_psh).dwFlags |= (PSH_WIZARD97 | PSH_USEHBMWATERMARK  | PSH_USEHBMHEADER);

        // start the wizard
        m_pWizard->DoModal();

    } while (FALSE);

    if (m_hTitleFont)
        DeleteObject(m_hTitleFont);

    if (m_pWizard)
    {
        delete m_pWizard;
        m_pWizard = NULL;
    }

    if (hbmHeader)
        DeleteObject(hbmHeader);

    if (hbmWatermark)
        DeleteObject(hbmWatermark);

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

// ProductSuite:
// Key: HKLM\SYSTEM\CurrentControlSet\Control\ProductOptions
// Value: ProductSuite
// Type: REG_MULTI_SZ
// Data: for SBS, it by default contains 2 strings "Small Business" and "Small Business(Restricted)" 

#define KEY_PRODUCT_SUITE       _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions")
#define VALUE_PRODUCT_SUITE     _T("ProductSuite")
#define SBS_PRODUCT_SUITE       _T("Small Business")

BOOL IsServerSBS(IN LPCTSTR pszComputer)
{
    BOOL bSBS = FALSE;

    HKEY hkeyMachine = HKEY_LOCAL_MACHINE;
    DWORD dwErr = ERROR_SUCCESS;

    if (pszComputer && *pszComputer)
    {
        dwErr = RegConnectRegistry(pszComputer, HKEY_LOCAL_MACHINE, &hkeyMachine);
        if (ERROR_SUCCESS != dwErr)
            return bSBS;
    }

    HKEY hkey = NULL;
    dwErr = RegOpenKeyEx(hkeyMachine, KEY_PRODUCT_SUITE, 0, KEY_READ, &hkey ) ;
    if (ERROR_SUCCESS == dwErr)
    {
        DWORD cbData = 0;
        dwErr = RegQueryValueEx(hkey, VALUE_PRODUCT_SUITE, 0, NULL, NULL, &cbData);
        if (ERROR_SUCCESS == dwErr)
        {
            LPBYTE pBuffer = (LPBYTE)calloc(cbData, sizeof(BYTE));
            if (pBuffer)
            {
                DWORD dwType = REG_MULTI_SZ;
                dwErr = RegQueryValueEx(hkey, VALUE_PRODUCT_SUITE, 0, &dwType, pBuffer, &cbData);
                if (ERROR_SUCCESS == dwErr && REG_MULTI_SZ == dwType)
                {
                    // pBuffer is pointing at an array of null-terminated strings, terminated by two null characters.
                    PTSTR p = (PTSTR)pBuffer;
                    while (*p)
                    {
                        if (!_tcsncmp(p, SBS_PRODUCT_SUITE, lstrlen(SBS_PRODUCT_SUITE)))
                        {
                            bSBS = TRUE;
                            break;
                        }

                        p += lstrlen(p) + 1; // point to the next null-terminated string
                    }
                }

                free(pBuffer);
            }

        }

        RegCloseKey(hkey);
    }

    if (pszComputer && *pszComputer)
        RegCloseKey(hkeyMachine);

    return bSBS;
}

BOOL
CShrwizApp::GetTargetComputer()
{
  BOOL bReturn = FALSE;

  m_cstrTargetComputer.Empty();
  m_cstrUNCPrefix.Empty();
  m_bIsLocal = FALSE;

  do { // false loop

    CString cstrCmdLine = m_lpCmdLine;
    cstrCmdLine.TrimLeft();
    cstrCmdLine.TrimRight();
    if (cstrCmdLine.IsEmpty() || cstrCmdLine == _T("/s"))
    { // local computer
      TCHAR szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
      DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      if (GetComputerName(szBuffer, &dwSize))
      {
        m_cstrTargetComputer = szBuffer;
        m_bIsLocal = TRUE;
      } else
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, GetLastError(), IDS_CANNOT_GET_LOCAL_COMPUTER);
        break;
      }
    } else if (_T("/s") == cstrCmdLine.Left(2))
    {
      if (_istspace(cstrCmdLine.GetAt(2)))
      {
        cstrCmdLine = cstrCmdLine.Mid(3);
        cstrCmdLine.TrimLeft();
        if ( _T("\\\\") == cstrCmdLine.Left(2) )
          m_cstrTargetComputer = cstrCmdLine.Mid(2);
        else
          m_cstrTargetComputer = cstrCmdLine;
      }
    }

    if (m_cstrTargetComputer.IsEmpty())
    {
      CString cstrAppName = AfxGetAppName();
      CString cstrUsage;
      cstrUsage.FormatMessage(IDS_CMDLINE_PARAMS, cstrAppName);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_APP_USAGE, cstrUsage);
      break;
    } else
    {
      SERVER_INFO_101 *pInfo = NULL;
      DWORD dwRet = ::NetServerGetInfo(
        const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrTargetComputer)), 101, (LPBYTE*)&pInfo);
      if (NERR_Success == dwRet)
      {
        if ((pInfo->sv101_version_major & MAJOR_VERSION_MASK) >= 5)
        {
            m_bCSC = TRUE;

            m_bServerSBS = IsServerSBS(static_cast<LPCTSTR>(m_cstrTargetComputer));

            // we compile this wizard with UNICODE defined.
#ifdef UNICODE
            // load ntdll.
            m_hLibNTDLL = ::LoadLibrary (_T("ntdll.dll"));
            if ( m_hLibNTDLL )
            {
                m_pfnIsDosDeviceName = (PfnRtlIsDosDeviceName_U)::GetProcAddress(m_hLibNTDLL, "RtlIsDosDeviceName_U");
            }
#endif // UNICODE
        }

        m_bServerSFM = (pInfo->sv101_type & SV_TYPE_AFP) &&
                        (m_hLibSFM = LoadLibrary(_T("sfmapi.dll")));

        NetApiBufferFree(pInfo);

        if (!m_bIsLocal)
          m_bIsLocal = IsLocalComputer(m_cstrTargetComputer);

        bReturn = TRUE;
      } else
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, dwRet, IDS_CANNOT_CONTACT_COMPUTER, m_cstrTargetComputer);
        break;
      }
    }
  } while (0);

    if (!bReturn)
    {
        m_cstrTargetComputer.Empty();
    } else
    {
        m_cstrUNCPrefix = _T("\\\\");
        m_cstrUNCPrefix += m_cstrTargetComputer;
        m_cstrUNCPrefix += _T("\\");
    }

  return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\shrwiz.h ===
// shrwiz.h : main header file for the SHRWIZ application
//

#if !defined(AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

// this is the user-defined message
#define WM_SETPAGEFOCUS WM_APP+2

/* nturtl.h
NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    PCWSTR DosFileName
    );
*/

typedef ULONG (*PfnRtlIsDosDeviceName_U)(PCWSTR DosFileName);

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp:
// See shrwiz.cpp for the implementation of this class
//

class CShrwizApp : public CWinApp
{
public:
	CShrwizApp();
	~CShrwizApp();
  void Reset();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShrwizApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
  BOOL GetTargetComputer();
  inline void SetSecurity(IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
  {
    if (m_pSD)
      LocalFree((HLOCAL)m_pSD);
    m_pSD = pSecurityDescriptor;
  }

  CPropertySheetEx *m_pWizard;
  HFONT m_hTitleFont;

  // filled in by initialization routine in shrwiz.cpp
  CString   m_cstrTargetComputer;
  CString   m_cstrUNCPrefix;
  BOOL      m_bIsLocal;
  BOOL      m_bServerSBS;
  BOOL      m_bServerSFM;
  BOOL      m_bCSC;   // CSC is available on NT5+
  HINSTANCE m_hLibSFM;  // sfmapi.dll

  HINSTANCE m_hLibNTDLL;// ntdll.dll
  PfnRtlIsDosDeviceName_U m_pfnIsDosDeviceName;

  // filled in by the folder page
  CString m_cstrFolder;

  // filled in by the client page
  CString m_cstrShareName;
  CString m_cstrShareDescription;
  CString m_cstrMACShareName;
  BOOL    m_bSMB;
  BOOL    m_bSFM;
  DWORD   m_dwCSCFlag;
  CString m_cstrFinishTitle;
  CString m_cstrFinishStatus;
  CString m_cstrFinishSummary;

  CString m_cstrNextButtonText;
  CString m_cstrFinishButtonText;

  BOOL m_bFolderPathPageInitialized;
  BOOL m_bShareNamePageInitialized;
  BOOL m_bPermissionsPageInitialized;

  // filled in by the permission page
  PSECURITY_DESCRIPTOR m_pSD;

	//{{AFX_MSG(CShrwizApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\smb.cpp ===
// smb.cpp : Implementation of shares for Microsoft Windows

#include "stdafx.h"
#include <lm.h>

BOOL
SMBShareNameExists(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszShareName
)
{
  BOOL                  bReturn = FALSE;
  DWORD                 dwRet = NERR_Success;
  SHARE_INFO_0          *pInfo = NULL;

  dwRet = NetShareGetInfo(
            const_cast<LPTSTR>(lpszServerName),
            const_cast<LPTSTR>(lpszShareName),
            0,
            (LPBYTE*)&pInfo);

  if (NERR_Success == dwRet)
  {
    bReturn = TRUE;
    NetApiBufferFree(pInfo);
  }

  return bReturn;
}

DWORD
SMBCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszShareComment,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD
)
{
  SHARE_INFO_502 sInfo;

  ZeroMemory(&sInfo, sizeof(sInfo));
  sInfo.shi502_netname = const_cast<LPTSTR>(lpszShareName);
  sInfo.shi502_type = STYPE_DISKTREE;
  sInfo.shi502_remark = const_cast<LPTSTR>(lpszShareComment);
  sInfo.shi502_max_uses = -1;
  sInfo.shi502_path = const_cast<LPTSTR>(lpszSharePath);
  sInfo.shi502_security_descriptor = pSD;
        
  DWORD dwParamErr = 0;
  return NetShareAdd(const_cast<PTSTR>(lpszServer), 502, (LPBYTE)&sInfo, &dwParamErr);
}

DWORD
SMBSetCSC(
    IN LPCTSTR      lpszServer,
    IN LPCTSTR      lpszShare,
    IN DWORD        dwCSCFlag
    )
{
    SHARE_INFO_1005 shi1005;

    ZeroMemory( &shi1005, sizeof(shi1005) );
    shi1005.shi1005_flags = dwCSCFlag;

    DWORD dwDummy = 0;
    return NetShareSetInfo(const_cast<LPTSTR>(lpszServer), const_cast<LPTSTR>(lpszShare),
                            1005, (LPBYTE)&shi1005, &dwDummy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\smb.h ===
#ifndef _SMB_H_
#define _SMB_H_

BOOL
SMBShareNameExists(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszShareName
);

DWORD
SMBCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszShareComment,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD
);

DWORD
SMBSetCSC(
    IN LPCTSTR      lpszServer,
    IN LPCTSTR      lpszShare,
    IN DWORD        dwCSCFlag
);

#endif // _SMB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "lm.h"
#include "resource.h"		// main symbols
#include "utils.h"

#include "shrwiz.h"
#include "smb.h"
#include "sfm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\utils.cpp ===
// utils.cpp : Implementation of helper functions

#include "stdafx.h"
#include <dns.h>
#include <macfile.h>

HRESULT 
GetErrorMessageFromModule(
  IN  DWORD       dwError,
  IN  LPCTSTR     lpszDll,
  OUT LPTSTR      *ppBuffer
)
{
  if (0 == dwError || !lpszDll || !*lpszDll || !ppBuffer)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;

  HINSTANCE  hMsgLib = LoadLibrary(lpszDll);
  if (!hMsgLib)
    hr = HRESULT_FROM_WIN32(GetLastError());
  else
  {
    DWORD dwRet = ::FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        hMsgLib, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)ppBuffer, 0, NULL);

    if (0 == dwRet)
      hr = HRESULT_FROM_WIN32(GetLastError());

    FreeLibrary(hMsgLib);
  }

  return hr;
}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
)
{
  if (0 == i_dwError)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    {
      hr = GetErrorMessageFromModule((i_dwError & 0x0000ffff), _T("netmsg.dll"), &lpBuffer);
      if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr)
      {
        int iError = i_dwError;  // convert to a signed integer
        if (iError >= AFPERR_MIN && iError < AFPERR_BASE)
        { 
          // use a positive number to search sfmmsg.dll
          hr = GetErrorMessageFromModule(-iError, _T("sfmmsg.dll"), &lpBuffer);
        }
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    cstrErrorMsg = lpBuffer;
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll/sfmmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    cstrErrorMsg.Format(_T("0x%x"), i_dwError);
  }

  return S_OK;
}

void
GetDisplayMessageHelper(
  OUT CString&  cstrMsg,
  IN  DWORD     dwErr,      // error code
  IN  UINT      iStringId,  // string resource Id
  IN  va_list   *parglist)  // Optional arguments
{
  HRESULT hr = S_OK;
  CString cstrErrorMsg;

  if (dwErr)
    hr = GetErrorMessage(dwErr, cstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      if (dwErr)
      {
        cstrMsg = cstrErrorMsg;
      } else
      {
        cstrMsg = va_arg(*parglist, LPCTSTR);
      }
    }
    else
    {
      CString cstrString;
      cstrString.LoadString(iStringId);

      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        cstrString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        parglist);
      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        cstrMsg = lpBuffer;
        if (dwErr)
          cstrMsg += cstrErrorMsg;
  
        LocalFree(lpBuffer);
      }
    }
  }

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    cstrMsg.Format(_T("0x%x"), hr);
  }
}

void
GetDisplayMessage(
  OUT CString&  cstrMsg,
  IN  DWORD     dwErr,      // error code
  IN  UINT      iStringId,  // string resource Id
  ...)                  // Optional arguments
{
  va_list arglist;
  va_start(arglist, iStringId);
  GetDisplayMessageHelper(cstrMsg, dwErr, iStringId, &arglist);
  va_end(arglist);
}

int
DisplayMessageBox(
  IN HWND   hwndParent,
  IN UINT   uType,      // style of message box
  IN DWORD  dwErr,      // error code
  IN UINT   iStringId,  // string resource Id
  ...)                  // Optional arguments
{
  CString cstrCaption;
  CString cstrMsg;

  cstrCaption.LoadString(IDS_WIZARD_TITLE);

  va_list arglist;
  va_start(arglist, iStringId);
  GetDisplayMessageHelper(cstrMsg, dwErr, iStringId, &arglist);
  va_end(arglist);

  return ::MessageBox(hwndParent, cstrMsg, cstrCaption, uType);
}

// NOTE: this function only handles limited cases, e.g., no ip address
BOOL IsLocalComputer(IN LPCTSTR lpszComputer)
{
  if (!lpszComputer || !*lpszComputer)
    return TRUE;

  if ( _tcslen(lpszComputer) > 2 && *lpszComputer == _T('\\') && *(lpszComputer + 1) == _T('\\') )
    lpszComputer += 2;

  BOOL    bReturn = FALSE;
  DWORD   dwErr = 0;
  TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
  DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

 // 1st: compare against local Netbios computer name
  if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
  {
    dwErr = GetLastError();
  } else
  {
    bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
    if (!bReturn)
    { // 2nd: compare against local Dns computer name 
      dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
      if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
      else
        dwErr = GetLastError();
    }
  }

  if (dwErr)
    TRACE(_T("IsLocalComputer dwErr = %x\n"), dwErr);

  return bReturn;
}

void GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
)
{
  ASSERT(lpszDir && *lpszDir);

  if (IsLocalComputer(lpszServer))
  {
    cstrPath = lpszDir;
  } else
  {
    if (*lpszServer != _T('\\') || *(lpszServer + 1) != _T('\\'))
    {
      cstrPath = _T("\\\\");
      cstrPath += lpszServer;
    } else
    {
      cstrPath = lpszServer;
    }
    cstrPath += _T("\\");
    cstrPath += lpszDir;
    int i = cstrPath.Find(_T(':'));
    ASSERT(-1 != i);
    cstrPath.SetAt(i, _T('$'));
  }
}

// Purpose: verify if the specified drive belongs to a list of disk drives on the server
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
)
{
  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetServerDiskEnum(
                                const_cast<LPTSTR>(lpszServer),
                                0,
                                &pBuffer,        
                                -1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    LPTSTR pDrive = (LPTSTR)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if (_totupper(*pDrive) == _totupper(*lpszDrive))
      {
        hr = S_OK;
        break;
      }
      pDrive += 3;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}

// Purpose: is there a related admin $ share
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
)
{
  ASSERT(!IsLocalComputer(lpszServer));

  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetShareEnum( 
                                const_cast<LPTSTR>(lpszServer),
                                1,
                                &pBuffer,        
                                -1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    PSHARE_INFO_1 pShareInfo = (PSHARE_INFO_1)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if ( (pShareInfo->shi1_type & STYPE_SPECIAL) &&
           _tcslen(pShareInfo->shi1_netname) == 2 &&
           *(pShareInfo->shi1_netname + 1) == _T('$') &&
           _totupper(*(pShareInfo->shi1_netname)) == _totupper(*lpszDrive) )
      {
        hr = S_OK;
        break;
      }
      pShareInfo++;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
);

void
GetDisplayMessage(
  OUT CString&  cstrMsg,
	IN  DWORD     dwErr,
	IN  UINT      iStringId,
	...);

int
DisplayMessageBox(
	IN HWND   hwndParent,
	IN UINT   uType,
	IN DWORD  dwErr,
	IN UINT   iStringId,
	...);

BOOL IsLocalComputer(IN LPCTSTR lpszComputer);

void GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
);

HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
);

HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizclnt.cpp ===
// WizClnt.cpp : implementation file
//

#include "stdafx.h"
#include "WizClnt.h"
#include "icanon.h"
#include <macfile.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SHARE_NAME_LIMIT          NNLEN
#define SFM_SHARE_NAME_LIMIT      AFP_VOLNAME_LEN
#define SHARE_DESCRIPTION_LIMIT   MAXCOMMENTSZ
#define UNC_NAME_LIMIT            MAX_PATH

/////////////////////////////////////////////////////////////////////////////
// CWizClient0 property page

IMPLEMENT_DYNCREATE(CWizClient0, CPropertyPageEx)

CWizClient0::CWizClient0() : CPropertyPageEx(CWizClient0::IDD, 0, IDS_HEADERTITLE_CLIENT, IDS_HEADERSUBTITLE_CLIENT)
{
    //{{AFX_DATA_INIT(CWizClient0)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
    m_bCSC = pApp->m_bCSC;

    pApp->m_bSMB = TRUE;
    pApp->m_bSFM = FALSE;
}

CWizClient0::~CWizClient0()
{
}

void CWizClient0::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizClient0)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizClient0, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizClient0)
    ON_EN_CHANGE(IDC_SHARENAME, OnChangeSharename)
    ON_BN_CLICKED(IDC_CSC_CHANGE, OnCSCChange)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizClient0 message handlers

BOOL CWizClient0::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();
    
    GetDlgItem(IDC_SHARENAME)->SendMessage(EM_LIMITTEXT, SHARE_NAME_LIMIT, 0);
    GetDlgItem(IDC_UNC)->SendMessage(EM_LIMITTEXT, UNC_NAME_LIMIT, 0);
    GetDlgItem(IDC_SHAREDESCRIPTION)->SendMessage(EM_LIMITTEXT, SHARE_DESCRIPTION_LIMIT, 0);

    if (!m_bCSC)
    {
        GetDlgItem(IDC_CSC_LABEL)->EnableWindow(FALSE);
        SetDlgItemText(IDC_CSC, _T(""));
        GetDlgItem(IDC_CSC)->EnableWindow(FALSE);
        GetDlgItem(IDC_CSC_CHANGE)->EnableWindow(FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWizClient0::UpdateCSCString()
{
    if (m_bCSC)
    {
        CString cstrCSC;

        switch (m_dwCSCFlag & CSC_MASK)
        {
        case CSC_CACHE_MANUAL_REINT:
            cstrCSC.LoadString(IDS_CSC_MANUAL);
            break;
        case CSC_CACHE_AUTO_REINT:
        case CSC_CACHE_VDO:
            cstrCSC.LoadString(IDS_CSC_AUTOMATIC);
            break;
        case CSC_CACHE_NONE:
            cstrCSC.LoadString(IDS_CSC_NOCACHING);
            break;
        default:
            break;
        }
        
        SetDlgItemText(IDC_CSC, cstrCSC);
    }
}

typedef HRESULT (*PfnCacheSettingsDlg)(HWND hwndParent, DWORD & dwFlags);

void CWizClient0::OnCSCChange()
{
    HINSTANCE hInstance = ::LoadLibrary (_T("FileMgmt.dll"));
    if ( hInstance )
    {
        PfnCacheSettingsDlg pfn = (PfnCacheSettingsDlg)::GetProcAddress(hInstance, "CacheSettingsDlg");
        if (pfn)
        {
            pfn(m_hWnd, m_dwCSCFlag);
        }
        ::FreeLibrary(hInstance);
    }

    UpdateCSCString();
}

LRESULT CWizClient0::OnWizardNext() 
{
    CWaitCursor wait;
    Reset(); // init all related place holders

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);
    cstrShareName.TrimLeft();
    cstrShareName.TrimRight();
    if (cstrShareName.IsEmpty())
    {
        CString cstrField;
        cstrField.LoadString(IDS_SHARENAME_LABEL);
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
        GetDlgItem(IDC_SHARENAME)->SetFocus();
        return -1;
    }

    DWORD dwStatus = I_NetNameValidate(
                    (pApp->m_bIsLocal ? NULL : const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer))),
                    const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrShareName)),
                    NAMETYPE_SHARE,
                    0);
    if (dwStatus)
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_SHARENAME, cstrShareName);
        GetDlgItem(IDC_SHARENAME)->SetFocus();
        return -1;
    }

    if (ShareNameExists(cstrShareName))
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_DUPLICATE_SHARENAME, cstrShareName);
        GetDlgItem(IDC_SHARENAME)->SetFocus();
        return -1;
    }

    pApp->m_cstrShareName = cstrShareName;

    CString cstrShareDescription;
    GetDlgItemText(IDC_SHAREDESCRIPTION, cstrShareDescription);
    cstrShareDescription.TrimLeft();
    cstrShareDescription.TrimRight();
    pApp->m_cstrShareDescription = cstrShareDescription;

    pApp->m_dwCSCFlag = m_dwCSCFlag;

    return CPropertyPageEx::OnWizardNext();
}

void CWizClient0::OnChangeSharename() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);

    CString cstrUNC = pApp->m_cstrUNCPrefix;
    cstrUNC += cstrShareName;
    SetDlgItemText(IDC_UNC,  cstrUNC.Left(UNC_NAME_LIMIT));
}

BOOL CWizClient0::OnSetActive() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    GetParent()->SetDlgItemText(ID_WIZNEXT, pApp->m_cstrNextButtonText);

    if (!pApp->m_bShareNamePageInitialized)
    {
        // SMB share description
        SetDlgItemText(IDC_SHAREDESCRIPTION, pApp->m_cstrShareDescription);

        // SMB CSC settings
        m_dwCSCFlag = pApp->m_dwCSCFlag;
        UpdateCSCString();

        // SMB share name
        SetDlgItemText(IDC_SHARENAME, pApp->m_cstrShareName);

        CString cstrStart = pApp->m_cstrFolder.Mid(3);
        int index = cstrStart.ReverseFind(_T('\\'));
        CString cstrDefaultShareName;
        if (0 == index)
            cstrDefaultShareName = cstrStart;
        else
            cstrDefaultShareName = cstrStart.Mid(index+1);

        if (cstrDefaultShareName.GetLength() <= SHARE_NAME_LIMIT)
        {
            if (!ShareNameExists(cstrDefaultShareName))
                SetDlgItemText(IDC_SHARENAME, cstrDefaultShareName);
        }

        OnChangeSharename();

        pApp->m_bShareNamePageInitialized = TRUE;
    }

    BOOL fRet = CPropertyPageEx::OnSetActive();

    PostMessage(WM_SETPAGEFOCUS, 0, 0L);

    return fRet;
}

BOOL CWizClient0::ShareNameExists(IN LPCTSTR lpszShareName)
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  return SMBShareNameExists(pApp->m_cstrTargetComputer, lpszShareName);
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
LRESULT CWizClient0::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
    GetDlgItem(IDC_SHARENAME)->SetFocus();

    return 0;
} 

void CWizClient0::Reset()
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_cstrShareName.Empty();
  pApp->m_cstrShareDescription.Empty();
  pApp->m_dwCSCFlag = CSC_CACHE_MANUAL_REINT;
}

/////////////////////////////////////////////////////////////////////////////
// CWizClient property page

IMPLEMENT_DYNCREATE(CWizClient, CPropertyPageEx)

CWizClient::CWizClient() : CPropertyPageEx(CWizClient::IDD, 0, IDS_HEADERTITLE_CLIENT, IDS_HEADERSUBTITLE_CLIENT)
{
    //{{AFX_DATA_INIT(CWizClient)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
    m_bCSC = pApp->m_bCSC;
}

CWizClient::~CWizClient()
{
}

void CWizClient::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizClient)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizClient, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizClient)
    ON_BN_CLICKED(IDC_CHECK_MAC, OnCheckMac)
    ON_BN_CLICKED(IDC_CHECK_MS, OnCheckMs)
    ON_EN_CHANGE(IDC_SHARENAME, OnChangeSharename)
    ON_BN_CLICKED(IDC_CSC_CHANGE, OnCSCChange)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizClient message handlers

BOOL CWizClient::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();
    
    GetDlgItem(IDC_SHARENAME)->SendMessage(EM_LIMITTEXT, SHARE_NAME_LIMIT, 0);
    GetDlgItem(IDC_UNC)->SendMessage(EM_LIMITTEXT, UNC_NAME_LIMIT, 0);
    GetDlgItem(IDC_SHAREDESCRIPTION)->SendMessage(EM_LIMITTEXT, SHARE_DESCRIPTION_LIMIT, 0);
    GetDlgItem(IDC_MACSHARENAME)->SendMessage(EM_LIMITTEXT, SFM_SHARE_NAME_LIMIT, 0);
    
    if (!m_bCSC)
    {
        GetDlgItem(IDC_CSC_LABEL)->EnableWindow(FALSE);
        SetDlgItemText(IDC_CSC, _T(""));
        GetDlgItem(IDC_CSC)->EnableWindow(FALSE);
        GetDlgItem(IDC_CSC_CHANGE)->EnableWindow(FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWizClient::UpdateCSCString()
{
    if (m_bCSC)
    {
        CString cstrCSC;

        switch (m_dwCSCFlag & CSC_MASK)
        {
        case CSC_CACHE_MANUAL_REINT:
            cstrCSC.LoadString(IDS_CSC_MANUAL);
            break;
        case CSC_CACHE_AUTO_REINT:
        case CSC_CACHE_VDO:
            cstrCSC.LoadString(IDS_CSC_AUTOMATIC);
            break;
        case CSC_CACHE_NONE:
            cstrCSC.LoadString(IDS_CSC_NOCACHING);
            break;
        default:
            break;
        }
        
        SetDlgItemText(IDC_CSC, cstrCSC);
    }
}

void CWizClient::OnCSCChange()
{
    HINSTANCE hInstance = ::LoadLibrary (_T("FileMgmt.dll"));
    if ( hInstance )
    {
        PfnCacheSettingsDlg pfn = (PfnCacheSettingsDlg)::GetProcAddress(hInstance, "CacheSettingsDlg");
        if (pfn)
        {
            pfn(m_hWnd, m_dwCSCFlag);
        }
        ::FreeLibrary(hInstance);
    }

    UpdateCSCString();
}

LRESULT CWizClient::OnWizardNext() 
{
  CWaitCursor wait;
  Reset(); // init all related place holders

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_bSMB = (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck());
  pApp->m_bSFM = (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());

  if (!pApp->m_bSMB && !pApp->m_bSFM)
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_CLIENT_REQUIRED);
    GetDlgItem(IDC_CHECK_MS)->SetFocus();
    return -1;
  }

  DWORD dwStatus = 0;
  if (pApp->m_bSMB)
  {
    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);
    cstrShareName.TrimLeft();
    cstrShareName.TrimRight();
    if (cstrShareName.IsEmpty())
    {
      CString cstrField;
      cstrField.LoadString(IDS_SHARENAME_LABEL);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    dwStatus = I_NetNameValidate(
                  (pApp->m_bIsLocal ? NULL : const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer))),
                  const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrShareName)),
                  NAMETYPE_SHARE,
                  0);
    if (dwStatus)
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_SHARENAME, cstrShareName);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    if (ShareNameExists(cstrShareName, CLIENT_TYPE_SMB))
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_DUPLICATE_SMB_SHARENAME, cstrShareName);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    pApp->m_cstrShareName = cstrShareName;
  }

  if (pApp->m_bSMB)
  {
    CString cstrShareDescription;
    GetDlgItemText(IDC_SHAREDESCRIPTION, cstrShareDescription);
    cstrShareDescription.TrimLeft();
    cstrShareDescription.TrimRight();
    pApp->m_cstrShareDescription = cstrShareDescription;

    pApp->m_dwCSCFlag = m_dwCSCFlag;
  }

  if (pApp->m_bSFM)
  {
    CString cstrMACShareName;
    GetDlgItemText(IDC_MACSHARENAME, cstrMACShareName);
    cstrMACShareName.TrimLeft();
    cstrMACShareName.TrimRight();
    if (cstrMACShareName.IsEmpty())
    {
      CString cstrField;
      cstrField.LoadString(IDS_MACSHARENAME_LABEL);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
      GetDlgItem(IDC_MACSHARENAME)->SetFocus();
      return -1;
    } else
    {
      dwStatus = I_NetNameValidate(
                    (pApp->m_bIsLocal ? NULL : const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer))),
                    const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrMACShareName)),
                    NAMETYPE_SHARE,
                    0);
      if (dwStatus)
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_SHARENAME, cstrMACShareName);
        GetDlgItem(IDC_MACSHARENAME)->SetFocus();
        return -1;
      }
    }

    if (ShareNameExists(cstrMACShareName, CLIENT_TYPE_SFM))
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_DUPLICATE_SFM_SHARENAME, cstrMACShareName);
      GetDlgItem(IDC_MACSHARENAME)->SetFocus();
      return -1;
    }

    pApp->m_cstrMACShareName = cstrMACShareName;
  }

    return CPropertyPageEx::OnWizardNext();
}

void CWizClient::OnCheckClient()
{
    BOOL bSMB = (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck());
    BOOL bSFM = (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());

    GetDlgItem(IDC_SHARENAME)->EnableWindow(bSMB);
    GetDlgItem(IDC_UNC)->EnableWindow(bSMB);
    GetDlgItem(IDC_SHAREDESCRIPTION)->EnableWindow(bSMB);
    if (m_bCSC)
    {
        GetDlgItem(IDC_CSC)->EnableWindow(bSMB);
        GetDlgItem(IDC_CSC_CHANGE)->EnableWindow(bSMB);
    }

    GetDlgItem(IDC_MACSHARENAME)->EnableWindow(bSFM);
}

void CWizClient::OnCheckMac() 
{
  OnCheckClient();

  if (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck())
  {
    CString cstrShareName;
    GetDlgItemText(IDC_MACSHARENAME, cstrShareName);

    if (cstrShareName.IsEmpty() && 
        (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck()))
    {
        GetDlgItemText(IDC_SHARENAME, cstrShareName);
        SetDlgItemText(IDC_MACSHARENAME, cstrShareName.Left(SFM_SHARE_NAME_LIMIT));
    }
  }
}

void CWizClient::OnCheckMs() 
{
  OnCheckClient();
}

void CWizClient::OnChangeSharename() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);

    CString cstrUNC = pApp->m_cstrUNCPrefix;
    cstrUNC += cstrShareName;
    SetDlgItemText(IDC_UNC,  cstrUNC.Left(UNC_NAME_LIMIT));

    BOOL bSFM = (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());
    if (bSFM)
    {
        SetDlgItemText(IDC_MACSHARENAME,  cstrShareName.Left(SFM_SHARE_NAME_LIMIT));
    }
}

BOOL CWizClient::OnSetActive() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
    GetParent()->SetDlgItemText(ID_WIZNEXT, pApp->m_cstrNextButtonText);

    if (!pApp->m_bShareNamePageInitialized)
    {
        CheckDlgButton(IDC_CHECK_MS, pApp->m_bSMB);
        CheckDlgButton(IDC_CHECK_MAC, pApp->m_bSFM);
        OnCheckMs();

        // SMB share description
        SetDlgItemText(IDC_SHAREDESCRIPTION, pApp->m_cstrShareDescription);

        // SMB CSC settings
        m_dwCSCFlag = pApp->m_dwCSCFlag;
        UpdateCSCString();

        // MAC share name
        SetDlgItemText(IDC_MACSHARENAME, pApp->m_cstrMACShareName);

        // SMB share name
        SetDlgItemText(IDC_SHARENAME, pApp->m_cstrShareName);

        CString cstrStart = pApp->m_cstrFolder.Mid(3);
        int index = cstrStart.ReverseFind(_T('\\'));
        CString cstrDefaultShareName;
        if (0 == index)
        cstrDefaultShareName = cstrStart;
        else
        cstrDefaultShareName = cstrStart.Mid(index+1);

        if (cstrDefaultShareName.GetLength() <= SHARE_NAME_LIMIT)
        {
            if (!ShareNameExists(cstrDefaultShareName, CLIENT_TYPE_SMB))
                SetDlgItemText(IDC_SHARENAME, cstrDefaultShareName);
        }

        OnChangeSharename();

        pApp->m_bShareNamePageInitialized = TRUE;
    }

    BOOL fRet = CPropertyPageEx::OnSetActive();

    PostMessage(WM_SETPAGEFOCUS, 0, 0L);

    return fRet;
}

BOOL CWizClient::ShareNameExists(IN LPCTSTR lpszShareName, IN CLIENT_TYPE iType)
{
  BOOL        bReturn = FALSE;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  switch (iType)
  {
  case CLIENT_TYPE_SMB:
    {
      bReturn = SMBShareNameExists(pApp->m_cstrTargetComputer, lpszShareName);
      break;
    }
  case CLIENT_TYPE_SFM:
    {
      ASSERT(pApp->m_hLibSFM);
      bReturn = SFMShareNameExists(pApp->m_cstrTargetComputer, lpszShareName, pApp->m_hLibSFM);
      break;
    }
  default:
    break;
  }

  return bReturn;
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
LRESULT CWizClient::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
    if (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck())
    {
        GetDlgItem(IDC_SHARENAME)->SetFocus();
    } else if (BST_CHECKED == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck())
    {
        GetDlgItem(IDC_MACSHARENAME)->SetFocus();
    } else
    {
        GetDlgItem(IDC_CHECK_MS)->SetFocus();
    }

    return 0;
} 

void CWizClient::Reset()
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_cstrShareName.Empty();
  pApp->m_cstrShareDescription.Empty();
  pApp->m_cstrMACShareName.Empty();
  pApp->m_dwCSCFlag = CSC_CACHE_MANUAL_REINT;
  pApp->m_bSMB = TRUE;
  pApp->m_bSFM = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizclnt.h ===
#if !defined(AFX_WIZCLNT_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZCLNT_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizClnt.h : header file
//

typedef enum _CLIENT_TYPE {
    CLIENT_TYPE_SMB=0, 
    CLIENT_TYPE_SFM
} CLIENT_TYPE;

/////////////////////////////////////////////////////////////////////////////
// CWizClient0 dialog

class CWizClient0 : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CWizClient0)

// Construction
public:
	CWizClient0();
	~CWizClient0();

// Dialog Data
	//{{AFX_DATA(CWizClient0)
	enum { IDD = IDD_SHRWIZ_FOLDER0 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizClient0)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizClient0)
	virtual BOOL OnInitDialog();
	afx_msg void OnCSCChange();
	afx_msg void OnChangeSharename();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void UpdateCSCString();
    LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);
    void Reset();
    BOOL ShareNameExists(IN LPCTSTR lpszShareName);

    BOOL m_bCSC;
    DWORD m_dwCSCFlag;
};

/////////////////////////////////////////////////////////////////////////////
// CWizClient dialog

class CWizClient : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CWizClient)

// Construction
public:
	CWizClient();
	~CWizClient();

// Dialog Data
	//{{AFX_DATA(CWizClient)
	enum { IDD = IDD_SHRWIZ_FOLDER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizClient)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizClient)
	virtual BOOL OnInitDialog();
	afx_msg void OnCSCChange();
	afx_msg void OnCheckMac();
	afx_msg void OnCheckMs();
	afx_msg void OnChangeSharename();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void UpdateCSCString();
    void OnCheckClient();
    LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);
    void Reset();
    BOOL ShareNameExists(IN LPCTSTR lpszShareName, IN CLIENT_TYPE iType);

    BOOL m_bCSC;
    DWORD m_dwCSCFlag;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZCLNT_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizdir.h ===
#if !defined(AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizDir.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizFolder dialog

class CWizFolder : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CWizFolder)

// Construction
public:
	CWizFolder();
	~CWizFolder();

// Dialog Data
	//{{AFX_DATA(CWizFolder)
	enum { IDD = IDD_SHRWIZ_COMPUTER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizFolder)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizFolder)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowsefolder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

  LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);
  void Reset();

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizdir.cpp ===
// WizDir.cpp : implementation file
//

#include "stdafx.h"
#include "WizDir.h"
#include <shlobj.h>
#include "icanon.h"
#include <macfile.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void OpenBrowseDialog(IN HWND hwndParent, IN LPCTSTR lpszComputer, OUT LPTSTR lpszDir);

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
);

BOOL
VerifyDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
);

/////////////////////////////////////////////////////////////////////////////
// CWizFolder property page

IMPLEMENT_DYNCREATE(CWizFolder, CPropertyPageEx)

CWizFolder::CWizFolder() : CPropertyPageEx(CWizFolder::IDD, 0, IDS_HEADERTITLE_FOLDER, IDS_HEADERSUBTITLE_FOLDER)
{
    //{{AFX_DATA_INIT(CWizFolder)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
}

CWizFolder::~CWizFolder()
{
}

void CWizFolder::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizFolder)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizFolder, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizFolder)
    ON_BN_CLICKED(IDC_BROWSEFOLDER, OnBrowsefolder)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizFolder message handlers

BOOL CWizFolder::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    SetDlgItemText(IDC_COMPUTER, pApp->m_cstrTargetComputer);

    GetDlgItem(IDC_FOLDER)->SendMessage(EM_LIMITTEXT, _MAX_DIR - 1, 0);
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CWizFolder::OnWizardNext() 
{
  CWaitCursor wait;
  Reset(); // init all related place holders

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  CString cstrFolder;
  GetDlgItemText(IDC_FOLDER, cstrFolder);
  cstrFolder.TrimLeft();
  cstrFolder.TrimRight();
  if (cstrFolder.IsEmpty())
  {
    CString cstrField;
    cstrField.LoadString(IDS_FOLDER_LABEL);
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  }

  // Removing the ending backslash, otherwise, GetFileAttribute/NetShareAdd will fail.
  int iLen = cstrFolder.GetLength();
  if (cstrFolder[iLen - 1] == _T('\\') &&
      cstrFolder[iLen - 2] != _T(':'))
    cstrFolder.SetAt(iLen - 1, _T('\0'));

  if (!IsValidLocalAbsolutePath(cstrFolder))
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_FOLDER);
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  }

  //
  // need to exclude reserved MS-DOS device name
  //
  if (pApp->m_pfnIsDosDeviceName)
  {
      LPTSTR pszPath = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrFolder));
      LPTSTR pszStart = pszPath + 3;

      ULONG ulRet = 0;
      if (*pszStart)
      {
          TCHAR *pchCurrent = NULL;
          TCHAR *pchNext = NULL;

          while (0 == (ulRet = pApp->m_pfnIsDosDeviceName(pszPath)))
          {
               pchNext = _tcsrchr(pszStart, _T('\\'));

               if (pchCurrent)
                   *pchCurrent = _T('\\');

               if (!pchNext)
                   break;

               pchCurrent = pchNext;
               *pchNext = _T('\0');
          }

          if (0 != ulRet && pchCurrent)
              *pchCurrent = _T('\\');
      }

      if (0 != ulRet)
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_ISDOSDEVICENAME);
        GetDlgItem(IDC_FOLDER)->SetFocus();
        return -1;
      }
  }

  if (!VerifyDirectory(pApp->m_cstrTargetComputer, cstrFolder))
  {
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  }

  pApp->m_cstrFolder = cstrFolder;

    return CPropertyPageEx::OnWizardNext();
}

void CWizFolder::OnBrowsefolder() 
{
  CShrwizApp  *pApp = (CShrwizApp *)AfxGetApp();
  LPTSTR      lpszComputer = const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer));
  CString     cstrPath;
  TCHAR       szDir[MAX_PATH * 2] = _T(""); // double the size in case the remote path is itself close to MAX_PATH
  
  OpenBrowseDialog(m_hWnd, lpszComputer, szDir);
  if (szDir[0])
  {
    if (pApp->m_bIsLocal)
      cstrPath = szDir;
    else
    { // szDir is in the form of \\server\share or \\server\share\path....
      LPTSTR pShare = _tcschr(szDir + 2, _T('\\'));
      pShare++;
      LPTSTR pLeftOver = _tcschr(pShare, _T('\\'));
      if (pLeftOver && *pLeftOver)
        *pLeftOver++ = _T('\0');

      SHARE_INFO_2 *psi = NULL;
      if (NERR_Success == NetShareGetInfo(lpszComputer, pShare, 2, (LPBYTE *)&psi))
      {
        cstrPath = psi->shi2_path;
        if (pLeftOver && *pLeftOver)
        {
          if (_T('\\') != cstrPath.Right(1))
            cstrPath += _T('\\');
          cstrPath += pLeftOver;
        }
        NetApiBufferFree(psi);
      }
    }
  }

  if (!cstrPath.IsEmpty())
    SetDlgItemText(IDC_FOLDER, cstrPath);
}

BOOL CWizFolder::OnSetActive() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    ((CPropertySheet *)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    if (!pApp->m_bFolderPathPageInitialized)
    {
        // in re-run case, reset button behaviors that have been introduced by the last page
        GetParent()->SetDlgItemText(ID_WIZNEXT, pApp->m_cstrNextButtonText);
        GetParent()->GetDlgItem(ID_WIZBACK)->ShowWindow(SW_SHOW);
        GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(TRUE);

        SetDlgItemText(IDC_FOLDER, pApp->m_cstrFolder);

        pApp->m_bFolderPathPageInitialized = TRUE;
    }

    BOOL fRet = CPropertyPageEx::OnSetActive();

    PostMessage(WM_SETPAGEFOCUS, 0, 0L);

    return fRet;
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
LRESULT CWizFolder::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
  GetDlgItem(IDC_FOLDER)->SetFocus();
  return 0;
} 

void CWizFolder::Reset()
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_cstrFolder.Empty();
}

////////////////////////////////////////////////////////////
// OpenBrowseDialog
//

//
// 7/11/2001 LinanT bug#426953
// Since connection made by Terminal Service may bring some client side resources 
// (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
// the OK button when browsing to a non-local folder. We don't have this problem
// when browsing a remote machine.
//

#define DISK_ENTRY_LENGTH   4  // Drive letter, colon, whack, NULL
#define DISK_NAME_LENGTH    2  // Drive letter, colon

//
// This function determines if pszDir sits on any of
// the local logical drives.
// Contents in pszLocalDrives look like: c:\<null>d:\<null><null>
//
BOOL InDiskList(IN LPCTSTR pszDir, IN TCHAR *pszLocalDrives)
{
    if (!pszDir || !*pszDir || !pszLocalDrives || !*pszLocalDrives)
        return FALSE;

    DWORD i = 0;
    PTSTR pszDisk = pszLocalDrives;
    while (*pszDisk)
    {
        if (!_tcsnicmp(pszDisk, pszDir, DISK_NAME_LENGTH))
            return TRUE;

        pszDisk += DISK_ENTRY_LENGTH;
    }

    return FALSE;
}

int CALLBACK
BrowseCallbackProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPARAM lp,
    IN LPARAM pData
)
{
  switch(uMsg) {
  case BFFM_SELCHANGED:
    { 
      // enable the OK button if the selected path is local to that computer.
      BOOL bEnableOK = FALSE;
      TCHAR szDir[MAX_PATH];
      if (SHGetPathFromIDList((LPITEMIDLIST) lp ,szDir))
      {
          if (pData)
          {
              // we're looking at a local computer, verify if szDir is on a local disk
              bEnableOK = InDiskList(szDir, (TCHAR *)pData);
          } else
          {
              // no such problem when browsing at a remote computer, always enable OK button.
              bEnableOK = TRUE;
          }
      }
      SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bEnableOK);
      break;
    }
  case BFFM_VALIDATEFAILED:
  {
    DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, 0, IDS_BROWSE_FOLDER_INVALID);
    return 1;
  }
  default:
    break;
  }

  return 0;
}

//
// Since the buffer contents looks like c:\<null>d:\<null><null>,
// we're defining the buffer length to be 4*26+1.
//
#define LOGICAL_DRIVES_BUFFER_LENGTH            (4 * 26 + 1)

//
// This function retrieves logical drive letters, filters out
// remote drives, and returns drive letters on the local machine
// in the form of: c:\<null>d:\<null><null>
//
HRESULT GetLocalLogicalDriveStrings
(
    UINT nCharsInBuffer,    // number of total tchars in the buffer, including the terminating null char
    PTSTR pszBuffer
)
{
    HRESULT hr = S_OK;
    TCHAR szLocalDrives[LOGICAL_DRIVES_BUFFER_LENGTH];
    DWORD nChars = GetLogicalDriveStrings(
                     LOGICAL_DRIVES_BUFFER_LENGTH - 1, // in TCHARs, this size does NOT include the terminating null char.
                     szLocalDrives);
    //
    // MSDN:
    // If the function above succeeds, the return value is the length, 
    // in characters, of the strings copied to the buffer, not including
    // the terminating null character.
    // If the function fails, the return value is zero.
    //
    if (0 == nChars)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    } else
    {
        if ((nChars + 1 ) > nCharsInBuffer)
        {
            hr = E_INVALIDARG; // treat small buffer as invalid parameter
        } else
        {
            ZeroMemory(pszBuffer, nCharsInBuffer * sizeof(TCHAR));

            PTSTR pszDrive = szLocalDrives;
            while (*pszDrive)
            {
                if (DRIVE_REMOTE != GetDriveType(pszDrive))
                {
                    lstrcpyn(pszBuffer, pszDrive, DISK_ENTRY_LENGTH);
                    pszBuffer += DISK_ENTRY_LENGTH;
                }

                pszDrive += DISK_ENTRY_LENGTH;
            }
        }
    }

    return hr;
}

void OpenBrowseDialog(IN HWND hwndParent, IN LPCTSTR lpszComputer, OUT LPTSTR lpszDir)
{
  ASSERT(lpszComputer && *lpszComputer);

  HRESULT hr = S_OK;

  TCHAR szLocalDrives[LOGICAL_DRIVES_BUFFER_LENGTH];
  ZeroMemory(szLocalDrives, sizeof(szLocalDrives));

  CString cstrComputer;
  if (*lpszComputer != _T('\\') || *(lpszComputer + 1) != _T('\\'))
  {
    cstrComputer = _T("\\\\");
    cstrComputer += lpszComputer;
  } else
  {
    cstrComputer = lpszComputer;
  }

  hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (SUCCEEDED(hr))
  {
    LPMALLOC pMalloc;
    hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
      LPSHELLFOLDER pDesktopFolder;
      hr = SHGetDesktopFolder(&pDesktopFolder);
      if (SUCCEEDED(hr))
      {
        LPITEMIDLIST  pidlRoot;
        if (IsLocalComputer(lpszComputer))
        {
          hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlRoot);
          if (SUCCEEDED(hr))
          {
                //
                // 7/11/2001 LinanT bug#426953
                // Since connection made by Terminal Service may bring some client side resources 
                // (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
                // the OK button when browsing to a non-local folder. We don't have this problem
                // when browsing a remote machine.
                //
               //
               // Get an array of local disk names, this information is later used
               // in the browse dialog to disable OK button if non-local path is selected.
               // 

              // bug#714842: to work around the problem that NetServerDiskEnum
              // requires admin privilege, we call GetLogicalDriveStrings and
              // filter out remote drives.
              //
               hr = GetLocalLogicalDriveStrings(
                                   LOGICAL_DRIVES_BUFFER_LENGTH, // in TCHARs, including the terminating null char.
                                   szLocalDrives);
          }
        } else
        {
          hr = pDesktopFolder->ParseDisplayName(hwndParent, NULL,
                                const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrComputer)),
                                NULL, &pidlRoot, NULL);
        }
        if (SUCCEEDED(hr))
        {
          CString cstrLabel;
          cstrLabel.LoadString(IDS_BROWSE_FOLDER);

          BROWSEINFO bi;
          ZeroMemory(&bi,sizeof(bi));
          bi.hwndOwner = hwndParent;
          bi.pszDisplayName = 0;
          bi.lpszTitle = cstrLabel;
          bi.pidlRoot = pidlRoot;
          bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_SHAREABLE | BIF_USENEWUI | BIF_VALIDATE;
          bi.lpfn = BrowseCallbackProc;
          if (szLocalDrives[0])
            bi.lParam = (LPARAM)szLocalDrives; // pass the structure to the browse dialog

          LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
          if (pidl) {
            SHGetPathFromIDList(pidl, lpszDir);
            pMalloc->Free(pidl);
          }
          pMalloc->Free(pidlRoot);
        }
        pDesktopFolder->Release();
      }
      pMalloc->Release();
    }

    CoUninitialize();
  }

  if (FAILED(hr))
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONWARNING, hr, IDS_CANNOT_BROWSE_FOLDER, lpszComputer);
}

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
)
{
  DWORD dwPathType = 0;
  DWORD dwStatus = I_NetPathType(
                  NULL,
                  const_cast<LPTSTR>(lpszPath),
                  &dwPathType,
                  0);
  if (dwStatus)
    return FALSE;

  if (dwPathType ^ ITYPE_PATH_ABSD)
    return FALSE;

  return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnExistingFolder
//
//  Synopsis:   Check if pszPath is pointing at an existing folder.
//
//    S_OK:     The specified path points to an existing folder.
//    S_FALSE:  The specified path doesn't point to an existing folder.
//    hr:       Failed to get info on the specified path, or
//              the path exists but doesn't point to a folder.
//              The function reports error msg for both failures if desired.
//----------------------------------------------------------------------------
HRESULT
IsAnExistingFolder(
    IN HWND     hwnd,
    IN LPCTSTR  pszPath,
    IN BOOL     bDisplayErrorMsg
)
{
  if (!hwnd)
    hwnd = GetActiveWindow();

  HRESULT   hr = S_OK;
  DWORD     dwRet = GetFileAttributes(pszPath);

  if (-1 == dwRet)
  {
    DWORD dwErr = GetLastError();
    if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
    {
      // the specified path doesn't exist
      hr = S_FALSE;
    }
    else
    {
      hr = HRESULT_FROM_WIN32(dwErr);

      if (ERROR_NOT_READY == dwErr)
      {
        // fix for bug#358033/408803: ignore errors from GetFileAttributes in order to 
        // allow the root of movable drives to be shared without media inserted in.  
        int len = _tcslen(pszPath);
        if (len > 3 && 
            pszPath[len - 1] == _T('\\') &&
            pszPath[len - 2] == _T(':'))
        {
          // pszPath is pointing at the root of the drive, ignore the error
          hr = S_OK;
        }
      }

      if ( FAILED(hr) && bDisplayErrorMsg )
        DisplayMessageBox(hwnd, MB_OK, dwErr, IDS_FAILED_TO_GETINFO_FOLDER, pszPath);
    }
  } else if ( 0 == (dwRet & FILE_ATTRIBUTE_DIRECTORY) )
  {
    // the specified path is not pointing to a folder
    if (bDisplayErrorMsg)
      DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, 0, IDS_PATH_NOT_FOLDER, pszPath);
    hr = E_FAIL;
  }

  return hr;
}

// create the directories layer by layer
HRESULT
CreateLayeredDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
)
{
  ASSERT(IsValidLocalAbsolutePath(lpszDir));

  BOOL    bLocal = IsLocalComputer(lpszServer);

  CString cstrFullPath;
  GetFullPath(lpszServer, lpszDir, cstrFullPath);

  // add prefix to skip the CreateDirectory limit of 248 chars
  CString cstrFullPathNoParsing = (bLocal ? _T("\\\\?\\") : _T("\\\\?\\UNC"));
  cstrFullPathNoParsing += (bLocal ? cstrFullPath : cstrFullPath.Right(cstrFullPath.GetLength() - 1));

  HRESULT hr = IsAnExistingFolder(NULL, cstrFullPathNoParsing, FALSE);
  ASSERT(S_FALSE == hr);

  LPTSTR  pch = _tcschr(cstrFullPathNoParsing, (bLocal ? _T(':') : _T('$')));
  ASSERT(pch);

  // pszPath holds "\\?\C:\a\b\c\d" or "\\?\UNC\server\share\a\b\c\d"
  // pszLeft holds "a\b\c\d"
  LPTSTR  pszPath = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrFullPathNoParsing));
  LPTSTR  pszLeft = pch + 2;
  LPTSTR  pszRight = NULL;

  ASSERT(pszLeft && *pszLeft);

  //
  // this loop will find out the 1st non-existing sub-dir to create, and
  // the rest of non-existing sub-dirs
  //
  while (pch = _tcsrchr(pszLeft, _T('\\')))  // backwards search for _T('\\')
  {
    *pch = _T('\0');
    hr = IsAnExistingFolder(NULL, pszPath, TRUE);
    if (FAILED(hr))
      return S_FALSE;  // errormsg has already been reported by IsAnExistingFolder().

    if (S_OK == hr)
    {
      //
      // pszPath is pointing to the parent dir of the 1st non-existing sub-dir.
      // Once we restore the _T('\\'), pszPath will point at the 1st non-existing subdir.
      //
      *pch = _T('\\');
      break;
    } else
    {
      //
      // pszPath is pointing to a non-existing folder, continue with the loop.
      //
      if (pszRight)
        *(pszRight - 1) = _T('\\');
      pszRight = pch + 1;
    }
  }

  // We're ready to create directories:
  // pszPath points to the 1st non-existing dir, e.g., "C:\a\b" or "\\server\share\a\b"
  // pszRight points to the rest of non-existing sub dirs, e.g., "c\d"
  // 
  do 
  {
    if (!CreateDirectory(pszPath, NULL))
      return HRESULT_FROM_WIN32(GetLastError());

    if (!pszRight || !*pszRight)
      break;

    *(pszRight - 1) = _T('\\');
    if (pch = _tcschr(pszRight, _T('\\')))  // forward search for _T('\\')
    {
      *pch = _T('\0');
      pszRight = pch + 1;
    } else
    {
      pszRight = NULL;
    }
  } while (1);

  return S_OK;
}

BOOL
VerifyDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
)
{
  ASSERT(lpszDir && *lpszDir);
  ASSERT(IsValidLocalAbsolutePath(lpszDir));

  HWND hwnd = ::GetActiveWindow();

  BOOL    bLocal = IsLocalComputer(lpszServer);
  HRESULT hr = VerifyDriveLetter(lpszServer, lpszDir);
  if (FAILED(hr))
  { /*
    // fix for bug#351212: ignore error and leave permission checkings to NetShareAdd apis
    DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszDir);
    return FALSE;
    */
    hr = S_OK;
  } else if (S_OK != hr)
  {
    DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, 0, IDS_INVALID_DRIVE, lpszDir);
    return FALSE;
  }

  // warn if user has choosen to share out the whole volume
  if (3 == lstrlen(lpszDir) &&
      _T(':') == lpszDir[1] &&
      _T('\\') == lpszDir[2])
  {
      if (IDNO == DisplayMessageBox(hwnd, MB_YESNO|MB_DEFBUTTON2|MB_ICONWARNING, 0, IDS_WARNING_WHOLE_VOLUME, lpszDir))
          return FALSE;
  }

  if (!bLocal)
  {
    hr = IsAdminShare(lpszServer, lpszDir);
    if (FAILED(hr))
    {
      DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszDir);
      return FALSE;
    } else if (S_OK != hr)
    {
      // there is no matching $ shares, hence, no need to call GetFileAttribute, CreateDirectory,
      // assume lpszDir points to an existing directory
      return TRUE;
    }
  }

  CString cstrPath;
  GetFullPath(lpszServer, lpszDir, cstrPath);

  // add prefix to skip the GetFileAttribute limit when the path is on a remote server
  CString cstrPathNoParsing = (bLocal ? _T("\\\\?\\") : _T("\\\\?\\UNC"));
  cstrPathNoParsing += (bLocal ? cstrPath : cstrPath.Right(cstrPath.GetLength() - 1));

  hr = IsAnExistingFolder(hwnd, cstrPathNoParsing, TRUE); // error has already been reported.
  if (FAILED(hr) || S_OK == hr)
    return (S_OK == hr);

  if ( IDYES != DisplayMessageBox(hwnd, MB_YESNO|MB_ICONQUESTION, 0, IDS_CREATE_NEW_DIR, cstrPath) )
    return FALSE;

  // create the directories layer by layer
  hr = CreateLayeredDirectory(lpszServer, lpszDir);
  if (FAILED(hr))
    DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_CREATE_NEW_DIR, cstrPath);

  return (S_OK == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizfirst.cpp ===
// WizFirst.cpp : implementation file
//

#include "stdafx.h"
#include "WizFirst.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizWelcome property page

IMPLEMENT_DYNCREATE(CWizWelcome, CPropertyPageEx)

CWizWelcome::CWizWelcome() : CPropertyPageEx(CWizWelcome::IDD)
{
    //{{AFX_DATA_INIT(CWizWelcome)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_HIDEHEADER;
}

CWizWelcome::~CWizWelcome()
{
}

void CWizWelcome::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizWelcome)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizWelcome, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizWelcome)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizWelcome message handlers

BOOL CWizWelcome::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    ((CPropertySheet *)GetParent())->GetDlgItemText(ID_WIZNEXT, pApp->m_cstrNextButtonText);
    ((CPropertySheet *)GetParent())->GetDlgItemText(ID_WIZFINISH, pApp->m_cstrFinishButtonText);

    GetDlgItem(IDC_WELCOME)->SendMessage(WM_SETFONT, (WPARAM)pApp->m_hTitleFont, (LPARAM)TRUE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CWizWelcome::OnSetActive() 
{
  ((CPropertySheet *)GetParent())->SetWizardButtons(PSWIZB_NEXT);

  return CPropertyPageEx::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizfirst.h ===
#if !defined(AFX_WIZFIRST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZFIRST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizFirst.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizWelcome dialog

class CWizWelcome : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CWizWelcome)

// Construction
public:
	CWizWelcome();
	~CWizWelcome();

// Dialog Data
	//{{AFX_DATA(CWizWelcome)
	enum { IDD = IDD_WELCOME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizWelcome)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZFIRST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizlast.cpp ===
// WizLast.cpp : implementation file
//

#include "stdafx.h"
#include "WizLast.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizFinish property page

IMPLEMENT_DYNCREATE(CWizFinish, CPropertyPageEx)

CWizFinish::CWizFinish() : CPropertyPageEx(CWizFinish::IDD)
{
    //{{AFX_DATA_INIT(CWizFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_HIDEHEADER;
    m_cstrNewFinishButtonText.LoadString(IDS_NEW_FINISHBUTTONTEXT);
}

CWizFinish::~CWizFinish()
{
}

void CWizFinish::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWizFinish, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizFinish)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizFinish message handlers

BOOL CWizFinish::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    GetDlgItem(IDC_FINISH_TITLE)->SendMessage(WM_SETFONT, (WPARAM)pApp->m_hTitleFont, (LPARAM)TRUE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CWizFinish::OnWizardFinish() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    if (BST_CHECKED == ((CButton *)GetDlgItem(IDC_MORE_SHARES))->GetCheck())
    {
        pApp->Reset();
        return FALSE;
    }

    return CPropertyPageEx::OnWizardFinish();
}

BOOL CWizFinish::OnSetActive()
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    ((CPropertySheet *)GetParent())->SetWizardButtons(PSWIZB_FINISH);

    ((CPropertySheet *)GetParent())->SetFinishText(m_cstrNewFinishButtonText); // this hides Back button too
    GetParent()->GetDlgItem(ID_WIZBACK)->ShowWindow(SW_HIDE); // to make sure it is hidden
    GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);

    SetDlgItemText(IDC_FINISH_TITLE, pApp->m_cstrFinishTitle);
    SetDlgItemText(IDC_FINISH_STATUS, pApp->m_cstrFinishStatus);
    SetDlgItemText(IDC_FINISH_SUMMARY, pApp->m_cstrFinishSummary);

    BOOL fRet = CPropertyPageEx::OnSetActive();

    PostMessage(WM_SETPAGEFOCUS, 0, 0L);

    return fRet;
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
LRESULT CWizFinish::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
    GetDlgItem(IDC_MORE_SHARES)->SetFocus();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizlast.h ===
#if !defined(AFX_WIZLAST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZLAST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizLast.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizFinish dialog

class CWizFinish : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CWizFinish)

// Construction
public:
	CWizFinish();
	~CWizFinish();

// Dialog Data
	//{{AFX_DATA(CWizFinish)
	enum { IDD = IDD_FINISH };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizFinish)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizFinish)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);

public:
    CString m_cstrNewFinishButtonText;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZLAST_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizperm.cpp ===
// WizPerm.cpp : implementation file
//

#include "stdafx.h"
#include "WizPerm.h"
#include "aclpage.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizPerm property page

IMPLEMENT_DYNCREATE(CWizPerm, CPropertyPageEx)

CWizPerm::CWizPerm() : CPropertyPageEx(CWizPerm::IDD, 0, IDS_HEADERTITLE_PERM, IDS_HEADERSUBTITLE_PERM)
{
    //{{AFX_DATA_INIT(CWizPerm)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
}

CWizPerm::~CWizPerm()
{
}

void CWizPerm::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageEx::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizPerm)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizPerm, CPropertyPageEx)
    //{{AFX_MSG_MAP(CWizPerm)
    ON_BN_CLICKED(IDC_RADIO_PERM1, OnRadioPerm1)
    ON_BN_CLICKED(IDC_RADIO_PERM2, OnRadioPerm2)
    ON_BN_CLICKED(IDC_RADIO_PERM3, OnRadioPerm3)
    ON_BN_CLICKED(IDC_RADIO_PERM4, OnRadioPerm4)
    ON_BN_CLICKED(IDC_PERM_CUSTOM, OnPermCustom)
    ON_NOTIFY(NM_CLICK, IDC_PERM_HELPLINK, OnHelpLink)
    ON_NOTIFY(NM_RETURN, IDC_PERM_HELPLINK, OnHelpLink)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizPerm message handlers
BOOL CWizPerm::OnInitDialog() 
{
    CPropertyPageEx::OnInitDialog();

    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    if (pApp->m_bServerSBS)
    {
        CString cstrPerm2, cstrPerm3;
        cstrPerm2.LoadString(IDS_SBS_PERM2);
        cstrPerm3.LoadString(IDS_SBS_PERM3);

        SetDlgItemText(IDC_RADIO_PERM2, cstrPerm2);
        SetDlgItemText(IDC_RADIO_PERM3, cstrPerm3);
    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWizPerm::OnRadioPerm1() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
}

void CWizPerm::OnRadioPerm2() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
}

void CWizPerm::OnRadioPerm3() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
}

void CWizPerm::OnRadioPerm4() 
{
  // do not call Reset, in order to keep the pSD that the user has customized
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(TRUE);
}

void CWizPerm::OnPermCustom() 
{
  CWaitCursor wait;
  HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (FAILED(hr))
  {
    TRACE(_T("CoInitializeEx failed hr=%x"), hr);
    return;
  }

  CShrwizApp                *pApp = (CShrwizApp *)AfxGetApp();
  CShareSecurityInformation *pssInfo = NULL;
  HPROPSHEETPAGE            phPages[2];
  int                       cPages = 1;

  CString cstrSheetTitle, cstrSharePageTitle;
  cstrSheetTitle.LoadString(IDS_CUSTOM_PERM);
  cstrSharePageTitle.LoadString(IDS_SHARE_PERMISSIONS);

  // create "Share Permissions" property page
  BOOL bSFMOnly = (!pApp->m_bSMB && pApp->m_bSFM);
  if (bSFMOnly)
  {
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = AfxGetResourceHandle();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NO_SHARE_PERMISSIONS);
    psp.pszTitle = cstrSharePageTitle;

    phPages[0] = CreatePropertySheetPage(&psp);
    if ( !(phPages[0]) )
    {
      hr = GetLastError();
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
    }
  } else
  {
    pssInfo = new CShareSecurityInformation(pApp->m_pSD);
    if (!pssInfo)
    {
      hr = E_OUTOFMEMORY;
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
    } else
    {
      pssInfo->Initialize(pApp->m_cstrTargetComputer, pApp->m_cstrShareName, cstrSharePageTitle);
      phPages[0] = CreateSecurityPage(pssInfo);
      if ( !(phPages[0]) )
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
      }
    }
  }
  
  if (SUCCEEDED(hr))
  {
    // create "File Security" property page
    CFileSecurityDataObject *pfsDataObject = new CFileSecurityDataObject;
    if (!pfsDataObject)
    {
      hr = E_OUTOFMEMORY;
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
      // destroy pages that have not been passed to the PropertySheet function
      DestroyPropertySheetPage(phPages[0]);
    } else
    {
      pfsDataObject->Initialize(pApp->m_cstrTargetComputer, pApp->m_cstrFolder);
      hr = CreateFileSecurityPropPage(&(phPages[1]), pfsDataObject);
      if (SUCCEEDED(hr))
        cPages = 2;

      PROPSHEETHEADER psh;
      ZeroMemory(&psh, sizeof(psh));
      psh.dwSize = sizeof(psh);
      psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
      psh.hwndParent = m_hWnd;
      psh.hInstance = AfxGetResourceHandle();
      psh.pszCaption = cstrSheetTitle;
      psh.nPages = cPages;
      psh.phpage = phPages;

      // create the property sheet
      PropertySheet(&psh);

      pfsDataObject->Release();
    }
  }

  if (!bSFMOnly)
  {
    if (pssInfo)
      pssInfo->Release();
  }

  CoUninitialize();
}

void CWizPerm::OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult)
{
    CWaitCursor wait;

    ::HtmlHelp(0, _T("file_srv.chm"), HH_DISPLAY_TOPIC, (DWORD_PTR)(_T("file_srv_set_permissions.htm")));

    *pResult = 0;
}

LRESULT CWizPerm::OnWizardNext() 
{
  CWaitCursor wait;
  HRESULT     hr = S_OK;
  BOOL        bCustom = FALSE;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
    
  switch (GetCheckedRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4))
  {
  case IDC_RADIO_PERM1:
    {
      CPermEntry permEntry;
      hr = permEntry.Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_READ_ONLY);
      if (SUCCEEDED(hr))
        hr = BuildSecurityDescriptor(&permEntry, 1, &(pApp->m_pSD));
    }
    break;
  case IDC_RADIO_PERM2:
    {
      CPermEntry permEntry[3];
      UINT i = 0;
      hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_READ_ONLY);
      if (SUCCEEDED(hr))
      {
        hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_ADMINISTRATORS, SHARE_PERM_FULL_CONTROL);
        if (SUCCEEDED(hr))
        {
            if (pApp->m_bServerSBS)
                hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_SBSFOLDEROPERATORS, SHARE_PERM_FULL_CONTROL);

            if (SUCCEEDED(hr))
                hr = BuildSecurityDescriptor(permEntry, i, &(pApp->m_pSD));
        }
      }
    }
    break;
  case IDC_RADIO_PERM3:
    {
      CPermEntry permEntry[3];
      UINT i = 0;
      hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_READ_WRITE);
      if (SUCCEEDED(hr))
      {
        hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_ADMINISTRATORS, SHARE_PERM_FULL_CONTROL);
        if (SUCCEEDED(hr))
        {
          if (pApp->m_bServerSBS)
              hr = permEntry[i++].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_SBSFOLDEROPERATORS, SHARE_PERM_FULL_CONTROL);

          if (SUCCEEDED(hr))
              hr = BuildSecurityDescriptor(permEntry, i, &(pApp->m_pSD));
        }
      }
    }
    break;
  case IDC_RADIO_PERM4:
    {
      bCustom = TRUE;
      if (NULL == pApp->m_pSD)
      {
          CPermEntry permEntry;
          hr = permEntry.Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_READ_ONLY);
          if (SUCCEEDED(hr))
              hr = BuildSecurityDescriptor(&permEntry, 1, &(pApp->m_pSD));
      }
    }
    break;
  default:
    ASSERT(FALSE);
    return FALSE; // prevent the property sheet from being destroyed
  }

  if (!bCustom && FAILED(hr))
  {
    DisplayMessageBox(m_hWnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_GET_SD);
    return FALSE; // prevent the property sheet from being destroyed
  }

  CreateShare();

  return CPropertyPageEx::OnWizardNext();
}

BOOL CWizPerm::OnSetActive() 
{
    CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

    GetParent()->SetDlgItemText(ID_WIZNEXT, pApp->m_cstrFinishButtonText);

    BOOL bSFMOnly = (!pApp->m_bSMB && pApp->m_bSFM);

    GetDlgItem(IDC_RADIO_PERM1)->EnableWindow(!bSFMOnly);
    GetDlgItem(IDC_RADIO_PERM2)->EnableWindow(!bSFMOnly);
    GetDlgItem(IDC_RADIO_PERM3)->EnableWindow(!bSFMOnly);

    if (bSFMOnly)
    {
        CheckRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4, IDC_RADIO_PERM4);
        OnRadioPerm4();
    }

    if (!pApp->m_bPermissionsPageInitialized)
    {
        if (!bSFMOnly)
        {
            CheckRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4, IDC_RADIO_PERM1);
            OnRadioPerm1();
        }

        pApp->m_bPermissionsPageInitialized = TRUE;
    }
    
    return CPropertyPageEx::OnSetActive();
}

void CWizPerm::Reset() 
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  if (pApp->m_pSD)
  {
    LocalFree((HLOCAL)(pApp->m_pSD));
    pApp->m_pSD = NULL;
  }
}

int
CWizPerm::CreateShare()
{
  DWORD dwRet = NERR_Success;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  UINT    iSuccess = 0;

  CString cstrSMBError;
  CString cstrSFMError;

  do {
    if (pApp->m_bSMB)
    {
      CString cstrSMB;
      cstrSMB.LoadString(IDS_SMB_CLIENTS);

      dwRet = SMBCreateShare(
                  pApp->m_cstrTargetComputer,
                  pApp->m_cstrShareName,
                  pApp->m_cstrShareDescription,
                  pApp->m_cstrFolder,
                  pApp->m_pSD
                  );
      if (NERR_Success != dwRet)
      {
          GetErrorMessage(dwRet, cstrSMBError);
      } else 
      {
        iSuccess++;

        if (pApp->m_bIsLocal) // refresh shell
          SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH | SHCNF_FLUSH, pApp->m_cstrFolder, 0);

        // set client side caching setting, ignore error
        if (pApp->m_bCSC)
        {
            (void)SMBSetCSC(
                          pApp->m_cstrTargetComputer,
                          pApp->m_cstrShareName,
                          pApp->m_dwCSCFlag
                          );
        }

      }
    }

    if (pApp->m_bSFM)
    {
      dwRet = SFMCreateShare(
                  pApp->m_cstrTargetComputer,
                  pApp->m_cstrMACShareName,
                  pApp->m_cstrFolder,
                  pApp->m_hLibSFM
                  );
      if (NERR_Success != dwRet)
      {
          GetErrorMessage(dwRet, cstrSFMError);
      } else
      {
        iSuccess++;
      }
    }
  } while (0);

  enum {noMac, onlySMB, onlySFM, both} eClientSelection = noMac;

  if (!pApp->m_bServerSFM)
  {
      eClientSelection = noMac;
  } else if (pApp->m_bSMB)
  {
      if (pApp->m_bSFM)
          eClientSelection = both;
      else
          eClientSelection = onlySMB;
  } else
  {
      eClientSelection = onlySFM;
  }

  // summary text
  switch (eClientSelection)
  {
  case noMac:
      pApp->m_cstrFinishSummary.FormatMessage(IDS_SUMMARY_NOMAC,
                                    pApp->m_cstrTargetComputer,
                                    pApp->m_cstrFolder,
                                    pApp->m_cstrShareName,
                                    pApp->m_cstrUNCPrefix + pApp->m_cstrShareName);
      break;
  case onlySMB:
      pApp->m_cstrFinishSummary.FormatMessage(IDS_SUMMARY_ONLYSMB,
                                    pApp->m_cstrTargetComputer,
                                    pApp->m_cstrFolder,
                                    pApp->m_cstrShareName,
                                    pApp->m_cstrUNCPrefix + pApp->m_cstrShareName);
      break;
  case onlySFM:
      pApp->m_cstrFinishSummary.FormatMessage(IDS_SUMMARY_ONLYSFM,
                                    pApp->m_cstrTargetComputer,
                                    pApp->m_cstrFolder,
                                    pApp->m_cstrMACShareName);
      break;
  case both:
      pApp->m_cstrFinishSummary.FormatMessage(IDS_SUMMARY_BOTH,
                                    pApp->m_cstrTargetComputer,
                                    pApp->m_cstrFolder,
                                    pApp->m_cstrShareName,
                                    pApp->m_cstrUNCPrefix + pApp->m_cstrShareName,
                                    pApp->m_cstrMACShareName);
      break;
  default:
      break;
  }

  // title & status
  if (0 == iSuccess)
  { // total failure
      pApp->m_cstrFinishTitle.LoadString(IDS_TITLE_FAILURE);

      switch (eClientSelection)
      {
      case noMac:
            pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_FAILURE_NOMAC, cstrSMBError);
          break;
      case onlySMB:
            pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_FAILURE_ONLYSMB, cstrSMBError);
          break;
      case onlySFM:
            pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_FAILURE_ONLYSFM, cstrSFMError);
          break;
      case both:
            pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_FAILURE_BOTH, cstrSMBError, cstrSFMError);
          break;
      default:
          break;
      }
  } else if (both == eClientSelection && 1 == iSuccess)
  { // partial failure
      pApp->m_cstrFinishTitle.LoadString(IDS_TITLE_PARTIAL_FAILURE);

      if (cstrSMBError.IsEmpty())
          pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_PARTIAL_FAILURE_SFM, cstrSFMError);
      else
          pApp->m_cstrFinishStatus.FormatMessage(IDS_STATUS_PARTIAL_FAILURE_SMB, cstrSMBError);

  } else
  { // success
      pApp->m_cstrFinishTitle.LoadString(IDS_TITLE_SUCCESS);

      pApp->m_cstrFinishStatus.LoadString(IDS_STATUS_SUCCESS);
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wizards\shrwiz\wizperm.h ===
#if !defined(AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizPerm.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizPerm dialog

class CWizPerm : public CPropertyPageEx
{
    DECLARE_DYNCREATE(CWizPerm)

// Construction
public:
    CWizPerm();
    ~CWizPerm();

// Dialog Data
    //{{AFX_DATA(CWizPerm)
    enum { IDD = IDD_SHRWIZ_PERM };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizPerm)
    public:
    virtual LRESULT OnWizardNext();
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWizPerm)
    virtual BOOL OnInitDialog();
    afx_msg void OnRadioPerm1();
    afx_msg void OnRadioPerm2();
    afx_msg void OnRadioPerm3();
    afx_msg void OnRadioPerm4();
    afx_msg void OnPermCustom();
    afx_msg void OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

  void Reset();
  int  CreateShare();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#define _ATL_FREE_THREADED
//#define _ATL_APARTMENT_THREADED

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need safe functions (after atl)
#define STRSAFE_LIB
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

///////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////
#define	__SUPPORT_WAIT

//#define	__SUPPORT_ICECAP_ONCE
//#define	__SUPPORT_EVENTVWR
//#define	__SUPPORT_MSGBOX

//#define	__SUPPORT_LOGGING

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_app.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_App.cpp
//
//	Abstract:
//
//					module for application
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"
#include "RefresherUtils.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

///////////////////////////////////////////////////////////////////////////
// GLOBAL STUFF
///////////////////////////////////////////////////////////////////////////

extern	LPCWSTR				g_szRefreshMutex;	// name of mutex for refresh
extern	__SmartHANDLE		g_hRefreshMutex;	// mutex to find out refersh request

extern	LPCWSTR				g_szRefreshMutexLib;// name of mutex for refresh
extern	__SmartHANDLE		g_hRefreshMutexLib;	// mutex to find out refersh request

extern	LPCWSTR				g_szRefreshFlag;
extern	__SmartHANDLE		g_hRefreshFlag;

extern __SmartHANDLE		g_hDoneWorkEvt;		//	event for COM init/uninit	( nonsignaled )
extern __SmartHANDLE		g_hDoneWorkEvtCIM;	//	event for CIM connect/release	( nonsignaled )
extern __SmartHANDLE		g_hDoneWorkEvtWMI;	//	event for WMI connect/release	( nonsignaled )
extern __SmartHANDLE		g_hDoneLibEvt;		//	event for lib connect/disconnect	( nonsignaled )
extern __SmartHANDLE		g_hDoneInitEvt;		//	event for init is finished	( nonsignaled )

extern LPCWSTR g_szAppName;
extern LPCWSTR g_szAppNameGlobal;

///////////////////////////////////////////////////////////////////////////
// construction & destruction
///////////////////////////////////////////////////////////////////////////

WmiAdapterApp::WmiAdapterApp( ):

	#ifdef	__SUPPORT_EVENTVWR
	m_hResources ( NULL ),
	#endif	__SUPPORT_EVENTVWR

	m_bInUse ( FALSE ),
	m_bManual ( FALSE )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp construction\n"
				L"*************************************************************\n" );

	::InitializeCriticalSection ( &m_cs );
}

WmiAdapterApp::~WmiAdapterApp()
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp destruction\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// release mutex ( previous instance checker :)) )
	////////////////////////////////////////////////////////////////////////
	if ( m_hInstance.GetHANDLE() )
	{
		::ReleaseMutex ( m_hInstance );
		m_hInstance.CloseHandle();
	}

	////////////////////////////////////////////////////////////////////////
	// release security attributtes
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pStuff.IsEmpty() )
		{
			delete pStuff.Detach();
		}
	}
	catch ( ... )
	{
		pStuff.Detach();
	}

	#ifdef	__SUPPORT_EVENTVWR
	////////////////////////////////////////////////////////////////////////
	// release event log
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pEventLog.IsEmpty() )
		{
			delete pEventLog.Detach();
		}
	}
	catch ( ... )
	{
		pEventLog.Detach();
	}
	#endif	__SUPPORT_EVENTVWR

	////////////////////////////////////////////////////////////////////////
	// release security attributtes
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pSA.IsEmpty() )
		{
			delete pSA.Detach();
		}
	}
	catch ( ... )
	{
		pSA.Detach();
	}

	#ifdef	__SUPPORT_EVENTVWR
	////////////////////////////////////////////////////////////////////////
	// close resources
	////////////////////////////////////////////////////////////////////////
	if ( m_hResources )
	{
		::FreeLibrary ( m_hResources );
		m_hResources = NULL;
	}
	#endif	__SUPPORT_EVENTVWR

	::DeleteCriticalSection ( &m_cs );

	#ifdef	_DEBUG
	_CrtDumpMemoryLeaks();
	#endif	_DEBUG
}

///////////////////////////////////////////////////////////////////////////
// exists instance ?
///////////////////////////////////////////////////////////////////////////

BOOL WmiAdapterApp::Exists ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp exists application\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast < LPCRITICAL_SECTION> ( &m_cs ) );


	// check instance

	if ( m_hInstance.GetHANDLE() == NULL )
	{
		if ( !pSA.IsEmpty() )
		{
			if ( m_hInstance.SetHANDLE ( ::CreateMutexW ( pSA->GetSecurityAttributtes(), FALSE, g_szAppNameGlobal ) ), m_hInstance.GetHANDLE() != NULL )
			{
				if ( ::GetLastError () == ERROR_ALREADY_EXISTS )
				{
					return TRUE;
				}
			}
			else
			{
				// m_hInstance.GetHANDLE() == NULL
				// something's is very bad
				// return we already exists :))
				return TRUE;
			}
		}
		else
		{
			// security is not initialized
			// something's is very bad
			// return we already exists :))
			return TRUE;
		}
	}
	else
	{
		// something's is very bad
		// we should not really be here
		return TRUE;
	}

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
// INITIALIZATION
///////////////////////////////////////////////////////////////////////////

HRESULT	WmiAdapterApp::InitKill ( void )
{
	HRESULT hRes = S_FALSE;

	try
	{
		if (_App.m_hKill.GetHANDLE() == NULL)
		{
			if ( (	_App.m_hKill =
				::CreateEvent ( ((WmiSecurityAttributes*)_App)->GetSecurityAttributtes(),
								TRUE,
								FALSE,
								NULL ) 
				 ) == NULL )
			{
				// get error
				HRESULT hr = HRESULT_FROM_WIN32 ( ::GetLastError() );

				if FAILED ( hr )
				{
					hRes = hr;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}
			else
			{
				hRes = S_OK;
			}
		}
	}
	catch ( ... )
	{
		hRes = HRESULT_FROM_WIN32 ( ERROR_NOT_READY );
	}

	return hRes;
}

HRESULT WmiAdapterApp::InitAttributes ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp initialization of neccessary attributes\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( &m_cs );

	#ifdef	__SUPPORT_EVENTVWR
	////////////////////////////////////////////////////////////////////////
	// load resource library
	////////////////////////////////////////////////////////////////////////
	if ( ! m_hResources )
	{
		m_hResources = GetResourceDll();
	}
	#endif	__SUPPORT_EVENTVWR

	try
	{
		////////////////////////////////////////////////////////////////////////
		// create Security descriptor
		////////////////////////////////////////////////////////////////////////
		if ( pSA.IsEmpty() && ( pSA.SetData ( new WmiSecurityAttributes() ), pSA.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}

		//
		// check to see if security is initialized
		//

		if ( FALSE == pSA->m_bInitialized )
		{
			return E_FAIL;
		}

		#ifdef	__SUPPORT_EVENTVWR
		////////////////////////////////////////////////////////////////////////
		// create event log
		////////////////////////////////////////////////////////////////////////
		if ( pEventLog.IsEmpty() && ( pEventLog.SetData( new CPerformanceEventLogBase( L"WMIAdapter" ) ), pEventLog.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}
		#endif	__SUPPORT_EVENTVWR
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT WmiAdapterApp::Init ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp initialization\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( &m_cs );

	#ifdef	__SUPPORT_EVENTVWR
	////////////////////////////////////////////////////////////////////////
	// load resource library
	////////////////////////////////////////////////////////////////////////
	if ( ! m_hResources )
	{
		m_hResources = GetResourceDll();
	}
	#endif	__SUPPORT_EVENTVWR

	try
	{
		////////////////////////////////////////////////////////////////////////
		// create stuff
		////////////////////////////////////////////////////////////////////////
		if ( pStuff.IsEmpty() && ( pStuff.SetData( new WmiAdapterStuff( ) ), pStuff.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	#ifdef	__SUPPORT_WAIT
	m_hData = ::CreateEventW(	pSA->GetSecurityAttributtes(),
								TRUE,
								FALSE, 
								L"Global\\WmiAdapterDataReady"
						    );
	#endif	__SUPPORT_WAIT

	if ( ( m_hInit = ::CreateSemaphoreW(	pSA->GetSecurityAttributtes(),
											0L,
											100L,
											L"Global\\WmiAdapterInit"
										)
		 ) == NULL )
	{
		// this is really important to have
		return E_OUTOFMEMORY;
	}

	if ( ( m_hUninit= ::CreateSemaphoreW(	pSA->GetSecurityAttributtes(),
											0L,
											100L,
											L"Global\\WmiAdapterUninit"
										)
		 ) == NULL )
	{
		// this is really important to have
		return E_OUTOFMEMORY;
	}

	///////////////////////////////////////////////////////////////////////////
	// GLOBAL STUFF
	///////////////////////////////////////////////////////////////////////////

	if ( ! g_hRefreshMutex )
	{
		if ( ( g_hRefreshMutex = ::CreateMutex	(
													pSA->GetSecurityAttributtes(),
													FALSE,
													g_szRefreshMutex
												)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hRefreshMutexLib )
	{
		if ( ( g_hRefreshMutexLib = ::CreateMutex	(
														pSA->GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutexLib
													)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hRefreshFlag )
	{
		if ( ( g_hRefreshFlag = ::CreateMutex	(
													pSA->GetSecurityAttributtes(),
													FALSE,
													g_szRefreshFlag
												)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvt )
	{
		if ( ( g_hDoneWorkEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvtCIM )
	{
		if ( ( g_hDoneWorkEvtCIM = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvtWMI )
	{
		if ( ( g_hDoneWorkEvtWMI = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneInitEvt )
	{
		if ( ( g_hDoneInitEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneLibEvt )
	{
		if ( ( g_hDoneLibEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	return S_OK;
}

void WmiAdapterApp::Term ( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter.cpp
//
//	Abstract:
//
//					implements functionality ( decides what to do :)) )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

// resorces

#include "PreComp.h"

// guids
#include <initguid.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// messages ( event log )
#include "WmiAdapterMessages.h"

#include ".\WMIAdapter\resource.h"

// declarations
#include "WMIAdapter_Service.h"
#include "WMIAdapter_App.h"

// registration
#include "Wmi_Adapter_Registry_Service.h"

// enum
#include <refreshergenerate.h>

/////////////////////////////////////////////////////////////////////////////
// VARIABLES
/////////////////////////////////////////////////////////////////////////////

// app
WmiAdapterApp		_App;

// service module
WmiAdapterService	_Service;

////////////////////////////////////////////////////////////////////////////
// ATL stuff
////////////////////////////////////////////////////////////////////////////

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need registry
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

CStaticCritSec		g_cs;						//	synch object used to protect above globals
LONG				g_lRef			= 0;		//	count of threads attached into Run Function
__SmartHANDLE		g_hDoneWorkEvt	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorking		= FALSE;	//	boolean used to tell if init/unit in progress

//Performs Initialization if necessary, waits until initialization is done if necessary.
HRESULT DoInit()
{
	HRESULT hRes = E_FAIL;

	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( g_lRef == 0 )
		{
			bDoWork = TRUE;
			g_lRef++;
			g_bWorking = TRUE;
			::ResetEvent(g_hDoneWorkEvt);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorking )
			{
				::LeaveCriticalSection ( &g_cs );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvt, INFINITE ) )
				{
					return hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRef++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &g_cs );

	if (bDoWork)
	{
		if SUCCEEDED ( hRes = _App.InitKill ( ) )
		{
			try
			{
				if SUCCEEDED ( hRes = ::CoInitializeSecurity(	( ( WmiSecurityAttributes* ) _App )->GetAbsoluteSecurityDescriptor(),
																-1,
																NULL,
																NULL,
																RPC_C_AUTHN_LEVEL_PKT,
																RPC_C_IMP_LEVEL_IDENTIFY,
																NULL,
																EOAC_DYNAMIC_CLOAKING | EOAC_SECURE_REFS,
																NULL
															)
							 )
				{
					try
					{
						////////////////////////////////////////////////////////////////////////
						// LOCATOR ( neccessary )
						////////////////////////////////////////////////////////////////////////

						if ( ! ( (WmiAdapterStuff*) _App )->m_Stuff.m_spLocator )
						{
							hRes =	::CoCreateInstance
									(
											__uuidof ( WbemLocator ),
											NULL,
											CLSCTX_INPROC_SERVER,
											__uuidof ( IWbemLocator ),
											(void**) & ( ( (WmiAdapterStuff*) _App )->m_Stuff.m_spLocator )
									);
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}
		
		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch (...)
		{
			// no choice have to give others a chance!
			::InterlockedDecrement ( &g_lRef );

			g_bWorking = FALSE;
			::SetEvent(g_hDoneWorkEvt);

			return E_OUTOFMEMORY;
		}

		if (FAILED(hRes))
		{
			g_lRef--;
		}

		g_bWorking = FALSE;
		::SetEvent(g_hDoneWorkEvt);
		::LeaveCriticalSection ( &g_cs );
	}

	return hRes;
}
		
//Performs unitialization ONLY if necessary. While unitializing sets global g_bWorking to TRUE.
void DoUninit()
{
	BOOL bDoWork = FALSE;

	try
	{
		::EnterCriticalSection ( &g_cs );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRef == 1 )
	{
		bDoWork = TRUE;
		g_bWorking = TRUE;
		::ResetEvent(g_hDoneWorkEvt);
	}
	else
	{
		g_lRef--;
	}

	::LeaveCriticalSection( &g_cs );

	if (bDoWork)
	{
		try
		{
			if ( _App.m_hKill.GetHANDLE() )
			{
				::SetEvent ( _App.m_hKill );
			}

			// is refresh of registry already done ?
			if ( ((WmiAdapterStuff*)_App)->RequestGet() )
			{
				((WmiAdapterStuff*)_App)->Generate ( FALSE );
			}

			////////////////////////////////////////////////////////////////////////
			// LOCATOR
			////////////////////////////////////////////////////////////////////////
			try
			{
				( ( WmiAdapterStuff* ) _App )->m_Stuff.m_spLocator.Release();
			}
			catch ( ... )
			{
			}
		}
		catch (...)
		{
		}

		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch ( ... )
		{
			//gotta give others a chance to work, risk it!
			::InterlockedDecrement ( &g_lRef );

			g_bWorking = FALSE;
			::SetEvent( g_hDoneWorkEvt );
			return;
		}

		g_lRef--;
		g_bWorking = FALSE;
		::SetEvent( g_hDoneWorkEvt );
		::LeaveCriticalSection ( &g_cs );
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// WIN MAIN
//
/////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI   WinRun		( );

extern "C" int WINAPI _tWinMain		( HINSTANCE hInstance, HINSTANCE, LPTSTR, int )
{
	return WinMain ( hInstance, NULL, GetCommandLineA(), SW_SHOW );
}

extern "C" int WINAPI   WinMain		( HINSTANCE, HINSTANCE, LPSTR, int )
{
	if ( CStaticCritSec::anyFailure () )
	{
		//
		// some critical section was not
		// initialized properly due to low memory
		//
		return ERROR_NOT_ENOUGH_MEMORY ;
	}

	HRESULT	nRet		= S_FALSE;

	////////////////////////////////////////////////////////////////////////
	// initialization
	////////////////////////////////////////////////////////////////////////
	if SUCCEEDED ( nRet = _App.InitAttributes ( ) )
	{
		////////////////////////////////////////////////////////////////////////
		// variables
		////////////////////////////////////////////////////////////////////////

		WCHAR	szTokens[]	= L"-/";

		////////////////////////////////////////////////////////////
		// initialization
		////////////////////////////////////////////////////////////
		if SUCCEEDED ( nRet = _App.Init ( ) )
		{
			////////////////////////////////////////////////////////////////////////
			// command line
			////////////////////////////////////////////////////////////////////////
			LPWSTR lpCmdLine = GetCommandLineW();

			////////////////////////////////////////////////////////////////////////
			// find behaviour
			////////////////////////////////////////////////////////////////////////

			LPCWSTR lpszToken	= WmiAdapterApp::FindOneOf(lpCmdLine, szTokens);
			BOOL	bContinue	= TRUE;
			try
			{
				while (lpszToken != NULL && bContinue)
				{
					if (lstrcmpiW(lpszToken, L"UnregServer")==0)
					{
						////////////////////////////////////////////////////////////////
						// unregister service
						////////////////////////////////////////////////////////////////
						if SUCCEEDED ( nRet = _Service.UnregisterService ( ) )
						{
							((WmiAdapterStuff*)_App)->Generate( FALSE, UnRegistration );

							////////////////////////////////////////////////////////////
							// unregister registry
							////////////////////////////////////////////////////////////
							WmiAdapterRegistryService::__UpdateRegistrySZ( false );
						}

						bContinue = FALSE;
					}
					else
					{
						if (lstrcmpiW(lpszToken, L"RegServer")==0)
						{
							////////////////////////////////////////////////////////////
							// register service
							////////////////////////////////////////////////////////////
							if SUCCEEDED ( nRet = _Service.RegisterService ( ) )
							{
								////////////////////////////////////////////////////////
								// create registry again
								////////////////////////////////////////////////////////
								WmiAdapterRegistryService::__UpdateRegistrySZ( true );

								((WmiAdapterStuff*)_App)->Generate( FALSE, Registration );
							}

							bContinue = FALSE;
						}
					}

					lpszToken = WmiAdapterApp::FindOneOf(lpszToken, szTokens);
				}

				if ( bContinue )
				{
					////////////////////////////////////////////////////////////////
					// previous instance
					////////////////////////////////////////////////////////////////
					if ( ! _App.Exists() )
					{
						////////////////////////////////////////////////////////
						// initialization
						////////////////////////////////////////////////////////
						_Service.Init	( );

						__SmartServiceHANDLE	pSCM;
						if ( ( pSCM = OpenSCManager	(
														NULL,                   // machine (NULL == local)
														NULL,                   // database (NULL == default)
														SC_MANAGER_ALL_ACCESS   // access required
													) ) != NULL )
						{
							__SmartServiceHANDLE	pService;
							if ( ( pService = OpenServiceW ( pSCM, g_szAppName, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG ) )
								!= NULL )
							{
								LPQUERY_SERVICE_CONFIG	lpQSC = NULL;
								DWORD					dwQSC = 0L;

								try
								{
									if ( ! QueryServiceConfig ( pService, lpQSC, 0, &dwQSC ) )
									{
										if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
										{
											if ( ( lpQSC = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LPTR, dwQSC ) ) != NULL )
											{
												if ( QueryServiceConfig ( pService, lpQSC, dwQSC, &dwQSC ) != 0 )
												{
													_App.m_bManual = ( lpQSC->dwStartType == SERVICE_DEMAND_START );
												}
											}
										}
									}
								}
								catch ( ... )
								{
								}

								LocalFree ( lpQSC ); 

								SERVICE_STATUS s;
								QueryServiceStatus ( pService, &s );

								// we are service, not running ???
								if( s.dwCurrentState != SERVICE_RUNNING )
								{
									if ( ! _Service.StartService () )
									{
										DWORD dwError = ERROR_SUCCESS;
										dwError = ::GetLastError();

										if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
										{
											nRet = HRESULT_FROM_WIN32 ( dwError );
										}
										else
										{
											nRet = HRESULT_FROM_WIN32 ( ERROR_NOT_READY );
										}
									}
								}
								else
								{
									DWORD dwError = ERROR_SUCCESS;
									dwError = ::GetLastError();

									if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
									{
										nRet = HRESULT_FROM_WIN32 ( dwError );
									}
									else
									{
										nRet = HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
									}
								}
							}
							else
							{
								DWORD dwError = ERROR_SUCCESS;
								dwError = ::GetLastError();

								if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
								{
									nRet = HRESULT_FROM_WIN32 ( dwError );
								}
								else
								{
									nRet = E_FAIL;
								}
							}
						}
						else
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError();

							if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
							{
								nRet = HRESULT_FROM_WIN32 ( dwError );
							}
							else
							{
								nRet = E_FAIL;
							}
						}
					}
					else
					{
						////////////////////////////////////////////////////////////
						// termination
						////////////////////////////////////////////////////////////
						nRet =  HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
					}
				}
			}
			catch ( ... )
			{
				// catastrophic failure
				nRet = E_FAIL;
			}

			// return
			if SUCCEEDED ( nRet )
			{
				nRet = _Service.GetServiceStatus()->dwWin32ExitCode;
			}

			_App.Term ();
		}
	}

	return nRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// RUN :))
//
///////////////////////////////////////////////////////////////////////////////
extern "C" int WINAPI WinRun( )
{
	///////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	///////////////////////////////////////////////////////////////////////////

	LONG	lRes = ERROR_SUCCESS;
	HRESULT hRes = E_FAIL;

	///////////////////////////////////////////////////////////////////////////
	// COM INITIALIZATION
	///////////////////////////////////////////////////////////////////////////
	if SUCCEEDED ( hRes = ::CoInitializeEx(NULL, COINIT_MULTITHREADED) )
	{
		// mark service is running IMMEDIATELY
		_Service.SetServiceStatus ( SERVICE_RUNNING );

		if SUCCEEDED ( hRes = DoInit() )
		{
			try
			{
				if ( ( lRes = _Service.Work () ) != S_OK )
				{
					if ( _App.m_hKill.GetHANDLE() )
					{
						::SetEvent ( _App.m_hKill );
					}
				}

				::WaitForSingleObject ( _App.m_hKill, INFINITE );
			}
			catch ( ... )
			{
				lRes = E_UNEXPECTED;
			}

			///////////////////////////////////////////////////////////////////
			// do real finishing stuff ( synchronize etc )
			///////////////////////////////////////////////////////////////////
			DoUninit();
		}

		///////////////////////////////////////////////////////////////////////
		// COM UNINITIALIZATION
		///////////////////////////////////////////////////////////////////////
		::CoUninitialize();
	}

	if FAILED ( hRes )
	{
		// something was wrong in helpers
		return hRes;
	}
	else
	{
		// result from real work
		return ( lRes == S_FALSE ) ? S_OK : lRes;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_service_work.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Service_Work.cpp
//
//	Abstract:
//
//					module for service real working
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// service module
#include "WMIAdapter_Service.h"
extern WmiAdapterService	_Service;

extern	LONG				g_lRefLib;		// reference count of perf libraries
extern	CStaticCritSec		g_csInit;		// synch object used to protect above globals

/////////////////////////////////////////////////////////////////////////////
//
// WORK
//
/////////////////////////////////////////////////////////////////////////////

LONG WmiAdapterService::Work ( void )
{
	LONG		lReturn = 0L;

	if ( _App.m_bManual )
	{
		((WmiAdapterStuff*)_App)->Init();
	}
	else
	{
		try
		{
			////////////////////////////////////////////////////////////////////////////////
			// INITIALIZE
			////////////////////////////////////////////////////////////////////////////////

			if FAILED ( lReturn = ((WmiAdapterStuff*)_App)->Initialize() )
			{
				ATLTRACE (	L"*************************************************************\n"
							L"worker initialization failed ... %d ... 0x%x\n"
							L"*************************************************************\n",
							::GetCurrentThreadId(),
							lReturn
						 );
			}
		}
		catch ( ... )
		{
		}
	}

	DWORD	dwHandles = 3;
	HANDLE	hHandles[] =

	{
		_App.m_hKill,
		_App.GetInit(),
		_App.GetUninit()
	};

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService WAIT for INITIALIZATION event\n"
				L"*************************************************************\n" );

	DWORD	dwWaitResult	= 0L;
	BOOL	bContinue		= TRUE;

	try
	{
		while ( bContinue &&

				( ( dwWaitResult = ::WaitForMultipleObjects	(
																dwHandles - 1,
																hHandles,
																FALSE,
																INFINITE
															)
				) != WAIT_OBJECT_0 )
			  )
		{
			if ( dwWaitResult == WAIT_OBJECT_0 + 1 )
			{
				BOOL bContinueRefresh = TRUE;

				try
				{
					////////////////////////////////////////////////////////////////
					// INITIALIZE PERFORMANCE 
					////////////////////////////////////////////////////////////////
					if ( ( lReturn = ((WmiAdapterStuff*)_App)->InitializePerformance() ) != S_OK )
					{
						ATLTRACE (	L"*************************************************************\n"
									L"worker initialization failed ... %d ... 0x%x\n"
									L"*************************************************************\n",
									::GetCurrentThreadId(),
									lReturn
								 );

						// go to main loop
						bContinueRefresh = FALSE;

						if ( _App.m_bManual )
						{
							// go away
							bContinue = FALSE;
						}
					}
				}
				catch ( ... )
				{
				}

				if ( ! bContinueRefresh &&
					   ((WmiAdapterStuff*)_App)->IsValidInternalRegistry() &&
					 ! ((WmiAdapterStuff*)_App)->IsValidBasePerfRegistry()
					   
				   )
				{
					// make termination refersh
					((WmiAdapterStuff*)_App)->RequestSet();
				}

				if ( bContinueRefresh )
				{
					ATLTRACE (	L"*************************************************************\n"
								L"WmiAdapterService WAIT for WORK\n"
								L"*************************************************************\n" );

					dwWaitResult = WAIT_TIMEOUT;

					#ifdef	__SUPPORT_WAIT
					BOOL bFirstRefresh    = TRUE;
					#endif	__SUPPORT_WAIT

					do
					{
						switch ( dwWaitResult )
						{
							case WAIT_TIMEOUT:
							{
								// show trace timeout gone
								ATLTRACE ( L"WAIT_TIMEOUT ... Performance ... id %x\n", ::GetCurrentThreadId() );

								try
								{
									// refresh everything ( internal ) :))
									((WmiAdapterStuff*)_App)->Refresh();
								}
								catch ( ... )
								{
								}

								// send library event we are ready
								#ifdef	__SUPPORT_WAIT
								if ( bFirstRefresh )
								{
									_App.SignalData ();
									bFirstRefresh = FALSE;
								}
								#endif	__SUPPORT_WAIT
							}
							break;

							case WAIT_OBJECT_0 + 1:
							{
								// dwWaitResult == WAIT_OBJECT_0 + 1
								::InterlockedIncrement ( &g_lRefLib );
							}
							break;

							case WAIT_OBJECT_0 + 2:
							{
								try
								{
									////////////////////////////////////////////////////////////
									// UNINITIALIZE PERFORMANCE 
									////////////////////////////////////////////////////////////
									if ( ((WmiAdapterStuff*)_App)->UninitializePerformance() == S_OK )
									{
										// got to the main loop only when it is last one
										bContinueRefresh = FALSE;
									}
								}
								catch ( ... )
								{
									// something goes wrong
									// got to the main loop
									bContinueRefresh = FALSE;
								}
							}
							break;

							default:
							{
								try
								{
									////////////////////////////////////////////////////////////
									// UNINITIALIZE PERFORMANCE 
									////////////////////////////////////////////////////////////
									((WmiAdapterStuff*)_App)->UninitializePerformance();
								}
								catch ( ... )
								{
								}

								// something goes wrong
								// got to the main loop
								bContinueRefresh = FALSE;
							}
							break;
						}

						#ifdef	__SUPPORT_ICECAP_ONCE
						{
							// got to the main loop
							bContinueRefresh	= FALSE;
							bContinue			= FALSE;
						}
						#endif	__SUPPORT_ICECAP_ONCE

						/////////////////////////////////////////////////////////////////////////
						// check usage of shared memory ( protect against perfmon has killed )
						/////////////////////////////////////////////////////////////////////////
						((WmiAdapterStuff*)_App)->CheckUsage();
					}
					while (	bContinueRefresh &&
							( ( dwWaitResult = ::WaitForMultipleObjects	(
																			dwHandles,
																			hHandles,
																			FALSE,
																			1000
																		)
							) != WAIT_OBJECT_0 )
						  );

					// reset library event we are starting again
					#ifdef	__SUPPORT_WAIT
					_App.SignalData ( FALSE );
					#endif	__SUPPORT_WAIT

					if ( ! _App.m_bManual )
					{
						// is refresh of registry already done ?
						if ( ((WmiAdapterStuff*)_App)->RequestGet() )
						{
							if ( ::TryEnterCriticalSection ( &g_csInit ) )
							{
								// lock & leave CS
								_App.InUseSet ( TRUE );
								::LeaveCriticalSection ( &g_csInit );

								try
								{
									( ( WmiAdapterStuff*) _App )->Generate ( ) ;
								}
								catch ( ... )
								{
								}

								if ( ::TryEnterCriticalSection ( &g_csInit ) )
								{
									// unlock & leave CS
									_App.InUseSet ( FALSE );

									::LeaveCriticalSection ( &g_csInit );
								}
							}
						}
					}
				}
			}
			else
			{
				bContinue = FALSE;
			}
		}
	}
	catch ( ... )
	{
	}

	try
	{
		#ifdef	__SUPPORT_ICECAP_ONCE
		if ( dwWaitResult == WAIT_TIMEOUT )
		#else	__SUPPORT_ICECAP_ONCE
		if ( dwWaitResult == WAIT_OBJECT_0 )
		#endif	__SUPPORT_ICECAP_ONCE
		{
			if ( ::InterlockedCompareExchange ( &g_lRefLib, g_lRefLib, g_lRefLib ) > 0 )
			{
				try
				{
					////////////////////////////////////////////////////////////////
					// UNINITIALIZE PERFORMANCE 
					////////////////////////////////////////////////////////////////
					((WmiAdapterStuff*)_App)->UninitializePerformance();
				}
				catch ( ... )
				{
				}
			}
		}
	}
	catch ( ... )
	{
	}

	try
	{
		////////////////////////////////////////////////////////////////////////
		// UNINITIALIZE
		////////////////////////////////////////////////////////////////////////
		((WmiAdapterStuff*)_App)->Uninitialize();
	}
	catch ( ... )
	{
	}

	if ( _App.m_bManual )
	{
		((WmiAdapterStuff*)_App)->Uninit();
	}

	return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_service.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Service.cpp
//
//	Abstract:
//
//					module for service
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// messaging
#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// service module
#include "WMIAdapter_Service.h"
extern WmiAdapterService	_Service;

extern	LONG				g_lRefLib;	// refcount of libarries attached into process
extern	CStaticCritSec		g_csInit;	// synch object used to protect above globals

/////////////////////////////////////////////////////////////////////////////////////////
// destruction
/////////////////////////////////////////////////////////////////////////////////////////

WmiAdapterService::~WmiAdapterService()
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService destruction\n"
				L"*************************************************************\n" );

	if ( m_hServiceStatus )
	{
//		service status handle doesn't have to be closed
//		::CloseHandle ( m_hServiceStatus );

		m_hServiceStatus = NULL;
	}

	::DeleteCriticalSection ( &m_cs );
}

///////////////////////////////////////////////////////////////////////////////////////////////
// service status
///////////////////////////////////////////////////////////////////////////////////////////////
BOOL WmiAdapterService::SetServiceStatus ( DWORD dwState )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService set status\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

	m_ServiceStatus.dwCurrentState = dwState;

	try
	{
		return ::SetServiceStatus ( m_hServiceStatus, &m_ServiceStatus );
	}
	catch ( ... )
	{
	}

	return FALSE;
}

SERVICE_STATUS* WmiAdapterService::GetServiceStatus ( void ) const
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService get status\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

	return const_cast < SERVICE_STATUS* > ( &m_ServiceStatus );
}

/////////////////////////////////////////////////////////////////////////////////////////
// run body :))
/////////////////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI WinRun	( );

/////////////////////////////////////////////////////////////////////////////////////////
// functions
/////////////////////////////////////////////////////////////////////////////////////////

void WINAPI WmiAdapterService::_ServiceMain(DWORD dwArgc, LPWSTR* lpszArgv)
{
    _Service.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI WmiAdapterService::_ServiceHandler(DWORD dwOpcode)
{
    _Service.ServiceHandler(dwOpcode); 
}

/////////////////////////////////////////////////////////////////////////////////////////
// routine
/////////////////////////////////////////////////////////////////////////////////////////

inline void WmiAdapterService::ServiceMain( DWORD, LPWSTR* )
{
	// Register the control request handler
	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

	if ( ( m_hServiceStatus = RegisterServiceCtrlHandlerW(g_szAppName, _ServiceHandler) ) == NULL )
	{
		#ifdef	__SUPPORT_EVENTVWR
		try
		{
			((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
		}
		catch ( ... )
		{
		}
		#endif	__SUPPORT_EVENTVWR

		return;
	}

	SetServiceStatus(SERVICE_START_PENDING);

	m_ServiceStatus.dwWin32ExitCode	= S_OK;
	m_ServiceStatus.dwCheckPoint	= 0;
	m_ServiceStatus.dwWaitHint		= 0;

	try
	{
		m_ServiceStatus.dwWin32ExitCode	= WinRun ( );
	}
	catch ( ... )
	{
		m_ServiceStatus.dwWin32ExitCode	= static_cast < ULONG > ( E_UNEXPECTED );
	}

	SetServiceStatus ( SERVICE_STOPPED );
}

/////////////////////////////////////////////////////////////////////////////////////////
// handler
/////////////////////////////////////////////////////////////////////////////////////////

inline void WmiAdapterService::ServiceHandler(DWORD dwOpcode)
{
	// auto lock/unlock
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

    switch (dwOpcode)
    {
		case SERVICE_CONTROL_STOP:
		{
			BOOL bStop = FALSE;

			if ( ::TryEnterCriticalSection ( &g_csInit ) )
			{
				if ( ( ::InterlockedCompareExchange ( &g_lRefLib, 0, 0 ) == 0 ) && ! _App.InUseGet() )
				{
					bStop = TRUE;
				}

				::LeaveCriticalSection ( &g_csInit );
			}

			if ( bStop )
			{
				if ( SetServiceStatus ( SERVICE_STOP_PENDING ) )
				{
					if ( _App.m_hKill.GetHANDLE() )
					{
						// kill application
						::SetEvent	( _App.m_hKill );
					}
				}
			}
		}
		break;
		case SERVICE_CONTROL_CONTINUE:
		{
			m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
		}
		break;
		case SERVICE_CONTROL_PAUSE:
		break;
		case SERVICE_CONTROL_INTERROGATE:
		break;
		case SERVICE_CONTROL_SHUTDOWN:
		break;

		default:
		{
			// bad service status :))
		}
    }
}

BOOL WmiAdapterService::StartService ( void )
{
	SERVICE_TABLE_ENTRY st[] =
	{
		{ const_cast < LPWSTR > ( g_szAppName ), _ServiceMain },
		{ NULL, NULL }
	};

	if ( ! ::StartServiceCtrlDispatcher ( st ) )
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
// initialization
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::Init ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService initialization\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

    m_hServiceStatus = NULL;

    m_ServiceStatus.dwServiceType				= SERVICE_WIN32_OWN_PROCESS;
    m_ServiceStatus.dwCurrentState				= SERVICE_STOPPED;
    m_ServiceStatus.dwControlsAccepted			= SERVICE_ACCEPT_STOP;
    m_ServiceStatus.dwWin32ExitCode				= 0;
    m_ServiceStatus.dwServiceSpecificExitCode	= 0;
    m_ServiceStatus.dwCheckPoint				= 0;
    m_ServiceStatus.dwWaitHint					= 0;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
// helper if installed
/////////////////////////////////////////////////////////////////////////////////////////

int WmiAdapterService::IsInstalled ( SC_HANDLE hSC )
{
	int iResult = -1;

	if ( hSC )
	{
		__SmartServiceHANDLE hService;


		if ( ( hService = ::OpenServiceW ( hSC, g_szAppName, SERVICE_QUERY_CONFIG ) ) != NULL )
		{
			iResult = 1;
		}
		else
		{
			iResult = 0;
		}
	}

	return iResult;
}

/////////////////////////////////////////////////////////////////////////////////////////
// register service
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::RegisterService ( void )
{
	HRESULT hr = S_FALSE;

	// Unregister service ( could have bad variables )
	hr = UnregisterService ( false );

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService registration\n"
				L"*************************************************************\n" );

	if SUCCEEDED ( hr )
	{
		// SCM has suggested wait a while if we were deleting
		if ( hr == S_OK )
		{
			// I do not like it either, but there is no way
			// to waitforsingleobject on some kernel object ...
			::Sleep ( 3000 );
		}

		__SmartServiceHANDLE hSC;
		if ( ( hSC = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) != NULL )
		{
			// Get the executable file path
			WCHAR wszFilePath[_MAX_PATH] = { L'\0' };
			::GetModuleFileNameW(NULL, wszFilePath, _MAX_PATH-1);

			__SmartServiceHANDLE hService;

			// create service description
			LPWSTR wszServiceName = NULL;

			try
			{
				wszServiceName = LoadStringSystem ( ::GetModuleHandle( NULL ), IDS_NAME );
			}
			catch ( ... )
			{
				if ( wszServiceName )
				{
					delete [] wszServiceName;
					wszServiceName = NULL;
				}
			}

			if ( ( hService = ::CreateServiceW	(	hSC,
													g_szAppName,

													( wszServiceName != NULL ) ?
														wszServiceName : 
														L"WMI Performance Adapter",

													SERVICE_ALL_ACCESS,
													SERVICE_WIN32_OWN_PROCESS,
													SERVICE_DEMAND_START,
													SERVICE_ERROR_NORMAL,
													wszFilePath,
													0,
													0,
													L"RPCSS\0",
													0,
													0
												) )
				 != NULL )
			{
				hr = E_OUTOFMEMORY;

				// create service description
				LPWSTR wszDescription = NULL;

				try
				{
					if ( ( wszDescription = LoadStringSystem ( ::GetModuleHandle( NULL ), IDS_DESCRIPTION ) ) != NULL )
					{
						hr = S_OK;

						SERVICE_DESCRIPTION sd;
						sd.lpDescription = wszDescription;

						if ( ! ChangeServiceConfig2 ( hService, SERVICE_CONFIG_DESCRIPTION, reinterpret_cast < LPVOID > ( &sd ) ) )
						{
							hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
						}
					}
				}
				catch ( ... )
				{
					hr = E_FAIL;
				}

				if ( wszDescription )
				{
					delete [] wszDescription;
					wszDescription = NULL;
				}
			}
			else
			{
				#ifdef	__SUPPORT_EVENTVWR
				LPWSTR wszError = NULL;

				wszError = GetErrorMessageModule ( WMI_ADAPTER_CREATE_SC_FAIL, _App.m_hResources );
				::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

				delete wszError;

				try
				{
					((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_CREATE_SC_FAIL, 0, 0, 0, 0 );
				}
				catch ( ... )
				{
				}
				#endif	__SUPPORT_EVENTVWR

				if ( wszServiceName )
				{
					delete [] wszServiceName;
					wszServiceName = NULL;
				}

				// unable to create service
				hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
			}

			if ( wszServiceName )
			{
				delete [] wszServiceName;
				wszServiceName = NULL;
			}
		}
		else
		{
			#ifdef	__SUPPORT_EVENTVWR
			LPWSTR wszError = NULL;

			wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SCM_FAIL, _App.m_hResources );
			::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

			delete wszError;

			try
			{
				((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
			}
			catch ( ... )
			{
			}
			#endif	__SUPPORT_EVENTVWR

			// unable to open service manager
			hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// unregister service
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::UnregisterService ( bool bStatus )
{
	HRESULT hr = S_FALSE;

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService unregistartion\n"
				L"*************************************************************\n" );

	__SmartServiceHANDLE hSCM;
	if ( ( hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) != NULL )
	{
		if ( IsInstalled ( hSCM ) != 0 )
		{
			BOOL bContinue = TRUE;
			BOOL bSucceeded= FALSE;

			DWORD	dwTry = 5;
			while ( bContinue && dwTry-- )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW( hSCM, g_szAppName, SERVICE_QUERY_STATUS | SERVICE_STOP ) ) != NULL)
				{
					SERVICE_STATUS s;
					QueryServiceStatus ( hService, &s );

					// we are service what's our status
					if( s.dwCurrentState != SERVICE_STOPPED )
					{
						if ( ! ::ControlService( hService, SERVICE_CONTROL_STOP, &s ) )
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError ();

							switch ( dwError )
							{
								case ERROR_SERVICE_NOT_ACTIVE:
								{
									bContinue = FALSE;
									bSucceeded= TRUE;
								}
								break;

								case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
								{
									if ( s.dwCurrentState == SERVICE_STOPPED )
									{
										bContinue = FALSE;
										bSucceeded= TRUE;
									}
								}
								break;

								default:
								{
									bContinue = FALSE;
									hr = HRESULT_FROM_WIN32 ( dwError );
								}
								break;
							}
						}
						else
						{
							bSucceeded = TRUE;
						}
					}
					else
					{
						bContinue = FALSE;
						bSucceeded= TRUE;
					}
				}
				else
				{
					#ifdef	__SUPPORT_EVENTVWR
					LPWSTR wszError = NULL;

					wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SC_FAIL, _App.m_hResources );
					::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

					delete wszError;

					try
					{
						((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SC_FAIL, 0, 0, 0, 0 );
					}
					catch ( ... )
					{
					}
					#endif	__SUPPORT_EVENTVWR

					// unable to open service
					hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
					bContinue = FALSE;
				}
			}

			if ( bSucceeded )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW( hSCM, g_szAppName, DELETE ) ) != NULL)
				{
					BOOL bDelete = FALSE;
					if ( ( bDelete = ::DeleteService( hService ) ) == FALSE )
					{
						hr = S_FALSE;
					}
					else
					{
						hr = S_OK;
					}

					if ( bStatus )
					{
						#ifdef	__SUPPORT_EVENTVWR
						LPWSTR wszError = NULL;

						wszError = GetErrorMessageModule ( WMI_ADAPTER_DELETE_SC_FAIL, _App.m_hResources );
						::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

						delete wszError;

						try
						{
							((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_DELETE_SC_FAIL, 0, 0, 0, 0 );
						}
						catch ( ... )
						{
						}
						#endif	__SUPPORT_EVENTVWR
					}
				}
				else
				{
					#ifdef	__SUPPORT_EVENTVWR
					LPWSTR wszError = NULL;

					wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SC_FAIL, _App.m_hResources );
					::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

					delete wszError;

					try
					{
						((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SC_FAIL, 0, 0, 0, 0 );
					}
					catch ( ... )
					{
					}
					#endif	__SUPPORT_EVENTVWR

					// unable to open service
					hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
					bContinue = FALSE;
				}
			}
		}
	}
	else
	{
		#ifdef	__SUPPORT_EVENTVWR
		LPWSTR wszError = NULL;

		wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SCM_FAIL, _App.m_hResources );
		::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

		delete wszError;

		try
		{
			((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
		}
		catch ( ... )
		{
		}
		#endif	__SUPPORT_EVENTVWR

		// unable to open service manager
		hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff.cpp
//
//	Abstract:
//
//					module for application stuff ( security, event logging ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

#include "WMIAdapter_Stuff.h"
#include "WMIAdapter_Stuff_Refresh.cpp"

#include "RefresherUtils.h"

///////////////////////////////////////////////////////////////////////////////
// IsValid
///////////////////////////////////////////////////////////////////////////////
BOOL	WmiAdapterStuff::IsValidBasePerfRegistry ( )
{
	return	( m_data.IsValidGenerate () );
}

BOOL	WmiAdapterStuff::IsValidInternalRegistry ( )
{
	return	( m_data.GetPerformanceData() != NULL );
}

///////////////////////////////////////////////////////////////////////////////
// init
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Init ( )
{
	return m_Stuff.Init();
}

///////////////////////////////////////////////////////////////////////////////
// uninit
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Uninit ( )
{
	return m_Stuff.Uninit();
}

///////////////////////////////////////////////////////////////////////////////
// construction
///////////////////////////////////////////////////////////////////////////////
WmiAdapterStuff::WmiAdapterStuff() :

m_pWMIRefresh ( NULL )

{
	try
	{
		if ( ( m_pWMIRefresh = new WmiRefresh < WmiAdapterStuff > ( this ) ) == NULL )
		{
			return;
		}
	}
	catch ( ... )
	{
		return;
	}
}

///////////////////////////////////////////////////////////////////////////////
// destruction
///////////////////////////////////////////////////////////////////////////////
WmiAdapterStuff::~WmiAdapterStuff()
{
	try
	{
		if ( m_pWMIRefresh )
		{
			delete m_pWMIRefresh;
			m_pWMIRefresh = NULL;
		}
	}
	catch ( ... )
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
// generate requested ?
///////////////////////////////////////////////////////////////////////////////
extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyRefresh;

BOOL	WmiAdapterStuff::RequestGet ()
{
	DWORD dwValue = 0;
	GetRegistry ( g_szKey, g_szKeyRefresh, &dwValue );

	return ( ( dwValue ) ? TRUE : FALSE ); 
}

BOOL	WmiAdapterStuff::RequestSet ()
{
	BOOL bResult = FALSE;

	if ( ! ( bResult = RequestGet () ) )
	{
		bResult = SUCCEEDED ( SetRegistry ( g_szKey, g_szKeyRefresh, 1 ) );
	}

	return bResult; 
}

///////////////////////////////////////////////////////////////////////////////
// generate
///////////////////////////////////////////////////////////////////////////////
extern __SmartHANDLE		g_hRefreshMutex;
extern __SmartHANDLE		g_hRefreshMutexLib;
extern __SmartHANDLE		g_hRefreshFlag;

HRESULT WmiAdapterStuff::Generate ( BOOL bInitialize, GenerateEnum type )
{
	HRESULT hRes = E_FAIL;

	BOOL	bInit			= FALSE;
	BOOL	bOwnFlag		= FALSE;
	BOOL	bOwnMutex		= FALSE;
	BOOL	bLocked			= FALSE;
	DWORD	dwWaitResult	= 0L;

	DWORD	dwHandles	= 2;
	HANDLE	hHandles[]	=
	{
		g_hRefreshMutex,
		g_hRefreshMutexLib
	};

	dwWaitResult = ::WaitForMultipleObjects ( dwHandles, hHandles, TRUE, 0 );
	if ( dwWaitResult == WAIT_TIMEOUT )
	{
		bLocked = TRUE;
	}
	else
	{
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			bOwnMutex	= TRUE;
			hRes		= S_OK;
		}
	}

	if ( bLocked )
	{
		DWORD	dwHandles = 3;
		HANDLE	hHandles[] =

		{
			_App.m_hKill,
			g_hRefreshMutex,
			g_hRefreshMutexLib
		};

		dwWaitResult = ::WaitForMultipleObjects	(
													dwHandles,
													hHandles,
													FALSE,
													INFINITE
												);

		switch	( dwWaitResult )
		{
			case WAIT_OBJECT_0 + 2:
			{
				dwWaitResult = ::WaitForMultipleObjects	(
															dwHandles - 1,
															hHandles,
															FALSE,
															INFINITE
														);

				if ( dwWaitResult != WAIT_OBJECT_0 + 1 )
				{
					hRes = E_UNEXPECTED;

					::ReleaseMutex ( g_hRefreshMutexLib );
					break;
				}
			}

			case WAIT_OBJECT_0 + 1:
			{
				// we got a mutex so must reinit because registry might changed
				bOwnMutex	= TRUE;
				bInit		= TRUE;

				hRes		= S_OK;
			}
			break;

			case WAIT_OBJECT_0:
			{
				hRes = S_FALSE;
			}
			break;

			default:
			{
				hRes = E_UNEXPECTED;
			}
			break;
		}
	}

	if ( hRes == S_OK )
	{
		dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, INFINITE );
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			// mutex guarding registry has to be cleared
			bOwnFlag	= TRUE;

			// call refresh procedure
			hRes = m_Stuff.Generate ( FALSE, type );

			if SUCCEEDED ( hRes )
			{
				// reinit because registry might changed
				bInit = TRUE;
			}
		}
		else
		{
			hRes = E_UNEXPECTED;
		}
	}

	// if we got a mutex and are supposed to refresh our selves
	if ( bInitialize && bInit )
	{
		///////////////////////////////////////////////////////////////////////
		// clear first
		///////////////////////////////////////////////////////////////////////
		try
		{
			// clear internal structure ( obtained from registry )
			m_data.ClearPerformanceData();
		}
		catch ( ... )
		{
		}

		try
		{
			if ( m_pWMIRefresh )
			{
				// remove enums :))
				m_pWMIRefresh->RemoveHandles();
			}
		}
		catch ( ... )
		{
		}

		///////////////////////////////////////////////////////////////////////
		// obtain registry structure and make arrays
		///////////////////////////////////////////////////////////////////////
		if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
		{
			m_data.Generate ();

			if ( m_data.IsValidGenerate () )
			{
				if ( m_pWMIRefresh )
				{
					// add handles :))
					m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() );
				}
			}
			else
			{
				hRes = E_FAIL;
			}
		}
	}

	if ( bOwnFlag )
	{
		::ReleaseMutex ( g_hRefreshFlag );
	}

	if ( bOwnMutex )
	{
		::ReleaseMutex ( g_hRefreshMutexLib );
		::ReleaseMutex ( g_hRefreshMutex );
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff_performance.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 - 2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff_Performance.cpp
//
//	Abstract:
//
//					performance stuff ( init, uninit, real refresh ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapter_Stuff.h"
#include "WMIAdapter_Stuff_Refresh.cpp"

// messaging
#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)

////////////////////////////////////////////////////////////////////////////////
// GLOBAL STUFF
////////////////////////////////////////////////////////////////////////////////

extern __SmartHANDLE	g_hRefreshFlag;		// already defined in static library

extern __SmartHANDLE	g_hRefreshMutex;	// already defined in static library
BOOL					g_bRefreshMutex;	// do we own a mutex

__SmartHANDLE		g_hDoneInitEvt	= NULL;		//	event to set when init/uninit is finished ( nonsignaled )
BOOL				g_bWorkingInit	= FALSE;	//	boolean used to tell if init/unit is finished
BOOL				g_bInit			= FALSE;	//	current state - initialized or not.
CStaticCritSec		g_csInit;					//	synch object used to protect above globals

LONG				g_lRefLib		= 0;		//	count of perf libs attached into work
__SmartHANDLE		g_hDoneLibEvt	= NULL;		//	event to set when perf init/uninit is finished ( nonsignaled )
BOOL				g_bWorkingLib	= FALSE;	//	boolean used to tell if perf init/unit in progress

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyRefreshed;

////////////////////////////////////////////////////////////////////////////////
// INITIALIZE DATA
////////////////////////////////////////////////////////////////////////////////
HRESULT WmiAdapterStuff::Initialize ( )
{
	HRESULT hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	BOOL bLocked		= FALSE;
	BOOL bRefreshMutex	= FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( ! g_bWorkingInit )
		{
			if ( ! g_lRefLib && ! g_bInit )
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( g_hRefreshMutex, 0 );

				if ( dwWaitResult == WAIT_TIMEOUT )
				{
					bLocked = TRUE;
					hRes = S_FALSE;
				}
				else
				{
					if ( dwWaitResult == WAIT_OBJECT_0 )
					{
						bRefreshMutex = TRUE;
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					bDoWork = TRUE;
					g_bWorkingInit = TRUE;
					::ResetEvent ( g_hDoneInitEvt );
				}
			}

			bWait = FALSE;
		}
		else
		{
			::LeaveCriticalSection ( &g_csInit );
			
			if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneInitEvt, INFINITE ) )
			{
				return hRes;
			}
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if ( bDoWork )
	{
		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// init stuff for adapter ( never FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Init();
			}
			catch ( ... )
			{
			}
		}

		if ( bLocked )
		{
			DWORD dwWaitResult = 0L;

			DWORD	dwHandles = 2;
			HANDLE	hHandles[] =

			{
				_App.m_hKill,
				g_hRefreshMutex
			};

			dwWaitResult = ::WaitForMultipleObjects	(
														dwHandles,
														hHandles,
														FALSE,
														INFINITE
													);

			switch	( dwWaitResult )
			{
				case WAIT_OBJECT_0 + 1:
				{
					hRes = S_OK;
				}
				break;

				default:
				{
					hRes = E_FAIL;
				}
				break;
			}
		}

		if SUCCEEDED ( hRes )
		{
			try
			{
				///////////////////////////////////////////////////////////////////////
				// obtain registry structure
				///////////////////////////////////////////////////////////////////////
				if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
				{
					if ( m_pWMIRefresh )
					{
						// add handles :))

						BOOL	bReconnect	= TRUE;
						DWORD	dwReconnect	= 3;

						do
						{
							if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
							{
								m_pWMIRefresh->RemoveHandles ();

								try
								{
									// close handle to winmgmt ( only if exists )
									m_Stuff.WMIHandleClose ();

									Uninit ();
									Init ();

									// open handle to winmgmt
									m_Stuff.WMIHandleOpen ();
								}
								catch ( ... )
								{
									bReconnect = FALSE;
								}
							}
							else
							{
								bReconnect = FALSE;
							}
						}
						while ( bReconnect && dwReconnect-- );
					}

					// change flag to let them now we are done
					if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
					{
						SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
						::ReleaseMutex ( g_hRefreshFlag );
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if ( hRes != S_OK )
			{
				// TOTAL CLEANUP ( FAILURE )
				try
				{
					// clear internal structure ( obtained from registry )
					m_data.ClearPerformanceData();
				}
				catch ( ... )
				{
				}

				try
				{
					if ( m_pWMIRefresh )
					{
						// remove enums :))
						m_pWMIRefresh->RemoveHandles();
					}
				}
				catch ( ... )
				{
				}
			}
		}

		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// uninit stuff for adapter ( never FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Uninit();
			}
			catch ( ... )
			{
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			g_bWorkingInit = FALSE;
			::SetEvent ( g_hDoneInitEvt );

			if ( bRefreshMutex )
			{
				::ReleaseMutex ( g_hRefreshMutex );
				bRefreshMutex = FALSE;
			}

			return E_OUTOFMEMORY;
		}

		if SUCCEEDED ( hRes )
		{
			g_bInit = TRUE;
		}

		g_bWorkingInit = FALSE;
		::SetEvent ( g_hDoneInitEvt );

		// change flag to let them now we are done
		if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
		{
			hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
			::ReleaseMutex ( g_hRefreshFlag );
		}

		if ( bRefreshMutex )
		{
			::ReleaseMutex ( g_hRefreshMutex );
			bRefreshMutex = FALSE;
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf initialize
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::InitializePerformance ( void )
{
	HRESULT hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	BOOL bLocked	= FALSE;
	BOOL bInitPerf	= FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( ! _App.m_bManual && ! g_bInit )
		{
			bWait = FALSE;
		}
		else
		{
			if ( g_lRefLib == 0 )
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( g_hRefreshMutex, 0 );

				if ( dwWaitResult == WAIT_TIMEOUT )
				{
					bLocked = TRUE;
					hRes = S_FALSE;
				}
				else
				{
					if ( dwWaitResult == WAIT_OBJECT_0 )
					{
						g_bRefreshMutex = TRUE;
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					bDoWork = TRUE;
					g_lRefLib++;
					g_bWorkingLib = TRUE;
					::ResetEvent ( g_hDoneLibEvt );
				}

				bWait = FALSE;
			}
			else
			{
				if ( g_bWorkingLib )
				{
					::LeaveCriticalSection ( &g_csInit );
					
					if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneLibEvt, INFINITE ) )
					{
						return hRes;
					}
				}
				else
				{
					bWait = FALSE;
					g_lRefLib++;
					hRes = S_OK;
				}
			}
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if (bDoWork)
	{
		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// init stuff for adapter ( NEVER FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				DWORD	dwStatus	= 0L;

				if ( m_Stuff.GetWMI () )
				{
					if ( ( GetExitCodeProcess ( m_Stuff.GetWMI (), &dwStatus ) ) != 0 )
					{
						if ( dwStatus != STILL_ACTIVE )
						{
							bInitPerf = TRUE;
						}
					}
				}
				else
				{
					//
					// we didn't have a handle to winmgmt
					// let's try to get it again
					//

					bInitPerf = TRUE;
				}

				Init();

				if ( bInitPerf )
				{
					// close handle to winmgmt ( only if exists )
					m_Stuff.WMIHandleClose ();

					// open handle to winmgmt
					m_Stuff.WMIHandleOpen ();
				}
			}
			catch ( ... )
			{
			}
		}
		else
		{
			bInitPerf = TRUE;
		}

		if ( bLocked )
		{
			DWORD dwWaitResult = 0L;

			DWORD	dwHandles = 2;
			HANDLE	hHandles[] =

			{
				_App.m_hKill,
				g_hRefreshMutex
			};

			dwWaitResult = ::WaitForMultipleObjects	(
														dwHandles,
														hHandles,
														FALSE,
														INFINITE
													);

			switch	( dwWaitResult )
			{
				case WAIT_OBJECT_0 + 1:
				{
					// we got a mutex so must reinit because registry might changed
					g_bRefreshMutex = TRUE;

					if ( ! _App.m_bManual )
					{
						DWORD	dwValue = 0L;

						if SUCCEEDED ( GetRegistry ( g_szKey, g_szKeyRefreshed, &dwValue ) )
						{
							if ( dwValue )
							{
								///////////////////////////////////////////////////////////////////////
								// clear first
								///////////////////////////////////////////////////////////////////////
								try
								{
									// clear internal structure ( obtained from registry )
									m_data.ClearPerformanceData();
								}
								catch ( ... )
								{
								}

								try
								{
									if ( m_pWMIRefresh )
									{
										// remove enums :))
										m_pWMIRefresh->RemoveHandles();
									}
								}
								catch ( ... )
								{
								}

								bInitPerf = TRUE;
							}
						}
					}
				}
				break;

				default:
				{
					hRes = E_FAIL;
				}
				break;
			}
		}
		else
		{
			if ( ! _App.m_bManual )
			{
				DWORD	dwValue = 0L;

				if SUCCEEDED ( GetRegistry ( g_szKey, g_szKeyRefreshed, &dwValue ) )
				{
					if ( dwValue )
					{
						///////////////////////////////////////////////////////////////////////
						// clear first
						///////////////////////////////////////////////////////////////////////
						try
						{
							// clear internal structure ( obtained from registry )
							m_data.ClearPerformanceData();
						}
						catch ( ... )
						{
						}

						try
						{
							if ( m_pWMIRefresh )
							{
								// remove enums :))
								m_pWMIRefresh->RemoveHandles();
							}
						}
						catch ( ... )
						{
						}

						bInitPerf = TRUE;
					}
				}
			}
		}

		if ( SUCCEEDED ( hRes ) && bInitPerf )
		{
			///////////////////////////////////////////////////////////////////////
			// obtain registry structure and make arrays
			///////////////////////////////////////////////////////////////////////
			if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
			{
				if ( m_pWMIRefresh )
				{
					// add handles :))

					BOOL	bReconnect	= TRUE;
					DWORD	dwReconnect	= 3;

					do
					{
						if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
						{
							m_pWMIRefresh->RemoveHandles ();

							try
							{
								// close handle to winmgmt ( only if exists )
								m_Stuff.WMIHandleClose ();

								Uninit ();
								Init ();

								// open handle to winmgmt
								m_Stuff.WMIHandleOpen ();
							}
							catch ( ... )
							{
								bReconnect = FALSE;
							}
						}
						else
						{
							bReconnect = FALSE;
						}
					}
					while ( bReconnect && dwReconnect-- );
				}

				// change flag to let them now we are done
				if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
				{
					SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
					::ReleaseMutex ( g_hRefreshFlag );
				}
			}
		}
		else
		{
			if ( SUCCEEDED ( hRes ) && ! bInitPerf )
			{
				// I was not re-refreshing so everything is OK
				hRes = S_OK;
			}
		}

		if ( hRes == S_OK )
		{
			try
			{
				////////////////////////////////////////////////////////////////////////
				// initialize memory structure
				////////////////////////////////////////////////////////////////////////
				if SUCCEEDED( hRes = m_data.InitializeData () )
				{
					if SUCCEEDED( hRes = m_data.InitializeTable () )
					{

						////////////////////////////////////////////////////////////////
						// create shared memory :))
						////////////////////////////////////////////////////////////////
						if SUCCEEDED( hRes = 
									m_pMem.MemCreate(	L"Global\\WmiReverseAdapterMemory",
														((WmiSecurityAttributes*)_App)->GetSecurityAttributtes()
													)
									)
						{
							if ( m_pMem.MemCreate (	m_data.GetDataSize() + 
													m_data.GetDataTableSize() + 
													m_data.GetDataTableOffset()
												  ),

								 m_pMem.IsValid () )
							{
								try
								{
									if ( m_pWMIRefresh )
									{
										// init data
										m_pWMIRefresh->DataInit();

										// add enums :))

										BOOL	bReconnect	= TRUE;
										DWORD	dwReconnect	= 3;

										do
										{
											if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddEnum ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
											{
												m_pWMIRefresh->RemoveEnum ();
												m_pWMIRefresh->RemoveHandles ();

												try
												{
													// close handle to winmgmt ( only if exists )
													m_Stuff.WMIHandleClose ();

													Uninit ();
													Init ();

													// open handle to winmgmt
													m_Stuff.WMIHandleOpen ();
												}
												catch ( ... )
												{
													bReconnect = FALSE;
												}

												if ( bReconnect )
												{
													BOOL	bReconnectHandles	= TRUE;
													DWORD	dwReconnectHandles	= 3;

													do
													{
														if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
														{
															m_pWMIRefresh->RemoveHandles ();

															try
															{
																// close handle to winmgmt ( only if exists )
																m_Stuff.WMIHandleClose ();

																Uninit ();
																Init ();

																// open handle to winmgmt
																m_Stuff.WMIHandleOpen ();
															}
															catch ( ... )
															{
																bReconnectHandles = FALSE;
															}
														}
														else
														{
															bReconnectHandles = FALSE;
														}
													}
													while ( bReconnectHandles && dwReconnectHandles-- );
												}
											}
											else
											{
												bReconnect = FALSE;
											}
										}
										while ( bReconnect && dwReconnect-- );
									}
								}
								catch ( ... )
								{
									hRes =  E_FAIL;
								}
							}
							else
							{
								hRes = E_OUTOFMEMORY;
							}
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			// TOTAL CLEANUP DUE TO FAILURE
			if FAILED ( hRes )
			{
				try
				{
					m_data.DataClear();
					m_data.DataTableClear();
				}
				catch ( ... )
				{
				}

				try
				{
					// clear shared memory :))
					if ( m_pMem.IsValid() )
					{
						m_pMem.MemDelete();
					}
				}
				catch ( ... )
				{
				}

				try
				{
					if ( m_pWMIRefresh )
					{
						// remove enums :))
						m_pWMIRefresh->RemoveEnum();

						// uninit data
						m_pWMIRefresh->DataUninit();
					}
				}
				catch ( ... )
				{
				}
			}
		}

		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// uninit stuff for adapter ( NEVER FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Uninit();
			}
			catch ( ... )
			{
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if ( hRes != S_OK )
			{
				g_lRefLib--;
			}

			g_bWorkingLib = FALSE;
			::SetEvent(g_hDoneLibEvt);

			return E_OUTOFMEMORY;
		}

		if ( hRes != S_OK )
		{
			g_lRefLib--;
		}

		g_bWorkingLib = FALSE;
		::SetEvent(g_hDoneLibEvt);

		if ( hRes == S_OK )
		{
			// let service now we are in use
			_App.InUseSet ( TRUE );
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf refresh
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Refresh()
{
	HRESULT hRes = S_FALSE;

	try
	{
		if ( ::TryEnterCriticalSection ( &g_csInit ) )
		{
			if SUCCEEDED ( hRes = m_pWMIRefresh->Refresh() )
			{
				try
				{
					//////////////////////////////////////////////////////////////////////
					// create proper data and refres table
					//////////////////////////////////////////////////////////////////////
					if SUCCEEDED ( hRes = m_data.CreateData	( m_pWMIRefresh->GetEnums (), m_pWMIRefresh->GetProvs ()) )
					{
						m_data.RefreshTable	( );

						//////////////////////////////////////////////////////////////////
						// fill memory :))
						//////////////////////////////////////////////////////////////////

						if ( m_pMem.Write (	m_data.GetDataTable(),
											m_data.GetDataTableSize(),
											NULL,
											m_data.GetDataTableOffset()
										  )
						   )
						{
							// write everything into memory :))

							DWORD dwBytesRead	= 0L;
							DWORD dwOffset		= m_data.GetDataTableSize() + m_data.GetDataTableOffset();

							DWORD dwRealSize = m_data.__GetValue ( m_data.GetDataTable(), offsetRealSize );

							DWORD dwIndexWritten = 0L;
							DWORD dwBytesWritten = 0L;

							while ( ( dwBytesWritten < dwRealSize ) && SUCCEEDED ( hRes ) )
							{
								DWORD dwBytesWrote	= 0L;
								BYTE* ptr			= NULL;

								ptr = m_data.GetData ( dwIndexWritten++, &dwBytesRead );

								if ( m_pMem.Write ( ptr, dwBytesRead, &dwBytesWrote, dwOffset ) && dwBytesWrote )
								{
									dwOffset		+= dwBytesWrote;
									dwBytesWritten	+= dwBytesWrote;
								}
								else
								{
									hRes = E_FAIL;
								}
							}
						}
						else
						{
							hRes = E_FAIL;
						}
					}
				}
				catch ( ... )
				{
				}
			}

			::LeaveCriticalSection ( &g_csInit );
		}
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	};

	#ifdef	_DEBUG
	if FAILED ( hRes )
	{
		ATLTRACE ( L"\n\n\n ******* REFRESH FAILED ******* \n\n\n" );
	}
	#endif	_DEBUG

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf uninitialize
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::UninitializePerformance ( void )
{
	HRESULT	hRes	= S_FALSE;
	BOOL	bDoWork = FALSE;

	try
	{
		::EnterCriticalSection ( &g_csInit );
	}
	catch ( ... )
	{
		return E_OUTOFMEMORY;
	}

	if ( g_lRefLib == 1 )
	{
		bDoWork = TRUE;
		g_bWorkingLib = TRUE;
		::ResetEvent(g_hDoneLibEvt);
	}
	else
	{
		if ( g_lRefLib )
		{
			g_lRefLib--;
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if (bDoWork)
	{
		// clear internal structure ( obtained from registry )
		try
		{
			m_data.DataClear();
			m_data.DataTableClear();
		}
		catch ( ... )
		{
		}

		try
		{
			// clear shared memory :))
			if ( m_pMem.IsValid() )
			{
				m_pMem.MemDelete();
			}
		}
		catch ( ... )
		{
		}

		try
		{
			if ( m_pWMIRefresh )
			{
				// remove enums :))
				m_pWMIRefresh->RemoveEnum();

				// uninit data
				m_pWMIRefresh->DataUninit();
			}
		}
		catch ( ... )
		{
		}

		if ( g_bRefreshMutex )
		{
			::ReleaseMutex ( g_hRefreshMutex );
			g_bRefreshMutex = FALSE;
		}

		::CoFreeUnusedLibraries ( );

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			//gotta give others a chance to work, risk it!
			g_lRefLib--;
			g_bWorkingLib = FALSE;
			::SetEvent( g_hDoneLibEvt );

			// let service now we are not in use anymore
			_App.InUseSet ( FALSE );

			return E_OUTOFMEMORY;
		}

		g_bWorkingLib = FALSE;
		g_lRefLib--;
		::SetEvent( g_hDoneLibEvt );

		// let service now we are not in use anymore
		_App.InUseSet ( FALSE );

		hRes = S_OK;

		if ( _App.m_bManual )
		{
			::SetEvent ( _App.m_hKill );
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

////////////////////////////////////////////////////////////////////////////////
// UNINITIALIZE FINAL
////////////////////////////////////////////////////////////////////////////////
void	WmiAdapterStuff::Uninitialize ( void )
{
	if ( ! _App.m_bManual )
	{
		// close handle to winmgmt
		m_Stuff.WMIHandleClose ();
	}

	try
	{
		// clear internal structure ( obtained from registry )
		m_data.ClearPerformanceData();
	}
	catch ( ... )
	{
	}

	try
	{
		if ( m_pWMIRefresh )
		{
			// remove enums :))
			m_pWMIRefresh->RemoveHandles();
		}
	}
	catch ( ... )
	{
	}
}

/////////////////////////////////////////////////////////////////////////
// check usage of shared memory ( protect against perfmon has killed )
// undocumented kernel stuff for having number of object here
/////////////////////////////////////////////////////////////////////////

void	WmiAdapterStuff::CheckUsage ( void )
{
	// variables
	WmiReverseMemoryExt<WmiReverseGuard>* pMem = NULL;

	if ( m_pMem.IsValid() )
	{
		if ( ( pMem = m_pMem.GetMemory ( 0 ) ) != NULL )
		{
			LONG lRefCount = 0L;
			if ( ( lRefCount = pMem->References () ) > 0 )
			{
				if	(	lRefCount == 1 &&
						::InterlockedCompareExchange ( &g_lRefLib, g_lRefLib, 1 )
					)
				{
					HANDLE hUninit = NULL;
					if ( ( hUninit = _App.GetUninit() ) != NULL )
					{
						::ReleaseSemaphore( hUninit, 1, NULL );
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff_refresh.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff_Refresh.cpp
//
//	Abstract:
//
//					module for refersh stuff ( WMI refresh HELPER )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapter_Stuff.h"

extern LPCWSTR g_szNamespace1;
extern LPCWSTR g_szNamespace2;

enum NamespaceIn
{
	CIMV2,
	WMI,
	UNKNOWN
};

///////////////////////////////////////////////////////////////////////////////
// performance refreshing CLASS
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
class WmiRefresh
{
	DECLARE_NO_COPY ( WmiRefresh );

	WmiRefreshParent*	parent;

	// variables
	IWbemRefresher*				m_pRefresher;		// A pointer to the refresher
	IWbemConfigureRefresher*	m_pConfig;			// A pointer to the refresher's manager

	__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >	m_Enums;	// enumerators
	__WrapperARRAY< WmiRefreshObject* >							m_Provs;	// providers ( handles )

	DWORD m_dwCount;

	public:

	WmiRefresh  ( WmiRefreshParent* pParent );
	~WmiRefresh ();

	HRESULT DataInit();
	HRESULT	DataUninit();

	///////////////////////////////////////////////////////////////////////////
	// accessors
	///////////////////////////////////////////////////////////////////////////
	__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >&	GetEnums ()
	{
		return m_Enums;
	}

	__WrapperARRAY< WmiRefreshObject* >	&						GetProvs ()
	{
		return m_Provs;
	}

	///////////////////////////////////////////////////////////////////////////
	// real refreshing stuff
	///////////////////////////////////////////////////////////////////////////
	HRESULT	Refresh ( void )
	{
		try
		{
			if  ( m_pRefresher )
			{
				return m_pRefresher->Refresh ( 0L );
			}
			else
			{
				return E_FAIL;
			}
		}
		catch ( ... )
		{
			return E_UNEXPECTED;
		}
	}

	///////////////////////////////////////////////////////////////////////////
	// enums
	///////////////////////////////////////////////////////////////////////////
	HRESULT	AddEnum		( PWMI_PERFORMANCE perf );
	HRESULT	RemoveEnum	( void);

	///////////////////////////////////////////////////////////////////////////
	// handles
	///////////////////////////////////////////////////////////////////////////
	HRESULT	AddHandles		( PWMI_PERFORMANCE perf );
	HRESULT	RemoveHandles	( void);

	private:

	HRESULT	CreateHandles ( IWbemServices* pServices, PWMI_PERF_OBJECT obj, WmiRefreshObject** ppObj );

	// count of enums
	DWORD	GetEnumCount ( PWMI_PERFORMANCE perf );
	DWORD	GetEnumCount ( void );
};

///////////////////////////////////////////////////////////////////////////////
// construction & destruction
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
WmiRefresh < WmiRefreshParent >::WmiRefresh( WmiRefreshParent* pParent ) :

m_dwCount ( 0 ),

parent ( pParent ),

m_pRefresher	( NULL ),
m_pConfig		( NULL )

{
//	// Create the refresher and refresher manager
//	// ==========================================
//	DataInit();
}

template < class WmiRefreshParent >
WmiRefresh < WmiRefreshParent >::~WmiRefresh()
{
	// to be sure
	RemoveEnum();
	DataUninit();

	parent = NULL;
}

///////////////////////////////////////////////////////////////////////////////
// init stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::DataInit()
{
	HRESULT hRes = S_OK;

	// create refresher
	if SUCCEEDED( hRes = ::CoCreateInstance(	__uuidof ( WbemRefresher ), 
												NULL, 
												CLSCTX_INPROC_SERVER, 
												__uuidof ( IWbemRefresher ), 
												(void**) &m_pRefresher
										   )
				)
	{
		// crete refresher manager
		hRes = m_pRefresher->QueryInterface	(	__uuidof ( IWbemConfigureRefresher ),
												(void**) &m_pConfig
											);
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::DataUninit()
{
	HRESULT hRes = S_FALSE;
	if ( m_pRefresher && m_pConfig )
	{
		hRes = S_OK;
	}

	try
	{
		// destroy refresher
		if ( m_pRefresher )
		{
			m_pRefresher->Release();
			m_pRefresher = NULL;
		}
	}
	catch ( ... )
	{
		m_pRefresher = NULL;
	}

	try
	{
		// destroy refresher manager
		if ( m_pConfig )
		{
			m_pConfig->Release();
			m_pConfig = NULL;
		}
	}
	catch ( ... )
	{
		m_pConfig = NULL;
	}

	// we're successfull allready
	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// ENUM HELPERS
///////////////////////////////////////////////////////////////////////////////

template < class WmiRefreshParent >
DWORD WmiRefresh < WmiRefreshParent >::GetEnumCount ( PWMI_PERFORMANCE perf )
{
	DWORD dwCount = 0;

	if ( perf != NULL )
	{
		PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
		for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
		{
			dwCount += n->dwChildCount;
			n = __Namespace::Next ( n );
		}
	}

	return dwCount;
}

template < class WmiRefreshParent >
DWORD WmiRefresh < WmiRefreshParent >::GetEnumCount ( void )
{
	if ( m_Enums.IsEmpty() )
	{
		return 0L;
	}

	return ((DWORD)m_Enums);
}

///////////////////////////////////////////////////////////////////////////////
// handles stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::RemoveHandles ( void )
{
	try
	{
		// reset all handlers
		if ( ! m_Provs.IsEmpty() )
		{
			for ( DWORD dw = m_Provs; dw > 0 ; dw-- )
			{
				if ( m_Provs[dw-1] )
				m_Provs.DataDelete(dw-1);
			}

			delete [] m_Provs.Detach();
			m_Provs.SetData ( NULL, NULL );
		}
	}
	catch ( ... )
	{
	}

	return S_OK;
}

template < class WmiRefreshParent >
HRESULT	WmiRefresh < WmiRefreshParent >::AddHandles ( PWMI_PERFORMANCE perf )
{
	if ( perf == NULL )
	{
		RemoveHandles ();
		return S_FALSE;
	}

	DWORD dwIndex = 0L;
	m_dwCount = GetEnumCount ( perf );

	typedef WmiRefreshObject*						PWmiRefreshObject;

	// result
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		m_Provs.SetData ( new PWmiRefreshObject[m_dwCount], m_dwCount );

		if ( !m_Provs.IsEmpty() )
		{
//			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
//			{
//				m_Provs.SetAt ( dw );
//			}

			///////////////////////////////////////////////////////////////////////////
			// go accross all namespaces and add them into refresher
			///////////////////////////////////////////////////////////////////////////

			PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
			for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
			{
				DWORD dwItem = UNKNOWN;

				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace1 ) ) == 0 )
				{
					dwItem = CIMV2;
				}
				else
//				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace2 ) ) == 0 )
				{
					dwItem = WMI;
				}

				PWMI_PERF_OBJECT o = __Object::First ( n );
				for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
				{
					WmiRefreshObject* pobj = NULL;

					switch ( dwItem )
					{
						case CIMV2:
						{
							if ( parent->m_Stuff.m_pServices_CIM )
							hRes = CreateHandles ( parent->m_Stuff.m_pServices_CIM, o, &pobj );
						}
						break;

						case WMI:
						{
							if ( parent->m_Stuff.m_pServices_WMI )
							hRes = CreateHandles ( parent->m_Stuff.m_pServices_WMI, o, &pobj );
						}
						break;
					}

					if ( hRes == WBEM_E_NOT_FOUND )
					{
						// let adapter know it is supposed to refresh at the end
						parent->RequestSet ();
					}

//					if SUCCEEDED ( hRes )
//					{
						try
						{
							m_Provs.SetAt ( dwIndex++, pobj );
						}
						catch ( ... )
						{
							hRes = E_FAIL;
						}
//					}

					// get next object
					o = __Object::Next ( o );
				}

				// get next namespace
				n = __Namespace::Next ( n );
			}

		}
	}
	catch ( ... )
	{
		m_Provs.SetData ( NULL, NULL );
		hRes = E_FAIL;
	}

	return hRes;
}

template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::CreateHandles ( IWbemServices* pServices, PWMI_PERF_OBJECT obj, WmiRefreshObject** pObj )
{
	if ( ! pServices || ! obj )
	{
		return E_INVALIDARG;
	}

	// main body :))

	HRESULT hRes = S_OK;

	try
	{
		if ( ( ( *pObj ) = new WmiRefreshObject() ) == NULL )
		{
			return E_OUTOFMEMORY;
		}

		CComPtr < IWbemClassObject >	pClass;
		CComPtr < IWbemObjectAccess >	pAccess;

		if SUCCEEDED ( hRes = pServices -> GetObject ( CComBSTR ( __Object::GetName( obj ) ), 0, 0, &pClass, 0 ) )
		{
			if SUCCEEDED ( hRes = pClass -> QueryInterface ( __uuidof ( IWbemObjectAccess ) , (void**) &pAccess ) )
			{
				if ( ( (*pObj)->m_pHandles = new LONG[obj->dwChildCount + 2] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				long lHandle = 0;

				pAccess->GetPropertyHandle( L"Timestamp_PerfTime", NULL, &lHandle );
				(*pObj)->m_pHandles[0] = lHandle;

				lHandle = 0;

				hRes = pAccess->GetPropertyHandle( L"Frequency_PerfTime", NULL, &lHandle );
				(*pObj)->m_pHandles[1] = lHandle;

				// obtain all handles and store them into array
				PWMI_PERF_PROPERTY p = NULL;

				if ( obj->dwSingleton )
				{
					// jump across instance
					PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( obj ) + obj->dwLength );
					p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
				}
				else
				{
					p = __Property::First ( obj );
				}

				for ( DWORD dw = 0; dw < obj->dwChildCount; dw++ )
				{
					lHandle = 0;

					if SUCCEEDED ( hRes = pAccess->GetPropertyHandle( CComBSTR ( __Property::GetName ( p ) ), NULL, &lHandle ) )
					{
						(*pObj)->m_pHandles[dw+2] = lHandle;
						p = __Property::Next ( p );
					}
					else
					{
						// clear we were failed
						delete ( *pObj );
						( *pObj ) = NULL;

						return hRes;
					}
				}
			}
		}
	}
	catch ( ... )
	{
		if ( ( *pObj ) )
		{
			// clear we were failed
			delete ( *pObj );
			( *pObj ) = NULL;
		}

		return E_FAIL;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// enum stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::RemoveEnum ( void )
{
	try
	{
		// reset all enumerators :))
		if ( ! m_Enums.IsEmpty() )
		{
			for ( DWORD dw = m_Enums; dw > 0 ; dw-- )
			{
				if ( m_Enums[dw-1] )
				{
					// remove enum from refresher
					if ( m_pConfig )
					{
						try
						{
							m_pConfig->Remove ( m_Enums[dw-1]->GetID(), WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT );
						}
						catch ( ... )
						{
							m_pConfig = NULL;
						}
					}

					try
					{
						// remove all objects from enum
						if ( m_Enums[dw-1]->IsValid() )
						{
							IWbemHiPerfEnum * pEnum = NULL;
							if ( ( pEnum = m_Enums[dw-1]->GetMember() ) != NULL )
							{
								pEnum->RemoveAll ( 0 );
							}
						}
					}
					catch ( ... )
					{
					}

					m_Enums[dw-1]->Reset();
					m_Enums.DataDelete(dw-1);
				}
			}

			delete [] m_Enums.Detach();
			m_Enums.SetData ( NULL, NULL );
		}
	}
	catch ( ... )
	{
	}

	return S_OK;
}

template < class WmiRefreshParent >
HRESULT	WmiRefresh < WmiRefreshParent >::AddEnum ( PWMI_PERFORMANCE perf )
{
	if ( ! m_pConfig )
	{
		return E_UNEXPECTED;
	}

	DWORD dwIndex = 0L;

	typedef WmiRefresherMember<IWbemHiPerfEnum>*	PWmiRefresherMemberEnum;

	// result
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		m_Enums.SetData ( new PWmiRefresherMemberEnum[ m_dwCount ], m_dwCount );

		if ( !m_Enums.IsEmpty() )
		{
//			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
//			{
//				m_Enums.SetAt ( dw );
//			}

			///////////////////////////////////////////////////////////////////////////
			// go accross all namespaces and add them into refresher
			///////////////////////////////////////////////////////////////////////////

			PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
			for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
			{
				DWORD dwItem = UNKNOWN;

				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace1 ) ) == 0 )
				{
					dwItem = CIMV2;
				}
				else
//				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace2 ) ) == 0 )
				{
					dwItem = WMI;
				}

				PWMI_PERF_OBJECT o = __Object::First ( n );
				for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
				{
					CComPtr < IWbemHiPerfEnum > pEnum;
					long						lEnum = 0L;

					switch ( dwItem )
					{
						case CIMV2:
						{
							if ( parent->m_Stuff.m_pServices_CIM )
							hRes = m_pConfig->AddEnum (	parent->m_Stuff.m_pServices_CIM,
														__Object::GetName ( o ),
														0,
														NULL,
														&pEnum,
														&lEnum
													 );
						}
						break;

						case WMI:
						{
							if ( parent->m_Stuff.m_pServices_WMI )
							hRes = m_pConfig->AddEnum (	parent->m_Stuff.m_pServices_WMI,
														__Object::GetName ( o ),
														0,
														NULL,
														&pEnum,
														&lEnum
													 );
						}
						break;
					}

					if SUCCEEDED ( hRes )
					{
						WmiRefresherMember < IWbemHiPerfEnum > * mem = NULL;

						try
						{
							if ( ( mem = new WmiRefresherMember < IWbemHiPerfEnum > () ) != NULL )
							{
								if ( ! ( pEnum == NULL ) )
								{
									mem->Set ( pEnum, lEnum );
								}

								m_Enums.SetAt ( dwIndex++, mem );
							}
							else
							{
								m_Enums.SetAt ( dwIndex++ );
							}
						}
						catch ( ... )
						{
							if ( mem )
							{
								delete mem;
								mem = NULL;
							}

							m_Enums.SetAt ( dwIndex++ );
							hRes = E_FAIL;
						}
					}
					else
					{
						// if enum exist remove from refresher
						if ( ( pEnum == NULL ) && ( m_pConfig == NULL ) )
						{
							try
							{
								m_pConfig->Remove ( lEnum, WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT );
							}
							catch ( ... )
							{
								m_pConfig = NULL;
							}
						}

						m_Enums.SetAt ( dwIndex++ );
					}

					// get next object
					o = __Object::Next ( o );
				}

				// get next namespace
				n = __Namespace::Next ( n );
			}
		}
	}
	catch ( ... )
	{
		m_Enums.SetData ( NULL, NULL );
		hRes = E_FAIL;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter.cpp
//
//	Abstract:
//
//					Defines the entry point for the DLL application.
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_adapter.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

////////////////////////////////////////////////////////////////////////////////////
// variables
////////////////////////////////////////////////////////////////////////////////////

#include "wmi_adapter_wrapper.h"
__WrapperPtr<WmiAdapterWrapper>		pWrapper;

#include "wmi_eventlog.h"
__WrapperPtr<CPerformanceEventLog>	pEventLog;

#include "wmi_security.h"
#include "wmi_security_attributes.h"
__WrapperPtr<WmiSecurityAttributes>	pSA;

#include "WMI_adapter_registry.h"

// save instance
HMODULE g_hModule		= NULL;

#ifdef	__SUPPORT_ICECAP
#include <icecap.h>
#endif	__SUPPORT_ICECAP

#include <wmiaplog.h>

#include ".\\WMIAdapter_Refresh\\RefresherGenerate.H"

////////////////////////////////////////////////////////////////////////////////////
// dll main
////////////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  dwReason, LPVOID )
{
    switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			AdapterLogMessage0 ( L"DllMain -> DLL_PROCESS_ATTACH" );

//			if ( !lpReserved )
//			{
//				// loaded dynamic
//			}
//			else
//			{
//				// loaded static
//			}

			// disable attach/detach of threads
			::DisableThreadLibraryCalls ( (HMODULE) hModule );

			BOOL bResult = FALSE;

			try
			{
				// event log initialization
				pEventLog.SetData( new CPerformanceEventLog( L"WmiAdapter" ) );

				pSA.SetData ( new WmiSecurityAttributes() );
				if ( ! pSA.IsEmpty() )
				{
					if ( pSA->GetSecurityAttributtes () )
					{
						pWrapper.SetData( new WmiAdapterWrapper() );
						if ( ! pWrapper.IsEmpty() )
						{
							bResult = TRUE;
						}
					}
				}
			}
			catch ( ... )
			{
			}

			if ( bResult )
			{
				g_hModule		= ( HMODULE ) hModule;
			}

			return bResult;
		}
		break;

		case DLL_PROCESS_DETACH:
		{
			AdapterLogMessage0 ( L"DllMain -> DLL_PROCESS_DETACH" );

//			if ( !lpReserved )
//			{
//				// unloaded by FreeLibrary
//			}
//			else
//			{
//				// unloaded by end of proccess
//			}

			// delete event log
			if ( !pEventLog.IsEmpty() )
			{
				delete  pEventLog.Detach();
			}

			// delete perflib wrapper
			delete pWrapper.Detach ();

			// delete security attributes
			delete pSA.Detach();

			#ifdef	_DEBUG
			_CrtDumpMemoryLeaks();
			#endif	_DEBUG
		}
		break;

		// thread attaching is not used !!!
		case DLL_THREAD_ATTACH: break;
		case DLL_THREAD_DETACH: break;
    }

	AdapterLogMessage1 ( L"DllMain", 1 );
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// registration of perflib dll
////////////////////////////////////////////////////////////////////////////////////
EXTERN_C HRESULT __stdcall DllRegisterServer ( )
{
	if ( ::GetModuleFileNameW ( g_hModule, g_szPath, _MAX_PATH - 1 ) )
	{
		g_szPath [ _MAX_PATH - 1 ] = L'\0';
		HRESULT hr = S_OK;

		if SUCCEEDED ( hr = WmiAdapterRegistry::__UpdateRegistrySZ( true ) )
		{
			hr = DoReverseAdapterMaintenanceInternal ( FALSE, Registration );
		}

		return hr;
	}

	return HRESULT_FROM_WIN32 ( ::GetLastError() );
}

////////////////////////////////////////////////////////////////////////////////////
// unregistration of perflib dll
////////////////////////////////////////////////////////////////////////////////////
EXTERN_C HRESULT __stdcall DllUnregisterServer ( void )
{
	HRESULT hr = S_OK;

	if SUCCEEDED ( hr = DoReverseAdapterMaintenanceInternal ( FALSE, UnRegistration ) )
	{
		hr = WmiAdapterRegistry::__UpdateRegistrySZ( false );
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
// exported functions ( PERFORMANCE )
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

DWORD __stdcall WmiOpenPerfData	(	LPWSTR lpwszDeviceNames )
{
	#ifdef	__SUPPORT_ICECAP
	StartProfile ( PROFILE_GLOBALLEVEL, PROFILE_CURRENTID );
	#endif	__SUPPORT_ICECAP

	AdapterLogMessage0 ( L"WmiOpenPerfData" );
	return pWrapper->Open ( lpwszDeviceNames );
}

DWORD __stdcall WmiClosePerfData	()
{
	#ifdef	__SUPPORT_ICECAP
	StopProfile ( PROFILE_GLOBALLEVEL, PROFILE_CURRENTID );
	#endif	__SUPPORT_ICECAP

	AdapterLogMessage0 ( L"WmiClosePerfData" );
	return pWrapper->Close ( );
}

DWORD __stdcall WmiCollectPerfData	(	LPWSTR lpwszValue, 
										LPVOID *lppData, 
										LPDWORD lpcbBytes, 
										LPDWORD lpcbObjectTypes
									)
{
	return pWrapper->Collect ( lpwszValue, lppData, lpcbBytes, lpcbObjectTypes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_common.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_common.cpp
//
//	Abstract:
//
//					declarations of common constants
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR	g_szAppName			= L"WmiApSrv";
LPCWSTR	g_szAppNameGlobal	= L"Global\\WmiApSrv";

////////////////////////////////////////////////////////////////////////////////////
// this constants are part of static library already
////////////////////////////////////////////////////////////////////////////////////

/*

LPCWSTR	g_szRefreshMutex	= L"Global\\RefreshRA";

// namespaces
LPCWSTR	g_szNamespace1	= L"\\\\.\\root\\cimv2";
LPCWSTR	g_szNamespace2	= L"\\\\.\\root\\wmi";

// registry
LPCWSTR	g_szKey			= L"SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance";
LPCWSTR	g_szKeyValue	= L"Performance Data";

LPCWSTR	g_szKeyCounter	= L"SYSTEM\\CurrentControlSet\\Services\\WmiApRpl\\Performance";

*/

///////////////////////////////////////////////////////////////////////////////
// convertion
///////////////////////////////////////////////////////////////////////////////

WCHAR	g_szPath[_MAX_PATH] = { L'\0' };

LPCWSTR	g_szOpen	= L"WmiOpenPerfData";
LPCWSTR	g_szCollect	= L"WmiCollectPerfData";
LPCWSTR	g_szClose	= L"WmiClosePerfData";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter_wrapper_pseudo.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper_pseudo.cpp
//
//	Abstract:
//
//					Defines pseudo counter implementation
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "WMI_adapter_wrapper.h"
#include "RefresherUtils.h"

#define	cCountInstances	1
#define	cCountCounter	2

void WmiAdapterWrapper::AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset )
{
	// append structure
	if ( dwOffset <= m_dwData )
	{
		//
		// get min of "size to write" and 
		// "size available" so it won't overrun
		//

		DWORD dwCount = min ( dwStr, m_dwData - dwOffset );
		::CopyMemory ( m_pData + dwOffset, pStr, dwCount );

		dwOffset += dwCount;
	}

	return;
}

void WmiAdapterWrapper::AppendMemory ( DWORD dwValue, DWORD& dwOffset )
{
	* reinterpret_cast < PDWORD > ( m_pData + dwOffset ) = dwValue;
	dwOffset += sizeof ( DWORD );

	return;
}

extern LPCWSTR	g_szKeyCounter;

HRESULT	WmiAdapterWrapper::PseudoCreateRefresh ( )
{
	HRESULT hr = E_FAIL;

	DWORD	dwOffset	= 0L;
	DWORD	dwCount		= 0L;
	DWORD	dwHelp		= 0L;

	// get data from registry
	GetRegistrySame ( g_szKeyCounter, L"First Counter",	&dwCount );
	GetRegistrySame ( g_szKeyCounter, L"First Help",	&dwHelp );

	if ( dwCount && dwHelp && dwCount+1 == dwHelp )
	{
		m_dwPseudoCounter	= dwCount;
		m_dwPseudoHelp		= dwHelp;

		try
		{
			////////////////////////////////////////////////////////////////////
			// PERF_OBJECT_TYPE
			////////////////////////////////////////////////////////////////////

			#ifndef	_WIN64
			LPWSTR	Name = NULL;
			LPWSTR	Help = NULL;
			#endif	_WIN64

			// time
			unsigned __int64 _PerfTime = 0; 
			unsigned __int64 _PerfFreq = 0;

			AppendMemory (	m_dwData, dwOffset );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ) + 
							sizeof ( PERF_COUNTER_DEFINITION ) * cCountCounter, dwOffset );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ), dwOffset );

			AppendMemory (	dwCount, dwOffset );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&Name, sizeof ( LPWSTR ), dwOffset );
			#else	_WIN64
			AppendMemory (	0, dwOffset );
			#endif	_WIN64

			AppendMemory (	dwHelp, dwOffset );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&Help, sizeof ( LPWSTR ), dwOffset );
			#else	_WIN64
			AppendMemory (	0, dwOffset );
			#endif	_WIN64

			AppendMemory (	PERF_DETAIL_NOVICE, dwOffset );
			AppendMemory (	cCountCounter, dwOffset );
			AppendMemory (	( DWORD ) -1, dwOffset );
			AppendMemory (	( DWORD ) PERF_NO_INSTANCES, dwOffset );
			AppendMemory (	0, dwOffset );

			AppendMemory ( (BYTE*) &_PerfTime,	sizeof ( unsigned __int64 ), dwOffset );
			AppendMemory ( (BYTE*) &_PerfFreq,	sizeof ( unsigned __int64 ), dwOffset );

			// increment index :)))
			dwCount	+= 2;
			dwHelp	+= 2;

			for ( DWORD dw = 0; dw < cCountCounter; dw++ )
			{
				////////////////////////////////////////////////////////////////////
				// PERF_COUNTER_DEFINITION
				////////////////////////////////////////////////////////////////////

				AppendMemory ( sizeof ( PERF_COUNTER_DEFINITION), dwOffset );
				AppendMemory ( dwCount, dwOffset );

				#ifndef	_WIN64
				AppendMemory (	(BYTE*)&Name, sizeof ( LPWSTR ), dwOffset );
				#else	_WIN64
				AppendMemory (	0, dwOffset );
				#endif	_WIN64

				AppendMemory ( dwHelp, dwOffset );

				#ifndef	_WIN64
				AppendMemory (	(BYTE*)&Help, sizeof ( LPWSTR ), dwOffset );
				#else	_WIN64
				AppendMemory (	0, dwOffset );
				#endif	_WIN64

				AppendMemory ( (
									( dw == 0 ) ?
									(
										0
									)
									:
									(
										1
									)
								),
								dwOffset
							 );

				AppendMemory ( PERF_DETAIL_NOVICE, dwOffset );

				AppendMemory ( (
									( dw == 0 ) ?
									(
										PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL
									)
									:
									(
										PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL
									)
								),
								dwOffset
							 );
				
				AppendMemory ( sizeof ( __int64 ), dwOffset );

				AppendMemory (	sizeof ( PERF_COUNTER_BLOCK ) + sizeof ( DWORD ) + 
								sizeof ( __int64 ) * (int) dw, dwOffset );

				// increment index :)))
				dwCount	+= 2;
				dwHelp	+= 2;
			}

			////////////////////////////////////////////////////////////////////
			// PERF_COUNTER_BLOCK
			////////////////////////////////////////////////////////////////////

			// append counter block
			AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
								sizeof ( DWORD ) + 
								cCountCounter * sizeof ( __int64 ), dwOffset );

			// fill hole ( to be 8 aligned )
			// dwOffset +=  sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			/////////////////////////////////////////////////////////
			// resolve counter data
			/////////////////////////////////////////////////////////

			m_dwDataOffsetCounter = dwOffset;
			AppendMemory (	0, dwOffset );
			// fill hole ( to be 8 aligned )
			// dwOffset += sizeof ( __int64 ) - sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			m_dwDataOffsetValidity = dwOffset;
			AppendMemory (	0, dwOffset );
			// fill hole ( to be 8 aligned )
			// dwOffset += sizeof ( __int64 ) - sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			hr = S_OK;
		}
		catch ( ... )
		{
			PseudoDelete ();
		}
	}

	return hr;
}

HRESULT	WmiAdapterWrapper::PseudoCreate ()
{
	HRESULT hRes		= S_FALSE;

	if ( ! m_pData )
	{
		m_dwData	=	sizeof	( PERF_OBJECT_TYPE ) +
						sizeof	( PERF_COUNTER_DEFINITION ) * cCountCounter 
								+
								(
									cCountInstances * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
															cCountCounter * sizeof ( __int64 )
														 )
													)
								);

		try
		{
			if ( ( m_pData = new BYTE [ m_dwData ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			PseudoDelete ();
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			PseudoCreateRefresh ();
		}
	}
	else
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

void	WmiAdapterWrapper::PseudoDelete ()
{
	if ( m_pData )
	{
		delete [] m_pData;
		m_pData = NULL;
	}

	m_dwData		= 0L;

	m_dwDataOffsetCounter	= 0L;
	m_dwDataOffsetValidity	= 0L;
}

void	WmiAdapterWrapper::PseudoRefresh ( DWORD dwCount )
{
	DWORD dwOffset	= 0L;

	dwOffset = m_dwDataOffsetCounter;
	AppendMemory ( dwCount, dwOffset );
}

void	WmiAdapterWrapper::PseudoRefresh ( BOOL bValid )
{
	DWORD dwOffset	= 0L;
	DWORD dwValue	= 0L;
	
	dwOffset	= m_dwDataOffsetValidity;
	dwValue		= ( bValid ) ? 1 : 0 ;

	AppendMemory ( dwValue, dwOffset );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter_wrapper.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper.cpp
//
//	Abstract:
//
//					Defines wrapper for performance lib
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// event messages
#include "wmiadaptermessages.h"
// event log helpers
#include "wmi_eventlog.h"

//security helper
#include "wmi_security.h"
#include "wmi_security_attributes.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "WMI_adapter_wrapper.h"
#include "WMI_adapter_ObjectList.h"

// registry helpers
#include "wmi_perf_reg.h"

// shared memory
#include "wmi_reverse_memory.h"
#include "wmi_reverse_memory_ext.h"

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;

#ifndef	__WMI_PERF_REGSTRUCT__
#include "wmi_perf_regstruct.h"
#endif	__WMI_PERF_REGSTRUCT__

#include "RefresherUtils.h"

DWORD	GetCount ( LPCWSTR wszKey, LPCWSTR wszKeyValue )
{
	DWORD				dwResult	= 0L;
	PWMI_PERFORMANCE	p			= NULL;

	if SUCCEEDED ( GetRegistry ( wszKey, wszKeyValue, (BYTE**) &p ) )
	{
		try
		{
			if ( p )
			{
				PWMI_PERF_NAMESPACE n		= NULL;
				DWORD				dwCount	= 0L;

				// get namespace
				n = __Namespace::First ( p );

				// count num of supported objects ( first dword )
				for ( DWORD  dw = 0; dw < p->dwChildCount; dw++ )
				{
					dwCount += n->dwChildCount;
					n = __Namespace::Next ( n );
				}

				delete [] p;
				p = NULL;

				dwResult = dwCount;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			dwResult = 0L;
		}
	}

	return dwResult;
}

////////////////////////////////////////////////////////////////////////////////////
// variables & m