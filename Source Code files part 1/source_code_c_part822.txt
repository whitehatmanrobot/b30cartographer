  //  be preserved through dialog exit, update internal
                    //  struct after the hook proc is called.
                    //
                    ThunkOpenFileNameA2W(pOFI);
                }
                else
                {
                    bHookRet = (*lpfnHook)( hDlg,
                                            msgFILEOKW,
                                            0,
                                            (LPARAM)pOFI->pOFN );
                }
                if (bHookRet)
                {
                    HourGlass(FALSE);
                    break;
                }
            }

            wNoRedraw = 0;

            if (pOFI->pOFN->Flags & OFN_ENABLEHOOK)
            {
                LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                glpfnFileHook = lpfnHook;
            }

            RemoveProp(hDlg, FILEPROP);

            EndDialog(hDlg, bRet);

            if (pOFI)
            {
                if ((pOFN->Flags & OFN_NOCHANGEDIR) && *pOFI->szCurDir)
                {
                    ChangeDir(hDlg, pOFI->szCurDir, TRUE, FALSE);
                }
            }

            //
            //  WARNING:
            //  If the app subclasses ID_ABORT, the worker thread will never
            //  get exited.  This will cause problems.  Currently, there are
            //  no apps that do this, though.
            //

            return (TRUE);
            break;
        }
        case ( edt1 ) :
        {
            if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE )
            {
                int iIndex, iCount;
                HWND hLBox = GetDlgItem(hDlg, lst1);
                WORD wIndex = (WORD)SendMessage(hLBox, LB_GETCARETINDEX, 0, 0);

                szText[0] = CHAR_NULL;

                if (wIndex == (WORD)LB_ERR)
                {
                    break;
                }

                SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                             WM_GETTEXT,
                             (WPARAM)MAX_FULLPATHNAME,
                             (LPARAM)szText );

                if ((iIndex = (int)SendMessage( hLBox,
                                                LB_FINDSTRING,
                                                (WPARAM)(wIndex - 1),
                                                (LPARAM)szText )) != LB_ERR)
                {
                    RECT rRect;

                    iCount = (int)SendMessage(hLBox, LB_GETTOPINDEX, 0, 0L);
                    GetClientRect(hLBox, (LPRECT)&rRect);

                    if ((iIndex < iCount) ||
                        (iIndex >= (iCount + rRect.bottom / dyText)))
                    {
                        SendMessage(hLBox, LB_SETCARETINDEX, (WPARAM)iIndex, 0);
                        SendMessage(hLBox, LB_SETTOPINDEX, (WPARAM)iIndex, 0);
                    }
                }
                return (TRUE);
            }
            else if ( GET_WM_COMMAND_CMD(wParam, lParam) ==  EN_SETFOCUS )
            {
                SetModeBias(MODEBIASMODE_FILENAME);
            }
            else if ( GET_WM_COMMAND_CMD(wParam, lParam)== EN_KILLFOCUS )
            {
                SetModeBias(MODEBIASMODE_DEFAULT);
            }
            break;
        }
        case ( lst1 ) :
        {
            //
            //  A double click means OK.
            //
            if (GET_WM_COMMAND_CMD(wParam, lParam)== LBN_DBLCLK)
            {
                SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, 0, 0));
                return (TRUE);
            }
            else if (pOFN && (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE))
            {
                if (pOFN->Flags & OFN_ALLOWMULTISELECT)
                {
                    int *pSelIndex;

                    //
                    //  Muliselection allowed.
                    //
                    sCount = (SHORT)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                                LB_GETSELCOUNT,
                                                0,
                                                0L );
                    if (!sCount)
                    {
                        //
                        //  If nothing selected, clear edit control.
                        //
                        SetDlgItemText(hDlg, edt1, szNull);
                    }
                    else
                    {
                        DWORD cchMemBlockSize = 2048;
                        DWORD cchTotalLength = 0;

                        pSelIndex = (int *)LocalAlloc(LPTR, sCount * sizeof(int));
                        if (!pSelIndex)
                        {
                            goto LocalFailure1;
                        }

                        sCount = (SHORT)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETSELITEMS,
                                            (WPARAM)sCount,
                                            (LONG_PTR)(LPTSTR)pSelIndex );

                        pch2 = pch = (LPTSTR)
                             LocalAlloc(LPTR, cchMemBlockSize * sizeof(TCHAR));
                        if (!pch)
                        {
                            goto LocalFailure2;
                        }

                        for (*pch = CHAR_NULL, i = 0; i < sCount; i++)
                        {
                            len = (WORD)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETTEXTLEN,
                                            (WPARAM)(*(pSelIndex + i)),
                                            (LPARAM)0 );

                            //
                            //  Add the length of the selected file to the
                            //  total length of selected files. + 2 for the
                            //  space that goes in between files and for the
                            //  possible dot added at the end of the filename
                            //  if the file does not have an extension.
                            //
                            cchTotalLength += (len + 2);

                            if (cchTotalLength > cchMemBlockSize)
                            {
                                LPTSTR pTemp;
                                UINT cchPrevLen = cchTotalLength - (len + 2);

                                cchMemBlockSize = cchMemBlockSize << 1;
                                pTemp = (LPTSTR)LocalReAlloc(
                                                 pch,
                                                 cchMemBlockSize * sizeof(TCHAR),
                                                 LMEM_MOVEABLE );
                                if (pTemp)
                                {
                                    pch = pTemp;
                                    pch2 = pch + cchPrevLen;
                                }
                                else
                                {
                                    LocalFree(pch);
                                    goto LocalFailure2;
                                }

                            }

                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETTEXT,
                                         (WPARAM)(*(pSelIndex + i)),
                                         (LONG_PTR)pch2 );

                            if (!StrChr(pch2, CHAR_DOT))
                            {
                                *(pch2 + len++) = CHAR_DOT;
                            }

                            pch2 += len;
                            *pch2++ = CHAR_SPACE;
                        }
                        if (pch2 != pch)
                        {
                            *--pch2 = CHAR_NULL;
                        }

                        SetDlgItemText(hDlg, edt1, pch);
                        LocalFree((HANDLE)pch);
LocalFailure2:
                        LocalFree((HANDLE)pSelIndex);
                    }
LocalFailure1:
                    if (pOFN->lpfnHook)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETCARETINDEX,
                                               0,
                                               0L );
                        if (!(i & 0x8000))
                        {
                            wFlag = (SendMessage(
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETSEL,
                                         (WPARAM)i,
                                         0L )
                                     ? CD_LBSELADD
                                     : CD_LBSELSUB);
                        }
                        else
                        {
                            wFlag = CD_LBSELNOITEMS;
                        }
                    }
                }
                else
                {
                    //
                    //  Multiselection is not allowed.
                    //  Put the file name in the edit control.
                    //
                    szText[0] = CHAR_NULL;

                    i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                           LB_GETCURSEL,
                                           0,
                                           0L );

                    if (i != (WORD)LB_ERR)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETTEXT,
                                               (WPARAM)i,
                                               (LONG_PTR)szText );

                        if (!StrChr(szText, CHAR_DOT))
                        {
                            if (i < MAX_FULLPATHNAME - 1)
                            {
                                szText[i]     = CHAR_DOT;
                                szText[i + 1] = CHAR_NULL;
                            }
                        }

                        if (!bCasePreserved)
                        {
                            CharLower(szText);
                        }

                        SetDlgItemText(hDlg, edt1, szText);
                        if (pOFN->lpfnHook)
                        {
                            i = (WORD)SendMessage(
                                          GET_WM_COMMAND_HWND(wParam, lParam),
                                          LB_GETCURSEL,
                                          0,
                                          0L );
                            wFlag = CD_LBSELCHANGE;
                        }
                    }
                }

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                    else
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                }

                SendDlgItemMessage(hDlg, edt1, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                return (TRUE);
            }
            break;
        }
        case ( cmb1 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    if (wWinVer >= 0x030A)
                    {
                        pOFN->Flags |= OFN_FILTERDOWN;
                    }
                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(cmb1, lParam, MYCBN_DRAW) );

                    return (TRUE);
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    //
                    //  Need to change the file listing in lst1.
                    //
                    if (pOFN->Flags & OFN_FILTERDOWN)
                    {
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_DRAW ) :
                {
                    SHORT nIndex;
                    LPCTSTR lpFilter;

                    HourGlass(TRUE);

                    pOFN->Flags &= ~OFN_FILTERDOWN;
ChangingFilter:
                    nIndex = (SHORT)SendDlgItemMessage( hDlg,
                                                        cmb1,
                                                        CB_GETCURSEL,
                                                        0,
                                                        0L );
                    if (nIndex < 0)
                    {
                        //
                        //  No current selection.
                        //
                        break;
                    }

                    //
                    //  Must also check if filter contains anything.
                    //
                    if (nIndex ||
                        !(pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
                    {
                        lpFilter = pOFN->lpstrFilter +
                                   SendDlgItemMessage( hDlg,
                                                       cmb1,
                                                       CB_GETITEMDATA,
                                                       (WPARAM)nIndex,
                                                       0L );
                    }
                    else
                    {
                        lpFilter = pOFN->lpstrCustomFilter +
                                   lstrlen(pOFN->lpstrCustomFilter) + 1;
                    }
                    if (*lpFilter)
                    {
                        GetDlgItemText( hDlg,
                                        edt1,
                                        szText,
                                        MAX_FULLPATHNAME - 1 );
                        bRet = (!szText[0] ||
                                (StrChr(szText, CHAR_STAR)) ||
                                (StrChr(szText, CHAR_QMARK)));
                        
                        if (SUCCEEDED(StringCchCopy(szText, ARRAYSIZE(szText), lpFilter)))
                        {
                            if (bRet)
                            {
                                CharLower(szText);
                                SetDlgItemText(hDlg, edt1, szText);
                                SendDlgItemMessage( hDlg,
                                                    edt1,
                                                    EM_SETSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)-1 );
                            }
                            FListAll(pOFI, hDlg, szText, ARRAYSIZE(szText));
                            if (!bInitializing)
                            {
                                EVAL(SUCCEEDED(StringCchCopy(pOFI->szLastFilter, ARRAYSIZE(pOFI->szLastFilter), szText))); // szText is smaller than pOFI->szLastFilter
                                //
                                //  Provide dynamic lpstrDefExt updating
                                //  when lpstrDefExt is user initialized.
                                //
                                if (StrChr((LPTSTR)lpFilter, CHAR_DOT) &&
                                    pOFN->lpstrDefExt)
                                {
                                    DWORD cbLen = MIN_DEFEXT_LEN - 1; // only 1st 3
                                    LPTSTR lpTemp = (LPTSTR)(pOFN->lpstrDefExt);

                                    while (*lpFilter++ != CHAR_DOT);
                                    if (!(StrChr((LPTSTR)lpFilter, CHAR_STAR)) &&
                                        !(StrChr((LPTSTR)lpFilter, CHAR_QMARK)))
                                    {
                                        while (cbLen--)
                                        {
                                            *lpTemp++ = *lpFilter++;
                                        }
                                        *lpTemp = CHAR_NULL;
                                    }
                                }
                            }
                        }
                    }
                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                        else
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                    }
                    HourGlass(FALSE);
                    return (TRUE);

                    break;
                }

                default :
                {
                    break;
                }
            }
            break;
        }
        case ( lst2 ) :
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
            {
                if (!(pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    if ((DWORD)SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L ) != pOFI->idirSub - 1)
                    {
                        StripFileName(hDlg, IS16BITWOWAPP(pOFN));
                        pOFN->Flags |= OFN_DIRSELCHANGED;
                    }
                }
                return (TRUE);
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SETFOCUS)
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                SendMessage( GetDlgItem(hDlg, IDCANCEL),
                             BM_SETSTYLE,
                             (WPARAM)BS_PUSHBUTTON,
                             (LPARAM)TRUE );
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_KILLFOCUS)
            {
                if (pOFN && (pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    pOFN->Flags &= ~OFN_DIRSELCHANGED;
                }
                else
                {
                    bChangeDir = FALSE;
                }
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
            {
                TCHAR szNextDir[CCHNETPATH];
                LPTSTR lpCurDir;
                DWORD idir;
                DWORD idirNew;
                int cb;
                LPTSTR pstrPath = NULL;
ChangingDir:
                bChangeDir = FALSE;
                pOFN->Flags &= ~OFN_DIRSELCHANGED;
                idirNew = (DWORD)SendDlgItemMessage( hDlg,
                                                     lst2,
                                                     LB_GETCURSEL,
                                                     0,
                                                     0L );
                //
                //  Can use relative path name.
                //
                *pOFI->szPath = 0;
                if (idirNew >= pOFI->idirSub)
                {
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   (WPARAM)idirNew,
                                                   (LPARAM)pOFI->szPath );
                    //
                    //  sanity check
                    //
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    if (SUCCEEDED(StringCchCopy(szNextDir, ARRAYSIZE(szNextDir), lpCurDir)) && PathAddBackslash(szNextDir))
                    {

                        //
                        //  Fix phenom with c:\\foobar - because of inconsistency
                        //  in directory display guaranteed to have a valid
                        //  lpCurDir here, right?
                        //
                        if (SUCCEEDED(StringCchCat(szNextDir, ARRAYSIZE(szNextDir), pOFI->szPath)))
                        {
                            pstrPath = szNextDir;
                            idirNew = pOFI->idirSub;    // for msgLBCHANGE message
                        }
                    }
                }
                else
                {
                    //
                    //  Need full path name.
                    //
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   0,
                                                   (LPARAM)pOFI->szPath );

                    //
                    //  The following condition is necessary because wb displays
                    //  \\server\share (the disk resource name) for unc, but
                    //  for root paths (eg. c:\) for device conns, this in-
                    //  consistency is hacked around here and in FillOutPath.
                    //
                    if (DBL_BSLASH(pOFI->szPath) && SUCCEEDED(StringCchCat(pOFI->szPath, ARRAYSIZE(pOFI->szPath), L"\\")))
                    {
                        cb++;
                    }

                    for (idir = 1; idir <= idirNew; ++idir)
                    {
                        cb += (int) SendDlgItemMessage(
                                             hDlg,
                                             lst2,
                                             LB_GETTEXT,
                                             (WPARAM)idir,
                                             (LPARAM)&pOFI->szPath[cb] );

                        pOFI->szPath[cb++] = CHAR_BSLASH;
                    }

                    //
                    //  The root is a special case.
                    //
                    if (idirNew)
                    {
                        pOFI->szPath[cb - 1] = CHAR_NULL;
                    }

                    pstrPath = pOFI->szPath;
                }

                if (!pstrPath || !*pstrPath ||
                    (ChangeDir(hDlg, pstrPath, FALSE, TRUE) == CHANGEDIR_FAILED))
                {
                    break;
                }

                //
                //  List all directories under this one.
                //
                UpdateListBoxes(hDlg, pOFI, NULL, mskDirectory);

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                    else
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                }
                return (TRUE);
            }
            break;
        }
        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    pOFN->Flags |= OFN_DRIVEDOWN;

                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    //
                    //  It would seem reasonable to merely do the update
                    //  at this point, but that would rely on message
                    //  ordering, which isnt a smart move.  In fact, if
                    //  you hit ALT-DOWNARROW, DOWNARROW, ALT-DOWNARROW,
                    //  you receive CBN_DROPDOWN, CBN_SELCHANGE, and then
                    //  CBN_CLOSEUP.  But if you use the mouse to choose
                    //  the same element, the last two messages trade
                    //  places.  PostMessage allows all messages in the
                    //  sequence to be processed, and then updates are
                    //  done as needed.
                    //
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(
                                     cmb2,
                                     GET_WM_COMMAND_HWND(wParam, lParam),
                                     MYCBN_DRAW ) );
                    return (TRUE);
                    break;
                }
                case ( MYCBN_LIST ) :
                {
                    LoadDrives(hDlg);
                    break;
                }
                case ( MYCBN_REPAINT ) :
                {
                    int cchCurDir;
                    LPTSTR lpCurDir;

                    // sanity
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    cchCurDir = GetPathOffset(lpCurDir);
                    if (cchCurDir != -1)
                    {
                        TCHAR szRepaintDir[CCHNETPATH];
                        HWND hCmb2 = (HWND)lParam;

                        if (SUCCEEDED(StringCchCopy(szRepaintDir, ARRAYSIZE(szRepaintDir), lpCurDir)))
                        {
                            szRepaintDir[cchCurDir] = CHAR_NULL;
                            SendMessage(hCmb2, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)szRepaintDir);
                        }
                    }
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    StripFileName(hDlg, IS16BITWOWAPP(pOFN));

                    //
                    //  Version check not needed, since flag never set
                    //  for versions not supporting CBN_CLOSEUP. Putting
                    //  check at CBN_DROPDOWN is more efficient since it
                    //  is less frequent than CBN_SELCHANGE.

                    if (pOFN->Flags & OFN_DRIVEDOWN)
                    {
                        //
                        //  Don't fill lst2 while the combobox is down.
                        //
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_CHANGEDIR ) :
                case ( MYCBN_DRAW ) :
                {
                    TCHAR szTitle[WARNINGMSGLENGTH];
                    LPTSTR lpFilter;
                    int nDiskInd, nInd;
                    DWORD dwType = 0;
                    LPTSTR lpszPath = NULL;
                    LPTSTR lpszDisk = NULL;
                    HWND hCmb2;
                    OFN_DISKINFO *pofndiDisk = NULL;
                    static TCHAR szDrawDir[CCHNETPATH];
                    int nRet;

                    HourGlass(TRUE);

                    //
                    //  Clear Flag for future CBN_SELCHANGE messeges.
                    //
                    pOFN->Flags &= ~OFN_DRIVEDOWN;

                    //
                    //  Change the drive.
                    //
                    szText[0] = CHAR_NULL;

                    hCmb2 = (HWND)lParam;

                    if (hCmb2 != NULL)
                    {
                        nInd = (int) SendMessage(hCmb2, CB_GETCURSEL, 0, 0L);

                        if (nInd != CB_ERR)
                        {
                            SendMessage( hCmb2,
                                         CB_GETLBTEXT,
                                         nInd,
                                         (LPARAM)szDrawDir );
                        }

                        if ((nInd == CB_ERR) || ((INT_PTR)pofndiDisk == CB_ERR))
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir && (lstrlen(lpCurDlg->lpstrCurDir) < ARRAYSIZE(szDrawDir)))
                                {
                                    // Don't touch szDrawDir unless there we are assured successful copy
                                    StringCchCopy(szDrawDir, ARRAYSIZE(szDrawDir), lpCurDlg->lpstrCurDir);
                                }
                            }
                        }

                        CharLower(szDrawDir);

                        //
                        //  Should always succeed.
                        //
                        nDiskInd = DiskAddedPreviously(0, szDrawDir);
                        if (nDiskInd != 0xFFFFFFFF)
                        {
                            pofndiDisk = &gaDiskInfo[nDiskInd];
                        }
                        else
                        {
                            //
                            //  Skip update in the case where it fails.
                            //
                            return (TRUE);
                        }

                        dwType = pofndiDisk->dwType;

                        lpszDisk = pofndiDisk->lpPath;
                    }

                    if ((GET_WM_COMMAND_CMD(wParam, lParam)) == MYCBN_CHANGEDIR)
                    {
                        if (lpNetDriveSync)
                        {
                            lpszPath = lpNetDriveSync;
                            lpNetDriveSync = NULL;
                        }
                        else
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir && (lstrlen(lpCurDlg->lpstrCurDir) < ARRAYSIZE(szDrawDir)))
                                {
                                    // Don't touch szDrawDir unless we are assured a successful copy.
                                    StringCchCopy(szDrawDir, ARRAYSIZE(szDrawDir), lpCurDlg->lpstrCurDir);
                                    lpszPath = szDrawDir;
                                }
                            }
                        }
                    }
                    else
                    {
                        lpszPath = lpszDisk;
                    }

                    if (bInitializing)
                    {
                        lpFilter = szTitle;
                        if (pOFN->lpstrFile &&
                            (StrChr(pOFN->lpstrFile, CHAR_STAR) ||
                             StrChr(pOFN->lpstrFile, CHAR_QMARK)))
                        {
                            if (FAILED(StringCchCopy(szTitle, ARRAYSIZE(szTitle), pOFN->lpstrFile)))
                            {
                                goto NullSearch; // Don't use filter string.
                            }
                        }
                        else
                        {
                            HWND hcmb1 = GetDlgItem(hDlg, cmb1);

                            nInd = (int) SendMessage(hcmb1, CB_GETCURSEL, 0, 0L);
                            if (nInd == CB_ERR)
                            {
                                //
                                //  No current selection.
                                //
                                goto NullSearch;
                            }

                            //
                            //  Must also check if filter contains anything.
                            //
                            if (nInd ||
                                !(pOFN->lpstrCustomFilter &&
                                  *pOFN->lpstrCustomFilter))
                            {
                                lpFilter = (LPTSTR)(pOFN->lpstrFilter);
                                lpFilter += SendMessage( hcmb1,
                                                         CB_GETITEMDATA,
                                                         (WPARAM)nInd,
                                                         0 );
                            }
                            else
                            {
                                lpFilter = pOFN->lpstrCustomFilter;
                                lpFilter += lstrlen(pOFN->lpstrCustomFilter) + 1;
                            }
                        }
                    }
                    else
                    {
NullSearch:
                        lpFilter = NULL;
                    }

                    //
                    //  UpdateListBoxes cuts up filter string in place.
                    //
                    if (lpFilter)
                    {
                        // It's possible these overlap, since we have done a lpFilter = szTitle
                        if (SUCCEEDED(StringCchCopyOverlap(szTitle, ARRAYSIZE(szTitle), lpFilter)))
                        {
                            CharLower(szTitle);
                        }
                        else
                        {
                            lpFilter = NULL; // Don't use filter string.
                        }
                    }

                    if (dwType == REMDRVBMP)
                    {
                        DWORD err = WNetRestoreConnection(hDlg, lpszDisk);

                        if (err != WN_SUCCESS)
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }

                        pofndiDisk->dwType = NETDRVBMP;

                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                   hCmb2,
                                   CB_SELECTSTRING,
                                   (WPARAM)-1,
                                   (LPARAM)(LPTSTR)pofndiDisk->lpAbbrName ),
                            (LPARAM)NETDRVBMP );
                    }

                    //
                    //  Calls to ChangeDir will call SelDisk, so no need
                    //  to update cmb2 on our own here (used to be after
                    //  updatelistboxes).
                    //
                    if ((nRet = ChangeDir( hDlg,
                                           lpszPath,
                                           FALSE,
                                           FALSE )) == CHANGEDIR_FAILED)
                    {
                        int mbRet;

                        while (nRet == CHANGEDIR_FAILED)
                        {
                            if (dwType == FLOPPYBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_DRIVE,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION));
                            }
                            else if (dwType == CDDRVBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_CDROM,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION) );
                            }
                            else
                            {
                                //
                                //  See if it's a RAW volume.
                                //
                                if (dwType == HARDDRVBMP &&
                                    GetLastError() == ERROR_UNRECOGNIZED_VOLUME)
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_UNRECOGNIZED_VOLUME,
                                                   (UINT)(MB_OK |
                                                          MB_ICONEXCLAMATION) );
                                }
                                else
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_DIR_ACCESS_DENIED,
                                                   (UINT)(MB_RETRYCANCEL |
                                                          MB_ICONEXCLAMATION) );
                                }
                            }

                            if (bFirstTime || (mbRet != IDRETRY))
                            {
                                lpszPath = NULL;
                                nRet = ChangeDir(hDlg, lpszPath, TRUE, FALSE);
                            }
                            else
                            {
                                nRet = ChangeDir(hDlg, lpszPath, FALSE, FALSE);
                            }
                        }
                    }

                    UpdateListBoxes( hDlg,
                                     pOFI,
                                     lpFilter ? szTitle : lpFilter,
                                     (WORD)(mskDrives | mskDirectory) );

                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                        nInd = (int) SendDlgItemMessage( hDlg,
                                                         cmb2,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0 );
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                        else
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                    }

                    HourGlass(FALSE);

                    return (TRUE);

                    break;
                }
                default :
                {
                    break;
                }
            }
            break;
        }
        case ( pshHelp ) :
        {
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                if (msgHELPA && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPA,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            else
            {
                if (msgHELPW && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPW,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            break;
        }
        case ( psh14 ) :
        {
            bGetNetDrivesSync = TRUE;
            if (CallNetDlg(hDlg))
            {
                LNDSetEvent(hDlg);
            }
            else
            {
                bGetNetDrivesSync = FALSE;
            }
            break;
        }
        default :
        {
            break;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateListBoxes
//
//  Fills out File and Directory List Boxes in a single pass
//  given (potentially) multiple filters
//
//  It assumes the string of extensions are delimited by semicolons.
//
//  hDlg        Handle to File Open/Save dialog
//  pOFI        pointer to OPENFILEINFO structure
//  lpszFilter  pointer to filter, if NULL, use pOFI->szSpecCur
//  wMask       mskDirectory and/or mskDrives, or NULL
//
//  Returns:  TRUE   if match
//            FALSE  if not
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateListBoxes(
    HWND hDlg,
    POPENFILEINFO pOFI,
    LPTSTR lpszFilter,
    WORD wMask)
{
    LPTSTR lpszF[MAXFILTERS + 1];
    LPTSTR lpszTemp;
    SHORT i, nFilters;
    HWND hFileList = GetDlgItem(hDlg, lst1);
    HWND hDirList = GetDlgItem(hDlg, lst2);
    BOOL bRet = FALSE;
    TCHAR szSpec[MAX_FULLPATHNAME];
    BOOL bDriveChange;
    BOOL bFindAll = FALSE;
    RECT rDirLBox;
    BOOL bLFN;
    HANDLE hff;
    DWORD dwErr;
    WIN32_FIND_DATA FindFileData;
    TCHAR szBuffer[MAX_FULLPATHNAME];       // add one for CHAR_DOT
    WORD wCount;
    LPCURDLG lpCurDlg;


    //
    //  Save the drive bit and then clear it out.
    //
    bDriveChange = wMask & mskDrives;
    wMask &= ~mskDrives;

    if (!lpszFilter)
    {
        lpszFilter = szSpec;
        GetDlgItemText( hDlg,
                        edt1,
                        szSpec,
                        ARRAYSIZE(szSpec) - 1);

        //
        //  If any directory or drive characters are in there, or if there
        //  are no wildcards, use the default spec.
        //
        if ( StrChr(szSpec, CHAR_BSLASH) ||
             StrChr(szSpec, CHAR_SLASH)  ||
             StrChr(szSpec, CHAR_COLON)  ||
             (!((StrChr(szSpec, CHAR_STAR)) ||
                (StrChr(szSpec, CHAR_QMARK)))) )
        {
            EVAL(SUCCEEDED(StringCchCopy(szSpec, ARRAYSIZE(szSpec), pOFI->szSpecCur)));
        }
        else
        {
            // szSpec comes from the editbox, which is limited to MAX_PATH chars, so this should always succeed.
            EVAL(SUCCEEDED(StringCchCopy(pOFI->szLastFilter, ARRAYSIZE(pOFI->szLastFilter), szSpec)));
        }
    }

    //
    //  We need to find out what kind of a drive we are running
    //  on in order to determine if spaces are valid in a filename
    //  or not.
    //
    bLFN = IsLFNDriveX(hDlg, TEXT("\0"));

    //
    //  Find the first filter in the string, and add it to the
    //  array.
    //
    if (bLFN)
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonTab);
    }
    else
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonSpaceTab);
    }

    //
    //  Now we are going to loop through all the filters in the string
    //  parsing the one we already have, and then finding the next one
    //  and starting the loop over again.
    //
    while (lpszF[nFilters] && (nFilters < MAXFILTERS))
    {
        //
        //  Check to see if the first character is a space.
        //  If so, remove the spaces, and save the pointer
        //  back into the same spot.  Why?  because the
        //  FindFirstFile/Next api will _still_ work on
        //  filenames that begin with a space because
        //  they also look at the short names.  The
        //  short names will begin with the same first
        //  real letter as the long filename.  For
        //  example, the long filename is "  my document"
        //  the first letter of this short name is "m",
        //  so searching on "m*.*" or " m*.*" will yield
        //  the same results.
        //
        if (bLFN && (*lpszF[nFilters] == CHAR_SPACE))
        {
            lpszTemp = lpszF[nFilters];
            while ((*lpszTemp == CHAR_SPACE) && *lpszTemp)
            {
                lpszTemp = CharNext(lpszTemp);
            }

            lpszF[nFilters] = lpszTemp;
        }

        //
        //  The original code used to do a CharUpper here to put the
        //  filter strings in upper case.  EG:  *.TXT  However, this
        //  is not a good thing to do for Turkish.  Capital 'i' does
        //  not equal 'I', so the CharUpper is being removed.
        //
        //  CharUpper(lpszF[nFilters]);

        //
        //  Compare the filter with *.*.  If we find *.* then
        //  set the boolean bFindAll, and this will cause the
        //  files listbox to be filled in at the same time the
        //  directories listbox is filled.  This saves time
        //  from walking the directory twice (once for the directory
        //  names and once for the filenames).
        //
        if (!lstrcmpi(lpszF[nFilters], szStarDotStar))
        {
            bFindAll = TRUE;
        }

        //
        //  Now we need to check if this filter is a duplicate
        //  of an already existing filter.
        //
        for (wCount = 0; wCount < nFilters; wCount++)
        {
            //
            //  If we find a duplicate, decrement the current
            //  index pointer by one so that the last location
            //  is written over (thus removing the duplicate),
            //  and break out of this loop.
            //
            if (!lstrcmpi(lpszF[nFilters], lpszF[wCount]))
            {
                nFilters--;
                break;
            }
        }

        //
        //  Ready to move on to the next filter.  Find the next
        //  filter based upon the type of file system we're using.
        //
        if (bLFN)
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonTab);
        }
        else
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
        }

        //
        //  In case we found a pointer to NULL, then look for the
        //  next filter.
        //
        while (lpszF[nFilters] && !*lpszF[nFilters])
        {
            if (bLFN)
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonTab);
            }
            else
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
            }
        }
    }

    //
    //  Add NULL terminator only if needed.
    //
    if (nFilters >= MAXFILTERS)
    {
        lpszF[MAXFILTERS] = 0;
    }

    HourGlass(TRUE);

    SendMessage(hFileList, WM_SETREDRAW, FALSE, 0L);
    SendMessage(hFileList, LB_RESETCONTENT, 0, 0L);
    if (wMask & mskDirectory)
    {
        wNoRedraw |= 2;     // HACK!!! WM_SETREDRAW isn't complete
        SendMessage(hDirList, WM_SETREDRAW, FALSE, 0L);

        //
        //  LB_RESETCONTENT causes InvalidateRect(hDirList, 0, TRUE) to be
        //  sent as well as repositioning the scrollbar thumb and drawing
        //  it immediately.  This causes flicker when the LB_SETCURSEL is
        //  made, as it clears out the listbox by erasing the background of
        //  each item.
        //
        SendMessage(hDirList, LB_RESETCONTENT, 0, 0L);
    }

    //
    //  Always open enumeration for *.*
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
    hff = FindFirstFile(szStarDotStar, &FindFileData);

    if ( hff == INVALID_HANDLE_VALUE)
    {
        //
        //  Error.  Call GetLastError to determine what happened.
        //
        dwErr = GetLastError();

        //
        //  With the ChangeDir logic handling AccessDenied for cds,
        //  if we are not allowed to enum files, that's ok, just get out.
        //
        if (dwErr == ERROR_ACCESS_DENIED)
        {
            wMask = mskDirectory;
            goto Func4EFailure;
        }

        //
        //  For bad path of bad filename.
        //
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            wMask = mskDrives;
            goto Func4EFailure;
        }
    }

    //
    //  A listing was made, even if empty.
    //
    bRet = TRUE;
    wMask &= mskDirectory;

    //
    //  GetLastError says no more files.
    //
    if (hff == INVALID_HANDLE_VALUE  && dwErr == ERROR_FILE_NOT_FOUND)
    {
        //
        //  Things went well, but there are no files.
        //
        goto NoMoreFilesFound;
    }

    do
    {
        if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
        {
            UNICODE_STRING Name;
            BOOLEAN fSpace = FALSE;

            if (NT_SUCCESS(RtlInitUnicodeStringEx(&Name, FindFileData.cFileName)) && RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
            {
                //
                //  Legal 8.3 name and no spaces, so use the principal
                //  file name.
                //
                EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cFileName)));
            }
            else
            {
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                //
                //  Use the alternate file name.
                //
                EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cAlternateFileName)));
            }
        }
        else
        {
            EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cFileName)));
        }

        if ((FindFileData.dwFileAttributes & EXCLBITS))
        {
            continue;
        }

        if ((pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT))
        {
            if (StrChr(szBuffer, CHAR_SPACE))
            {
                //
                //  HPFS does not support alternate filenames
                //  for multiselect, bump all spacey filenames.
                //
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cAlternateFileName)));
            }
        }

        if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (wMask & mskDirectory)
            {
                //
                //  Don't include the subdirectories "." and "..".
                //
                if (szBuffer[0] == CHAR_DOT)
                {
                    if ((szBuffer[1] == CHAR_NULL) ||
                        ((szBuffer[1] == CHAR_DOT) && (szBuffer[2] == CHAR_NULL)))
                    {
                        continue;
                    }
                }
                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }
                i = (WORD)SendMessage( hDirList,
                                       LB_ADDSTRING,
                                       0,
                                       (DWORD_PTR)szBuffer );
            }
        }
        else if (bFindAll)
        {
            if (!bCasePreserved)
            {
                CharLower(szBuffer);
            }

            SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
        }
    } while (FindNextFile(hff, &FindFileData));

    if (hff == INVALID_HANDLE_VALUE)
    {
        goto Func4EFailure;
    }

    FindClose(hff);

    if (!bFindAll)
    {
        for (i = 0; lpszF[i]; i++)
        {
            if (!lstrcmpi(lpszF[i], szStarDotStar))
            {
                continue;
            }

            //
            //  Find First for each filter.
            //
            hff = FindFirstFile(lpszF[i], &FindFileData);

            if (hff == INVALID_HANDLE_VALUE)
            {
                DWORD dwErr = GetLastError();

                if ((dwErr == ERROR_FILE_NOT_FOUND) ||
                    (dwErr == ERROR_INVALID_NAME))
                {
                    //
                    //  Things went well, but there are no files.
                    //
                    continue;
                }
                else
                {
                    wMask = mskDrives;
                    goto Func4EFailure;
                }
            }

            do
            {
                if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
                {
                    UNICODE_STRING Name;
                    BOOLEAN fSpace = FALSE;

                    if (NT_SUCCESS(RtlInitUnicodeStringEx(&Name, FindFileData.cFileName)) && RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
                    {
                        //
                        //  Legal 8.3 name and no spaces, so use the principal
                        //  file name.
                        //
                        EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cFileName)));
                    }
                    else
                    {
                        if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                        {
                            continue;
                        }

                        //
                        //  Use the alternate file name.
                        //
                        EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cAlternateFileName)));
                    }
                }
                else
                {
                    EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cFileName)));

                    if (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT)
                    {
                        if (StrChr(szBuffer, CHAR_SPACE))
                        {
                            //
                            //  HPFS does not support alternate filenames
                            //  for multiselect, bump all spacey filenames.
                            //
                            if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                            {
                                continue;
                            }

                            EVAL(SUCCEEDED(StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), FindFileData.cAlternateFileName)));
                        }
                    }
                }

                if ((FindFileData.dwFileAttributes & EXCLBITS) ||
                    (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    continue;
                }

                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }

                SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
            } while (FindNextFile(hff, &FindFileData));

            if (hff != INVALID_HANDLE_VALUE)
            {
                FindClose(hff);
            }
        }
    }

NoMoreFilesFound:

Func4EFailure:
    if (wMask)
    {
        if (wMask == mskDirectory)
        {
            LPTSTR lpCurDir = NULL;

            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
            {
                lpCurDir = lpCurDlg->lpstrCurDir;
            }

            FillOutPath(hDirList, pOFI);

            //
            //  The win31 way of chopping the text by just passing
            //  it on to user doesn't work for unc names since user
            //  doesn't see the drivelessness of them (thinks drive is
            //  a bslash char).  So, special case it here.
            //
            EVAL(SUCCEEDED(StringCchCopy(pOFI->szPath, ARRAYSIZE(pOFI->szPath), lpCurDir)));

            if (DBL_BSLASH(pOFI->szPath))
            {
                SetDlgItemText(hDlg, stc1, ChopText(hDlg, stc1, pOFI->szPath));
            }
            else
            {
                DlgDirList(hDlg, pOFI->szPath, 0, stc1, DDL_READONLY);
            }

            SendMessage(hDirList, LB_SETCURSEL, pOFI->idirSub - 1, 0L);

            if (bDriveChange)
            {
                //
                //  The design here is to show the selected drive whenever the
                //  user changes drives, or whenever the number of
                //  subdirectories is sufficiently low to allow them to be
                //  shown along with the drive.  Otherwise, show the
                //  immediate parent and all the children that can be shown.
                //  This all was done to meet the UITF spec.
                //
                i = 0;
            }
            else
            {
                //
                //  Show as many children as possible.
                //
                if ((i = (SHORT)(pOFI->idirSub - 2)) < 0)
                {
                    i = 0;
                }
            }

            //
            //  LB_SETTOPINDEX must be after LB_SETCURSEL, as LB_SETCURSEL will
            //  alter the top index to bring the current selection into view.
            //
            SendMessage(hDirList, LB_SETTOPINDEX, (WPARAM)i, 0L);
        }
        else
        {
            SetDlgItemText(hDlg, stc1, szNull);
        }

        wNoRedraw &= ~2;
        SendMessage(hDirList, WM_SETREDRAW, TRUE, 0L);

        GetWindowRect(hDirList, (LPRECT)&rDirLBox);
        rDirLBox.left++, rDirLBox.top++;
        rDirLBox.right--, rDirLBox.bottom--;
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rDirLBox, 2);

        //
        //  If there are less than enough directories to fill the listbox,
        //  Win 3.0 doesn't clear out the bottom.  Pass TRUE as the last
        //  parameter to demand a WM_ERASEBACKGROUND message.
        //
        InvalidateRect(hDlg, (LPRECT)&rDirLBox, (BOOL)(wWinVer < 0x030A));
    }

    SendMessage(hFileList, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hFileList, (LPRECT)0, (BOOL)TRUE);

#ifndef WIN32
   ResetDTAAddress();
#endif

   HourGlass(FALSE);
   return (bRet);
}


// Stores <cch> in pOFN->lpstrFile
void StoreFileSizeInOFN(LPOPENFILENAME pOFN, UINT cch)
{
    ASSERT(cch >= pOFN->nMaxFile);

    if (pOFN->nMaxFile > 0)
        pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
    if (pOFN->nMaxFile > 1)
        pOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
    if (pOFN->nMaxFile > 2)
        pOFN->lpstrFile[2] = CHAR_NULL;
}

// Copies pszPath into pOFN->lpstrFile if room, stores lstrlen(pszPath) otherwise
void StorePathOrFileSizeInOFN(LPOPENFILENAME pOFN, LPTSTR pszPath)
{
    if (pOFN->lpstrFile)
    {
        UINT cch = lstrlen(pszPath);
        if (cch < pOFN->nMaxFile)
        {
            StringCchCopy(pOFN->lpstrFile, pOFN->nMaxFile, pszPath); // Can never fail.
        }
        else
        {
            StoreFileSizeInOFN(pOFN, cch+1);
        }
    }
}

//
//  Fix bug where progman cannot OK a file being browsed for new
//  item because it has Execute only permission.
//  Returns FALSE if handle passed in was invalid, but not because of ERROR_ACCESS_DENIED
//  Otherwise returns TRUE.
//
HANDLE ProgManBugCreateFile(HANDLE hFile, LPCTSTR szPathName, DWORD *dwErrCode)
{
    if (hFile == INVALID_HANDLE_VALUE)
    {
        *dwErrCode = GetLastError();

        if (*dwErrCode == ERROR_ACCESS_DENIED)
        {
            hFile = CreateFile( szPathName,
                                GENERIC_EXECUTE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
            if (hFile == INVALID_HANDLE_VALUE)
            {
                *dwErrCode = GetLastError();
            }
        }
    }
    return hFile;
}




#define SP_NOERR 0
#define SP_INVALIDDRIVE 1
#define SP_PATHNOTFOUND 2


////////////////////////////////////////////////////////////////////////////
//
//  OKButtonPressed
//
//  Note:  There are 4 cases for validation of a file name:
//    1)  OFN_NOVALIDATE        allows invalid characters
//    2)  No validation flags   No invalid characters, but path need not exist
//    3)  OFN_PATHMUSTEXIST     No invalid characters, path must exist
//    4)  OFN_FILEMUSTEXIST     No invalid characters, path & file must exist
//
////////////////////////////////////////////////////////////////////////////

BOOL OKButtonPressed(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode = 0;
    DWORD cch;
    DWORD cchSearchPath;
    LPOPENFILENAME pOFN = pOFI->pOFN;
    int nFileOffset, nExtOffset;
    HANDLE hFile;
    BOOL bAddExt = FALSE;
    BOOL bUNCName = FALSE;
    int nTempOffset;
    TCHAR szPathName[MAX_FULLPATHNAME];
    DWORD lRet;
    BOOL blfn;
    LPCURDLG lpCurDlg;
    TCHAR ch = 0;


    cch = GetUNCDirectoryFromLB(hDlg, lst2, pOFI);  // Is it a tree headed by a UNC share?
    if (cch)
    {
        // If so, cch now points to the end of the entire name, and we might have
        //  pOFI->szPath be something like \\foo\bar\bar\bar
        nTempOffset = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                       lst2,
                                                       LB_GETTEXTLEN,
                                                       0,
                                                       0 );
        // While nTempOffset points to the end of just the UNC part (so to \bar\bar)
    }
    else
    {
        nTempOffset = 0; // and of course cch == 0
    }

    GetDlgItemText(hDlg, edt1, pOFI->szPath + cch, ARRAYSIZE(pOFI->szPath) - 1 - cch);

    if (cch)
    {
        //
        //  If a drive or new UNC was specified, forget the old UNC.
        //
        if ((pOFI->szPath[cch + 1] == CHAR_COLON) ||
            (DBL_BSLASH(pOFI->szPath + cch)) )
        {
            StringCopyOverlap(pOFI->szPath, pOFI->szPath + cch);
        }
        else if ((ISBACKSLASH(pOFI->szPath, cch)) ||
                 (pOFI->szPath[cch] == CHAR_SLASH))
        {
            //
            //  If a directory from the root is given, put it immediately
            //  after the \\server\share listing.
            //
            //  For example, if the directory is \\foo\bar\bar\ba, the user typed \x in the editbox,
            //   give us \\foo\bar\x
            EVAL(SUCCEEDED(StringCchCopy(pOFI->szPath + nTempOffset, ARRAYSIZE(pOFI->szPath) - nTempOffset, pOFI->szPath + cch)));
        }
    }

    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        blfn = FALSE;
    }
    else
    {
        blfn = IsLFNDriveX(hDlg, pOFI->szPath);
    }

    lRet = ParseFile(pOFI->szPath, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    nExtOffset  = (int)(SHORT)HIWORD(lRet);

    if (nFileOffset == PARSE_EMPTYSTRING)
    {
        UpdateListBoxes(hDlg, pOFI, NULL, 0);
        return (FALSE);
    }
    else if ((nFileOffset != PARSE_DIRECTORYNAME) &&
             (pOFN->Flags & OFN_NOVALIDATE))
    {
        pOFN->nFileOffset = (WORD)(nFileOffset >= 0 ? nFileOffset : lstrlen(pOFI->szPath)); // point at NULL in error case
        pOFN->nFileExtension = (WORD)nExtOffset;
        StorePathOrFileSizeInOFN(pOFN, pOFI->szPath);
        return (TRUE);
    }
    else if ((pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             SpacesExist(pOFI->szPath))
    {
        return (MultiSelectOKButton(hDlg, pOFI, bSave));
    }
    else if (pOFI->szPath[nExtOffset] == CHAR_SEMICOLON)
    {
        pOFI->szPath[nExtOffset] = CHAR_NULL;
        nFileOffset = (int)(SHORT)LOWORD(ParseFile( pOFI->szPath,
                                                    blfn,
                                                    IS16BITWOWAPP(pOFN),
                                                    FALSE ));
        pOFI->szPath[nExtOffset] = CHAR_SEMICOLON;
        if ( (nFileOffset >= 0) &&
             (StrChr(pOFI->szPath + nFileOffset, CHAR_STAR) ||
              StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK)) )
        {
            EVAL(SUCCEEDED(StringCchCopy(pOFI->szLastFilter, ARRAYSIZE(pOFI->szLastFilter), pOFI->szPath + nFileOffset)));
            if (FListAll(pOFI, hDlg, pOFI->szPath, ARRAYSIZE(pOFI->szPath)) == CHANGEDIR_FAILED)
            {
                //
                //  Conform with cchSearchPath error code settings in
                //  PathCheck.
                //
                cchSearchPath = SP_PATHNOTFOUND;
                goto PathCheck;
            }
            return (FALSE);
        }
        else
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto Warning;
        }
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        //
        //  End with slash?
        //
        if ((ISBACKSLASH(pOFI->szPath, nExtOffset - 1)) ||
            (pOFI->szPath[nExtOffset - 1] == CHAR_SLASH))
        {
            //
            //  ... and is not the root, get rid of the slash.
            //
            if ( (nExtOffset != 1) &&
                 (pOFI->szPath[nExtOffset - 2] != CHAR_COLON) &&
                 (nExtOffset != nTempOffset + 1) )
            {
                pOFI->szPath[nExtOffset - 1] = CHAR_NULL;
            }
        }
        else if ((pOFI->szPath[nExtOffset - 1] == CHAR_DOT) &&
                 ((pOFI->szPath[nExtOffset - 2] == CHAR_DOT) ||
                  (ISBACKSLASH(pOFI->szPath, nExtOffset - 2)) ||
                  (pOFI->szPath[nExtOffset - 2] == CHAR_SLASH)) &&
                 ((DBL_BSLASH(pOFI->szPath)) ||
                  ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                   (DBL_BSLASH(pOFI->szPath + 2)))))
        {
            pOFI->szPath[nExtOffset] = CHAR_BSLASH;
            pOFI->szPath[nExtOffset + 1] = CHAR_NULL;
        }

        //
        //  Fall through to Directory Checking.
        //
    }
    else if (nFileOffset < 0)
    {
        //
        //  Put in nErrCode so that call can be used from other points.
        //
        nErrCode = (DWORD)nFileOffset;
Warning:

        //
        //  If the disk is not a floppy and they tell me there's no
        //  disk in the drive, dont believe it.  Instead, put up the error
        //  message that they should have given us.
        //  (Note that the error message is checked first since checking
        //  the drive type is slower.)
        //
        if (nErrCode == ERROR_ACCESS_DENIED)
        {
            if (bUNCName)
            {
                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
            }
            else
            {
                szPathName[0] = CharLowerChar(szPathName[0]);

                if (GetDiskType(szPathName) == DRIVE_REMOTE)
                {
                    nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                }
                else if (GetDiskType(szPathName) == DRIVE_REMOVABLE)
                {
                    nErrCode = ERROR_NO_DISK_IN_DRIVE;
                }
                else if (GetDiskType(szPathName) == DRIVE_CDROM)
                {
                    nErrCode = ERROR_NO_DISK_IN_CDROM;
                }
            }
        }

        if ((nErrCode == ERROR_WRITE_PROTECT) ||
            (nErrCode == ERROR_CANNOT_MAKE) ||
            (nErrCode == ERROR_NO_DISK_IN_DRIVE) ||
            (nErrCode == ERROR_NO_DISK_IN_CDROM))
        {
            pOFI->szPath[0] = szPathName[0];
        }

        InvalidFileWarning(hDlg, pOFI->szPath, nErrCode, 0);

        //
        //  Can't cd case (don't want WM_ACTIVATE to setevent to GetNetDrives!).
        //  Reset wNoRedraw.
        //
        wNoRedraw &= ~1;
        return (FALSE);
    }

    bUNCName = ((DBL_BSLASH(pOFI->szPath)) ||
                ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                (DBL_BSLASH(pOFI->szPath + 2))));

    ASSERT((nFileOffset >= 0 ) || (nFileOffset == PARSE_DIRECTORYNAME)); // PARSE_DIRECTORYNAME is the only error case handled below...

    nTempOffset = nFileOffset;

    //
    //  Get the fully-qualified path.
    //
    {
        BOOL bSlash;
        BOOL bRet;
        WORD nNullOffset;

        // Chop of the file part of the path in pOFI->szPath for the time being, to ensure we're dealing with a directory.
        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            ch = *(pOFI->szPath + nFileOffset);
            *(pOFI->szPath + nFileOffset) = CHAR_NULL;
            nNullOffset = (WORD) nFileOffset;
        }

        //
        //  For files of the format c:filename where c is not the
        //  current directory, SearchPath does not return the curdir of c
        //  so, prefetch it - should searchpath be changed?
        //
        if (nFileOffset > 0)
        {
            if (*(pOFI->szPath + nFileOffset - 1) == CHAR_COLON)
            {
                //
                //  If it fails, fall through to the error generated below.
                //
                if (ChangeDir(hDlg, pOFI->szPath, FALSE, FALSE) != CHANGEDIR_FAILED)
                {
                    //
                    //  Replace old null offset.
                    //
                    *(pOFI->szPath + nFileOffset) = ch;
                    ch = *pOFI->szPath;

                    //
                    //  Don't pass drive-colon into search path.
                    //
                    *pOFI->szPath = CHAR_NULL;
                    nNullOffset = 0;
                }
            }
        }

        bSlash = (*pOFI->szPath == CHAR_SLASH);
        if (bSlash)
        {
            *pOFI->szPath = CHAR_BSLASH;
        }

        szPathName[0] = CHAR_NULL;

        HourGlass(TRUE);

        //
        //  REARCHITECT:
        //  Each wow thread can change the current directory.
        //  Since searchpath doesn't check current dirs on a per thread basis,
        //  reset it here and hope that we don't get interrupted between
        //  setting and searching...
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

        if (pOFI->szPath[0] == TEXT('\0'))  // space for name (pretend it's valid for now)
        {
            EVAL(SUCCEEDED(StringCchCopyEx(szPathName, ARRAYSIZE(szPathName), (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL), NULL, NULL, STRSAFE_IGNORE_NULLS)));
            bRet = 1;
        }
        else
        {
            bRet = GetFullPathName( pOFI->szPath,
                                    ARRAYSIZE(szPathName),
                                    szPathName,
                                    NULL );
        }

        // Now szPathName contains the current directory (if pOFI->szPath was empty), or pOFI->szPath (fully qualified path?)

        // Except in the failure case, where bRet == FALSE... like say for example we entered a bad drive:
        if (!bRet && (pOFI->szPath[1] == CHAR_COLON))
        {
            int nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);

            //
            //  If it's a remembered connection, try to reconnect it.
            //
            if (nDriveIndex != 0xFFFFFFFF  &&
                gaDiskInfo[nDriveIndex].dwType == REMDRVBMP)
            {
                DWORD err = WNetRestoreConnection( hDlg,
                                                   gaDiskInfo[nDriveIndex].lpPath );

                if (err == WN_SUCCESS)
                {
                    gaDiskInfo[nDriveIndex].dwType = NETDRVBMP;
                    nDriveIndex = (int) SendDlgItemMessage(
                           hDlg,
                           cmb2,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM)(LPTSTR)gaDiskInfo[nDriveIndex].lpPath );
                    SendDlgItemMessage( hDlg,
                                        cmb2,
                                        CB_SETITEMDATA,
                                        (WPARAM)nDriveIndex,
                                        (LPARAM)NETDRVBMP );
                    bRet = GetFullPathName( pOFI->szPath,
                                            MAX_FULLPATHNAME,
                                            szPathName,
                                            NULL);
                }
            }
        }
        HourGlass(FALSE);

        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            *(pOFI->szPath + nNullOffset) = ch;
        }

        if (bSlash)
        {
            *pOFI->szPath = CHAR_SLASH;
        }

        if (bRet) // We got something.
        {
            cchSearchPath = SP_NOERR;

            if (nFileOffset != PARSE_DIRECTORYNAME)
            {
                // Add file name to path
                // (Can't use PathCombine, because it only fits MAX_PATH)
                if (!ISBACKSLASH(szPathName, lstrlen(szPathName) - 1))
                {
                    EVAL(SUCCEEDED(StringCchCat(szPathName, ARRAYSIZE(szPathName), L"\\"))); // Shouldn't be longer than MAX_FULLPATH
                }

                EVAL(SUCCEEDED(StringCchCat(szPathName, ARRAYSIZE(szPathName), (pOFI->szPath + nFileOffset)))); // Shouldn't be longer than MAX_FULLPATH
            }
            else // we were given a directory name, try to go to that directory.
            {
                //
                //  Hack to get around SearchPath inconsistencies.
                //
                //  searching for c: returns c:
                //  searching for server share dir1 .. returns  server share
                //  in these two cases bypass the regular ChangeDir call that
                //  uses szPathName and use the original pOFI->szPath instead
                //  OKButtonPressed needs to be simplified!
                //
                int cch = GetPathOffset(pOFI->szPath);

                // cch now points to the last \ in "c:\" or the "\\foo\bar\"

                if (cch > 0)
                {
                    if (bUNCName)
                    {
                        //
                        //  If this fails, how is szPathName used?
                        //  szPathName's disk should equal pOFI->szPath's
                        //  so the cch will be valid.
                        //
                        szPathName[cch] = CHAR_BSLASH;
                        szPathName[cch + 1] = CHAR_NULL; // Removing the file part of the path.
                        if (ChangeDir( hDlg,
                                       pOFI->szPath,
                                       FALSE,
                                       TRUE ) != CHANGEDIR_FAILED)
                        {
                            goto ChangedDir;
                        }
                    }
                    else
                    {
                        // It's a drive letter.  We only changedir if there is nothing after the drive letter.
                        if (!pOFI->szPath[cch])
                        {
                            if (ChangeDir( hDlg,
                                           pOFI->szPath,
                                           FALSE,
                                           TRUE) != CHANGEDIR_FAILED)
                            {
                                goto ChangedDir;
                            }
                        }
                    }
                }
            }
        }
        else // (!bRet)
        {
            // Some kind of invalid path... perhaps a search pattern?
            if (!(pOFN->Flags & OFN_PATHMUSTEXIST))
            {
                EVAL(SUCCEEDED(StringCchCopy(szPathName, ARRAYSIZE(szPathName), pOFI->szPath))); // Must fit in MAX_FULLPATH
            }
            nErrCode = GetLastError();
            if ((nErrCode == ERROR_INVALID_DRIVE) ||
                (pOFI->szPath[1] == CHAR_COLON))
            {
                cchSearchPath = SP_INVALIDDRIVE;
            }
            else
            {
                cchSearchPath = SP_PATHNOTFOUND;
            }
        }
    }

    //
    //  Full pattern?
    //
    if ( !cchSearchPath && (nFileOffset >= 0) &&
         ((StrChr(pOFI->szPath + nFileOffset, CHAR_STAR)) ||
          (StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK))) )
    {
        // Search pattern....
        TCHAR szSameDirFile[MAX_FULLPATHNAME];

        if (nTempOffset > 0)
        {
            //
            //  Must restore character in case it is part of the filename,
            //  e.g. nTempOffset is 1 for "\foo.txt".
            //
            ch = pOFI->szPath[nTempOffset];
            pOFI->szPath[nTempOffset] = 0;
            ChangeDir(hDlg, pOFI->szPath, FALSE, TRUE);
            pOFI->szPath[nTempOffset] = ch;
        }

        // If there is a file extension, or if there wasn't, and we succeeded in putting a dot where the filename is (?), then
        if (nExtOffset || SUCCEEDED(StringCchCat(pOFI->szPath + nFileOffset, ARRAYSIZE(pOFI->szPath) - nFileOffset, L".")))
        {
            if (SUCCEEDED(StringCchCopy(pOFI->szLastFilter, ARRAYSIZE(pOFI->szLastFilter), pOFI->szPath + nFileOffset)))
            {
                if (SUCCEEDED(StringCchCopy(szSameDirFile, ARRAYSIZE(szSameDirFile), pOFI->szPath + nFileOffset)))
                {
                    // Redo list, based on new file spec:
                    if (FListAll(pOFI, hDlg, szSameDirFile, ARRAYSIZE(szSameDirFile)) < 0)
                    {
                        MessageBeep(0);
                    }
                }
            }
        }

        return (FALSE);
    }

    //
    //  We either have a file pattern or a real file.
    //  If its a directory
    //       (1) Add on default pattern
    //       (2) Act like its a pattern (goto pattern (1))
    //  Else if its a pattern
    //       (1) Update everything
    //       (2) display files in whatever dir were now in
    //  Else if its a file name!
    //       (1) Check out the syntax
    //       (2) End the dialog given OK
    //       (3) Beep/message otherwise
    //

    //
    //  Drive-letter:\dirpath ??
    //
    if (!cchSearchPath)
    {
        DWORD dwFileAttr = GetFileAttributes(szPathName);

        if (dwFileAttr != 0xFFFFFFFF)
        {
            if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                {
ChangedDir:
                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, FALSE, 0L);
                    if (*pOFI->szLastFilter)
                    {
                        SetDlgItemText(hDlg, edt1, pOFI->szLastFilter);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, edt1, szStarDotStar);
                    }

                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb1,
                                                     GetDlgItem(hDlg, cmb1),
                                                     CBN_CLOSEUP ) );
                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb2,
                                                     GetDlgItem(hDlg, cmb2),
                                                     MYCBN_CHANGEDIR ) );

                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(GetDlgItem(hDlg, edt1), NULL, FALSE);
                }
                return (FALSE);
            }
        }
    }

    //
    //  Was there a path and did it fail?
    //
    if (nFileOffset && cchSearchPath && (pOFN->Flags & OFN_PATHMUSTEXIST))
    {
PathCheck:
        if (cchSearchPath == SP_PATHNOTFOUND)
        {
            nErrCode = ERROR_PATH_NOT_FOUND;
        }
        else if (cchSearchPath == SP_INVALIDDRIVE)
        {
            int nDriveIndex;

            //
            //  Lowercase drive letters since DiskAddedPreviously is case
            //  sensitive.
            //
            CharLower(pOFI->szPath);

            //  We can get here without performing an OpenFile call.  As such
            //  the szPathName can be filled with random garbage.  Since we
            //  only need one character for the error message, set
            //  szPathName[0] to the drive letter.
            //
            if (pOFI->szPath[1] == CHAR_COLON)
            {
                nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);
            }
            else
            {
                nDriveIndex = DiskAddedPreviously(0, pOFI->szPath);
            }

            if (nDriveIndex == 0xFFFFFFFF)
            {
                nErrCode = ERROR_NO_DRIVE;
            }
            else
            {
                if (bUNCName)
                {
                    nErrCode = ERROR_NO_DRIVE;
                }
                else
                {
                    switch (GetDiskType(pOFI->szPath))
                    {
                        case ( DRIVE_REMOVABLE ) :
                        {
                            szPathName[0] = pOFI->szPath[0];
                            nErrCode = ERROR_NO_DISK_IN_DRIVE;
                            break;
                        }
                        case ( DRIVE_CDROM ) :
                        {
                           szPathName[0] = pOFI->szPath[0];
                           nErrCode = ERROR_NO_DISK_IN_CDROM;
                           break;
                        }
                        default :
                        {
                           nErrCode = ERROR_PATH_NOT_FOUND;
                        }
                    }
                }
            }
        }
        else
        {
            // We can never get here, because cchSearchPath must equal 0, SP_PATHNOTFOUND or SP_INVALIDDRIVE.
            ASSERT(FALSE);
            nErrCode = ERROR_FILE_NOT_FOUND;
        }

        //
        //  If we don't set wNoRedraw here, then WM_ACTIVATE will set the
        //  GetNetDrives event.
        //
        wNoRedraw |= 1;

        goto Warning;
    }

    if ((nFileOffset != PARSE_DIRECTORYNAME) && PortName(pOFI->szPath + nFileOffset))
    {
        nErrCode = ERROR_PORTNAME;
        goto Warning;
    }


    //
    //  Add the default extension unless filename ends with period or no
    //  default extension exists.  If the file exists, consider asking
    //  permission to overwrite the file.
    //
    //  NOTE:  When no extension given, default extension is tried 1st.
    //
    if ( (nFileOffset != PARSE_DIRECTORYNAME) &&
         nExtOffset &&
         !pOFI->szPath[nExtOffset] &&
         pOFN->lpstrDefExt &&
         *pOFN->lpstrDefExt &&
         (((DWORD)nExtOffset + lstrlen(pOFN->lpstrDefExt)) < pOFN->nMaxFile) )
    {
        DWORD dwFileAttr;
        int nExtOffset2 = lstrlen(szPathName);

        if (AppendExt(pOFI->szPath, ARRAYSIZE(pOFI->szPath), pOFN->lpstrDefExt, FALSE) &&
            AppendExt(szPathName, ARRAYSIZE(szPathName), pOFN->lpstrDefExt, FALSE))
        {
            bAddExt = TRUE;

            //
            //  Directory may match default extension.  Change to it as if it had
            //  been typed in.  A dir w/o the extension would have been switched
            //  to in the logic above.
            //
            if ((dwFileAttr = GetFileAttributes(pOFI->szPath)) != 0xFFFFFFFF)
            {
                if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                    {
                        goto ChangedDir;
                    }
                }
            }

            hFile = CreateFile( szPathName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

            hFile = ProgManBugCreateFile(hFile, szPathName, &nErrCode);

            if (nErrCode == ERROR_SHARING_VIOLATION)
            {
                goto SharingViolationInquiry;
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(hFile))
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }

    AskPermission:
                //
                //  Is the file read-only?
                //
                if (pOFN->Flags & OFN_NOREADONLYRETURN)
                {
                    int nRet;
                    if ((nRet = GetFileAttributes(szPathName)) != -1)
                    {
                        if (nRet & ATTR_READONLY)
                        {
                            nErrCode = ERROR_LAZY_READONLY;
                            goto Warning;
                        }
                    }
                    else
                    {
                        nErrCode = GetLastError();
                        goto Warning;
                    }
                }

                if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                    (nErrCode == ERROR_ACCESS_DENIED))
                {
                    goto Warning;
                }

                if (pOFN->Flags & OFN_OVERWRITEPROMPT)
                {
                    if (bSave && !FOkToWriteOver(hDlg, szPathName))
                    {
                        PostMessage( hDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hDlg, edt1),
                                     (LPARAM)1L );
                        return (FALSE);
                    }
                }

                if (nErrCode == ERROR_SHARING_VIOLATION)
                {
                    goto SharingViolationInquiry;
                }
                goto FileNameAccepted;
            }
            else
            {
                // Remove the file extension.
                *(pOFI->szPath + nExtOffset) = CHAR_NULL;
                szPathName[nExtOffset2] = CHAR_NULL;
            }
        }
    }
    // else bAddExt is still FALSE

    hFile = CreateFile( szPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    hFile = ProgManBugCreateFile(hFile, szPathName, &nErrCode);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            nErrCode = GetLastError();
            goto Warning;
        }
        goto AskPermission;
    }
    else
    {
        if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
            (nErrCode == ERROR_PATH_NOT_FOUND))
        {
            //
            //  Figure out if the default extension should be tacked on.
            //
            // (Note: there is only one way in here where bAddExt is TRUE, and in that
            //  case we know for certain that AppendExt will succeed)
            if (bAddExt)
            {
                EVAL(AppendExt(pOFI->szPath, ARRAYSIZE(pOFI->szPath), pOFN->lpstrDefExt, FALSE));
                EVAL(AppendExt(szPathName, ARRAYSIZE(szPathName), pOFN->lpstrDefExt, FALSE));
            }
        }
        else if (nErrCode == ERROR_SHARING_VIOLATION)
        {

SharingViolationInquiry:
            //
            //  If the app is "share aware", fall through.
            //  Otherwise, ask the hook function.
            //
            if (!(pOFN->Flags & OFN_SHAREAWARE))
            {
                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        CHAR szPathNameA[MAX_FULLPATHNAME];

                        RtlUnicodeToMultiByteSize(
                              &cch,
                              szPathName,
                              lstrlenW(szPathName) * sizeof(TCHAR) );

                        SHUnicodeToAnsi(szPathName,(LPSTR)&szPathNameA[0],cch + 1);

                        cch = (DWORD)(*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONA,
                                           0,
                                           (LONG_PTR)(LPSTR)szPathNameA );
                    }
                    else
                    {
                        cch = (DWORD)(*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONW,
                                           0,
                                           (LONG_PTR)szPathName );
                    }
                    if (cch == OFN_SHARENOWARN)
                    {
                        return (FALSE);
                    }
                    else if (cch != OFN_SHAREFALLTHROUGH)
                    {
                        goto Warning;
                    }
                }
                else
                {
                    goto Warning;
                }
            }
            goto FileNameAccepted;
        }

        if (!bSave)
        {
            if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
                (nErrCode == ERROR_PATH_NOT_FOUND))
            {
                if (pOFN->Flags & OFN_FILEMUSTEXIST)
                {
                    if (pOFN->Flags & OFN_CREATEPROMPT)
                    {
                        //
                        //  Don't alter pOFI->szPath.
                        //
                        bInChildDlg = TRUE;
                        cch = (DWORD)CreateFileDlg(hDlg, pOFI->szPath);
                        bInChildDlg = FALSE;
                        if (cch == IDYES)
                        {
                            goto TestCreation;
                        }
                        else
                        {
                            return (FALSE);
                        }
                    }
                    goto Warning;
                }
            }
            else
            {
                goto Warning;
            }
        }

        //
        //  The file doesn't exist.  Can it be created?  This is needed because
        //  there are many extended characters which are invalid that won't be
        //  caught by ParseFile.
        //  Two more good reasons:  Write-protected disks & full disks.
        //
        //  BUT, if they dont want the test creation, they can request that we
        //  not do it using the OFN_NOTESTFILECREATE flag.  If they want to
        //  create files on a share that has create-but-no-modify privileges,
        //  they should set this flag but be ready for failures that couldn't
        //  be caught, such as no create privileges, invalid extended
        //  characters, a full disk, etc.
        //

TestCreation:
        if ((pOFN->Flags & OFN_PATHMUSTEXIST) &&
            (!(pOFN->Flags & OFN_NOTESTFILECREATE)))
        {
            //
            //  Must use the FILE_FLAG_DELETE_ON_CLOSE flag so that the
            //  file is automatically deleted when the handle is closed
            //  (no need to call DeleteFile).  This is necessary in the
            //  event that the directory only has Add & Read access.
            //  The CreateFile call will succeed, but the DeleteFile call
            //  will fail.  By adding the above flag to the CreateFile
            //  call, it overrides the access rights and deletes the file
            //  during the call to CloseHandle.
            //
            hFile = CreateFile( szPathName,
                                FILE_ADD_FILE,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );

            if (hFile == INVALID_HANDLE_VALUE)
            {
                nErrCode = GetLastError();
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(hFile))
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }
            }
            else
            {
                //
                //  Unable to create it.
                //
                //  If it's not write-protection, a full disk,
                //  network protection, or the user popping the drive door
                //  open, assume that the filename is invalid.
                //
                if ( (nErrCode != ERROR_WRITE_PROTECT) &&
                     (nErrCode != ERROR_CANNOT_MAKE) &&
                     (nErrCode != ERROR_NETWORK_ACCESS_DENIED) &&
                     (nErrCode != ERROR_ACCESS_DENIED) )
                {
                    nErrCode = 0;
                }
                goto Warning;
            }
        }
    }

FileNameAccepted:

    HourGlass(TRUE);

    lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    cch = (DWORD)HIWORD(lRet);

    ASSERT(nFileOffset >= 0); // if the filename was accepted, we better parse it without error...

    pOFN->nFileOffset = (WORD)nFileOffset;
    if (nExtOffset || bAddExt)
    {
        pOFN->nFileExtension = LOWORD(cch);
    }
    else
    {
        pOFN->nFileExtension = 0;
    }

    pOFN->Flags &= ~OFN_EXTENSIONDIFFERENT;
    if (pOFN->lpstrDefExt && pOFN->nFileExtension)
    {
        TCHAR szPrivateExt[4];
        SHORT i;

        for (i = 0; i < 3; i++)
        {
            szPrivateExt[i] = *(pOFN->lpstrDefExt + i);
        }
        szPrivateExt[3] = CHAR_NULL;

        if (lstrcmpi(szPrivateExt, szPathName + cch))
        {
            pOFN->Flags |= OFN_EXTENSIONDIFFERENT;
        }
    }

    //
    //  If we're called from wow, and the user hasn't changed
    //  directories, shorten the path to abbreviated 8.3 format.
    //
    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(szPathName);

        //
        //  If the path was shortened, the offset might have changed so
        //  we must parse the file again.
        //
        lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        cch  = (DWORD)HIWORD(lRet);

        ASSERT(nFileOffset >= 0); // shortening the path better not introduce a parse error...

        //
        //  When in Save dialog, the file may not exist yet, so the file
        //  name cannot be shortened.  So, we need to test if it's an
        //  8.3 filename and popup an error message if not.
        //
        if (bSave)
        {
            LPTSTR lptmp;
            LPTSTR lpExt = NULL;

            for (lptmp = szPathName + nFileOffset; *lptmp; lptmp++)
            {
                if (*lptmp == CHAR_DOT)
                {
                    if (lpExt)
                    {
                        //
                        //  There's more than one dot in the file, so it is
                        //  invalid.
                        //
                        nErrCode = FNERR_INVALIDFILENAME;
                        goto Warning;
                    }
                    lpExt = lptmp;
                }
                if (*lptmp == CHAR_SPACE)
                {
                    nErrCode = FNERR_INVALIDFILENAME;
                    goto Warning;
                }
            }

            if (lpExt)
            {
                //
                //  There's an extension.
                //
                *lpExt = 0;
            }

            if ((lstrlen(szPathName + nFileOffset) > 8) ||
                (lpExt && lstrlen(lpExt + 1) > 3))
            {
                if (lpExt)
                {
                    *lpExt = CHAR_DOT;
                }

                nErrCode = FNERR_INVALIDFILENAME;
                goto Warning;
            }
            if (lpExt)
            {
                *lpExt = CHAR_DOT;
            }
        }
    }

    StorePathOrFileSizeInOFN(pOFN, szPathName);

    //
    //  File Title.  Note that it's cut off at whatever the buffer length
    //               is, so if the buffer is too small, *no notice is given*.
    //
    if (pOFN->lpstrFileTitle && pOFN->nMaxFileTitle)
    {
        cch = lstrlen(szPathName + nFileOffset);
        if (cch > pOFN->nMaxFileTitle)
        {
            szPathName[nFileOffset + pOFN->nMaxFileTitle - 1] = CHAR_NULL;
        }
        EVAL(SUCCEEDED(StringCchCopy(pOFN->lpstrFileTitle, pOFN->nMaxFileTitle, szPathName + nFileOffset)));
    }


    if (!(pOFN->Flags & OFN_HIDEREADONLY))
    {
        if (IsDlgButtonChecked(hDlg, chx1))
        {
            pOFN->Flags |= OFN_READONLY;
        }
        else
        {
            pOFN->Flags &= ~OFN_READONLY;
        }
    }

    return (TRUE);
}

WCHAR c_szSpace[] = L" ";

////////////////////////////////////////////////////////////////////////////
//
//  MultiSelectOKButton
//
////////////////////////////////////////////////////////////////////////////

BOOL MultiSelectOKButton(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode;
    LPTSTR lpCurDir;
    LPTSTR lpchStart;                  // start of an individual filename
    LPTSTR lpchEnd;                    // end of an individual filename
    DWORD cch;
    HANDLE hFile;
    LPOPENFILENAME pOFN;
    BOOL EOS = FALSE;                  // end of string flag
    BOOL bRet;
    TCHAR szPathName[MAX_FULLPATHNAME - 1];
    LPCURDLG lpCurDlg;


    pOFN = pOFI->pOFN;

    //
    //  Check for space for first full path element.
    //
    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    EVAL(SUCCEEDED(StringCchCopy(pOFI->szPath, ARRAYSIZE(pOFI->szPath), lpCurDir)));

    if (StrChr(pOFI->szPath, CHAR_SPACE))
    {
        GetShortPathName(pOFI->szPath, pOFI->szPath, ARRAYSIZE(pOFI->szPath));
    }

    if (!bCasePreserved)
    {
        CharLower(pOFI->szPath);
    }

    cch = (DWORD)(lstrlen(pOFI->szPath) + ARRAYSIZE(c_szSpace) + SendDlgItemMessage(hDlg, edt1, WM_GETTEXTLENGTH, 0, 0L));
    if (pOFN->lpstrFile)
    {
        if (cch > pOFN->nMaxFile)
        {
            // Not enough room.
            StoreFileSizeInOFN(pOFN, cch);
        }
        else // pOFN->nMaxFile >= cch
        {
            //
            //  Copy in the full path as the first element.
            //
            StringCchCopy(pOFN->lpstrFile, pOFN->nMaxFile, pOFI->szPath); // We know these both succeed.
            StringCchCat(pOFN->lpstrFile, pOFN->nMaxFile, c_szSpace);

            //
            //  Get the other files here.
            //
            cch = lstrlen(pOFN->lpstrFile); // cch is now the length of the path plus a space.

            //
            //  The path is guaranteed to be less than 64K (actually, < 260).
            //
            pOFN->nFileOffset = LOWORD(cch);
            lpchStart = pOFN->lpstrFile + cch;

            // This shouldn't get truncated, assuming the text in the edit box is still the same length as above.
            GetDlgItemText(hDlg, edt1, lpchStart, (pOFN->nMaxFile - cch - 1));

            while (*lpchStart == CHAR_SPACE)
            {
                lpchStart = CharNext(lpchStart);
            }
            if (*lpchStart == CHAR_NULL)
            {
                return (FALSE);
            }

            //
            //  Go along file path looking for multiple filenames delimited by
            //  spaces.  For each filename found, try to open it to make sure
            //  it's a valid file.
            //
            while (!EOS)
            {
                //
                //  Find the end of the filename.
                //
                lpchEnd = lpchStart;
                while (*lpchEnd && *lpchEnd != CHAR_SPACE)
                {
                    lpchEnd = CharNext(lpchEnd);
                }

                //
                //  Mark the end of the filename with a NULL.
                //
                if (*lpchEnd == CHAR_SPACE)
                {
                    *lpchEnd = CHAR_NULL;
                }
                else
                {
                    //
                    //  Already NULL, found the end of the string.
                    //
                    EOS = TRUE;
                }

                //
                //  Check that the filename is valid.
                //
                bRet = GetFullPathName(lpchStart, ARRAYSIZE(szPathName), szPathName, NULL);

                if (!bRet)
                {
                    nErrCode = ERROR_FILE_NOT_FOUND;
                    goto MultiFileNotFound;
                }

                hFile = CreateFile(szPathName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

                hFile = ProgManBugCreateFile(hFile, szPathName, &nErrCode);

                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
MultiFileNotFound:
                    if ( ((pOFN->Flags & OFN_FILEMUSTEXIST) ||
                          (nErrCode != ERROR_FILE_NOT_FOUND)) &&
                         ((pOFN->Flags & OFN_PATHMUSTEXIST) ||
                          (nErrCode != ERROR_PATH_NOT_FOUND)) &&
                         (!(pOFN->Flags & OFN_SHAREAWARE) ||
                          (nErrCode != ERROR_SHARING_VIOLATION)) )
                    {
                        if ( (nErrCode == ERROR_SHARING_VIOLATION) &&
                             pOFN->lpfnHook )
                        {
                            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                            if (pOFI->ApiType == COMDLG_ANSI)
                            {
                                CHAR szPathNameA[MAX_FULLPATHNAME];

                                RtlUnicodeToMultiByteSize(
                                     &cch,
                                     szPathName,
                                     lstrlenW(szPathName) * sizeof(TCHAR) );

                                SHUnicodeToAnsi(szPathName,(LPSTR)&szPathNameA[0],cch + 1);

                                cch = (DWORD)(*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONA,
                                                   0,
                                                   (LONG_PTR)(LPSTR)szPathNameA );
                            }
                            else
                            {
                                cch = (DWORD)(*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONW,
                                                   0,
                                                   (LONG_PTR)szPathName );
                            }
                            if (cch == OFN_SHARENOWARN)
                            {
                                return (FALSE);
                            }
                            else if (cch == OFN_SHAREFALLTHROUGH)
                            {
                                goto EscapedThroughShare;
                            }
                        }
                        else if (nErrCode == ERROR_ACCESS_DENIED)
                        {
                            szPathName[0] = CharLowerChar(szPathName[0]);

                            if (GetDiskType(szPathName) != DRIVE_REMOVABLE)
                            {
                                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                            }
                        }
                        if ((nErrCode == ERROR_WRITE_PROTECT) ||
                            (nErrCode == ERROR_CANNOT_MAKE)   ||
                            (nErrCode == ERROR_ACCESS_DENIED))
                        {
                            *lpchStart = szPathName[0];
                        }
MultiWarning:
                        InvalidFileWarning(hDlg, lpchStart, nErrCode, 0);
                        return (FALSE);
                    }
                }
EscapedThroughShare:
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    if (!CloseHandle(hFile))
                    {
                        nErrCode = GetLastError();
                        goto MultiWarning;
                    }
                    if ((pOFN->Flags & OFN_NOREADONLYRETURN) &&
                        (GetFileAttributes(szPathName) & FILE_ATTRIBUTE_READONLY))
                    {
                        nErrCode = ERROR_LAZY_READONLY;
                        goto MultiWarning;
                    }

                    if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                        (nErrCode == ERROR_ACCESS_DENIED))
                    {
                        goto MultiWarning;
                    }

                    if (pOFN->Flags & OFN_OVERWRITEPROMPT)
                    {
                        if (bSave && !FOkToWriteOver(hDlg, szPathName))
                        {
                            PostMessage( hDlg,
                                         WM_NEXTDLGCTL,
                                         (WPARAM)GetDlgItem(hDlg, edt1),
                                         (LPARAM)1L );
                            return (FALSE);
                        }
                    }
                }

                //
                //  This file is valid, so check the next one.
                //
                if (!EOS)
                {
                    lpchStart = lpchEnd + 1;
                    while (*lpchStart == CHAR_SPACE)
                    {
                        lpchStart = CharNext(lpchStart);
                    }
                    if (*lpchStart == CHAR_NULL)
                    {
                        EOS = TRUE;
                    }
                    else
                    {
                        //
                        //  Not at end, replace NULL with SPACE.
                        //
                        *lpchEnd = CHAR_SPACE;
                    }
                }
            }

            //
            //  Limit String.
            //
            *lpchEnd = CHAR_NULL;
        }
    }

    //
    //  This doesn't really mean anything for multiselection.
    //
    pOFN->nFileExtension = 0;

    pOFN->nFilterIndex = (int) SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  dwOKSubclass
//
//  Simulates a double click if the user presses OK with the mouse
//  and the focus was on the directory listbox.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By setting the global flag bChangeDir
//  when the directory listbox loses the focus and clearing it when
//  the OK button loses the focus, we can check whether a mouse
//  click should update the directory.
//
//  Returns:  Return value from default listbox procedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwOKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        if (bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg = GetParent(hOK), FILEPROP))
            {
                SendDlgItemMessage( hDlg,
                                    lst2,
                                    LB_SETCURSEL,
                                    (WPARAM)(pOFI->idirSub - 1),
                                    0L );
            }
            bChangeDir = FALSE;
        }
    }
    return (CallWindowProc(lpOKProc, hOK, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  dwLBSubclass
//
//  Simulates a double click if the user presses OK with the mouse.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By simulating a double click, the change
//  takes place.
//
//  Returns:  Return value from default listbox proceedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwLBSubclass(
    HWND hLB,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        hDlg = GetParent(hLB);
        bChangeDir = (GetDlgItem(hDlg, IDOK) == (HWND)wParam) ? TRUE : FALSE;
        if (!bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
            {
                SendMessage( hLB,
                             LB_SETCURSEL,
                             (WPARAM)(pOFI->idirSub - 1),
                             0L );
            }
        }
    }
    return (CallWindowProc(lpLBProc, hLB, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  InvalidFileWarning
//
////////////////////////////////////////////////////////////////////////////

int InvalidFileWarning(
    HWND hDlg,
    LPTSTR szFile,
    DWORD wErrCode,
    UINT mbType)
{
    SHORT isz;
    BOOL bDriveLetter = FALSE;
    int nRet = 0;

    if (lstrlen(szFile) > TOOLONGLIMIT)
    {
        *(szFile + TOOLONGLIMIT) = CHAR_NULL;
    }

    switch (wErrCode)
    {
        case ( ERROR_NO_DISK_IN_DRIVE ) :
        {
            isz = iszNoDiskInDrive;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DISK_IN_CDROM ) :
        {
            isz = iszNoDiskInCDRom;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DRIVE ) :
        {
            isz = iszDriveDoesNotExist;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_TOO_MANY_OPEN_FILES ) :
        {
            isz = iszNoFileHandles;
            break;
        }
        case ( ERROR_PATH_NOT_FOUND ) :
        {
            isz = iszPathNotFound;
            break;
        }
        case ( ERROR_FILE_NOT_FOUND ) :
        {
            isz = iszFileNotFound;
            break;
        }
        case ( ERROR_CANNOT_MAKE ) :
        case ( ERROR_DISK_FULL ) :
        {
            isz = iszDiskFull;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_WRITE_PROTECT ) :
        {
            isz = iszWriteProtection;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_SHARING_VIOLATION ) :
        {
            isz = iszSharingViolation;
            break;
        }
        case ( ERROR_CREATE_NO_MODIFY ) :
        {
            isz = iszCreateNoModify;
            break;
        }
        case ( ERROR_NETWORK_ACCESS_DENIED ) :
        {
            isz = iszNetworkAccessDenied;
            break;
        }
        case ( ERROR_PORTNAME ) :
        {
            isz = iszPortName;
            break;
        }
        case ( ERROR_LAZY_READONLY ) :
        {
            isz = iszReadOnly;
            break;
        }
        case ( ERROR_DIR_ACCESS_DENIED ) :
        {
            isz = iszDirAccessDenied;
            break;
        }
        case ( ERROR_FILE_ACCESS_DENIED ) :
        case ( ERROR_ACCESS_DENIED ) :
        {
            isz = iszFileAccessDenied;
            break;
        }
        case ( ERROR_UNRECOGNIZED_VOLUME ) :
        {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS |
                          FORMAT_MESSAGE_MAX_WIDTH_MASK,
                          NULL,
                          wErrCode,
                          GetUserDefaultLCID(),
                          szWarning,
                          WARNINGMSGLENGTH,
                          NULL);
            goto DisplayError;
        }
        default :
        {
            isz = iszInvalidFileName;
            break;
        }
    }
    if (!CDLoadString( g_hinst,
                     isz,
                     szCaption,
                     WARNINGMSGLENGTH ))
    {
        StringCchPrintf( szWarning, ARRAYSIZE(szWarning),
                  TEXT("Error occurred, but error resource cannot be loaded.") );
    }
    else
    {
        StringCchPrintf( szWarning, ARRAYSIZE(szWarning),
                  szCaption,
                  bDriveLetter ? (LPTSTR)(CHAR)*szFile : szFile );

DisplayError:
        GetWindowText(hDlg, szCaption, WARNINGMSGLENGTH);

        if (!mbType)
        {
            mbType = MB_OK | MB_ICONEXCLAMATION;
        }

        nRet = MessageBox(hDlg, szWarning, szCaption, mbType);
    }

    if (isz == iszInvalidFileName)
    {
        PostMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, edt1),
                     (LPARAM)1L );
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  MeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID MeasureItem(
    HWND hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    if (!dyItem)
    {
        HDC hDC = GetDC(hDlg);
        TEXTMETRIC TM;
        HANDLE hFont;

        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
        dyText = TM.tmHeight;
        dyItem = max(dyDirDrive, dyText);
    }

    if (mis->CtlID == lst1)
    {
        mis->itemHeight = dyText;
    }
    else
    {
        mis->itemHeight = dyItem;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Signum
//
//  Returns the sign of an integer:
//           -1 if integer < 0
//            0 if integer = 0
//            1 if integer > 0
//
//  Note:  Signum *could* be defined as an inline macro, but that causes
//         the C compiler to disable Loop optimization, Global register
//         optimization, and Global optimizations for common subexpressions
//         in any function that the macro would appear.  The cost of a call
//         to the function seemed worth the optimizations.
//
////////////////////////////////////////////////////////////////////////////

int Signum(
    int nTest)
{
    return ((nTest == 0) ? 0 : (nTest > 0) ? 1 : -1);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawItem
//
//  Draws the drive/directory pictures in the respective combo list boxes.
//
//  lst1 is listbox for files
//  lst2 is listbox for directories
//  cmb1 is combobox for filters
//  cmb2 is combobox for drives
//
////////////////////////////////////////////////////////////////////////////

VOID DrawItem(
    POPENFILEINFO pOFI,
    HWND hDlg,
    WPARAM wParam,
    LPDRAWITEMSTRUCT lpdis,
    BOOL bSave)
{
    HDC hdcList;
    RECT rc;
    TCHAR szText[MAX_FULLPATHNAME + 1];
    int dxAcross;
    LONG nHeight;
    LONG rgbBack, rgbText, rgbOldBack, rgbOldText;
    SHORT nShift = 1;             // to shift directories right in lst2
    BOOL bSel;
    int BltItem;
    int nBackMode;

    if ((int)lpdis->itemID < 0)
    {
        DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LPARAM)lpdis);
        return;
    }

    *szText = CHAR_NULL;

    if (lpdis->CtlID != lst1 && lpdis->CtlID != lst2 && lpdis->CtlID != cmb2)
    {
        return;
    }

    if (!pOFI)
    {
        return;
    }

    hdcList = lpdis->hDC;

    if (lpdis->CtlID != cmb2)
    {
        SendDlgItemMessage( hDlg,
                            (int)lpdis->CtlID,
                            LB_GETTEXT ,
                            (WPARAM)lpdis->itemID,
                            (LONG_PTR)szText );

        if (*szText == 0)
        {
            //
            //  If empty listing.
            //
            DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LONG_PTR)lpdis);
            return;
        }

        if (!bCasePreserved)
        {
            CharLower(szText);
        }
    }

    nHeight = (lpdis->CtlID == lst1) ? dyText : dyItem;

    CopyRect((LPRECT)&rc, (LPRECT)&lpdis->rcItem);

    rc.bottom = rc.top + nHeight;

    if (bSave && (lpdis->CtlID == lst1))
    {
        rgbBack = rgbWindowColor;
        rgbText = rgbGrayText;
    }
    else
    {
        //
        //  Careful checking of bSel is needed here.  Since the file
        //  listbox (lst1) can allow multiselect, only ODS_SELECTED needs
        //  to be set.  But for the directory listbox (lst2), ODS_FOCUS
        //  also needs to be set.
        //
        bSel = (lpdis->itemState & (ODS_SELECTED | ODS_FOCUS));
        if ((bSel & ODS_SELECTED) &&
            ((lpdis->CtlID != lst2) || (bSel & ODS_FOCUS)))
        {
            rgbBack = rgbHiliteColor;
            rgbText = rgbHiliteText;
        }
        else
        {
            rgbBack = rgbWindowColor;
            rgbText = rgbWindowText;
        }
    }

    rgbOldBack = SetBkColor(hdcList, rgbBack);
    rgbOldText = SetTextColor(hdcList, rgbText);

    //
    //  Drives -- text is now in UI style, c: VolumeName/Server-Sharename.
    //
    if (lpdis->CtlID == cmb2)
    {
        HANDLE hCmb2 = GetDlgItem(hDlg, cmb2);

        dxAcross = dxDirDrive / BMPHIOFFSET;

        BltItem = (int) SendMessage(hCmb2, CB_GETITEMDATA, lpdis->itemID, 0);

        SendMessage(hCmb2, CB_GETLBTEXT, lpdis->itemID, (LPARAM)szText);

        if (bSel & ODS_SELECTED)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst2)
    {
        //
        //  Directories.
        //
        dxAcross = dxDirDrive / BMPHIOFFSET;

        if (lpdis->itemID > pOFI->idirSub)
        {
            nShift = (SHORT)pOFI->idirSub;
        }
        else
        {
            nShift = (SHORT)lpdis->itemID;
        }

        //
        //  Must be at least 1.
        //
        nShift++;

        BltItem = 1 + Signum(lpdis->itemID + 1 - pOFI->idirSub);
        if (bSel & ODS_FOCUS)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst1)
    {
        //
        //  Prep for TextOut below.
        //
        dxAcross = -dxSpace;
    }

    if (bSave && (lpdis->CtlID == lst1) && !rgbText)
    {
        HBRUSH hBrush = CreateSolidBrush(rgbBack);
        HBRUSH hOldBrush;

        nBackMode = SetBkMode(hdcList, TRANSPARENT);
        hOldBrush = SelectObject( lpdis->hDC,
                                  hBrush
                                      ? hBrush
                                      : GetStockObject(WHITE_BRUSH) );

        FillRect(lpdis->hDC, (LPRECT)(&(lpdis->rcItem)), hBrush);
        SelectObject(lpdis->hDC, hOldBrush);
        if (hBrush)
        {
            DeleteObject(hBrush);
        }

        GrayString( lpdis->hDC,
                    GetStockObject(BLACK_BRUSH),
                    NULL,
                    (LPARAM)szText,
                    0,
                    lpdis->rcItem.left + dxSpace,
                    lpdis->rcItem.top,
                    0,
                    0 );
        SetBkMode(hdcList, nBackMode);
    }
    else
    {
        //
        //  Draw the name.
        //
        ExtTextOut( hdcList,
                    rc.left + (WORD)(dxSpace + dxAcross) + dxSpace * nShift,
                    rc.top + (nHeight - dyText) / 2,
                    ETO_OPAQUE | ETO_CLIPPED,
                    (LPRECT)&rc,
                    szText,
                    lstrlen(szText),
                    NULL );
    }

    //
    //  Draw the picture.
    //
    if (lpdis->CtlID != lst1)
    {
        BitBlt( hdcList,
                rc.left + dxSpace * nShift,
                rc.top + (dyItem - dyDirDrive) / 2,
                dxAcross,
                dyDirDrive,
                hdcMemory,
                BltItem * dxAcross,
                0,
                SRCCOPY );
    }

    SetTextColor(hdcList, rgbOldText);
    SetBkColor(hdcList, rgbBack);

    if (lpdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(hdcList, (LPRECT)&lpdis->rcItem);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SpacesExist
//
////////////////////////////////////////////////////////////////////////////

BOOL SpacesExist(
    LPTSTR szFileName)
{
    while (*szFileName)
    {
        if (*szFileName == CHAR_SPACE)
        {
            return (TRUE);
        }
        else
        {
            szFileName++;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  StripFileName
//
//  Removes all but the filename from editbox contents.
//  This is to be called before the user makes directory or drive
//  changes by selecting them instead of typing them.
//
////////////////////////////////////////////////////////////////////////////

void StripFileName(
    HANDLE hDlg,
    BOOL bWowApp)
{
    TCHAR szText[MAX_FULLPATHNAME];
    SHORT nFileOffset, cb;

    if (GetDlgItemText(hDlg, edt1, szText, MAX_FULLPATHNAME - 1))
    {
        DWORD lRet;

        lRet = ParseFile(szText, IsLFNDriveX(hDlg, szText), bWowApp, FALSE);
        nFileOffset = (SHORT)LOWORD(lRet);
        cb = HIWORD(lRet);
        if (nFileOffset < 0)
        {
            //
            //  If there was a parsing error, check for CHAR_SEMICOLON
            //  delimeter.
            //
            if (szText[cb] == CHAR_SEMICOLON)
            {
                szText[cb] = CHAR_NULL;
                lRet = ParseFile( szText,
                                  IsLFNDriveX(hDlg, szText),
                                  bWowApp,
                                  FALSE );
                nFileOffset = (SHORT)LOWORD(lRet);
                szText[cb] = CHAR_SEMICOLON;
                if (nFileOffset < 0)
                {
                    //
                    //  Still trouble, so Exit.
                    //
                    szText[0] = CHAR_NULL;
                }
            }
            else
            {
                szText[0] = CHAR_NULL;
            }
        }
        if (nFileOffset > 0)
        {
            StringCopyOverlap(szText, szText + nFileOffset);
        }
        if (nFileOffset)
        {
            SetDlgItemText(hDlg, edt1, szText);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  lstrtok
//
////////////////////////////////////////////////////////////////////////////

LPTSTR lstrtok(
    LPTSTR lpStr,
    LPCTSTR lpDelim)
{
    static LPTSTR lpString;
    LPTSTR lpRetVal, lpTemp;

    //
    //  If we are passed new string skip leading delimiters.
    //
    if (lpStr)
    {
        lpString = lpStr;

        while (*lpString && StrChr(lpDelim, *lpString))
        {
            lpString = CharNext(lpString);
        }
    }

    //
    //  If there are no more tokens, return NULL.
    //
    if (!*lpString)
    {
        return (CHAR_NULL);
    }

    //
    //  Save head of token.
    //
    lpRetVal = lpString;

    //
    //  Find delimiter or end of string.
    //
    while (*lpString && !StrChr(lpDelim, *lpString))
    {
        lpString = CharNext(lpString);
    }

    //
    //  If we found a delimiter insert string terminator and skip.
    //
    if (*lpString)
    {
        lpTemp = CharNext(lpString);
        *lpString = CHAR_NULL;
        lpString = lpTemp;
    }

    //
    //  Return token.
    //
    return (lpRetVal);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChopText
//
////////////////////////////////////////////////////////////////////////////

LPTSTR ChopText(
    HWND hwndDlg,
    int idStatic,
    LPTSTR lpch)
{
    RECT rc;
    register int cxField;
    BOOL fChop = FALSE;
    HWND hwndStatic;
    HDC hdc;
    TCHAR chDrv;
    HANDLE hOldFont;
    LPTSTR lpstrStart = lpch;
    SIZE Size;
    BOOL bRet;

    //
    //  Get length of static field.
    //
    hwndStatic = GetDlgItem(hwndDlg, idStatic);
    GetClientRect(hwndStatic, (LPRECT)&rc);
    cxField = rc.right - rc.left;

    //
    //  Chop characters off front end of text until short enough.
    //
    hdc = GetDC(hwndStatic);

    hOldFont = NULL;

    while ((bRet = GetTextExtentPoint(hdc, lpch, lstrlen(lpch), &Size)) &&
           (cxField < Size.cx))
    {
        if (!fChop)
        {
            chDrv = *lpch;

            //
            //  Proportional font support.
            //
            if (bRet = GetTextExtentPoint(hdc, lpch, 7, &Size))
            {
                cxField -= Size.cx;
            }
            else
            {
                break;
            }

            if (cxField <= 0)
            {
               break;
            }

            lpch += 7;
        }
        while (*lpch && (!ISBACKSLASH_P(lpstrStart, lpch)))
        {
            lpch++;
        }
        //Skip the backslash 
        lpch++;

        fChop = TRUE;
    }

    ReleaseDC(hwndStatic, hdc);

    //
    //  If any characters chopped off, replace first three characters in
    //  remaining text string with ellipsis.
    //
    if (fChop)
    {
        //Skip back to include the backslash
        lpch--;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = *(lpstrStart + 2);
        *--lpch = *(lpstrStart + 1);
        *--lpch = *lpstrStart;
    }

    return (lpch);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillOutPath
//
//  Fills out lst2 given that the current directory has been set.
//
//  Returns:  TRUE    if they DO NOT match
//            FALSE   if match
//
////////////////////////////////////////////////////////////////////////////

BOOL FillOutPath(
    HWND hList,
    POPENFILEINFO pOFI)
{
    TCHAR szPath[CCHNETPATH];
    LPTSTR lpCurDir;
    LPTSTR lpB, lpF;
    TCHAR wc;
    int cchPathOffset;
    LPCURDLG lpCurDlg;

    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    EVAL(SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), lpCurDir)));
    lpF = szPath;    

    //
    //  Wow apps started from lfn dirs will set the current directory to an
    //  lfn, but only in the case where it is less than 8 chars.
    //
    if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(lpF);
    }

    *lpF = (TCHAR)CharLower((LPTSTR)*lpF);
    cchPathOffset = GetPathOffset(lpF);
    if (cchPathOffset == -1)
    {
        cchPathOffset = 0;
    }
    lpB = (lpF + cchPathOffset); // lpB now points to c:[here]\bar  or \\foo\bar[here]\foo

    //
    //  Hack to retain Winball display functionality.
    //  Drived disks are displayed as C:\ (the root dir).
    //  whereas unc disks are displayed as \\server\share (the disk).
    //  Hence, extend display of drived disks by one char.
    //
    if (*(lpF + 1) == CHAR_COLON)
    {
        ++lpB;
        wc = *(lpB);      // For "c:\foo", wc = 'f', and lpF is now  "c:\"
        *lpB = CHAR_NULL;
    }
    else
    {
        //
        //  Since we use lpF over and over again to speed things
        //  up, and since GetCurrentDirectory returns the disk name
        //  for unc, but the root path for drives, we have the following hack
        //  for when we are at the root of the unc directory, and lpF
        //  contains old stuff out past cchPathOffset.
        //

        EVAL(PathAddBackslash(lpF)); // Make sure there is a backslash... 

        wc = 0;
        *lpB = CHAR_NULL;
        lpB++; // For "\\foo\bar\hoo"  lpF is now "\\foo\bar"  (no final backslash), lpB is "hoo"
    }

    //
    //  Insert the items for the path to the current dir
    //  Insert the root...
    //
    pOFI->idirSub = 0;

    SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF); // Inserting the root ("c:\" or "\\foo\bar")

    if (wc)
    {
        *lpB = wc; // Replace any missing character - so for "c:\foo", lpB is now "foo".  For "\\foo\bar\hoo", lpB is now still 0 (followed by "hoo")
    }

    // For "\\foo\bar\hoo", lpB is now "hoo"
    // For "c:\foo", lpB is now "foo"
    for (lpF = lpB; *lpB; lpB++)
    {
        if ((ISBACKSLASH_P(szPath, lpB)) || (*lpB == CHAR_SLASH))
        {
            *lpB = CHAR_NULL;

            SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);

            lpF = lpB + 1;

            *lpB = CHAR_BSLASH;
        }
    }

    //
    //  Assumes that a path always ends with one last un-delimited dir name.
    //  Check to make sure we have at least one.
    //
    if (lpF != lpB)
    {
        SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShortenThePath
//
//  Takes a pathname and converts all dirs to shortnames if they are
//  not valid DOS 8.3 names.
//
//  Returns:  TRUE    if pathname converted
//            FALSE   if ran out of space, buffer left alone
//  Note: pPath is assumed to be at least MAX_PATH in length.
//
////////////////////////////////////////////////////////////////////////////

BOOL ShortenThePath(
    LPTSTR pPath)
{
    TCHAR szDest[MAX_PATH];
    LPTSTR pSrcNextSpec, pReplaceSpec;
    LPTSTR pDest, p;
    LPTSTR pSrc;
    int cchPathOffset;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;
    UINT i;
    int nSpaceLeft = ARRAYSIZE(szDest) - 1;
    UNICODE_STRING Name;
    BOOLEAN fSpace = FALSE;

    //
    //  Save pointer to beginning of buffer.
    //
    pSrc = pPath;

    //
    //  Eliminate double quotes.
    //
    for (p = pDest = pSrc; *p; p++, pDest++)
    {
        if (*p == CHAR_QUOTE)
        {
            p++;
        }
        *pDest = *p;
    }

    *pDest = CHAR_NULL;

    //
    //  Strip out leading spaces.
    //
    while (*pSrc == CHAR_SPACE)
    {
        pSrc++;
    }

    //
    //  Skip past \\foo\bar or <drive>:
    //
    pDest = szDest;
    pSrcNextSpec = pSrc;

    //
    //  Reuse shell32 internal api that calculates path offset.
    //  The cchPathOffset variable will be the offset that when added to
    //  the pointer will result in a pointer to the backslash before the
    //  first part of the path.
    //
    //  NOTE:  UNICODE only call.
    //
    cchPathOffset = GetPathOffset(pSrc);

    //
    //  Check to see if it's valid.  If pSrc is not of the \\foo\bar
    //  or <drive>: form we just do nothing.
    //
    if (cchPathOffset == -1)
    {
        return (TRUE);
    }

    //
    //  cchPathOffset will always be at least 1 and is the number of
    //  characters - 1 that we want to copy (that is, if 0 was
    //  permissible, it would denote 1 character).
    //
    do
    {
        *pDest++ = *pSrcNextSpec++;

        if (!--nSpaceLeft)
        {
            return (FALSE);
        }
    } while (cchPathOffset--);

    //
    //  At this point, we have just the filenames that we can shorten:
    //  \\foo\bar\it\is\here ->  it\is\here
    //  c:\angry\lions       ->  angry\lions
    //
    while (pSrcNextSpec)
    {
        //
        //  pReplaceSpec holds the current spec we need to replace.
        //  By default, if we can't find the altname, then just use this.
        //
        pReplaceSpec = pSrcNextSpec;

        //
        //  Search for trailing "\"
        //  pSrcNextSpec will point to the next spec to fix.
        //  (*pSrcNextSpec = NULL if done)
        //
        while (*pSrcNextSpec && (!ISBACKSLASH_P(pReplaceSpec, pSrcNextSpec)))
        {
            pSrcNextSpec++;
        }

        if (*pSrcNextSpec)
        {
            //
            //  If there is more, then pSrcNextSpec should point to it.
            //  Also delimit this spec.
            //
            *pSrcNextSpec = CHAR_NULL;
        }
        else
        {
            pSrcNextSpec = NULL;
        }

        hFind = FindFirstFile(pSrc, &FindData);

        //
        //  We could exit as soon as this FindFirstFileFails,
        //  but there's the special case of having execute
        //  without read permission.  This would fail since the lfn
        //  is valid for lfn apps.
        //
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            //
            //  See if it's not a legal 8.3 name or if there are spaces
            //  in the name.  If either is true, use the alternate name.
            //
            if (NT_SUCCESS(RtlInitUnicodeStringEx(&Name, FindData.cFileName)))
            {
                if (!RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) || fSpace)
                {
                    if (FindData.cAlternateFileName[0])
                    {
                        pReplaceSpec = FindData.cAlternateFileName;
                    }
                }
            }
        }

        i = lstrlen(pReplaceSpec);
        nSpaceLeft -= i;

        if (nSpaceLeft <= 0)
        {
            return (FALSE);
        }

        EVAL(SUCCEEDED(StringCchCopy(pDest, nSpaceLeft + 1, pReplaceSpec)));
        pDest += i;

        //
        //  Now replace the CHAR_NULL with a slash if necessary.
        //
        if (pSrcNextSpec)
        {
            *pSrcNextSpec++ = CHAR_BSLASH;

            //
            //  Also add backslash to destination.
            //
            *pDest++ = CHAR_BSLASH;
            nSpaceLeft--;
        }
    }

    EVAL(SUCCEEDED(StringCchCopy(pPath, MAX_PATH, szDest)));

    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  FListAll
//
//  Given a file pattern, it changes the directory to that of the spec,
//  and updates the display.
//
//  notes: pszSpec must be a string less than MAX_FULLPATHNAME in size.
//  cchSpec is the length of the buffer that contains pszSpec.  It may
//  have an extension appended to it.
//
////////////////////////////////////////////////////////////////////////////

int FListAll(
    POPENFILEINFO pOFI,
    HWND hDlg,
    LPTSTR pszSpec,
    int cchSpec)
{
    LPTSTR pszPattern;
    TCHAR chSave;
    int nRet = 0;
    TCHAR szDirBuf[MAX_FULLPATHNAME + 1];
    BOOL bPattern = TRUE;

    if (!bCasePreserved)
    {
        CharLower(pszSpec);
    }

    //
    //  No directory.
    //
    pszPattern = StrRChr(pszSpec, pszSpec + lstrlen(pszSpec), CHAR_BSLASH);
    if (!pszPattern &&
        !StrChr(pszSpec, CHAR_COLON))
    {
        EVAL(SUCCEEDED(StringCchCopy(pOFI->szSpecCur, ARRAYSIZE(pOFI->szSpecCur), pszSpec))); // Should always be enough room.
        if (!bInitializing)
        {
            UpdateListBoxes(hDlg, pOFI, pszSpec, mskDirectory);
        }
    }
    else
    {
        *szDirBuf = CHAR_NULL;

        //
        //  Just root + pattern.
        //
        if (pszPattern == StrChr(pszSpec, CHAR_BSLASH))
        {
            if (!pszPattern)
            {
                //
                //  Didn't find a slash, must have drive.
                //
                pszPattern = CharNext(CharNext(pszSpec));
            }
            else if ((pszPattern == pszSpec) ||
                     ((pszPattern - 2 == pszSpec) &&
                      (*(pszSpec + 1) == CHAR_COLON)))
            {
                pszPattern = CharNext(pszPattern);
            }
            else
            {
                goto KillSlash;
            }
            chSave = *pszPattern;
            if (chSave != CHAR_DOT)
            {
                //
                //  If not c:.. or c:.
                //
                *pszPattern = CHAR_NULL;
            }
            EVAL(SUCCEEDED(StringCchCopy(szDirBuf, ARRAYSIZE(szDirBuf), pszSpec)));
            if (chSave == CHAR_DOT)
            {
                int lenSpec = lstrlen(pszSpec);
                pszPattern = pszSpec + lenSpec;
                // Could potentially get truncated, bPattern reflects this:
                bPattern = AppendExt(pszPattern, cchSpec - lenSpec, pOFI->pOFN->lpstrDefExt, TRUE);
            }
            else
            {
                *pszPattern = chSave;
            }
        }
        else
        {
KillSlash:
            *pszPattern++ = 0;
            EVAL(SUCCEEDED(StringCchCopy(szDirBuf, ARRAYSIZE(szDirBuf), pszSpec)));
        }

        if ((nRet = ChangeDir(hDlg, szDirBuf, TRUE, FALSE)) < 0)
        {
            return (nRet);
        }

        if (bPattern)
        {
            EVAL(SUCCEEDED(StringCchCopy(pOFI->szSpecCur, ARRAYSIZE(pOFI->szSpecCur), pszPattern)));
            SetDlgItemText(hDlg, edt1, pOFI->szSpecCur);

            SelDisk(hDlg, NULL);

            if (!bInitializing)
            {
                SendMessage( hDlg,
                             WM_COMMAND,
                             GET_WM_COMMAND_MPS( cmb2,
                                                 GetDlgItem(hDlg, cmb2),
                                                 MYCBN_DRAW ) );
            }
        }
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeDir
//
//  Changes the current directory and/or resource.
//
//  lpszDir - Fully qualified, or partially qualified names.
//            To change to another disk and cd automatically to the
//            last directory as set in the shell's environment, specify
//            only a disk name (i.e. c: or \\triskal\scratch - must not end
//            in backslash).
//  bForce  - If True, then caller requires that ChangeDir successfully cd
//            somewhere.  Order of cding is as follows:
//                1. lpszDir
//                2. current dir for the current thread
//                3. root of current dir for the current thread
//                4. c:
//  bError - if TRUE, then pop up an AccessDenied dialog at every step
//           in the force.
//
//  Returns an index into gaDiskInfo for new disk chosen or,
//  the ADDDISK_error code.
//  Returns ADDDISK_NOCHANGE in the event that it cannot cd to the root
//  directory of the specific file.
//
////////////////////////////////////////////////////////////////////////////

int ChangeDir(
    HWND hDlg,
    LPCTSTR lpszDir,
    BOOL bForce,
    BOOL bError)
{
    TCHAR szCurDir[CCHNETPATH];
    LPTSTR lpCurDir;
    int cchDirLen;
    TCHAR wcDrive = 0;
    int nIndex;
    BOOL nRet;
    LPCURDLG lpCurDlg;


    //
    //  SheChangeDirEx will call GetCurrentDir, but will use what it
    //  gets only in the case where the path passed in was no good.
    //

    //
    //  1st, try request.
    //
    if (lpszDir && *lpszDir)
    {
        if (SUCCEEDED(StringCchCopy(szCurDir, ARRAYSIZE(szCurDir), lpszDir)))
        {
            //
            //  Remove trailing spaces.
            //
            lpCurDir = szCurDir + lstrlen(szCurDir) - 1;
            while (*lpCurDir && (*lpCurDir == CHAR_SPACE))
            {
                *lpCurDir-- = CHAR_NULL;
            }

            nRet = SheChangeDirEx(szCurDir);
        
            if (nRet == ERROR_ACCESS_DENIED)
            {
                if (bError)
                {
                    //
                    //  Casting to LPTSTR is ok below - InvalidFileWarning will
                    //  not change this string because the path is always
                    //  guaranteed to be <= MAX_FULLPATHNAME.
                    //
                    InvalidFileWarning( hDlg,
                                        (LPTSTR)lpszDir,
                                        ERROR_DIR_ACCESS_DENIED,
                                        0 );
                }

                if (!bForce)
                {
                    return (CHANGEDIR_FAILED);
                }
            }
            else
            {
                goto ChangeDir_OK;
            }
        }
    }

    //
    //  2nd, try lpCurDlg->lpstrCurDir value (which we got above).
    //
    //  !!! need to check for a null return value ???
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

    nRet = SheChangeDirEx(lpCurDir);

    if (nRet == ERROR_ACCESS_DENIED)
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                lpCurDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    //
    //  3rd, try root of lpCurDlg->lpstrCurDir or GetCurrentDir (sanity).
    //
    EVAL(SUCCEEDED(StringCchCopy(szCurDir, ARRAYSIZE(szCurDir), lpCurDir)));
    cchDirLen = GetPathOffset(szCurDir);

    //
    //  Sanity check - it's guaranteed not to fail ...
    //
    if (cchDirLen != -1)
    {
        szCurDir[cchDirLen] = CHAR_BSLASH;
        szCurDir[cchDirLen + 1] = CHAR_NULL;

        nRet = SheChangeDirEx(szCurDir);

        if (nRet == ERROR_ACCESS_DENIED)
        {
            if (bError)
            {
                InvalidFileWarning( hDlg,
                                    (LPTSTR)lpszDir,
                                    ERROR_DIR_ACCESS_DENIED,
                                    0 );
            }
        }
        else
        {
            goto ChangeDir_OK;
        }
    }

    //
    //  4th, try c:
    //
    StringCchCopy(szCurDir, ARRAYSIZE(szCurDir), L"c:");
    nRet = SheChangeDirEx(szCurDir);

    if (nRet == ERROR_ACCESS_DENIED)
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                (LPTSTR)lpszDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    return (CHANGEDIR_FAILED);

ChangeDir_OK:

    GetCurrentDirectory(ARRAYSIZE(szCurDir), szCurDir);

    nIndex = DiskAddedPreviously(0, szCurDir);

    //
    //  If the disk doesn't exist, add it.
    //
    if (nIndex == -1)
    {
        HWND hCmb2 = GetDlgItem(hDlg, cmb2);
        LPTSTR lpszDisk = NULL;
        DWORD dwType;
        TCHAR wc1, wc2;

        if (szCurDir[1] == CHAR_COLON)
        {
            wcDrive = szCurDir[0];
        }
        else
        {
            lpszDisk = &szCurDir[0];
        }

        cchDirLen = GetPathOffset(szCurDir);
        if (cchDirLen != -1)
        {
            wc1 = szCurDir[cchDirLen];
            wc2 = szCurDir[cchDirLen + 1];

            szCurDir[cchDirLen] = CHAR_BSLASH;
            szCurDir[cchDirLen + 1] = CHAR_NULL;
        }

        dwType = GetDiskIndex(GetDiskType(szCurDir));

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = CHAR_NULL;
        }

        nIndex = AddDisk(wcDrive, lpszDisk, NULL, dwType);

        SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

        wNoRedraw |= 1;

        SendMessage( hCmb2,
                     CB_SETITEMDATA,
                     (WPARAM)SendMessage(
                                 hCmb2,
                                 CB_ADDSTRING,
                                 (WPARAM)0,
                                 (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                     (LPARAM)gaDiskInfo[nIndex].dwType );

        if ((dwType != NETDRVBMP) && (dwType != REMDRVBMP))
        {
            gaDiskInfo[nIndex].bCasePreserved =
                IsFileSystemCasePreserving(gaDiskInfo[nIndex].lpPath);
        }

        wNoRedraw &= ~1;

        SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = wc1;
            szCurDir[cchDirLen + 1] = wc2;
        }
    }
    else
    {
        //
        //  Validate the disk if it has been seen before.
        //
        //  For unc names that fade away, refresh the cmb2 box.
        //
        if (!gaDiskInfo[nIndex].bValid)
        {
            gaDiskInfo[nIndex].bValid = TRUE;

            SendDlgItemMessage(
                   hDlg,
                   cmb2,
                   CB_SETITEMDATA,
                   (WPARAM)SendDlgItemMessage(
                               hDlg,
                               cmb2,
                               CB_ADDSTRING,
                               (WPARAM)0,
                               (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                   (LPARAM)gaDiskInfo[nIndex].dwType );
        }
    }

    //
    //  Update our global concept of Case.
    //
    if (nIndex >= 0)
    {
        //
        //  Send special WOW message to indicate the directory has
        //  changed.
        //
        SendMessage(hDlg, msgWOWDIRCHANGE, 0, 0);

        //
        //  Get pointer to current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        if (!lpCurDlg || !lpCurDir)
        {
            return (CHANGEDIR_FAILED);
        }

        bCasePreserved = gaDiskInfo[nIndex].bCasePreserved;

        //
        //  In case the unc name already has a drive letter, correct
        //  lst2 display.
        //
        cchDirLen = 0;

        //
        //  Compare with szCurDir since it's been lowercased.
        //
        if (DBL_BSLASH(szCurDir) &&
            (*gaDiskInfo[nIndex].lpAbbrName != szCurDir[0]))
        {
            if ((cchDirLen = GetPathOffset(szCurDir)) != -1)
            {
                szCurDir[--cchDirLen] = CHAR_COLON;
                szCurDir[--cchDirLen] = *gaDiskInfo[nIndex].lpAbbrName;
            }
        }

        if ((gaDiskInfo[nIndex].dwType == CDDRVBMP) ||
            (gaDiskInfo[nIndex].dwType == FLOPPYBMP))
        {
            if (*lpCurDir != gaDiskInfo[nIndex].wcDrive)
            {
                TCHAR szDrive[5];

                //
                //  Get new volume info - should always succeed.
                //
                szDrive[0] = gaDiskInfo[nIndex].wcDrive;
                szDrive[1] = CHAR_COLON;
                szDrive[2] = CHAR_BSLASH;
                szDrive[3] = CHAR_NULL;
                UpdateLocalDrive(szDrive, TRUE);

                //
                //  Flush to the cmb before selecting the disk.
                //
                if ( lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg) )
                {
                    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;
                    FlushDiskInfoToCmb2();
                }
            }
        }
        
        // lpCurDir came from lpstrCurDir, which is of length CCHNETPATH
        EVAL(SUCCEEDED(StringCchCopy(lpCurDir, CCHNETPATH, (LPTSTR)&szCurDir[cchDirLen]))); // szCurDir not longer than CCH_NETPATH
        PathAddBackslash(lpCurDir);

        //
        //  If the worker thread is running, then trying to select here
        //  will just render the cmb2 blank, which is what we want;
        //  otherwise, it should successfully select it.
        //
        SelDisk(hDlg, gaDiskInfo[nIndex].lpPath);
    }

    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsFileSystemCasePreserving
//
////////////////////////////////////////////////////////////////////////////

BOOL IsFileSystemCasePreserving(
    LPTSTR lpszDisk)
{
    TCHAR szPath[MAX_FULLPATHNAME];
    DWORD dwFlags;

    if (!lpszDisk)
    {
        return (FALSE);
    }

    if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), lpszDisk)))
    {
        if (SUCCEEDED(StringCchCat(szPath, ARRAYSIZE(szPath), L"\\")))
        {
            if (GetVolumeInformation( szPath,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL,
                                      &dwFlags,
                                      NULL,
                                      0 ))
            {
                return ((dwFlags & FS_CASE_IS_PRESERVED));
            }
        }
    }

    //
    //  Default to FALSE if there is an error.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsLFNDriveX
//
////////////////////////////////////////////////////////////////////////////

BOOL IsLFNDriveX(
    HWND hDlg,
    LPTSTR pszPath)
{
    TCHAR szRootPath[MAX_FULLPATHNAME];
    DWORD dwVolumeSerialNumber;
    DWORD dwMaximumComponentLength;
    DWORD dwFileSystemFlags;
    LPTSTR lpCurDir;
    LPCURDLG lpCurDlg;


    if (!pszPath[0] || !pszPath[1] ||
        (pszPath[1] != CHAR_COLON && !(DBL_BSLASH(pszPath))))
    {
        //
        //  If the path is not a full path then get the directory path
        //  from the TLS current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        EVAL(SUCCEEDED(StringCchCopy(szRootPath, ARRAYSIZE(szRootPath), lpCurDir)));
    }
    else
    {
        EVAL(SUCCEEDED(StringCchCopy(szRootPath, ARRAYSIZE(szRootPath), pszPath)));
    }

    if (szRootPath[1] == CHAR_COLON)
    {
        szRootPath[2] = CHAR_BSLASH;
        szRootPath[3] = 0;
    }
    else if (DBL_BSLASH(szRootPath))
    {
        int i;
        LPTSTR p;

        //
        //  Stop at "\\foo\bar".
        //
        for (i = 0, p = szRootPath + 2; *p && i < 2; p++)
        {
            if (ISBACKSLASH_P(szRootPath, p))
            {
                i++;
            }
        }

        switch (i)
        {
            case ( 0 ) :
            {
                return (FALSE);
            }
            case ( 1 ) :
            {
                if (lstrlen(szRootPath) < MAX_FULLPATHNAME - 2)
                {
                    *p = CHAR_BSLASH;
                    *(p + 1) = CHAR_NULL;
                }
                else
                {
                    return (FALSE);
                }
                break;
            }

            case ( 2 ) :
            {
                *p = CHAR_NULL;
                break;
            }
        }
    }

    if (GetVolumeInformation( szRootPath,
                              NULL,
                              0,
                              &dwVolumeSerialNumber,
                              &dwMaximumComponentLength,
                              &dwFileSystemFlags,
                              NULL,
                              0 ))
    {
        if (dwMaximumComponentLength == (MAXDOSFILENAMELEN - 1))
        {
            return (FALSE);
        }
        else
        {
            return (TRUE);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DiskAddedPreviously
//
//  This routine checks to see if a disk resource has been previously
//  added to the global structure.
//
//  wcDrive  - if this is set, then there is no lpszName comparison
//  lpszName - if wcDrive is not set, but the lpszName is of the form
//               "c:\" then set wcDrive = *lpszName and index by drive letter
//             else assume lpszName is a unc name
//
//  Returns:   0xFFFFFFFF   failure (disk doesn't exist in list)
//             0 - 128      number of disk in list
//
////////////////////////////////////////////////////////////////////////////

int DiskAddedPreviously(
    TCHAR wcDrive,
    LPTSTR lpszName)
{
    WORD i;

    //
    //  There are two index schemes (by drive or by unc \\server\share).
    //  If it doesn't have a drive letter, assume unc.
    //
    if (wcDrive || (lpszName && (*(lpszName + 1) == CHAR_COLON)))
    {
        if (!wcDrive)
        {
            wcDrive = *lpszName;
            wcDrive = (TCHAR)CharLower((LPTSTR)wcDrive);
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            //
            //  See if the drive letters are the same.
            //
            if (wcDrive)
            {
                if (wcDrive == (TCHAR)CharLower((LPTSTR)gaDiskInfo[i].wcDrive))
                {
                    return (i);
                }
            }
        }
    }
    else if (lpszName)
    {
        DWORD cchDirLen;
        TCHAR wc;

        //
        //  Check remote name (\\server\share).
        //
        cchDirLen = GetPathOffset(lpszName);

        //
        //  If we're given a unc path, get the disk name.
        //  Otherwise, assume the whole thing is a disk name.
        //
        if (cchDirLen != -1)
        {
            wc = *(lpszName + cchDirLen);
            *(lpszName + cchDirLen) = CHAR_NULL;
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            if (!lstrcmpi(gaDiskInfo[i].lpName, lpszName))
            {
                if (cchDirLen != -1)
                {
                    *(lpszName + cchDirLen) = wc;
                }
                return (i);
            }
        }

        if (cchDirLen != -1)
        {
            *(lpszName + cchDirLen) = wc;
        }
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddDisk
//
//  Adds a disk to one of the global structures:
//      gaNetDiskInfo
//      gaLocalDiskInfo
//
//  wcDrive    - the drive to attach to (this parm should be 0 for unc)
//  lpName     - \\server\share name for remote disks
//               volume name for local disks
//  lpProvider - used for remote disks only, the name of the provider
//               used with WNetFormatNetworkName api
//  dwType     - type of the bitmap to display
//               except when we are adding a drive letter temporarily
//               at startup this parameter can equal TMPNETDRV in which
//               case we set the bitmap to NETDRVBMP
//
//  Returns:  -2    Cannot Add Disk
//            -1    DiskInfo did not change
//             0    dwNumDisks - DiskInfo changed
//
////////////////////////////////////////////////////////////////////////////

int AddDisk(
    TCHAR wcDrive,
    LPTSTR lpName,
    LPTSTR lpProvider,
    DWORD dwType)
{
    int nIndex, nRet;
    DWORD cchMultiLen = 0;
    DWORD cchAbbrLen = 0;
    DWORD cchLen;
    DWORD dwRet = 0;
    LPTSTR lpBuff;
    OFN_DISKINFO *pofndiDisk = NULL, *pgDI;


    //
    //  Sanity check - wcDrive and/or lpName must be set.
    //
    if (!wcDrive && (!lpName || !*lpName))
    {
        return (ADDDISK_INVALIDPARMS);
    }

    nIndex = DiskAddedPreviously(wcDrive, lpName);

    if (nIndex != 0xFFFFFFFF)
    {
        //
        //  Do not add a temporary drive letter if we already
        //  have something better (added, for example, in a previous call).
        //
        if (dwType == TMPNETDRV)
        {
            gaDiskInfo[nIndex].bValid = TRUE;
            return (ADDDISK_NOCHANGE);
        }

        //  Using a floating profile, there can be collisions between
        //  local and network drives in which case we take the former.
        //
        //  Note: If the drive is remembered, we assume that getdrivetype
        //        will return false and that the drive is not added.
        //        But if it was added, then we overwrite anyway,
        //        since it's the desired behavior.
        //
        if ((dwType == REMDRVBMP) &&
            (dwType != gaDiskInfo[nIndex].dwType))
        {
            return (ADDDISK_NOCHANGE);
        }

        //
        //  Update previous connections.
        //
        if (!lstrcmpi(lpName, gaDiskInfo[nIndex].lpName))
        {
            //
            //  Don't update a connection as remembered, unless it's been
            //  invalidated.
            //
            if (dwType != REMDRVBMP)
            {
                gaDiskInfo[nIndex].dwType = dwType;
            }
            gaDiskInfo[nIndex].bValid = TRUE;

            return (ADDDISK_NOCHANGE);
        }
        else if (!*lpName && ((dwType == CDDRVBMP) || (dwType == FLOPPYBMP)))
        {
            //
            //  Guard against lazy calls to updatelocaldrive erasing current
            //  changed dir volume name (set via changedir).
            //
            return (ADDDISK_NOCHANGE);
        }
    }

    if (dwNumDisks >= MAX_DISKS)
    {
        return (ADDDISK_MAXNUMDISKS);
    }

    //
    //  If there is a drive, then lpPath needs only 4.
    //  If it's unc, then lpPath just equals lpName.
    //
    if (wcDrive)
    {
        cchLen = 4;
    }
    else
    {
        cchLen = 0;
    }

    if (lpName && *lpName)
    {
        //
        //  Get the length of the standard (Remote/Local) name.
        //
        cchLen += (lstrlen(lpName) + 1);

        if (lpProvider && *lpProvider &&
            ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
        {
            //
            //  Get the length for the multiline name.
            //
            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchMultiLen,
                                           WNFMT_MULTILINE,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard)
            //
            if (wcDrive)
            {
                cchMultiLen += 4;
            }

            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchAbbrLen,
                                           WNFMT_ABBREVIATED,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard).
            //
            if (wcDrive)
            {
                cchAbbrLen += 4;
            }
        }
        else
        {
            //
            //  Make enough room so that lpMulti and lpAbbr can point to
            //  4 characters (drive letter + : + space + null) ahead of
            //  lpremote.
            //
            if (wcDrive)
            {
                cchLen += 4;
            }
        }
    }
    else
    {
        //
        //  Make enough room so that lpMulti and lpAbbr can point to
        //  4 characters (drive letter + : + space + null) ahead of
        //  lpremote.
        //
        if (wcDrive)
        {
            cchLen += 4;
        }
    }

    //
    //  Allocate a temp OFN_DISKINFO object to work with.
    //  When we are finished, we'll request the critical section
    //  and update the global array.
    //
    pofndiDisk = (OFN_DISKINFO *)LocalAlloc(LPTR, sizeof(OFN_DISKINFO));
    if (!pofndiDisk)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    lpBuff = (LPTSTR)LocalAlloc( LPTR,
                                 (cchLen + cchMultiLen + cchAbbrLen) * sizeof(TCHAR));
    if (!lpBuff)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    if (dwType == TMPNETDRV)
    {
        pofndiDisk->dwType = NETDRVBMP;
    }
    else
    {
        pofndiDisk->dwType = dwType;
    }

    //
    //  Always set these slots, even though wcDrive can equal 0.
    //
    pofndiDisk->wcDrive = wcDrive;
    pofndiDisk->bValid = TRUE;

    pofndiDisk->cchLen = cchLen + cchAbbrLen + cchMultiLen;

    //
    //  NOTE: lpAbbrName must always point to the head of lpBuff
    //        so that we can free the block later at DLL_PROCESS_DETACH
    //
    if (lpName && *lpName && lpProvider && *lpProvider &&
        ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
    {
        //
        //  Create an entry for a network disk.
        //
        pofndiDisk->lpAbbrName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchAbbrLen -= 3;
        }

        dwRet = WNetFormatNetworkName( lpProvider,
                                       lpName,
                                       lpBuff,
                                       &cchAbbrLen,
                                       WNFMT_ABBREVIATED,
                                       dwAveCharPerLine );
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        lpBuff += cchAbbrLen;

        pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchMultiLen -= 3;
        }

        dwRet = WNetFormatNetworkName(lpProvider, lpName,
                                      lpBuff, &cchMultiLen, WNFMT_MULTILINE, dwAveCharPerLine);
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        //
        //  Note: this assumes that the lpRemoteName
        //        returned by WNetEnumResources is always in
        //        the form \\server\share (without a trailing bslash).
        //
        pofndiDisk->lpPath = lpBuff;

        //
        //  if it's not unc.
        //
        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_NULL;
            cchLen -= 3;
        }

        EVAL(SUCCEEDED(StringCchCopy(lpBuff, cchLen, lpName))); // Should always be enough room.
        pofndiDisk->lpName = lpBuff;

        pofndiDisk->bCasePreserved =
            IsFileSystemCasePreserving(pofndiDisk->lpPath);
    }
    else
    {
        //
        //  Create entry for a local name, or a network one with
        //  no name yet.
        //
        pofndiDisk->lpAbbrName = pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;
            cchLen -= 3;
        }

        if (lpName)
        {
            EVAL(SUCCEEDED(StringCchCopy(lpBuff, cchLen, lpName))); // Should always be enough room.
        }
        else
        {
            *lpBuff = CHAR_NULL;
        }

        pofndiDisk->lpName = lpBuff;

        if (wcDrive)
        {
            lpBuff += lstrlen(lpBuff) + 1;
            *lpBuff = wcDrive;
            *(lpBuff + 1) = CHAR_COLON;
            *(lpBuff + 2) = CHAR_NULL;
        }

        pofndiDisk->lpPath = lpBuff;

        if ((dwType == NETDRVBMP) || (dwType == REMDRVBMP))
        {
            pofndiDisk->bCasePreserved =
                IsFileSystemCasePreserving(pofndiDisk->lpPath);
        }
        else
        {
            pofndiDisk->bCasePreserved = FALSE;
        }
    }

    //
    //  Now we need to update the global array.
    //
    if (nIndex == 0xFFFFFFFF)
    {
        nIndex = dwNumDisks;
    }

    pgDI = &gaDiskInfo[nIndex];

    //
    //  Enter critical section and update data.
    //
    EnterCriticalSection(&g_csLocal);

    pgDI->cchLen = pofndiDisk->cchLen;
    pgDI->lpAbbrName = pofndiDisk->lpAbbrName;
    pgDI->lpMultiName = pofndiDisk->lpMultiName;
    pgDI->lpName = pofndiDisk->lpName;
    pgDI->lpPath = pofndiDisk->lpPath;
    pgDI->wcDrive = pofndiDisk->wcDrive;
    pgDI->bCasePreserved = pofndiDisk->bCasePreserved;
    pgDI->dwType = pofndiDisk->dwType;
    pgDI->bValid = pofndiDisk->bValid;

    LeaveCriticalSection(&g_csLocal);

    if ((DWORD)nIndex == dwNumDisks)
    {
        dwNumDisks++;
    }

    nRet = nIndex;

AddDisk_Error:

    if (pofndiDisk)
    {
        LocalFree(pofndiDisk);
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableDiskInfo
//
////////////////////////////////////////////////////////////////////////////

VOID EnableDiskInfo(
    BOOL bValid,
    BOOL bDoUnc)
{
    DWORD dwCnt = dwNumDisks;

    EnterCriticalSection(&g_csLocal);
    while (dwCnt--)
    {
        if (gaDiskInfo[dwCnt].dwType == NETDRVBMP)
        {
            if (!(DBL_BSLASH(gaDiskInfo[dwCnt].lpAbbrName)) || bDoUnc)
            {
                gaDiskInfo[dwCnt].bValid = bValid;
            }

            //
            //  Always re-invalidate remembered just in case someone
            //  escapes from fileopen, removes a connection
            //  overriding a remembered and comes back expecting to see
            //  the original remembered.
            //
        }
    }
    LeaveCriticalSection(&g_csLocal);
}


////////////////////////////////////////////////////////////////////////////
//
//  FlushDiskInfoToCmb2
//
////////////////////////////////////////////////////////////////////////////

VOID FlushDiskInfoToCmb2()
{
    DWORD dwDisk;
    DWORD dwDlg;

    for (dwDlg = 0; dwDlg < dwNumDlgs; dwDlg++)
    {
        if (gahDlg[dwDlg])
        {
            HWND hCmb2;

            if (hCmb2 = GetDlgItem(gahDlg[dwDlg], cmb2))
            {
                wNoRedraw |= 1;

                SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

                SendMessage(hCmb2, CB_RESETCONTENT, 0, 0);

                dwDisk = dwNumDisks;
                while (dwDisk--)
                {
                    if (gaDiskInfo[dwDisk].bValid)
                    {
                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                hCmb2,
                                CB_ADDSTRING,
                                (WPARAM)0,
                                (LPARAM)(LPTSTR)gaDiskInfo[dwDisk].lpAbbrName ),
                            (LPARAM)gaDiskInfo[dwDisk].dwType );
                    }
                }

                wNoRedraw &= ~1;

                SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hCmb2, NULL, FALSE);

                SendMessage( gahDlg[dwDlg],
                             WM_COMMAND,
                             GET_WM_COMMAND_MPS(cmb2, hCmb2, MYCBN_REPAINT) );
            }
            gahDlg[dwDlg] = NULL;           
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CallNetDlg
//
//  Calls the appropriate network dialog in winnet driver.
//
//  hwndParent - parent window of network dialog
//
//  Returns:  TRUE     there are new drives to display
//            FALSE    there are no new drives to display
//
////////////////////////////////////////////////////////////////////////////

BOOL CallNetDlg(
    HWND hWnd)
{
    DWORD wRet;

    HourGlass(TRUE);

    wRet = WNetConnectionDialog(hWnd, WNTYPE_DRIVE);

    if ((wRet != WN_SUCCESS) && (wRet != WN_CANCEL) && (wRet != 0xFFFFFFFF))
    {
        if (CDLoadString( g_hinst,
                         iszNoNetButtonResponse,
                         szCaption,
                         ARRAYSIZE(szCaption)))
        {
            EVAL(SUCCEEDED(StringCchPrintf(szWarning, ARRAYSIZE(szWarning), szCaption)));

            GetWindowText(hWnd, szCaption, WARNINGMSGLENGTH);
            MessageBox( hWnd,
                        szWarning,
                        szCaption,
                        MB_OK | MB_ICONEXCLAMATION );
        }
    }

    HourGlass(FALSE);

    return (wRet == WN_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskType
//
////////////////////////////////////////////////////////////////////////////

UINT GetDiskType(
    LPTSTR lpszDisk)
{
    //
    //  Unfortunately GetDriveType is not for deviceless connections.
    //  So assume all unc stuff is just "remote" - no way of telling
    //  if it's a cdrom or not.
    //
    if (DBL_BSLASH(lpszDisk))
    {
        return (DRIVE_REMOTE);
    }
    else
    {
        return (GetDriveType(lpszDisk));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUNCDirectoryFromLB
//
//  If lb contains a UNC listing, the function returns the full UNC path.
//
//  Returns:   0 if no UNC listing in lb
//             length of UNC listing string
//  Note: this also fills in pOFI->szPath with the *full* UNC path (if UNC),
//         or the name of the drive (if not UNC)
//
////////////////////////////////////////////////////////////////////////////

DWORD GetUNCDirectoryFromLB(
    HWND hDlg,
    WORD nLB,
    POPENFILEINFO pOFI)
{
    DWORD cch;
    DWORD idir;
    DWORD idirCurrent;

    cch = (DWORD)SendDlgItemMessage( hDlg,
                                     nLB,
                                     LB_GETTEXT,
                                     0,
                                     (LPARAM)(LPTSTR)pOFI->szPath );
    //
    //  If not UNC listing, return 0.
    //
    if (pOFI->szPath[0] != CHAR_BSLASH)
    {
        return (0);
    }

    idirCurrent = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                   nLB,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L );
    if (idirCurrent < (pOFI->idirSub - 1))
    {
        pOFI->idirSub = idirCurrent;
    }
    pOFI->szPath[cch++] = CHAR_BSLASH;
    for (idir = 1; idir < pOFI->idirSub; ++idir)
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idir,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    //
    //  Only add the subdirectory if it's not the \\server\share point.
    //
    if (idirCurrent && (idirCurrent >= pOFI->idirSub))
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idirCurrent,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    pOFI->szPath[cch] = CHAR_NULL;

    return (cch);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelDisk
//
//  Selects the given disk in the combo drive list.  Works for unc names,
//  too.
//
////////////////////////////////////////////////////////////////////////////

VOID SelDisk(
    HWND hDlg,
    LPTSTR lpszDisk)
{
    HWND hCmb = GetDlgItem(hDlg, cmb2);

    if (lpszDisk)
    {
        CharLower(lpszDisk);

        SendMessage( hCmb,
                     CB_SETCURSEL,
                     (WPARAM)SendMessage( hCmb,
                                          CB_FINDSTRING,
                                          (WPARAM)-1,
                                          (LPARAM)lpszDisk ),
                     0L );
    }
    else
    {
        TCHAR szChangeSel[CCHNETPATH];
        LPTSTR lpCurDir;
        LPCURDLG lpCurDlg;

        if ((lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) &&
            (lpCurDir = lpCurDlg->lpstrCurDir))
        {
            int cch;
            if (!GetCurrentDirectory(ARRAYSIZE(szChangeSel), szChangeSel))
            {
                EVAL(SUCCEEDED(StringCchCopy(szChangeSel, ARRAYSIZE(szChangeSel), lpCurDir)));
            }
            cch = GetPathOffset(szChangeSel);
            if (cch != -1)
            {
                szChangeSel[cch] = CHAR_NULL;
            }

            SendMessage( hCmb,
                         CB_SETCURSEL,
                         (WPARAM)SendMessage( hCmb,
                                              CB_FINDSTRING,
                                              (WPARAM)-1,
                                              (LPARAM)szChangeSel ),
                         0L );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LNDSetEvent
//
////////////////////////////////////////////////////////////////////////////

VOID LNDSetEvent(
    HWND hDlg)
{
    LPCURDLG lpCurDlg;

    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if ( lpCurDlg &&
         hLNDEvent &&
         !wNoRedraw &&
         hLNDThread &&
         bNetworkInstalled)
    {
        gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

        SetEvent(hLNDEvent);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateLocalDrive
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateLocalDrive(
    LPTSTR szDrive,
    BOOL bGetVolName)
{
    DWORD dwFlags = 0;
    DWORD dwDriveType;
    TCHAR szVolLabel[MAX_PATH];

    //
    //  No unc here - so bypass extra call to GetDiskType and call
    //  GetDriveType directly.
    //
    dwDriveType = GetDriveType(szDrive);
    if ((dwDriveType != 0) && (dwDriveType != 1))
    {
        BOOL bRet = TRUE;

        szVolLabel[0] = CHAR_NULL;
        szDrive[1] = CHAR_COLON;
        szDrive[2] = CHAR_NULL;

        if ( bGetVolName ||
             ((dwDriveType != DRIVE_REMOVABLE) &&
              (dwDriveType != DRIVE_CDROM) &&
              (dwDriveType != DRIVE_REMOTE)) )
        {
            //
            //  Removing call to CharUpper since it causes trouble on
            //  turkish machines.
            //
            //  CharUpper(szDrive);

            if (GetFileAttributes(szDrive) != (DWORD)0xffffffff)
            {
                if (dwDriveType != DRIVE_REMOTE)
                {
                    szDrive[2] = CHAR_BSLASH;

                    bRet = GetVolumeInformation( szDrive,
                                                 szVolLabel,
                                                 MAX_PATH,
                                                 NULL,
                                                 NULL,
                                                 &dwFlags,
                                                 NULL,
                                                 (DWORD)0 );

                    //
                    //  The adddisk hack to prevent lazy loading from
                    //  overwriting the current removable media's label
                    //  with "" (because it never calls getvolumeinfo)
                    //  is to not allow null lpnames to overwrite, so when
                    //  the volume label really is null, we make it a space.
                    //
                    if (!szVolLabel[0])
                    {
                        szVolLabel[0] = CHAR_SPACE;
                        szVolLabel[1] = CHAR_NULL;
                    }
                }
            }
        }

        if (bRet)
        {
            int nIndex;

            CharLower(szDrive);

            if (dwDriveType == DRIVE_REMOTE)
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  TMPNETDRV );
            }
            else
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  GetDiskIndex(dwDriveType) );
            }

            if (nIndex != ADDDISK_NOCHANGE)
            {
                gaDiskInfo[nIndex].bCasePreserved =
                    (dwFlags & FS_CASE_IS_PRESERVED);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNetDrives
//
//  Enumerates network disk resources and updates the global disk info
//  structure.
//
//  dwScope   RESOURCE_CONNECTED or RESOURCE_REMEMBERED
//
//  Returns the last connection that did not previously exist.
//
////////////////////////////////////////////////////////////////////////////

VOID GetNetDrives(
    DWORD dwScope)
{
    DWORD dwRet;
    HANDLE hEnum = NULL;

    //
    //  Guard against termination with the enum handle open.
    //
    dwRet = WNetOpenEnum( dwScope,
                          RESOURCETYPE_DISK,
                          RESOURCEUSAGE_CONNECTABLE,
                          NULL,
                          &hEnum );
    if (dwRet == WN_SUCCESS)
    {
        while (dwRet == WN_SUCCESS)
        {
            DWORD dwCount = 0xffffffff;
            DWORD cbSize = cbNetEnumBuf;

            if (bLNDExit)
            {
                WNetCloseEnum(hEnum);
                return;
            }

            dwRet = WNetEnumResource(hEnum, &dwCount, gpcNetEnumBuf, &cbSize);
            switch (dwRet)
            {
                case ( WN_SUCCESS ) :
                {
                    //
                    //  Add the Entries to the listbox.
                    //
                    TCHAR wcDrive = 0;
                    NETRESOURCE *pNetRes;
                    WORD i;

                    pNetRes = (LPNETRESOURCE)gpcNetEnumBuf;

                    for (i = 0; dwCount; dwCount--, i++)
                    {
                        if (pNetRes[i].lpLocalName)
                        {
                            CharLower(pNetRes[i].lpLocalName);
                            wcDrive = *pNetRes[i].lpLocalName;
                        }
                        else
                        {
                            //
                            //  Skip deviceless names that are not
                            //  LanMan provided (or, in the case where there
                            //  is no LanMan provider name, skip deviceless
                            //  always).
                            //
                            wcDrive = 0;
                        }

                        if (!DBL_BSLASH(pNetRes[i].lpRemoteName))
                        {
                            continue;
                        }

                        //
                        //  When bGetNetDrivesSync is TRUE, we are coming back
                        //  from the Network button, so we want to cd to the
                        //  last connected drive.
                        //      (see last command in this routine)
                        //
                        if (bGetNetDrivesSync)
                        {
                            int nIndex;
                            WORD k;

                            nIndex = AddDisk( wcDrive,
                                              pNetRes[i].lpRemoteName,
                                              pNetRes[i].lpProvider,
                                              (dwScope == RESOURCE_REMEMBERED)
                                                  ? REMDRVBMP
                                                  : NETDRVBMP );

                            //
                            //  If it's a new connection, update global state.
                            //
                            if (nIndex >= 0)
                            {
                                //
                                //  Since flushdiskinfotocmb2 will clear out
                                //  the array below, remember it's state here.
                                //  It's a hack, but a nice way to find out
                                //  exactly which of the many threads
                                //  completed a net dlg operation.
                                //
                                for (k = 0; k < dwNumDlgs; k++)
                                {
                                    if (gahDlg[k])
                                    {
                                        //  Could encounter small problems with
                                        //  preemption here, but assume that
                                        //  user cannot simultaneously return
                                        //  from two different net dlg calls.
                                        //
                                        lpNetDriveSync = gaDiskInfo[nIndex].lpPath;

                                        SendMessage(
                                            gahDlg[k],
                                            WM_COMMAND,
                                            GET_WM_COMMAND_MPS(
                                                   cmb2,
                                                   GetDlgItem(gahDlg[k], cmb2),
                                                   MYCBN_CHANGEDIR ) );
                                    }
                                }
                            }
                        }
                        else
                        {
                            AddDisk( wcDrive,
                                     pNetRes[i].lpRemoteName,
                                     pNetRes[i].lpProvider,
                                     (dwScope == RESOURCE_REMEMBERED)
                                         ? REMDRVBMP
                                         : NETDRVBMP );
                        }
                    }
                    break;
                }
                case ( WN_MORE_DATA ) :
                {
                    LPTSTR pcTemp;

                    pcTemp = (LPTSTR)LocalReAlloc( gpcNetEnumBuf,
                                                   cbSize,
                                                   LMEM_MOVEABLE );
                    if (!pcTemp)
                    {
                        cbNetEnumBuf = 0;
                    }
                    else
                    {
                        gpcNetEnumBuf = pcTemp;
                        cbNetEnumBuf = cbSize;
                        dwRet = WN_SUCCESS;
                        break;
                    }
                }
                case ( WN_NO_MORE_ENTRIES ) :
                case ( WN_EXTENDED_ERROR ) :
                case ( WN_NO_NETWORK ) :
                {
                    //
                    //  WN_NO_MORE_ENTRIES is a success error code.
                    //  It is special cased when we fall out of the loop.
                    //
                    break;
                }
                case ( WN_BAD_HANDLE ) :
                default :
                {
                    break;
                }
            }
        }

        WNetCloseEnum(hEnum);

        //
        //  Flush once per event - there will always be a call with
        //  dwscope = connected.
        //
        if (dwScope == RESOURCE_CONNECTED)
        {
            FlushDiskInfoToCmb2();
        }

        if (bGetNetDrivesSync)
        {
            bGetNetDrivesSync = FALSE;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ListNetDrivesHandler
//
////////////////////////////////////////////////////////////////////////////

VOID ListNetDrivesHandler()
{
    BOOL bInit = TRUE;
    HANDLE hEnum = NULL;
  
    if (!gpcNetEnumBuf &&
        !(gpcNetEnumBuf = (LPTSTR)LocalAlloc(LPTR, cbNetEnumBuf)))
    {
        hLNDThread = NULL;
        return;
    }

    if (bLNDExit)
    {
        goto LNDExitThread1;
    }

    EnterCriticalSection(&g_csNetThread);
   
    while (1)
    {
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        //
        //  hLNDEvent will always be valid since we have loaded ourself
        //  and FreeLibrary will not produce a DLL_PROCESS_DETACH.
        //
        WaitForSingleObject(hLNDEvent, INFINITE);

        //
        //  In case this is the exit event.
        //
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        EnableDiskInfo(FALSE, FALSE);
       
        if (bInit)
        {
            GetNetDrives(RESOURCE_REMEMBERED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            bInit = FALSE;
        }
        else
        {
            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }
        }

        ResetEvent(hLNDEvent);
    }

LNDExitThread:

    bLNDExit = FALSE;       
    LeaveCriticalSection(&g_csNetThread);

LNDExitThread1:

    FreeLibraryAndExitThread(g_hinst, 1);

    //
    //  The ExitThread is implicit in this return.
    //
    return;
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadDrives
//
//  Lists the current drives (connected) in the combo box.
//
////////////////////////////////////////////////////////////////////////////

VOID LoadDrives(
    HWND hDlg)
{
    //
    //  Hard-code this - It's internal && always cmb2/psh14.
    //
    HWND hCmb = GetDlgItem(hDlg, cmb2);
    DWORD dwThreadID;
    LPCURDLG lpCurDlg;
    BOOL bFirstAttach = FALSE;
    WORD wCurDrive;
    TCHAR szDrive[5];
    
    if (!hLNDEvent)
    {
        //
        //  Don't check if this succeeds since we can run without the net.
        //
        hLNDEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        bFirstAttach = TRUE;
    }
    else
    {
        //
        //  Assume all previous connections (except unc) are valid
        //  for first display - but only when they exist.
        //
        EnableDiskInfo(TRUE, FALSE);
    }

    //
    //  Set the hDlg into the refresh array before initially
    //  creating the thread so that the worker thread can hide/disable
    //  the net button in the event that there is no network.
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    // sanity check
    if (!lpCurDlg)
    {
        return;
    }

    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

    //
    //  If there is no worker thread for network disk enumeration,
    //  start up here rather than in the dll, since it's only
    //  for the fileopen dlg.
    //
    //  Always start a thread if the number of active fileopen dialogs
    //  goes from 0 to 1
    //
    if ((lpCurDlg->dwCurDlgNum == 0) && (!hLNDThread))
    {
        if (hLNDEvent && (bNetworkInstalled = IsNetworkInstalled()))
        {
            TCHAR szModule[MAX_PATH];

            //
            //  Do this once when dialog thread count goes from 0 to 1.
            //
            GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule));
            if (LoadLibrary(szModule))
            {
                hLNDThread = CreateThread(
                                   NULL,
                                   (DWORD)0,
                                   (LPTHREAD_START_ROUTINE)ListNetDrivesHandler,
                                   (LPVOID)NULL,
                                   (DWORD_PTR)NULL,
                                   &dwThreadID );
            }
        }
        else
        {
            HWND hNet = GetDlgItem(hDlg, psh14);

            EnableWindow(hNet, FALSE);
            ShowWindow(hNet, SW_HIDE);
        }
    }

    // Fix for Millenium BUG #113035
    // Putting the get drives information code instead of in the 
    // ListNetDriveHandler thread.
    

    //
    //  Get the drive information for all drives.
    //
    //  NOTE: If we don't redo all volume info, then a change in a volume
    //        label will never be caught by wow apps unless wowexec is
    //        killed and restarted.  Therefore, information for all drives
    //        should be retrieved here.
    //
    for (wCurDrive = 0; wCurDrive <= 25; wCurDrive++)
    {
        szDrive[0] = (CHAR_A + (TCHAR)wCurDrive);
        szDrive[1] = CHAR_COLON;
        szDrive[2] = CHAR_BSLASH;
        szDrive[3] = CHAR_NULL;

        UpdateLocalDrive(szDrive, FALSE);
    }
    
    FlushDiskInfoToCmb2();

    //
    //  Now invalidate all net conns and re-enum, but only if there is
    //  indeed a worker thread too.
    //
    if (!bFirstAttach)
    {
        EnableDiskInfo(FALSE, FALSE);
    }
    
    LNDSetEvent(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskIndex
//
////////////////////////////////////////////////////////////////////////////

DWORD GetDiskIndex(
    DWORD dwDriveType)
{
    if (dwDriveType == 1)
    {
        //
        //  Drive doesn't exist!
        //
        return (0);
    }
    else if (dwDriveType == DRIVE_CDROM)
    {
        return (CDDRVBMP);
    }
    else if (dwDriveType == DRIVE_REMOVABLE)
    {
        return (FLOPPYBMP);
    }
    else if (dwDriveType == DRIVE_REMOTE)
    {
        return (NETDRVBMP);
    }
    else if (dwDriveType == DRIVE_RAMDISK)
    {
        return (RAMDRVBMP);
    }

    return (HARDDRVBMP);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpFile
//
//  This releases the memory used by the system dialog bitmaps.
//
////////////////////////////////////////////////////////////////////////////

VOID CleanUpFile()
{
    //
    //  Check if anyone else is around.
    //
    if (--cLock)
    {
        return;
    }

    //
    //  Select the null bitmap into our memory DC so that the
    //  DirDrive bitmap can be discarded.
    //
    SelectObject(hdcMemory, hbmpOrigMemBmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenAbort
//
////////////////////////////////////////////////////////////////////////////

VOID FileOpenAbort()
{
    LPCURDLG lpCurDlg;


    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if (lpCurDlg)
    {
        EnterCriticalSection(&g_csLocal);

        if (dwNumDlgs > 0)
        {
            dwNumDlgs--;
        }

        if (dwNumDlgs == 0)
        {
            //
            //  If there are no more fileopen dialogs for this process,
            //  then signal the worker thread it's all over.
            //
            if (hLNDEvent && hLNDThread)
            {
                bLNDExit = TRUE;
                SetEvent(hLNDEvent);

                CloseHandle(hLNDThread);
                hLNDThread = NULL;
            }
        }

        LeaveCriticalSection(&g_csLocal);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TermFile
//
////////////////////////////////////////////////////////////////////////////

VOID TermFile()
{
    vDeleteDirDriveBitmap();
    if (hdcMemory)
    {
        DeleteDC(hdcMemory);
    }

    if (hLNDEvent)
    {
        CloseHandle(hLNDEvent);
        hLNDEvent = NULL;
    }

    if (gpcNetEnumBuf)
    {
        LocalFree(gpcNetEnumBuf);
    }

    while (dwNumDisks)
    {
        dwNumDisks--;
        if (gaDiskInfo[dwNumDisks].lpAbbrName)
        {
            LocalFree(gaDiskInfo[dwNumDisks].lpAbbrName);
        }
    }
}






/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2WDelayed
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkOpenFileNameA2WDelayed(
    POPENFILEINFO pOFI)
{
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        DWORD cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);

        if (pOFNW->lpstrDefExt)
        {
            LocalFree((HLOCAL)pOFNW->lpstrDefExt);
        }
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return;
        }
        else
        {
            if (pOFNA->lpstrDefExt)
            {
                SHAnsiToUnicode(pOFNA->lpstrDefExt,(LPWSTR)pOFNW->lpstrDefExt,cbLen );
            }
        }
    }

    //
    //  Need to thunk back to A value since Claris Filemaker side effects
    //  this in an ID_OK subclass without hooking at the very last moment.
    //  Do an |= instead of an = to preserve internal flags.
    //
    pOFNW->Flags &= OFN_ALL_INTERNAL_FLAGS;
    pOFNW->Flags |= pOFNA->Flags;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2W
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameA2W(
    POPENFILEINFO pOFI)
{
    int    nRet;


    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    pOFNW->Flags = pOFNA->Flags;
    pOFNW->lCustData = pOFNA->lCustData;

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if ((pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW)) 
       )
    {
        pOFNW->pvReserved = pOFNA->pvReserved ;
        pOFNW->dwReserved = pOFNA->dwReserved;
        pOFNW->FlagsEx   = pOFNA->FlagsEx;
    }

    //
    //  Various WOW apps change the strings and *ptrs* to the strings in the
    //  OPENFILENAME struct while processing messages with their hook procs.
    //  Handle that silliness here.  (We probably don't want to promote this
    //  beyond WOW).
    //
    if (pOFNA->Flags & CD_WOWAPP)
    {
        pOFNW->lpstrFilter = (LPCWSTR)
                       ThunkMultiANSIStrToWIDE( (LPWSTR)pOFNW->lpstrFilter,
                                                (LPSTR)pOFNA->lpstrFilter,
                                                0 );

        pOFNW->lpstrCustomFilter =
                       ThunkMultiANSIStrToWIDE( pOFNW->lpstrCustomFilter,
                                                pOFNA->lpstrCustomFilter,
                                                pOFNA->nMaxCustFilter );

        pOFNW->lpstrFile =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFile,
                                           pOFNA->lpstrFile,
                                           pOFNA->nMaxFile );

        pOFNW->lpstrFileTitle =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFileTitle,
                                           pOFNA->lpstrFileTitle,
                                           pOFNA->nMaxFileTitle );

        pOFNW->lpstrInitialDir = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrInitialDir,
                                           (LPSTR)pOFNA->lpstrInitialDir,
                                           0 );

        pOFNW->lpstrTitle = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrTitle,
                                           (LPSTR)pOFNA->lpstrTitle,
                                           0 );

        pOFNW->lpstrDefExt = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrDefExt,
                                           (LPSTR)pOFNA->lpstrDefExt,
                                           0 );

        pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        pOFNW->nMaxFile       = pOFNA->nMaxFile;
        pOFNW->nMaxFileTitle  = pOFNA->nMaxFileTitle;
        pOFNW->nFileOffset    = pOFNA->nFileOffset;
        pOFNW->nFileExtension = pOFNA->nFileExtension;
    }
    else
    {
        if (pOFNW->lpstrFile)
        {
            if (pOFNA->lpstrFile)
            {
                nRet = SHAnsiToUnicode(pOFNA->lpstrFile,pOFNW->lpstrFile,pOFNW->nMaxFile );
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrFileTitle && pOFNW->nMaxFileTitle)
        {
            if (pOFNA->lpstrFileTitle)
            {
                nRet= MultiByteToWideChar(CP_ACP,
                              0,
                              pOFNA->lpstrFileTitle,
                              pOFNA->nMaxFileTitle,
                              pOFNW->lpstrFileTitle,
                              pOFNW->nMaxFileTitle);
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrCustomFilter)
        {
            if (pOFI->pasCustomFilter)
            {
                LPSTR psz = pOFI->pasCustomFilter->Buffer;
                DWORD cch = 0;

                if (*psz || *(psz + 1))
                {
                    cch = 2;
                    while (*psz || *(psz + 1))
                    {
                        psz++;
                        cch++;
                    }
                }

                if (cch)
                {
                    pOFI->pasCustomFilter->Length = cch;

                    nRet = MultiByteToWideChar(CP_ACP,
                                    0,
                                    pOFI->pasCustomFilter->Buffer,
                                    pOFI->pasCustomFilter->Length,
                                    pOFI->pusCustomFilter->Buffer,
                                    pOFI->pusCustomFilter->MaximumLength );
                    if (nRet == 0)
                    {
                        return (FALSE);
                    }
                }
            }
        }
    }

    pOFNW->nFilterIndex = pOFNA->nFilterIndex;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameW2A
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameW2A(
    POPENFILEINFO pOFI)
{
    int nRet;

    LPOPENFILENAMEW pOFNW = pOFI->pOFN;
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPWSTR pszW;
    USHORT cch;

    //
    //  Supposedly invariant, but not necessarily.
    //    Definition: invariant - changed by 16-bit apps frequently
    //
    pOFNA->Flags = pOFNW->Flags;
    pOFNA->lCustData = pOFNW->lCustData;
    
    // this way we can assert that we are covered.
    DEBUG_CODE(pOFNA->nFileOffset = 0 );

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if (pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW) 
       )
    {
        pOFNA->pvReserved = pOFNW->pvReserved;
        pOFNA->dwReserved = pOFNW->dwReserved;
        pOFNA->FlagsEx   = pOFNW->FlagsEx;
    }


    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        nRet = SHUnicodeToAnsi(pOFNW->lpstrFileTitle,pOFNA->lpstrFileTitle,pOFNA->nMaxFileTitle);

        if (nRet == 0)
        {
            return (FALSE);
        }
    }

    if (pOFNA->lpstrCustomFilter)
    {
        pszW = pOFI->pusCustomFilter->Buffer;

        cch = 0;
        if (*pszW || *(pszW + 1))
        {
            cch = 2;
            while (*pszW || *(pszW + 1))
            {
                pszW++;
                cch++;
            }
        }

        if (cch)
        {
            pOFI->pusCustomFilter->Length = cch;
            nRet = WideCharToMultiByte(CP_ACP,
                                0,
                                pOFI->pusCustomFilter->Buffer,
                                pOFI->pusCustomFilter->Length,
                                pOFI->pasCustomFilter->Buffer,
                                pOFI->pasCustomFilter->MaximumLength,
                                NULL,
                                NULL);
            if (nRet == 0)
            {
                return (FALSE);
            }
        }
    }

    pOFNA->nFilterIndex   = pOFNW->nFilterIndex;

    if (pOFNA->lpstrFile && pOFNW->lpstrFile)
    {
        if (GetStoredExtendedError() == FNERR_BUFFERTOOSMALL)
        {
            //
            //  In the case where the lpstrFile buffer is too small,
            //  lpstrFile contains the size of the buffer needed for
            //  the string rather than the string itself.
            //
            pszW = pOFNW->lpstrFile;
            switch (pOFNA->nMaxFile)
            {
                case ( 3 ) :
                default :
                {
                    pOFNA->lpstrFile[2] = CHAR_NULL;

                    // fall thru...
                }
                case ( 2 ) :
                {
                    pOFNA->lpstrFile[1] = HIBYTE(*pszW);

                    // fall thru...
                }
                case ( 1 ) :
                {
                    pOFNA->lpstrFile[0] = LOBYTE(*pszW);

                    // fall thru...
                }
                case ( 0 ) :
                {
                    break;
                }
            }
        }
        else
        {
            LPWSTR pFileW = pOFNW->lpstrFile;
            DWORD cchFile = 0;

            // Find the length of string to be converted. This takes care of both single select (there will be only string)
            // and multiselect case (there will multiple strings with double null termination)
            while (*pFileW)
            {
                DWORD cch = lstrlenW(pFileW) +1;
                cchFile +=cch;
                pFileW += cch;
            }

            if (pOFNW->Flags & OFN_ALLOWMULTISELECT)
            {
                // for the double null terminator
                cchFile++;
            }
              
            // need to copy the whole buffer after the initial directory
            nRet = WideCharToMultiByte(CP_ACP,
                          0,
                          pOFNW->lpstrFile, cchFile,
                          pOFNA->lpstrFile, pOFNA->nMaxFile,
                          NULL, NULL);

            if (nRet == 0)
            {
                return (FALSE);
            }

            if ((SHORT)pOFNW->nFileOffset > 0)
            {
                pOFNA->nFileOffset = (WORD) WideCharToMultiByte( CP_ACP,
                                                                 0,
                                                                 pOFNW->lpstrFile,
                                                                 pOFNW->nFileOffset,
                                                                 NULL,
                                                                 0,
                                                                 NULL,
                                                                 NULL );
            }
            else
            {
                pOFNA->nFileOffset = pOFNW->nFileOffset;
            }

            if ((SHORT)pOFNW->nFileExtension > 0)
            {
                pOFNA->nFileExtension = (WORD) WideCharToMultiByte( CP_ACP,
                                                                    0,
                                                                    pOFNW->lpstrFile,
                                                                    pOFNW->nFileExtension,
                                                                    NULL,
                                                                    0,
                                                                    NULL,
                                                                    NULL );
            }
            else
            {
                pOFNA->nFileExtension = pOFNW->nFileExtension;    
            }
        }
    }
    else
    {
        pOFNA->nFileOffset    = pOFNW->nFileOffset;
        pOFNA->nFileExtension = pOFNW->nFileExtension;

    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GenericGetFileNameA
//
////////////////////////////////////////////////////////////////////////////

BOOL GenericGetFileNameA(
    LPOPENFILENAMEA pOFNA,
    DLGPROC qfnDlgProc)
{
    LPOPENFILENAMEW pOFNW;
    BOOL bRet = FALSE;
    OFN_UNICODE_STRING usCustomFilter;
    OFN_ANSI_STRING asCustomFilter;
    DWORD cbLen;
    LPSTR pszA;
    DWORD cch;
    LPBYTE pStrMem = NULL;
    OPENFILEINFO OFI = {0};
        
    if (!pOFNA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

     //Set the Open File Version
    OFI.iVersion = OPENFILEVERSION;

    if (pOFNA->lStructSize == OPENFILENAME_SIZE_VERSION_400)
    {
        OFI.iVersion = OPENFILEVERSION_NT4;
    }

    //  we allow both sizes because we allocate a full size one anyway
    //  and we want to preserve the original structure for notifies
    if ((pOFNA->lStructSize != OPENFILENAME_SIZE_VERSION_400) &&
        (pOFNA->lStructSize != sizeof(OPENFILENAMEA))
       )
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pOFNW = (LPOPENFILENAMEW)LocalAlloc(LPTR, sizeof(OPENFILENAMEW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  Constant stuff.
    //
    pOFNW->lStructSize = sizeof(OPENFILENAMEW);
    pOFNW->hwndOwner = pOFNA->hwndOwner;
    pOFNW->hInstance = pOFNA->hInstance;
    pOFNW->lpfnHook = pOFNA->lpfnHook;

    //  it will always be a valid structsize at this point
    if (pOFNA->lStructSize != OPENFILENAME_SIZE_VERSION_400)
    {
        pOFNW->pvReserved = pOFNA->pvReserved;
        pOFNW->dwReserved = pOFNA->dwReserved;
        pOFNW->FlagsEx   = pOFNA->FlagsEx;
    }

    //
    //  Init TemplateName constant.
    //
    if (pOFNA->Flags & OFN_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pOFNA->lpTemplateName))
        {
            cbLen = lstrlenA(pOFNA->lpTemplateName) + 1;
            if (!(pOFNW->lpTemplateName = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                goto GenericExit;
            }
            else
            {
                SHAnsiToUnicode(pOFNA->lpTemplateName,(LPWSTR)pOFNW->lpTemplateName,cbLen);
            }
        }
        else
        {
            (DWORD_PTR)pOFNW->lpTemplateName = (DWORD_PTR)pOFNA->lpTemplateName;
        }
    }
    else
    {
        pOFNW->lpTemplateName = NULL;
    }

    //
    //  Initialize Initial Dir constant.
    //
    if (pOFNA->lpstrInitialDir)
    {
        cbLen = lstrlenA(pOFNA->lpstrInitialDir) + 1;
        if (!(pOFNW->lpstrInitialDir = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrInitialDir,(LPWSTR)pOFNW->lpstrInitialDir,cbLen);
        }
    }
    else
    {
        pOFNW->lpstrInitialDir = NULL;
    }

    //
    //  Initialize Title constant.
    //
    if (pOFNA->lpstrTitle)
    {
        cbLen = lstrlenA(pOFNA->lpstrTitle) + 1;
        if (!(pOFNW->lpstrTitle = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrTitle,(LPWSTR)pOFNW->lpstrTitle,cbLen );
        }
    }
    else
    {
        pOFNW->lpstrTitle = NULL;
    }

    //
    //  Initialize Def Ext constant.
    //
    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            SHAnsiToUnicode(pOFNA->lpstrDefExt,(LPWSTR)pOFNW->lpstrDefExt,cbLen );
        }
    }
    else
    {
        pOFNW->lpstrDefExt = NULL;
    }

    //
    //  Initialize Filter constant.  Note: 16-bit apps change this.
    //
    if (pOFNA->lpstrFilter)
    {
        pszA = (LPSTR)pOFNA->lpstrFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            //
            //  Pick up trailing nulls.
            //
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  Need to do cch + 1 in the Local Alloc rather than just cch.
        //  This is to make sure there is at least one extra null in the
        //  string so that if a filter does not have the second part of
        //  the pair, three nulls will be placed in the wide string.
        //
        //  Example:  "Print File (*.prn)\0\0\0"
        //
        if (!(pOFNW->lpstrFilter = (LPWSTR)LocalAlloc(LPTR, ((cch + 1) * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar(CP_ACP,
                     0,
                     pOFNA->lpstrFilter,
                     cch,
                     (LPWSTR)pOFNW->lpstrFilter, 
                     cch);
        }
    }
    else
    {
        pOFNW->lpstrFilter = NULL;
    }

    //
    //  Initialize File strings.
    //
    if (pOFNA->lpstrFile)
    {
        if (pOFNA->nMaxFile <= (DWORD)lstrlenA(pOFNA->lpstrFile))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            goto GenericExit;
        }
        pOFNW->nMaxFile = pOFNA->nMaxFile;

        if (!(pOFNW->lpstrFile = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFile * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFile = 0;
        pOFNW->lpstrFile = NULL;
    }

    //
    //  Initialize File Title strings.
    //
    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        //
        //  Calculate length of lpstrFileTitle.
        //
        pszA = pOFNA->lpstrFileTitle;
        cch = 0;
        try
        {
            while (*pszA++)
            {
                cch++;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            if (cch)
            {
                cch--;
            }
            (pOFNA->lpstrFileTitle)[cch] = CHAR_NULL;
        }

        if (pOFNA->nMaxFileTitle < cch)
        {
            //
            //  Override the incorrect length from the app.
            //  Make room for the null.
            //
            pOFNW->nMaxFileTitle = cch + 1;
        }
        else
        {
            pOFNW->nMaxFileTitle = pOFNA->nMaxFileTitle;
        }

        if (!(pOFNW->lpstrFileTitle = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFileTitle * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFileTitle = 0;
        pOFNW->lpstrFileTitle = NULL;
    }

    //
    //  Initialize custom filter strings.
    //
    if ((asCustomFilter.Buffer = pOFNA->lpstrCustomFilter))
    {
        pszA = pOFNA->lpstrCustomFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  JVert-inspired-wow-compatibility-hack-to-make-vbasic2.0-makeexe
        //  save-as-dialog-box-work-even-though-they-didn't-fill-in-
        //  the-whole-structure(nMaxCustFilter)-according-to-winhelp-spec fix
        //
        if (!(pOFNA->Flags & OFN_NOLONGNAMES))
        {
            if (((DWORD)cch >= pOFNA->nMaxCustFilter) ||
                (pOFNA->nMaxCustFilter < 40))
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
            asCustomFilter.Length = cch;
            asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
            pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        }
        else
        {
            asCustomFilter.Length = cch;
            if (pOFNA->nMaxCustFilter < cch)
            {
                asCustomFilter.MaximumLength = cch;
                pOFNW->nMaxCustFilter = cch;
            }
            else
            {
                asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
                pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
            }
        }
        usCustomFilter.MaximumLength = (asCustomFilter.MaximumLength + 1) * sizeof(WCHAR);
        usCustomFilter.Length = asCustomFilter.Length * sizeof(WCHAR);
    }
    else
    {
        pOFNW->nMaxCustFilter = usCustomFilter.MaximumLength = 0;
        pOFNW->lpstrCustomFilter = NULL;
    }

    if (usCustomFilter.MaximumLength > 0)
    {
        if (!(pStrMem = (LPBYTE)LocalAlloc(LPTR, usCustomFilter.MaximumLength)))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            pOFNW->lpstrCustomFilter = usCustomFilter.Buffer = (LPWSTR)pStrMem;
        }
    }
    else
    {
        pStrMem = NULL;
    }

    OFI.pOFN = pOFNW;
    OFI.pOFNA = pOFNA;
    OFI.pasCustomFilter = &asCustomFilter;
    OFI.pusCustomFilter = &usCustomFilter;
    OFI.ApiType = COMDLG_ANSI;

    //
    //  The following should always succeed.
    //
    if (!ThunkOpenFileNameA2W(&OFI))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        goto GenericExit;
    }

    bRet = GetFileName(&OFI, qfnDlgProc);
    if (g_bUserPressedCancel == FALSE)
    {
        ThunkOpenFileNameW2A(&OFI);
    }

GenericExit:

    if (pStrMem)
    {
        LocalFree(pStrMem);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFile))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFile);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFileTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFileTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFilter))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFilter);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrDefExt))
    {
        LocalFree((HLOCAL)pOFNW->lpstrDefExt);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrInitialDir))
    {
        LocalFree((HLOCAL)pOFNW->lpstrInitialDir);
    }

    if (!IS_INTRESOURCE(pOFNW->lpTemplateName))
    {
        LocalFree((HLOCAL)pOFNW->lpTemplateName);
    }

    LocalFree(pOFNW);

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strlenA
//
//  This is a strlen for ANSI string lists that have several strings that
//  are *separated* by a NULL char and are *terminated* by two NULL chars.
//
//  Returns length of string including all NULL *separators* but not the
//  2nd NULL *terminator*.  (ie. cat0dog00 would return length = 8)
//
////////////////////////////////////////////////////////////////////////////

int Multi_strlenA(
    LPCSTR str)
{
    int ctr = 0;

    if (str)
    {
        while (*str)
        {
            while (*str++)
            {
                ctr++;
            }
            ctr++;                // count the NULL separator
        }
    }

    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strcpyAtoW
//
//  This is a strcpy for string lists that have several strings that are
//  *separated* by a NULL char and are *terminated* by two NULL chars.
//  Returns FALSE if:
//    1. the wide buffer is determined to be too small
//    2. the ptr to either buffer is NULL
//  Returns TRUE if the copy was successful.
//
////////////////////////////////////////////////////////////////////////////

BOOL Multi_strcpyAtoW(
    LPWSTR pDestW,
    LPCSTR pSrcA,
    int cChars)
{
    int off = 0;
    int cb;

    if (!pSrcA || !pDestW)
    {
        return (FALSE);
    }

    cChars = max(cChars, (Multi_strlenA(pSrcA) + 1));

    if (LocalSize((HLOCAL)pDestW) < (cChars * sizeof(WCHAR)))
    {
        return (FALSE);
    }

    while (*pSrcA)
    {
        cb = lstrlenA(pSrcA) + 1;

        off += MultiByteToWideChar(CP_ACP,0,pSrcA,cb,pDestW + off, cb);
        pSrcA += cb;
    }

    pDestW[off] = L'\0';

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkMultiANSIStrToWIDE
//
//  Thunks an ANSI multi-string (a list of NULL *separated* strings with
//  two NULLs *terminating* the list) to the equivalent WIDE multi-string.
//
//  Note: If the original wide buffer is too small to contain the new list,
//        it will be free'd and a new wide buffer will be allocated.  If a
//        new wide buffer can't be allocated, the ptr to the original wide
//        buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkMultiANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    int size;
    HLOCAL hBufW;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    //
    //  First try to copy to the existing wide buffer since most of the time
    //  there will be no change to the buffer ptr anyway.
    //
    if (!(Multi_strcpyAtoW(pDestW, pSrcA, cChars)))
    {
        //
        //  If the wide buffer is too small (or NULL or invalid), allocate
        //  a bigger buffer.
        //
        size = max(cChars, (Multi_strlenA(pSrcA) + 1));
        cChars = size;

        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if ((Multi_strcpyAtoW((LPWSTR)hBufW, pSrcA, cChars)))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }

    return (pDestW);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkANSIStrToWIDE
//
//  Thunks an ANSI string to WIDE.
//
//  Note: If the original wide buffer is too small to contain the new
//        string, it will be free'd and a new wide buffer will be allocated.
//        If a new wide buffer can't be allocated, the ptr to the original
//        wide buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    HLOCAL hBufW;
    int size;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    size = max(cChars, (lstrlenA(pSrcA) + 1));
    cChars = size;

    //
    //  If the wide buffer is too small (or NULL or invalid), allocate a
    //  bigger buffer.
    //
    if (LocalSize((HLOCAL)pDestW) < (size * sizeof(WCHAR)))
    {
        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if (SHAnsiToUnicode(pSrcA,(LPWSTR)hBufW,cChars ))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }
    else
    {
        //
        //  Just use the original wide buffer.
        //
        SHAnsiToUnicode(pSrcA,pDestW, cChars);
    }

    return (pDestW);
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_OFN_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the OPENFILENAME structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_OFN_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    POPENFILEINFO pOFI;

    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN && pOFI->pOFNA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkOpenFileNameA2W(pOFI);
            }
            else
            {
                ThunkOpenFileNameW2A(pOFI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\find.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    find.c

Abstract:

    This module implements the Win32 find dialog.

Revision History:

--*/


// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "find.h"
#include "util.h"

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  FindTextA
//
//  ANSI entry point for FindText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_FIND, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  FindTextW
//
//  Stub UNICODE function for FindText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  FindText
//
//  The FindText function creates a system-defined modeless dialog box
//  that enables the user to find text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_FIND, COMDLG_WIDE) );
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextA
//
//  ANSI entry point for ReplaceText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_REPLACE, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextW
//
//  Stub UNICODE function for ReplaceText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  ReplaceText
//
//  The ReplaceText function creates a system-defined modeless dialog box
//  that enables the user to find and replace text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_REPLACE, COMDLG_WIDE) );
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFindReplaceDlg
//
//  Creates FindText modeless dialog.
//
//  pFR     - ptr to FINDREPLACE structure set up by user
//  DlgType - type of dialog to create (DLGT_FIND, DLGT_REPLACE)
//  ApiType - type of FINDREPLACE ptr (COMDLG_ANSI or COMDLG_WIDE)
//
//  Returns   success => HANDLE to created dlg
//            failure => HNULL = ((HANDLE) 0)
//
////////////////////////////////////////////////////////////////////////////

HWND CreateFindReplaceDlg(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HWND hWndDlg;                      // handle to created modeless dialog
    HANDLE hDlgTemplate;               // handle to loaded dialog resource
    LPCDLGTEMPLATE lpDlgTemplate;      // pointer to loaded resource block
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif

    if (!pFR)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (!SetupOK(pFR, DlgType, ApiType))
    {
        return (HNULL);
    }

    if (!(hDlgTemplate = GetDlgTemplate(pFR, DlgType, ApiType)))
    {
        return (FALSE);
    }

    if (lpDlgTemplate = (LPCDLGTEMPLATE)LockResource(hDlgTemplate))
    {
        PFINDREPLACEINFO pFRI;

        if (pFRI = (PFINDREPLACEINFO)LocalAlloc(LPTR, sizeof(FINDREPLACEINFO)))
        {
            //
            //  CLEAR extended error on new instantiation.
            //
            StoreExtendedError(0);

            if (pFR->Flags & FR_ENABLEHOOK)
            {
                glpfnFindHook = GETHOOKFN(pFR);
            }

            pFRI->pFR = pFR;
            pFRI->ApiType = ApiType;
            pFRI->DlgType = DlgType;

#ifdef UNICODE
            if (IS16BITWOWAPP(pFR))
            {
                uiWOWFlag = SCDLG_16BIT;
            }

            hWndDlg = CreateDialogIndirectParamAorW( g_hinst,
                                                     lpDlgTemplate,
                                                     pFR->hwndOwner,
                                                     FindReplaceDlgProc,
                                                     (LPARAM)pFRI,
                                                     uiWOWFlag );
#else
            hWndDlg = CreateDialogIndirectParam( g_hinst,
                                                 lpDlgTemplate,
                                                 pFR->hwndOwner,
                                                 FindReplaceDlgProc,
                                                 (LPARAM)pFRI );
#endif
            if (!hWndDlg)
            {
                glpfnFindHook = 0;
                LocalFree(pFRI);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (NULL);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
        return (HNULL);
    }

    return (hWndDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetupOK
//
//  Checks setup for unmet preconditions.
//
//  pFR       ptr to FINDREPLACE structure
//  DlgType   dialog type (either FIND or REPLACE)
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   TRUE   - success
//            FALSE  - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL SetupOK(
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    //
    //  Sanity
    //
    if (!pFR)
    {
        return (FALSE);
    }

    if (pFR->lStructSize != sizeof(FINDREPLACE))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  Verify window handle and text pointers.
    //
    if (!IsWindow(pFR->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    if (!pFR->lpstrFindWhat ||
        ((DlgType == DLGT_REPLACE) && !pFR->lpstrReplaceWith) ||
        !pFR->wFindWhatLen)
    {
        StoreExtendedError(FRERR_BUFFERLENGTHZERO);
        return (FALSE);
    }

    //
    //  Verify lpfnHook has a ptr if ENABLED.
    //
    if (pFR->Flags & FR_ENABLEHOOK)
    {
        if (!pFR->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pFR->lpfnHook = 0;
    }

    //
    // Get LangID 
    //
    if (
        !(pFR->Flags & FR_ENABLETEMPLATE) &&
        !(pFR->Flags & FR_ENABLETEMPLATEHANDLE) )
    {
        LangID = GetDialogLanguage(pFR->hwndOwner, NULL);
    }

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) LangID);

    //
    //  Load "CLOSE" text for Replace.
    //
    if ((DlgType == DLGT_REPLACE) &&
        !CDLoadString(g_hinst, iszClose, (LPTSTR)szClose, CCHCLOSE))
    {
        StoreExtendedError(CDERR_LOADSTRFAILURE);
        return (FALSE);
    }


    //
    //  Setup unique msg# for talking to hwndOwner.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        if (!(wFRMessage = RegisterWindowMessageA((LPCSTR)FINDMSGSTRINGA)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }
    else
#endif
    {
        if (!(wFRMessage = RegisterWindowMessage((LPCTSTR)FINDMSGSTRING)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDlgTemplate
//
//  Finds and loads the dialog template.
//
//  pFR       ptr to FINDREPLACE structure
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   handle to dialog template   - success
//            HNULL = ((HANDLE) 0)        - failure
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetDlgTemplate(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HANDLE hRes;                 // handle of res. block with dialog
    HANDLE hDlgTemplate;         // handle to loaded dialog resource
    LANGID LangID;

    if (pFR->Flags & FR_ENABLETEMPLATE)
    {
        //
        //  Find/Load TEMP NAME and INSTANCE from pFR.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            hRes = FindResourceA( (HMODULE)pFR->hInstance,
                                  (LPCSTR)pFR->lpTemplateName,
                                  (LPCSTR)RT_DIALOG );
        }
        else
#endif
        {
            hRes = FindResource( pFR->hInstance,
                                 (LPCTSTR)pFR->lpTemplateName,
                                 (LPCTSTR)RT_DIALOG );
        }
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(pFR->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }
    else if (pFR->Flags & FR_ENABLETEMPLATEHANDLE)
    {
        //
        //  Get whole PRELOADED resource handle from user.
        //
        if (!(hDlgTemplate = pFR->hInstance))
        {
            StoreExtendedError(CDERR_NOHINSTANCE);
            return (HNULL);
        }
    }
    else
    {
        //
        //  Get STANDARD dialog from DLL instance block.
        //
        LangID = (LANGID) TlsGetValue(g_tlsLangID);

        if (DlgType == DLGT_FIND)
        {
            hRes = FindResourceExFallback( g_hinst,
                                   RT_DIALOG, 
                                   MAKEINTRESOURCE(FINDDLGORD),
                                   LangID);
        }
        else
        {
            hRes = FindResourceExFallback( g_hinst,
                                   RT_DIALOG, 
                                   MAKEINTRESOURCE(REPLACEDLGORD),
                                   LangID);
        }

        //
        //  !!!!!  definitely ORD here?
        //
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }

    return (hDlgTemplate);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindReplaceDlgProc
//
//  Handles messages to FindText/ReplaceText dialogs.
//
//  hDlg   -  handle to dialog
//  wMsg   -  window message
//  wParam -  w parameter of message
//  lParam -  l parameter of message
//
//  Note: lparam contains ptr to FINDREPLACEINITPROC upon
//        initialization from CreateDialogIndirectParam...
//
//  Returns:   TRUE (or dlg fcn return vals) - success
//             FALSE                         - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FindReplaceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PFINDREPLACEINFO pFRI;
    LPFINDREPLACE pFR;
    BOOL_PTR bRet;

    //
    //  If a hook exists, let hook function do procing.
    //
    if (pFRI = (PFINDREPLACEINFO)GetProp(hDlg, FINDREPLACEPROP))
    {
        if ((pFR = (LPFINDREPLACE)pFRI->pFR) &&
            (pFR->Flags & FR_ENABLEHOOK))
        {
            LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

            if ((bRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam)))
            {
                return (bRet);
            }
        }
    }
    else if (glpfnFindHook &&
             (wMsg != WM_INITDIALOG) &&
             (bRet = (* glpfnFindHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bRet);
    }

    //
    //  Dispatch MSG to appropriate HANDLER.
    //
    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Set Up P-Slot.
            //
            pFRI = (PFINDREPLACEINFO)lParam;
            SetProp(hDlg, FINDREPLACEPROP, (HANDLE)pFRI);

            glpfnFindHook = 0;

            //
            //  Init dlg controls accordingly.
            //
            pFR = pFRI->pFR;
            InitControlsWithFlags(hDlg, pFR, pFRI->DlgType, pFRI->ApiType);

            //
            //  If Hook function, do extra processing.
            //
            if (pFR->Flags & FR_ENABLEHOOK)
            {
                LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

                bRet = (*lpfnHook)(hDlg, wMsg, wParam, (LPARAM)pFR);
            }
            else
            {
                bRet = TRUE;
            }

            if (bRet)
            {
                //
                //  If the hook function returns FALSE, then we must call
                //  these functions here.
                //
                ShowWindow(hDlg, SW_SHOWNORMAL);
                UpdateWindow(hDlg);
            }

            return (bRet);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pFRI || !pFR)
            {
                return (FALSE);
            }

            switch (GET_WM_COMMAND_ID (wParam, lParam))
            {
                //
                //  FIND NEXT button clicked.
                //
                case ( IDOK ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        FR_FINDNEXT,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    NotifyUpdateTextAndFlags(pFR);
                    break;
                }
                case ( IDCANCEL ) :
                case ( IDABORT ) :
                {
                    EndDlgSession(hDlg, pFR);
                    LocalFree(pFRI);
                    break;
                }
                case ( psh1 ) :
                case ( psh2 ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        (wParam == psh1)
                                            ? FR_REPLACE
                                            : FR_REPLACEALL,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    if (NotifyUpdateTextAndFlags(pFR) == TRUE)
                    {
                        //
                        //  Change <Cancel> button to <Close> if function
                        //  returns TRUE.
                        //  IDCANCEL instead of psh1.
                        SetWindowText( GetDlgItem(hDlg, IDCANCEL),
                                       (LPTSTR)szClose );
                    }
                    break;
                }
                case ( pshHelp ) :
                {
                    //
                    //  Call HELP app.
                    //
#ifdef UNICODE
                    if (pFRI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    break;
                }
                case ( edt1 ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        BOOL fAnythingToFind =
                            (BOOL)SendDlgItemMessage( hDlg,
                                                      edt1,
                                                      WM_GETTEXTLENGTH,
                                                      0,
                                                      0L );
                        EnableWindow(GetDlgItem(hDlg, IDOK), fAnythingToFind);
                        if (pFRI->DlgType == DLGT_REPLACE)
                        {
                            EnableWindow(GetDlgItem(hDlg, psh1), fAnythingToFind);
                            EnableWindow(GetDlgItem(hDlg, psh2), fAnythingToFind);
                        }
                    }

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK),
                                      (BOOL)SendDlgItemMessage(
                                                   hDlg,
                                                   edt1,
                                                   WM_GETTEXTLENGTH,
                                                   0,
                                                   0L ));
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CLOSE ) :
        {
            SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDCANCEL, 0, 0));
            return (TRUE);
            break;
        }
        default:
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EndDlgSession
//
//  Cleans up upon destroying the dialog.
//
////////////////////////////////////////////////////////////////////////////

VOID EndDlgSession(
   HWND hDlg,
   LPFINDREPLACE pFR)
{
    //
    //  Need to terminate regardless of app testing order ... so:
    //

    //
    //  No SUCCESS on termination.
    //
    pFR->Flags &= ~((DWORD)(FR_REPLACE | FR_FINDNEXT | FR_REPLACEALL));

    //
    //  Tell caller dialog is about to terminate.
    //
    pFR->Flags |= FR_DIALOGTERM;
    NotifyUpdateTextAndFlags(pFR);

    if (IS16BITWOWAPP(pFR))
    {
        if ((pFR->Flags & FR_ENABLEHOOK) && (pFR->lpfnHook))
        {
            (*pFR->lpfnHook)(hDlg, WM_DESTROY, 0, 0);
        }
    }

    //
    //  Free property slots.
    //
    RemoveProp(hDlg, FINDREPLACEPROP);
    DestroyWindow(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitControlsWithFlags
//
////////////////////////////////////////////////////////////////////////////

VOID InitControlsWithFlags(
   HWND hDlg,
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    HWND hCtl;

    //
    //  Set EDIT control to FindText.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        SetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat);
    }
    else
#endif
    {
        SetDlgItemText(hDlg, edt1, (LPTSTR)pFR->lpstrFindWhat);
    }
    SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(edt1, 0, EN_CHANGE));

    //
    //  Set HELP push button state.
    //
    if (!(pFR->Flags & FR_SHOWHELP))
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, pshHelp), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }

    //
    //  Dis/Enable check state of WHOLE WORD control.
    //
    if (pFR->Flags & FR_HIDEWHOLEWORD)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOWHOLEWORD)
    {
        EnableWindow(GetDlgItem(hDlg, chx1), FALSE);
    }
    CheckDlgButton(hDlg, chx1, (pFR->Flags & FR_WHOLEWORD) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of MATCH CASE control.
    //
    if (pFR->Flags & FR_HIDEMATCHCASE)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOMATCHCASE)
    {
        EnableWindow(GetDlgItem(hDlg, chx2), FALSE);
    }
    CheckDlgButton(hDlg, chx2, (pFR->Flags & FR_MATCHCASE) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of UP/DOWN buttons.
    //
    if (pFR->Flags & FR_HIDEUPDOWN)
    {
        ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOUPDOWN)
    {
        EnableWindow(GetDlgItem(hDlg, rad1), FALSE);
        EnableWindow(GetDlgItem(hDlg, rad2), FALSE);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Find Text only search direction setup.
        //
        CheckRadioButton( hDlg,
                          rad1,
                          rad2,
                          (pFR->Flags & FR_DOWN ? rad2 : rad1) );
    }
    else
    {
        //
        //  Replace Text only operations.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
             SetDlgItemTextA(hDlg, edt2, (LPSTR)pFR->lpstrReplaceWith);
        }
        else
#endif
        {
             SetDlgItemText(hDlg, edt2, pFR->lpstrReplaceWith);
        }
        SendMessage( hDlg,
                     WM_COMMAND,
                     GET_WM_COMMAND_MPS(edt2, 0, EN_CHANGE) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateTextAndFlags
//
//  chx1 is whether or not to match entire words
//  chx2 is whether or not case is relevant
//  chx3 is whether or not to wrap scans
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateTextAndFlags(
    HWND hDlg,
    LPFINDREPLACE pFR,
    DWORD dwActionFlag,
    UINT DlgType,
    UINT ApiType)
{
    //
    //  Only clear flags that this routine sets.  The hook and template
    //  flags should not be anded off here.
    //
    pFR->Flags &= ~((DWORD)(FR_WHOLEWORD | FR_MATCHCASE | FR_REPLACE |
                            FR_FINDNEXT | FR_REPLACEALL | FR_DOWN));
    if (IsDlgButtonChecked(hDlg, chx1))
    {
        pFR->Flags |= FR_WHOLEWORD;
    }

    if (IsDlgButtonChecked(hDlg, chx2))
    {
        pFR->Flags |= FR_MATCHCASE;
    }

    //
    //  Set ACTION flag FR_{REPLACE,FINDNEXT,REPLACEALL}.
    //
    pFR->Flags |= dwActionFlag;

#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        GetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }
    else
#endif
    {
        GetDlgItemText(hDlg, edt1, pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Assume searching down.  Check if UP button is NOT pressed, rather
        //  than if DOWN button IS.  So, if buttons have been hidden or
        //  disabled, FR_DOWN flag will be set correctly.
        //
        if (!IsDlgButtonChecked(hDlg, rad1))
        {
            pFR->Flags |= FR_DOWN;
        }
    }
    else
    {
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            GetDlgItemTextA( hDlg,
                             edt2,
                             (LPSTR)pFR->lpstrReplaceWith,
                             pFR->wReplaceWithLen );
        }
        else
#endif
        {
            GetDlgItemText( hDlg,
                            edt2,
                            pFR->lpstrReplaceWith,
                            pFR->wReplaceWithLen );
        }
        pFR->Flags |= FR_DOWN;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NotifyUpdateTextAndFlags
//
////////////////////////////////////////////////////////////////////////////

LRESULT NotifyUpdateTextAndFlags(
    LPFINDREPLACE pFR)
{
    if (IS16BITWOWAPP(pFR))
    {
        return ( SendMessage( pFR->hwndOwner,
                              WM_NOTIFYWOW,
                              WMNW_UPDATEFINDREPLACE,
                              (DWORD_PTR)pFR ) );
    }
    return ( SendMessage(pFR->hwndOwner, wFRMessage, 0, (DWORD_PTR)pFR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\init.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    init.c

Abstract:

    This module contains the init routines for the Win32 common dialogs.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

//
//  External Declarations.
//

extern HDC hdcMemory;
extern HBITMAP hbmpOrigMemBmp;

extern CRITICAL_SECTION g_csLocal;
extern CRITICAL_SECTION g_csNetThread;

// TLS index to get current dlg info for the current thread
extern DWORD g_tlsiCurDlg;   

// TLS index to get most recent ExtError for the current thread
extern DWORD g_tlsiExtError; 

// TLS index to get LangID used for the current thread
extern DWORD g_tlsLangID;

extern HANDLE hMPR;
extern HANDLE hMPRUI;
extern HANDLE hLNDEvent;

extern DWORD dwNumDisks;
extern OFN_DISKINFO gaDiskInfo[MAX_DISKS];

extern DWORD cbNetEnumBuf;
extern LPTSTR gpcNetEnumBuf;

extern RECT g_rcDlg;

extern TCHAR g_szInitialCurDir[MAX_PATH];

//
//  Global Variables.
//

WCHAR szmsgLBCHANGEW[]          = LBSELCHSTRINGW;
WCHAR szmsgSHAREVIOLATIONW[]    = SHAREVISTRINGW;
WCHAR szmsgFILEOKW[]            = FILEOKSTRINGW;
WCHAR szmsgCOLOROKW[]           = COLOROKSTRINGW;
WCHAR szmsgSETRGBW[]            = SETRGBSTRINGW;
WCHAR szCommdlgHelpW[]          = HELPMSGSTRINGW;

TCHAR szShellIDList[]           = CFSTR_SHELLIDLIST;

BOOL g_bMirroredOS              = FALSE;
//
//  Private message for WOW to indicate 32-bit logfont
//  needs to be thunked back to 16-bit log font.
//
CHAR szmsgWOWLFCHANGE[]         = "WOWLFChange";

//
//  Private message for WOW to indicate 32-bit directory needs to be
//  thunked back to 16-bit task directory.
//
CHAR szmsgWOWDIRCHANGE[]        = "WOWDirChange";
CHAR szmsgWOWCHOOSEFONT_GETLOGFONT[]  = "WOWCHOOSEFONT_GETLOGFONT";

CHAR szmsgLBCHANGEA[]           = LBSELCHSTRINGA;
CHAR szmsgSHAREVIOLATIONA[]     = SHAREVISTRINGA;
CHAR szmsgFILEOKA[]             = FILEOKSTRINGA;
CHAR szmsgCOLOROKA[]            = COLOROKSTRINGA;
CHAR szmsgSETRGBA[]             = SETRGBSTRINGA;
CHAR szCommdlgHelpA[]           = HELPMSGSTRINGA;

UINT g_cfCIDA;





////////////////////////////////////////////////////////////////////////////
//
//  FInitColor
//
////////////////////////////////////////////////////////////////////////////

extern DWORD rgbClient;
extern HBITMAP hRainbowBitmap;

int FInitColor(
    HANDLE hInst)
{
    cyCaption = (short)GetSystemMetrics(SM_CYCAPTION);
    cyBorder = (short)GetSystemMetrics(SM_CYBORDER);
    cxBorder = (short)GetSystemMetrics(SM_CXBORDER);
    cyVScroll = (short)GetSystemMetrics(SM_CYVSCROLL);
    cxVScroll = (short)GetSystemMetrics(SM_CXVSCROLL);
    cxSize = (short)GetSystemMetrics(SM_CXSIZE);

    rgbClient = GetSysColor(COLOR_3DFACE);

    hRainbowBitmap = 0;

    return (TRUE);
    hInst;
}


////////////////////////////////////////////////////////////////////////////
//
//  FInitFile
//
////////////////////////////////////////////////////////////////////////////

BOOL FInitFile(
    HANDLE hins)
{
    bMouse = GetSystemMetrics(SM_MOUSEPRESENT);

    wWinVer = 0x0A0A;

    //
    //  Initialize these to reality.
    //
#if DPMICDROMCHECK
    wCDROMIndex = InitCDROMIndex((LPWORD)&wNumCDROMDrives);
#endif

    //
    // special WOW messages
    //
    msgWOWLFCHANGE       = RegisterWindowMessageA((LPSTR)szmsgWOWLFCHANGE);
    msgWOWDIRCHANGE      = RegisterWindowMessageA((LPSTR)szmsgWOWDIRCHANGE);
    msgWOWCHOOSEFONT_GETLOGFONT = RegisterWindowMessageA((LPSTR)szmsgWOWCHOOSEFONT_GETLOGFONT);

    msgLBCHANGEA         = RegisterWindowMessageA((LPSTR)szmsgLBCHANGEA);
    msgSHAREVIOLATIONA   = RegisterWindowMessageA((LPSTR)szmsgSHAREVIOLATIONA);
    msgFILEOKA           = RegisterWindowMessageA((LPSTR)szmsgFILEOKA);
    msgCOLOROKA          = RegisterWindowMessageA((LPSTR)szmsgCOLOROKA);
    msgSETRGBA           = RegisterWindowMessageA((LPSTR)szmsgSETRGBA);

#ifdef UNICODE
    msgLBCHANGEW         = RegisterWindowMessageW((LPWSTR)szmsgLBCHANGEW);
    msgSHAREVIOLATIONW   = RegisterWindowMessageW((LPWSTR)szmsgSHAREVIOLATIONW);
    msgFILEOKW           = RegisterWindowMessageW((LPWSTR)szmsgFILEOKW);
    msgCOLOROKW          = RegisterWindowMessageW((LPWSTR)szmsgCOLOROKW);
    msgSETRGBW           = RegisterWindowMessageW((LPWSTR)szmsgSETRGBW);
#else
    msgLBCHANGEW         = msgLBCHANGEA;
    msgSHAREVIOLATIONW   = msgSHAREVIOLATIONA;
    msgFILEOKW           = msgFILEOKA;
    msgCOLOROKW          = msgCOLOROKA;
    msgSETRGBW           = msgSETRGBA;
#endif

    g_cfCIDA             = RegisterClipboardFormat(szShellIDList);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  Initializes any instance specific data needed by functions in the
//  common dialogs.
//
//  Returns:   TRUE    - success
//             FALSE   - failure
//
////////////////////////////////////////////////////////////////////////////

// ccover needs to link to C-runtime, so we rename LibMain to DllMain
#ifdef CCOVER 
#define LibMain DllMain
#endif

BOOL LibMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            //
            //  Threads can only enter and leave the comdlg32 dll from the
            //  Get{Open,Save}FileName apis, so the TLS lpCurDlg alloc is
            //  done inside the InitFileDlg routine in fileopen.c
            //
            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hinst = (HANDLE)hModule;

            if (!FInitColor(g_hinst) || !FInitFile(g_hinst))
            {
                goto CantInit;
            }

            DisableThreadLibraryCalls(hModule);

            //
            //  msgHELP is sent whenever a help button is pressed in one of
            //  the common dialogs (provided an owner was declared and the
            //  call to RegisterWindowMessage doesn't fail).
            //
            msgHELPA = RegisterWindowMessageA((LPSTR)szCommdlgHelpA);
#ifdef UNICODE
            msgHELPW = RegisterWindowMessageW((LPWSTR)szCommdlgHelpW);
#else
            msgHELPW = msgHELPA;
#endif

            //
            //  Need a semaphore locally for managing array of disk info.
            //
            if (!InitializeCriticalSectionAndSpinCount(&g_csLocal, 0))
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Need a semaphore for control access to CreateThread.
            //
            if (!InitializeCriticalSectionAndSpinCount(&g_csNetThread, 0))
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Allocate a tls index for curdlg so we can make it per-thread.
            //
            if ((g_tlsiCurDlg = TlsAlloc()) != 0xFFFFFFFF)
            {
                // mark the list as empty
                TlsSetValue(g_tlsiCurDlg, (LPVOID) 0);
            }
            else
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Store the current directory on process attach.
            //
            GetCurrentDirectory(ARRAYSIZE(g_szInitialCurDir), g_szInitialCurDir);

            //
            //  Allocate a tls index for extended error.
            //
            if ((g_tlsiExtError = TlsAlloc()) == 0xFFFFFFFF)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Allocate a tls index for LangID so we can make it per-thread.
            //  it heavily used by CDLoadString.
            //
            if ((g_tlsLangID = TlsAlloc()) != 0xFFFFFFFF)
            {
                // mark the list as Neutral
                TlsSetValue(g_tlsLangID, (LPVOID) MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
            }
            else
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }



            dwNumDisks = 0;
            gpcNetEnumBuf = NULL;

            //
            //  NetEnumBuf allocated in ListNetDrivesHandler.
            //
            cbNetEnumBuf = WNETENUM_BUFFSIZE;

            hMPR = NULL;
            hMPRUI = NULL;

            hLNDEvent = NULL;

            //
            //  For file open dialog.
            //
            g_rcDlg.left = g_rcDlg.right = g_rcDlg.top = g_rcDlg.bottom = 0;

            g_bMirroredOS = IS_MIRRORING_ENABLED();
            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            //
            //  We only want to do our clean up work if we are being called
            //  with freelibrary, not if the process is ending.
            //
            if (lpRes == NULL)
            {
                TermFile();
                TermPrint();
                TermColor();
                TermFont();

                TlsFree(g_tlsiCurDlg);
                TlsFree(g_tlsiExtError);
                TlsFree(g_tlsLangID);

                DeleteCriticalSection(&g_csLocal);
                DeleteCriticalSection(&g_csNetThread);
            }

            return (TRUE);
            break;
        }
    }

CantInit:
    return (FALSE);
    lpRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\isz.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    isz.h

Abstract:

    This module contains the string resource IDs for the common dialogs.

Revision History:

--*/



//
//  0x0000 - 0x00ff Error codes.
//


//
//  MESSAGES:  0x0100 to 0x01ff.
//
#define iszOverwriteCaption       0x0100
#define iszOverwriteQuestion      0x0101
#define iszDefExitCaption         0x0102
#define iszDefExitText            0x0103

#define iszDefaultPitch           0x0104
#define iszFixedPitch             0x0105
#define iszVariablePitch          0x0106
#define iszAnsiCharset            0x0107
#define iszOemCharset             0x0108
#define iszSymbolCharset          0x0109
#define iszDecorativeFamily       0x010a
#define iszUnknownFamily          0x010b
#define iszModernFamily           0x010c
#define iszRomanFamily            0x010d
#define iszScriptFamily           0x010e
#define iszSwissFamily            0x010f

#define iszSystemFont             0x0110
#define iszHelvFont               0x0111
#define iszCourierFont            0x0112
#define iszTmsRmnFont             0x0113
#define iszSymbolFont             0x0114
#define iszRomanFont              0x0115
#define iszScriptFont             0x0116
#define iszModernFont             0x0117
#define iszLastFont               iszModernFont

#define iszFileSaveIn             0x0170
#define iszFileSaveButton         0x0171
#define iszFileOpenButton         0x0172
#define iszPrintButton            0x0173

#define iszFileOpenTitle          0x0180
#define iszFileSaveTitle          0x0181
#define iszSaveFileAsType         0x0182
#define iszDriveDoesNotExist      0x0183
#define iszNoDiskInDrive          0x0184
#define iszWrongDiskInDrive       0x0185
#define iszUnformatedDisk         0x0186
#define iszFileNotFound           0x0187
#define iszPathNotFound           0x0188
#define iszInvalidFileName        0x0189
#define iszSharingViolation       0x018A
#define iszNetworkAccessDenied    0x018B
#define iszReadOnly               0x018C
#define iszInt24Error             0x018D
#define iszPortName               0x018E
#define iszWriteProtection        0x018F
#define iszDiskFull               0x0190
#define iszNoFileHandles          0x0191
#define iszCreatePrompt           0x0192
#define iszCreateNoModify         0x0193
#define iszSelectDriveTrouble     0x0194
#define iszNoNetButtonResponse    0x0195
#define iszFileAccessDenied       0x0196
#define iszDirAccessDenied        0x0197
#define iszNoDiskInCDRom          0x0198
#define iszNetworkButtonText      0x0199
#define iszNetworkButtonTextAccel 0x019A
#define iszTooManyFiles           0x019B
#define iszSaveAsType             0x019C

#define iszObjectName             0x01A2
#define iszObjectType             0x01A3
#define iszSaveRestricted         0x01A4
#define iszNoSaveToURL            0x01A5
#define iszPrinterDeleted         0x01A6
#define iszDirSaveAccessDenied    0x01A7

//
//  RESOURCES:  0x0200 to 0x020f.
//
//     Menus:           0x0200 to 0x020f
//     Icons:           0x0210 to 0x021f
//     Cursors:         0x0220 to 0x022f
//     Accelerators:    0x0230 to 0x023f
//     Bitmaps:         0x0240 to 0x024f
//     Private:         0x0250 to 0x025f
//
#define ICO_PORTRAIT              0x0210
#define ICO_LANDSCAPE             0x0211
#define ICO_P_NONE                0x0212
#define ICO_L_NONE                0x0213
#define ICO_P_HORIZ               0x0214
#define ICO_L_HORIZ               0x0215
#define ICO_P_VERT                0x0216
#define ICO_L_VERT                0x0217
#define ICO_COLLATE               0x0218
#define ICO_NO_COLLATE            0x0219
#define ICO_P_PSSTAMP             0x021a
#define ICO_L_PSSTAMP             0x021b
#define ICO_PRINTER               0x021c

#define bmpDirDrive               576


//
//  DIALOGS:  0x0300 to 0x03ff.
//
#define dlgFileOpen               0x0300
#define dlgFileSave               0x0301
#define dlgExitChanges            0x0302
#define dlgChooseColor            0x0303
#define dlgFindText               0x0304
#define dlgReplaceText            0x0305
#define dlgFormatChar             0x0306
#define dlgFontInfo               0x0307
#define dlgPrintDlg               0x0308
#define dlgPrintSetupDlg          0x0309
#define dlgMultiFileOpen          0x030a


//
//  MISC:  0x0400 to 0x06ff.
//
#define BMFONT                    38

#define iszClose                  0x040d   // "Close" text for find/replace


#define iszBlack                  0x0410
#define iszDkRed                  0x0411
#define iszDkGreen                0x0412
#define iszDkYellow               0x0413
#define iszDkBlue                 0x0414
#define iszDkPurple               0x0415
#define iszDkAqua                 0x0416
#define iszDkGrey                 0x0417
#define iszLtGrey                 0x0418
#define iszLtRed                  0x0419
#define iszLtGreen                0x041a
#define iszLtYellow               0x041b
#define iszLtBlue                 0x041c
#define iszLtPurple               0x041d
#define iszLtAqua                 0x041e
#define iszWhite                  0x041f

#define iszHighPrnQ               0x0430
#define iszMedPrnQ                0x0431
#define iszLowPrnQ                0x0432
#define iszDraftPrnQ              0x0433

#define iszPrinter                0x0440
#define iszSysPrn                 0x0441
#define iszPrnOnPort              0x0442
#define iszDefCurOn               0x0443

#define iszSizeNumber             0x044A
#define iszSizeRange              0x044B
#define iszSynth                  0x044C
#define iszTrueType               0x044D
#define iszPrinterFont            0x044E
#define iszGDIFont                0x044F

#ifdef WINNT
#define iszTTOpenType             0x0470
#define iszPSOpenType             0x0471
#define iszType1                  0x0472
#endif

#define iszPageRangeError         0x0450
#define iszFromToError            0x0451
#define iszPageFromError          0x0452
#define iszPageToError            0x0453
#define iszBadMarginError         0x0454
#define iszCopiesZero             0x0455
#define iszTooManyCopies          0x0456
#define iszWarningTitle           0x0457
#define iszNoPrnsInstalled        0x0458
#define iszPrnNotFound            0x0459
#define iszMemoryError            0x045A
#define iszGeneralWarning         0x045B
#define iszUnknownDriver          0x045C
#define iszBadPageRange           0x045D
#define iszTooManyPageRanges      0x045E
#define iszBadPageRangeSyntaxOld  0x045F
#define iszBadPageRangeSyntaxNew  0x0460
#define iszNoPrinters             0x0461
//  Empty                         0x0462
#define iszNoPrinterSelected      0x0463
#define iszDefaultMenuText        0x0464
#define iszNoPrinterAccess        0x0465

#define iszNoFontsTitle           0x0500
#define iszNoFontsMsg             0x0501
#define iszNoFaceSel              0x0502
#define iszNoStyleSel             0x0503
#define iszRegular                0x0504
#define iszBold                   0x0505
#define iszItalic                 0x0506
#define iszBoldItalic             0x0507
#define iszNoScript               0x0508

//
//  CCHSTYLE is the max allowed length of iszRegular to iszBoldItalic strings
//
#define CCHSTYLE                  32


#define iszStatusReady            0x0600

#define iszStatusPaused           0x0601
#define iszStatusError            0x0602
#define iszStatusPendingDeletion  0x0603
#define iszStatusPaperJam         0x0604
#define iszStatusPaperOut         0x0605
#define iszStatusManualFeed       0x0606
#define iszStatusPaperProblem     0x0607
#define iszStatusOffline          0x0608
#define iszStatusIOActive         0x0609
#define iszStatusBusy             0x060A
#define iszStatusPrinting         0x060B
#define iszStatusOutputBinFull    0x060C
#define iszStatusNotAvailable     0x060D
#define iszStatusWaiting          0x060E
#define iszStatusProcessing       0x060F
#define iszStatusInitializing     0x0610
#define iszStatusWarmingUp        0x0611
#define iszStatusTonerLow         0x0612
#define iszStatusNoToner          0x0613
#define iszStatusPagePunt         0x0614
#define iszStatusUserIntervention 0x0615
#define iszStatusOutOfMemory      0x0616
#define iszStatusDoorOpen         0x0617

#define iszStatusDocumentsWaiting 0x062F
#define iszStatusDefaultPrinter   0x062E

#define iszPrintRangeAll          0x0630

#define iszMarginsInches          0x0631
#define iszMarginsMillimeters     0x0632
#define iszInches                 0x0633
#define iszMillimeters            0x0634
#define iszDefaultSource          0x0635

#define iszGeneralPage            0x0640
#define iszPrintCaption           0x0641


//
//  FONT SAMPLES:  0x0700 to 0x07ff.
//
#define iszFontSample               0x0700

//Unicode Font Samples
#define iszUnicode                  0x0800
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\precomp.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Revision History:

    Lazar Ivanov (LazarI) - created 2/21/2001

--*/

#define _COMDLG32_                     // We are Comdlg32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <lm.h>
#include <winnetwk.h>
#include <winnetp.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellp.h>
#include <shellapi.h>
#include <commctrl.h>
#include <shsemip.h>
#include <coguid.h>
#include <shlguid.h>
#include <shdguid.h>
#include <shguidp.h>
#include <ieguidp.h>
#include <oleguid.h>
#include <commdlg.h>
#include <ole2.h>
#include <dbt.h>
#include <inetreg.h>
#include <sfview.h>
#include <tchar.h>
#include <msprintx.h>
#include <imm.h>
#include <wingdip.h>                    // for IS_ANY_DBCS_CHARSET macro
#include <winspool.h>
#include <commctrl.h>
#include <dlgs.h>
#include <wowcmndg.h>
#include <winuserp.h>
#include <npapi.h>
#include <platform.h>
#include <port32.h>
#include <ccstock.h>
#include <wininet.h>
#include <debug.h>

#ifdef __cplusplus                      // C++ headers
#include <dpa.h>
#include <shstr.h>
#endif

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "comdlg32.h"                   // some private common definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\parse.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    parse.c

Abstract:

    This module contains the parse routines for the Win32 common dialogs.

Revision History:

--*/


// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "fileopen.h"




////////////////////////////////////////////////////////////////////////////
//
//  ParseFileNew
//
//  On the return, pnExtOffset is the offset to the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileNew(
    LPTSTR pszPath,
    int *pnExtOffset,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    if (pnExtOffset)
    {
        int nExt;

        nExt = (int)(SHORT)HIWORD(lRet);
        *pnExtOffset = ((nExt) && *(pszPath + nExt)) ? nExt : 0;
    }

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFileOld
//
//  On return, pnExtOffset is the offset to the the dot and
//  pnOldExt is the offset to the character following the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileOld(
    LPTSTR pszPath,
    int *pnExtOffset,
    int *pnOldExt,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    int nExt = (int)(SHORT)HIWORD(lRet);
    *pnExtOffset = nExt;
    *pnOldExt = ((nExt) && *(pszPath + nExt)) ? nExt + 1 : 0;

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFile
//
//  Determines if the filename is a legal dos name.
//
//  Circumstances checked:
//      1) Valid as directory name, but not as file name
//      2) Empty String
//      3) Illegal Drive label
//      4) Period in invalid location (in extension, 1st in file name)
//      5) Missing directory character
//      6) Illegal character
//      7) Wildcard in directory name
//      8) Double slash beyond 1st 2 characters
//      9) Space character in the middle of the name (trailing spaces OK)
//         -->> no longer applies : spaces are allowed in LFN
//      10) Filename greater than 8 characters : NOT APPLICABLE TO LONG FILE NAMES
//      11) Extension greater than 3 characters: NOT APPLICABLE TO LONG FILE NAMES
//
//  lpstrFileName - ptr to a single file name
//
//  Returns:
//      LONG - LOWORD = char offset to filename,
//             HIWORD = char offset to extension (dot),
//      LONG - LOWORD is error code (<0), HIWORD is approx. place of problem
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseFile(
    LPTSTR lpstrFileName,
    BOOL bLFNFileSystem,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    SHORT nFile, nExt, nFileOffset, nExtOffset = 0;
    BOOL bExt;
    BOOL bWildcard;
    SHORT nNetwork = 0;
    BOOL bUNCPath = FALSE;
    LPTSTR lpstr = lpstrFileName;

    //Check if the string is empty
    if (!*lpstr)
    {
        nFileOffset = PARSE_EMPTYSTRING;
        goto ParseFile_Failure;
    }

    //Check if the string is of form  c:\foo1\foo2
    if (*(lpstr + 1) == CHAR_COLON)
    {
        //Yes. Get the drive letter
        TCHAR cDrive = CharLowerChar(*lpstr);

        //
        //  Test to see if the drive is legal.
        //
        //  Note: Does not test that drive exists.
        //
        if ((cDrive < CHAR_A) || (cDrive > CHAR_Z))
        {
            nFileOffset = PARSE_INVALIDDRIVE;
            goto ParseFile_Failure;
        }

        //Move string past drive letter and ':'
        lpstr = CharNext(CharNext(lpstr));
    }

    if ((*lpstr == CHAR_BSLASH) || (*lpstr == CHAR_SLASH && !bNewStyle))
    {
        //
        //  Cannot have "c:\."
        //
        if (*++lpstr == CHAR_DOT)
        {
            //
            //  Except that "c:\.\" is allowed.
            //
            if ((*++lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
            {
                //
                //  It's the root directory.
                //
                if (!*lpstr)
                {
                    goto MustBeDir;
                }
                else
                {
                    lpstr--;
                }
            }
            else
            {
                //
                //  It's saying top dir (once again), thus allowed.
                //
                ++lpstr;
            }
        }
        else if ((*lpstr == CHAR_BSLASH) && (*(lpstr - 1) == CHAR_BSLASH))
        {
            //
            //  It seems that for a full network path, whether a drive is
            //  declared or not is insignificant, though if a drive is given,
            //  it must be valid (hence the code above should remain there).
            //

            //
            //  ...since it's the first slash, 2 are allowed.
            //
            ++lpstr;

            //
            //  Must receive server and share to be real.
            //
            nNetwork = -1;

            //
            //  No wildcards allowed if UNC name.
            //
            bUNCPath = TRUE;
        }
        else if (*lpstr == CHAR_SLASH && !bNewStyle)
        {
            nFileOffset = PARSE_INVALIDDIRCHAR;
            goto ParseFile_Failure;
        }
    }
    else if (*lpstr == CHAR_DOT)
    {
        //
        //  Up one directory.
        //
        if (*++lpstr == CHAR_DOT)
        {
            ++lpstr;
        }

        if (!*lpstr)
        {
            goto MustBeDir;
        }
        if ((*lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
        {
            //
            //  Jumping to Failure here will skip the parsing that causes
            //  ".xxx.txt" to return with nFileOffset = 2.
            //
            nFileOffset = 0;
            goto ParseFile_Failure;
        }
        else
        {
            //
            //  Allow directory.
            //
            ++lpstr;
        }
    }

    if (!*lpstr)
    {
        goto MustBeDir;
    }

    //
    //  Should point to first char in filename by now.
    //
    nFileOffset = nExtOffset = nFile = nExt = 0;
    bWildcard = bExt = FALSE;
    while (*lpstr)
    {
        //
        //  Anything below the "Space" character is invalid.
        //
        if (*lpstr < CHAR_SPACE)
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto ParseFile_Failure;
        }
        switch (*lpstr)
        {
            case ( CHAR_COLON ) :
            case ( CHAR_BAR ) :
            case ( CHAR_LTHAN ) :
            case ( CHAR_QUOTE ) :
            {
                //
                //  Invalid characters for all file systems.
                //
                nFileOffset = PARSE_INVALIDCHAR;
                goto ParseFile_Failure;
            }
            case ( CHAR_SEMICOLON ) :
            case ( CHAR_COMMA ) :
            case ( CHAR_PLUS ) :
            case ( CHAR_LBRACKET ) :
            case ( CHAR_RBRACKET ) :
            case ( CHAR_EQUAL ) :
            {
                if (!bLFNFileSystem)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    goto RegularCharacter;
                }
            }
            case ( CHAR_SLASH ) :
            {
                if (bNewStyle)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }

                // fall thru...
            }
            case ( CHAR_BSLASH ) :
            {
                //
                //  Subdir indicators.
                //
                nNetwork++;
                if (bWildcard)
                {
                    nFileOffset = PARSE_WILDCARDINDIR;
                    goto ParseFile_Failure;
                }

                //
                // if nFile==0 means that we are seeing this backslash right next to a backslash  
                // which is not allowed.
                if (nFile == 0)
                {
                    nFileOffset = PARSE_INVALIDDIRCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    //Move over the BSLASH/SLASH character.
                    ++lpstr;

                    //Check if the path is valid network path name
                    if (!nNetwork && !*lpstr)
                    {
                        nFileOffset = PARSE_INVALIDNETPATH;
                        goto ParseFile_Failure;
                    }

                    
                    //We assume that the  characters we are seeing are filename characters. This BSLASH/SLASH
                    //character tells that characters we have seen so far specifies the name of a directory in the
                    //path. Reset flags so that we can start looking for filename again.
                    nFile = nExt = 0;
                    nExtOffset = 0;
                    bExt = FALSE;
                }
                break;
            }
            case ( CHAR_SPACE ) :
            {
                LPTSTR lpSpace = lpstr;

                if (bLFNFileSystem)
                {
                    // In Long file name file system space characters  are O.K
                    goto RegularCharacter;
                }


                //We are not interested in the trailing spaces so null terminate it.
                *lpSpace = CHAR_NULL;


                // In non long file name file systems, space characters are OK at the end of file
                // name. Check to see if all the characters that follows are spaces. if thats the case
                // then its valid. if we have any non space character after the first space then its a 
                // invalid file name.
                
                while (*++lpSpace)
                {
                    if (*lpSpace != CHAR_SPACE)
                    {
                        *lpstr = CHAR_SPACE;
                        nFileOffset = PARSE_INVALIDSPACE;
                        goto ParseFile_Failure;
                    }
                }

                break;
            }
            
            case ( CHAR_DOT ) :
            {

                // In newstyle nExtOffset points to the dot and not to the first character of extension.
                if (bNewStyle)
                {
                    nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    goto RegularCharacter;
                }
                
                if (nFile == 0)
                {
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                    if (*++lpstr == CHAR_DOT)
                    {
                        ++lpstr;
                    }
                    if (!*lpstr)
                    {
                        goto MustBeDir;
                    }

                    //
                    //  Flags already set.
                    //
                    nFile++;
                    ++lpstr;
                }
                else
                {
                    nExtOffset = 0;
                    ++lpstr;
                    bExt = TRUE;
                }
                break;
            }
            case ( CHAR_STAR ) :
            case ( CHAR_QMARK ) :
            {
                bWildcard = TRUE;

                //  Fall thru...
            }
            default :
            {
RegularCharacter:

                //Are we in extension part ?
                if (bExt)
                {
                    //Is this first character in extension part
                    if (++nExt == 1)
                    {
                        //Yes, then get the Extension offset
                        nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    }
                }

                //We are still in file name part. 
                //Is this the first character in filename part ?
                else if (++nFile == 1)
                {
                    //Yes. Get the filename offset
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                }

                //Move to the next character
                lpstr = CharNext(lpstr);
                break;
            }
        }
    }

    if (nNetwork == -1)
    {
        nFileOffset = PARSE_INVALIDNETPATH;
        goto ParseFile_Failure;
    }
    else if (bUNCPath)
    {
        if (!nNetwork)
        {
            //
            //  Server and share only.(e.g \\server\foo)
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
        else if ((nNetwork == 1) && !nFile)
        {
            //
            //  Server and share root.(e.g \\server\foo\)
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
    }

    if (!nFile)
    {
MustBeDir:
        nFileOffset = PARSE_DIRECTORYNAME;
        goto ParseFile_Failure;
    }

    //
    //  If bNewStyle is true, no ext. wanted.
    //
    if (!bNewStyle)
    {
        if ((bWowApp) &&
            (*(lpstr - 1) == CHAR_DOT) &&
            (*CharNext(lpstr - 2) == CHAR_DOT))
        {
            //
            //  Remove terminating period.
            //
            *(lpstr - 1) = CHAR_NULL;
        }
        else if (!nExt)
        {
ParseFile_Failure:
            //
            //  Need to recheck bNewStyle since we can jump here.
            //
            if (!bNewStyle)
            {
                nExtOffset = (SHORT)(lpstr - lpstrFileName);
            }
        }
    }

    return (MAKELONG(nFileOffset, nExtOffset));
}


////////////////////////////////////////////////////////////////////////////
//
//  PathRemoveBslash
//
//  Removes a trailing backslash from the given path.
//
//  Returns:
//      Pointer to NULL that replaced the backslash   OR
//      Pointer to the last character if it isn't a backslash
//
////////////////////////////////////////////////////////////////////////////

LPTSTR PathRemoveBslash(
    LPTSTR lpszPath)
{
    int len = lstrlen(lpszPath) - 1;

#ifndef UNICODE
    if (IsDBCSLeadByte(*CharPrev(lpszPath, lpszPath + len + 1)))
    {
        len--;
    }
#endif

    if (!PathIsRoot(lpszPath) && (lpszPath[len] == CHAR_BSLASH))
    {
        lpszPath[len] = CHAR_NULL;
    }

    return (lpszPath + len);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsWild
//
////////////////////////////////////////////////////////////////////////////

BOOL IsWild(
    LPCTSTR lpsz)
{
    return (StrChr(lpsz, CHAR_STAR) || StrChr(lpsz, CHAR_QMARK));
}


////////////////////////////////////////////////////////////////////////////
//
//  AppendExt
//
//  Appends default extension onto path name.
//  It assumes the current path name doesn't already have an extension.
//  lpExtension does not need to be null terminated.
//
//  Returns TRUE upon succes, otherwise FALSE (not enough buffer room),
//
////////////////////////////////////////////////////////////////////////////

BOOL AppendExt(
    LPTSTR lpszPath,
    DWORD cchPath,
    LPCTSTR lpExtension,
    BOOL bWildcard)
{
    WORD wOffset;
    SHORT i;
    TCHAR szExt[MAX_PATH + 1];
    BOOL bRet = TRUE;

    if (lpExtension && *lpExtension)
    {
        wOffset = (WORD)lstrlen(lpszPath);
        if (bWildcard)
        {
            if (wOffset < (cchPath - 1))
            {
                *(lpszPath + wOffset) = CHAR_STAR;
                wOffset++;
            }
            else
            {
                bRet = FALSE;
            }
        }

        if (bRet)
        {
            //
            //  Add a period.
            //
            if (wOffset < (cchPath - 1))
            {
                *(lpszPath + wOffset) = CHAR_DOT;
                wOffset++;
            }
            else
            {
                bRet = FALSE;
            }

            if (bRet)
            {
                for (i = 0; *(lpExtension + i) && i < MAX_PATH; i++)
                {
                    szExt[i] = *(lpExtension + i);
                }
                szExt[i] = 0;

                //
                //  Remove leading / trailing blanks in the extension.
                //
                PathRemoveBlanks(szExt);

                //
                //  Add the rest.
                //
                bRet = SUCCEEDED(StringCchCopy(lpszPath + wOffset, (cchPath - wOffset), szExt));
            }
        }
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  IsUNC
//
//  Determines if the given path is a UNC path.
//
//  Returns:
//      TRUE    if path starts with "\\" or "X:\\"
//      FALSE   otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL IsUNC(
    LPCTSTR lpszPath)
{
    return ( DBL_BSLASH(lpszPath) ||
             ((lpszPath[1] == CHAR_COLON) && DBL_BSLASH(lpszPath + 2)) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PortName
//
////////////////////////////////////////////////////////////////////////////

#define PORTARRAY 14

BOOL PortName(
    LPTSTR lpszFileName)
{
    static TCHAR *szPorts[PORTARRAY] = { TEXT("LPT1"),
                                         TEXT("LPT2"),
                                         TEXT("LPT3"),
                                         TEXT("LPT4"),
                                         TEXT("COM1"),
                                         TEXT("COM2"),
                                         TEXT("COM3"),
                                         TEXT("COM4"),
                                         TEXT("EPT"),
                                         TEXT("NUL"),
                                         TEXT("PRN"),
                                         TEXT("CLOCK$"),
                                         TEXT("CON"),
                                         TEXT("AUX"),
                                       };
    short i;
    TCHAR cSave, cSave2;


    cSave = *(lpszFileName + 4);
    if (cSave == CHAR_DOT)
    {
        *(lpszFileName + 4) = CHAR_NULL;
    }

    //
    //  For "EPT".
    //
    cSave2 = *(lpszFileName + 3);
    if (cSave2 == CHAR_DOT)
    {
      *(lpszFileName + 3) = CHAR_NULL;
    }

    for (i = 0; i < PORTARRAY; i++)
    {
        if (!lstrcmpi(szPorts[i], lpszFileName))
        {
            break;
        }
    }
    *(lpszFileName + 4) = cSave;
    *(lpszFileName + 3) = cSave2;

    return (i != PORTARRAY);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDirectory
//
////////////////////////////////////////////////////////////////////////////

BOOL IsDirectory(
    LPTSTR pszPath)
{
    DWORD dwAttributes;

    //
    //  Clean up for GetFileAttributes.
    //
    PathRemoveBslash(pszPath);

    dwAttributes = GetFileAttributes(pszPath);
    return ( (dwAttributes != (DWORD)(-1)) &&
             (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) );
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteProtectedDirCheck
//
//  This function takes a full filename, strips the path, and creates
//  a temp file in that directory.  If it can't, the directory is probably
//  write protected.
//
//  Returns:
//      error code if writeprotected
//      0 if successful creation of file.
//
//  Assumptions:
//    Full Path name on input with space for full filename appended.
//
//  Note: Do NOT use this on a floppy, it's too slow!
//
////////////////////////////////////////////////////////////////////////////

int WriteProtectedDirCheck(
    LPCTSTR lpszFile)
{
    SHORT nFileOffset;
    TCHAR szFile[MAX_PATH + 1];
    TCHAR szBuf[MAX_PATH + 1];
    DWORD dwRet;

    EVAL(SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), lpszFile)));
    dwRet = ParseFile(szFile, TRUE, FALSE, TRUE);
    nFileOffset = (SHORT)LOWORD(dwRet);

    ASSERT(nFileOffset > 0);
    szFile[nFileOffset - 1] = CHAR_NULL;
    if (!GetTempFileName(szFile, TEXT("TMP"), 0, szBuf))
    {
        return (GetLastError());
    }
    else
    {
        DeleteFile(szBuf);
        return (0);               // success
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FOkToWriteOver
//
//  Verifies that the user really does want to destroy the file,
//  replacing its contents with new stuff.
//
////////////////////////////////////////////////////////////////////////////

BOOL FOkToWriteOver(
    HWND hDlg,
    LPTSTR szFileName)
{
    TCHAR szCaption[128];
    TCHAR szWarning[128 + MAX_FULLPATHNAME];
    BOOL bRet = FALSE;

    if (CDLoadString( g_hinst,
                     iszOverwriteQuestion,
                     szCaption,
                     ARRAYSIZE(szCaption)))
    {

        //
        //  Since we're passed in a valid filename, if the 3rd & 4th characters
        //  are both slashes, weve got a dummy drive as the 1st two characters.
        //
        if (DBL_BSLASH(szFileName + 2))
        {
            szFileName = szFileName + 2;
        }

        if (SUCCEEDED(StringCchPrintf(szWarning, ARRAYSIZE(szWarning), szCaption, szFileName)))
        {
            GetWindowText(hDlg, szCaption, ARRAYSIZE(szCaption));
            bRet = (MessageBox( hDlg,
                            szWarning,
                            szCaption,
                            MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ) == IDYES);
        }
    }
    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFileDlg
//
////////////////////////////////////////////////////////////////////////////

int CreateFileDlg(
    HWND hDlg,
    LPTSTR szPath)
{
    TCHAR szCaption[128];
    TCHAR szWarning[128 + MAX_FULLPATHNAME];
    int nRet = IDNO;
    //
    //  Since we're passed in a valid filename, if the 3rd & 4th
    //  characters are both slashes, we've got a dummy drive as the
    //  1st two characters.
    //
    if (DBL_BSLASH(szPath + 2))
    {
        szPath = szPath + 2;
    }

    if (CDLoadString(g_hinst, iszCreatePrompt, szCaption, ARRAYSIZE(szCaption)))
    {
        if (lstrlen(szPath) > TOOLONGLIMIT)
        {
            *(szPath + TOOLONGLIMIT) = CHAR_NULL;
        }

        if (SUCCEEDED(StringCchPrintf(szWarning, ARRAYSIZE(szWarning), szCaption, szPath)))
        {
            GetWindowText(hDlg, szCaption, ARRAYSIZE(szCaption));

            nRet = (MessageBox( hDlg,
                                szWarning,
                                szCaption,
                                MB_YESNO | MB_ICONQUESTION ));
        }
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\printnew.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.h

Abstract:

    This module contains the header information for the Win32
    property sheet print common dialogs.

Revision History:

    11-04-97    JulieB    Created.
    Feb-2000    LazarI    major redesign (not to use printui anymore)

--*/



#ifdef __cplusplus
extern "C" {
#endif

//
//  Include Files.
//

#include <dlgs.h>
#include <initguid.h>
#include <winprtp.h>

//
//  Constant Declarations.
//

//
//  Dialog Constants.
//
#define IDD_PRINT_GENERAL          100
#define IDD_PRINT_GENERAL_LARGE    101 

#define IDI_COLLATE               ico1

#define IDC_PRINTER_LIST          1000
#define IDC_PRINTER_LISTVIEW      1001
#define IDC_PRINT_TO_FILE         1002
#define IDC_FIND_PRINTER          1003
#define IDC_STATUS_TEXT           1004
#define IDC_STATUS                1005
#define IDC_LOCATION_TEXT         1006
#define IDC_LOCATION              1007
#define IDC_COMMENT_TEXT          1008
#define IDC_COMMENT               1009
#define IDC_DRIVER                1010
#define IDC_HIDDEN_TEXT           1011

#define IDC_RANGE_ALL             rad1
#define IDC_RANGE_SELECTION       rad2
#define IDC_RANGE_CURRENT         rad3
#define IDC_RANGE_PAGES           rad4
#define IDC_RANGE_EDIT            edt1
#define IDC_RANGE_TEXT1           stc1
#define IDC_RANGE_TEXT2           stc2

#define IDC_COPIES                edt2
#define IDC_COPIES_TEXT           stc3
#define IDC_COLLATE               chx1

#define IDC_STATIC                -1


//
//  Typedef Declarations.
//

typedef struct
{
    UINT           ApiType;
    LPPRINTDLGEX   pPD;
    DWORD          ProcessVersion;
    DWORD          dwFlags;
    UINT           FinalResult;
    HRESULT        hResult;
    BOOL           fApply;
    BOOL           fOld;
    DWORD          dwExtendedError;
    HRESULT        hrOleInit;
    LPPRINTDLGEXA  pPDA;
    BOOL           fPrintTemplateAlloc;
} PRINTINFOEX, *PPRINTINFOEX;


//
//  Registry keys.
//
static const TCHAR c_szSettings[] = TEXT("Printers\\Settings");
static const TCHAR c_szViewMode[] = TEXT("ViewMode");




//
//  CPrintBrowser Class.
//

class CPrintBrowser : public IShellBrowser, 
                      public ICommDlgBrowser2, 
                      public IPrintDialogCallback, 
                      public IPrintDialogServices
{
public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) (THIS);
    STDMETHOD_(ULONG, Release) (THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND *lphwnd);
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode);

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject) (THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream) (THIS_ DWORD grfMode, LPSTREAM *pStrm);
    STDMETHOD(GetControlWindow) (THIS_ UINT id, HWND *lphwnd);
    STDMETHOD(SendControlMsg) (THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView) (THIS_ struct IShellView **ppshv);
    STDMETHOD(OnViewWindowActive) (THIS_ struct IShellView *pshv);
    STDMETHOD(SetToolbarItems) (THIS_ LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView *ppshv);
    STDMETHOD(OnStateChange) (THIS_ struct IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ struct IShellView *ppshv, LPCITEMIDLIST lpItem);
    STDMETHOD(Notify) (THIS_ struct IShellView *ppshv, DWORD dwNotifyType);
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView *ppshv, WCHAR *pszText, INT cchMax);
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS);
    STDMETHOD(SelectionChange) (THIS);
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult);

    // *** IPrintDialogServices methods ***
    STDMETHOD(GetCurrentDevMode) (THIS_ LPDEVMODE pDevMode, UINT *pcbSize);
    STDMETHOD(GetCurrentPrinterName) (THIS_ LPTSTR pPrinterName, UINT *pcchSize);
    STDMETHOD(GetCurrentPortName) (THIS_ LPTSTR pPortName, UINT *pcchSize);

    // *** Our own methods ***
    CPrintBrowser(HWND hDlg);
    ~CPrintBrowser();

    BOOL    OnInitDialog(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
    VOID    OnDestroyMessage();
    BOOL    OnCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnNotifyMessage(WPARAM wParam, LPNMHDR lpnmhdr);
    BOOL    OnSelChange();
    BOOL    OnChangeNotify(LONG lNotification, LPCITEMIDLIST *ppidl);
    BOOL    OnAccelerator(HWND hwndActivePrint, HWND hwndFocus, HACCEL haccPrint, PMSG pMsg);
    VOID    OnNoPrinters(HWND hDlg, HRESULT hr);
    VOID    OnInitDone();

private:

    HRESULT CreatePrintShellView();
    UINT    GetViewMode();
    VOID    SetViewMode();
    HRESULT CreateHookDialog();
    BOOL    UpdateStatus(LPCITEMIDLIST pidl);
    BOOL    SelectSVItem();
    BOOL    GetCurrentPrinter();
    VOID    InitPrintToFile();
    VOID    InitPageRangeGroup();
    VOID    InitCopiesAndCollate();
    BOOL    SaveCopiesAndCollateInDevMode(LPDEVMODE pDM, LPTSTR pszPrinter);
    BOOL    SetCopiesOnApply();
    VOID    SaveDevMode();
    BOOL    MergeDevMode(LPTSTR pszPrinterName);
    BOOL    IsValidPageRange(LPTSTR pszString, UINT *pErrorId);
    BOOL    ConvertPageRangesToString(LPTSTR pszString, UINT cchLen);
    UINT    IntegerToString(DWORD Value, LPTSTR pszString, UINT cchLen);
    VOID    ShowError(HWND hDlg, UINT uCtrlID, UINT uMsgID, ...);
    int     ShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, ...);
    int     InternalShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, va_list args);
    UINT    InsertDevicePage(LPCWSTR pszName, PDEVMODE pDevMode);
    UINT    RemoveDevicePage();
    UINT    RemoveAndInsertDevicePage(LPCWSTR pszName, PDEVMODE pDevMode);
    BOOL    FitViewModeBest(HWND hwndListView);
    VOID    SelectPrinterItem(LPITEMIDLIST pidlItem);
    BOOL    IsCurrentPrinter(LPCITEMIDLIST pidl);
    BOOL    OnRename(LPCITEMIDLIST *ppidl);

    //
    // These functions maintain the internal devmode, driver UI stuff and
    // implement the printui.dll functionality - bPrinterSetup(...).
    //
    BOOL FindPrinter(HWND hwnd, LPTSTR pszBuffer, UINT cchSize);
    BOOL GetInternalPrinterName(LPTSTR pszBuffer, DWORD *pdwSize);
    LPDEVMODE GetCurrentDevMode();
    HRESULT GetDefaultDevMode(HANDLE hPrinter, LPCTSTR pszPrinterName, PDEVMODE *ppDevMode);
    HRESULT WrapEnumPrinters(DWORD dwFlags, LPCTSTR pszServer, DWORD dwLevel, PVOID* ppvBuffer, PDWORD pcbBuffer, PDWORD pcPrinters);
    HRESULT GetUsablePrinter(LPTSTR szPrinterNameBuf, DWORD *pcchBuf);
    HRESULT GetInternalDevMode(PDEVMODE *ppOutDevMode, LPCTSTR pszPrinter, HANDLE hPrinter, PDEVMODE pInDevMode);
    HRESULT InstallDevMode(LPCTSTR pszPrinterName, PDEVMODE pDevModeToMerge);
    HRESULT UninstallDevMode();

    //
    // Members start here.
    //
    UINT cRef;                         // compobj refcount
    HWND hwndDlg;                      // handle of this dialog
    HWND hSubDlg;                      // handle of the hook dialog
    HWND hwndView;                     // current view window
    HWND hwndUpDown;                   // UpDown Control Window handle;
    IShellView *psv;                   // shell view object
    IShellFolderView *psfv;            // shell folder view object
    IShellFolder2 *psfRoot;            // print folder shell folder
    LPITEMIDLIST pidlRoot;             // pidl for print folder
    IPrinterFolder *ppf;               // printer folder private interface

    HIMAGELIST himl;                   // system imagelist (small images)

    PPRINTINFOEX pPI;                  // ptr to PRINTINFOEX struct
    LPPRINTDLGEX pPD;                  // caller's PRINTDLGEX struct

    IPrintDialogCallback *pCallback;   // ptr to app's callback interface
    IObjectWithSite *pSite;            // ptr to app's SetSite interface

    LPDEVMODE pDMInit;                 // ptr to the initial DEVMODE struct
    LPDEVMODE pDMCur;                  // ptr to the current DEVMODE struct
    LPDEVMODE pDMSave;                 // ptr to the last good DEVMODE struct

    UINT cchCurPrinter;                // size, in chars, of pszCurPrinter
    LPTSTR pszCurPrinter;              // ptr to name of current printer

    DWORD nCopies;                     // number of copies
    DWORD nMaxCopies;                  // max number for the "number of copies"
    DWORD nPageRanges;                 // number of page ranges in pPageRange
    DWORD nMaxPageRanges;              // max number of page ranges allowed
    LPPRINTPAGERANGE pPageRanges;      // ptr to an array of page range structs

    BOOL fCollateRequested;            // collate is requested
    BOOL fSelChangePending;            // we have a selchange message pending
    BOOL fFirstSel;                    // still need to set first selection
    BOOL fAPWSelected;                 // add printer wizard is selected
    BOOL fNoAccessPrinterSelected;     // a printer we do not have access to is selected
    BOOL fDirtyDevmode;                // Set if we change the devmode while editing.
    BOOL fDevmodeEdit;                 // devmode editor is open
    BOOL fAllowCollate;                // whether collation is allowed by the device

    UINT nInitDone;                    // number of CDM_INITDONE messages

    UINT nListSep;                     // number of characters in szListSep
    TCHAR szListSep[20];               // list separator

    UINT uRegister;                    // change notify register

    TCHAR szScratch[kPrinterBufMax];   // scratch buffer
    UINT uDefViewMode;                 // How the default view mode is mapped

    LPDEVMODE pInternalDevMode;        // ptr to the internal DEVMODE
    TCHAR szPrinter[kPrinterBufMax];   // The internal printer name
    HANDLE hPrinter;                   // The internal printer
};




//
//  Context Help IDs.
//

DWORD aPrintExHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_PRINTER_LISTVIEW,    IDH_PRINT_PRINTER_FOLDER,

    IDC_STATUS_TEXT,         IDH_PRINT_SETUP_DETAILS,
    IDC_STATUS,              IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION_TEXT,       IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION,            IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT_TEXT,        IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT,             IDH_PRINT_SETUP_DETAILS,

    IDC_PRINT_TO_FILE,       IDH_PRINT_TO_FILE,
    IDC_FIND_PRINTER,        IDH_PRINT_FIND_PRINTER,
    IDC_DRIVER,              IDH_PRINT_PREFERENCES,

    grp2,                    NO_HELP,
    IDOK,                    IDH_PRINT_BTN,

    0, 0
};


DWORD aPrintExChildHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_RANGE_ALL,           IDH_PRINT32_RANGE,
    IDC_RANGE_SELECTION,     IDH_PRINT32_RANGE,
    IDC_RANGE_CURRENT,       IDH_PRINT32_RANGE,
    IDC_RANGE_PAGES,         IDH_PRINT32_RANGE,
    IDC_RANGE_EDIT,          IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT1,         IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT2,         IDH_PRINT32_RANGE,

    grp2,                    NO_HELP,
    IDC_COPIES,              IDH_PRINT_COPIES,
    IDC_COPIES_TEXT,         IDH_PRINT_COPIES,
    IDC_COLLATE,             IDH_PRINT_COLLATE,
    IDI_COLLATE,             IDH_PRINT_COLLATE,

    0, 0
};




//
//  Function Prototypes.
//

HRESULT
PrintDlgExX(
    PPRINTINFOEX pPI);

HRESULT
Print_ReturnDefault(
    PPRINTINFOEX pPI);

BOOL
Print_LoadLibraries();

VOID
Print_UnloadLibraries();

BOOL
Print_LoadIcons();

BOOL
Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD);

BOOL_PTR
Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR
Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

BOOL
Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam);

HRESULT
Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID *ppv);

BOOL
Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD);

VOID
Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer);

HANDLE
Print_GetDevModeWrapper(
    LPTSTR pszDeviceName);

BOOL
Print_NewPrintDlg(
    PPRINTINFO pPI);


HRESULT
ThunkPrintDlgEx(
    PPRINTINFOEX pPI,
    LPPRINTDLGEXA pPDA);

VOID
FreeThunkPrintDlgEx(
    PPRINTINFOEX pPI);

VOID
ThunkPrintDlgExA2W(
    PPRINTINFOEX pPI);

VOID
ThunkPrintDlgExW2A(
    PPRINTINFOEX pPI);

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\srccpp.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(CCSHELL_DIR)\common.inc

TARGETNAME = srccpp
TARGETPATH = obj
TARGETTYPE = LIBRARY

SOURCES    = ..\filemru.cpp     \
             ..\filenew.cpp     \
             ..\printnew.cpp    \
             ..\d32tlog.cpp     \
             ..\util.cpp
	
INCLUDES=$(INCLUDES);$(PRINTSCAN_INC_PATH);$(NET_INC_PATH)

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\printnew.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.cpp

Abstract:

    This module implements the Win32 property sheet print dialogs.

Revision History:

    11-04-97    JulieB    Created.
    Feb-2000    LazarI    major redesign (not to use printui anymore)
    Oct-2000    LazarI    messages cleanup & redesign

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "prnsetup.h"
#include "printnew.h"
#include "util.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif // ARRAYSIZE

inline static HRESULT CreateError()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

//
//  Constant Declarations.
//

#define CDM_SELCHANGE             (CDM_LAST + 102)
#define CDM_PRINTNOTIFY           (CDM_LAST + 103)
#define CDM_NOPRINTERS            (CDM_LAST + 104)
#define CDM_INITDONE              (CDM_LAST + 105)

#define PRINTERS_ICOL_NAME        0
#define PRINTERS_ICOL_QUEUESIZE   1
#define PRINTERS_ICOL_STATUS      2
#define PRINTERS_ICOL_COMMENT     3
#define PRINTERS_ICOL_LOCATION    4
#define PRINTERS_ICOL_MODEL       5

#define SZ_PRINTUI                TEXT("printui.dll")

//
// Default view mode value
//
#define VIEW_MODE_DEFAULT         (UINT )(-1)

//
//  Macro Definitions.
//

#define Print_HwndToBrowser(hwnd)      ((CPrintBrowser *)GetWindowLongPtr(hwnd, DWLP_USER))
#define Print_StoreBrowser(hwnd, pbrs) (SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pbrs))
#define Print_IsInRange(id, idFirst, idLast) \
    ((UINT)((id) - idFirst) <= (UINT)(idLast - idFirst))




//
//  Global Variables.
//

HWND g_hwndActivePrint = NULL;
HACCEL g_haccPrint = NULL;
HHOOK g_hHook = NULL;
int g_nHookRef = -1;



//
//  Extern Declarations.
//

extern HWND
GetFocusedChild(
    HWND hwndDlg,
    HWND hwndFocus);

extern void
GetViewItemText(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPTSTR pBuf,
    UINT cchBuf,
    DWORD dwFlags);


// Frees up the PIDL using the shell allocator
static void FreePIDL(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        LPMALLOC pShellMalloc;
        if (SUCCEEDED(SHGetMalloc(&pShellMalloc)))
        {
            pShellMalloc->Free(pidl);
            pShellMalloc->Release();
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExA
//
//  ANSI entry point for PrintDlgEx when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgExA(
    LPPRINTDLGEXA pPDA)
{
    PRINTINFOEX PI;
    HRESULT hResult;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    hResult = ThunkPrintDlgEx(&PI, pPDA);
    if (SUCCEEDED(hResult))
    {
        ThunkPrintDlgExA2W(&PI);

        hResult = PrintDlgExX(&PI);

        ThunkPrintDlgExW2A(&PI);
    }
    FreeThunkPrintDlgEx(&PI);

    return (hResult);
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgEx
//
//  The PrintDlgEx function displays a Print dialog that enables the
//  user to specify the properties of a particular print job.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgEx(
    LPPRINTDLGEX pPD)
{
    PRINTINFOEX PI;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgExX(&PI) );
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExX
//
//  Worker routine for the PrintDlgEx api.
//
////////////////////////////////////////////////////////////////////////////

HRESULT PrintDlgExX(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    BOOL hResult;
    DWORD dwFlags;
    DWORD nCopies;
    LPPRINTPAGERANGE pPageRanges;
    DWORD nFromPage, nToPage;
    UINT Ctr;
    BOOL bHooked = FALSE;

    //
    //  Make sure the print dlg structure exists and that we're not being
    //  called from a wow app.
    //
    if ((!pPD) || (IS16BITWOWAPP(pPD)))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the size of the print dlg structure is valid.
    //
    if (pPD->lStructSize != sizeof(PRINTDLGEX))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the owner window exists and  is valid.
    //
    if (!pPD->hwndOwner || !IsWindow(pPD->hwndOwner))
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure only valid flags are passed into this routine.
    //
    if ((pPD->Flags & ~(PD_ALLPAGES                   |
                        PD_SELECTION                  |
                        PD_PAGENUMS                   |
                        PD_NOSELECTION                |
                        PD_NOPAGENUMS                 |
                        PD_COLLATE                    |
                        PD_PRINTTOFILE                |
                        PD_NOWARNING                  |
                        PD_RETURNDC                   |
                        PD_RETURNIC                   |
                        PD_RETURNDEFAULT              |
                        PD_ENABLEPRINTTEMPLATE        |
                        PD_ENABLEPRINTTEMPLATEHANDLE  |
                        PD_USEDEVMODECOPIESANDCOLLATE |
                        PD_DISABLEPRINTTOFILE         |
                        PD_HIDEPRINTTOFILE            |
                        PD_CURRENTPAGE                |
                        PD_NOCURRENTPAGE              |
                        PD_EXCLUSIONFLAGS             |
                        PD_USELARGETEMPLATE           |
                        CD_WX86APP)) ||
        (pPD->Flags2 != 0) ||
        (pPD->ExclusionFlags & ~(PD_EXCL_COPIESANDCOLLATE)) ||
        (pPD->dwResultAction != 0))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the template settings as much as we can here.
    //
    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
    {
        if (!pPD->lpPrintTemplateName)
        {
            pPI->dwExtendedError = CDERR_NOTEMPLATE;
            return (E_POINTER);
        }
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else
    {
        if (pPD->lpPrintTemplateName || pPD->hInstance)
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }
    }

    //
    //  Check the application property pages and the start page value.
    //
    if ((pPD->nPropertyPages && (pPD->lphPropertyPages == NULL)) ||
        ((pPD->nStartPage != START_PAGE_GENERAL) &&
         (pPD->nStartPage >= pPD->nPropertyPages)))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the page range boundaries if the PD_NOPAGENUMS flag is
    //  not set.
    //
    if (!(pPD->Flags & PD_NOPAGENUMS))
    {
        if ((pPD->nMinPage > pPD->nMaxPage) ||
            (pPD->nPageRanges > pPD->nMaxPageRanges) ||
            (pPD->nMaxPageRanges == 0) ||
            ((pPD->nMaxPageRanges) && (!pPD->lpPageRanges)))
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }

        //
        //  Check each of the given ranges.
        //
        pPageRanges = pPD->lpPageRanges;
        for (Ctr = 0; Ctr < pPD->nPageRanges; Ctr++)
        {
            //
            //  Get the range.
            //
            nFromPage = pPageRanges[Ctr].nFromPage;
            nToPage   = pPageRanges[Ctr].nToPage;

            //
            //  Make sure the range is valid.
            //
            if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
                (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                return (E_INVALIDARG);
            }
        }
    }

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

    //
    //  Init hDC.
    //
    pPD->hDC = 0;

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        return (Print_ReturnDefault(pPI));
    }

    //
    //  Load the necessary libraries.
    //
    if (!Print_LoadLibraries())
    {
        pPI->dwExtendedError = PDERR_LOADDRVFAILURE;
        hResult = CreateError();
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Load the necessary icons.
    //
    if (!Print_LoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        pPI->dwExtendedError = PDERR_SETUPFAILURE;
        hResult = CreateError();
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Make sure the page ranges info is valid.
    //
    if ((!(pPD->Flags & PD_NOPAGENUMS)) &&
        ((pPD->nMinPage > pPD->nMaxPage) ||
         (pPD->nPageRanges > pPD->nMaxPageRanges) ||
         (pPD->nMaxPageRanges == 0) ||
         ((pPD->nMaxPageRanges) && (!(pPD->lpPageRanges)))))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Save the original information passed in by the app in case the
    //  user hits cancel.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be saved.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    pPI->dwFlags = dwFlags;

    //
    //  Set up the hook proc for input event messages.
    //
    if (InterlockedIncrement((LPLONG)&g_nHookRef) == 0)
    {
        g_hHook = SetWindowsHookEx( WH_MSGFILTER,
                                    Print_MessageHookProc,
                                    0,
                                    GetCurrentThreadId() );
        if (g_hHook)
        {
            bHooked = TRUE;
        }
        else
        {
            --g_nHookRef;
        }
    }
    else
    {
        bHooked = TRUE;
    }

    //
    //  Load the print folder accelerators.
    //
    if (!g_haccPrint)
    {
        g_haccPrint = LoadAccelerators( g_hinst,
                                        MAKEINTRESOURCE(IDA_PRINTFOLDER) );
    }

    //
    //  Initialize the error codes to failure in case we die before we
    //  actually bring up the property pages.
    //
    pPI->dwExtendedError = CDERR_INITIALIZATION;
    pPI->hResult = E_FAIL;
    pPI->hrOleInit = E_FAIL;

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    //
    //  Bring up the dialog.
    //
    Print_InvokePropertySheets(pPI, pPD);

    hResult = pPI->hResult;


    //Ole Would have been initialized during the WM_INITDIALOG processing. 
    // Uninitialize Ole Now

    SHOleUninitialize(pPI->hrOleInit);

    //
    //  Unhook the input event messages.
    //
    if (bHooked)
    {
        //
        //  Put this in a local so we don't need a critical section.
        //
        HHOOK hHook = g_hHook;

        if (InterlockedDecrement((LPLONG)&g_nHookRef) < 0)
        {
            UnhookWindowsHookEx(hHook);
        }
    }

    //
    //  If the user hit cancel or if there was an error, restore the original
    //  values passed in by the app.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be restored here.
    //
    if ((pPI->FinalResult == 0) && (!pPI->fApply))
    {
        pPD->Flags   = dwFlags;
        pPD->nCopies = nCopies;
    }

    //
    //  See if we need to fill in the dwResultAction member field.
    //
    if (SUCCEEDED(hResult))
    {
        if (pPI->FinalResult != 0)
        {
            pPD->dwResultAction = PD_RESULT_PRINT;
        }
        else if (pPI->fApply)
        {
            pPD->dwResultAction = PD_RESULT_APPLY;
        }
        else
        {
            pPD->dwResultAction = PD_RESULT_CANCEL;
        }
    }

    //
    //  Display any error messages.
    //
PrintDlgExX_DisplayWarning:

    if ((!(dwFlags & PD_NOWARNING)) && FAILED(hResult) &&
        (pPI->ProcessVersion >= 0x40000))
    {
        TCHAR szWarning[SCRATCHBUF_SIZE];
        TCHAR szTitle[SCRATCHBUF_SIZE];
        int iszWarning;

        szTitle[0] = TEXT('\0');
        if (pPD->hwndOwner)
        {
            GetWindowText(pPD->hwndOwner, szTitle, ARRAYSIZE(szTitle));
        }
        if (!szTitle[0])
        {
            CDLoadString(g_hinst, iszWarningTitle, szTitle, ARRAYSIZE(szTitle));
        }

        switch (hResult)
        {
            case ( E_OUTOFMEMORY ) :
            {
                iszWarning = iszMemoryError;
                break;
            }
            default :
            {
                iszWarning = iszGeneralWarning;
                break;
            }
        }

        CDLoadString(g_hinst, iszWarning, szWarning, ARRAYSIZE(szWarning));
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox( pPD->hwndOwner,
                    szWarning,
                    szTitle,
                    MB_ICONEXCLAMATION | MB_OK );
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ReturnDefault
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ReturnDefault(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    TCHAR szPrinterName[MAX_PRINTERNAME];
    LPDEVNAMES pDN;
    LPDEVMODE pDM;

    //
    //  Initialize the error code to 0.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;

    //
    //  Make sure the hDevMode and hDevNames fields are NULL.
    //
    if (pPD->hDevMode || pPD->hDevNames)
    {
        pPI->dwExtendedError = PDERR_RETDEFFAILURE;
        return (E_HANDLE);
    }

    //
    //  Get the default printer name.
    //
    szPrinterName[0] = 0;
    PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
    if (szPrinterName[0] == 0)
    {
        pPI->dwExtendedError = PDERR_NODEFAULTPRN;
        return (E_FAIL);
    }

    //
    //  Allocate and fill in the DevNames structure.
    //
    if (!Print_SaveDevNames(szPrinterName, pPD))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return CreateError();
    }

    //
    //  Allocate and fill in the DevMode structure.
    //
    pPD->hDevMode = Print_GetDevModeWrapper(szPrinterName);

    //
    //  Get the device or information context, depending on which one
    //  was requested (if any).
    //
    if ((pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (S_OK);
        }
        else
        {
            GlobalUnlock(pPD->hDevNames);
        }
    }

    //
    //  Make sure the pointers are NULL since we failed.
    //
    if (pPD->hDevNames)
    {
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Return failure.
    //
    pPI->dwExtendedError = PDERR_NODEFAULTPRN;
    return (E_FAIL);
}

typedef BOOL (*PFN_bPrinterSetup)(
    HWND hwnd,                  // handle to parent window 
    UINT uAction,               // setup action
    UINT cchPrinterName,        // size of pszPrinterName buffer in characters
    LPTSTR pszPrinterName,      // in/out buffer for the printer name
    UINT *pcchPrinterName,      // out buffer where we put the required number of characters
    LPCTSTR  pszServerName      // server name
    );

typedef LONG (*PFN_DocumentPropertiesWrap)(
    HWND hwnd,                  // handle to parent window 
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    );

EXTERN_C CRITICAL_SECTION g_csLocal;
static HINSTANCE hPrintUI = NULL;
static PFN_bPrinterSetup g_pfnPrinterSetup = NULL;
static PFN_DocumentPropertiesWrap g_pfnDocumentPropertiesWrap = NULL;

////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadLibraries
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadLibraries()
{
    //
    // Make sure we hold the global CS while initializing 
    // the global variables.
    //
    EnterCriticalSection(&g_csLocal);

    //
    //  Load PrintUI.
    //
    if (!hPrintUI)
    {
        if ((hPrintUI = LoadLibrary(SZ_PRINTUI)))
        {
            //
            // Get the proc addresses of bPrinterSetup private API.
            //
            g_pfnPrinterSetup = (PFN_bPrinterSetup)GetProcAddress(hPrintUI, "bPrinterSetup");
            g_pfnDocumentPropertiesWrap = (PFN_DocumentPropertiesWrap)GetProcAddress(hPrintUI, "DocumentPropertiesWrap");

            if (NULL == g_pfnPrinterSetup || NULL == g_pfnDocumentPropertiesWrap)
            {
                // failed to get addresses of core printui APIs
                FreeLibrary(hPrintUI);
                hPrintUI = NULL;
            }
        }
    }

    //
    //  Leave the global CS.
    //
    LeaveCriticalSection(&g_csLocal);

    //
    //  Return the result.
    //
    return (hPrintUI != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_UnloadLibraries
//
////////////////////////////////////////////////////////////////////////////

VOID Print_UnloadLibraries()
{
    if (hPrintUI)
    {
        FreeLibrary(hPrintUI);
        hPrintUI = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadIcons()
{
    //
    //  Load the collation images.
    //
    hIconCollate = LoadImage( g_hinst,
                              MAKEINTRESOURCE(ICO_COLLATE),
                              IMAGE_ICON,
                              0,
                              0,
                              LR_SHARED);
    hIconNoCollate = LoadImage( g_hinst,
                                MAKEINTRESOURCE(ICO_NO_COLLATE),
                                IMAGE_ICON,
                                0,
                                0,
                               LR_SHARED);

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (hIconCollate && hIconNoCollate);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InvokePropertySheets
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD)
{
    BOOL bResult = FALSE;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszCaption[MAX_PATH];
    HANDLE hTemplate = NULL;
    HRSRC hRes;
    LANGID LangID;

    if (GET_BIDI_LOCALIZED_SYSTEM_LANGID(NULL)) {

        if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
        {
            hTemplate = pPD->hInstance;
        }
        else
        {
            if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
            {
                hRes = FindResource(pPD->hInstance, pPD->lpPrintTemplateName, RT_DIALOG);
                if (hRes) {
                    hTemplate = LoadResource(pPD->hInstance, hRes);
                }
            }
        }
        //
        // Warning! Warning! Warning!
        //
        // We have to set g_tlsLangID before any call for CDLoadString
        //
        TlsSetValue(g_tlsLangID, (LPVOID) GetDialogLanguage(pPD->hwndOwner, hTemplate));
    }

    //
    //  Load all of the necessary strings.
    //
    CDLoadString(g_hinst, iszGeneralPage, pszTitle, ARRAYSIZE(pszTitle));
    CDLoadString(g_hinst, iszPrintCaption, pszCaption, ARRAYSIZE(pszCaption));

    //
    //  See if the exclusion flags are set properly.
    //
    if (!(pPD->Flags & PD_EXCLUSIONFLAGS))
    {
        pPD->ExclusionFlags = PD_EXCL_COPIESANDCOLLATE;
    }

    //
    //  Set up the General page.
    //
    PROPSHEETPAGE genPage = {0};

    genPage.dwSize      = sizeof(PROPSHEETPAGE);
    genPage.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    genPage.hInstance   = g_hinst;
    genPage.pszTemplate = (pPD->Flags & PD_USELARGETEMPLATE) ? MAKEINTRESOURCE(IDD_PRINT_GENERAL_LARGE)
                                                               : MAKEINTRESOURCE(IDD_PRINT_GENERAL);
    LangID = (LANGID)TlsGetValue(g_tlsLangID);
    if (LangID) {
        hRes = FindResourceExFallback(g_hinst, RT_DIALOG, genPage.pszTemplate, LangID);
        if (hRes) {
            if ((hTemplate = LoadResource(g_hinst, hRes)) &&
                LockResource(hTemplate)) {
                genPage.dwFlags   |= PSP_DLGINDIRECT;
                genPage.pResource  = (LPCDLGTEMPLATE)hTemplate;
            }
        }
    }

    genPage.pszIcon     = NULL;
    genPage.pszTitle    = pszTitle;
    genPage.pfnDlgProc  = Print_GeneralDlgProc;
    genPage.lParam      = (LPARAM)pPI;
    genPage.pfnCallback = NULL;
    genPage.pcRefParent = NULL;

    HPROPSHEETPAGE hGenPage = CreatePropertySheetPage( &genPage );

    if( hGenPage )
    {
        //
        //  Initialize the property sheet header.
        //
        PROPSHEETHEADER psh = {0};
        psh.dwSize          = sizeof(psh);

        psh.dwFlags         = pPI->fOld ? PSH_USEICONID | PSH_NOAPPLYNOW  : PSH_USEICONID;
        psh.hwndParent      = pPD->hwndOwner;
        psh.hInstance       = g_hinst;
        psh.pszIcon         = MAKEINTRESOURCE(ICO_PRINTER);
        psh.pszCaption      = pszCaption;
        psh.nPages          = pPD->nPropertyPages + 1;

        psh.phpage          = new HPROPSHEETPAGE[ psh.nPages ];

        if( psh.phpage )
        {
            psh.phpage[0] = hGenPage;
            memcpy( psh.phpage+1, pPD->lphPropertyPages, pPD->nPropertyPages * sizeof(psh.phpage[0]) );

            //
            // Bring up the property sheet pages.
            //
            bResult = (-1 != PropertySheet(&psh));

            delete [] psh.phpage;
        }
        else
        {
            pPI->hResult = E_OUTOFMEMORY;
        }
    }
    else
    {
        pPI->hResult = CreateError();
    }

    //
    //  Return the result.
    //
    return (bResult);
}


LRESULT CALLBACK PrshtSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LRESULT lres;


    switch (wm)
    {
        case WM_NCDESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hwnd, PrshtSubclassProc, 0);
            lres = DefSubclassProc(hwnd, wm, wp, lp);
            break;

        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lp)->hItemHandle;

            if (hwndItem == GetDlgItem(hwnd, IDOK))
            {
                WinHelp( hwndItem,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aPrintExHelpIDs );

                lres = TRUE;
            }
            else
            {
                lres = DefSubclassProc(hwnd, wm, wp, lp);
            }

            break;

        }

        case ( WM_CONTEXTMENU ) :
        {
            if ((HWND)wp == GetDlgItem(hwnd, IDOK))
            {
                WinHelp( (HWND)wp,
                         NULL,
                         HELP_CONTEXTMENU,
                        (ULONG_PTR)(LPVOID)aPrintExHelpIDs );

                lres = TRUE;
            }
            else
            {
                lres = DefSubclassProc(hwnd, wm, wp, lp);
            }
            break;
        }

        default:
            lres = DefSubclassProc(hwnd, wm, wp, lp);
            break;
    }

    return lres;
}

////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CPrintBrowser *pDlgStruct = NULL;

    if (uMsg != WM_INITDIALOG)
    {
        pDlgStruct = Print_HwndToBrowser(hDlg);
    }

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Print_InitDialog(hDlg, wParam, lParam))
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
            g_hwndActivePrint = hDlg;

            //Subclass the Main Property sheet for Help Messages
            SetWindowSubclass(GetParent(hDlg), PrshtSubclassProc, 0, 0);
            break;
        }
        case ( WM_NCDESTROY ) :
        {
            Print_StoreBrowser(hDlg, NULL);

            if (pDlgStruct)
            {
                pDlgStruct->OnDestroyMessage();
                pDlgStruct->Release();
            }
            break;
        }
        case ( WM_ERASEBKGND ) :
        {
            //
            // This code is to workaround: Windows NT Bugs#344991
            //
            HWND hwndView = GetDlgItem(hDlg, IDC_PRINTER_LISTVIEW);
            if (hwndView)
            {
                //
                //  Get the printer folder view rect.
                //
                RECT rcView;
                if (GetWindowRect(hwndView, &rcView))
                {
                    MapWindowRect(HWND_DESKTOP, hDlg, &rcView);

                    //
                    // Exclude the printer folder view rect from the cliping region.
                    //
                    if (ERROR == ExcludeClipRect(reinterpret_cast<HDC>(wParam),
                        rcView.left, rcView.top, rcView.right, rcView.bottom))
                    {
                        ASSERT(FALSE);
                    }
                }
            }
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (wParam == WA_INACTIVE)
            {
                //
                //  Make sure some other Print dialog has not already grabbed
                //  the focus.  This is a process global, so it should not
                //  need to be protected.
                //
                if (g_hwndActivePrint == hDlg)
                {
                    g_hwndActivePrint = NULL;
                }
            }
            else
            {
                g_hwndActivePrint = hDlg;
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnNotifyMessage(wParam, (LPNMHDR)lParam));
            }
            break;
        }
        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;

            //
            //  We assume that the defview has one child window that
            //  covers the entire defview window.
            //
            HWND hwndDefView = GetDlgItem(hDlg, IDC_PRINTER_LISTVIEW);
            if (GetParent(hwndItem) == hwndDefView)
            {
                hwndItem = hwndDefView;
            }

            WinHelp( hwndItem,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( CWM_GETISHELLBROWSER ) :
        {
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LRESULT)pDlgStruct);
            return (TRUE);
        }
        case ( CDM_SELCHANGE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnSelChange();
            }
            break;
        }
        case ( CDM_PRINTNOTIFY ) :
        {
            if (pDlgStruct)
            {
                LPITEMIDLIST *ppidl;
                LONG lEvent;
                BOOL bRet = FALSE;
                LPSHChangeNotificationLock pLock;

                //
                //  Get the change notification info from the shared memory
                //  block identified by the handle passed in the wParam.
                //
                pLock = SHChangeNotification_Lock( (HANDLE)wParam,
                                                   (DWORD)lParam,
                                                   &ppidl,
                                                   &lEvent );
                if (pLock == NULL)
                {
                    return (FALSE);
                }

                //
                //  Handle the change notification.
                //
                bRet = pDlgStruct->OnChangeNotify( lEvent,
                                                   (LPCITEMIDLIST *)ppidl );

                //
                //  Release the shared block.
                //
                SHChangeNotification_Unlock(pLock);

                //
                //  Return the result.
                //
                return (bRet);
            }
            break;
        }
        case ( CDM_NOPRINTERS ) :
        {
            //
            //  There are no printers, so bring up the dialog telling the
            //  user that they need to install a printer.
            //
            if (pDlgStruct)
            {
                pDlgStruct->OnNoPrinters((HWND)wParam, (HRESULT)lParam);
            }
        }
        case ( CDM_INITDONE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnInitDone();
            }
            break;
        }

        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralChildDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lResult = FALSE;
    CPrintBrowser *pDlgStruct = Print_HwndToBrowser(GetParent(hDlg));

    //
    //  See if we need to call an application callback to handle the
    //  message.
    //
    if (pDlgStruct)
    {
        if (pDlgStruct->HandleMessage(hDlg, uMsg, wParam, lParam, &lResult) != S_FALSE)
        {
            if (uMsg == WM_INITDIALOG)
            {
                PostMessage(GetParent(hDlg), CDM_INITDONE, 0, 0);
            }

            // 
            // BUGBUG: The return from a dlgproc is different than a winproc.
            //

            return (BOOLFROMPTR(lResult));

        }
    }

    //
    //  If we get to this point, we need to handle the message.
    //
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (pDlgStruct)
            {
                if (!pDlgStruct->OnChildInitDialog(hDlg, wParam, lParam))
                {
                    PropSheet_PressButton( GetParent(GetParent(hDlg)),
                                           PSBTN_CANCEL );
                }
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnChildCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExChildHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExChildHelpIDs );

            return (TRUE);
        }
        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_MessageHookProc
//
//  Handles the input event messages.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    PMSG pMsg;

    //
    //  See if the nCode is negative.  If so, call the default hook proc.
    //
    if (nCode < 0)
    {
        return (DefHookProc(nCode, wParam, lParam, &g_hHook));
    }

    //
    //  Make sure we only handle dialog box messages.
    //
    if (nCode != MSGF_DIALOGBOX)
    {
        return (0);
    }

    //
    //  Get the msg structure.
    //
    pMsg = (PMSG)lParam;

    //
    //  Make sure the message is one of the WM_KEY* messages.
    //
    if (Print_IsInRange(pMsg->message, WM_KEYFIRST, WM_KEYLAST))
    {
        HWND hwndActivePrint = g_hwndActivePrint;
        HWND hwndFocus = GetFocusedChild(hwndActivePrint, pMsg->hwnd);
        CPrintBrowser *pDlgStruct;

        if (hwndFocus &&
            (pDlgStruct = Print_HwndToBrowser(hwndActivePrint)) != NULL)
        {
            return (pDlgStruct->OnAccelerator( hwndActivePrint,
                                               hwndFocus,
                                               g_haccPrint,
                                               pMsg ));
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InitDialog
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    //  Create the CPrintBrowser object and store it in DWL_USER.
    //
    CPrintBrowser *pDlgStruct = new CPrintBrowser(hDlg);
    if (pDlgStruct == NULL)
    {
        return (FALSE);
    }
    Print_StoreBrowser(hDlg, pDlgStruct);

    //
    //  Let the class function do the work.
    //
    return (pDlgStruct->OnInitDialog(wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ICoCreateInstance
//
//  Create an instance of the specified shell class.
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPCITEMIDLIST pidl,
    LPVOID *ppv)
{
    LPSHELLFOLDER pshf = NULL;
    HRESULT hres = E_FAIL;

    //
    //  Initialize the pointer to the shell view.
    //
    *ppv = NULL;

    //
    //  Get the IShellFolder interface to the desktop folder and then
    //  bind to it.  This is equivalent to calling CoCreateInstance
    //  with CLSID_ShellDesktop.
    //
    hres = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hres))
    {
        hres = pshf->BindToObject(pidl, NULL, riid, ppv);
        pshf->Release();
    }

    //
    //  Return the result.
    //
    return (hres);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_SaveDevNames
//
//  Saves the current devnames in the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD)
{
    TCHAR szPortName[MAX_PATH];
    TCHAR szPrinterName[MAX_PATH];
    DWORD cbDevNames;
    LPDEVNAMES pDN;

    //
    //  Get the port name.
    //
    szPortName[0] = 0;
    Print_GetPortName(pCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  Compute the size of the DevNames structure.
    //
    cbDevNames = lstrlen(szDriver) + 1 +
                 lstrlen(szPortName) + 1 +
                 lstrlen(pCurPrinter) + 1 +
                 DN_PADDINGCHARS;

    cbDevNames *= sizeof(TCHAR);
    cbDevNames += sizeof(DEVNAMES);

    //
    //  Allocate the new DevNames structure.
    //
    pDN = NULL;
    if (pPD->hDevNames)
    {
        HANDLE handle;

        handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

        //Check that realloc succeeded.
        if (handle)
        {
            pPD->hDevNames  = handle;
        }
        else
        {
            //Realloc didn't succeed. Free the memory occupied.
            GlobalFree(pPD->hDevNames);
            pPD->hDevNames = NULL;
        }
    }
    else
    {
        pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
    }

    //
    //  Fill in the DevNames structure with the appropriate information.
    //
    if ( (pPD->hDevNames) &&
         (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)) )
    {
        //
        //  Save the driver name - winspool.
        //
        pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
        StringCchCopy((LPTSTR)pDN + pDN->wDriverOffset, lstrlen(szDriver) + 1, szDriver);

        //
        //  Save the printer name.
        //
        pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
        StringCchCopy((LPTSTR)pDN + pDN->wDeviceOffset, lstrlen(pCurPrinter) + 1, pCurPrinter);

        //
        //  Save the port name.
        //
        pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pCurPrinter) + 1;
        StringCchCopy((LPTSTR)pDN + pDN->wOutputOffset, lstrlen(szPortName) + 1, szPortName);

        //
        //  Save whether or not it's the default printer.
        //
        if (pPD->Flags & PD_RETURNDEFAULT)
        {
            pDN->wDefault = DN_DEFAULTPRN;
        }
        else
        {
            szPrinterName[0] = 0;
            PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
            if (szPrinterName[0] && !lstrcmp(pCurPrinter, szPrinterName))
            {
                pDN->wDefault = DN_DEFAULTPRN;
            }
            else
            {
                pDN->wDefault = 0;
            }
        }

        //
        //  Unlock it.
        //
        GlobalUnlock(pPD->hDevNames);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetPortName
//
//  Gets the port name for the given printer and stores it in the
//  given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer)
{
    HANDLE hPrinter;
    DWORD cbPrinter = 0;
    PRINTER_INFO_2 *pPrinter = NULL;

    //
    //  Initialize the buffer.
    //
    if (!cchBuffer)
    {
        return;
    }
    pBuffer[0] = 0;

    //
    //  Open the current printer.
    //
    if (OpenPrinter(pCurPrinter, &hPrinter, NULL))
    {
        //
        //  Get the size of the buffer needed to hold the printer info 2
        //  information.
        //
        if (!GetPrinter( hPrinter,
                         2,
                         (LPBYTE)pPrinter,
                         cbPrinter,
                         &cbPrinter ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                //  Allocate a buffer to hold the printer info 2 information.
                //
                if (pPrinter = (PRINTER_INFO_2 *)LocalAlloc(LPTR, cbPrinter))
                {
                    //
                    //  Get the printer info 2 information.
                    //
                    if (GetPrinter( hPrinter,
                                    2,
                                    (LPBYTE)pPrinter,
                                    cbPrinter,
                                    &cbPrinter ))
                    {
                        //
                        //  Save the port name in the given buffer.
                        //
                        lstrcpyn(pBuffer, pPrinter->pPortName, cchBuffer);
                        pBuffer[cchBuffer - 1] = 0;
                    }
                }
            }
        }

        //
        //  Close the printer.
        //
        ClosePrinter(hPrinter);
    }

    //
    //  Free the printer info 2 information for the current printer.
    //
    if (pPrinter)
    {
        LocalFree(pPrinter);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetDevModeWrapper
//
//  Calls PrintGetDevMode.
//
////////////////////////////////////////////////////////////////////////////

HANDLE Print_GetDevModeWrapper(
    LPTSTR pszDeviceName)
{
    HANDLE hPrinter;
    HANDLE hDevMode = NULL;

    if (OpenPrinter(pszDeviceName, &hPrinter, NULL))
    {
        hDevMode = PrintGetDevMode(0, hPrinter, pszDeviceName, NULL);
        ClosePrinter(hPrinter);
    }

    //
    //  Return the handle to the devmode.
    //
    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_NewPrintDlg
//
//  Converts the old style pPD structure to the new one and then calls
//  the PrintDlgEx function.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_NewPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    PRINTINFOEX PIEx;
    PRINTDLGEX PDEx;
    PRINTPAGERANGE PageRange;
    HRESULT hResult;

    // PrintDlg did the following for the page ranges. Do the same thing for PrintDlgEx
    if (!(pPD->Flags & PD_PAGENUMS))
    {
        if (pPD->nFromPage != 0xFFFF)
        {
            if (pPD->nFromPage < pPD->nMinPage)
            {
                pPD->nFromPage = pPD->nMinPage;
            }
            else if (pPD->nFromPage > pPD->nMaxPage)
            {
                pPD->nFromPage = pPD->nMaxPage;
            }
        }
        if (pPD->nToPage != 0xFFFF)
        {
            if (pPD->nToPage < pPD->nMinPage)
            {
                pPD->nToPage = pPD->nMinPage;
            }
            else if (pPD->nToPage > pPD->nMaxPage)
            {
                pPD->nToPage = pPD->nMaxPage;
            }
        }
    }



    //
    //  Set up the PRINTINFOEX structure.
    //
    PIEx.ApiType = pPI->ApiType;
    PIEx.pPD     = &PDEx;
    PIEx.fOld    = TRUE;

    //
    //  Copy the page range.
    //
    PageRange.nFromPage = pPD->nFromPage;
    PageRange.nToPage   = pPD->nToPage;

    //
    //  Set up the PRINTDLGEX structure with the appropriate values from
    //  the PRINTDLG structure.
    //
    PDEx.lStructSize         = sizeof(PRINTDLGEX);
    PDEx.hwndOwner           = pPD->hwndOwner;
    PDEx.hDevMode            = pPD->hDevMode;
    PDEx.hDevNames           = pPD->hDevNames;
    PDEx.hDC                 = pPD->hDC;
    PDEx.Flags               = (pPD->Flags & ~(PD_SHOWHELP | PD_NONETWORKBUTTON)) |
                               (PD_NOCURRENTPAGE);
    PDEx.Flags2              = 0;
    PDEx.ExclusionFlags      = 0;
    PDEx.nPageRanges         = 1;
    PDEx.nMaxPageRanges      = 1;
    PDEx.lpPageRanges        = &PageRange;
    PDEx.nMinPage            = pPD->nMinPage;
    PDEx.nMaxPage            = pPD->nMaxPage;
    PDEx.nCopies             = pPD->nCopies;
    PDEx.hInstance           = pPD->hInstance;
    PDEx.lpCallback          = NULL;
    PDEx.lpPrintTemplateName = NULL;
    PDEx.nPropertyPages      = 0;
    PDEx.lphPropertyPages    = NULL;
    PDEx.nStartPage          = START_PAGE_GENERAL;
    PDEx.dwResultAction      = 0;

    //
    //  Since we're in the old dialog, allow the the hInstance to be
    //  non-NULL even if there is not a template.
    //
    if (!(pPD->Flags & (PD_ENABLEPRINTTEMPLATE | PD_ENABLEPRINTTEMPLATEHANDLE)))
    {
        PDEx.hInstance = NULL;
    }
    
    //
    //  Initialize the error code to 0.
    //
    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Call PrintDlgExX to bring up the dialog.
    //
    hResult = PrintDlgExX(&PIEx);

    //
    //  See if the call failed.  If so, store the error and return FALSE.
    //
    if (FAILED(hResult))
    {
        StoreExtendedError(PIEx.dwExtendedError);
        return (FALSE);
    }

    //
    //  The call succeeded, so convert the PRINTDLGEX structure back to
    //  the PRINTDLG structure if PD_RESULT_CANCEL is not set.
    //
    if (PDEx.dwResultAction != PD_RESULT_CANCEL)
    {
        pPD->hDevMode  = PDEx.hDevMode;
        pPD->hDevNames = PDEx.hDevNames;
        pPD->hDC       = PDEx.hDC;
        pPD->Flags     = PDEx.Flags & ~(PD_NOCURRENTPAGE);
        pPD->nFromPage = (WORD)PageRange.nFromPage;
        pPD->nToPage   = (WORD)PageRange.nToPage;
        pPD->nCopies   = (WORD)PDEx.nCopies;
    }

    //
    //  Return TRUE if the user hit Print.
    //
    if (PDEx.dwResultAction == PD_RESULT_PRINT)
    {
        return (TRUE);
    }

    //
    //  Return FALSE for cancel.
    //
    return (FALSE);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CPrintBrowser
//
//  CPrintBrowser constructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::CPrintBrowser(
    HWND hDlg)
    : cRef(1),
      hwndDlg(hDlg),
      hSubDlg(NULL),
      hwndView(NULL),
      hwndUpDown(NULL),
      psv(NULL),
      psfv(NULL),
      psfRoot(NULL),
      pidlRoot(NULL),
      ppf(NULL),
      pPI(NULL),
      pPD(NULL),
      pCallback(NULL),
      pSite(NULL),
      pDMInit(NULL),
      pDMCur(NULL),
      cchCurPrinter(0),
      pszCurPrinter(NULL),
      nCopies(1),
      nMaxCopies(1),
      nPageRanges(0),
      nMaxPageRanges(0),
      pPageRanges(NULL),
      fSelChangePending(FALSE),
      fFirstSel(1),
      fCollateRequested(FALSE),
      fAPWSelected(FALSE),
      fNoAccessPrinterSelected(FALSE),
      fDirtyDevmode(FALSE),
      fDevmodeEdit(FALSE),
      fAllowCollate(FALSE),
      nInitDone(0),
      nListSep(0),
      uRegister(0),
      uDefViewMode(VIEW_MODE_DEFAULT),
      pInternalDevMode(NULL),
      hPrinter(NULL)
{
    HMENU hMenu;

    hMenu = GetSystemMenu(hDlg, FALSE);
    DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_RESTORE,  MF_BYCOMMAND);

    szListSep[0] = 0;
    szScratch[0] = 0;
    szPrinter[0] = 0;

    pDMSave = (LPDEVMODE)GlobalAlloc(GPTR, sizeof(DEVMODE));

    Shell_GetImageLists(NULL, &himl);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::~CPrintBrowser
//
//  CPrintBrowser destructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::~CPrintBrowser()
{
    //
    //  Deregister notifications.
    //
    if (uRegister)
    {
        SHChangeNotifyDeregister(uRegister);
        uRegister = 0;
    }

    //
    //  Release the printer folder private interface.
    //
    if (ppf != NULL)
    {
        ppf->Release();
        ppf = NULL;
    }

    //
    //  Release the printer shell folder.
    //
    if (psfRoot != NULL)
    {
        psfRoot->Release();
        psfRoot = NULL;
    }

    //
    //  Free the pidl.
    //
    if (pidlRoot != NULL)
    {
        SHFree(pidlRoot);
        pidlRoot = NULL;
    }

    //
    //  Free the devmodes.
    //
    if (pDMInit)
    {
        GlobalFree(pDMInit);
        pDMInit = NULL;
    }
    if (pDMSave)
    {
        GlobalFree(pDMSave);
        pDMSave = NULL;
    }

    //
    //  Free the current printer buffer.
    //
    cchCurPrinter = 0;
    if (pszCurPrinter)
    {
        GlobalFree(pszCurPrinter);
        pszCurPrinter = NULL;
    }

    //
    //  Free the page range.
    //
    nPageRanges = 0;
    nMaxPageRanges = 0;
    if (pPageRanges)
    {
        GlobalFree(pPageRanges);
        pPageRanges = NULL;
    }

    if (pInternalDevMode)
    {
        GlobalFree(pInternalDevMode);
        pInternalDevMode = NULL;
    }

    if (hPrinter)
    {
        ClosePrinter(hPrinter);
        hPrinter = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryInterface
//
//  Standard OLE2 style methods for this object.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IShellBrowser) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellBrowser *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser2))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_IPrintDialogServices))
    {
        *ppvObj = (IPrintDialogServices *)this;
        ++cRef;
        return (S_OK);
    }

    *ppvObj = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::AddRef
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::AddRef()
{
    return (++cRef);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Release
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::Release()
{
    cRef--;
    if (cRef > 0)
    {
        return (cRef);
    }

    delete this;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetWindow(
    HWND *phwnd)
{
    *phwnd = hwndDlg;
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ContextSensitiveHelp
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::ContextSensitiveHelp(
    BOOL fEnable)
{
    //
    //  Shouldn't need in a common dialog.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InsertMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::InsertMenusSB(
    HMENU hmenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetMenuSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetMenuSB(
    HMENU hmenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::RemoveMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::RemoveMenusSB(
    HMENU hmenuShared)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetStatusTextSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetStatusTextSB(
    LPCOLESTR pwch)
{
    //
    //  We don't have any status bar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::EnableModelessSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::EnableModelessSB(
    BOOL fEnable)
{
    //
    //  We don't have any modeless window to be enabled/disabled.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::TranslateAcceleratorSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::TranslateAcceleratorSB(
    LPMSG pmsg,
    WORD wID)
{
    //
    //  We don't use the  Key Stroke.
    //
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::BrowseObject
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::BrowseObject(
    LPCITEMIDLIST pidl,
    UINT wFlags)
{
    //
    //  We don't support browsing, or more precisely, CDefView doesn't.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewStateStream
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewStateStream(
    DWORD grfMode,
    LPSTREAM *pStrm)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetControlWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetControlWindow(
    UINT id,
    HWND *lphwnd)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SendControlMsg
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SendControlMsg(
    UINT id,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pret)
{
    LRESULT lres = 0;

    if (pret)
    {
        *pret = lres;
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryActiveShellView
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::QueryActiveShellView(
    LPSHELLVIEW *ppsv)
{
    if (psv)
    {
        *ppsv = psv;
        psv->AddRef();
        return (S_OK);
    }

    *ppsv = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnViewWindowActive
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnViewWindowActive(
    LPSHELLVIEW psv)
{
    //
    //  No need to process this. We don't do menus.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetToolbarItems
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetToolbarItems(
    LPTBBUTTON lpButtons,
    UINT nButtons,
    UINT uFlags)
{
    //
    //  We don't let containers customize our toolbar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDefaultCommand
//
//  Process a double-click or Enter keystroke in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnDefaultCommand(
    struct IShellView *ppshv)
{
    //
    //  Make sure it's the correct shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  See if the Add Printer Wizard is selected.
    //
    if (fAPWSelected)
    {
        //
        //  Invoke the Add Printer Wizard (modeless).
        //
        InvokeAddPrinterWizardModal(hwndDlg, NULL);
    }
    else if (fNoAccessPrinterSelected)
    {
        //
        // Display error message indicated we do not have access.
        //
        ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterAccess);
    }
    else
    {
        //
        //  Simulate the pressing of the OK button.
        //
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
    }

    //
    //  Tell the shell that the action has been processed.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnStateChange
//
//  Process selection change in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnStateChange(
    struct IShellView *ppshv,
    ULONG uChange)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (uChange)
    {
        case ( CDBOSC_SETFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_KILLFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_SELCHANGE ) :
        {
            //
            //  Post one of these messages, since we seem to get a whole
            //  bunch of them.
            //
            if (!fSelChangePending)
            {
                fSelChangePending = TRUE;
                PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
            }

            break;
        }
        case ( CDBOSC_RENAME ) :
        {
            break;
        }
        default :
        {
            return (E_NOTIMPL);
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IncludeObject
//
//  Tell the view control which objects to include in its enumerations.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::IncludeObject(
    struct IShellView *ppshv,
    LPCITEMIDLIST pidl)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If we have the printer folder private interface, return ok only
    //  if it's a printer.
    //
    if (ppf)
    {
        return (ppf->IsPrinter(pidl) ? S_OK : S_FALSE);
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Notify
//
//  Notification to decide whether or not a printer should be selected.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::Notify(
    struct IShellView *ppshv,
    DWORD dwNotify)
{
    HRESULT hr = S_OK;

    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (dwNotify)
    {
        case (CDB2N_CONTEXTMENU_DONE):
        {
            HWND hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);
            if (hwndListView)
            {
                HWND hwndEdit = ListView_GetEditControl(hwndListView);
                if (NULL == hwndEdit)
                {
                    // if not in edit mode then re-select the current item
                    SelectSVItem();
                }
            }
            break;
        }

        default:
        {
            hr = S_FALSE;
            break;
        }
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (hr);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetDefaultMenuText
//
//  Returns the default menu text.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetDefaultMenuText(
    struct IShellView *ppshv,
    WCHAR *pszText,
    INT cchMax)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If the add printer wizard is the selected item, do not change
    //  the default menu text.
    //
    if (fAPWSelected)
    {
        return (S_FALSE);
    }

    //
    //  Change the default menu text from 'Select' to 'Print'.
    //
    if (!CDLoadString(g_hinst, iszDefaultMenuText, szScratch, ARRAYSIZE(szScratch)))
    {
        return (E_FAIL);
    }

    //
    //  Just copy the default menu text to the provided buffer if there
    //  is room.
    //
    if (lstrlen(szScratch) < cchMax)
    {
        lstrcpyn(pszText, szScratch, cchMax);
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewFlags
//
//  Returns Flags to customize the view .
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewFlags(DWORD *pdwFlags)
{
    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return S_OK;
}




////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitDone
//
//  Notifies the sub dialog that initialization of the General page is
//  complete.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::InitDone()
{
    HRESULT hResult = S_FALSE;

    //
    //  Notify the sub dialog that initialization is complete.
    //
    if (pCallback)
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }

        hResult = pCallback->InitDone();

        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectionChange
//
//  Notifies the sub dialog that a selection change has taken place.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::SelectionChange()
{
    HRESULT hResult = S_FALSE;

    //
    //  Handle the Print To File here.
    //
    InitPrintToFile();

    //
    //  Notify the sub dialog that a selection change has taken place.
    //
    if (pCallback)
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }

        hResult = pCallback->SelectionChange();

        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
    }

    //
    //  Handle the selection change.
    //
    if (hResult == S_FALSE)
    {
        //
        //  Handle copies and collate.
        //
        InitCopiesAndCollate();

        //
        //  Handle the page ranges.
        //
        InitPageRangeGroup();

        //
        //  Return success.
        //
        hResult = S_OK;
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::HandleMessage
//
//  Process a message for the child window by calling the application
//  callback function.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::HandleMessage(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pResult)
{
    HRESULT hResult = S_FALSE;
    BOOL bTest;
    UINT nRet, ErrorId;
    DWORD nTmpCopies;

    //
    //  Initialize the return value.
    //
    *pResult = FALSE;

    //
    //  See if the message should be handled.
    //
    if (pCallback)
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }

        hResult = pCallback->HandleMessage(hDlg, uMsg, wParam, lParam, pResult);

        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
    }

    //
    //  Handle the message.
    //
    if ((hResult == S_FALSE) && (uMsg == WM_NOTIFY))
    {
        switch (((LPNMHDR)lParam)->code)
        {
            case ( PSN_KILLACTIVE ) :
            {
                //
                //  Make sure the page has valid entries.
                //  If invalid entries are found, then set the DWL_MSGRESULT
                //  of the General page to be TRUE and return TRUE in order
                //  to prevent the page from losing the activation.
                //

                //
                //  Validate the number of copies and store it in the
                //  nCopies member.
                //
                if ((GetDlgItem(hSubDlg, IDC_COPIES)) &&
                    (fAPWSelected == FALSE))
                {
                    nTmpCopies = nCopies;
                    nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                    if (!bTest || !nCopies)
                    {
                        nCopies = nTmpCopies;
                        ShowError(hSubDlg, IDC_COPIES, iszCopiesZero);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Validate the page range and store it in the pRange member.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES) &&
                    GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                {
                    nRet = GetDlgItemText( hSubDlg,
                                           IDC_RANGE_EDIT,
                                           szScratch,
                                           ARRAYSIZE(szScratch) );
                    ErrorId = iszBadPageRange;
                    if (!nRet || !IsValidPageRange(szScratch, &ErrorId))
                    {
                        ShowError(hSubDlg,
                                  IDC_RANGE_EDIT,
                                  ErrorId,
                                  (ErrorId == iszTooManyPageRanges)
                                    ? nMaxPageRanges
                                    : pPD->nMinPage,
                                  pPD->nMaxPage);

                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
            case ( PSN_APPLY ) :
            {
                //
                //  Clear the flags that need to be set based on the
                //  contents of the General page.
                //
                pPD->Flags &= ~((DWORD)( PD_PAGENUMS    |
                                         PD_SELECTION   |
                                         PD_CURRENTPAGE ));

                //
                //  Save the page range information.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_SELECTION))
                {
                    pPD->Flags |= PD_SELECTION;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_CURRENT))
                {
                    pPD->Flags |= PD_CURRENTPAGE;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES))
                {
                    pPD->Flags |= PD_PAGENUMS;

                    //
                    //  Copy the page ranges to the pPageRanges structure
                    //  in the PrintDlg structure.
                    //
                    if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                    {
                        pPD->nPageRanges = nPageRanges;
                        CopyMemory( pPD->lpPageRanges,
                                    pPageRanges,
                                    nPageRanges * sizeof(PRINTPAGERANGE) );
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
        }
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentDevMode
//
//  Returns the current devmode structure.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentDevMode(
    LPDEVMODE pDevMode,
    UINT *pcbSize)
{
    UINT cbSize;

    //
    //  Make sure pcbSize is valid.
    //
    if ((pcbSize == NULL) || (*pcbSize && !pDevMode))
    {
        return (E_INVALIDARG);
    }

    //
    //  When there is no current devmode, set the size to zero and return
    //  TRUE.
    //
    if (!pDMCur)
    {
        *pcbSize = 0;
        return (S_OK);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //

    GetCurrentPrinter();

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcbSize == 0)
    {
        //
        //  Return the size of the buffer needed.
        //
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
        }
        else
        {
            *pcbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
        }
    }
    else
    {
        //
        //  Make sure the copies and collate information is up to date.
        //
        SaveCopiesAndCollateInDevMode(pDMCur, pszCurPrinter);

        //
        //  Return the devmode information as well as the size of the
        //  buffer.
        //
        if (pPI->ApiType == COMDLG_ANSI)
        {
            cbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            ThunkDevModeW2A(pDMCur, (LPDEVMODEA)pDevMode);
            *pcbSize = cbSize;
        }
        else
        {
            cbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            CopyMemory(pDevMode, pDMCur, cbSize);
            *pcbSize = cbSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinterName
//
//  Returns the current printer name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPrinterName(
    LPTSTR pPrinterName,
    UINT *pcchSize)
{
    UINT cchSize;

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPrinterName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             pszCurPrinter,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
        {
            *pcchSize = lstrlen(pszCurPrinter) + 1;
        }
    }
    else
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = SHUnicodeToAnsi(pszCurPrinter,(LPSTR)pPrinterName,*pcchSize);

            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
        {
            cchSize = lstrlen(pszCurPrinter) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            StringCchCopy(pPrinterName, cchSize, pszCurPrinter);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPortName
//
//  Returns the current port name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPortName(
    LPTSTR pPortName,
    UINT *pcchSize)
{
    UINT cchSize;
    TCHAR szPortName[MAX_PATH];

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPortName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  Get the port name for the current printer.
    //
    szPortName[0] = 0;
    Print_GetPortName(pszCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             szPortName,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
        {
            *pcchSize = lstrlen(szPortName) + 1;
        }
    }
    else
    {
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = SHUnicodeToAnsi(szPortName,(LPSTR)pPortName,*pcchSize);

            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
        {
            cchSize = lstrlen(szPortName) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            StringCchCopy(pPortName, cchSize, szPortName);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDialog
//
//  Process a WM_INITDIALOG message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnInitDialog(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    HRESULT hrDevMode;
    HRESULT hResult;
    SHChangeNotifyEntry fsne;

    // 
    // If disable printer addition policy is set then 
    // then disable find button on the print dialog
    //
    if( SHRestricted(REST_NOPRINTERADD) )
    {
        EnableWindow( GetDlgItem( hwndDlg, IDC_FIND_PRINTER ), FALSE );
    }

    //
    // Always disable the preferences button in the begining
    //
    EnableWindow( GetDlgItem( hwndDlg, IDC_DRIVER ), FALSE );

    //
    //  Get the pointer to the PRINTINFOEX structure from the lParam of
    //  the property sheet structure.
    //
    pPI = (PPRINTINFOEX)((LPPROPSHEETPAGE)lParam)->lParam;
    pPD = pPI->pPD;

    //Initialize Ole Before doing anything
    pPI->hrOleInit = SHOleInitialize(0);

    DEBUG_CODE(GdiSetBatchLimit(1));
    //
    //  Initialize the error codes to success now that we have the
    //  pPI structure.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;
    pPI->hResult = S_OK;

    //
    //  Create the printer folder shell view.
    //
    hResult = CreatePrintShellView();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Insert the device pages for the appropriate printer.
    //
    //  First:  Try the printer in the DevMode.
    //  Second: Try the printer in the DevNames.
    //  Third:  Use the default by passing in NULLs.
    //
    hrDevMode = E_FAIL;
    if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
    {
        DWORD cbSize = (DWORD)(pDM->dmSize + pDM->dmDriverExtra);

        if (cbSize >= sizeof(DEVMODE) && (pDMInit = (LPDEVMODE)GlobalAlloc(GPTR, cbSize)))
        {
            CopyMemory(pDMInit, pDM, cbSize);
            hrDevMode = InstallDevMode((LPTSTR)pDM->dmDeviceName, pDMInit);
        }

        GlobalUnlock(pPD->hDevMode);
    }

    if ((FAILED(hrDevMode)) &&
        (pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        LPTSTR pPrinter = (LPTSTR)pDN + pDN->wDeviceOffset;

        hrDevMode = InstallDevMode(pPrinter, pDMInit);
        GlobalUnlock(pPD->hDevNames);
    }

    if (FAILED(hrDevMode))
    {
        hrDevMode = InstallDevMode(NULL, pDMInit);
    }

    //
    //  Get the current printer name and the current devmode.
    //
    GetCurrentPrinter();

    //
    //  Initialize the "Print to file" check box appropriately.
    //
    if (hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hwndDlg, IDC_PRINT_TO_FILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    //
    //  Set the number of copies and the collation correctly.
    //
    pDM = pDMInit ? pDMInit : pDMCur;

    if (pDMCur && (pDMCur->dmFields & DM_COPIES))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            pPD->nCopies = (DWORD)pDM->dmCopies;
        }
        else if (pPD->nCopies)
        {
            pDMCur->dmCopies = (short)pPD->nCopies;
        }
    }

    if (pDMCur && (pDMCur->dmFields & DM_COLLATE))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            if (pDM->dmCollate == DMCOLLATE_FALSE)
            {
                pPD->Flags &= ~PD_COLLATE;
            }
            else
            {
                pPD->Flags |= PD_COLLATE;
            }
        }
        else
        {
            pDMCur->dmCollate = (pPD->Flags & PD_COLLATE)
                                    ? DMCOLLATE_TRUE
                                    : DMCOLLATE_FALSE;
        }
    }
    if (pPD->Flags & PD_COLLATE)
    {
        fCollateRequested = TRUE;
    }

    //
    //  Create the hook dialog.
    //
    hResult = CreateHookDialog();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Set the ClipChildren style bit on the main dialog so that we get
    //  proper repainting of the various children in the General page.
    //
    SetWindowLong( GetParent(hwndDlg),
                   GWL_STYLE,
                   GetWindowLong(GetParent(hwndDlg), GWL_STYLE) | WS_CLIPCHILDREN );

    //
    //  Set the OK button to Print.
    //
    CDLoadString(g_hinst, iszPrintButton, szScratch, ARRAYSIZE(szScratch));
    SetDlgItemText(GetParent(hwndDlg), IDOK, szScratch);

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Register change notifications.
    //
    if (pidlRoot)
    {
        fsne.pidl = pidlRoot;
        fsne.fRecursive = FALSE;

        uRegister = SHChangeNotifyRegister(
                        hwndDlg,
                        SHCNRF_NewDelivery | SHCNRF_ShellLevel |
                            SHCNRF_InterruptLevel,
                        SHCNE_ATTRIBUTES | SHCNE_UPDATEITEM | SHCNE_CREATE |
                            SHCNE_DELETE | SHCNE_RENAMEITEM,
                        CDM_PRINTNOTIFY,
                        1,
                        &fsne );
    }

    //
    // If we failed to insert the device page then tell the 
    // user what is wrong. 
    //
    if (FAILED(hrDevMode) || !pDMCur)
    {
        //
        // Something has failed. Show an error message.
        //
        PostMessage(hwndDlg, CDM_NOPRINTERS, (WPARAM)hwndDlg, (LPARAM)hrDevMode);
    }

    //
    //  Give the application the pointer to the IPrintDialogServices
    //  interface.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pSite);
        if (pSite)
        {
            pSite->SetSite((IPrintDialogServices *)this);
        }
    }

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildInitDialog
//
//  Process a WM_INITDIALOG message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD wCheckID;
    HWND hCtl;

    //
    //  Save the handle to the child window.
    //
    hSubDlg = hDlg;

    //
    //  Get the list separator for the current user locale.
    //
    nListSep = GetLocaleInfo( LOCALE_USER_DEFAULT,
                              LOCALE_SLIST,
                              szListSep,
                              ARRAYSIZE(szListSep) );
    if (nListSep == 0)
    {
        szListSep[0] = TEXT(',');
        szListSep[1] = 0;
        nListSep = 2;
    }
    nListSep--;

    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, MAX_COPIES);
    SetDlgItemInt(hSubDlg, IDC_COPIES, pPD->nCopies, FALSE);
    nCopies = pPD->nCopies;

    if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
        (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE))
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        hwndUpDown = CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hSubDlg,
                             IDC_COPIES_UDARROW,
                             g_hinst,
                             hCtl,
                             MAX_COPIES,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the 
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth(hSubDlg, hCtl);
    }

    //
    //  Make sure the collate icon is centered.  Only want to do this once.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    //
    //  Initialize the copies and collate info.
    //
    InitCopiesAndCollate();

    //
    //  Set the page range.
    //
    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT1), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT2), FALSE);

        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  See if the page range only consists of one page.  If so,
        //  disable the Pages radio button and the associated edit control
        //  and disable and hide the collate check box.
        //
        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);

            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            fCollateRequested = FALSE;
            EnableWindow(GetDlgItem(hSubDlg, IDC_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hSubDlg, IDC_COLLATE), SW_HIDE);
        }
        else
        {
            //
            //  Initialize the page range members.
            //
            nPageRanges = pPD->nPageRanges;
            nMaxPageRanges = pPD->nMaxPageRanges;
            pPageRanges = (LPPRINTPAGERANGE)
                          GlobalAlloc(GPTR, nMaxPageRanges * sizeof(PRINTPAGERANGE));
            if (!pPageRanges)
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = E_OUTOFMEMORY;
                return (FALSE);
            }
            CopyMemory( pPageRanges,
                        pPD->lpPageRanges,
                        nPageRanges * sizeof(PRINTPAGERANGE) );

            //
            //  See if we should only accept a single page range.
            //
            if (nMaxPageRanges == 1)
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }
            else
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }

            //
            //  Validate the page ranges.
            //
            if (!ConvertPageRangesToString(szScratch, ARRAYSIZE(szScratch)))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                pPI->hResult = E_INVALIDARG;
                return (FALSE);
            }

            //
            //  Put the page range string in the edit control.
            //
            if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
            {
                SetDlgItemText(hSubDlg, IDC_RANGE_EDIT, szScratch);
            }
        }
    }

    //
    //  See if we should disable the Selection radio button.
    //
    if (pPD->Flags & PD_NOSELECTION)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_SELECTION))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    //
    //  See if we should disable the Current Page radio button.
    //
    if (pPD->Flags & PD_NOCURRENTPAGE)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_CURRENT))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_CURRENTPAGE);
    }

    //
    //  Choose one of the page range radio buttons.
    //
    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = IDC_RANGE_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = IDC_RANGE_SELECTION;
    }
    else if (pPD->Flags & PD_CURRENTPAGE)
    {
        wCheckID = IDC_RANGE_CURRENT;
    }
    else    // PD_ALL
    {
        wCheckID = IDC_RANGE_ALL;
    }
    CheckRadioButton(hSubDlg, IDC_RANGE_ALL, IDC_RANGE_PAGES, (int)wCheckID);

    //
    //  See if the collate check box should be checked or not.
    //
    if (pPD->Flags & PD_COLLATE)
    {
        CheckDlgButton(hSubDlg, IDC_COLLATE, TRUE);
    }

    //
    //  Display the appropriate collate icon.
    //
    if ((GetWindowLong( GetDlgItem(hSubDlg, IDC_COLLATE),
                        GWL_STYLE ) & WS_VISIBLE) &&
        (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)))
    {
        ShowWindow(hCtl, SW_HIDE);
        SendMessage( hCtl,
                     STM_SETICON,
                     IsDlgButtonChecked(hSubDlg, IDC_COLLATE)
                         ? (LONG_PTR)hIconCollate
                         : (LONG_PTR)hIconNoCollate,
                     0L );
        ShowWindow(hCtl, SW_SHOW);
    }

    //
    //  Save the flags as they are now so I know what to enable
    //  when the selection changes from the Add Printer Wizard icon.
    //
    pPI->dwFlags = pPD->Flags;
    if (pPD->nMinPage == pPD->nMaxPage)
    {
        pPI->dwFlags |= PD_NOPAGENUMS;
    }

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDestroyMessage
//
//  Process a WM_DESTROY message for the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnDestroyMessage()
{
    if (psfv)
    {
        psfv->Release();
        psfv = NULL;
    }
    if (psv)
    {
        psv->DestroyViewWindow();
        psv->Release();
        psv = NULL;
    }
    if (pCallback)
    {
        pCallback->Release();
        pCallback = NULL;
    }
    if (pSite)
    {
        pSite->SetSite(NULL);
        pSite->Release();
        pSite = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnCommandMessage
//
//  Process a WM_COMMAND message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case ( IDC_DRIVER ) :
        {
            //
            //  Show the driver UI calling DocumentProperties API.
            //
            if (pInternalDevMode)
            {
                DWORD dwSize = pInternalDevMode->dmSize + pInternalDevMode->dmDriverExtra;

                //
                // Allocate memory for the in/out devmodes and open separate temp printer handle.
                //
                LPDEVMODE pDevModeIn = (LPDEVMODE)GlobalAlloc(GPTR, dwSize);
                LPDEVMODE pDevModeOut = (LPDEVMODE)GlobalAlloc(GPTR, dwSize);
                HANDLE hTempPrinter = NULL;

                if (pDevModeIn && pDevModeOut && OpenPrinter((LPTSTR)szPrinter, &hTempPrinter, NULL))
                {
                    //
                    // Call DocumentProperties API to allow the user to edit the devmode.
                    //
                    fDirtyDevmode = FALSE;
                    memcpy(pDevModeIn, pInternalDevMode, dwSize);
                    memcpy(pDevModeOut, pInternalDevMode, dwSize);

                    //
                    // Update current copy and collation settings to DEVMODE before calling DocumentProperties()
                    //
                    pDevModeIn->dmCopies = nCopies;
                    pDevModeIn->dmCollate = fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE;

                    fDevmodeEdit = TRUE;
                    LONG lResult = g_pfnDocumentPropertiesWrap(hwndDlg, hTempPrinter, szPrinter, pDevModeOut, 
                        pDevModeIn, DM_IN_BUFFER|DM_OUT_BUFFER|DM_IN_PROMPT|DM_OUT_DEFAULT, pPD->ExclusionFlags);
                    fDevmodeEdit = FALSE;

                    if (IDOK == lResult)
                    {
                        //
                        // Check if there is a change after the editing.
                        //
                        if (!fDirtyDevmode && pInternalDevMode && memcmp(pDevModeOut, pInternalDevMode, dwSize))
                        {
                            //
                            // Refresh the copies and collation in case of change in Preferences...
                            // We simulate a BN_CLICKED message since we need to refresh the collation icon
                            // when we change the collation settings.
                            //
                            if (nCopies != pDevModeOut->dmCopies)
                            {
                                SetDlgItemInt(hSubDlg, IDC_COPIES, pDevModeOut->dmCopies, FALSE);
                            }

                            if ((fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE) ^ pDevModeOut->dmCollate)
                            {
                                CheckDlgButton(hSubDlg, IDC_COLLATE, pDevModeOut->dmCollate ? BST_CHECKED : BST_UNCHECKED);
                                SendMessage(hSubDlg, WM_COMMAND, MAKEWPARAM(IDC_COLLATE ,BN_CLICKED), (LPARAM)GetDlgItem(hSubDlg, IDC_COLLATE));
                            }
                            
                            //
                            // The internal devmode has been changed. Update it and enable the "Apply" button.
                            //
                            memcpy(pInternalDevMode, pDevModeOut, dwSize);
                            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                        }
                    }
                }

                //
                // Release the allocated resources.
                //
                if (pDevModeIn)
                {
                    GlobalFree((HANDLE)pDevModeIn);
                }

                if (pDevModeOut)
                {
                    GlobalFree((HANDLE)pDevModeOut);
                }

                if (hTempPrinter)
                {
                    ClosePrinter(hTempPrinter);
                }

                // select the printer's list control
                SendMessage(hwndDlg, WM_NEXTDLGCTL, 
                    reinterpret_cast<WPARAM>(GetDlgItem(hwndDlg, IDC_PRINTER_LISTVIEW)), 1);
            }

            break;
        }
        case ( IDC_FIND_PRINTER ) :
        {
            //
            //  Turn on the hour glass.
            //
            HourGlass(TRUE);

            //
            //  Bring up the Find Printer dialog.
            //
            szScratch[0] = 0;
            if (FindPrinter(hwndDlg, szScratch, ARRAYSIZE(szScratch)) && (szScratch[0] != 0))
            {
                //
                //  Add the appropriate device pages and select the
                //  newly found printer.
                //
                if (!MergeDevMode(szScratch))
                {
                    InstallDevMode(szScratch, NULL);
                }
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }

            //
            //  Turn off the hour glass.
            //
            HourGlass(FALSE);

            break;
        }
        case ( IDC_PRINT_TO_FILE ) :
        {
            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_REFRESH ) :
        {
            if (psv)
            {
                psv->Refresh();
            }

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildCommandMessage
//
//  Process a WM_COMMAND message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    RECT rc;
    DWORD nTmpCopies;
    BOOL bTest;

    switch (LOWORD(wParam))
    {
        case ( IDC_RANGE_ALL ) :            // Print Range - All
        case ( IDC_RANGE_SELECTION ) :      // Print Range - Selection
        case ( IDC_RANGE_CURRENT ) :        // Print Range - Current Page
        case ( IDC_RANGE_PAGES ) :          // Print Range - Pages
        {
            CheckRadioButton( hSubDlg,
                              IDC_RANGE_ALL,
                              IDC_RANGE_PAGES,
                              GET_WM_COMMAND_ID(wParam, lParam) );

            //
            //  Only move the focus to the "Pages" edit control when
            //  the up/down arrow is NOT used.
            //
            if ( !IS_KEY_PRESSED(VK_UP) &&
                 !IS_KEY_PRESSED(VK_DOWN) &&
                 ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == IDC_RANGE_PAGES)) )
            {
                SendMessage( hSubDlg,
                             WM_NEXTDLGCTL,
                             (WPARAM)GetDlgItem(hSubDlg, IDC_RANGE_EDIT),
                             1L );
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_RANGE_EDIT ) :           // Print Range - Pages edit control
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                CheckRadioButton( hSubDlg,
                                  IDC_RANGE_ALL,
                                  IDC_RANGE_PAGES,
                                  IDC_RANGE_PAGES );

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COPIES ) :
        {
            if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) &&
                (fAPWSelected == FALSE))
            {
                //
                //  Save the number of copies.
                //
                nTmpCopies = nCopies;
                nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                if (!bTest || !nCopies)
                {
                    nCopies = nTmpCopies;
                }

                //
                //  If the printer can support collate and copy count > 1, enable collate.
                //  Otherwise, disable it.
                //
                if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
                {
                    EnableWindow( hCtl, (fAllowCollate && (nCopies > 1) ? TRUE : FALSE) );
                }

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COLLATE ) :
        {
            fCollateRequested = (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                                    ? TRUE
                                    : FALSE;

            if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             fCollateRequested
                                 ? (LONG_PTR)hIconCollate
                                 : (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNotifyMessage
//
//  Process WM_NOTIFY messages for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnNotifyMessage(
    WPARAM wParam,
    LPNMHDR pnm)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    LRESULT lResult;

    switch (pnm->code)
    {
        case ( PSN_SETACTIVE ) :
        {
            break;
        }
        case ( PSN_KILLACTIVE ) :
        {
            //
            //  Validation of the copies and page range values is done
            //  in the HandleMessage function for the sub dialog.
            //
            break;
        }
        case ( PSN_APPLY ) :
        {
            //
            //  Save the current printer information.
            //
            if (!GetCurrentPrinter() || !pDMCur)
            {
                ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return (TRUE);
            }

            //
            //  Clear the flags that need to be set based on the contents
            //  of the General page.
            //
            pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                     PD_COLLATE     |
                                     PD_PAGENUMS    |
                                     PD_SELECTION   |
                                     PD_CURRENTPAGE ));

            //
            //  Save the collate information.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COLLATE)) &&
                (fAPWSelected == FALSE))
            {
                if (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                {
                    pPD->Flags |= PD_COLLATE;
                }
                else
                {
                    pPD->Flags &= ~PD_COLLATE;
                }
            }

            //
            //  Save the info that the user hit OK.
            //
            pPI->FinalResult = 1;
            pPI->fApply = TRUE;
            //
            //  Save the print to file information.
            //
            if (IsDlgButtonChecked(hwndDlg, IDC_PRINT_TO_FILE))
            {
                pPD->Flags |= PD_PRINTTOFILE;
            }

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            //
            //  Disable the Apply button.
            //
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            break;

        }

        case PSN_LASTCHANCEAPPLY:
        {
            //
            //  Save the current printer information.
            //
            if (!GetCurrentPrinter() || !pDMCur)
            {
                ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
                return (TRUE);
            }
           
            //
            //  Save the number of copies.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
                (fAPWSelected == FALSE))
            {
                pPD->nCopies = nCopies;
                if(!SetCopiesOnApply())
                {
                    nCopies = pPD->nCopies;
                    SetDlgItemInt(hSubDlg, IDC_COPIES, nCopies, FALSE);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return (TRUE);
                }
            }

            //
            //  Save the DevMode information.
            //
            SaveDevMode();

            //
            //  Save the DevNames information.
            //
            if (!Print_SaveDevNames(pszCurPrinter, pPD))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = CreateError();
                pPI->FinalResult = 0;
            }

            //
            //  Save the hDC or hIC, depending on which flag is set.
            //
            if (pPI->FinalResult)
            {
                pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode);
                pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames);
                if (pDM && pDN)
                {
                    PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);
                }
                if (pDM)
                {
                    GlobalUnlock(pPD->hDevMode);
                }
                if (pDN)
                {
                    GlobalUnlock(pPD->hDevNames);
                }
            }
            break;
        }

        case ( PSN_QUERYCANCEL ) :
        {
            break;
        }

        case ( PSN_RESET ) :
        {
            //
            //  Save the info that the user hit CANCEL.
            //
            pPI->FinalResult = 0;

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Notify the sub dialog.
    //
    if (Print_IsInRange(pnm->code, PSN_LAST, PSN_FIRST) &&
        (HandleMessage(hSubDlg, WM_NOTIFY, wParam, (LPARAM)pnm, &lResult) !=
             S_FALSE))
    {
        // 
        // The return from a dlgproc is different than a winproc. The lResult is
        // the real result.
        //

        return (BOOLFROMPTR(lResult) );
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnSelChange
//
//  Process a CDM_SELCHANGE message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnSelChange()
{
    HRESULT hres;
    LPCITEMIDLIST *ppidlSel = NULL;
    UINT uItems = 0;
    UINT uCount = 0;
    TCHAR szPrinterNameBuf[kPrinterBufMax];
    BOOL bChanged = FALSE;
    HRESULT hr = S_OK;

    //
    //  We get this message during init, so use it to set the
    //  initial selection.
    //
    if (fFirstSel)
    {
        //
        //  Select the appropriate item in the list view.
        //
        //  If an item cannot be selected, it probably means that the
        //  printer that was passed in has been deleted.  In this case,
        //  insert the driver pages and select the default printer.
        //
        if (!SelectSVItem())
        {
            //
            //  Insert the device page for the default printer.
            //
            if (FAILED(InstallDevMode(NULL, NULL)))
            {
                UninstallDevMode();
            }

            //
            //  Get the current printer and select the appropriate item
            //  in the list view.
            //
            SelectSVItem();
        }

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();

        //
        //  Disable the Apply button if it's the very first time
        //  (during initialization).
        //
        if (fFirstSel == 1)
        {
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
        }

        //
        //  Reset the flags.
        //
        fFirstSel = 0;
        fSelChangePending = FALSE;

        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Reset the flag.
    //
    fSelChangePending = FALSE;

    //
    //  Make sure we have the shell folder view interface.
    //
    if (!psfv)
    {
        return (FALSE);
    }

    //
    //  Get the selected object in the print folder.
    //
    hres = psfv->GetSelectedObjects(&ppidlSel, &uItems);
    if (SUCCEEDED(hres) && (uItems > 0) && ppidlSel && *ppidlSel)
    {
        //
        //  Get the printer name.
        //
        szPrinterNameBuf[0] = 0;
        GetViewItemText( psfRoot,
                         *ppidlSel,
                         szPrinterNameBuf,
                         ARRAYSIZE(szPrinterNameBuf),
                         SHGDN_FORPARSING);

        // if the selection is same as current printer
        if (pszCurPrinter && (lstrcmpi(szPrinterNameBuf, pszCurPrinter) == 0))
        {
            //Dont do anything.
            LocalFree(ppidlSel);
            return TRUE;

        }


        //
        //  See if it's the Add Printer Wizard.
        //
        if (lstrcmpi(szPrinterNameBuf, TEXT("WinUtils_NewObject")) == 0)
        {
            //
            //  It's the Add Printer Wizard.
            //
            fAPWSelected = TRUE;

            //
            //  Disable the OK and Apply buttons.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            //  Remove the device pages, since no printer is selected.
            //
            if (SUCCEEDED(UninstallDevMode()))
            {
                bChanged = TRUE;
            }

            //
            //  Update the current printer information and the printer
            //  status text (all should be empty).
            //
            GetCurrentPrinter();
            UpdateStatus(NULL);

            //
            //  Notify the sub dialog that the selection changed.
            //
            if (bChanged)
            {
                SelectionChange();
                bChanged = FALSE;
            }
        }
        else
        {
            //
            //  It's not the Add Printer Wizard.
            //
            fAPWSelected = FALSE;

            if (!MergeDevMode(szPrinterNameBuf))
            {
                hr = InstallDevMode(szPrinterNameBuf, NULL);
            }
            if (SUCCEEDED(hr))
            {
                bChanged = TRUE;
            }
            else if (SUCCEEDED(UninstallDevMode()))
            {
                bChanged = TRUE;
            }

            //
            //  Get the current printer name and the current devmode and
            //  update the printer status text.
            //
            GetCurrentPrinter();

            if (SUCCEEDED(hr))
            {
                //
                // Clear the no access printer flag.
                //
                fNoAccessPrinterSelected = FALSE;

                //
                //  Make sure the OK button is enabled.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);

                //
                // Update the printer status.
                //
                UpdateStatus(*ppidlSel);
            }
            else
            {
                //
                // Save the fact we do not have access to this printer.
                //
                if (ERROR_ACCESS_DENIED == HRESULT_CODE(hr))
                {
                    fNoAccessPrinterSelected = TRUE;
                }

                //
                //  Disable the OK and Apply buttons.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
                PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

                //
                // Nuke the status.
                //
                UpdateStatus(NULL);
            }
        }

        //
        //  Free the pidl.
        //
        LocalFree(ppidlSel);
    }
    //
    //  See if anything changed.
    //
    if (bChanged)
    {
        //
        //  Enable the Apply button.
        //
        PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();
    }

    //
    //  Return success.
    //
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsCurrentPrinter
//
//  Checks whether the given pidl represents the current printer
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsCurrentPrinter(LPCITEMIDLIST pidl)
{
    TCHAR szPrinterBufName[kPrinterBufMax];
    if (pszCurPrinter)
    {
        szPrinterBufName[0] = 0;
        GetViewItemText( psfRoot,
                         pidl,
                         szPrinterBufName,
                         ARRAYSIZE(szPrinterBufName),
                         SHGDN_FORPARSING);
        if (lstrcmpi(szPrinterBufName, pszCurPrinter) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnRename
//
//  Handles the Rename Notification
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnRename(LPCITEMIDLIST *ppidl)
{
    TCHAR szPrinterBufName[kPrinterBufMax];
    LPITEMIDLIST pidl;
    TCHAR szNewPrinter[kPrinterBufMax];

    pidl = ILFindLastID(ppidl[0]);

    szNewPrinter[0] = 0;
    GetViewItemText( psfRoot,
                     ILFindLastID(ppidl[1]),
                     szNewPrinter,
                     ARRAYSIZE(szNewPrinter),
                     SHGDN_FORPARSING);

    //Has user clicked on Apply and saved any printer information ?
    if (pPI->fApply)
    {                
        //Yes. Check if the printer that is renamed is the one that is saved.
        LPDEVNAMES pDN;
        
        if ((pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
        {
            //Get the saved  printer name from the DEVNAMES structure.
            szPrinterBufName[0] = 0;
            GetViewItemText( psfRoot,
                             pidl,
                             szPrinterBufName,
                             ARRAYSIZE(szPrinterBufName),
                             SHGDN_FORPARSING);

            //Is the saved printer and renamed printer the same ?
            if (!lstrcmpi(szPrinterBufName, ((LPTSTR)pDN + pDN->wDeviceOffset)))
            {
                //Yes. Updated the saved DEVMODE and DEVNAMES Structure.
                LPDEVMODE pDM;


                //Update the dev names struture with the new printer name.
                Print_SaveDevNames(szNewPrinter, pPD);
        
                //Update the device name in the devmode to new name 
                if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
                {
                    lstrcpyn(pDM->dmDeviceName, szNewPrinter, CCHDEVICENAME);
                    GlobalUnlock(pPD->hDevMode);
                }                        
            }
           
            GlobalUnlock(pPD->hDevNames);
        }
    }

    if (IsCurrentPrinter(pidl))
    {
        if (!MergeDevMode(szNewPrinter))
        {
            InstallDevMode(szNewPrinter, NULL);
        }        
    }

    return TRUE;

}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChangeNotify
//
//  Handle the change notification message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChangeNotify(
    LONG lNotification,
    LPCITEMIDLIST *ppidl)
{
    LPCITEMIDLIST pidl;
    UINT uRes = 0;
    TCHAR szPrinterBufName[kPrinterBufMax];

    //
    //  Get the pidl for the object.
    //
    pidl = ILFindLastID(ppidl[0]);

    //
    //  Handle the notification.
    //
    switch (lNotification)
    {
        case ( SHCNE_ATTRIBUTES ) :
        case ( SHCNE_UPDATEITEM ) :
        {
            if (NULL == pidl || ILIsEqual(ppidl[0], pidlRoot))
            {
                // pidl is NULL or equal to the local PF which means that full refresh 
                // has been requested. if the current object is the APW then try to select 
                // a printer.
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }
            else
            {
                //
                //  If the selected object is the one that changed, then
                //  update the status text.
                if (IsCurrentPrinter(pidl))
                {
                    UpdateStatus(pidl);

                    //
                    //  Reinit the copies and collate because these attributes may be changed
                    //
                    InitCopiesAndCollate();
                }
            }
            break;
        }

        case ( SHCNE_RENAMEITEM ) :
        {
            OnRename(ppidl);
            break;
        }


        case ( SHCNE_CREATE ) :
        {
            //
            //  If the Add Printer Wizard is selected when we get this
            //  message, then select the newly created object.
            //
            if (fAPWSelected == TRUE)
            {
                //
                //  Get the printer name.
                //
                szPrinterBufName[0] = 0;
                GetViewItemText( psfRoot,
                                 pidl,
                                 szPrinterBufName,
                                 ARRAYSIZE(szPrinterBufName),
                                 SHGDN_FORPARSING);

                //
                //  Add the appropriate device pages and select the
                //  new printer.
                //
                if (!MergeDevMode(szPrinterBufName))
                {
                    InstallDevMode(szPrinterBufName, NULL);
                }
                if (!fSelChangePending)
                {
                    fFirstSel = 2;
                    fSelChangePending = TRUE;
                    PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                }
            }
            break;
        }
        case ( SHCNE_DELETE ) :
        {
            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            // Check if the current printer has just been deleted.
            // If so - set appropriate flag and disable the print button.
            if (IsCurrentPrinter(pidl))
            {
                TCHAR szSavePrinterName[kPrinterBufMax];
                StringCchCopy(szSavePrinterName, ARRAYSIZE(szSavePrinterName), szPrinter);

                //
                // Uninstall the current devmode and select the new default 
                // printer if any.
                //
                UninstallDevMode();
                InstallDevMode(NULL, NULL);
                SelectSVItem();

                //
                // If the devmode editor is open, we need to notify the user
                // that the printer has just been deleted.
                //
                if (fDevmodeEdit)
                {
                    //
                    // Display error message which indicates that the printer you are currently 
                    // editing properties for has just been deleted. Ask the user to close the
                    // driver UI dialog and select another printer.
                    //
                    fDirtyDevmode = TRUE;
                    ShowError(hwndDlg, 0, iszPrinterDeleted, szSavePrinterName);
                }
            }

            break;
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnAccelerator
//
//  Handles an input event message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnAccelerator(
    HWND hwndActivePrint,
    HWND hwndFocus,
    HACCEL haccPrint,
    PMSG pMsg)
{
    if (psv && (hwndFocus == hwndView))
    {
        if (psv->TranslateAccelerator(pMsg) == S_OK)
        {
            return (1);
        }

        if (haccPrint &&
            TranslateAccelerator(hwndActivePrint, haccPrint, pMsg))
        {
            return (1);
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNoPrinters
//
//  Displays a message box telling the user that they have no printers
//  installed.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnNoPrinters(HWND hDlg, HRESULT hr)
{
    switch (HRESULT_CODE(hr))
    {
        case ERROR_FILE_NOT_FOUND:
            {
                //
                // ERROR_FILE_NOT_FOUND means there are no printer's installed.
                //
                if (IDYES == ShowMessage(hDlg, IDC_PRINTER_LISTVIEW, iszNoPrinters, MB_YESNO|MB_ICONQUESTION, FALSE))
                {
                    //
                    // invoke the add printer wizard here
                    //
                    InvokeAddPrinterWizardModal(hwndDlg, NULL);
                }
            }
            break;

        case ERROR_ACCESS_DENIED:
            {
                //
                // Access is denied.
                //
                ShowError(hDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterAccess);
            }
            break;

        default:
            {
                //
                // Some other error have occured.
                //
                ShowError(hDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
            }
            break;
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDone
//
//  Handle the CDM_INITDONE message.  Initialization is complete, so
//  call IPrintDialogCallback::InitDone and then switch to the chosen
//  start page if it's not the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnInitDone()
{
    //
    //  See if we need to do this anymore.  This routine shouldn't be
    //  entered more than twice, but just in case.
    //
    if (nInitDone != -1)
    {
        //
        //  Make sure we have seen the CDM_INITDONE message for the
        //  completion of both the main dialog and the sub dialog.
        //
        if (nInitDone < 1)
        {
            //
            //  We only want to go through this code once.
            //
            nInitDone = -1;

            //
            //  Tell the sub dialog that initialization is complete.
            //
            InitDone();

            //
            //  Switch to the appropriate start page.
            //
            if (pPD->nStartPage != START_PAGE_GENERAL)
            {
                PropSheet_SetCurSel( GetParent(hwndDlg),
                                     NULL,
                                     pPD->nStartPage + 1 );
            }
        }
        else
        {
            nInitDone++;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreatePrintShellView
//
//  Creates the shell view window for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreatePrintShellView()
{
    RECT rcView;
    FOLDERSETTINGS fs;
    HRESULT hResult;
    HWND    hHiddenText;

    //
    //  Get the Printer Folder pidl.
    //
    pidlRoot = SHCloneSpecialIDList(hwndDlg, CSIDL_PRINTERS, TRUE);
    if (!pidlRoot)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_FAIL);
    }

    //
    //  Create an instance of IShellFolder and store it in the CPrintBrowser
    //  class.
    //
    hResult = Print_ICoCreateInstance( CLSID_CPrinters,
                                       IID_IShellFolder2,
                                       pidlRoot,
                                       (LPVOID *)&psfRoot );
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Get the private printer folder interface.
    //
    hResult = psfRoot->QueryInterface(IID_IPrinterFolder, (LPVOID *)&ppf);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Create the printer folder view.
    //
    GetWindowRect(GetDlgItem(hwndDlg, IDC_PRINTER_LIST), &rcView);
    MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView);

    fs.ViewMode = GetViewMode();
    fs.fFlags = FWF_AUTOARRANGE | FWF_SINGLESEL | FWF_ALIGNLEFT |
                FWF_SHOWSELALWAYS;

    hResult = psfRoot->CreateViewObject(hwndDlg, IID_IShellView, (LPVOID *)&psv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }
    hResult = psv->CreateViewWindow(NULL, &fs, this, &rcView, &hwndView);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    hResult = psv->UIActivate(SVUIA_INPLACEACTIVATE);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }
    //
    //  Get the shell folder view interface.
    //
    hResult = psv->QueryInterface(IID_IShellFolderView, (LPVOID *)&psfv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Move the view window to the right spot in the Z (tab) order.
    //
    SetWindowPos( hwndView,
                  HWND_TOP,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE );

    //
    //  Give it the right window ID for WinHelp and error selection.
    //
    SetWindowLong(hwndView, GWL_ID, IDC_PRINTER_LISTVIEW);

    //
    //  Move the hidden text ahead of the list view, thus the parent name of  
    //  the list view in MSAA is "Select Printer"
    //
    if (hHiddenText = GetDlgItem(hwndDlg, IDC_HIDDEN_TEXT))
    {
        SetParent(hHiddenText, hwndView);
        SetWindowPos(hHiddenText,
                     HWND_TOP,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW | SWP_NOACTIVATE);
    }

    //
    //  Show the window after creating the ShellView so we do not get a
    //  big ugly gray spot.
    //
    ShowWindow(hwndDlg, SW_SHOW);
    UpdateWindow(hwndDlg);

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::GetViewMode()
{
    HKEY hKey;
    UINT ViewMode = FVM_ICON;
    DWORD cbData;

    //
    //  Open the Printers\Settings registry key and read the information
    //  from the ViewMode value entry.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szSettings,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        cbData = sizeof(ViewMode);

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_szViewMode, NULL, NULL, (LPBYTE)&ViewMode, &cbData))
        {
            //
            // A "real" mode exist in the registry. Don't make
            // smart decisions for the view mode thereafter.
            //
            uDefViewMode = ViewMode;
        }

        RegCloseKey(hKey);
    }

    //
    //  Make sure it's in the correct range.
    //
    if (ViewMode > FVM_DETAILS)
    {
        ViewMode = FVM_ICON;
    }

    //
    //  Return the view mode.
    //
    return (ViewMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SetViewMode()
{
    HWND hwndListView;
    HKEY hKey;
    UINT ViewMode = VIEW_MODE_DEFAULT;
    DWORD cbData;

    //
    //  Get the current view mode.
    //
    if (psv && (hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL)))
    {
        FOLDERSETTINGS fs;
        psv->GetCurrentInfo(&fs);

        ViewMode = fs.ViewMode;
    }

    //
    // Check if the user changed the view mode
    //
    if( uDefViewMode != ViewMode )
    {
        //
        //  Open the Printers\Settings registry key and save the information
        //  to the ViewMode value entry.
        //
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szSettings,
                          0L,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            cbData = sizeof(ViewMode);
            RegSetValueEx(hKey, c_szViewMode, 0L, REG_DWORD, (LPBYTE)&ViewMode, cbData);
            RegCloseKey(hKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreateHookDialog
//
//  Creates the child window for the application specific area of the
//  General page.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreateHookDialog()
{
    DWORD Flags = pPD->Flags;
    HANDLE hTemplate;
    HINSTANCE hinst;
    LPCTSTR pDlg;
    RECT rcChild;
    DWORD dwStyle;
    LANGID LangID = (LANGID)TlsGetValue(g_tlsLangID);

    //
    //  See if there is a template.
    //
    if (Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        hTemplate = pPD->hInstance;
        hinst = ::g_hinst;
    }
    else
    {
        if (Flags & PD_ENABLEPRINTTEMPLATE)
        {
            pDlg = pPD->lpPrintTemplateName;
            hinst = pPD->hInstance;
            LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        }
        else
        {
            hinst = ::g_hinst;
            pDlg = MAKEINTRESOURCE(PRINTDLGEXORD);
        }

        HRSRC hRes = FindResourceExFallback(hinst, RT_DIALOG, pDlg, LangID);
        if (hRes == NULL)
        {
            pPI->dwExtendedError = CDERR_FINDRESFAILURE;
            return (E_HANDLE);
        }
        if ((hTemplate = LoadResource(hinst, hRes)) == NULL)
        {
            pPI->dwExtendedError = CDERR_LOADRESFAILURE;
            return (E_HANDLE);
        }
    }

    //
    //  Lock the resource.
    //
    if (!LockResource(hTemplate))
    {
        pPI->dwExtendedError = CDERR_LOADRESFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure the template is a child window.
    //
    dwStyle = ((LPDLGTEMPLATE)hTemplate)->style;
    if (!(dwStyle & WS_CHILD))
    {
        //
        //  I don't want to go poking in their template, and I don't want to
        //  make a copy, so I will just fail.  This also helps us weed out
        //  "old-style" templates that were accidentally used.
        //
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Get the callback interface pointer, if necessary.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface( IID_IPrintDialogCallback,
                                         (LPVOID *)&pCallback );
    }

    //
    //  Create the child dialog.
    //
    hSubDlg = CreateDialogIndirectParam( hinst,
                                         (LPDLGTEMPLATE)hTemplate,
                                         hwndDlg,
                                         Print_GeneralChildDlgProc,
                                         (LPARAM)pPD );
    if (!hSubDlg)
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Put the window in the designated spot on the General property page.
    //
    GetWindowRect(GetDlgItem(hwndDlg, grp2), &rcChild);
    MapWindowRect(NULL, hwndDlg, &rcChild);
    SetWindowPos( hSubDlg,
                  HWND_BOTTOM,
                  rcChild.left,
                  rcChild.top,
                  rcChild.right - rcChild.left,
                  rcChild.bottom - rcChild.top,
                  SWP_SHOWWINDOW );

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::UpdateStatus
//
//  Updates the static text for the currently selected printer.
//  The fields that are set are Status, Location, and Comment.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::UpdateStatus(
    LPCITEMIDLIST pidl)
{
    HRESULT hres;
    SHELLDETAILS Details;
    TCHAR szText[MAX_PATH];

    //
    //  If the pidl is NULL, then reset all of the static text to null
    //  strings.
    //
    if (!pidl)
    {
        szText[0] = 0;

        SetDlgItemText(hwndDlg, IDC_STATUS, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

        SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

        SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

        return (TRUE);
    }

    //
    //  Get the STATUS details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_STATUS, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_STATUS, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

    //
    //  Get the LOCATION details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_LOCATION, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

    //
    //  Get the COMMENT details for the given object.
    //
    szText[0] = 0;
    hres = psfRoot->GetDetailsOf(pidl, PRINTERS_ICOL_COMMENT, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectSVItem
//
//  Selects the item in the shell view with the given printer name.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SelectSVItem()
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlItem = NULL;
    BOOL bPrinterSelected = FALSE;

    //  Make sure we have a shell view and a shell folder view.
    if (psv && psfv)
    {
        //  Make sure we have the current printer information.
        GetCurrentPrinter();

        if (!pDMCur || !pszCurPrinter || !pszCurPrinter[0])
        {
            //  If there is no current printer then we just select the add printer
            //  wizard object.
            hr = psfRoot->ParseDisplayName(hwndDlg, NULL, TEXT("WinUtils_NewObject"), NULL, &pidlItem, NULL);
            if (SUCCEEDED(hr) && pidlItem)
            {
                // just select the APW special object
                SelectPrinterItem(pidlItem);
            
                // Free up the PIDL using the shell allocator
                FreePIDL(pidlItem);

                //  It's the Add Printer Wizard.
                fAPWSelected = TRUE;

                //  Disable the OK and Apply buttons.
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
                PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
            }
        }
        else
        {
            //  there is a current printer then we just select it
            hr = psfRoot->ParseDisplayName(hwndDlg, NULL, pszCurPrinter, NULL, &pidlItem, NULL);
            if (SUCCEEDED(hr) && pidlItem)
            {
                // select the printer and update the status
                SelectPrinterItem(pidlItem);
                UpdateStatus(pidlItem);

                // Free up the PIDL using the shell allocator
                FreePIDL(pidlItem);

                //  It's not the Add Printer Wizard.
                fAPWSelected = FALSE;

                //  Enable the OK and Apply buttons.
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                // A printer object has been selected
                bPrinterSelected = TRUE;
            }
        }
    }

    return SUCCEEDED(hr) ? bPrinterSelected : FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinter
//
//  Saves the current printer name and the current devmode in the class.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetCurrentPrinter()
{
    DWORD dwSize = cchCurPrinter;

    //
    //  Reset the devmode and the current printer string.
    //
    pDMCur = NULL;
    if (pszCurPrinter && cchCurPrinter)
    {
        pszCurPrinter[0] = 0;
    }

    //
    //  Get the name of the current printer.
    //
    if (!GetInternalPrinterName(pszCurPrinter, &dwSize))
    {
        //
        //  Allocate a buffer large enough to hold the name of the
        //  current printer.
        //
        if (dwSize > cchCurPrinter)
        {
            if (pszCurPrinter)
            {
                LPTSTR pTemp = pszCurPrinter;
                pszCurPrinter = NULL;
                cchCurPrinter = 0;
                GlobalFree(pTemp);
            }
            pszCurPrinter = (LPTSTR)GlobalAlloc(GPTR, dwSize * sizeof(TCHAR));
            if (!pszCurPrinter)
            {
                return (FALSE);
            }
            cchCurPrinter = dwSize;
            if (cchCurPrinter)
            {
                pszCurPrinter[0] = 0;
            }
        }

        //
        //  Try to get the name of the current printer again.
        //
        if (!GetInternalPrinterName(pszCurPrinter,&dwSize))
        {
            return (FALSE);
        }
    }

    //
    //  Get the current devmode.
    //
    pDMCur = GetCurrentDevMode();
    if (!pDMCur)
    {
        pszCurPrinter[0] = 0;
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPrintToFile
//
//  Initializes the print to file on a selection change.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPrintToFile()
{
    HWND hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE);

    //
    //  See if there is a Print To File control.
    //
    if (hCtl)
    {
        //
        //  See if a printer is selected.
        //
        if (pDMCur)
        {
            //
            //  A printer is selected, so enable the print to file if
            //  appropriate.
            //
            if (!(pPI->dwFlags & (PD_HIDEPRINTTOFILE | PD_DISABLEPRINTTOFILE)))
            {
                EnableWindow(hCtl, TRUE);
            }
        }
        else
        {
            //
            //  A printer is not selected, so disable it.
            //
            EnableWindow(hCtl, FALSE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPageRangeGroup
//
//  Initializes the page range group on a selection change.  It decides
//  which controls should be enabled when a selection change occurs from
//  the Add Printer Wizard.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPageRangeGroup()
{
    //
    //  See if a printer is selected.
    //
    if (pDMCur)
    {
        //
        //  A printer is selected, so enable the appropriate page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), TRUE);
        if (!(pPI->dwFlags & PD_NOSELECTION))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOCURRENTPAGE))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOPAGENUMS))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), TRUE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), TRUE);
        }
    }
    else
    {
        //
        //  A printer is not selected, so disable all of the page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitCopiesAndCollate
//
//  Initializes the copies and collate information in the devmode and the
//  print dialog structure.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitCopiesAndCollate()
{
    HWND hCtl;
    UINT IsCollate = FALSE;
    RECT rc;
    BOOL bEnabledCopies = TRUE;

    //
    //  Save the collate state so that the collate icon doesn't flicker on
    //  a selection change.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
    {
        IsCollate = IsDlgButtonChecked(hSubDlg, IDC_COLLATE);
    }

    //
    //  See what the printer driver can do and what the app requested
    //  and set the copies and collate accordingly.
    //
    if (pDMCur)
    {
        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            //
            // Modify the edit control and up-down arrow if needed
            //
            WORD    cDigits;

            //
            // If the calling application handles copies and collate, we
            // set max copies as 9999, else, we get the max copies from driver
            //
            if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
            {
                szScratch[0] = 0;
                Print_GetPortName(pszCurPrinter, szScratch, ARRAYSIZE(szScratch));
                nMaxCopies = DeviceCapabilities( pszCurPrinter,
                                                 szScratch,
                                                 DC_COPIES,
                                                 NULL,
                                                 NULL );
                //
                // If DeviceCapabilities() returns error, disable the controls
                //
                if ((nMaxCopies < 1) || (nMaxCopies == (DWORD)(-1)))
                {
                    nMaxCopies = 1;
                    nCopies = 1;
                    bEnabledCopies = FALSE;
                }
            }
            else
            {
                //
                // Assume the calling app will take care of multi-copies
                //
                nMaxCopies = MAX_COPIES;
            }

            if (nMaxCopies < nCopies)
            {
                nCopies = nMaxCopies;
            }

            cDigits = CountDigits(nMaxCopies);
            Edit_LimitText(hCtl, cDigits);

            SendMessage(GetDlgItem(hSubDlg, IDC_COPIES_UDARROW), UDM_SETRANGE, 
                0, MAKELONG(nMaxCopies, 1));
            InvalidateRect(GetDlgItem(hSubDlg, IDC_COPIES_UDARROW), NULL, FALSE);
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            DWORD   dwCollate;
            BOOL    bEnabled = TRUE;

            if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
            {
                szScratch[0] = 0;
                Print_GetPortName(pszCurPrinter, szScratch, ARRAYSIZE(szScratch));
                dwCollate = DeviceCapabilities(  pszCurPrinter,
                                                 szScratch,
                                                 DC_COLLATE,
                                                 NULL,
                                                 NULL );
                fAllowCollate = ((dwCollate < 1) || (dwCollate == (DWORD)-1)) ? FALSE : TRUE;
            }
            else 
            {
                //
                // Assume the calling app will take care of collation
                //
                fAllowCollate = TRUE;
            }

            if ( fAllowCollate )
            {
                EnableWindow(hCtl, (nCopies > 1));
                CheckDlgButton( hSubDlg,
                                IDC_COLLATE,
                                fCollateRequested ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);
            }

            //
            //  Display the appropriate collate icon if it changed.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) &&
                (IsCollate != IsDlgButtonChecked(hSubDlg, IDC_COLLATE)))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             IsCollate
                                 ? (LONG_PTR)hIconNoCollate
                                 : (LONG_PTR)hIconCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }

        //
        // We have to do it here because after setting the text, fAllowCollate
        // will be used
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            SetDlgItemInt(hSubDlg, IDC_COPIES, nCopies, FALSE);
            EnableWindow(hCtl, bEnabledCopies);
            EnableWindow(hwndUpDown, bEnabledCopies);
        }
    }
    else if (fNoAccessPrinterSelected)
    {
        // if No Access Printer is selected merely disable the Copies and Collate
        // Dont change any information user entered.

        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            EnableWindow(hCtl, FALSE);
            EnableWindow(hwndUpDown, FALSE);
        }
        
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
        }

        //
        //  Disable the Apply button It gets turned back on when the copies and collate values are
        //  disabled.
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    }
    else
    {
        //
        //  A printer is not selected, so disable copies and collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            SetDlgItemInt(hSubDlg, IDC_COPIES, 1, FALSE);
            EnableWindow(hCtl, FALSE);
            EnableWindow(hwndUpDown, FALSE);
        }
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
            CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);

            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) && IsCollate)
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }

        //
        //  Disable the Apply button since a printer is not selected.
        //  It gets turned back on when the copies and collate values are
        //  disabled.
        //
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveCopiesAndCollateInDevMode
//
//  Saves the copies and collate information in the given devmode.  This
//  routine does not affect the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SaveCopiesAndCollateInDevMode(
    LPDEVMODE pDM,
    LPTSTR pszPrinter)
{
    //
    //  Make sure we have a devmode and a printer name.
    //
    if (!pDM || !pszPrinter || !(pszPrinter[0]))
    {
        return (FALSE);
    }

    //
    // verify number of copies is less than max value
    //
    if( nMaxCopies < nCopies )
    {
        return (FALSE);
    }

    //
    //  Move the info to the devmode.
    //
    pDM->dmCopies = (short)nCopies;
    SetField(pDM, dmCollate, (fAllowCollate && fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetCopiesOnApply
//
//  Sets the appropriate number of copies in the PrintDlgEx structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SetCopiesOnApply()
{
    if (pDMCur)
    {
        if (!(pDMCur->dmFields & DM_COPIES))
        {
Print_LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the copy/collate
            //  info in the pPD.
            //
            pDMCur->dmCopies = 1;
            SetField(pDMCur, dmCollate, DMCOLLATE_FALSE);
        }
        else if ((pDMCur->dmSpecVersion < 0x0400) ||
                 (!(pDMCur->dmFields & DM_COLLATE)))
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto Print_LeaveInfoInPD;
            }
            else
            {
                goto Print_PutInfoInDevMode;
            }
        }
        else
        {
Print_PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pszCurPrinter)
            {
                goto Print_LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number of copies
            //  requested.
            //
            if (nMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
                {
                    ShowError(hSubDlg, IDC_COPIES, iszTooManyCopies, nMaxCopies);
                    pPD->nCopies = nMaxCopies;
                    return (FALSE);
                }
                else
                {

                    goto Print_LeaveInfoInPD;
                }
            }

            //
            //  The driver can do both copies and collate, so move the info
            //  to the devmode.
            //
            pDMCur->dmCopies = (short)pPD->nCopies;
            SetField( pDMCur,
                      dmCollate,
                      (fAllowCollate && (pPD->Flags & PD_COLLATE)) 
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveDevMode
//
//  Saves the current devmode in the pPD structure on Apply.
//  Assumes pDMCur has the current information.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SaveDevMode()
{
    DWORD cbSize;
    HANDLE hDevMode = NULL;
    LPDEVMODE pDM;

    //
    //  Allocate the space for the new DevMode and copy the
    //  information.
    //
    if (pDMCur)
    {
        cbSize = (DWORD)(pDMCur->dmSize + pDMCur->dmDriverExtra);
        hDevMode = GlobalAlloc(GHND, cbSize);
        if (hDevMode)
        {
            pDM = (LPDEVMODE)GlobalLock(hDevMode);
            if (pDM)
            {
                CopyMemory(pDM, pDMCur, cbSize);
                GlobalUnlock(hDevMode);
            }
            else
            {
                GlobalFree(hDevMode);
                hDevMode = NULL;
            }
        }
    }
    if (!hDevMode)
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        pPI->hResult = E_OUTOFMEMORY;
        pPI->FinalResult = 0;
    }

    //
    //  Free the copy of the DevMode handle passed in by the app.
    //
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Save the new DevMode in the pPD structure.
    //
    pPD->hDevMode = hDevMode;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::MergeDevMode
//
//  Merges the current devmode with the default devmode of the newly
//  selected printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::MergeDevMode(
    LPTSTR pszPrinterName)
{
    HANDLE  hDevMode = NULL;
    LPDEVMODE pDMNew  = NULL;
    LPDEVMODE pDMOld = NULL;
    BOOL bRet = TRUE;
    DWORD dmFields;
    short dmDefaultSource;

    //
    //  See if the printer name is NULL.  If so, we need to get the default
    //  printer loaded.  This happens when a printer is deleted.
    //
    if (!pszPrinterName)
    {
        ASSERT(0);
        return FALSE;
    }
    else
    {
        //
        //  Get the devmode for the old (current driver pages) printer.
        //
        GetCurrentPrinter();
        pDMOld = pDMCur ? pDMCur : pDMSave;
        if (!pDMOld)
        {
            return (FALSE);
        }

        hDevMode = Print_GetDevModeWrapper(pszPrinterName);

        if (hDevMode)
        {
            pDMNew = (LPDEVMODE)GlobalLock(hDevMode);
        }
        else
        {
            return FALSE;
        }

        if (!pDMNew)
        {
            GlobalFree(hDevMode);
            return FALSE;
        }

        dmFields = 0;
        dmDefaultSource = pDMNew->dmDefaultSource;

        if (pDMNew->dmFields & DM_DEFAULTSOURCE)
        {
            dmFields = DM_DEFAULTSOURCE;
        }

        //Check if the old devmode has any info to copy
        if (pDMOld->dmFields)
        {
            CopyMemory(&(pDMNew->dmFields), 
                       &(pDMOld->dmFields), 
                       sizeof(DEVMODE) - FIELD_OFFSET(DEVMODE, dmFields));
        }

        pDMNew->dmFields |= dmFields;
        pDMNew->dmDefaultSource = dmDefaultSource;

        pDMNew->dmFields = pDMNew->dmFields & ( DM_ORIENTATION  | DM_PAPERSIZE    |
                                                DM_PAPERLENGTH  | DM_PAPERWIDTH   |
                                                DM_SCALE        | DM_COPIES       |
                                                DM_COLLATE      | DM_FORMNAME     |
                                                DM_DEFAULTSOURCE);

        //
        //  Insert the device pages - this call will yield a proper devmode.
        //
        if (FAILED(UninstallDevMode()) || FAILED(InstallDevMode(pszPrinterName, pDMNew)))
        {
            bRet = FALSE;
        }

        //Free the new devmode that was allocated

        if (hDevMode)
        {
            GlobalUnlock(hDevMode);
            GlobalFree(hDevMode);
        }
    }


    //
    //  Return the result.
    //
    return (bRet);

}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsValidPageRange
//
//  Checks the validity of the page range string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsValidPageRange(
    LPTSTR pszString,
    UINT *pErrorId)
{
    LPTSTR pStr = pszString;
    BOOL bDigit = FALSE;
    BOOL bOld;
    UINT Number, Ctr;
    DWORD nNumRanges = 0;
    BOOL bFrom = TRUE;

    //
    //  Initially set the error id to 0.
    //
    *pErrorId = 0;

    //
    //  See if we can only have a single page range.
    //
    bOld = (nMaxPageRanges == 1);

    //
    //  Go through the string and validate the entries.
    //
    while (*pStr)
    {
        if (ISDIGIT(*pStr))
        {
            //
            //  Make sure there is room for another range.
            //
            if (nNumRanges >= nMaxPageRanges)
            {
                break;
            }

            //
            //  Found a digit.
            //
            bDigit = TRUE;

            //
            //  Make sure the page number is in the given page range.
            //
            Number = 0;
            while (ISDIGIT(*pStr))
            {
                Number *= 10;
                Number += *pStr - TEXT('0');
                pStr++;
            }
            pStr--;

            if ((Number < pPD->nMinPage) || (Number > pPD->nMaxPage))
            {
                *pErrorId = iszBadPageRange;
                return (FALSE);
            }

            //
            //  Save the value in the page range structure.
            //
            if (bFrom)
            {
                pPageRanges[nNumRanges].nFromPage = Number;
                bFrom = FALSE;
            }
            else
            {
                pPageRanges[nNumRanges].nToPage = Number;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else if (*pStr == TEXT('-'))
        {
            //
            //  Found a hyphen.  Make sure there is a digit preceding it
            //  and following it.  Also, make sure there isn't something
            //  like 1-2-3.
            //
            if (!bDigit || bFrom || !ISDIGIT(*(pStr + 1)))
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;
        }
        else if ((*pStr == szListSep[0]) || (*pStr == TEXT(',')))
        {
            //
            //  Found a list separator.  Make sure there is a digit
            //  preceding it.
            //
            if (!bDigit)
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;

            //
            //  If it's the list separator string instead of the simple
            //  comma, then make sure the entire list separator string
            //  is there.
            //  This will advance the string up to the last character
            //  of the list separator string.
            //
            if ((*pStr == szListSep[0]) &&
                ((szListSep[0] != TEXT(',')) || (!ISDIGIT(*(pStr + 1)))))
            {
                for (Ctr = 1; Ctr < nListSep; Ctr++)
                {
                    pStr++;
                    if (*pStr != szListSep[Ctr])
                    {
                        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                         : iszBadPageRangeSyntaxNew;
                        return (FALSE);
                    }
                }
            }

            //
            //  Make sure the From/To page range is complete.
            //
            if (!bFrom)
            {
                pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else
        {
            //
            //  Found an invalid character.
            //
            *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                             : iszBadPageRangeSyntaxNew;
            return (FALSE);
        }

        //
        //  Advance the string pointer.
        //
        pStr++;
    }

    //
    //  Make sure we reached the end of the string.
    //
    if (*pStr)
    {
        *pErrorId = iszTooManyPageRanges;
        return (FALSE);
    }

    //
    //  Make sure the last thing in the string was a digit.
    //
    if (!bDigit)
    {
        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                         : iszBadPageRangeSyntaxNew;
        return (FALSE);
    }

    //
    //  Make sure the last From/To page range is complete.
    //
    if (!bFrom)
    {
        pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
        bFrom = TRUE;
        nNumRanges++;
    }

    //
    //  Save the number of page ranges.
    //
    nPageRanges = nNumRanges;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ConvertPageRangesToString
//
//  Converts the page ranges to a string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::ConvertPageRangesToString(
    LPTSTR pszString,
    UINT cchLen)
{
    LPTSTR pStr = pszString;
    DWORD nFromPage, nToPage;
    UINT cch = cchLen - 1;
    UINT Ctr, Ctr2, Count;

    //
    //  Initialize the string.
    //
    if (cchLen)
    {
        pszString[0] = 0;
    }

    //
    //  Validate the ranges and create the string.
    //
    for (Ctr = 0; Ctr < nPageRanges; Ctr++)
    {
        //
        //  Get the range.
        //
        nFromPage = pPageRanges[Ctr].nFromPage;
        nToPage   = pPageRanges[Ctr].nToPage;

        //
        //  Make sure the range is valid.
        //
        if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
            (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
        {
            return (FALSE);
        }

        //
        //  Make sure it's not 0xFFFFFFFF.
        //
        if (nFromPage == 0xFFFFFFFF)
        {
            continue;
        }

        //
        //  Put it in the string.
        //
        Count = IntegerToString(nFromPage, pStr, cch);
        if (!Count)
        {
            return (FALSE);
        }
        pStr += Count;
        cch -= Count;

        if ((nFromPage == nToPage) || (nToPage == 0xFFFFFFFF))
        {
            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
        else
        {
            if (!cch)
            {
                return (FALSE);
            }
            *pStr = TEXT('-');
            pStr++;
            cch--;

            Count = IntegerToString(nToPage, pStr, cch);
            if (!Count)
            {
                return (FALSE);
            }
            pStr += Count;
            cch -= Count;

            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
    }

    *pStr = '\0';

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IntegerToString
//
//  Converts an integer to a string and returns the number of characters
//  written to the buffer (not including the null).
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::IntegerToString(
    DWORD Value,
    LPTSTR pszString,
    UINT cchLen)
{
    DWORD TempValue = Value;
    UINT NumChars = 1;
    UINT Ctr;

    //
    //  Get the number of characters needed.
    //
    while (TempValue = TempValue / 10)
    {
        NumChars++;
    }

    //
    //  Make sure there is enough room in the buffer.
    //
    if (NumChars > cchLen)
    {
        return (0);
    }

    //
    //  Make the string.
    //
    TempValue = Value;
    for (Ctr = NumChars; Ctr > 0; Ctr--)
    {
        pszString[Ctr - 1] = ((WORD)(TempValue % 10)) + TEXT('0');
        TempValue = TempValue / 10;
    }

    //
    //  Return the number of characters written to the buffer.
    //
    return (NumChars);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ShowError
//
//  Shows up an error message box
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::ShowError(HWND hDlg, UINT uCtrlID, UINT uMsgID, ...)
{
    va_list args;
    va_start(args, uMsgID);

    InternalShowMessage(hDlg, uCtrlID, uMsgID, MB_ICONEXCLAMATION|MB_OK, TRUE, args);

    va_end(args);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ShowMessage
//
//  Shows up a message box with the specified flags & parameters
//
////////////////////////////////////////////////////////////////////////////
int CPrintBrowser::ShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, ...)
{
    va_list args;
    va_start(args, bBeep);

    int iRet = InternalShowMessage(hDlg, uCtrlID, uMsgID, uType, bBeep, args);

    va_end(args);
    
    return iRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InternalShowMessage
//
//  Shows up a message box with the specified flags & parameters
//  Internal version
//
//  Assumes the control is not disabled.
//
////////////////////////////////////////////////////////////////////////////
int CPrintBrowser::InternalShowMessage(HWND hDlg, UINT uCtrlID, UINT uMsgID, UINT uType, BOOL bBeep, va_list args)
{
    int iRet = IDCANCEL;

    if (!(pPI->dwFlags & PD_NOWARNING))
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szFormat[MAX_PATH];
        TCHAR szMessage[MAX_PATH];
        
        //
        // Get msg box title & load the format string
        //
        if ( GetWindowText(GetParent(hwndDlg), szTitle, ARRAYSIZE(szTitle)) &&
             CDLoadString(g_hinst, uMsgID, szFormat, ARRAYSIZE(szFormat)) )
        {
            if (bBeep)
            {
                MessageBeep(MB_ICONEXCLAMATION);
            }

            //
            // format the message to be shown and call MessageBox over
            // the last active popup
            //
            wvnsprintf(szMessage, ARRAYSIZE(szMessage), szFormat, args);
            HWND hWndOwner = ::GetWindow(GetParent(hwndDlg), GW_OWNER);
            HWND hWndLastPopup = GetLastActivePopup(hWndOwner);
            
            iRet = MessageBox(hWndLastPopup, szMessage, szTitle, uType);
        }
        
        HWND hCtrl = ((0 == uCtrlID) ? NULL : GetDlgItem(hDlg, uCtrlID)); 
        if (hCtrl)
        {
            //
            // select & highlight the invalid value. we assume it 
            // is an edit box, if it isn't then EM_SETSEL won't be
            // processed and it's OK.
            //
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hCtrl, 1L);
            SendMessage(hCtrl, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        }
    }

    return iRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::FitViewModeBest
//
//  Adjust the view mode if the mini printers folder, so the printer names
//  fit best. This i8s necessary mainly because of accessibility problems.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::FitViewModeBest(HWND hwndListView)
{
    BOOL bResult = FALSE;

    if (VIEW_MODE_DEFAULT == uDefViewMode)
    {
        //
        // Asssume icon view by default.
        //
        uDefViewMode = FVM_ICON;

        //
        // If we are in a large icons view then check if something 
        // doesn't fit vertically - the only reliable way to do this
        // is to check if we scrolled the view (origin.y > 0)
        //
        if (LVS_ICON == (GetWindowLong(hwndListView, GWL_STYLE) & LVS_TYPEMASK))
        {
            POINT ptOrg;
            ListView_GetOrigin(hwndListView, &ptOrg);

            if (ptOrg.y > 0)
            {
                //
                // Switch the defview to List mode.
                //
                SendMessage(hwndView, WM_COMMAND, (WPARAM)SFVIDM_VIEW_LIST,0);

                uDefViewMode = FVM_LIST;
                bResult = TRUE;
            }
        }
    }

    return bResult;
}

VOID CPrintBrowser::SelectPrinterItem(LPITEMIDLIST pidlItem)
{
    BOOL bLocked = FALSE;
    HWND hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);

    if (hwndListView)
    {
        //
        // Disable the window update to prevent flickers
        //
        bLocked = LockWindowUpdate(hwndListView);
    }

    //
    // Try to make the printer item visible first
    //
    psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED | SVSI_ENSUREVISIBLE);

    //
    // Check to see if the view mode need to be changed
    //
    if (hwndListView && FitViewModeBest(hwndListView))
    {
        //
        // The view mode has been changed - call select item again
        // to ensure the visibility of the slected item in the new 
        // view mode.
        //
        psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED | SVSI_ENSUREVISIBLE);
    }

    if (hwndListView && bLocked)
    {
        //
        // Enable the window update
        //
        LockWindowUpdate(NULL);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::FindPrinter
//
//  Invokes the find in the DS ui using printui!bPrinterSetup interface
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::FindPrinter(HWND hwnd, LPTSTR pszBuffer, UINT cchSize)
{ 
    BOOL bReturn = FALSE;
    if (g_pfnPrinterSetup)
    {
        //
        // Invoke the DSUI to find a printer
        //
        bReturn = g_pfnPrinterSetup(hwnd, MSP_FINDPRINTER, cchSize, pszBuffer, &cchSize, NULL);

        // select the printer's list control
        SendMessage(hwndDlg, WM_NEXTDLGCTL, 
            reinterpret_cast<WPARAM>(GetDlgItem(hwndDlg, IDC_PRINTER_LISTVIEW)), 1);
    }
    return bReturn; 
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetInternalPrinterName
//
//  Returns the current printer name
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetInternalPrinterName(LPTSTR pszBuffer, DWORD *pdwSize)
{ 
    BOOL bReturn = FALSE;

    if (pdwSize)
    {
        //
        // If a buffer was provided and it is large enough, then copy the printer name.
        //
        DWORD iLen = _tcslen(szPrinter);
        if (pszBuffer && *pdwSize > iLen)
        {
            StringCchCopy(pszBuffer, *pdwSize, szPrinter);
            bReturn = TRUE;
        }
        else
        {
            //
            // Set the required length and the last error code.
            //
            *pdwSize = iLen + 1;
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
        }
    }

    return bReturn;
} 

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentDevMode
//
//  Returns the current internal devmode
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODE CPrintBrowser::GetCurrentDevMode()
{ 
    return pInternalDevMode; 
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetDefaultDevMode
//
//  Retrieve the default devmode for the specified printer.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::GetDefaultDevMode(HANDLE hPrinter, LPCTSTR pszPrinterName, PDEVMODE *ppDevMode)
{
    HRESULT                 hr = S_OK;
    LONG                    lResult = 0;
    PDEVMODE                pDevMode = NULL;

    if (SUCCEEDED(hr))
    {
        //
        // Call document properties to get the size of the devmode.
        //
        lResult = DocumentProperties(NULL, hPrinter, (LPTSTR)pszPrinterName, NULL, NULL, 0);
        hr = (lResult >= 0) ? S_OK : CreateError();
    }

    if (SUCCEEDED(hr))
    {
        //
        // If the size of the devmode was returned then allocate memory.
        //
        // GPTR initializes the memory with zeros.
        //
        pDevMode = (PDEVMODE)GlobalAlloc(GPTR, lResult);
        hr = pDevMode ? S_OK : E_OUTOFMEMORY;
    }

    //
    // If allocated then copy back the pointer.
    //
    if (SUCCEEDED(hr))
    {
        //
        // Call document properties to get the default dev mode.
        //
        lResult = DocumentProperties(NULL, hPrinter, (LPTSTR)pszPrinterName, pDevMode, NULL, DM_OUT_BUFFER);
        hr = (lResult >= 0) ? S_OK : CreateError();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Everything has succeeded. Move locals to out parameters.
        //
        *ppDevMode = pDevMode;
        pDevMode = NULL;
    }

    
    //
    // Cleanup...
    //
    if (pDevMode)
    {
        GlobalFree((HANDLE)pDevMode);
        pDevMode = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::WrapEnumPrinters
//
//  Wraps EnumPrinters API into more friendly interface
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::WrapEnumPrinters(DWORD dwFlags, LPCTSTR pszServer, DWORD dwLevel, PVOID* ppvBuffer, PDWORD pcbBuffer, PDWORD pcPrinters)
{
    HRESULT                 hr = S_OK;
    DWORD                   cbNeeded;
    BOOL                    bResult = FALSE;

    if (SUCCEEDED(hr))
    {
        hr = (ppvBuffer && pcbBuffer && pcPrinters) ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Pre-initialize *pcbPrinter if it's not set.
        //
        if (!*pcbBuffer)
        {
            *pcbBuffer = kInitialPrinterHint;
        }

        do
        {
            if (!*ppvBuffer)
            {
                *ppvBuffer = (PVOID)GlobalAlloc(GPTR, *pcbBuffer);

                if (!*ppvBuffer)
                {
                    *pcbBuffer = 0;
                    *pcPrinters = 0;
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            if (SUCCEEDED(hr))
            {
                bResult = EnumPrinters(dwFlags, (LPTSTR)pszServer, dwLevel, (PBYTE)*ppvBuffer, *pcbBuffer, &cbNeeded, pcPrinters);
                hr = bResult ? S_OK : CreateError();
            }

            if (SUCCEEDED(hr))
            {
                //
                // Everything went fine
                //
                break;
            }

            //
            // Check to see whether the buffer is too small.
            //
            GlobalFree((HANDLE)(*ppvBuffer));
            *ppvBuffer = NULL;

            if (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hr))
            {
                //
                // Reset hr & continue.
                //
                hr = S_OK;
                *pcbBuffer = cbNeeded;
                continue;
            }

            //
            // Something else (not the buffer) went wrong. 
            // Bail out.
            //
            *pcbBuffer = 0;
            *pcPrinters = 0;
            break;

        } while(1);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetUsablePrinter
//
//  Try to find a usable printer
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::GetUsablePrinter(LPTSTR szPrinterNameBuf, DWORD *pcchBuf)
{
    HRESULT                 hr = S_OK;
    BOOL                    bStatus = FALSE;
    DWORD                   cchBuf = *pcchBuf;
    HANDLE                  hPrinter = NULL;
    PDEVMODE                pDevMode = NULL;
    PRINTER_INFO_4         *pInfo4 = NULL;
    DWORD                   cInfo4 = 0;
    DWORD                   cbInfo4 = 0;

    if (SUCCEEDED(hr))
    {
        hr = (szPrinterNameBuf && pcchBuf) ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        do
        {
            if (SUCCEEDED(hr))
            {
                //
                // Attempt to the get the default printer.
                //
                bStatus = GetDefaultPrinter(szPrinterNameBuf, pcchBuf);
                hr = bStatus ? S_OK : CreateError();
            }

            if (SUCCEEDED(hr))
            {
                bStatus = OpenPrinter(szPrinterNameBuf, &hPrinter, NULL);
                hr = bStatus ? S_OK : CreateError();
            }

            if (SUCCEEDED(hr))
            {
                //
                // Try to get the default devmode for this printer.
                //
                hr = GetDefaultDevMode(hPrinter, szPrinterNameBuf, &pDevMode);
            }

            if (SUCCEEDED(hr))
            {
                //
                // The default printer is usable. Exit.
                //
                break;
            }
            else
            {
                //
                // The default printer is not usable. Now we should enumerate 
                // all the printers and find a usable one. Reset hr here.
                //
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                //
                // Enumerate the current printers.
                //
                hr = WrapEnumPrinters(PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS,
                                    NULL,
                                    4,
                                    reinterpret_cast<PVOID *>(&pInfo4),
                                    &cbInfo4,
                                    &cInfo4);
            }
                
            if (SUCCEEDED(hr))
            {
                // ERROR_FILE_NOT_FOUND will be an indication that the we have
                // no printers installer (i.e. printer's folder is empty) in 
                // which case we should suggest the user to install a printer.

                hr = cInfo4 ? S_OK : HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                //
                // Open the printers until we find one we have access to.
                //
                for (UINT i = 0; i<cInfo4; i++)
                {
                    if (hPrinter)
                    {
                        ClosePrinter(hPrinter);
                        hPrinter = NULL;
                    }

                    if (pDevMode)
                    {
                        GlobalFree((HANDLE)pDevMode);
                        pDevMode = NULL;
                    }

                    if (SUCCEEDED(hr))
                    {
                        bStatus = OpenPrinter(pInfo4[i].pPrinterName, &hPrinter, NULL);
                        hr = bStatus ? S_OK : CreateError();
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Try to get the default devmode for this printer.
                        //
                        hr = GetDefaultDevMode(hPrinter, pInfo4[i].pPrinterName, &pDevMode);
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Found a usable printer
                        //
                        StringCchCopy(szPrinterNameBuf, cchBuf, pInfo4[i].pPrinterName);
                        break;
                    }
                }
            }
        }
        while (false);
    }

    //
    // Cleanup...
    //
    if (pInfo4)
    {
        GlobalFree((HANDLE)pInfo4);
    }

    if (hPrinter)
    {
        ClosePrinter(hPrinter);
        hPrinter = NULL;
    }

    if (pDevMode)
    {
        GlobalFree((HANDLE)pDevMode);
        pDevMode = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetInternalDevMode
//
//  Get the internal devmode for this printer and merge with pInDevMode
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::GetInternalDevMode(PDEVMODE *ppOutDevMode, LPCTSTR pszPrinter, HANDLE hPrinter, PDEVMODE pInDevMode)
{
    HRESULT                 hr = S_OK;
    LONG                    lResult = 0;
    PDEVMODE                pDevMode = NULL;

    if (SUCCEEDED(hr))
    {
        //
        // Validate parameters.
        //
        hr = ppOutDevMode ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *ppOutDevMode = NULL;

        //
        // Get the default devmode for this printer.
        //
        hr = GetDefaultDevMode(hPrinter, pszPrinter, &pDevMode);
    }

    //
    // If fetched a default devmode and we were passed a devmode
    // then call the driver to merge the devmodes for us.
    //
    if (SUCCEEDED(hr))
    {
        if (pInDevMode)
        {
            //
            // Call document properties to get a merged copy of the devmode.
            //
            lResult = DocumentProperties(NULL,
                                         hPrinter,
                                         const_cast<LPTSTR>(pszPrinter),
                                         pDevMode,
                                         pInDevMode,
                                         DM_IN_BUFFER|DM_OUT_BUFFER);

            hr = (lResult >= 0) ? S_OK : CreateError();
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Everything has succeeded. Move locals to out parameters.
        //
        *ppOutDevMode = pDevMode;
        pDevMode = NULL;
    }

    //
    // Cleanup...
    //
    if (pDevMode)
    {
        GlobalFree((HANDLE)pDevMode);
        pDevMode = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InstallDevMode
//
//  Install a new internal devmode
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::InstallDevMode(LPCTSTR pszPrinterName, PDEVMODE pDevModeToMerge) 
{ 
    HRESULT                 hr = S_OK;
    BOOL                    bStatus = FALSE;
    TCHAR                   szBuffer[kPrinterBufMax];
    HANDLE                  hTempPrinter = NULL;
    PDEVMODE                pTempDevMode = NULL;
    DWORD                   dwSize;

    if (SUCCEEDED(hr))
    {
        dwSize = ARRAYSIZE(szBuffer);

        //
        // If a null printer name was specified use the default printer.
        //
        if (!pszPrinterName || !*pszPrinterName)
        {
            hr = GetUsablePrinter(szBuffer, &dwSize);

            if (SUCCEEDED(hr))
            {
                pszPrinterName = szBuffer;
            }
            else
            {
                //
                // GetDefaultPrinter fails with ERROR_FILE_NOT_FOUND if we
                // have no printers. 
                //
                // ERROR_FILE_NOT_FOUND will be an indication that the we have
                // no printers installer (i.e. printer's folder is empty) in 
                // which case we should suggest the user to install a printer.
                //
                bStatus = GetDefaultPrinter(szBuffer, &dwSize);
                hr = bStatus ? S_OK : CreateError();

                if (SUCCEEDED(hr))
                {
                    pszPrinterName = szBuffer;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Check if this is not the current printer in which case,
        // just do nothing.
        //
        if (pszPrinterName && _tcsicmp(pszPrinterName, szPrinter))
        {
            if (SUCCEEDED(hr))
            {
                bStatus = OpenPrinter((LPTSTR)pszPrinterName, &hTempPrinter, NULL);
                hr = bStatus ? S_OK : CreateError();
            }

            if (SUCCEEDED(hr))
            {
                hr = GetInternalDevMode(&pTempDevMode, pszPrinterName, hTempPrinter, pDevModeToMerge);
            }

            if (SUCCEEDED(hr))
            {
                if (hPrinter)
                {
                    ClosePrinter(hPrinter);
                    hPrinter = NULL;
                }

                if (pInternalDevMode)
                {
                    GlobalFree((HANDLE)pInternalDevMode);
                    pInternalDevMode = NULL;
                }

                StringCchCopy(szPrinter, ARRAYSIZE(szPrinter), pszPrinterName);

                hPrinter = hTempPrinter;
                hTempPrinter = NULL;

                pInternalDevMode = pTempDevMode;
                pTempDevMode = NULL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pInternalDevMode)
        {
            //
            // Enable the driver UI button
            //
            EnableWindow(GetDlgItem( hwndDlg, IDC_DRIVER ), TRUE);
        }
    }

    //
    // Cleanup...
    //
    if (hTempPrinter)
    {
        ClosePrinter(hTempPrinter);
        hTempPrinter = NULL;
    }

    if (pTempDevMode)
    {
        GlobalFree((HANDLE)pTempDevMode);
        pTempDevMode = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::UninstallDevMode
//
//  Unintall the current devmode
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::UninstallDevMode()
{ 
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
        hPrinter = NULL;
    }

    if (pInternalDevMode)
    {
        GlobalFree((HANDLE)pInternalDevMode);
        pInternalDevMode = NULL;
    }

    //
    // Clear the internal printer name.
    //
    szPrinter[0] = 0;

    //
    // Disable the driver UI button
    //
    EnableWindow(GetDlgItem( hwndDlg, IDC_DRIVER ), FALSE);

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
//  InvokeAddPrinterWizardModal
//
//  This is a global API declared in comdlg32.h
//
////////////////////////////////////////////////////////////////////////////

HRESULT 
InvokeAddPrinterWizardModal(
    IN  HWND hwnd,
    OUT BOOL *pbPrinterAdded
    )
{
    HRESULT hr = S_OK;
    if (Print_LoadLibraries() && g_pfnPrinterSetup)
    {
        BOOL bPrinterAdded = FALSE;
        TCHAR szBuffer[kPrinterBufMax];
        UINT uSize = ARRAYSIZE(szBuffer);
        szBuffer[0] = 0;

        //
        // Invoke the Add Printer Wizard here
        //
        bPrinterAdded = g_pfnPrinterSetup(hwnd, MSP_NEWPRINTER, uSize, szBuffer, &uSize, NULL);

        if (pbPrinterAdded)
        {
            *pbPrinterAdded = bPrinterAdded;
        }
    }
    else
    {
        hr = CreateError();
    }
    return hr;
}

/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

HRESULT ThunkPrintDlgEx(
    PPRINTINFOEX pPI,
    LPPRINTDLGEXA pPDA)
{
    LPPRINTDLGEXW pPDW;
    LPDEVMODEA pDMA;
    DWORD cbLen;

    if (!pPDA)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGEXA))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    if (!(pPDW = (LPPRINTDLGEXW)GlobalAlloc(GPTR, sizeof(PRINTDLGEXW))))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return (E_OUTOFMEMORY);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize      = sizeof(PRINTDLGEXW);
    pPDW->hwndOwner        = pPDA->hwndOwner;
    pPDW->ExclusionFlags   = pPDA->ExclusionFlags;
    pPDW->hInstance        = pPDA->hInstance;
    pPDW->lpCallback       = pPDA->lpCallback;
    pPDW->nPropertyPages   = pPDA->nPropertyPages;
    pPDW->lphPropertyPages = pPDA->lphPropertyPages;
    pPDW->nStartPage       = pPDA->nStartPage;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA((LPCSTR)pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    //
    //  Thunk Device Names A => W
    //
    pPDW->hDevNames = NULL;
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName = (LPCWSTR)
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                return (E_OUTOFMEMORY);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpPrintTemplateName,(LPWSTR)pPDW->lpPrintTemplateName,cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            pPDW->lpPrintTemplateName = (LPCWSTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Store the info in the PRINTINFOEX structure.
    //
    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlgEx(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;

    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExA2W(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;
    LPPRINTDLGEXA pPDA = pPI->pPDA;

    //
    //  Copy info A => W
    //
    pPDW->hDC            = pPDA->hDC;
    pPDW->Flags          = pPDA->Flags;
    pPDW->Flags2         = pPDA->Flags2;
    pPDW->nPageRanges    = pPDA->nPageRanges;
    pPDW->nMaxPageRanges = pPDA->nMaxPageRanges;
    pPDW->lpPageRanges   = pPDA->lpPageRanges;
    pPDW->nMinPage       = pPDA->nMinPage;
    pPDW->nMaxPage       = pPDA->nMaxPage;
    pPDW->nCopies        = pPDA->nCopies;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExW2A(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXA pPDA = pPI->pPDA;
    LPPRINTDLGEXW pPDW = pPI->pPD;

    //
    //  Copy info W => A
    //
    pPDA->hDC            = pPDW->hDC;
    pPDA->Flags          = pPDW->Flags;
    pPDA->Flags2         = pPDW->Flags2;
    pPDA->nPageRanges    = pPDW->nPageRanges;
    pPDA->nMaxPageRanges = pPDW->nMaxPageRanges;
    pPDA->lpPageRanges   = pPDW->lpPageRanges;
    pPDA->nMinPage       = pPDW->nMinPage;
    pPDA->nMaxPage       = pPDW->nMaxPage;
    pPDA->nCopies        = pPDW->nCopies;
    pPDA->dwResultAction = pPDW->dwResultAction;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesW2A(pPDW->hDevNames, &pPDA->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Check that realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode  = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied.
                pPDA->hDevMode = GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\prnsetup.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.c

Abstract:

    This module implements the Win32 print dialogs.

Revision History:

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "prnsetup.h"
#include "util.h"

//
//  The PrintDlgEx routines.
//
extern VOID Print_UnloadLibraries();
extern BOOL Print_NewPrintDlg(PPRINTINFO pPI);





////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgA
//
//  ANSI entry point for PrintDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlgA(
    LPPRINTDLGA pPDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    DWORD Flags;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    if (bResult = ThunkPrintDlg(&PI, pPDA))
    {
        ThunkPrintDlgA2W(&PI);

        Flags = pPDA->Flags;

        bResult = PrintDlgX(&PI);

        if ((bResult) || (Flags & (PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK)))
        {
            ThunkPrintDlgW2A(&PI);
        }
    }
    FreeThunkPrintDlg(&PI);

    return (bResult);
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlg
//
//  The PrintDlg function displays a Print dialog box or a Print Setup
//  dialog box.  The Print dialog box enables the user to specify the
//  properties of a particular print job.  The Print Setup dialog box
//  allows the user to select additional job properties and to configure
//  the printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlg(
    LPPRINTDLG pPD)
{
    PRINTINFO PI;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgX(&PI) );
}

////////////////////////////////////////////////////////////////////////////
//
//  ShowErrorMessage
//
//  Shows an error message
//
////////////////////////////////////////////////////////////////////////////

static HRESULT ShowErrorMessage(
    IN  const PRINTDLG *pPD,
    IN  const PRINTINFO *pPI,
    OUT BOOL *pbTryAgain        OPTIONAL
    )
{
    HRESULT hr = S_OK;
    BOOL bTryAgain = FALSE;
    BOOL bPrinterAdded = FALSE;

    if (!(pPD->Flags & PD_NOWARNING))
    {
        DWORD dwErr = GetStoredExtendedError();

        //
        //  Only do this for new apps.
        //
        if ( (pPI->ProcessVersion >= 0x40000) ||
             (dwErr == PDERR_NODEFAULTPRN) ||
             (dwErr == PDERR_PRINTERNOTFOUND) )
        {
            TCHAR szWarning[SCRATCHBUF_SIZE];
            TCHAR szTitle[SCRATCHBUF_SIZE];
            int iszWarning;

            szTitle[0] = TEXT('\0');
            if (pPD->hwndOwner)
            {
                GetWindowText(pPD->hwndOwner, szTitle, SCRATCHBUF_SIZE);
            }
            if (!szTitle[0])
            {
                CDLoadString(g_hinst, iszWarningTitle, szTitle, ARRAYSIZE(szTitle));
            }

            switch (dwErr)
            {
                case ( PDERR_NODEFAULTPRN ) :
                {
                    //
                    //  Notes: if the app is a 16-bit app, we don't ask the user whether to install a
                    //  new printer. This is because some components may break if we do it.
                    //

                    if (IS16BITWOWAPP(pPD))
                    {
                        iszWarning = iszNoPrnsInstalled;
                    }
                    else
                    {
                        iszWarning = iszNoPrinters;
                    }
                    break;
                }
                case ( PDERR_PRINTERNOTFOUND ) :
                {
                    iszWarning = iszPrnNotFound;
                    break;
                }
                case ( CDERR_MEMLOCKFAILURE ) :
                case ( CDERR_MEMALLOCFAILURE ) :
                case ( PDERR_LOADDRVFAILURE ) :
                {
                    iszWarning = iszMemoryError;
                    break;
                }
                default :
                {
                    iszWarning = iszGeneralWarning;
                    break;
                }
            }

            if (iszWarning == iszNoPrnsInstalled)
            {
                FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    ERROR_PRINTER_NOT_FOUND,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR)szWarning,
                    ARRAYSIZE(szWarning),
                    NULL);
            }
            else
            {
                CDLoadString(g_hinst, iszWarning, szWarning, ARRAYSIZE(szWarning));
            }

            MessageBeep(MB_ICONEXCLAMATION);

            if (iszWarning == iszNoPrinters)
            {
                //
                // If the problem is that there are no printers installed then ask the
                // user if he wants to add one, and then launch the add printer wizard.
                //
                if (IDYES == MessageBox( pPD->hwndOwner,
                                         szWarning,
                                         szTitle,
                                         MB_ICONQUESTION | MB_YESNO))
                {
                    hr = InvokeAddPrinterWizardModal(pPD->hwndOwner, &bPrinterAdded);

                    if (SUCCEEDED(hr) && bPrinterAdded)
                    {
                        //
                        // A printer was added successfully. Tell the caller to try again.
                        //
                        bTryAgain = TRUE;
                    }
                }
            }
            else
            {
                //
                // This is a fatal error. Just show an error message and bail.
                //
                MessageBox( pPD->hwndOwner,
                            szWarning,
                            szTitle,
                            MB_ICONEXCLAMATION | MB_OK );
            }
        }
    }

    if (pbTryAgain)
    {
        *pbTryAgain = bTryAgain;
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgX
//
//  Worker routine for the PrintDlg api.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintDlgX(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    BOOL nResult = -1;                      // <0==error, 0==CANCEL, >0==OK
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDevMode = NULL;
    LPDEVNAMES pDN = NULL;
    DWORD dwFlags;                          // old copy
    WORD nCopies, nFromPage, nToPage;       // old copy
    HGLOBAL hDevNames, hDevMode;            // old copy
    TCHAR szPrinterName[MAX_PRINTERNAME];   // old copy
    LONG cbNeeded;
    DWORD dwResult = 0;
    BOOL bTryAgain = TRUE;


    if (!pPD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPD->lStructSize != sizeof(PRINTDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pPD->hwndOwner && !IsWindow(pPD->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    //
    //  See if the application should get the new look.
    //
    //  Do not allow the new look if they have hooks, templates,
    //  Invalid hwndOwner,
    //  they want the setup dialog, or they just want to get the default
    //  printer.
    //
    //  Also don't allow the new look if we are in the context of
    //  a 16 bit process.
    //
    if ( (!(pPI->Status & PI_PRINTDLGX_RECURSE)) &&
         (!pPI->pPSD) &&
         ((!(pPD->Flags & (PD_PAGESETUP |
                           PD_PRINTSETUP |
                           PD_RETURNDEFAULT |
                           PD_ENABLEPRINTHOOK |
                           PD_ENABLESETUPHOOK |
                           PD_ENABLEPRINTTEMPLATE |
                           PD_ENABLESETUPTEMPLATE |
                           PD_ENABLEPRINTTEMPLATEHANDLE |
                           PD_ENABLESETUPTEMPLATEHANDLE)))) &&
         (pPD->hwndOwner && IsWindow(pPD->hwndOwner)) &&
         (!IS16BITWOWAPP(pPD)) )
    {
        //
        //  Show the new dialog.
        //
        StoreExtendedError(0);

        return Print_NewPrintDlg(pPI);
    }

    //
    // Warning! Warning! Warning!
    //
    // We have to set g_tlsLangID before any call for CDLoadString
    //
    TlsSetValue(g_tlsLangID, (LPVOID) GetDialogLanguage(pPD->hwndOwner, NULL));

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

    //
    //  Check if we need to use ExtDeviceMode.  We use this
    //  mode only if a 16 bit app is calling us with a NULL
    //  devmode.
    //
    if ((pPD->Flags & CD_WOWAPP) && !pPD->hDevMode)
    {
        pPI->bUseExtDeviceMode = TRUE;
    }
    else
    {
        pPI->bUseExtDeviceMode = FALSE;
    }

    pPD->hDC = 0;

    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        //
        //  Do not display a warning in this case if it fails.
        //  MFC 3.1 does not specify PD_NOWARNING, but that's what
        //  it really wants.
        //
        nResult = PrintReturnDefault(pPI);
        PrintClosePrinters(pPI);
        return (nResult);
    }

    if (!PrintLoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        StoreExtendedError(PDERR_SETUPFAILURE);
        goto PrintDlgX_DisplayWarning;
    }

    //
    //  Printer enumeration is delayed until the combobox is dropped down.
    //  However, if a printer is specified, we must force enumeration in
    //  order to find the printer so that the correct devmode can be created.
    //
    if ((pPD->hDevMode) &&
        (pPD->hDevNames) &&
        (pDM = GlobalLock(pPD->hDevMode)))
    {
        if (pDN = GlobalLock(pPD->hDevNames))
        {
            dwResult = lstrcmp((LPTSTR)pDM->dmDeviceName,
                               (LPTSTR)pDN + pDN->wDeviceOffset);
            GlobalUnlock(pPD->hDevNames);
        }
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  First : Try to open the printer in the DevMode.
    //
    //  Note: The printer name field in the DEVMODE struct is limited to
    //        32 chars which may cause this case to fail.
    //
    if ( (!dwResult) &&
         (!pPI->hCurPrinter) &&
         (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
        PrintOpenPrinter(pPI, pDM->dmDeviceName);
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  Second : Try to open the printer in the DevNames.
    //
    if ( (!pPI->hCurPrinter) &&
         (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintOpenPrinter(pPI, (LPTSTR)pDN + pDN->wDeviceOffset);
        GlobalUnlock(pPD->hDevNames);
    }

    for (;;)
    {
        //
        //  Third : Try to open the Default Printer.
        //
        PrintGetDefaultPrinterName(pPI->szDefaultPrinter, MAX_PRINTERNAME);
        if (!pPI->hCurPrinter)
        {
            if (pPI->szDefaultPrinter[0])
            {
                PrintOpenPrinter(pPI, pPI->szDefaultPrinter);
            }
        }

        //
        //  Fourth : Enumerate the Printers and try to open one of those.
        //
        if (!pPI->hCurPrinter)
        {
            if (!PrintEnumAndSelect(pPD->hwndOwner, 0, pPI, NULL, TRUE))
            {
                //
                //  There are no printers installed in the system.
                //
                if (SUCCEEDED(ShowErrorMessage(pPD, pPI, &bTryAgain)) && bTryAgain)
                {
                    //
                    // The user has installed a printer. Let's try again now.
                    //
                    continue;
                }
            }
        }

        break;
    }

    if (!bTryAgain && IS16BITWOWAPP(pPD))
    {
        //
        //  If it's a 16-bit app, we'll return immediately without showing
        //  warning message. This is because some 16-bit app will crash in
        //  the common print dialog.
        //
        return (FALSE);
    }

    //
    //  Save the original information passed in by the app in case the user
    //  hits cancel.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    nFromPage = pPD->nFromPage;
    nToPage = pPD->nToPage;
    hDevNames = pPD->hDevNames;
    hDevMode = pPD->hDevMode;
    if ((pPI->pCurPrinter) &&
        (lstrlen(pPI->pCurPrinter->pPrinterName) < ARRAYSIZE(szPrinterName)))
    {
        StringCchCopy(szPrinterName, ARRAYSIZE(szPrinterName), pPI->pCurPrinter->pPrinterName);
    }
    else
    {
        szPrinterName[0] = 0;
    }

    pPD->hDevNames = NULL;
    pPD->hDevMode = NULL;

    //
    //  Build a copy of the DevNames.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the *correct* DevMode.
    //
    if (hDevMode)
    {
        pDevMode = GlobalLock(hDevMode);
    }
    else
    {
        //
        //  If it's WOW and the app didn't specify a devmode, get the 16-bit
        //  devmode out of the registry (ie. win.ini [Windows] device section).
        //
        if (pPI->bUseExtDeviceMode && pPI->pCurPrinter)
        {
            pDevMode = (pPI->pCurPrinter)->pDevMode;
            if (pDevMode)
            {
                cbNeeded = sizeof(DEVMODEW) + pDevMode->dmDriverExtra;
                goto GotWOWDMSize;
            }

            //
            //  If a 16-bit devmode isn't available in the registry,
            //  drop through and get the system default devmode.
            //
        }
    }

    cbNeeded = DocumentProperties( pPD->hwndOwner,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );
GotWOWDMSize:
    if ((cbNeeded > 0) &&
        (pPD->hDevMode = GlobalAlloc(GHND, cbNeeded)))
    {
        BOOL fSuccess = FALSE;

        if (pDM = GlobalLock(pPD->hDevMode))
        {
            if (pPI->bUseExtDeviceMode && !hDevMode)
            {
                CopyMemory(pDM, pDevMode, cbNeeded);
                fSuccess = TRUE;
                goto GotNewWOWDM;
            }

            fSuccess = DocumentProperties( pPD->hwndOwner,
                                           pPI->hCurPrinter,
                                           (pPI->pCurPrinter)
                                               ? pPI->pCurPrinter->pPrinterName
                                               : NULL,
                                           pDM,            // out
                                           pDevMode,       // in
                                           DM_MODIFY | DM_COPY ) == IDOK;
GotNewWOWDM:
            if (pDM->dmFields & DM_COPIES)
            {
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES))
                {
                    pPD->nCopies = pDM->dmCopies;
                }
                else if (pPD->nCopies)
                {
                    pDM->dmCopies = pPD->nCopies;
                }
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                //
                // if PD_COLLATE is not set, we also use the setting in
                // the returned DEVMODE structure
                //
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES) || !(pPD->Flags & PD_COLLATE))
                {
                    if (pDM->dmCollate == DMCOLLATE_FALSE)
                    {
                        pPD->Flags  &= ~PD_COLLATE;
                        pPI->Status &= ~PI_COLLATE_REQUESTED;
                    }
                    else
                    {
                        pPD->Flags  |= PD_COLLATE;
                        pPI->Status |= PI_COLLATE_REQUESTED;
                    }
                }
                else // in this case (pPD->Flags & PD_COLLATE) must be TRUE
                {
                    pDM->dmCollate = DMCOLLATE_TRUE;
                }
            }

            GlobalUnlock(pPD->hDevMode);
        }

        if (!fSuccess)
        {
            GlobalFree(pPD->hDevMode);
            pPD->hDevMode = NULL;
        }
    }

    if (hDevMode)
    {
        GlobalUnlock(hDevMode);
    }

    //
    //  Get the default source string.
    //
    CDLoadString(g_hinst, iszDefaultSource, szDefaultSrc, ARRAYSIZE(szDefaultSrc));

    //
    //  Call the appropriate dialog routine.
    //
    switch (pPD->Flags & (PD_PRINTSETUP | PD_PAGESETUP))
    {
        case ( 0 ) :
        {
            nResult = PrintDisplayPrintDlg(pPI);
            break;
        }
        case ( PD_PRINTSETUP ) :
        case ( PD_PAGESETUP ) :
        {
            nResult = PrintDisplaySetupDlg(pPI);
            break;
        }
        default :
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            break;
        }
    }

    if (nResult > 0)
    {
        //
        //  User hit OK, so free the copies of the handles passed in
        //  by the app.
        //
        if (hDevMode && (hDevMode != pPD->hDevMode))
        {
            GlobalFree(hDevMode);
            hDevMode = NULL;
        }
        if (hDevNames && (hDevNames != pPD->hDevNames))
        {
            GlobalFree(hDevNames);
            hDevNames = NULL;
        }

        if (pPD->hDevMode)
        {
            //
            //  Make sure the device name in the devmode is null
            //  terminated.
            //
            pDevMode = GlobalLock(pPD->hDevMode);
            pDevMode->dmDeviceName[CCHDEVICENAME - 1] = 0;
            GlobalUnlock(pPD->hDevMode);
        }
    }
    else
    {
        //
        //  User hit CANCEL or there was an error, so restore original
        //  values passed in by the app.
        //
        pPD->Flags = dwFlags;
        pPD->nCopies = nCopies;
        pPD->nFromPage = nFromPage;
        pPD->nToPage = nToPage;
        if (pPD->hDevMode && (pPD->hDevMode != hDevMode))
        {
            GlobalFree(pPD->hDevMode);
        }
        if (pPD->hDevNames && (pPD->hDevNames != hDevNames))
        {
            GlobalFree(pPD->hDevNames);
        }
        pPD->hDevNames = hDevNames;
        pPD->hDevMode = hDevMode;

        //
        //  If we've been called from Page Setup, then we need to reset
        //  the current printer.
        //
        if (pPI->Status & PI_PRINTDLGX_RECURSE)
        {
            PrintCancelPrinterChanged(pPI, szPrinterName);
        }
    }

    //
    //  Make sure that we are really supposed to be leaving this function
    //  before we start closing printers and displaying error messages.
    //
    if (pPI->Status & PI_PRINTDLGX_RECURSE)
    {
        return (nResult > 0);
    }

    //
    //  Close the printers that were opened.
    //
    PrintClosePrinters(pPI);

    //
    //  Display any error messages.
    //
PrintDlgX_DisplayWarning:

    if (nResult < 0 && bTryAgain)
    {
        //
        // Display an error message and ignore the return code since we
        // don't care. If bTryAgain is FALSE, this means the user selects
        // not to install new printer. Don't show a duplicate error
        // message in this case.
        //
        ShowErrorMessage(pPD, pPI, NULL);
    }

    return (nResult > 0);
}

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgA
//
//  ANSI entry point for PageSetupDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlgA(
    LPPAGESETUPDLGA pPSDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    HANDLE hDevMode;
    HANDLE hDevNames;
    LPCSTR pTemplateName;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    //
    //  Get the pPDA structure from the pPSDA structure.
    //
    if (bResult = ThunkPageSetupDlg(&PI, pPSDA))
    {
        //
        //  Save the original devmode and devnames.
        //
        hDevMode = pPSDA->hDevMode;
        hDevNames = pPSDA->hDevNames;
        pTemplateName = pPSDA->lpPageSetupTemplateName;

        //
        //  Convert the pPDA structure to Unicode (pPI->pPD).
        //
        if (bResult = ThunkPrintDlg(&PI, PI.pPDA))
        {
            //
            //  Fill in the pPI->pPD structure.
            //
            ThunkPrintDlgA2W(&PI);

            //
            //  Copy the Unicode information from the pPD structure to
            //  the pPSD structure for the call to PageSetupDlgX.
            //
            (PI.pPSD)->hDevMode  = (PI.pPD)->hDevMode;
            (PI.pPSD)->hDevNames = (PI.pPD)->hDevNames;

            (PI.pPSD)->lpPageSetupTemplateName = (PI.pPD)->lpSetupTemplateName;

            //
            //  Call the PageSetupDlgX function to do the work.
            //
            if (bResult = PageSetupDlgX(&PI))
            {
                //
                //  Success.  Convert the Unicode pPD structure to
                //  its ANSI equivalent.
                //
                ThunkPrintDlgW2A(&PI);

                //
                //  Save the ANSI devmode and devnames in the
                //  pPSD structure to be returned to the caller.
                //
                pPSDA->hDevMode  = (PI.pPDA)->hDevMode;
                pPSDA->hDevNames = (PI.pPDA)->hDevNames;
            }
            else
            {
                //
                //  Failure.  Restore the old devmode and devnames.
                //
                pPSDA->hDevMode = hDevMode;
                pPSDA->hDevNames = hDevNames;
            }

            //
            //  Restore the old template name (always).
            //
            pPSDA->lpPageSetupTemplateName = pTemplateName;
        }
        FreeThunkPrintDlg(&PI);
    }
    FreeThunkPageSetupDlg(&PI);

    return (bResult);
}

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlg
//
//  The PageSetupDlg function displays a Page Setup dialog box.  This
//  dialog box enables the user to specify the page orientation, the
//  paper size, the paper source, and the margin settings.  The
//  appearance of the printed page is shown in the dialog's page preview.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlg(
    LPPAGESETUPDLG pPSD)
{
    PRINTINFO PI;
    BOOL bResult;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPSD = pPSD;
    PI.ApiType = COMDLG_WIDE;

    bResult = PageSetupDlgX(&PI);

    if (PI.pPD)
    {
        GlobalFree(PI.pPD);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgX
//
//  Worker routine for the PageSetupDlg api.
//
//  NOTE:  Caller of this routine must free pPI->pPD.
//
////////////////////////////////////////////////////////////////////////////

BOOL PageSetupDlgX(
    PPRINTINFO pPI)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    BOOL bResult = FALSE;
    LPPRINTDLG pPD;
    RECT rtMinMargin;
    RECT rtMargin;
    POINT ptPaperSize;
    DWORD Flags;


    if (!pPSD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSD->lStructSize != sizeof(PAGESETUPDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_RETURNDEFAULT) &&
        (pPSD->hDevNames || pPSD->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Make sure only the PSD_* bits are on.  Otherwise, bad things
    //  will happen.
    //
    if ((pPSD->Flags & ~(PSD_MINMARGINS |
                         PSD_MARGINS |
                         PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS |
                         PSD_DISABLEMARGINS |
                         PSD_DISABLEPRINTER |
                         PSD_NOWARNING |                     // must be same as PD_*
                         PSD_DISABLEORIENTATION |
                         PSD_DISABLEPAPER |
                         PSD_RETURNDEFAULT |                 // must be same as PD_*
                         PSD_SHOWHELP |                      // must be same as PD_*
                         PSD_ENABLEPAGESETUPHOOK |           // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATE |       // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE | // must be same as PD_*
                         PSD_ENABLEPAGEPAINTHOOK |
                         PSD_DISABLEPAGEPAINTING |
                         CD_WX86APP |
                         PSD_NONETWORKBUTTON))  ||           // must be same as PD_*
        ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS)) ==
         (PSD_INTHOUSANDTHSOFINCHES | PSD_INHUNDREDTHSOFMILLIMETERS)))
    {
        StoreExtendedError(PDERR_INITFAILURE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_MINMARGINS) && (pPSD->Flags & PSD_MARGINS))
    {
        if ( (pPSD->rtMargin.left   < pPSD->rtMinMargin.left)  ||
             (pPSD->rtMargin.top    < pPSD->rtMinMargin.top)   ||
             (pPSD->rtMargin.right  < pPSD->rtMinMargin.right) ||
             (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (FALSE);
        }
    }

    if (pPSD->Flags & PSD_ENABLEPAGESETUPHOOK)
    {
        if (!pPSD->lpfnPageSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPageSetupHook = NULL;
    }

    if (pPSD->Flags & PSD_ENABLEPAGEPAINTHOOK)
    {
        if (!pPSD->lpfnPagePaintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPagePaintHook = NULL;
    }

    if ((pPI->pPD) || (pPI->pPD = GlobalAlloc(GPTR, sizeof(PRINTDLG))))
    {
        pPD = pPI->pPD;

        pPD->lStructSize         = sizeof(PRINTDLG);
        pPD->hwndOwner           = pPSD->hwndOwner;
        pPD->Flags               = PD_PAGESETUP |
                                     (pPSD->Flags &
                                       (PSD_NOWARNING |
                                        PSD_SHOWHELP |
                                        PSD_ENABLEPAGESETUPHOOK |
                                        PSD_ENABLEPAGESETUPTEMPLATE |
                                        PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                        CD_WX86APP |
                                        PSD_NONETWORKBUTTON));
        pPD->hInstance           = pPSD->hInstance;
        pPD->lCustData           = pPSD->lCustData;
        pPD->lpfnSetupHook       = pPSD->lpfnPageSetupHook;
        pPD->lpSetupTemplateName = pPSD->lpPageSetupTemplateName;
        pPD->hSetupTemplate      = pPSD->hPageSetupTemplate;

        //
        //  Save original settings in case the user hits cancel.
        //
        rtMinMargin = pPSD->rtMinMargin;
        rtMargin    = pPSD->rtMargin;
        ptPaperSize = pPSD->ptPaperSize;
        Flags       = pPSD->Flags;

        //
        //  Make sure the measure choice is set.
        //
        if ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                            PSD_INHUNDREDTHSOFMILLIMETERS)) == 0)
        {
            TCHAR szIMeasure[2];

            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2);
            if (szIMeasure[0] == TEXT('1'))
            {
                pPSD->Flags |= PSD_INTHOUSANDTHSOFINCHES;
            }
            else
            {
                pPSD->Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
            }
        }

        //
        //  Set minimum margins to 0 if not passed in.
        //
        if (!(pPSD->Flags & PSD_MINMARGINS))
        {
            pPSD->rtMinMargin.left   = 0;
            pPSD->rtMinMargin.top    = 0;
            pPSD->rtMinMargin.right  = 0;
            pPSD->rtMinMargin.bottom = 0;
        }

        //
        //  Set margins to defaults if not passed in.
        //
        if (!(pPSD->Flags & PSD_MARGINS))
        {
            LONG MarginDefault = (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
                                     ? INCHES_DEFAULT
                                     : MMS_DEFAULT;

            pPSD->rtMargin.left   = MarginDefault;
            pPSD->rtMargin.top    = MarginDefault;
            pPSD->rtMargin.right  = MarginDefault;
            pPSD->rtMargin.bottom = MarginDefault;
        }

        TransferPSD2PD(pPI);

        bResult = PrintDlgX(pPI);

        TransferPD2PSD(pPI);

        if (!bResult)
        {
            //
            //  Restore original settings when the user hits cancel.
            //
            pPSD->rtMinMargin = rtMinMargin;
            pPSD->rtMargin    = rtMargin;
            pPSD->ptPaperSize = ptPaperSize;
            pPSD->Flags       = Flags;
        }
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintLoadIcons()
{
    //
    //  See if we need to load the icons.
    //
    if (bAllIconsLoaded == FALSE)
    {
        //
        //  Load the orientation icons.
        //
        hIconPortrait = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_PORTRAIT));
        hIconLandscape = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_LANDSCAPE));

        //
        //  Load the duplex icons.
        //
        hIconPDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_NONE));
        hIconLDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_NONE));
        hIconPDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_HORIZ));
        hIconLDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_VERT));
        hIconPDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_VERT));
        hIconLDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_HORIZ));

        //
        //  Load the page setup icons.
        //
        hIconPSStampP = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_PSSTAMP));
        hIconPSStampL = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_PSSTAMP));

        //
        //  Load the collation images.
        //
        hIconCollate = LoadImage( g_hinst,
                                  MAKEINTRESOURCE(ICO_COLLATE),
                                  IMAGE_ICON,
                                  0,
                                  0,
                                  LR_SHARED );
        hIconNoCollate = LoadImage( g_hinst,
                                    MAKEINTRESOURCE(ICO_NO_COLLATE),
                                    IMAGE_ICON,
                                    0,
                                    0,
                                    LR_SHARED );

        bAllIconsLoaded = ( hIconPortrait &&
                            hIconLandscape &&
                            hIconPDuplexNone &&
                            hIconLDuplexNone &&
                            hIconPDuplexTumble &&
                            hIconLDuplexTumble &&
                            hIconPDuplexNoTumble &&
                            hIconLDuplexNoTumble &&
                            hIconPSStampP &&
                            hIconPSStampL &&
                            hIconCollate &&
                            hIconNoCollate );
    }

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (bAllIconsLoaded);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplayPrintDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplayPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
    UINT uiWOWFlag = 0;


    //
    //  NOTE:  The print hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         PrintHook when calling Print Setup will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLEPRINTHOOK)
    {
        if (!pPD->lpfnPrintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnPrintHook = NULL;
    }

    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (pPD->hPrintTemplate)
        {
            hDlgTemplate = pPD->hPrintTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
        {
            if (pPD->lpPrintTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpPrintTemplateName;
                    hInstance = pPD->hInstance;

                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = MAKEINTRESOURCE(PRINTDLGORD);
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG);
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnPrintHook = GETPRINTHOOKFN(pPD);

        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );

        glpfnPrintHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplaySetupDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplaySetupDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
    UINT uiWOWFlag = 0;


    //
    //  NOTE:  The setup hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         SetupHook when calling Print will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLESETUPHOOK)
    {
        if (!pPD->lpfnSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnSetupHook = NULL;
    }

    if (pPD->Flags & PD_ENABLESETUPTEMPLATEHANDLE)
    {
        if (pPD->hSetupTemplate)
        {
            hDlgTemplate = pPD->hSetupTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLESETUPTEMPLATE)
        {
            if (pPD->lpSetupTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpSetupTemplateName;
                    hInstance = pPD->hInstance;
                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = ( (pPD->Flags & PD_PRINTSETUP)
                                 ? MAKEINTRESOURCE(PRNSETUPDLGORD)
                                 : MAKEINTRESOURCE(PAGESETUPDLGORD) );
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG);
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnSetupHook = GETSETUPHOOKFN(pPD);

        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintSetupDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );

        glpfnSetupHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgProc
//
//  Print Dialog procedure.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD;
    HWND hCtl;
    BOOL bTest;
    BOOL_PTR bResult;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnPrintHook))
        {
            LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
            }

            if ((bResult = (*lpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
            {
                if (pPI->ApiType == COMDLG_ANSI)
                {
                    ThunkPrintDlgA2W(pPI);
                }
                return (bResult);
            }
        }
    }
    else if (glpfnPrintHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
    {

        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            HourGlass(TRUE);
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            glpfnPrintHook = NULL;

            pPI = (PPRINTINFO)lParam;
            pPD = pPI->pPD;
            if (pPI->pPSD)
            {
                TCHAR szTitle[32];
                RECT aRtDlg;
                RECT aRtGrp;
                RECT aRtYep;
                RECT aRtCan;
                HWND hBtnYep = GetDlgItem(hDlg, IDOK);
                HWND hBtnCan = GetDlgItem(hDlg, IDCANCEL);
                RECT aRtWhere;
                RECT aRtCmmnt;
                LONG GapHeight, DlgTop;

                //
                //  Save the client coordinate for the top of the dialog.
                //  Also, save the height of the gap between the bottom of
                //  the original OK button and the bottom of the original
                //  dialog.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(hBtnYep, &aRtYep);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.left);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg, (LPPOINT)&aRtYep.right);
                DlgTop = aRtDlg.top;
                GapHeight = (aRtDlg.bottom - aRtYep.bottom > 0)
                               ? aRtDlg.bottom - aRtYep.bottom
                               : 15;

                //
                //  Display the title of the dialog box.
                //
                GetWindowText(GetParent(hDlg), szTitle, 32);
                SetWindowText(hDlg, szTitle);

                //
                //  Get the screen and client coordinates for the dialog,
                //  the Printer group box, the OK button, and the Cancel
                //  button.  These will be used to reposition the OK,
                //  Cancel, and Help buttons.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(GetDlgItem(hDlg, ID_PRINT_G_PRINTER), &aRtGrp);
                GetWindowRect(hBtnYep, &aRtYep);
                GetWindowRect(hBtnCan, &aRtCan);

                //
                //If we are in a mirrored Dlg the use the left side.
                //
                if (IS_WINDOW_RTL_MIRRORED(hDlg)) {
                    aRtDlg.right = aRtDlg.left;
                }
                ScreenToClient(hDlg   , (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg   , (LPPOINT)&aRtGrp.right);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtYep, 2);
                aRtYep.right -= aRtYep.left;
                aRtYep.bottom -= aRtYep.top;

                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtCan, 2);
                aRtCan.right -= aRtCan.left;
                aRtCan.bottom -= aRtCan.top;

                if (pPD->Flags & PD_SHOWHELP)
                {
                    HWND hBtnHlp = GetDlgItem(hDlg, ID_BOTH_P_HELP);
                    RECT aRtHlp;

                    //
                    //  Move the Help button up underneath the
                    //  Printer group box.
                    //
                    if (hBtnHlp)
                    {
                        GetWindowRect(hBtnHlp, &aRtHlp);
                        MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtHlp, 2);
                        aRtHlp.right -= aRtHlp.left;
                        aRtHlp.bottom -= aRtHlp.top;

                        MoveWindow( hBtnHlp,
                                    aRtHlp.left,
                                    aRtGrp.bottom + 2 * aRtHlp.bottom / 3,
                                    aRtHlp.right,
                                    aRtHlp.bottom,
                                    FALSE );
                    }
                }

                //
                //  Move the OK and Cancel buttons up underneath the
                //  Printer group box.
                //
                MoveWindow( hBtnYep,
                            aRtYep.left,
                            aRtGrp.bottom + 2 * aRtYep.bottom / 3,
                            aRtYep.right,
                            aRtYep.bottom,
                            FALSE );
                MoveWindow( hBtnCan,
                            aRtCan.left,
                            aRtGrp.bottom + 2 * aRtCan.bottom / 3,
                            aRtCan.right,
                            aRtCan.bottom,
                            FALSE );

                //
                //  Resize the dialog.
                //
                GetWindowRect(hBtnYep, &aRtYep);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtYep, 2);
                MoveWindow( hDlg,
                            aRtDlg.left,
                            aRtDlg.top,
                            aRtDlg.right,
                            (aRtYep.bottom - DlgTop) + GapHeight,
                            FALSE );

                //
                //  Hide all other print dlg items.
                //
                //  NOTE: Need to do a SetWindowPos to actually remove
                //        the window so that the AddNetButton call does
                //        not think it's there.
                //
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_TOFILE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_RANGE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_I_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_ALL),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_SELECTION),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_PAGES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );

                //
                //  Enlarge the comment edit control, since the
                //  "print to file" check box is hidden.
                //
                GetWindowRect(GetDlgItem(hDlg, ID_BOTH_S_WHERE), &aRtWhere);
                GetWindowRect( hCtl = GetDlgItem(hDlg, ID_BOTH_S_COMMENT),
                               &aRtCmmnt );
                MapWindowPoints(NULL, hDlg, (LPPOINT)&aRtCmmnt, 2);
                MoveWindow( hCtl,
                            aRtCmmnt.left,
                            aRtCmmnt.top,
                            aRtWhere.right  - aRtWhere.left,
                            aRtWhere.bottom - aRtWhere.top,
                            FALSE );

                //
                //  Add or hide net button, if necessary.
                //
                if ((pPD->Flags & PD_NONETWORKBUTTON))
                {
                    if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
                    {
                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
                else
                {
                    AddNetButton( hDlg,
                                  g_hinst,
                                  FILE_BOTTOM_MARGIN,
                                  TRUE,
                                  FALSE,
                                  TRUE);

                    //
                    //  The button can be added in two ways -
                    //      statically (they have it predefined in their template) and
                    //      dynamically (successful call to AddNetButton).
                    //
                    if (!IsNetworkInstalled())
                    {
                        hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
            }
            else
            {
                if (pPD->Flags & PD_COLLATE)
                {
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            if (!PrintInitGeneral(hDlg, ID_PRINT_C_NAME, pPI) ||
                ((dwResult = PrintInitPrintDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, -2);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_PRINT_C_NAME ) :       // Printer Name combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                    }
                    else if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                              !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_PRINT_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_PRINT_C_NAME, pPI);

                    break;
                }
                case ( ID_PRINT_P_SETUP ) :      // Setup... button
                {
                    DWORD dwFlags = pPD->Flags;
                    HWND hwndOwner = pPD->hwndOwner;

                    pPD->Flags |= PD_PRINTSETUP;
                    pPD->Flags &= ~(PD_RETURNDC | PD_RETURNIC);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;
                    pPD->hwndOwner = hDlg;

                    if (PrintDlgX(pPI))
                    {
                        if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
                        {
                            StoreExtendedError(CDERR_GENERALCODES);
                        }
                    }

                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;
                    pPD->Flags = dwFlags;
                    pPD->hwndOwner = hwndOwner;

                    break;
                }
                case ( ID_PRINT_R_ALL ) :        // Print Range - All
                case ( ID_PRINT_R_SELECTION ) :  // Print Range - Selection
                case ( ID_PRINT_R_PAGES ) :      // Print Range - Pages (From, To)
                {
                    CheckRadioButton( hDlg,
                                      ID_PRINT_R_ALL,
                                      ID_PRINT_R_PAGES,
                                      GET_WM_COMMAND_ID(wParam, lParam) );

                    //
                    //  Only move the the focus to the "From" control when
                    //  the up/down arrow is NOT used.
                    //
                    if ( !IS_KEY_PRESSED(VK_UP) &&
                         !IS_KEY_PRESSED(VK_DOWN) &&
                         ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == ID_PRINT_R_PAGES)) )
                    {
                        SendMessage( hDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hDlg, ID_PRINT_E_FROM),
                                     1L );
                    }

                    break;
                }
                case ( ID_PRINT_E_FROM ) :       // From  (Print Range - Pages)
                {
                    //
                    //  Only enable the "To" control if the "From" control
                    //  contains a value.
                    //
                    GetDlgItemInt(hDlg, ID_PRINT_E_FROM, &bTest, FALSE);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), bTest);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), bTest);

                    //  FALL THRU...
                }
                case ( ID_PRINT_E_TO ) :         // To  (Print Range - Pages)
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        CheckRadioButton( hDlg,
                                          ID_PRINT_R_ALL,
                                          ID_PRINT_R_PAGES,
                                          ID_PRINT_R_PAGES );
                    }

                    break;
                }


                case (ID_PRINT_E_COPIES ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        BOOL bTest;
                        //
                        //  Save the number of copies.
                        //
                        DWORD nCopies = GetDlgItemInt(hDlg, ID_PRINT_E_COPIES, &bTest, FALSE);

                        //
                        //  If the copy count is > 1, enable collate.  Otherwise,
                        //  disable it.
                        //
                        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
                        {
                            EnableWindow(hCtl, (nCopies > 1));
                        }

                    }

                    break;
                }

                case ( ID_PRINT_X_COLLATE ) :    // Collate check box
                {
                    if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
                    {
                        ShowWindow(hCtl, SW_HIDE);
                        SendMessage( hCtl,
                                     STM_SETICON,
                                     IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                                         ? (LONG_PTR)hIconCollate
                                         : (LONG_PTR)hIconNoCollate,
                                     0L );
                        ShowWindow(hCtl, SW_SHOW);

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                        {
                            pPI->Status |= PI_COLLATE_REQUESTED;
                        }
                        else
                        {
                            pPI->Status &= ~PI_COLLATE_REQUESTED;
                        }
                    }

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_PRINT_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_PRINT_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPI->pPDA );
                        }
                    }
                    else
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    bResult = TRUE;
                    if (!(pPI->pPSD))
                    {
                        pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                                 PD_PAGENUMS    |
                                                 PD_SELECTION   |
                                                 PD_COLLATE ));

                        pPD->nCopies = (WORD)GetDlgItemInt( hDlg,
                                                            ID_PRINT_E_COPIES,
                                                            &bTest,
                                                            FALSE );
                        if ((!bTest) || (!pPD->nCopies))
                        {
                            PrintEditError( hDlg,
                                            ID_PRINT_E_COPIES,
                                            iszCopiesZero );
                            return (TRUE);
                        }

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_R_SELECTION))
                        {
                            pPD->Flags |= PD_SELECTION;
                        }
                        else if (IsDlgButtonChecked(hDlg, ID_PRINT_R_PAGES))
                        {
                            //
                            //  Check the "From" and "To" values.
                            //
                            pPD->Flags |= PD_PAGENUMS;
                            pPD->nFromPage = (WORD)GetDlgItemInt( hDlg,
                                                                  ID_PRINT_E_FROM,
                                                                  &bTest,
                                                                  FALSE );
                            if (!bTest)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageFromError );
                                return (TRUE);
                            }

                            pPD->nToPage = (WORD)GetDlgItemInt( hDlg,
                                                                ID_PRINT_E_TO,
                                                                &bTest,
                                                                FALSE );
                            if (!bTest)
                            {
                                TCHAR szBuf[PAGE_EDIT_SIZE + 1];

                                if (GetDlgItemText( hDlg,
                                                    ID_PRINT_E_TO,
                                                    szBuf,
                                                    PAGE_EDIT_SIZE + 1 ))
                                {
                                    PrintEditError( hDlg,
                                                    ID_PRINT_E_TO,
                                                    iszPageToError );
                                    return (TRUE);
                                }
                                else
                                {
                                    pPD->nToPage = pPD->nFromPage;
                                }
                            }

                            if ( (pPD->nFromPage < pPD->nMinPage) ||
                                 (pPD->nFromPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if ( (pPD->nToPage < pPD->nMinPage) ||
                                 (pPD->nToPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_TO,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if (pPD->nFromPage > pPD->nToPage)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszFromToError );
                                return (TRUE);
                            }
                        }
                    }

                    HourGlass(TRUE);

                    if (IsDlgButtonChecked(hDlg, ID_PRINT_X_TOFILE))
                    {
                        pPD->Flags |= PD_PRINTTOFILE;
                    }

                    if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                         IsWindowEnabled(hCtl) &&
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE) )
                    {
                        pPD->Flags |= PD_COLLATE;
                    }

                    if (!PrintSetCopies(hDlg, pPI, ID_PRINT_C_NAME))
                    {
                        HourGlass(FALSE);
                        return (TRUE);
                    }

                    pDM = NULL;
                    pDN = NULL;
                    if (pPD->hDevMode)
                    {
                        pDM = GlobalLock(pPD->hDevMode);
                    }
                    if (pPD->hDevNames)
                    {
                        pDN = GlobalLock(pPD->hDevNames);
                    }
                    if (pDM && pDN)
                    {
                        DWORD nNum;

                        if ( GetDlgItem(hDlg, ID_PRINT_C_QUALITY) &&
                             (nNum = (DWORD) SendDlgItemMessage( hDlg,
                                                         ID_PRINT_C_QUALITY,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0L )) != CB_ERR )
                        {
                            pDM->dmPrintQuality =
                                (WORD)SendDlgItemMessage( hDlg,
                                                          ID_PRINT_C_QUALITY,
                                                          CB_GETITEMDATA,
                                                          (WPARAM)nNum,
                                                          0L );
                        }

                        PrintReturnICDC(pPD, pDN, pDM);
                    }
                    if (pDM)
                    {
                        GlobalUnlock(pPD->hDevMode);
                    }
                    if (pDN)
                    {
                        GlobalUnlock(pPD->hDevNames);
                    }

                    if (pPD->Flags & CD_WOWAPP)
                    {
                        UpdateSpoolerInfo(pPI);
                    }

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    glpfnPrintHook = GETPRINTHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL_PTR) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupDlgProc
//
//  Print Setup Dialog proc.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD = NULL;
    BOOL_PTR bResult;
    UINT uCmdId;
    LPDEVMODE pDM;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnSetupHook))
        {
            LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
                TransferPDA2PSD(pPI);

                pPI->NestCtr++;
                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);
                pPI->NestCtr--;

                if (bResult)
                {
                    TransferPSD2PDA(pPI);
                    ThunkPrintDlgA2W(pPI);
                    if (pPI->NestCtr == 0)
                    {
                        TransferPD2PSD(pPI);
                    }
                    return (bResult);
                }
            }
            else
            {
                TransferPD2PSD(pPI);

                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);

                if (bResult)
                {
                    TransferPSD2PD(pPI);
                    return (bResult);
                }
            }
        }
    }
    else if (glpfnSetupHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnSetupHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            //
            // Disable RTL mirroring on the WHITE-SAMPLE
            //
            SetWindowLong(GetDlgItem(hDlg, ID_SETUP_W_SAMPLE),
                          GWL_EXSTYLE,
                          GetWindowLong(GetDlgItem(hDlg, ID_SETUP_W_SAMPLE), GWL_EXSTYLE) & ~RTL_MIRRORED_WINDOW);
            HourGlass(TRUE);
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            pPI = (PPRINTINFO)lParam;
            pPI->bKillFocus = FALSE;
            glpfnSetupHook = NULL;

            if (!PrintInitGeneral(hDlg, ID_SETUP_C_NAME, pPI) ||
                ((dwResult = PrintInitSetupDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, FALSE);
            }
            else if (pPI->pPSD && (pPI->pPSD->Flags & PSD_RETURNDEFAULT))
            {
                //
                //  PSD_RETURNDEFAULT goes through the entire initialization
                //  in order to set rtMinMargin, rtMargin, and ptPaperSize.
                //  Win95 Notepad relies on this behavior.
                //
                SendMessage(hDlg, WM_COMMAND, IDOK, 0);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (uCmdId = GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_SETUP_C_NAME ) :       // Printer Name combobox
                {
                    if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                         !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_SETUP_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                    {
                        break;
                    }
                    if ( !GetDlgItem(hDlg, ID_SETUP_R_SPECIFIC) ||
                         IsDlgButtonChecked(hDlg, ID_SETUP_R_SPECIFIC) )
                    {
                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        break;
                    }

                    uCmdId = ID_SETUP_R_SPECIFIC;

                    // FALL THRU...
                }
                case ( ID_SETUP_R_DEFAULT ) :    // Default printer
                case ( ID_SETUP_R_SPECIFIC ) :   // Specific printer
                {
                    //
                    //  Sanity check for Publisher bug where user tries to
                    //  set focus to ID_SETUP_R_DEFAULT on exit if the
                    //  dialog has no default printer.
                    //
                    if (pPI->hCurPrinter)
                    {
                        HWND hCmb;
                        DWORD dwStyle;

                        hCmb = GetDlgItem(hDlg, ID_SETUP_C_NAME);
                        if (hCmb && (uCmdId == ID_SETUP_R_DEFAULT))
                        {
                            if (!(pPI->Status & PI_PRINTERS_ENUMERATED))
                            {
                                //
                                //  Enumerate printers if this hasn't been
                                //  done yet.  Otherwise, the default printer
                                //  may not be found in the list box when
                                //  switching from Specific to Default.
                                //
                                PrintEnumAndSelect( hDlg,
                                                    ID_SETUP_C_NAME,
                                                    pPI,
                                                    NULL,
                                                    TRUE );
                            }

                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (WPARAM)SendMessage(
                                             hCmb,
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM)-1,
                                             (LPARAM)(pPI->szDefaultPrinter) ),
                                         (LPARAM)0 );
                        }

                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);

                        CheckRadioButton( hDlg,
                                          ID_SETUP_R_DEFAULT,
                                          ID_SETUP_R_SPECIFIC,
                                          uCmdId);

                        dwStyle = GetWindowLong(hCmb, GWL_STYLE);
                        if (uCmdId == ID_SETUP_R_DEFAULT)
                        {
                            dwStyle &= ~WS_TABSTOP;
                        }
                        else
                        {
                            dwStyle |= WS_TABSTOP;
                            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hCmb, 1L);
                        }
                        SetWindowLong(hCmb, GWL_STYLE, dwStyle);
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_SETUP_C_NAME, pPI);

                    break;
                }
                case ( ID_SETUP_P_MORE ) :      // More... button
                {
                    pDM = GlobalLock(pPD->hDevMode);

                    AdvancedDocumentProperties( hDlg,
                                                pPI->hCurPrinter,
                                                (pPI->pCurPrinter)
                                                  ? pPI->pCurPrinter->pPrinterName
                                                  : NULL,
                                                pDM,
                                                pDM );

                    GlobalUnlock(pPD->hDevMode);
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    break;
                }
                case ( ID_SETUP_R_PORTRAIT ) :   // Portrait
                case ( ID_SETUP_R_LANDSCAPE ) :  // Landscape
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetOrientation( hDlg,
                                             pPI,
                                             pDM,
                                             pPI->uiOrientationID,
                                             uCmdId );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //  FALL THRU ...
                }
                case ( ID_SETUP_R_NONE ) :       // None       (2-Sided)
                case ( ID_SETUP_R_LONG ) :       // Long Side  (2-Sided)
                case ( ID_SETUP_R_SHORT ) :      // Short Side (2-Sided)
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetDuplex(hDlg, pDM, uCmdId);
                        GlobalUnlock(pPD->hDevMode);
                    }

                    break;
                }
                case ( ID_SETUP_C_SIZE ) :       // Size combobox
                {
                    UINT Orientation;

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            Orientation =
                                IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                              ? ID_SETUP_R_PORTRAIT
                                              : ID_SETUP_R_LANDSCAPE;
                            PrintSetOrientation( hDlg,
                                                 pPI,
                                                 pDM,
                                                 Orientation,
                                                 Orientation );
                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_C_SOURCE ) :       // Source combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_E_LEFT ) :       // Left    (Margins)
                case ( ID_SETUP_E_TOP ) :        // Top     (Margins)
                case ( ID_SETUP_E_RIGHT ) :      // Right   (Margins)
                case ( ID_SETUP_E_BOTTOM ) :     // Bottom  (Margins)
                {
                    if (pPI->bKillFocus)
                    {
                        break;
                    }

                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_KILLFOCUS ) :
                        {
                            pPI->bKillFocus = TRUE;
                            PrintSetMargin( hDlg,
                                            pPI,
                                            uCmdId,
                                            *((LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT) );
                            pPI->bKillFocus = FALSE;

                            break;
                        }
                        case ( EN_CHANGE ) :
                        {
                            HWND hSample;

                            PrintGetMargin( GET_WM_COMMAND_HWND(wParam, lParam),
                                            pPI,
                                            *((LONG*)&pPI->pPSD->rtMinMargin +
                                              uCmdId - ID_SETUP_E_LEFT),
                                            (LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT,
                                            (LONG*)&pPI->RtMarginMMs +
                                              uCmdId - ID_SETUP_E_LEFT );

                            if (hSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
                            {
                                RECT rect;

                                GetClientRect(hSample, &rect);
                                InflateRect(&rect, -1, -1);
                                InvalidateRect(hSample, &rect, TRUE);
                            }

                            break;
                        }
                    }

                    break;
                }
                case ( ID_SETUP_P_PRINTER ) :    // Printer... button
                {
                    //
                    //  Save a copy of the original values.
                    //
                    HWND hwndOwner = pPD->hwndOwner;
                    DWORD dwFlags = pPD->Flags;
                    HINSTANCE hInstance = pPD->hInstance;
                    LPCTSTR lpPrintTemplateName = pPD->lpPrintTemplateName;

                    //
                    //  Set up pPI so that PrintDlgX can do all the work.
                    //
                    pPD->hwndOwner = hDlg;
                    pPD->Flags &= ~( PD_ENABLEPRINTTEMPLATEHANDLE |
                                     PD_RETURNIC |
                                     PD_RETURNDC |
                                     PD_PAGESETUP );
                    pPD->Flags |= PD_ENABLEPRINTTEMPLATE;
                    pPD->hInstance = g_hinst;
                    pPD->lpPrintTemplateName = MAKEINTRESOURCE(PRINTDLGORD);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;

                    if (PrintDlgX(pPI))
                    {
                        PrintUpdateSetupDlg( hDlg,
                                             pPI,
                                             GlobalLock(pPD->hDevMode),
                                             TRUE );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //
                    //  Restore the original values.
                    //
                    pPD->hwndOwner = hwndOwner;
                    pPD->Flags = dwFlags;
                    pPD->hInstance = hInstance;
                    pPD->lpPrintTemplateName = lpPrintTemplateName;
                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;

                    //
                    //  Set the keyboard focus to the OK button.
                    //
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    HourGlass(FALSE);

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_SETUP_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_SETUP_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPI->pPDA );
                        }
                    }
                    else
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    LPPAGESETUPDLG pPSD = pPI->pPSD;
                    int i;

                    if (pPSD)
                    {
                        if ((pPSD->rtMinMargin.left + pPSD->rtMinMargin.right >
                                pPSD->ptPaperSize.x) ||
                            (pPSD->rtMinMargin.top + pPSD->rtMinMargin.bottom >
                                pPSD->ptPaperSize.y))
                        {
                            //
                            //  This is an unprintable case that can happen.
                            //  Let's assume that the driver is at fault
                            //  and accept whatever the user entered.
                            //
                        }
                        else if (pPSD->rtMargin.left + pPSD->rtMargin.right >
                                     pPSD->ptPaperSize.x)
                        {
                            i = (pPSD->rtMargin.left >= pPSD->rtMargin.right)
                                    ? ID_SETUP_E_LEFT
                                    : ID_SETUP_E_RIGHT;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                        else if (pPSD->rtMargin.top + pPSD->rtMargin.bottom >
                                     pPSD->ptPaperSize.y)
                        {
                            i = (pPSD->rtMargin.top >= pPSD->rtMargin.bottom)
                                    ? ID_SETUP_E_TOP
                                    : ID_SETUP_E_BOTTOM;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                    }
                    else
                    {
                        HourGlass(TRUE);
                        if (!PrintSetCopies(hDlg, pPI, ID_SETUP_C_NAME))
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }
                    }

                    bResult = TRUE;
                    SetFocus( GetDlgItem(hDlg, IDOK) );

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    if (bResult)
                    {
                        PrintGetSetupInfo(hDlg, pPD);
                        if (pPD->Flags & CD_WOWAPP)
                        {
                            UpdateSpoolerInfo(pPI);
                        }
                    }
                    else
                    {
                        SetFocus( GetDlgItem(hDlg, IDCANCEL) );
                    }
                    pPI->bKillFocus = TRUE;

                    glpfnSetupHook = GETSETUPHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)( pPD && (pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)( pPD && (pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL_PTR) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditMarginProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    if ( (msg == WM_CHAR) &&
         (wP != BACKSPACE) &&
         (wP != CTRL_X_CUT) &&
         (wP != CTRL_C_COPY) &&
         (wP != CTRL_V_PASTE) &&
         (wP != (WPARAM)cIntlDecimal) &&
         ((wP < TEXT('0')) || (wP > TEXT('9'))) )
    {
        MessageBeep(0);
        return (FALSE);
    }

    return ( CallWindowProc(lpEditMarginProc, hWnd, msg, wP, lP) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintPageSetupPaintProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    LRESULT lResult;
    PPRINTINFO pPI;
    LPPAGESETUPDLG pPSD;
    HDC hDC;
    RECT aRt, aRtPage, aRtUser;
    PAINTSTRUCT aPs;
    HGDIOBJ hPen, hBr, hFont, hFontGreek;
    HRGN hRgn;
    TCHAR szGreekText[] = TEXT("Dheevaeilnorpoefdi lfaocr, \nMoiccsriocsnoafrtf \tbnya\nSFlr acnn IF iynnnaepgmaonc\n F&i nyneelglaanm 'Ox' Mnaalgleenyn i&f QCnoamgpeannnyi FI nxca.r\nFSoaynb  Ftrfaonscoirscciom,  \rCoafl idfeopronlieav\ne\n");
    LPTSTR psGreekText;
    int i;


    if (msg != WM_PAINT)
    {
        return ( CallWindowProc(lpStaticProc, hWnd, msg, wP, lP) );
    }

    hDC = BeginPaint(hWnd, &aPs);
    GetClientRect(hWnd, &aRt);
    FillRect(hDC, &aRt, (HBRUSH)GetStockObject(WHITE_BRUSH));
    EndPaint(hWnd, &aPs);
    lResult = 0;

    if ( (!(hDC = GetDC(hWnd))) ||
         (!(pPI = (PPRINTINFO)GetProp(GetParent(hWnd), PRNPROP))) )
    {
        return (0);
    }
    pPSD = pPI->pPSD;

    TransferPD2PSD(pPI);
    aRtPage = aRt;
    hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);

    // Rectangle() does not work here
    MoveToEx( hDC, 0            , 0             , NULL );
    LineTo(   hDC, aRt.right - 1, 0              );
    MoveToEx( hDC, 0            , 1             , NULL );
    LineTo(   hDC, 0            , aRt.bottom - 1 );
    DeleteObject(SelectObject(hDC, hPen));

    // Rectangle() does not work here
    MoveToEx( hDC, aRt.right - 1, 0             , NULL );
    LineTo(   hDC, aRt.right - 1, aRt.bottom - 1 );
    MoveToEx( hDC, 0            , aRt.bottom - 1, NULL );
    LineTo(   hDC, aRt.right    , aRt.bottom - 1 );

    SetBkMode(hDC, TRANSPARENT);
    hPen = (HGDIOBJ)CreatePen(PS_DOT, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);
    hBr  = (HGDIOBJ)GetStockObject(NULL_BRUSH);
    hBr  = SelectObject(hDC, hBr);

    hFont = hFontGreek = CreateFont( pPI->PtMargins.y,
                                     pPI->PtMargins.x,
                                     0,
                                     0,
                                     FW_DONTCARE,
                                     0,
                                     0,
                                     0,
                                     ANSI_CHARSET,
                                     OUT_DEFAULT_PRECIS,
                                     CLIP_DEFAULT_PRECIS,
                                     DEFAULT_QUALITY,
                                     VARIABLE_PITCH | FF_SWISS,
                                     NULL );
    hFont = SelectObject(hDC, hFont);

    InflateRect(&aRt, -1, -1);
    aRtUser = aRt;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);

    if (pPSD->lpfnPagePaintHook)
    {
        WORD wFlags;
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        switch (pPI->dwRotation)
        {
            default :
            {
                //
                //  Portrait mode only.
                //
                wFlags = 0x0000;
                break;
            }
            case ( ROTATE_LEFT ) :
            {
                //
                //  Dot-Matrix (270)
                //
                wFlags = 0x0001;
                break;
            }
            case ( ROTATE_RIGHT ) :
            {
                //
                //  HP PCL (90)
                //
                wFlags = 0x0003;
                break;
            }
        }
        if ( !wFlags ||
             IsDlgButtonChecked(GetParent(hWnd), ID_SETUP_R_PORTRAIT) )
        {
            //
            //  Paper in portrait.
            //
            wFlags |= 0x0004;
        }
        if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
        {
            wFlags |= 0x0008;
            if (aRt.right < aRt.bottom)
            {
                //
                //  Envelope in portrait.
                //
                wFlags |= 0x0010;
            }
        }
        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_PAGESETUPDLG,
                                  MAKELONG(pPI->wPaper, wFlags),
                                  (LPARAM)pPSD ) ||
            (*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_FULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }

        aRtUser = aRt;
        aRtUser.left   += aRtUser.right  * pPI->RtMinMarginMMs.left   / pPI->PtPaperSizeMMs.x;
        aRtUser.top    += aRtUser.bottom * pPI->RtMinMarginMMs.top    / pPI->PtPaperSizeMMs.y;
        aRtUser.right  -= aRtUser.right  * pPI->RtMinMarginMMs.right  / pPI->PtPaperSizeMMs.x;
        aRtUser.bottom -= aRtUser.bottom * pPI->RtMinMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

        if ((aRtUser.left   < aRtUser.right)  &&
            (aRtUser.top    < aRtUser.bottom) &&
            (aRtUser.left   > aRtPage.left)   &&
            (aRtUser.top    > aRtPage.top)    &&
            (aRtUser.right  < aRtPage.right)  &&
            (aRtUser.bottom < aRtPage.bottom))
        {
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MINMARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto NoMorePainting;
            }
        }
    }

    aRt.left   += aRt.right  * pPI->RtMarginMMs.left   / pPI->PtPaperSizeMMs.x;
    aRt.top    += aRt.bottom * pPI->RtMarginMMs.top    / pPI->PtPaperSizeMMs.y;
    aRt.right  -= aRt.right  * pPI->RtMarginMMs.right  / pPI->PtPaperSizeMMs.x;
    aRt.bottom -= aRt.bottom * pPI->RtMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

    if ( (aRt.left > aRtPage.left) && (aRt.left < aRtPage.right) &&
         (aRt.right < aRtPage.right) && (aRt.right > aRtPage.left) &&
         (aRt.top > aRtPage.top) && (aRt.top < aRtPage.bottom) &&
         (aRt.bottom < aRtPage.bottom) && (aRt.bottom > aRtPage.top) &&
         (aRt.left < aRt.right) &&
         (aRt.top < aRt.bottom) )
    {
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipMarginRectangle;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            Rectangle(hDC, aRt.left, aRt.top, aRt.right, aRt.bottom);
        }

SkipMarginRectangle:

        InflateRect(&aRt, -1, -1);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_GREEKTEXTRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipGreekText;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            psGreekText = LocalAlloc( LPTR,
                                      10 * (sizeof(szGreekText) + sizeof(TCHAR)) );
            for (i = 0; i < 10; i++)
            {
                CopyMemory( &(psGreekText[i * (sizeof(szGreekText) / sizeof(TCHAR))]),
                            szGreekText,
                            sizeof(szGreekText) );
            }
            aRt.left++;
            aRt.right--;
            aRt.bottom -= (aRt.bottom - aRt.top) % pPI->PtMargins.y;
            hFontGreek = SelectObject(hDC, hFontGreek);
            DrawText( hDC,
                      psGreekText,
                      10 * (sizeof(szGreekText) / sizeof(TCHAR)),
                      &aRt,
                      DT_NOPREFIX | DT_WORDBREAK );
            SelectObject(hDC, hFontGreek);
            LocalFree(psGreekText);
        }
    }

SkipGreekText:

    InflateRect(&aRtPage, -1, -1);
    if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
    {
        int iOrientation;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)     // portrait
        //  switch (pPI->dwRotation)
            {
        //      default :               // no landscape
        //      case ( ROTATE_LEFT ) :  // dot-matrix
        //      {
        //          aRt.left = aRt.right  - 16;
        //          aRt.top  = aRt.bottom - 32;
        //          iOrientation = 2;
        //          break;
        //      }
        //      case ( ROTATE_RIGHT ) : // HP PCL
        //      {
                    aRt.right  = aRt.left + 16;
                    aRt.bottom = aRt.top  + 32;
                    iOrientation = 1;
        //          break;
        //      }
            }
        else                            // landscape
        {
            aRt.left   = aRt.right - 32;
            aRt.bottom = aRt.top   + 16;
            iOrientation = 3;
        }
        hRgn = CreateRectRgnIndirect(&aRt);
        SelectClipRgn(hDC, hRgn);
        DeleteObject(hRgn);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_ENVSTAMPRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipEnvelopeStamp;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            switch (iOrientation)
            {
                default :          // HP PCL
            //  case ( 1 ) :
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampP);
                    break;
                }
            //  case ( 2 ) :       // dot-matrix
            //  {
            //      DrawIcon(hDC, aRt.left - 16, aRt.top, hIconPSStampP);
            //      break;
            //  }
                case ( 3 ) :       // landscape
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampL);
                    break;
                }
            }
        }
    }

SkipEnvelopeStamp:;

    aRtUser = aRtPage;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);
    if (pPSD->lpfnPagePaintHook)
    {
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_YAFULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }
    }

    //
    //  Draw the envelope lines.
    //
    if ( (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING)) &&
         (pPI->pPD->Flags & PI_WPAPER_ENVELOPE) )
    {
        int iRotation;
        HGDIOBJ hPenBlack;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)                     // portrait
        {
        //  if (pPI->dwRotation == ROTATE_LEFT )        // dot-matrix
        //      iRotation = 3;
        //  else            // ROTATE_RIGHT             // HP PCL
                iRotation = 2;
        }
        else                                            // landscape
        {
            iRotation = 1;                              // normal
        }

        switch (iRotation)
        {
            default :
        //  case ( 1 ) :      // normal
            {
                aRt.right  = aRt.left + 32;
                aRt.bottom = aRt.top  + 13;
                break;
            }
            case ( 2 ) :      // left
            {
                aRt.right = aRt.left   + 13;
                aRt.top   = aRt.bottom - 32;
                break;
            }
        //  case ( 3 ) :      // right
        //  {
        //      aRt.left   = aRt.right - 13;
        //      aRt.bottom = aRt.top   + 32;
        //      break;
        //  }
        }

        InflateRect(&aRt, -3, -3);
        hPenBlack = SelectObject(hDC, GetStockObject(BLACK_PEN));
        switch (iRotation)
        {
            case ( 1 ) :       // normal
            {
                MoveToEx(hDC, aRt.left , aRt.top    , NULL);
                LineTo(  hDC, aRt.right, aRt.top);
                MoveToEx(hDC, aRt.left , aRt.top + 3, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 3);
                MoveToEx(hDC, aRt.left , aRt.top + 6, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 6);

                break;
            }
        //  case ( 2 ) :       // left
        //  case ( 3 ) :       // right
            default :
            {
                MoveToEx( hDC, aRt.left      , aRt.top       , NULL );
                LineTo(   hDC, aRt.left      , aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 3, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 3, aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 6, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 6, aRt.bottom     );

                break;
            }
        }
        SelectObject(hDC, hPenBlack);
    }

NoMorePainting:

    DeleteObject(SelectObject(hDC, hPen));
    SelectObject(hDC, hBr);
    DeleteObject(SelectObject(hDC, hFont));
    TransferPSD2PD(pPI);
    ReleaseDC(hWnd, hDC);

    return (lResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadResource
//
//  This routine loads the resource with the given name and type.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType)
{
    HANDLE hResInfo, hRes;
    LANGID LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    //
    // If we are loading a resource from ComDlg32 then use the correct LangID.
    //
    if (hInst == g_hinst) {
        LangID = (LANGID) TlsGetValue(g_tlsLangID);
    }

    if (!(hResInfo = FindResourceExFallback(hInst, pType, pResName, LangID)))
    {
        StoreExtendedError(CDERR_FINDRESFAILURE);
        return (NULL);
    }

    if (!(hRes = LoadResource(hInst, hResInfo)))
    {
        StoreExtendedError(CDERR_LOADRESFAILURE);
        return (NULL);
    }

    return (hRes);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDefaultPrinterName
//
//  This routine gets the name of the default printer and stores it
//  in the given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize)
{
    DWORD dwSize;
    LPTSTR lpsz;


    if (pDefaultPrinter[0] != CHAR_NULL)
    {
        return;
    }

    //
    //  First, try to get the default printername from the win.ini file.
    //
    if (GetProfileString( szTextWindows,
                          szTextDevice,
                          szTextNull,
                          pDefaultPrinter,
                          cchSize ))
    {
        lpsz = pDefaultPrinter;

        //
        // Make sure the string is null-terminated
        //
        pDefaultPrinter[cchSize - 1] = CHAR_NULL;

        while (*lpsz != CHAR_COMMA)
        {
            if (!*lpsz++)
            {
                pDefaultPrinter[0] = CHAR_NULL;
                goto GetDefaultFromRegistry;
            }
        }

        *lpsz = CHAR_NULL;
    }
    else
    {
GetDefaultFromRegistry:

        //
        //  Second, try to get it from the registry.
        //
        dwSize = cchSize * sizeof(TCHAR);

        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                                 szRegistryPrinter,
                                 0,
                                 KEY_READ,
                                 &hPrinterKey ) == ERROR_SUCCESS)
        {
            RegQueryValueEx( hPrinterKey,
                             szRegistryDefaultValueName,
                             NULL,
                             NULL,
                             (LPBYTE)(pDefaultPrinter),
                             &dwSize );

            //
            // Make sure the string is null-terminated
            //
            pDefaultPrinter[cchSize - 1] = CHAR_NULL;

            RegCloseKey(hPrinterKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnDefault
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintReturnDefault(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVNAMES pDN;
    LPDEVMODE pDM;


    StoreExtendedError(CDERR_GENERALCODES);

    if (pPD->hDevNames || pPD->hDevMode)
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    PrintBuildDevNames(pPI);

    if ((pPD->hDevNames) && (pDN = GlobalLock(pPD->hDevNames)))
    {
        //
        //  This is not needed in Win95.  An optimization was
        //  added to DocumentProperties that allows the caller to
        //  simply pass in the printer name without the printer
        //  handle.
        //
        LPTSTR pPrinterName;

        pPrinterName = (LPTSTR)pDN + pDN->wDeviceOffset;

        if (pPrinterName[0])
        {
            PrintOpenPrinter(pPI, pPrinterName);
        }

        pPD->hDevMode = PrintGetDevMode( 0,
                                         pPI->hCurPrinter,
                                         pPrinterName,
                                         NULL);

        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC(pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (TRUE);
        }
        GlobalUnlock(pPD->hDevNames);
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }

    StoreExtendedError(PDERR_NODEFAULTPRN);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitGeneral
//
//  Initialize (enable/disable) dialog elements general to both PrintDlg
//  and SetupDlg.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HWND hCtl;


    SetWindowLong( hDlg,
                   GWL_STYLE,
                   GetWindowLong(hDlg, GWL_STYLE) | DS_CONTEXTHELP );

    //
    //  LATER: If we don't enumerate here, there will only be ONE item
    //         in the list box.  As a result, we won't catch the
    //         keyboard strokes within the list box (eg. arrow keys,
    //         pgup, pgdown, etc).  Need to subclass the combo boxes
    //         to catch these key strokes so that the printers can be
    //         enumerated.
    //
    if (!PrintEnumAndSelect( hDlg,
                             Id,
                             pPI,
                             (pPI->pCurPrinter)
                               ? pPI->pCurPrinter->pPrinterName
                               : NULL,
                             (!(pPI->Status & PI_PRINTERS_ENUMERATED)) ))
    {
        goto InitGeneral_ConstructFailure;
    }

    PrintUpdateStatus(hDlg, pPI);

    //
    //  See if the Help button should be hidden.
    //
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }

    return (TRUE);

InitGeneral_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPrintDlg
//
//  Initialize PRINT DLG-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    WORD wCheckID;
    HWND hCtl;


    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, MAX_COPIES);
    SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);

    if ( !(pPI->pPSD) &&
         (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES)) &&
         (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE) )
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hDlg,
                             IDC_COPIES_UDARROW,
                             g_hinst,
                             hCtl,
                             MAX_COPIES,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth(hDlg, hCtl);
    }

    if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
    {
        if (!GetStoredExtendedError())
        {
            StoreExtendedError(PDERR_INITFAILURE);
        }
        return (0xFFFFFFFF);
    }

    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_TOFILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hDlg, ID_PRINT_X_TOFILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  Some apps (marked 3.1) do not pass in valid ranges.
        //      (e.g. Corel Ventura)
        //
        if ((pPI->ProcessVersion < 0x40000) || (!(pPD->Flags & PD_PAGENUMS)))
        {
            if (pPD->nFromPage != 0xFFFF)
            {
                if (pPD->nFromPage < pPD->nMinPage)
                {
                    pPD->nFromPage = pPD->nMinPage;
                }
                else if (pPD->nFromPage > pPD->nMaxPage)
                {
                    pPD->nFromPage = pPD->nMaxPage;
                }
            }
            if (pPD->nToPage != 0xFFFF)
            {
                if (pPD->nToPage < pPD->nMinPage)
                {
                    pPD->nToPage = pPD->nMinPage;
                }
                else if (pPD->nToPage > pPD->nMaxPage)
                {
                    pPD->nToPage = pPD->nMaxPage;
                }
            }
        }

        if ( pPD->nMinPage > pPD->nMaxPage ||
             ( pPD->nFromPage != 0xFFFF &&
               ( pPD->nFromPage < pPD->nMinPage ||
                 pPD->nFromPage > pPD->nMaxPage ) ) ||
             ( pPD->nToPage != 0xFFFF &&
               ( pPD->nToPage < pPD->nMinPage ||
                 pPD->nToPage > pPD->nMaxPage ) ) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (0xFFFFFFFF);
        }

        if (pPD->nFromPage != 0xFFFF)
        {
            SetDlgItemInt(hDlg, ID_PRINT_E_FROM, pPD->nFromPage, FALSE);
            if (pPD->nToPage != 0xFFFF)
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_TO, pPD->nToPage, FALSE);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);
        }

        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

            //
            //  Don't allow disabled button checked.
            //
            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            pPI->Status &= ~PI_COLLATE_REQUESTED;
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), SW_HIDE);
        }
    }

    if (pPD->Flags & PD_NOSELECTION)
    {
        HWND hRad = GetDlgItem(hDlg, ID_PRINT_R_SELECTION);

        if (hRad)
        {
            EnableWindow(hRad, FALSE);
        }

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = ID_PRINT_R_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = ID_PRINT_R_SELECTION;
    }
    else
    {
        // PD_ALL
        wCheckID = ID_PRINT_R_ALL;
    }

    CheckRadioButton(hDlg, ID_PRINT_R_ALL, ID_PRINT_R_PAGES, (int)wCheckID);

    //
    //  Subclass the integer only edit controls.
    //
    if (!(pPI->pPSD))
    {
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_FROM))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_TO))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
    }

    if (pPD->lpfnPrintHook)
    {
        LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

        if (pPI->ApiType == COMDLG_ANSI)
        {
            DWORD dwHookRet;

            ThunkPrintDlgW2A(pPI);
            dwHookRet = (*lpfnPrintHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (LONG_PTR)pPI->pPDA ) != 0;
            if (dwHookRet)
            {
                ThunkPrintDlgA2W(pPI);
            }

            return (dwHookRet);
        }
        else
        {
            return ( (*lpfnPrintHook)( hDlg,
                                       WM_INITDIALOG,
                                       wParam,
                                       (LONG_PTR)pPD ) ) != 0;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitSetupDlg
//
//  Initialize SETUP-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM = NULL;
    HWND hCtl;
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    UINT Orientation;


    if (!pPD->hDevMode ||
        !(pDM = GlobalLock(pPD->hDevMode)))
    {
        StoreExtendedError(CDERR_MEMLOCKFAILURE);
        goto InitSetupDlg_ConstructFailure;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_PAPERNAMES,
                             CCHPAPERNAME,
                             DC_PAPERS );
    }

    //
    //  Provide backward compatibility for old-style-template sources
    //  ID_SETUP_C_SOURCE.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_BINNAMES,
                             CCHBINNAME,
                             DC_BINS );
    }

    //
    //  Set the edit field lengths and other setup stuff for margins.
    //  This must be called before PrintSetMargin, which is called in
    //  PrintSetOrientation.
    //
    PrintSetupMargins(hDlg, pPI);

    PrintInitOrientation(hDlg, pPI, pDM);
    Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
    PrintSetOrientation( hDlg,
                         pPI,
                         pDM,
                         Orientation,
                         Orientation );

    PrintInitDuplex(hDlg, pDM);
    PrintSetDuplex( hDlg,
                    pDM,
                    pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

    GlobalUnlock(pPD->hDevMode);

    if (pPSD)
    {
        if (pPSD->Flags & PSD_DISABLEORIENTATION)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPAPER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SOURCE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SOURCE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEMARGINS)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_LEFT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_LEFT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_RIGHT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_RIGHT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_TOP), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_TOP),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_BOTTOM), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_BOTTOM),  FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPRINTER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_P_PRINTER), FALSE );
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
    {
        lpStaticProc = (WNDPROC)SetWindowLongPtr( hCtl,
                                               GWLP_WNDPROC,
                                               (LONG_PTR)PrintPageSetupPaintProc );
    }

    if ((pPD->Flags & PD_NONETWORKBUTTON))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }
    else if (!(pPI->pPSD))
    {
        AddNetButton( hDlg,
                      ((pPD->Flags & PD_ENABLESETUPTEMPLATE)
                          ? pPD->hInstance : g_hinst),
                      FILE_BOTTOM_MARGIN,
                      (pPD->Flags & (PD_ENABLESETUPTEMPLATE |
                                     PD_ENABLESETUPTEMPLATEHANDLE))
                          ? FALSE : TRUE,
                      FALSE,
                      TRUE );

        //
        //  The button can be added in two ways -
        //      statically (they have it predefined in their template) and
        //      dynamically (successful call to AddNetButton).
        //
        if (!IsNetworkInstalled())
        {
            hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }

    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }

    //
    //  Provide backward compatibility for old-style-template radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        TCHAR szBuf[MAX_DEV_SECT];
        TCHAR szDefFormat[MAX_DEV_SECT];

        if (pPI->szDefaultPrinter[0])
        {
            if (!CDLoadString( g_hinst,
                             iszDefCurOn,
                             szDefFormat,
                             ARRAYSIZE(szDefFormat) ))
            {
                StoreExtendedError(CDERR_LOADSTRFAILURE);
                goto InitSetupDlg_ConstructFailure;
            }

            wnsprintf(szBuf, ARRAYSIZE(szBuf), szDefFormat, pPI->szDefaultPrinter);
        }
        else
        {
            szBuf[0] = CHAR_NULL;
            EnableWindow(hCtl, FALSE);
        }
        SetDlgItemText(hDlg, ID_SETUP_S_DEFAULT, szBuf);

        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }

    if (pPD->lpfnSetupHook)
    {
        DWORD dwHookRet;
        LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgW2A(pPI);
            TransferPDA2PSD(pPI);

            pPI->NestCtr++;
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPI->pPDA ) != 0;
            pPI->NestCtr--;

            if (dwHookRet)
            {
                TransferPSD2PDA(pPI);
                ThunkPrintDlgA2W(pPI);
                if (pPI->NestCtr == 0)
                {
                    TransferPD2PSD(pPI);
                }
            }
        }
        else
        {
            TransferPD2PSD(pPI);
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPD ) != 0;
            TransferPSD2PD(pPI);
        }


        return (dwHookRet);
    }

    return (TRUE);

InitSetupDlg_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateSetupDlg
//
//  Update the print setup and page setup dialogs with the new settings.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent)
{
    HWND hCtl;
    UINT Count;
    UINT Orientation = 0;


    //
    //  Update the Size combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_PAPERNAMES,
                                 CCHPAPERNAME,
                                 DC_PAPERS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmPaperSize == (SHORT)SendMessage( hCtl,
                                                            CB_GETITEMDATA,
                                                            Count,
                                                            0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Source combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_BINNAMES,
                                 CCHBINNAME,
                                 DC_BINS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmDefaultSource == (SHORT)SendMessage( hCtl,
                                                                CB_GETITEMDATA,
                                                                Count,
                                                                0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Orientation radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintSetOrientation( hDlg,
                             pPI,
                             pDM,
                             IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                 ? ID_SETUP_R_PORTRAIT
                                 : ID_SETUP_R_LANDSCAPE,
                             Orientation );
    }

    //
    //  Update the Duplex radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        PrintSetDuplex( hDlg,
                        pDM,
                        pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );
    }

    //
    //  Update the page setup sample picture.
    //
    if ((Orientation == 0) && (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintUpdatePageSetup( hDlg,
                              pPI,
                              pDM,
                              0,
                              Orientation );
    }

    //
    //  Update the Default/Specific Printer radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetCopies
//
//  Sets the appropriate number of copies in the PrintDlg structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    DWORD dwMaxCopies;
    DWORD dwCollate;
    BOOL bAllowCollate;


    if ( (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
        //
        //  If we're coming from a WOW app, we need to only set
        //  the copies in the devmode if the PD_USEDEVMODECOPIES
        //  flag is set.
        //
        if (IS16BITWOWAPP(pPD))
        {
            if (pPD->Flags & PD_USEDEVMODECOPIES)
            {
                pDM->dmCopies = pPD->nCopies;
                pPD->nCopies = 1;
            }
            else
            {
                pDM->dmCopies = 1;
            }

            return (TRUE);
        }

        if ( (!(pDM->dmFields & DM_COPIES)) ||
             ((!(pPI->pPSD)) &&
              (pPI->ProcessVersion < 0x40000) &&
              (!(pPD->Flags & PD_USEDEVMODECOPIES))) )
        {
LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the
            //  copy/collate info in the pPD.
            //
            pDM->dmCopies = 1;
            SetField(pDM, dmCollate, DMCOLLATE_FALSE);
        }
        else if ( (pDM->dmSpecVersion < 0x0400) ||
                  (!(pDM->dmFields & DM_COLLATE)) )
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto LeaveInfoInPD;
            }
            else
            {
                goto PutInfoInDevMode;
            }
        }
        else
        {
PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pPI->pCurPrinter)
            {
                goto LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number
            //  of copies requested and collation.
            //
            dwMaxCopies = DeviceCapabilities(
                                     pPI->pCurPrinter->pPrinterName,
                                     pPI->pCurPrinter->pPortName,
                                     DC_COPIES,
                                     NULL,
                                     NULL );

            //
            // If DeviceCapabilities() returns error, set the copy number to 1
            //
            if ((dwMaxCopies < 1) || (dwMaxCopies == (DWORD)(-1)))
            {
                dwMaxCopies = 1;
            }
            if (dwMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIES)
                {
                    PrintEditError( hDlg,
                                    (Id == ID_PRINT_C_NAME)
                                        ? ID_PRINT_E_COPIES
                                        : ID_BOTH_P_PROPERTIES,
                                    iszTooManyCopies,
                                    dwMaxCopies );

                    GlobalUnlock(pPD->hDevMode);
                    return (FALSE);
                }

                goto LeaveInfoInPD;
            }

            dwCollate = DeviceCapabilities(
                                     pPI->pCurPrinter->pPrinterName,
                                     pPI->pCurPrinter->pPortName,
                                     DC_COLLATE,
                                     NULL,
                                     NULL );

            bAllowCollate = ((dwCollate < 1) || (dwCollate == (DWORD)-1)) ? FALSE : TRUE;

            //
            //  The driver can do both copies and collate,
            //  so move the info to the devmode.
            //
            pDM->dmCopies = pPD->nCopies;
            SetField( pDM,
                      dmCollate,
                      (bAllowCollate && (pPD->Flags & PD_COLLATE))
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }

        GlobalUnlock(pPD->hDevMode);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMinMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    HDC hDC;
    RECT rtMinMargin;


    if (!pPSD)
    {
        return;
    }

    if (pPSD->Flags & PSD_MINMARGINS)
    {
        //
        //  Convert passed in margins to 10th of MMs.
        //
        if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left / 10;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top / 10;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right / 10;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom / 10;
        }
        else           // PSD_INTHOUSANDTHSOFINCHES
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom * MMS_PER_INCH / 100;
        }
    }
    else
    {
        //
        //  Default to no minimum if we can't get the info.
        //
        pPI->RtMinMarginMMs.left   = 0;
        pPI->RtMinMarginMMs.top    = 0;
        pPI->RtMinMarginMMs.right  = 0;
        pPI->RtMinMarginMMs.bottom = 0;
        pPSD->rtMinMargin.left   = 0;
        pPSD->rtMinMargin.top    = 0;
        pPSD->rtMinMargin.right  = 0;
        pPSD->rtMinMargin.bottom = 0;

        //
        //  Calculate new min margins from driver.
        //
        if (hDC = CreateIC(NULL, pDM->dmDeviceName, NULL, pDM))
        {
            //
            //  These are in PIXELS.
            //
            int nPageWidth = GetDeviceCaps(hDC, PHYSICALWIDTH);
            int nPageHeight = GetDeviceCaps(hDC, PHYSICALHEIGHT);
            int nPrintWidth = GetDeviceCaps(hDC, HORZRES);
            int nPrintHeight = GetDeviceCaps(hDC, VERTRES);
            int nOffsetWidth = GetDeviceCaps(hDC, PHYSICALOFFSETX);
            int nOffsetHeight = GetDeviceCaps(hDC, PHYSICALOFFSETY);
            int nPerInchWidth = GetDeviceCaps(hDC, LOGPIXELSX);
            int nPerInchHeight = GetDeviceCaps(hDC, LOGPIXELSY);

            //
            //  Calculate min margins in PIXELS.
            //
            rtMinMargin.left   = nOffsetWidth;
            rtMinMargin.top    = nOffsetHeight;
            rtMinMargin.right  = nPageWidth - nPrintWidth - nOffsetWidth;
            rtMinMargin.bottom = nPageHeight - nPrintHeight - nOffsetHeight;

            //
            //  Convert to 10ths of MMs.
            //
            if (nPerInchWidth && nPerInchHeight)
            {
                pPI->RtMinMarginMMs.left   = rtMinMargin.left * MMS_PER_INCH / nPerInchWidth / 10;
                pPI->RtMinMarginMMs.top    = rtMinMargin.top * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.right  = rtMinMargin.right * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.bottom = rtMinMargin.bottom * MMS_PER_INCH / nPerInchHeight / 10;
            }

            if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
            {
                //
                //  Convert to 100ths of MMs.
                //
                pPSD->rtMinMargin.left   = pPI->RtMinMarginMMs.left / 10;
                pPSD->rtMinMargin.top    = pPI->RtMinMarginMMs.top / 10;
                pPSD->rtMinMargin.right  = pPI->RtMinMarginMMs.right / 10;
                pPSD->rtMinMargin.bottom = pPI->RtMinMarginMMs.bottom / 10;
            }
            else           // PSD_INTHOUSANDTHSOFINCHES
            {
                //
                //  Convert to 1000ths of inches.
                //
                if (nPerInchWidth && nPerInchHeight)
                {
                    pPSD->rtMinMargin.left   = rtMinMargin.left * 1000 / nPerInchWidth;
                    pPSD->rtMinMargin.top    = rtMinMargin.top * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.right  = rtMinMargin.right * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.bottom = rtMinMargin.bottom * 1000 / nPerInchHeight;
                }
            }

            DeleteDC(hDC);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szMars[32];
    TCHAR szText[16];
    int ids[4] = { ID_SETUP_E_LEFT,
                   ID_SETUP_E_TOP,
                   ID_SETUP_E_RIGHT,
                   ID_SETUP_E_BOTTOM };
    int i;
    HWND hEdt;


    //
    //  Margins are only available from the PageSetupDlg.
    //
    if (!(pPI->pPSD))
    {
        return;
    }

    for (i = 0; i < 4; i++)
    {
        if (hEdt = GetDlgItem(hDlg, ids[i]))
        {
            //
            //  "999999" is the maximum value.
            //
            SendMessage(hEdt, EM_LIMITTEXT, MARGIN_EDIT_SIZE, 0);

            lpEditMarginProc =
                (WNDPROC)SetWindowLongPtr( hEdt,
                                        GWLP_WNDPROC,
                                        (LONG_PTR)PrintEditMarginProc );

        }
    }

    if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SDECIMAL,
                        szText,
                        16 ))
    {
        cIntlDecimal = CHAR_DOT;
    }
    else
    {
        cIntlDecimal = szText[0];
    }

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            CDLoadString(g_hinst, iszMarginsMillimeters, szMars, ARRAYSIZE(szMars));
            CDLoadString(g_hinst, iszMillimeters, cIntlMeasure, ARRAYSIZE(cIntlMeasure));

            break;
        }
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            CDLoadString(g_hinst, iszMarginsInches, szMars, ARRAYSIZE(szMars));
            CDLoadString(g_hinst, iszInches, cIntlMeasure, ARRAYSIZE(cIntlMeasure));

            break;
        }
    }

    cchIntlMeasure = lstrlen(cIntlMeasure);

    SetWindowText(GetDlgItem(hDlg, ID_SETUP_G_MARGINS), szMars);
    pPI->PtMargins.x = 2 * (IS_KEY_PRESSED(pPI->PtMargins.x / 4) &&
                            IS_KEY_PRESSED(pPI->PtMargins.y / 4)
                                ? sizeof(WCHAR)
                                : sizeof(CHAR));
    pPI->PtMargins.y = 2 * pPI->PtMargins.x;
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue)
{
    HWND hEdt;
    TCHAR szText[32];
    TCHAR szILZero[2];
    LONG lFract;


    if (hEdt = GetDlgItem(hDlg, Id))
    {
        switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                    PSD_INHUNDREDTHSOFMILLIMETERS))
        {
            case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
            {
                lFract = lValue % 100;
                StringCchPrintf( szText,
                                 ARRAYSIZE(szText),
                                 lFract ? TEXT("%lu%c%02lu") : TEXT("%lu"),
                                 lValue / 100,
                                 cIntlDecimal,
                                 lFract );
                break;
            }
            case ( PSD_INTHOUSANDTHSOFINCHES ) :
            {
                lFract = lValue % 1000;
                StringCchPrintf( szText,
                                 ARRAYSIZE(szText),
                                 lFract ? TEXT("%lu%c%03lu") : TEXT("%lu"),
                                 lValue / 1000,
                                 cIntlDecimal,
                                 lFract );
                break;
            }
        }

        //
        //  Remove trailing zeros off of fraction.
        //
        if (lFract)
        {
            LPTSTR pStr = szText + lstrlen(szText) - 1;

            while (*pStr == TEXT('0'))
            {
                *pStr-- = TEXT('\0');
            }
        }

        //
        //  Determine if a leading zero is to be used and write the
        //  text to the edit window.
        //
        if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szILZero, 2))
        {
            szILZero[0] = TEXT('0');
        }
        SetWindowText( hEdt,
                       szText + (szText[0] == TEXT('0') &&
                                 szText[1] == cIntlDecimal &&
                                 szILZero[0] == TEXT('0')) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample)
{
    //
    // The buffer will concatinate "000" at the end, so the buffer
    // size should be equal or bigger than MARGIN_EDIT_SIZE + 3 +1.
    //
    TCHAR szText[MARGIN_EDIT_SIZE + 3 +1] = {0};
    TCHAR *pText;
    TCHAR *pFrac;

    //
    // Set the buffer size to ARRAYSIZE(szText) - 3 since we need to
    // reserve 3 chars for concatination of "000" later. If
    // GetWindowText fails, we don't mind since the buffer was
    // filled with 0 at first. The function will finally set *plMargin
    // and *plSample as 0 and return.
    //
    GetWindowText(hEdt, szText, ARRAYSIZE(szText) - 3);
    *plMargin = ConvertStringToInteger(szText);

    for (pText = szText; *pText;)
    {
        if (*pText++ == cIntlDecimal)
        {
            break;
        }
    }

    for (pFrac = pText; *pFrac; pFrac++)
    {
        if (*pFrac == cIntlMeasure[0])
        {
            *pFrac = CHAR_NULL;
            break;
        }

        if (*pFrac == cIntlDecimal)
        {
            *pFrac = CHAR_NULL;
            break;
        }
    }

    //
    // Don't check the return from StringCchCat, since
    // we will recalculate *plMargin and *plSample anyway
    //
    StringCchCat(szText, ARRAYSIZE(szText), TEXT("000"));

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            //
            //  In 1000ths of inches.
            //
            *plMargin *= 1000;
            pText[3] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin * MMS_PER_INCH / 1000;

            break;
        }
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            //
            //  In 100ths of MMs.
            //
            *plMargin *= 100 ;
            pText[2] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin / 10;

            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitBannerAndQuality
//
//  Reset PRINT DLG items dependent upon which printer was selected.
//  Assumes that pPD->hDevNames is non-NULL.  pPD->hDevMode non-NULL.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD)
{
    HWND hCtl;
    BOOL bResult = TRUE;
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    TCHAR szText[MAX_DEV_SECT];


    //
    //  ID_PRINT_S_DEFAULT is from one of the old templates.
    //
    if (GetDlgItem(hDlg, ID_PRINT_S_DEFAULT))
    {
        if (!pPD->hDevNames ||
            !(pDN = GlobalLock(pPD->hDevNames)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        if (PrintCreateBanner(hDlg, pDN, szText, MAX_DEV_SECT))
        {
            SetDlgItemText(hDlg, ID_PRINT_S_DEFAULT, szText);
        }
        else
        {
            //
            //  PrintCreateBanner sets the extended error.
            //
            bResult = FALSE;
        }

        GlobalUnlock(pPD->hDevNames);
    }

    //
    //  If the driver says it can do copies, pay attention to what the
    //  app requested.  If it cannot do copies, check & disable the
    //  checkbox.
    //
    if (pPD->hDevMode)
    {
        if (!(pDM = GlobalLock(pPD->hDevMode)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        //
        //  Enable print quality, if it exists.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, TRUE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, TRUE);

            PrintInitQuality( hCtl,
                              pDM->dmSpecVersion <= 0x0300 ? 0L : pPD,
                              pDM->dmPrintQuality );
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            if ( pDM->dmFields & DM_COLLATE ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                EnableWindow(hCtl, TRUE);
                CheckDlgButton( hDlg,
                                ID_PRINT_X_COLLATE,
                                (pPI->Status & PI_COLLATE_REQUESTED)
                                    ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hDlg, ID_PRINT_X_COLLATE, FALSE);
            }
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            if ( pDM->dmFields & DM_COPIES ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);
                EnableWindow(hCtl, TRUE);
            }
            else
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, 1, FALSE);
                EnableWindow(hCtl, FALSE);
            }
        }

        //
        //  Display the appropriate collate icon.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
        {
            SetWindowLong( hCtl,
                           GWL_STYLE,
                           GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
            ShowWindow(hCtl, SW_HIDE);
            SendMessage( hCtl,
                         STM_SETICON,
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                             ? (LONG_PTR)hIconCollate
                             : (LONG_PTR)hIconNoCollate,
                         0L );
            ShowWindow(hCtl, SW_SHOW);
        }

        GlobalUnlock(pPD->hDevMode);
    }
    else
    {
        //
        //  Disable the print quality, collate, and copies.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCreateBanner
//
//  Create "Printer: Prn on Port" or "Printer:  System Printer (Prn)".
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner)
{
    if (GetDlgItem(hDlg, ID_BOTH_S_PRINTER))
    {
        psBanner[0] = CHAR_NULL;
    }
    else if (!CDLoadString( g_hinst,
                          iszPrinter,
                          psBanner,
                          cchBanner ))
    {
        goto LoadStrFailure;
    }

    if (pDN->wDefault & DN_DEFAULTPRN)
    {
        TCHAR szSysPrn[MAX_DEV_SECT];

        if (!CDLoadString(g_hinst, iszSysPrn, szSysPrn, ARRAYSIZE(szSysPrn)))
        {
            goto LoadStrFailure;
        }
        StringCchCat(psBanner, cchBanner, (LPTSTR)szSysPrn);
        StringCchCat(psBanner, cchBanner, (LPTSTR)pDN + pDN->wDeviceOffset);
        StringCchCat(psBanner, cchBanner, (LPTSTR)TEXT(")"));
    }
    else
    {
        TCHAR szPrnOnPort[64];

        if (!CDLoadString(g_hinst, iszPrnOnPort, szPrnOnPort, ARRAYSIZE(szPrnOnPort)))
        {
            goto LoadStrFailure;
        }
        StringCchCat(psBanner, cchBanner, (LPTSTR)pDN + pDN->wDeviceOffset);
        StringCchCat(psBanner, cchBanner, (LPTSTR)szPrnOnPort);
        StringCchCat(psBanner, cchBanner, (LPTSTR)pDN + pDN->wOutputOffset);
    }

    return (TRUE);

LoadStrFailure:

    StoreExtendedError(CDERR_LOADSTRFAILURE);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitQuality
//
//  Initializes the Printer Quality Combobox.
//
//  Assumes pPD structure filled by caller.  If non-NULL, it's a 3.1 or
//  later driver.  If NULL, fill with default for 3.0.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality)
{
    SHORT nStringID;
    SHORT i;
    TCHAR szBuf[64];
    LPDEVMODE  pDM = NULL;
    LPDEVNAMES pDN = NULL;


    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    //
    //  Enum print qualities.
    //
    if (pPD && pPD->hDevMode && pPD->hDevNames)
    {
        HANDLE hPrnQ;                  // Memory handle for print qualities
        DWORD dw;                      // return from DC_ENUMRESOLUTIONS
        LPLONG pLong;                  // Pointer to pairs of longs
        LPTSTR psDevice;
        LPTSTR psPort;

        pDM = GlobalLock(pPD->hDevMode);
        pDN = GlobalLock(pPD->hDevNames);

        if (pDM->dmSpecVersion < 0x030A)
        {
            goto EnumResNotSupported;
        }

        psDevice = (LPTSTR)pDN + pDN->wDeviceOffset;
        psPort   = (LPTSTR)pDN + pDN->wOutputOffset;

        dw = DeviceCapabilities( psDevice,
                                 psPort,
                                 DC_ENUMRESOLUTIONS,
                                 NULL,
                                 NULL );
        if (!dw || (dw == (DWORD)(-1)))
        {
            goto EnumResNotSupported;
        }

        hPrnQ = GlobalAlloc(GHND, dw * 2 * sizeof(LONG));
        if (!hPrnQ)
        {
            goto EnumResNotSupported;
        }

        if (pLong = GlobalLock(hPrnQ))
        {
            dw = DeviceCapabilities( psDevice,
                                     psPort,
                                     DC_ENUMRESOLUTIONS,
                                     (LPTSTR)pLong,
                                     0 );

            for (nStringID = 0, i = (SHORT)(LOWORD(dw) - 1); i >= 0; i--)
            {
                DWORD xRes, yRes;

                if ((xRes = pLong[i * 2]) != (yRes = pLong[i * 2 + 1]) )
                {
                    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%ld dpi x %ld dpi"), xRes, yRes);
                }
                else
                {
                    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%ld dpi"), yRes);
                }

                SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
                SendMessage(hCmb, CB_SETITEMDATA, 0, xRes);

                if ( ((SHORT)xRes == nQuality) &&
                     ( (wWinVer < 0x030A) ||
                       !pDM->dmYResolution ||
                       (pDM->dmYResolution == (SHORT)yRes) ) )
                {
                    nStringID = i;
                }
            }
            GlobalUnlock(hPrnQ);
        }
        GlobalFree(hPrnQ);

        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)nStringID, 0L);
    }
    else
    {
EnumResNotSupported:

        for ( i = -1, nStringID = iszDraftPrnQ;
              nStringID >= iszHighPrnQ;
              i--, nStringID-- )
        {
            if (!CDLoadString(g_hinst, nStringID, szBuf, ARRAYSIZE(szBuf)))
            {
                return;
            }
            SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
            SendMessage(hCmb, CB_SETITEMDATA, 0, MAKELONG(i, 0));
        }

        if ((nQuality >= 0) || (nQuality < -4))
        {
            //
            //  Set to HIGH.
            //
            nQuality = -4;
        }
        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)(nQuality + 4), 0L);
    }

    if (pDM)
    {
        GlobalUnlock(pPD->hDevMode);
    }
    if (pDN)
    {
        GlobalUnlock(pPD->hDevNames);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintChangeProperties
//
//  Puts up the dialog to modify the properties.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    LONG cbNeeded;
    HANDLE hDevMode;
    WORD nCopies, nCollate;
    BOOL bTest;
    HWND hCtl;


    //
    //  There must be a devmode already.
    //
    if (!pPD->hDevMode)
    {
        return;
    }

    //
    //  Get the number of bytes needed for the devmode.
    //
    cbNeeded = DocumentProperties( hDlg,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );

    //
    //  Reallocate the devmode to be sure there is enough room in it, and
    //  then put up the document properties dialog box.
    //
    if ( (cbNeeded > 0) &&
         (hDevMode = GlobalReAlloc(pPD->hDevMode, cbNeeded, GHND)) &&
         (pDM = GlobalLock(hDevMode)) )
    {
        //
        //  This is done here to make sure that the ReAlloc succeeded
        //  before trashing the old hDevMode.
        //
        pPD->hDevMode = hDevMode;

        //
        //  Set the number of copies and collation in the devmode before
        //  calling DocumentProperties, if appropriate.
        //
        nCopies = pDM->dmCopies;
        nCollate = pDM->dmCollate;
        if (Id == ID_PRINT_C_NAME)
        {
            //
            //  Get the number of copies from the edit control.
            //
            pDM->dmCopies = (WORD)GetDlgItemInt( hDlg,
                                                 ID_PRINT_E_COPIES,
                                                 &bTest,
                                                 FALSE );
            if ((!bTest) || (!pDM->dmCopies))
            {
                pDM->dmCopies = nCopies;
            }

            //
            //  Get the collation from the check box.
            //
            if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                 IsWindowEnabled(hCtl) )
            {
                SetField( pDM,
                          dmCollate,
                          (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                              ? DMCOLLATE_TRUE
                              : DMCOLLATE_FALSE );
            }
        }
        else   // ID_SETUP_C_NAME
        {
            if ( (pDM->dmFields & DM_COPIES) &&
                 (pPI->ProcessVersion < 0x40000) &&
                 (!(pPD->Flags & PD_USEDEVMODECOPIES)) &&
                 (pPD->nCopies) )
            {
                pDM->dmCopies = pPD->nCopies;

                if (pDM->dmFields & DM_COLLATE)
                {
                    //
                    //  DM_COLLATE was specified, so dmCollate exists.
                    //
                    pDM->dmCollate = (pPD->Flags & PD_COLLATE)
                                         ? DMCOLLATE_TRUE
                                         : DMCOLLATE_FALSE;
                }
            }
        }

        //
        //  Put up the Document Properties dialog box.
        //
        if (DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                (pPI->pCurPrinter)
                                    ? pPI->pCurPrinter->pPrinterName
                                    : NULL,
                                pDM,
                                pDM,
                                DM_PROMPT | DM_MODIFY | DM_COPY ) == IDOK)
        {
            //
            //  Save the new number of copies and collation, if appropriate.
            //
            if (pDM->dmFields & DM_COPIES)
            {
                pPD->nCopies = pDM->dmCopies;
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                if (pDM->dmCollate == DMCOLLATE_FALSE)
                {
                    pPD->Flags  &= ~PD_COLLATE;
                    pPI->Status &= ~PI_COLLATE_REQUESTED;
                }
                else
                {
                    pPD->Flags  |= PD_COLLATE;
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            //
            //  Update the dialog.
            //
            if (Id == ID_PRINT_C_NAME)
            {
                //
                //  Update the print dialog with the new info.
                //
                PrintInitBannerAndQuality(hDlg, pPI, pPD);
            }
            else   // ID_SETUP_C_NAME
            {
                //
                //  Update the print setup dialog with the new info.
                //
                PrintUpdateSetupDlg(hDlg, pPI, pDM, FALSE);
            }
        }
        else
        {
            //
            //  Operation cancelled.  Restore the number of copies
            //  and the collation in the devmode.
            //
            pDM->dmCopies = nCopies;
            SetField(pDM, dmCollate, nCollate);
        }

        GlobalUnlock(pPD->hDevMode);

        SendMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, IDOK),
                     1L );
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintPrinterChanged
//
////////////////////////////////////////////////////////////////////////////

VOID PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HANDLE hDM = NULL;
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDMOld = NULL;
    HWND hCtl;
    UINT Orientation;
    LONG cbSize;
    DWORD dmSize;


    HourGlass(TRUE);

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Get the current printer from the combo box.
    //
    if (Id && (hCtl = GetDlgItem(hDlg, Id)))
    {
        TCHAR szPrinter[MAX_PRINTERNAME];
        DWORD ctr;

        ComboBoxGetLBText( hCtl,
                           (DWORD)SendMessage(hCtl, CB_GETCURSEL, 0, 0),
                           szPrinter,
                           ARRAYSIZE(szPrinter) );

        pPI->pCurPrinter = NULL;
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, szPrinter))
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];
                break;
            }
        }
        if (!pPI->pCurPrinter)
        {
            HourGlass(FALSE);
            return;
        }
    }

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Build the device names.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the devmode information.
    //
    cbSize = DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 NULL,
                                 NULL,
                                 0 );
    if (cbSize > 0)
    {
        hDM = GlobalAlloc(GHND, cbSize);

        //
        //  Get the default DevMode for the new printer.
        //
        if (hDM && (pDM = GlobalLock(hDM)) &&
            (DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 pDM,
                                 NULL,
                                 DM_COPY ) == IDOK))
        {
            //
            //  See if we need to merge in old DevMode settings.
            //
            if (pPD->hDevMode && (pDMOld = GlobalLock(pPD->hDevMode)))
            {
                //
                //  Reset the PaperSource back to the Document Default.
                //
                if (pDM->dmFields & DM_DEFAULTSOURCE)
                {
                    pDMOld->dmFields |= DM_DEFAULTSOURCE;
                    pDMOld->dmDefaultSource = pDM->dmDefaultSource;
                }
                else
                {
                    pDMOld->dmFields &= ~DM_DEFAULTSOURCE;
                }

                //
                //  Copy relevant info from the old devmode to the new
                //  devmode.
                //
                dmSize = min(pDM->dmSize, pDMOld->dmSize);
                if (dmSize > FIELD_OFFSET(DEVMODE, dmFields))
                {
                    CopyMemory( &(pDM->dmFields),
                                &(pDMOld->dmFields),
                                dmSize - FIELD_OFFSET(DEVMODE, dmFields) );
                }

                //
                //  Free the old devmode.
                //
                GlobalUnlock(pPD->hDevMode);
                GlobalFree(pPD->hDevMode);
            }

            //
            //  Save the new DevMode in the pPD structure.
            //
            pPD->hDevMode = hDM;

            //
            //  Get the newly merged DevMode.
            //
            pDM->dmFields = pDM->dmFields & (DM_ORIENTATION | DM_PAPERSIZE  |
                                             DM_PAPERLENGTH | DM_PAPERWIDTH |
                                             DM_SCALE       | DM_COPIES     |
                                             DM_COLLATE     | DM_FORMNAME   |
                                             DM_DEFAULTSOURCE);
            DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                pPI->pCurPrinter->pPrinterName,
                                pDM,
                                pDM,
                                DM_MODIFY | DM_COPY );
            GlobalUnlock(hDM);
        }
        else if (hDM)
        {
            if (pDM)
            {
                GlobalUnlock(hDM);
            }
            GlobalFree(hDM);
        }
    }

    //
    //  Fill in the appropriate information for the rest of the
    //  Print or Print Setup dialog box.
    //
    if (Id == ID_PRINT_C_NAME)
    {
        PrintInitBannerAndQuality(hDlg, pPI, pPD);
    }
    else   // ID_SETUP_C_NAME
    {
        if (pPD->hDevMode && (pDM = GlobalLock(pPD->hDevMode)))
        {
            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_PAPERNAMES,
                                     CCHPAPERNAME,
                                     DC_PAPERS );
            }

            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_BINNAMES,
                                     CCHBINNAME,
                                     DC_BINS );
            }

            PrintInitOrientation(hDlg, pPI, pDM);
            Orientation = (pDM->dmOrientation == DMORIENT_PORTRAIT)
                              ? ID_SETUP_R_PORTRAIT
                              : ID_SETUP_R_LANDSCAPE;
            PrintSetOrientation(hDlg, pPI, pDM, Orientation, Orientation);

            PrintInitDuplex(hDlg, pDM);
            PrintSetDuplex( hDlg,
                            pDM,
                            pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

            GlobalUnlock(pPD->hDevMode);
        }
    }

    //
    //  Update the status information.
    //
    PrintUpdateStatus(hDlg, pPI);

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCancelPrinterChanged
//
//  Opens the old printer since the user hit cancel.  The devmode and
//  devnames structures have already been set back to the old ones.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    LPPRINTDLG pPD = pPI->pPD;
    PPRINTER_INFO_2 pCurPrinter;


    //
    //  Make sure we have a previous printer and a devmode.
    //
    if ((pPrinterName[0] == 0) || (!pPD->hDevMode))
    {
        return;
    }

    //
    //  Turn on the hour glass.
    //
    HourGlass(TRUE);

    //
    //  Find the current printer in the list.
    //
    pCurPrinter = PrintSearchForPrinter(pPI, pPrinterName);
    if (!pCurPrinter)
    {
        HourGlass(FALSE);
        return;
    }

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Save the current printer.
    //
    pPI->pCurPrinter = pCurPrinter;

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Turn off the hour glass.
    //
    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateStatus
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szSeparator[] = TEXT("; ");
    TCHAR szText[256];
    TCHAR szJobs[64];
    LPDEVMODE pDM;
    UINT Length;
    DWORD dwStatus;
    int ctr;
    TCHAR *ps;
    BOOL bFound;


    //
    //  Update the printer status information in the dialog.
    //
    if (!GetDlgItem(hDlg, ID_BOTH_S_STATUS) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  ----------------------  Update Status  ----------------------
    //
    szText[0] = CHAR_NULL;

    if (pPI->pCurPrinter->Attributes & PRINTER_ATTRIBUTE_DEFAULT)
    {
        CDLoadString(g_hinst, iszStatusDefaultPrinter, szText, ARRAYSIZE(szText));
    }

    Length = lstrlen(szText);
    dwStatus = pPI->pCurPrinter->Status;
    for (ctr = 0; ctr++ < 32; dwStatus = dwStatus >> 1)
    {
        if (dwStatus & 1)
        {
            INT ilen = lstrlen(szText);

            CDLoadString( g_hinst,
                          iszStatusReady + ctr,
                          szText + ilen,
                          ARRAYSIZE(szText) - ilen);
        }
    }

    if (szText[Length])
    {
        if (CDLoadString(g_hinst, iszStatusDocumentsWaiting, szJobs, ARRAYSIZE(szJobs)))
        {
            StringCchPrintf( szText + lstrlen(szText),
                             ARRAYSIZE(szText) - lstrlen(szText),
                             szJobs,
                             pPI->pCurPrinter->cJobs );
        }
    }
    else
    {
        CDLoadString(g_hinst, iszStatusReady, szText + Length, ARRAYSIZE(szText) - Length);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_STATUS, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_STATUS));

    //
    //  ----------------------  Update Type  ----------------------
    //
    if (pPI->pCurPrinter->pDriverName)
    {
        StringCchCopy(szText, ARRAYSIZE(szText), pPI->pCurPrinter->pDriverName);
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    if (pPI->pPD->hDevMode && (pDM = GlobalLock(pPI->pPD->hDevMode)))
    {
        if (pDM->dmSpecVersion < 0x0400)
        {
            StringCchCat(szText, ARRAYSIZE(szText), TEXT(" (3.x)"));  // old driver designation
        }
        GlobalUnlock(pPI->pPD->hDevMode);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_TYPE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_TYPE));

    //
    //  ----------------------  Update Location  ----------------------
    //
    if (pPI->pCurPrinter->pLocation && pPI->pCurPrinter->pLocation[0])
    {
        bFound = FALSE;
        StringCchCopy(szText, ARRAYSIZE(szText), pPI->pCurPrinter->pLocation);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            goto ShowPortName;
        }
    }
    else
    {
ShowPortName:
        if (pPI->pCurPrinter->pPortName)
        {
            StringCchCopy(szText, ARRAYSIZE(szText), pPI->pCurPrinter->pPortName);
        }
        else
        {
            szText[0] = CHAR_NULL;
        }
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_WHERE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE));

    //
    //  ----------------------  Update Comment  ----------------------
    //
    if (pPI->pCurPrinter->pComment && pPI->pCurPrinter->pComment[0])
    {
        bFound = FALSE;
        StringCchCopy(szText, ARRAYSIZE(szText), pPI->pCurPrinter->pComment);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            //
            //  This is needed in case the comment field only has a
            //  carriage return in it.  Without this check, it will
            //  show a ";" in the comment field.  In this case, it
            //  should show "" in the comment field.
            //
            szText[0] = CHAR_NULL;
        }
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_COMMENT, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT));
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetSetupInfo
//
//  Purpose:  Retrieve info from Print Setup dialog elements
//  Assumes:  hDevMode handle to valid DEVMODE structure
//  Returns:  TRUE if hDevMode valid, FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD)
{
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    HWND hCmb;
    int nInd;


    if ( !pPD->hDevMode ||
         !(pDM = GlobalLock(pPD->hDevMode)) )
    {
        return (FALSE);
    }

    // Don't need to do this - this is kept up to date.
    // pDM->dmFields |= DM_ORIENTATION;

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0, 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_PAPERSIZE;
            pDM->dmPaperSize = (SHORT)SendMessage( hCmb,
                                                   CB_GETITEMDATA,
                                                   nInd,
                                                   0 );
            {
            //  pDM->dmFields |= DM_FORMNAME;
                ComboBoxGetLBText( hCmb,
                                   nInd,
                                   pDM->dmFormName,
                                   ARRAYSIZE(pDM->dmFormName) );

            }
        }
    }

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0 , 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_DEFAULTSOURCE;
            pDM->dmDefaultSource = (SHORT)SendMessage( hCmb,
                                                       CB_GETITEMDATA,
                                                       nInd,
                                                       0 );
        }
    }

    if ( (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintReturnICDC(pPD, pDN, pDM);
        GlobalUnlock(pPD->hDevNames);
    }

    GlobalUnlock(pPD->hDevMode);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSearchForPrinter
//
//  Returns the pointer to the PRINTER_INFO_2 structure for the printer
//  with the name pPrinterName.
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName)
{
    DWORD ctr;

    //
    //  Search for the printer.
    //
    for (ctr = 0; ctr < pPI->cPrinters; ctr++)
    {
        if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, lpsPrinterName))
        {
            //
            //  Found it.
            //
            return (&pPI->pPrinters[ctr]);
        }
    }

    //
    //  Did not find the printer.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetExtDeviceMode
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetExtDeviceMode(
    HWND hDlg,
    PPRINTINFO pPI)
{
    DWORD ctr;
    LPDEVMODEA pDMA;
    LPDEVMODEW pDMW;
    int iResult;
    CHAR szPrinterNameA[MAX_PRINTERNAME];


    if (!pPI->bUseExtDeviceMode)
    {
        return;
    }

    //
    //  Allocate the array to hold whether or not a new devmode has been
    //  allocated for each of the printers.
    //
    //  This is necessary because if the call to ExtDeviceMode fails, then
    //  nothing was allocated.  The one that is currently in the pPrinters
    //  array is actually part of the big pPrinters array (from the call
    //  to GetPrinter - it wants one giant buffer).
    //
    if (pPI->cPrinters)
    {
        if (pPI->pAllocInfo)
        {
            GlobalFree(pPI->pAllocInfo);
        }
        pPI->pAllocInfo = (LPBOOL)GlobalAlloc( GPTR,
                                               pPI->cPrinters * sizeof(BOOL) );
    }

    if (pPI->pAllocInfo)
    {
        //
        //  If we were called from a WOW app with a NULL devmode,
        //  then call ExtDeviceMode to get a default devmode.
        //
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            //
            //  Convert the printer name from Unicode to ANSI.
            //
            SHUnicodeToAnsi(pPI->pPrinters[ctr].pPrinterName, szPrinterNameA, ARRAYSIZE(szPrinterNameA));

            //
            //  Call ExtDeviceMode with 0 flags to find out the
            //  size of the devmode structure we need.
            //
            iResult = ExtDeviceMode( hDlg,
                                     NULL,
                                     NULL,
                                     szPrinterNameA,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0 );
            if (iResult < 0)
            {
                continue;
            }

            //
            //  Allocate the space.
            //
            pDMA = GlobalAlloc(GPTR, iResult);
            if (!pDMA)
            {
                continue;
            }

            //
            //  Call ExtDeviceMode to get the dummy devmode structure.
            //
            iResult = ExtDeviceMode( hDlg,
                                     NULL,
                                     pDMA,
                                     szPrinterNameA,
                                     NULL,
                                     NULL,
                                     NULL,
                                     DM_COPY );
            if (iResult < 0)
            {
                GlobalFree(pDMA);
                continue;
            }

            //
            //  Call AllocateUnicodeDevMode to allocate and copy the unicode
            //  version of this ANSI dev mode.
            //
            pDMW = AllocateUnicodeDevMode(pDMA);
            if (!pDMW)
            {
                GlobalFree(pDMA);
                continue;
            }

            //
            //  Store the pointer to the new devmode in the old pointer
            //  position.  We don't have to worry about freeing the
            //  current contents of pPrinter[ctr].pDevMode before sticking
            //  in the new pointer because in reality the pPrinter memory
            //  buffer is just one long allocation (the memory pDevmode
            //  points to is part of the pPrinters buffer).  So, when the
            //  buffer is freed at the end, the old devmode will be freed
            //  with it.
            //
            pPI->pPrinters[ctr].pDevMode = pDMW;
            pPI->pAllocInfo[ctr] = TRUE;

            //
            //  Free the ANSI dev mode.
            //
            GlobalFree(pDMA);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintEnumAndSelect
//
//  This routine enumerates the LOCAL and CONNECTED printers.
//  It is called at initialization and when a new printer is
//  added via the NETWORK... button.
//
//  If the second parameter is set, the first parameter is overridden.
//  When the second parameter is NULL, the first parameter is used.
//  In this case, if the first parameter is greater than the total
//  number of printers enumerated, then the last one in the list is
//  selected.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters)
{
    HWND hCtl = ((hDlg && Id) ? GetDlgItem(hDlg, Id) : 0);
    LPPRINTDLG pPD = pPI->pPD;
    TCHAR szPrinter[MAX_PRINTERNAME];
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD ctr;
    PPRINTER_INFO_2 pPrinters = NULL;


    //
    //  Enumerate the printers, if necessary.
    //
    if (bEnumPrinters)
    {
Print_Enumerate:
        //
        //  Save lpsPrinterToSelect in a local before it gets freed.
        //
        if (lpsPrinterToSelect)
        {
            lstrcpyn(szPrinter, lpsPrinterToSelect, ARRAYSIZE(szPrinter));
            lpsPrinterToSelect = szPrinter;
        }

        //
        //  Close and free any open printers.
        //
        PrintClosePrinters(pPI);

        //
        //  Clear out the error code.
        //
        StoreExtendedError(CDERR_GENERALCODES);

        //
        //  Enumerate the printers.
        //
        if (!EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                           NULL,
                           2,
                           NULL,
                           0,
                           &cbNeeded,
                           &cReturned ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (pPrinters = GlobalAlloc(GPTR, cbNeeded))
                {
                    if (EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                                      NULL,
                                      2,
                                      (LPBYTE)pPrinters,
                                      cbNeeded,
                                      &cbNeeded,
                                      &cReturned ))
                    {
                        pPI->cPrinters = cReturned;
                        pPI->pPrinters =  pPrinters;
                        pPI->Status |= PI_PRINTERS_ENUMERATED;
                    }
                    else
                    {
                        StoreExtendedError(PDERR_NODEFAULTPRN);
                    }
                }
                else
                {
                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                }
            }
            else
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
            }
        }
        else
        {
            StoreExtendedError(PDERR_NODEFAULTPRN);
        }

        if (GetStoredExtendedError())
        {
            if (pPrinters)
            {
                GlobalFree(pPrinters);
            }
            return (FALSE);
        }

        //
        //  Make modifications for a WOW app.
        //
        if (pPI->bUseExtDeviceMode)
        {
            PrintGetExtDeviceMode(hDlg, pPI);
        }

        //
        //  Try the selected printer.
        //
        if (lpsPrinterToSelect)
        {
            pPI->pCurPrinter = PrintSearchForPrinter(pPI, lpsPrinterToSelect);
        }

        //
        //  Open the current printer.
        //
        if (pPI->pCurPrinter)
        {
            //
            //  Open the current printer.
            //
            OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);
        }
        else
        {
            //
            //  If there isn't a current printer, try the printers in
            //  the list until either one is found that can be opened or
            //  until there are no more printers in the list.
            //
            for (ctr = 0; ctr < pPI->cPrinters; ctr++)
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];

                //
                //  Try to open the printer.
                //
                if (OpenPrinter( pPI->pCurPrinter->pPrinterName,
                                 &pPI->hCurPrinter,
                                 NULL ))
                {
                    break;
                }
            }
        }
    }
    else
    {
        //
        //  If there isn't a current printer, then try to enumerate.
        //  This means something isn't setup properly.
        //
        if ((!pPI->pCurPrinter) || (!pPI->pPrinters))
        {
            goto Print_Enumerate;
        }
    }

    if (hCtl)
    {
        //
        //  Reset the contents of the list box.
        //
        SendMessage(hCtl, CB_RESETCONTENT, 0, 0);

        //
        //  Add all of the printer name strings to the list box.
        //
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            SendMessage( hCtl,
                         CB_ADDSTRING,
                         0,
                         (LPARAM)pPI->pPrinters[ctr].pPrinterName );
        }

        //
        //  Set the current selection in the list box.
        //
        SendMessage( hCtl,
                     CB_SETCURSEL,
                     SendMessage( hCtl,
                                  CB_FINDSTRINGEXACT,
                                  (WPARAM)-1,
                                  (LPARAM)pPI->pCurPrinter->pPrinterName ),
                     0L );
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintBuildDevNames
//
////////////////////////////////////////////////////////////////////////////

VOID PrintBuildDevNames(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPTSTR pPrinterName = NULL;
    LPTSTR pPortName = NULL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szPort[MAX_PATH];
    LPTSTR pStr;
    LPDEVNAMES pDN;
    DWORD cbDevNames;
    HANDLE hPrinter ;
    PPRINTER_INFO_2 pPrinter = NULL;


    //
    //  If this is called from PrintReturnDefault, there is no
    //  PrinterInfo (pPI->pCurPrinter) because the printers were not
    //  enumerated.  So, build the DEVNAME from win.ini.
    //
    pStr = szBuffer;
    if (!pPI->pCurPrinter)
    {
        //
        //  Get the default printer from the "Windows" section of win.ini.
        //      (eg. device=\\server\local,winspool,Ne00:)
        //
        if ( (pPD->Flags & PD_RETURNDEFAULT) &&
             GetProfileString( szTextWindows,
                               szTextDevice,
                               szTextNull,
                               szBuffer,
                               ARRAYSIZE(szBuffer) ) )
        {
            //
            // Make sure null-terminated.
            //
            szBuffer[ARRAYSIZE(szBuffer) - 1] = CHAR_NULL;

            //  Examples of szBuffer:
            //    "My Local Printer,winspool,LPT1:"   or
            //    "\\server\local,winspool,Ne00:"

            //
            //  Skip leading space (if any).
            //
            while (*pStr == CHAR_SPACE)
            {
                pStr++;
            }

            //
            //  First token is the printer name.
            //
            pPrinterName = pStr;

            while (*pStr && *pStr != CHAR_COMMA)
            {
                pStr++;
            }

            //
            //  NULL terminate the printer name.
            //
            *pStr++ = CHAR_NULL;

            // For Newer Apps  return the port name from the PRINT_INFO_2 structure.
            // For older apps  return the short port name give in the win.ini
            if (pPI->ProcessVersion >= 0x40000)
            {
                //Newer App
                if (OpenPrinter(pPrinterName, &hPrinter, NULL))
                {
                    if (pPrinter = PrintGetPrinterInfo2(hPrinter))
                    {
                        StringCchCopy(szPort, ARRAYSIZE(szPort), pPrinter->pPortName);
                        pPortName = szPort;
                        GlobalFree(pPrinter);
                    }
                    ClosePrinter(hPrinter);

                 }
                 else
                 {
                     //Unable to Open Printer so return
                     return ;
                 }
            }
            else
            {

                //Old App

                //
                //  Skip the driver name (second token).
                //
                while (*pStr && *pStr++ != CHAR_COMMA)
                {
                    ;
                }

                //
                //  Skip leading space (if any).
                //
                while (*pStr == CHAR_SPACE)
                {
                    pStr++;
                }

                //
                //  Third (and last) token is the port name.
                //
                pPortName = pStr;
            }
        }
        else
        {
            return;
        }
    }
    else
    {
        //
        //  Get the printer name from the PrinterInfo2 structure
        //  for the current printer.
        //
        pPrinterName = pPI->pCurPrinter->pPrinterName;

        //
        //  Newer Apps:
        //    Get the port name from the PrinterInfo2 structure for the
        //    current printer.  Want to use the PrinterInfo2 structure
        //    for newer apps so that we can support multiple ports for
        //    one printer.
        //
        //  Older Apps:
        //    First try to get the port name from the "devices" section
        //    of win.ini.  If that fails, then use the PrinterInfo2
        //    structure for the current printer.
        //
        //    This needs to use the "devices" section first due to a bug
        //    in AutoCAD.  AutoCAD only allows 13 characters for the port
        //    name and it does not check the length when it tries to copy
        //    it to its own buffer.
        //

        if ( (pPI->ProcessVersion < 0x40000) &&
             (GetProfileString( szTextDevices,
                                pPrinterName,
                                szTextNull,
                                szBuffer,
                                ARRAYSIZE(szBuffer) )) )
        {
            //
            // Make sure null-terminated.
            //
            szBuffer[ARRAYSIZE(szBuffer) - 1] = CHAR_NULL;

            if ( !(pPortName = StrChr(szBuffer, CHAR_COMMA)) ||
                 (!((++pPortName)[0])) )
            {
                //
                //  Get the port name from the PrinterInfo2 structure
                //  for the current printer.
                //
                pPortName = pPI->pCurPrinter->pPortName;
            }
        }
        else
        {
            pPortName = pPI->pCurPrinter->pPortName;
        }
    }

    if (pPortName && pPrinterName)
    {
        //
        //  Compute the size of the DevNames structure.
        //
        cbDevNames = lstrlen(szDriver) + 1 +
                    lstrlen(pPortName) + 1 +
                    lstrlen(pPrinterName) + 1 +
                    DN_PADDINGCHARS;

        cbDevNames *= sizeof(TCHAR);
        cbDevNames += sizeof(DEVNAMES);

        //
        //  Allocate the new DevNames structure.
        //
        pDN = NULL;
        if (pPD->hDevNames)
        {
            HANDLE handle;

            handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

            //Make sure the Realloc succeeded.
            if (handle)
            {
                pPD->hDevNames = handle;
            }
            else
            {
                //Realloc didn't succeed.  Free the old the memory
                pPD->hDevNames = GlobalFree(pPD->hDevNames);
            }
        }
        else
        {
            pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
        }

        //
        //  Fill in the DevNames structure with the appropriate information.
        //
        if ( (pPD->hDevNames) &&
            (pDN = GlobalLock(pPD->hDevNames)) )
        {
            pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
            StringCchCopy((LPTSTR)pDN + pDN->wDriverOffset, lstrlen(szDriver) + 1, szDriver);

            pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
            StringCchCopy((LPTSTR)pDN + pDN->wDeviceOffset, lstrlen(pPrinterName) + 1, pPrinterName);

            pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pPrinterName) + 1;
            StringCchCopy((LPTSTR)pDN + pDN->wOutputOffset, lstrlen(pPortName) + 1, pPortName);

            if ( (pPD->Flags & PD_RETURNDEFAULT) ||
                !lstrcmp(pPrinterName, pPI->szDefaultPrinter) )
            {
                pDN->wDefault = DN_DEFAULTPRN;
            }
            else
            {
                pDN->wDefault = 0;
            }

            GlobalUnlock(pPD->hDevNames);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDevMode
//
//  Create and/or fill DEVMODE structure.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode)
{
    LONG cbNeeded;
    LPDEVMODE pDM;


    cbNeeded = DocumentProperties( hDlg,
                                   hPrinter,
                                   lpsDeviceName,
                                   (PDEVMODE)NULL,
                                   (PDEVMODE)NULL,
                                   0 );

    if (cbNeeded > 0)
    {
        if (hDevMode)
        {
            HANDLE h = GlobalReAlloc(hDevMode, cbNeeded, GHND);

            //Make sure realloc succeeded.
            if (h)
            {
                hDevMode  = h;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                GlobalFree(hDevMode);
                hDevMode = NULL;
            }

        }
        else
        {
            hDevMode = GlobalAlloc(GHND, cbNeeded);
        }

        if (hDevMode && (pDM = GlobalLock(hDevMode)))
        {
            if (DocumentProperties( hDlg,
                                    hPrinter,
                                    lpsDeviceName,
                                    pDM,
                                    NULL,
                                    DM_COPY ) != IDOK)
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
                GlobalUnlock(hDevMode);
                GlobalFree(hDevMode);
                return (NULL);
            }

            GlobalUnlock(hDevMode);
        }
        else
        {
            if (hDevMode)
            {
                StoreExtendedError(CDERR_MEMLOCKFAILURE);
                GlobalFree(hDevMode);
            }
            else
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
            }
            return (NULL);
        }
    }
    else
    {
        DWORD dwErrCode;

        hDevMode = NULL;
        dwErrCode = GetLastError();

        if ( (dwErrCode == ERROR_UNKNOWN_PRINTER_DRIVER) ||
             (dwErrCode == ERROR_MOD_NOT_FOUND) )
        {
            if (hDlg)
            {
                PrintEditError(hDlg, 0, iszUnknownDriver, lpsDeviceName);
            }
        }
    }

    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnICDC
//
//  Retrieve either the hDC or the hIC if either flag is set.
//  Assumes the PD_PRINTOFILE flag is appropriately set.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM)
{
    if (pPD->Flags & PD_PRINTTOFILE)
    {
        //
        // We are sure the destination buffer is large enough here. When we do the
        // GlobalAlloc/GlobalRealloc in PrintBuildDevNames(), the buffer size has
        // DN_PADDINGCHARS(16) characters for padding. Since the size of szFilePort
        // is 5 and wOutPutOffest is placed at the end of the memory, the padding
        // chars could be used to store szFilePort. So unless we change the order
        // of offsets in DEVNAMES, we are safe here.
        //
        StringCchCopy((LPTSTR)pDN + pDN->wOutputOffset, lstrlen(szFilePort) + 1, szFilePort);
    }

    //
    //  The dmCollate field wasn't part of the Win3.1 DevMode struct.  The way
    //  16-bit apps achieved collation was by checking the PD_COLLATE flag in
    //  the PrintDlg struct.  The app would then figure out the page printing
    //  order to achieve collation.  So what we're doing here is making sure
    //  that PD_COLLATE is the only collation mechanism for 16-bit apps.  If we
    //  let DM_COLLATE get into the DC we'd end up with the driver trying to
    //  collate a job that the app is already trying to collate!
    //
    if ((pPD->Flags & CD_WOWAPP) && pDM)
    {
        if (pDM->dmFields & DM_COLLATE)
        {
            pPD->Flags |= PD_COLLATE;
        }

        // these should always be off for WOW apps
        pDM->dmCollate = DMCOLLATE_FALSE;
        pDM->dmFields &= ~DM_COLLATE;
    }

    switch (pPD->Flags & (PD_RETURNDC | PD_RETURNIC))
    {
        case ( PD_RETURNIC ) :
        {
            pPD->hDC = CreateIC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM);
            if (pPD->hDC)
            {
                break;
            }

            // else fall thru...
        }
        case ( PD_RETURNDC ) :
        case ( PD_RETURNDC | PD_RETURNIC ) :
        {
            //
            //  PD_RETURNDC has priority if they are both set.
            //
            pPD->hDC = CreateDC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM );
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintMeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    HDC hDC;
    TEXTMETRIC TM;
    HANDLE hFont;


    if (hDC = GetDC(hDlg))
    {
        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        mis->itemHeight = (WORD)TM.tmHeight;
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitOrientation
//
//  Enable/Disable Paper Orientation controls
//
//  NOTE: If the driver doesn't support orientation AND is smart
//  enough to tell us about it, disable the appropriate dialog items.
//  "Smart enough" means the driver must support DC_ORIENTATION in its
//  DeviceCapabilities routine.  This was introduced for 3.1, hence the
//  version test.  NotBadDriver() may need to be incorporated if a
//  problem driver is found in testing.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    BOOL bEnable = TRUE;
    HWND hCtl;
    HDC hDC;
    int iHeight;
    PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;


    if (!pPrinter)
    {
        return;
    }

    if (pDM->dmSpecVersion >= 0x030A)
    {
        pPI->dwRotation = DeviceCapabilities( pPrinter->pPrinterName,
                                              pPrinter->pPortName,
                                              DC_ORIENTATION,
                                              NULL,
                                              pDM );
        switch (pPI->dwRotation)
        {
            case ( ROTATE_LEFT ) :
            case ( ROTATE_RIGHT ) :
            {
                bEnable = TRUE;
                break;
            }
            default :
            {
                pPI->dwRotation = 0;
                bEnable = FALSE;
                pDM->dmOrientation = DMORIENT_PORTRAIT;
                CheckRadioButton( hDlg,
                                  ID_SETUP_R_PORTRAIT,
                                  ID_SETUP_R_LANDSCAPE,
                                  ID_SETUP_R_PORTRAIT );
                break;
            }
        }
    }

    if ( (pDM->dmOrientation != DMORIENT_PORTRAIT) &&
         (pDM->dmOrientation != DMORIENT_LANDSCAPE) )
    {
        pDM->dmOrientation  = DMORIENT_PORTRAIT;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE))
    {
        //
        //  Landscape
        //
        if ( !( (pPI->pPSD) &&
                (pPI->pPSD->Flags & PSD_DISABLEORIENTATION) ) )
        {
            EnableWindow(hCtl, bEnable);
        }
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        //
        //  Orientation of icon.
        //
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    if ( (!pPI->RtSampleXYWH.left) &&
         (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) )
    {
        GetWindowRect(hCtl, (LPRECT)&pPI->RtSampleXYWH);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.left);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.right);

        iHeight = pPI->RtSampleXYWH.bottom - pPI->RtSampleXYWH.top;
        pPI->RtSampleXYWH.bottom = iHeight;

        if (hDC = GetDC(0))
        {
            iHeight = iHeight * GetDeviceCaps(hDC, LOGPIXELSX) /
                                GetDeviceCaps(hDC, LOGPIXELSY);
            ReleaseDC(0, hDC);
        }

        pPI->RtSampleXYWH.left =
            (pPI->RtSampleXYWH.left + pPI->RtSampleXYWH.right - iHeight) / 2;
        pPI->RtSampleXYWH.right = iHeight;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetOrientation
//
//  Switch icon, check button, for Portrait or LandScape printing mode.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait;
    HWND hIcn;


    bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);

    pDM->dmOrientation = ( bPortrait
                               ? DMORIENT_PORTRAIT
                               : DMORIENT_LANDSCAPE );

    CheckRadioButton(hDlg, ID_SETUP_R_PORTRAIT, ID_SETUP_R_LANDSCAPE, uiNewId);

    if (hIcn = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        ShowWindow(hIcn, SW_HIDE);
        SendMessage( hIcn,
                     STM_SETICON,
                     bPortrait ? (LONG_PTR)hIconPortrait : (LONG_PTR)hIconLandscape,
                     0L );
        ShowWindow(hIcn, SW_SHOW);
    }

    //
    //  Update the page setup dialog, if necessary.
    //
    if (pPI->pPSD)
    {
        PrintUpdatePageSetup(hDlg, pPI, pDM, uiOldId, uiNewId);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdatePageSetup
//
//  Update the page setup information.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    LPPRINTDLG pPD = pPI->pPD;
    HWND hWndSample;
    HWND hWndShadowRight;
    HWND hWndShadowBottom;
    HWND hWndSize;
    LONG lTemp;


    if (!pPSD)
    {
        return;
    }

    if (uiOldId != uiNewId)
    {
        RECT aRtMinMargin = pPSD->rtMinMargin;
        RECT aRtMargin    = pPSD->rtMargin;
        HWND hWndLeft     = GetDlgItem(hDlg, ID_SETUP_E_LEFT);
        HWND hWndTop      = GetDlgItem(hDlg, ID_SETUP_E_TOP);
        HWND hWndRight    = GetDlgItem(hDlg, ID_SETUP_E_RIGHT);
        HWND hWndBottom   = GetDlgItem(hDlg, ID_SETUP_E_BOTTOM);
        TCHAR szLeft  [8];
        TCHAR szTop   [8];
        TCHAR szRight [8];
        TCHAR szBottom[8];

        GetWindowText(hWndLeft, szLeft, 8);
        GetWindowText(hWndTop, szTop, 8);
        GetWindowText(hWndRight, szRight, 8);
        GetWindowText(hWndBottom, szBottom, 8);

        switch (uiNewId + pPI->dwRotation)
        {
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_RIGHT ) :  // HP PCL
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_LEFT ) :   // dot-matrix
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.top;
                pPSD->rtMinMargin.top    = aRtMinMargin.right;
                pPSD->rtMinMargin.right  = aRtMinMargin.bottom;
                pPSD->rtMinMargin.bottom = aRtMinMargin.left;

                pPSD->rtMargin.left   = aRtMargin.top;
                pPSD->rtMargin.top    = aRtMargin.right;
                pPSD->rtMargin.right  = aRtMargin.bottom;
                pPSD->rtMargin.bottom = aRtMargin.left;

                SetWindowText(hWndLeft, szTop);
                SetWindowText(hWndRight, szBottom);
                SetWindowText(hWndTop, szRight);
                SetWindowText(hWndBottom, szLeft);

                break;
            }
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_LEFT ) :   // dot-matrix
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_RIGHT ) :  // HP PCL
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.bottom;
                pPSD->rtMinMargin.top    = aRtMinMargin.left;
                pPSD->rtMinMargin.right  = aRtMinMargin.top;
                pPSD->rtMinMargin.bottom = aRtMinMargin.right;

                pPSD->rtMargin.left   = aRtMargin.bottom;
                pPSD->rtMargin.top    = aRtMargin.left;
                pPSD->rtMargin.right  = aRtMargin.top;
                pPSD->rtMargin.bottom = aRtMargin.right;

                SetWindowText(hWndLeft, szBottom);
                SetWindowText(hWndRight, szTop);
                SetWindowText(hWndTop, szLeft);
                SetWindowText(hWndBottom, szRight);

                break;
            }
        }
    }
    pPI->uiOrientationID = uiNewId;

    //
    //  Update ptPaperSize.
    //
    pPI->PtPaperSizeMMs.x = 0;
    pPI->PtPaperSizeMMs.y = 0;
    pPD->Flags &= ~PI_WPAPER_ENVELOPE;

    if ((hWndSize = GetDlgItem(hDlg, ID_SETUP_C_SIZE)) && (pPI->pCurPrinter))
    {
        PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;
        DWORD dwNumber;
        LPWORD lpPapers;
        LPPOINT lpPaperSize;
        int nInd;
        DWORD i;

        dwNumber = DeviceCapabilities( pPrinter->pPrinterName,
                                       pPrinter->pPortName,
                                       DC_PAPERS,
                                       NULL,
                                       pDM );
        if ( dwNumber &&
             (dwNumber != (DWORD)-1) &&
             (lpPapers = LocalAlloc( LPTR,
                                     dwNumber *
                                         (sizeof(WORD) + sizeof(POINT)) * 2 )) )
        {
            lpPaperSize = (LPPOINT)(lpPapers + dwNumber * 2);

            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERS,
                                (LPTSTR)lpPapers,
                                pDM );
            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERSIZE,
                                (LPTSTR)lpPaperSize,
                                pDM );

            if ((nInd = (int) SendMessage(hWndSize, CB_GETCURSEL, 0, 0)) != CB_ERR)
            {
                pPI->wPaper = (WORD)SendMessage( hWndSize,
                                                 CB_GETITEMDATA,
                                                 nInd,
                                                 0 );
                pDM->dmPaperSize = pPI->wPaper;
            }
            else
            {
                pPI->wPaper = pDM->dmPaperSize;
            }

            ComboBoxGetLBText( hWndSize,
                               nInd,
                               pDM->dmFormName,
                               ARRAYSIZE(pDM->dmFormName) );


            switch (pPI->wPaper)
            {
                case ( DMPAPER_ENV_9 ) :
                case ( DMPAPER_ENV_10 ) :
                case ( DMPAPER_ENV_11 ) :
                case ( DMPAPER_ENV_12 ) :
                case ( DMPAPER_ENV_14 ) :
                case ( DMPAPER_ENV_DL ) :
                case ( DMPAPER_ENV_C5 ) :
                case ( DMPAPER_ENV_C3 ) :
                case ( DMPAPER_ENV_C4 ) :
                case ( DMPAPER_ENV_C6 ) :
                case ( DMPAPER_ENV_C65 ) :
                case ( DMPAPER_ENV_B4 ) :
                case ( DMPAPER_ENV_B5 ) :
                case ( DMPAPER_ENV_B6 ) :
                case ( DMPAPER_ENV_ITALY ) :
                case ( DMPAPER_ENV_MONARCH ) :
                case ( DMPAPER_ENV_PERSONAL ) :
                case ( DMPAPER_ENV_INVITE ) :
                case ( DMPAPER_JENV_KAKU2 ) :
                case ( DMPAPER_JENV_KAKU3 ) :
                case ( DMPAPER_JENV_CHOU3 ) :
                case ( DMPAPER_JENV_CHOU4 ) :
                case ( DMPAPER_JENV_KAKU2_ROTATED ) :
                case ( DMPAPER_JENV_KAKU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU4_ROTATED ) :
                case ( DMPAPER_JENV_YOU4 ) :
                case ( DMPAPER_JENV_YOU4_ROTATED ) :
                case ( DMPAPER_PENV_1 ) :
                case ( DMPAPER_PENV_2 ) :
                case ( DMPAPER_PENV_3 ) :
                case ( DMPAPER_PENV_4 ) :
                case ( DMPAPER_PENV_5 ) :
                case ( DMPAPER_PENV_6 ) :
                case ( DMPAPER_PENV_7 ) :
                case ( DMPAPER_PENV_8 ) :
                case ( DMPAPER_PENV_9 ) :
                case ( DMPAPER_PENV_10 ) :
                case ( DMPAPER_PENV_1_ROTATED ) :
                case ( DMPAPER_PENV_2_ROTATED ) :
                case ( DMPAPER_PENV_3_ROTATED ) :
                case ( DMPAPER_PENV_4_ROTATED ) :
                case ( DMPAPER_PENV_5_ROTATED ) :
                case ( DMPAPER_PENV_6_ROTATED ) :
                case ( DMPAPER_PENV_7_ROTATED ) :
                case ( DMPAPER_PENV_8_ROTATED ) :
                case ( DMPAPER_PENV_9_ROTATED ) :
                case ( DMPAPER_PENV_10_ROTATED ) :
                {
                    pPD->Flags |= PI_WPAPER_ENVELOPE;
                    break;
                }
            }

            for (i = 0; i < dwNumber; i++)
            {
                if (lpPapers[i] == pPI->wPaper)
                {
                    //
                    //  In tenths of MMs.
                    //
                    *(LPPOINT)&pPI->PtPaperSizeMMs = lpPaperSize[i];
                    break;
                }
            }

            LocalFree(lpPapers);
        }
    }

    //
    //  If the paper size could not be found, use something reasonable
    //  (eg. letter).
    //
    if (!pPI->PtPaperSizeMMs.x)
    {
        pPI->PtPaperSizeMMs.x = 85 * MMS_PER_INCH / 10;
    }
    if (!pPI->PtPaperSizeMMs.y)
    {
        pPI->PtPaperSizeMMs.y = 11 * MMS_PER_INCH;
    }

    //
    //  Rotate envelopes as needed.
    //
    if ( (pPD->Flags & PI_WPAPER_ENVELOPE) &&
         (!pPI->dwRotation) &&
         (pPI->PtPaperSizeMMs.x < pPI->PtPaperSizeMMs.y) )
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Maintain everything in accordance with the orientation
    //  so that apps have to do as little work as possible.
    //
    if (!bPortrait)
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Set up return ptPaperSize value.
    //
    if (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 1000 / MMS_PER_INCH;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 1000 / MMS_PER_INCH;
    }
    else           // PSD_INHUNDREDTHSOFMILLIMETERS
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 10;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 10;
    }

    //
    //  Update RtMinMarginMMs and rtMinMargin for new papersize/orientation.
    //
    PrintSetMinMargins(hDlg, pPI, pDM);

    //
    //  Don't let margins overlap (page might have shrunk).
    //
    if (pPSD->rtMargin.left + pPSD->rtMargin.right > pPSD->ptPaperSize.x)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.left  = (pPSD->ptPaperSize.x - lTemp) / 2;
        pPSD->rtMargin.right = (pPSD->ptPaperSize.x - lTemp) / 2;
    }
    if (pPSD->rtMargin.top + pPSD->rtMargin.bottom > pPSD->ptPaperSize.y)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.top    = (pPSD->ptPaperSize.y - lTemp) / 2;
        pPSD->rtMargin.bottom = (pPSD->ptPaperSize.y - lTemp) / 2;
    }

    //
    //  There are new minimal margins, so adjust rtMargin
    //  (min margins might have grown).
    //
    if (pPSD->rtMargin.left < pPSD->rtMinMargin.left)
        pPSD->rtMargin.left = pPSD->rtMinMargin.left;
    if (pPSD->rtMargin.top < pPSD->rtMinMargin.top)
        pPSD->rtMargin.top = pPSD->rtMinMargin.top;
    if (pPSD->rtMargin.right < pPSD->rtMinMargin.right)
        pPSD->rtMargin.right = pPSD->rtMinMargin.right;
    if (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom)
        pPSD->rtMargin.bottom = pPSD->rtMinMargin.bottom;

    //
    //  The margins were adjusted, so update the ui.
    //
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_LEFT, pPSD->rtMargin.left);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_TOP, pPSD->rtMargin.top);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_RIGHT, pPSD->rtMargin.right);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_BOTTOM, pPSD->rtMargin.bottom);

    //
    //  Update the sample window size & shadow.
    //
    if ( (hWndSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) &&
         (hWndShadowRight = GetDlgItem(hDlg, ID_SETUP_W_SHADOWRIGHT)) &&
         (hWndShadowBottom = GetDlgItem(hDlg, ID_SETUP_W_SHADOWBOTTOM)) )
    {
        int iWidth = pPI->PtPaperSizeMMs.x;
        int iLength = pPI->PtPaperSizeMMs.y;
        int iExtent;
        RECT aRtSampleXYWH = pPI->RtSampleXYWH;
        int iX = aRtSampleXYWH.right  / 16;
        int iY = aRtSampleXYWH.bottom / 16;

        if (iWidth > iLength)
        {
            iExtent = aRtSampleXYWH.bottom * iLength / iWidth;
            aRtSampleXYWH.top += (aRtSampleXYWH.bottom - iExtent) / 2;
            aRtSampleXYWH.bottom = iExtent;
        }
        else
        {
            iExtent = aRtSampleXYWH.right * iWidth / iLength;
            aRtSampleXYWH.left += (aRtSampleXYWH.right - iExtent) / 2;
            aRtSampleXYWH.right = iExtent;
        }

        SetWindowPos( hWndSample,
                      0,
                      aRtSampleXYWH.left,
                      aRtSampleXYWH.top,
                      aRtSampleXYWH.right,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowRight,
                      0,
                      aRtSampleXYWH.left + aRtSampleXYWH.right,
                      aRtSampleXYWH.top + iY,
                      iX,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowBottom,
                      0,
                      aRtSampleXYWH.left + iX,
                      aRtSampleXYWH.top + aRtSampleXYWH.bottom,
                      aRtSampleXYWH.right,
                      iY,
                      SWP_NOZORDER );

        InvalidateRect(hWndSample, NULL, TRUE);
        UpdateWindow(hDlg);
        UpdateWindow(hWndSample);
        UpdateWindow(hWndShadowRight);
        UpdateWindow(hWndShadowBottom);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitDuplex
//
//  Enable/Disable Paper Duplexing controls.
//
//  Returns TRUE iff buttons used to be disabled, now enabled.
//  Returns FALSE otherwise.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM)
{
    BOOL bEnable;
    HWND hCtl;


    bEnable = (pDM->dmFields & DM_DUPLEX);

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_G_DUPLEX))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LONG))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_SHORT))
    {
        EnableWindow(hCtl, bEnable);
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
        if (!bEnable)
        {
            ShowWindow(hCtl, SW_HIDE);
            SendMessage(hCtl, STM_SETICON, (LONG_PTR)hIconPDuplexNone, 0L);
            ShowWindow(hCtl, SW_SHOW);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetDuplex
//
//  This routine will operate on pDocDetails->pDMInput PSDEVMODE structure,
//  making sure that is a structure we know about and can handle.
//
//  If the pd doesn't have DM_DUPLEX caps then just display the appropriate
//  paper icon for DMDUP_SIMPLEX (case where nRad = ID_SETUP_R_NONE).
//
//  If nRad = 0, update icon but don't change radio button.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad)
{
    BOOL bPortrait;
    HANDLE hDuplexIcon;
    HWND hCtl;


    bPortrait = (pDM->dmOrientation == DMORIENT_PORTRAIT);

    if (!(pDM->dmFields & DM_DUPLEX))
    {
        nRad = ID_SETUP_R_NONE;
    }

    //
    //  Boundary checking - default to ID_SETUP_R_NONE.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        if ((nRad < ID_SETUP_R_NONE) || (nRad > ID_SETUP_R_SHORT))
        {
            if (IsDlgButtonChecked(hDlg, ID_SETUP_R_SHORT))
            {
                nRad = ID_SETUP_R_SHORT;
            }
            else if (IsDlgButtonChecked(hDlg, ID_SETUP_R_LONG))
            {
                nRad = ID_SETUP_R_LONG;
            }
            else
            {
                nRad = ID_SETUP_R_NONE;
            }
        }
        else
        {
            CheckRadioButton(hDlg, ID_SETUP_R_NONE, ID_SETUP_R_SHORT, nRad);
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        switch (nRad)
        {
            case ( ID_SETUP_R_LONG ) :      // Long Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_VERTICAL;
                hDuplexIcon = bPortrait ? hIconPDuplexNoTumble : hIconLDuplexTumble;

                break;
            }
            case ( ID_SETUP_R_SHORT ) :     // Short Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_HORIZONTAL;
                hDuplexIcon = bPortrait ? hIconPDuplexTumble : hIconLDuplexNoTumble;

                break;
            }
            default :                       // None - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_SIMPLEX;
                hDuplexIcon = bPortrait ? hIconPDuplexNone : hIconLDuplexNone;

                break;
            }
        }

        //
        //  Set the appropriate icon.
        //
        ShowWindow(hCtl, SW_HIDE);
        SendMessage(hCtl, STM_SETICON, (LONG_PTR)hDuplexIcon, 0L);
        ShowWindow(hCtl, SW_SHOW);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPaperCombo
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2)
{
    DWORD cStr1, cStr2, cRet1, cRet2, i;
    LPTSTR lpsOut1;
    LPWORD lpwOut2;
    BOOL fFill;


    HourGlass(TRUE);

    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    cStr1 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap1,
                                NULL,
                                pDM );

    cStr2 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap2,
                                NULL,
                                pDM );

    //
    //  Check for error from DeviceCapabilities calls.  If either
    //  call failed, simply set cStr1 to be 0 so that the windows will be
    //  disabled and nothing will be initialized.
    //
    if ((cStr1 == (DWORD)(-1)) || (cStr2 == (DWORD)(-1)))
    {
        cStr1 = 0;
    }

    fFill = (cStr1 > 0) && (cStr1 == cStr2);

    if (!((pPI->pPSD) && (pPI->pPSD->Flags & PSD_DISABLEPAPER)))
    {
        //
        //  If no entries, disable hCmb and hStc.
        //
        EnableWindow(hCmb, fFill);
        EnableWindow(hStc, fFill);
    }

    if (fFill)
    {
        lpsOut1 = LocalAlloc(LPTR, cStr1 * cchSize1 * sizeof(TCHAR));

        lpwOut2 = LocalAlloc(LPTR, cStr2 * sizeof(WORD));

        if (lpsOut1 && lpwOut2)
        {
            cRet1 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap1,
                                        (LPTSTR)lpsOut1,
                                        pDM );

            cRet2 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap2,
                                        (LPTSTR)lpwOut2,
                                        pDM );

            if ((pPI->dwRotation =
                    DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        DC_ORIENTATION,
                                        NULL,
                                        pDM )) == (DWORD)(-1))
            {
                pPI->dwRotation = 0;
            }

            if ((cRet1 == cStr1) && (cRet2 == cStr2))
            {
                LPTSTR lpsT1 = lpsOut1;
                LPWORD lpwT2 = lpwOut2;
                int nInd;
                LPTSTR lpFound = NULL;
                LPTSTR lpFirst = NULL;

                for (i = 0; i < cRet1; i++, lpsT1 += cchSize1, lpwT2++)
                {
                    //
                    //  Look for a blank name entry.
                    //
                    if (!*lpsT1)
                    {
                        //
                        //  Blank entry, so ignore.
                        //
                        continue;
                    }

                    //
                    //  Add the string to the list box.
                    //
                    nInd = (int) SendMessage( hCmb,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM)lpsT1 );
                    if (nInd != CB_ERR)
                    {
                        //
                        //  Set the data associated with the string that
                        //  was just added to the list box.
                        //
                        SendMessage( hCmb,
                                     CB_SETITEMDATA,
                                     nInd,
                                     (LPARAM)*lpwT2 );

                        //
                        //  See if this item should be selected.
                        //
                        if (!lpFound)
                        {
                            if (!lpFirst)
                            {
                                lpFirst = lpsT1;
                            }

                            if ( (fwCap1 == DC_PAPERNAMES) &&
                                 (pDM->dmFields & DM_PAPERSIZE) &&
                                 (pDM->dmPaperSize == (SHORT)*lpwT2) )
                            {
                                lpFound = lpsT1;
                            }
                            else if ( (fwCap1 == DC_BINNAMES) &&
                                      (pDM->dmFields & DM_DEFAULTSOURCE) &&
                                      (pDM->dmDefaultSource == (SHORT)*lpwT2) )
                            {
                               lpFound = lpsT1;
                            }
                        }
                    }
                }

                //
                //  Set the appropriate selection.
                //
                if (lpFound)
                {
                    SendMessage( hCmb,
                                 CB_SETCURSEL,
                                 SendMessage( hCmb,
                                              CB_FINDSTRINGEXACT,
                                              (WPARAM)-1,
                                              (LPARAM)lpFound ),
                                 0 );
                }
                else
                {
                    if (fwCap1 == DC_PAPERNAMES)
                    {
                        //
                        //  Check for a default FORM name.
                        //
                        if (!( (pDM->dmFields & DM_FORMNAME) &&
                               ((nInd = (int)
                                   SendMessage( hCmb,
                                                CB_SELECTSTRING,
                                                (WPARAM)-1,
                                                (LPARAM)pDM->dmFormName )) != CB_ERR) ))
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                        else
                        {
                            //
                            //  Save the paper size since the form name exists
                            //  in the list box.
                            //
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                    }
                    else
                    {
                        //
                        //  Set the SOURCE to the Default if it exists.
                        //
                        nInd = (int) SendMessage( hCmb,
                                                  CB_SELECTSTRING,
                                                  (WPARAM)-1,
                                                  (LPARAM)szDefaultSrc );
                        if (nInd != CB_ERR)
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                        else
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                    }
                }
            }
        }
        if (lpsOut1)
        {
            LocalFree((HLOCAL)lpsOut1);
        }

        if (lpwOut2)
        {
            LocalFree((HLOCAL)lpwOut2);
        }
    }

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditError
//
//  Set focus to an edit control and select the entire contents.
//  This is generally used when an improper value was found at OK time.
//
//  Assumes edit control not disabled.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...)
{
    HWND hEdit;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszFormat[MAX_PATH];
    TCHAR pszMessage[MAX_PATH];


    //
    //  Put up the error message box.
    //
    if ( GetWindowText(hDlg, pszTitle, ARRAYSIZE(pszTitle)) &&
         CDLoadString(g_hinst, MessageId, pszFormat, ARRAYSIZE(pszFormat)) )
    {
        va_list ArgList;

        va_start(ArgList, MessageId);
        wvnsprintf(pszMessage, ARRAYSIZE(pszMessage), pszFormat, ArgList);
        va_end(ArgList);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox(hDlg, pszMessage, pszTitle, MB_ICONEXCLAMATION | MB_OK);
    }

    //
    //  Highlight the invalid value.
    //
    if (hEdit = ((Id == 0) ? NULL : GetDlgItem(hDlg, Id)))
    {
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hEdit, 1L);
        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintOpenPrinter
//
//  If the OpenPrinter call is successful, this sets hPrinter, pPrinter,
//  cPrinters, and pCurPrinter.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    if (OpenPrinter(pPrinterName, &pPI->hCurPrinter, NULL))
    {
        if (pPI->pPrinters = PrintGetPrinterInfo2(pPI->hCurPrinter))
        {
            pPI->cPrinters = 1;

            if (pPI->bUseExtDeviceMode)
            {
                PrintGetExtDeviceMode(NULL, pPI);
            }
        }
        pPI->pCurPrinter = pPI->pPrinters;
    }
    else
    {
        //
        //  Cannot trust the OpenPrinter call.
        //
        pPI->hCurPrinter = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintClosePrinters
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintClosePrinters(
    PPRINTINFO pPI)
{
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }
    pPI->pCurPrinter = NULL;

    FreePrinterArray(pPI);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSpoolerInfo
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSpoolerInfo(
    PPRINTINFO pPI)
{
    LPDEVMODEA pDMA;
    CHAR szPrinterNameA[33];
    LPDEVMODEW pDMW;


    //
    //  Get a pointer to the devmode structure.
    //
    pDMW = GlobalLock(pPI->pPD->hDevMode);
    if ((!pDMW) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  Convert the printer name from Unicode to ANSI.
    //
    SHUnicodeToAnsi(pPI->pCurPrinter->pPrinterName, szPrinterNameA, ARRAYSIZE(szPrinterNameA));

    //
    //  Allocate and convert the Unicode devmode to ANSI.
    //
    pDMA = AllocateAnsiDevMode(pDMW);
    if (!pDMA)
    {
        GlobalUnlock(pPI->pPD->hDevMode);
        return;
    }

    //
    //  Update the spooler's information.
    //
    ExtDeviceMode( NULL,
                   NULL,
                   NULL,
                   szPrinterNameA,
                   NULL,
                   pDMA,
                   NULL,
                   DM_UPDATE | DM_MODIFY );

    //
    //  Free the buffer.
    //
    GlobalFree(pDMA);
    GlobalUnlock(pPI->pPD->hDevMode);
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintGetPrinterInfo2
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintGetPrinterInfo2(
    HANDLE hPrinter)
{
    PPRINTER_INFO_2 pPrinter = NULL;
    DWORD cbPrinter = 0;


    StoreExtendedError(CDERR_GENERALCODES);

    if (!GetPrinter(hPrinter, 2, NULL, 0, &cbPrinter) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        if (pPrinter = GlobalAlloc(GPTR, cbPrinter))
        {
            if (!GetPrinter( hPrinter,
                             2,
                             (LPBYTE)pPrinter,
                             cbPrinter,
                             &cbPrinter ))
            {
                GlobalFree(pPrinter);
                pPrinter = NULL;
                StoreExtendedError(PDERR_PRINTERNOTFOUND);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
        }
    }
    else
    {
        StoreExtendedError(PDERR_SETUPFAILURE);
    }

    return (pPrinter);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertStringToInteger
//
//  Converts a string to an integer.  Stops at the first non digit.
//
////////////////////////////////////////////////////////////////////////////

int ConvertStringToInteger(
    LPCTSTR pSrc)
{
    int Number = 0;
    BOOL bNeg = FALSE;


    if (*pSrc == TEXT('-'))
    {
        bNeg = TRUE;
        pSrc++;
    }

    while (ISDIGIT(*pSrc))
    {
        Number *= 10;
        Number += *pSrc - TEXT('0');
        pSrc++;
    }

    return ( bNeg ? -Number : Number );
}


////////////////////////////////////////////////////////////////////////////
//
//  FreePrinterArray
//
//  Purpose:    Frees the buffer allocated to store printers.
//
//  Parameters: PPRINTINFO pPI
//
//  Return:     void
//
////////////////////////////////////////////////////////////////////////////

VOID FreePrinterArray(
    PPRINTINFO pPI)
{
    PPRINTER_INFO_2 pPrinters = pPI->pPrinters;
    DWORD dwCount;
    //
    //  If NULL, we can return now.
    //
    if (!pPrinters)
    {
        return;
    }

    //
    //  If we made calls to ExtDeviceMode, then we need to
    //  free the buffers allocated for each devmode.
    //
    if (pPI->bUseExtDeviceMode)
    {
        if (pPI->pAllocInfo)
        {
            //
            //  Loop through each of the printers.
            //
            for (dwCount = 0; dwCount < pPI->cPrinters; dwCount++)
            {
                //
                //  If pDevMode exists, free it.
                //
                if ((pPrinters[dwCount].pDevMode) &&
                    (pPI->pAllocInfo[dwCount]))
                {
                    GlobalFree(pPrinters[dwCount].pDevMode);
                    pPrinters[dwCount].pDevMode = NULL;
                }
            }
            GlobalFree(pPI->pAllocInfo);
            pPI->pAllocInfo = NULL;
        }
    }

    //
    //  Free the entire block.
    //
    GlobalFree(pPI->pPrinters);
    pPI->pPrinters = NULL;
    pPI->cPrinters = 0;
}


////////////////////////////////////////////////////////////////////////////
//
//  TermPrint
//
////////////////////////////////////////////////////////////////////////////

VOID TermPrint(void)
{
    Print_UnloadLibraries();           // printnew.cpp
}





/*========================================================================*/
/*                   Page Setup <-> Print Dialog                          */
/*========================================================================*/


////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPD->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPD->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPD2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPD2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPSD->hDevMode  = pPI->pPD->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PDA
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PDA(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPDA->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPDA->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPDA2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPDA2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPSD->hDevMode  = pPI->pPDA->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPDA->hDevNames;
    }
}

/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPageSetupDlg(
    PPRINTINFO pPI,
    LPPAGESETUPDLGA pPSDA)
{
    LPPRINTDLGA pPDA;


    if (!pPSDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSDA->lStructSize != sizeof(PAGESETUPDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSDA->Flags & PSD_RETURNDEFAULT) &&
        (pPSDA->hDevNames || pPSDA->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Reset the size of the pPSD structure to the UNICODE size and
    //  save it in the pPI structure.
    //
    //  NOTE:  This must be reset back to the ANSI size before
    //         returning to the caller.
    //
    pPSDA->lStructSize = sizeof(PAGESETUPDLGW);
    pPI->pPSD = (LPPAGESETUPDLG)pPSDA;
    pPI->ApiType = COMDLG_ANSI;

    //
    //  Create the ANSI version of the print dialog structure.
    //
    if (pPDA = GlobalAlloc(GPTR, sizeof(PRINTDLGA)))
    {
        pPI->pPDA = pPDA;

        pPDA->lStructSize         = sizeof(PRINTDLGA);
        pPDA->hwndOwner           = pPSDA->hwndOwner;
        pPDA->Flags               = PD_PAGESETUP |
                                      (pPSDA->Flags &
                                        (PSD_NOWARNING |
                                         PSD_SHOWHELP |
                                         PSD_ENABLEPAGESETUPHOOK |
                                         PSD_ENABLEPAGESETUPTEMPLATE |
                                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                         CD_WX86APP |
                                         PSD_NONETWORKBUTTON));
        pPDA->hInstance           = pPSDA->hInstance;
        pPDA->lCustData           = pPSDA->lCustData;
        pPDA->lpfnSetupHook       = pPSDA->lpfnPageSetupHook;
        pPDA->lpSetupTemplateName = pPSDA->lpPageSetupTemplateName;
        pPDA->hSetupTemplate      = pPSDA->hPageSetupTemplate;

        pPDA->hDevMode            = pPSDA->hDevMode;
        pPDA->hDevNames           = pPSDA->hDevNames;
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPageSetupDlg(
    PPRINTINFO pPI)
{
    //
    //  Reset the size of the pPSD structure to the correct value.
    //
    if (pPI->pPSD)
    {
        pPI->pPSD->lStructSize = sizeof(PAGESETUPDLGA);
    }

    //
    //  Free the ANSI print dialog structure.
    //
    if (pPI->pPDA)
    {
        GlobalFree(pPI->pPDA);
        pPI->pPDA = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPrintDlg(
    PPRINTINFO pPI,
    LPPRINTDLGA pPDA)
{
    LPPRINTDLGW pPDW;
    LPDEVMODEA pDMA;
    DWORD cbLen;


    if (!pPDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pPDW = GlobalAlloc(GPTR, sizeof(PRINTDLGW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize    = sizeof(PRINTDLGW);
    pPDW->hwndOwner      = pPDA->hwndOwner;
    pPDW->hInstance      = pPDA->hInstance;
    pPDW->lpfnPrintHook  = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook  = pPDA->lpfnSetupHook;
    pPDW->hPrintTemplate = pPDA->hPrintTemplate;
    pPDW->hSetupTemplate = pPDA->hSetupTemplate;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    //
    //  Thunk Device Names A => W
    //
    pPDW->hDevNames = NULL;
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName =
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpPrintTemplateName,(LPWSTR)pPDW->lpPrintTemplateName, cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpPrintTemplateName = (DWORD_PTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Init Print Setup TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLESETUPTEMPLATE) && (pPDA->lpSetupTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpSetupTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpSetupTemplateName) + 1;
            if (!(pPDW->lpSetupTemplateName =
                      GlobalAlloc( GPTR,
                                   (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fSetupTemplateAlloc = TRUE;
                SHAnsiToUnicode(pPDA->lpSetupTemplateName,(LPWSTR)pPDW->lpSetupTemplateName,cbLen);
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpSetupTemplateName = (DWORD_PTR)pPDA->lpSetupTemplateName;
        }
    }
    else
    {
        pPDW->lpSetupTemplateName = NULL;
    }

    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;


    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    if (pPI->fSetupTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpSetupTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgA2W(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;
    LPPRINTDLGA pPDA = pPI->pPDA;


    //
    //  Copy info A => W
    //
    pPDW->hDC           = pPDA->hDC;
    pPDW->Flags         = pPDA->Flags;
    pPDW->nFromPage     = pPDA->nFromPage;
    pPDW->nToPage       = pPDA->nToPage;
    pPDW->nMinPage      = pPDA->nMinPage;
    pPDW->nMaxPage      = pPDA->nMaxPage;
    pPDW->nCopies       = pPDA->nCopies;
    pPDW->lCustData     = pPDA->lCustData;
    pPDW->lpfnPrintHook = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook = pPDA->lpfnSetupHook;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesA2W(pPDA->hDevNames, &pPDW->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgW2A(
    PPRINTINFO pPI)
{
    LPPRINTDLGA pPDA = pPI->pPDA;
    LPPRINTDLGW pPDW = pPI->pPD;

    //
    //  Copy info W => A
    //
    pPDA->hDC           = pPDW->hDC;
    pPDA->Flags         = pPDW->Flags;
    pPDA->nFromPage     = pPDW->nFromPage;
    pPDA->nToPage       = pPDW->nToPage;
    pPDA->nMinPage      = pPDW->nMinPage;
    pPDA->nMaxPage      = pPDW->nMaxPage;
    pPDA->nCopies       = pPDW->nCopies;
    pPDA->lCustData     = pPDW->lCustData;
    pPDA->lpfnPrintHook = pPDW->lpfnPrintHook;
    pPDA->lpfnSetupHook = pPDW->lpfnSetupHook;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        // ignore the error case since we can't handle it either way.
        HRESULT hr = ThunkDevNamesW2A(pPDW->hDevNames, &pPDA->hDevNames);
        ASSERT(SUCCEEDED(hr));
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Make sure realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                pPDA->hDevMode = GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeA2W(
    LPDEVMODEA pDMA,
    LPDEVMODEW pDMW)
{
    LPDEVMODEA pDevModeA;

    if (!pDMA || !pDMW)
    {
        return;
    }

    //
    //  Make sure the device name in the devmode is not too long such that
    //  it has overwritten the other devmode fields.
    //
    if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
        (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
    {
        return;
    }

    //
    //  We need to create a temporary ANSI that is a known size.
    //  The problem is if we are being called from WOW, the WOW
    //  app could be either a Windows 3.1 or 3.0 app.  The size
    //  of the devmode structure was different for both of these
    //  versions compared to the DEVMODE structure in NT.
    //  By copying the ANSI devmode to one we allocate, then we
    //  can access all of the fields (26 currently) without causing
    //  an access violation.
    //
    pDevModeA = GlobalAlloc(GPTR, sizeof(DEVMODEA) + pDMA->dmDriverExtra);
    if (!pDevModeA)
    {
        return;
    }

    CopyMemory( (LPBYTE)pDevModeA,
                (LPBYTE)pDMA,
                min(sizeof(DEVMODEA), pDMA->dmSize) );

    CopyMemory( (LPBYTE)pDevModeA + sizeof(DEVMODEA),
                (LPBYTE)pDMA + pDMA->dmSize,
                pDMA->dmDriverExtra );

    //
    //  Now we can thunk the contents of the ANSI structure to the
    //  Unicode structure.
    //
    SHAnsiToUnicode((LPSTR)pDevModeA->dmDeviceName,(LPWSTR)pDMW->dmDeviceName,CCHDEVICENAME );

    pDMW->dmSpecVersion   = pDevModeA->dmSpecVersion;
    pDMW->dmDriverVersion = pDevModeA->dmDriverVersion;
    pDMW->dmSize          = sizeof(DEVMODEW);
    pDMW->dmDriverExtra   = pDevModeA->dmDriverExtra;
    pDMW->dmFields        = pDevModeA->dmFields;
    pDMW->dmOrientation   = pDevModeA->dmOrientation;
    pDMW->dmPaperSize     = pDevModeA->dmPaperSize;
    pDMW->dmPaperLength   = pDevModeA->dmPaperLength;
    pDMW->dmPaperWidth    = pDevModeA->dmPaperWidth;
    pDMW->dmScale         = pDevModeA->dmScale;
    pDMW->dmCopies        = pDevModeA->dmCopies;
    pDMW->dmDefaultSource = pDevModeA->dmDefaultSource;
    pDMW->dmPrintQuality  = pDevModeA->dmPrintQuality;
    pDMW->dmColor         = pDevModeA->dmColor;
    pDMW->dmDuplex        = pDevModeA->dmDuplex;
    pDMW->dmYResolution   = pDevModeA->dmYResolution;
    pDMW->dmTTOption      = pDevModeA->dmTTOption;
    pDMW->dmCollate       = pDevModeA->dmCollate;

    SHAnsiToUnicode((LPSTR)pDevModeA->dmFormName,(LPWSTR)pDMW->dmFormName,CCHFORMNAME );

    pDMW->dmLogPixels        = pDevModeA->dmLogPixels;
    pDMW->dmBitsPerPel       = pDevModeA->dmBitsPerPel;
    pDMW->dmPelsWidth        = pDevModeA->dmPelsWidth;
    pDMW->dmPelsHeight       = pDevModeA->dmPelsHeight;
    pDMW->dmDisplayFlags     = pDevModeA->dmDisplayFlags;
    pDMW->dmDisplayFrequency = pDevModeA->dmDisplayFrequency;

    pDMW->dmICMMethod        = pDevModeA->dmICMMethod;
    pDMW->dmICMIntent        = pDevModeA->dmICMIntent;
    pDMW->dmMediaType        = pDevModeA->dmMediaType;
    pDMW->dmDitherType       = pDevModeA->dmDitherType;

    pDMW->dmReserved1        = pDevModeA->dmReserved1;
    pDMW->dmReserved2        = pDevModeA->dmReserved2;

    pDMW->dmPanningWidth     = pDevModeA->dmPanningWidth;
    pDMW->dmPanningHeight    = pDevModeA->dmPanningHeight;

    CopyMemory( (pDMW + 1),
                (pDevModeA + 1),
                pDevModeA->dmDriverExtra );

    //
    //  Free the memory we allocated.
    //
    GlobalFree(pDevModeA);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeW2A(
    LPDEVMODEW pDMW,
    LPDEVMODEA pDMA)
{
    if (!pDMW || !pDMA)
    {
        return;
    }


    SHUnicodeToAnsi((LPWSTR)pDMW->dmDeviceName,(LPSTR)pDMA->dmDeviceName,CCHDEVICENAME);

    pDMA->dmSpecVersion   = pDMW->dmSpecVersion;
    pDMA->dmDriverVersion = pDMW->dmDriverVersion;
    pDMA->dmSize          = sizeof(DEVMODEA);
    pDMA->dmDriverExtra   = pDMW->dmDriverExtra;
    pDMA->dmFields        = pDMW->dmFields;
    pDMA->dmOrientation   = pDMW->dmOrientation;
    pDMA->dmPaperSize     = pDMW->dmPaperSize;
    pDMA->dmPaperLength   = pDMW->dmPaperLength;
    pDMA->dmPaperWidth    = pDMW->dmPaperWidth;
    pDMA->dmScale         = pDMW->dmScale;
    pDMA->dmCopies        = pDMW->dmCopies;
    pDMA->dmDefaultSource = pDMW->dmDefaultSource;
    pDMA->dmPrintQuality  = pDMW->dmPrintQuality;
    pDMA->dmColor         = pDMW->dmColor;
    pDMA->dmDuplex        = pDMW->dmDuplex;
    pDMA->dmYResolution   = pDMW->dmYResolution;
    pDMA->dmTTOption      = pDMW->dmTTOption;
    pDMA->dmCollate       = pDMW->dmCollate;

    SHUnicodeToAnsi((LPWSTR)pDMW->dmFormName,(LPSTR)pDMA->dmFormName,CCHFORMNAME);

    pDMA->dmLogPixels        = pDMW->dmLogPixels;
    pDMA->dmBitsPerPel       = pDMW->dmBitsPerPel;
    pDMA->dmPelsWidth        = pDMW->dmPelsWidth;
    pDMA->dmPelsHeight       = pDMW->dmPelsHeight;
    pDMA->dmDisplayFlags     = pDMW->dmDisplayFlags;
    pDMA->dmDisplayFrequency = pDMW->dmDisplayFrequency;

    pDMA->dmICMMethod        = pDMW->dmICMMethod;
    pDMA->dmICMIntent        = pDMW->dmICMIntent;
    pDMA->dmMediaType        = pDMW->dmMediaType;
    pDMA->dmDitherType       = pDMW->dmDitherType;

    pDMA->dmReserved1        = pDMW->dmReserved1;
    pDMA->dmReserved2        = pDMW->dmReserved2;

    pDMA->dmPanningWidth     = pDMW->dmPanningWidth;
    pDMA->dmPanningHeight    = pDMW->dmPanningHeight;

    CopyMemory( (pDMA + 1),
                (pDMW + 1),
                pDMA->dmDriverExtra );
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateUnicodeDevMode
//
//  Purpose:    Allocates a Unicode devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEA pANSIDevMode
//
//  Return:     LPDEVMODEW - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEW AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode)
{
    int iSize;
    LPDEVMODEW pUnicodeDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEW);

    iSize += pANSIDevMode->dmDriverExtra;

    pUnicodeDevMode = GlobalAlloc(GPTR, iSize);

    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the ANSI devmode to the
    //  Unicode devmode.
    //
    ThunkDevModeA2W(pANSIDevMode, pUnicodeDevMode);

    //
    //  Return the pointer.
    //
    return (pUnicodeDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateAnsiDevMode
//
//  Purpose:    Allocates a Ansi devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEW pUnicodeDevMode
//
//  Return:     LPDEVMODEA - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEA AllocateAnsiDevMode(
    LPDEVMODEW pUnicodeDevMode)
{
    int iSize;
    LPDEVMODEA pANSIDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEA);

    iSize += pUnicodeDevMode->dmDriverExtra;

    pANSIDevMode = GlobalAlloc(GPTR, iSize);

    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the Unicode devmode to the
    //  ANSI devmode.
    //
    ThunkDevModeW2A(pUnicodeDevMode, pANSIDevMode);

    //
    //  Return the pointer.
    //
    return (pANSIDevMode);
}

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_PD_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_PD_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PPRINTINFO pPI;

    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if (pPI->pPD && pPI->pPDA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkPrintDlgA2W(pPI);
            }
            else
            {
                ThunkPrintDlgW2A(pPI);
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SetCopiesEditWidth
//
// Adjust the width of the copies edit control using the current
// font and the scroll bar width.  This is necessary to handle the
// the up down control from encroching on the space in the edit
// control when we are in High Contrast (extra large) mode.
//
////////////////////////////////////////////////////////////////////////////

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl)
{
    HDC hDC                 = NULL;
    LONG MaxDigitExtant     = 0;
    LONG EditControlWidth   = 0;
    LONG CurrentWidth       = 0;
    UINT i                  = 0;
    INT aDigitWidth[10];
    WINDOWPLACEMENT WndPl;

    //
    // Acquire the edit controls device context.
    //
    hDC = GetDC( hControl );

    if (hDC)
    {
        //
        // Determine max width of the digit group.
        //
        if (GetCharWidth32( hDC, TEXT('0'), TEXT('9'), aDigitWidth))
        {
            for (i = 0; i < ARRAYSIZE(aDigitWidth); i++)
            {
                if (aDigitWidth[i] > MaxDigitExtant)
                {
                    MaxDigitExtant = aDigitWidth[i];
                }
            }

            //
            // Get the edit control placement.
            //
            WndPl.length = sizeof( WndPl );

            if (GetWindowPlacement( hControl, &WndPl ))
            {
                //
                // Calculate the edit control current width.
                //
                EditControlWidth = MaxDigitExtant * COPIES_EDIT_SIZE;

                //
                // Calculate the current width of the edit control.
                //
                CurrentWidth = WndPl.rcNormalPosition.right - WndPl.rcNormalPosition.left;

                //
                // Set the new position of the edit control.
                //
                WndPl.rcNormalPosition.left = WndPl.rcNormalPosition.left - (EditControlWidth - CurrentWidth);

                //
                // Place the control.
                //
                SetWindowPlacement( hControl, &WndPl );
            }
        }

        //
        // Release the device context.
        //
        ReleaseDC( hControl, hDC );
    }
}

////////////////////////////////////////////////////////////////////////////
//
// CountDigits
//
// Count how many digits is needed for a specific number
//
////////////////////////////////////////////////////////////////////////////

WORD
CountDigits(
    DWORD dwNumber)
{
    WORD    cDigits = 0;

    if(dwNumber == 0)
    {
        return 1;
    }

    while(dwNumber > 0)
    {
        cDigits++;
        dwNumber /= 10;
    }

    return cDigits++;
}

////////////////////////////////////////////////////////////////////////////
//
// ComboBoxGetLBText
//
// A wrapper function for getting combobox label text.
//
////////////////////////////////////////////////////////////////////////////

HRESULT
ComboBoxGetLBText(
    IN HWND     hComboBox,
    IN DWORD    dwIndex,
    IN LPTSTR   pszText,
    IN DWORD    cchText)
{
    HRESULT hr = S_OK;
    LRESULT lResult = CB_ERR;

    if(!pszText || cchText == 0)
    {
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        //
        // Get the length of the text first
        //
        lResult = SendMessage( hComboBox,
                               CB_GETLBTEXTLEN,
                               (WPARAM)dwIndex,
                               0L );

        if(lResult == CB_ERR)
        {
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        if((DWORD)lResult < cchText)
        {
            //
            // Buffer is large enough, now get the label text
            //
            lResult = SendMessage( hComboBox,
                                   CB_GETLBTEXT,
                                   (WPARAM)dwIndex,
                                   (LPARAM)pszText );
            hr = (lResult != CB_ERR) ? S_OK : E_FAIL;
        }
        else
        {
            //
            // In case of the buffer size less than needed, we try to truncate
            // the label text into the buffer.
            //
            LPTSTR pszBuffer = NULL;

            pszBuffer = (LPTSTR)LocalAlloc(LPTR, (lResult + 1) * sizeof(TCHAR));
            if(pszBuffer)
            {
                //
                // Get the label text
                //
                lResult = SendMessage( hComboBox,
                                       CB_GETLBTEXT,
                                       (WPARAM)dwIndex,
                                       (LPARAM)pszBuffer );

                if(lResult != CB_ERR)
                {
                    hr = StringCchCopy(pszText, cchText, pszBuffer);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            //
            // Cleanup
            //
            LocalFree(pszBuffer);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\prnsetup.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.h

Abstract:

    This module contains the header information for the Win32 print dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

#define PI_PRINTERS_ENUMERATED    0x00000001
#define PI_COLLATE_REQUESTED      0x00000002
#define PI_WPAPER_ENVELOPE        0x00000004     // wPaper is DMPAPER_ENV_x
#define PI_PRINTDLGX_RECURSE      0x00000008     // PrintDlgX calls PrintDlgX

#define PRNPROP (LPCTSTR)         0xA000L

#define MMS_PER_INCH              254            // 25.4 mms/inch

#define INCHES_DEFAULT            1000
#define MMS_DEFAULT               2500

#define COPIES_EDIT_SIZE          4
#define PAGE_EDIT_SIZE            5
#define MARGIN_EDIT_SIZE          6

#define CCHPAPERNAME              64
#define CCHBINNAME                24

#define ROTATE_LEFT               270            // dot-matrix
#define ROTATE_RIGHT              90             // HP PCL

#define MAX_DEV_SECT              512
#define BACKSPACE                 0x08
#define CTRL_X_CUT                0x18
#define CTRL_C_COPY               0x03
#define CTRL_V_PASTE              0x16

#define SIZEOF_DEVICE_INFO        32

#define MAX_PRINTERNAME           (MAX_PATH * 2)

#define SCRATCHBUF_SIZE           256

#define MIN_DEVMODE_SIZEA         40             // from spooler\inc\splcom.h

#define MAX_COPIES                9999
#define IDC_COPIES_UDARROW        9999

//
//  Constant Declarations for DLG file.
//

#define ID_BOTH_P_PROPERTIES      psh2
#define ID_BOTH_P_NETWORK         psh14
#define ID_BOTH_P_HELP            pshHelp
#define ID_BOTH_S_PRINTER         stc6
#define ID_BOTH_S_STATUS          stc12
#define ID_BOTH_S_TYPE            stc11
#define ID_BOTH_S_WHERE           stc14
#define ID_BOTH_S_COMMENT         stc13

#define ID_PRINT_X_TOFILE         chx1
#define ID_PRINT_X_COLLATE        chx2
#define ID_PRINT_C_QUALITY        cmb1
#define ID_PRINT_C_NAME           cmb4
#define ID_PRINT_E_FROM           edt1
#define ID_PRINT_E_TO             edt2
#define ID_PRINT_E_COPIES         edt3
#define ID_PRINT_G_RANGE          grp1
#define ID_PRINT_G_COPIES         grp2
#define ID_PRINT_G_PRINTER        grp4
#define ID_PRINT_I_COLLATE        ico3
#define ID_PRINT_P_SETUP          psh1
#define ID_PRINT_R_ALL            rad1
#define ID_PRINT_R_SELECTION      rad2
#define ID_PRINT_R_PAGES          rad3
#define ID_PRINT_S_DEFAULT        stc1
#define ID_PRINT_S_FROM           stc2
#define ID_PRINT_S_TO             stc3
#define ID_PRINT_S_QUALITY        stc4
#define ID_PRINT_S_COPIES         stc5

#define ID_SETUP_C_NAME           cmb1
#define ID_SETUP_C_SIZE           cmb2
#define ID_SETUP_C_SOURCE         cmb3
#define ID_SETUP_E_LEFT           edt4
#define ID_SETUP_E_TOP            edt5
#define ID_SETUP_E_RIGHT          edt6
#define ID_SETUP_E_BOTTOM         edt7
#define ID_SETUP_G_ORIENTATION    grp1
#define ID_SETUP_G_PAPER          grp2
#define ID_SETUP_G_DUPLEX         grp3
#define ID_SETUP_G_MARGINS        grp4
#define ID_SETUP_I_ORIENTATION    ico1
#define ID_SETUP_I_DUPLEX         ico2
#define ID_SETUP_P_MORE           psh1
#define ID_SETUP_P_PRINTER        psh3
#define ID_SETUP_R_PORTRAIT       rad1
#define ID_SETUP_R_LANDSCAPE      rad2
#define ID_SETUP_R_DEFAULT        rad3
#define ID_SETUP_R_SPECIFIC       rad4
#define ID_SETUP_R_NONE           rad5
#define ID_SETUP_R_LONG           rad6
#define ID_SETUP_R_SHORT          rad7
#define ID_SETUP_S_DEFAULT        stc1
#define ID_SETUP_S_SIZE           stc2
#define ID_SETUP_S_SOURCE         stc3
#define ID_SETUP_S_LEFT           stc15
#define ID_SETUP_S_RIGHT          stc16
#define ID_SETUP_S_TOP            stc17
#define ID_SETUP_S_BOTTOM         stc18
#define ID_SETUP_W_SAMPLE         rct1
#define ID_SETUP_W_SHADOWRIGHT    rct2
#define ID_SETUP_W_SHADOWBOTTOM   rct3




//
//  Typedef Declarations.
//

typedef struct {
    UINT            ApiType;
    LPPRINTDLG      pPD;
    LPPAGESETUPDLG  pPSD;
    DWORD           cPrinters;
    PPRINTER_INFO_2 pPrinters;
    PPRINTER_INFO_2 pCurPrinter;
    HANDLE          hCurPrinter;
    DWORD           Status;
    TCHAR           szDefaultPrinter[MAX_PRINTERNAME];
    WORD            wPaper;
    DWORD           dwRotation;
    UINT            uiOrientationID;
    POINT           PtPaperSizeMMs;
    RECT            RtMinMarginMMs;
    RECT            RtMarginMMs;
    POINT           PtMargins;
    RECT            RtSampleXYWH;
    BOOL            bKillFocus;
    DWORD           ProcessVersion;
    LPPRINTDLGA     pPDA;
    LPBOOL          pAllocInfo;
    BOOL            bUseExtDeviceMode;
    BOOL            fPrintTemplateAlloc;
    BOOL            fSetupTemplateAlloc;
    UINT            NestCtr;
} PRINTINFO, *PPRINTINFO;




//
//  Global Variables.
//

static TCHAR  szTextWindows[]     = TEXT("Windows");
static TCHAR  szTextDevices[]     = TEXT("devices");
static TCHAR  szTextDevice[]      = TEXT("device");
static TCHAR  szTextNull[]        = TEXT("");
static TCHAR  szFilePort[]        = TEXT("FILE:");
static TCHAR  szDriver[]          = TEXT("winspool");

LPPRINTHOOKPROC glpfnPrintHook = NULL;
LPSETUPHOOKPROC glpfnSetupHook = NULL;

WNDPROC lpEditNumOnlyProc = NULL;
WNDPROC lpEditMarginProc = NULL;
WNDPROC lpStaticProc = NULL;

HKEY hPrinterKey;
TCHAR *szRegistryPrinter = TEXT("Printers");
TCHAR *szRegistryDefaultValueName = TEXT("Default");

static BOOL   bAllIconsLoaded = FALSE;         // if all icons/images loaded

static HANDLE hIconCollate = NULL;             // Image
static HANDLE hIconNoCollate = NULL;           // Image

static HICON  hIconPortrait = NULL;            // Icon
static HICON  hIconLandscape = NULL;           // Icon
static HICON  hIconPDuplexNone = NULL;         // Icon
static HICON  hIconLDuplexNone = NULL;         // Icon
static HICON  hIconPDuplexTumble = NULL;       // Icon
static HICON  hIconLDuplexTumble = NULL;       // Icon
static HICON  hIconPDuplexNoTumble = NULL;     // Icon
static HICON  hIconLDuplexNoTumble = NULL;     // Icon
static HICON  hIconPSStampP = NULL;            // Icon
static HICON  hIconPSStampL = NULL;            // Icon


static TCHAR  cIntlDecimal = CHAR_NULL;        // decimal separator (.)
static TCHAR  cIntlMeasure[5] = TEXT("");      // measurement designator ("/mm)
static int    cchIntlMeasure = 0;              // # of chars in cIntlMeasure
static TCHAR  szDefaultSrc[SCRATCHBUF_SIZE] = TEXT("");




//
//  Context Help IDs.
//

const static DWORD aPrintHelpIDs[] =             // Context Help IDs
{
    // for Print dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb4,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    chx1,  IDH_PRINT_TO_FILE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT32_RANGE,
    rad1,  IDH_PRINT32_RANGE,
    rad2,  IDH_PRINT32_RANGE,
    rad3,  IDH_PRINT32_RANGE,
    stc2,  IDH_PRINT32_RANGE,
    edt1,  IDH_PRINT32_RANGE,
    stc3,  IDH_PRINT32_RANGE,
    edt2,  IDH_PRINT32_RANGE,

    grp2,  NO_HELP,
    edt3,  IDH_PRINT_COPIES,
    ico3,  IDH_PRINT_COLLATE,
    chx2,  IDH_PRINT_COLLATE,

    // for win3.1 Print template

    stc1,  IDH_PRINT_SETUP_DETAILS,

    stc4,  IDH_PRINT_QUALITY,
    cmb1,  IDH_PRINT_QUALITY,

    stc5,  IDH_PRINT_COPIES,

    psh1,  IDH_PRINT_PRINTER_SETUP,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0,     0
};

const static DWORD aPrintSetupHelpIDs[] =        // Context Help IDs
{
    // for PrintSetup dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT_SETUP_ORIENT,
    rad1,  IDH_PRINT_SETUP_ORIENT,
    rad2,  IDH_PRINT_SETUP_ORIENT,

    // for win3.1 PrintSetup template

    grp3,  NO_HELP,
    stc1,  IDH_PRINT_CHOOSE_PRINTER,
    rad3,  IDH_PRINT_CHOOSE_PRINTER,
    rad4,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh1,  IDH_PRINT_PROPERTIES,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    // for winNT PrintSetup template

    grp2,  NO_HELP,                              // grp2 used for win31 help
    ico2,  IDH_PRINT_SETUP_DUPLEX,
    rad5,  IDH_PRINT_SETUP_DUPLEX,
    rad6,  IDH_PRINT_SETUP_DUPLEX,
    rad7,  IDH_PRINT_SETUP_DUPLEX,

    0,     0
};

const static DWORD aPageSetupHelpIDs[] =         // Context Help IDs
{
    rct1,  IDH_PAGE_SAMPLE,
    rct2,  IDH_PAGE_SAMPLE,
    rct3,  IDH_PAGE_SAMPLE,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    rad1,  IDH_PAGE_ORIENTATION,
    rad2,  IDH_PAGE_ORIENTATION,

    grp4,  NO_HELP,
    stc15, IDH_PAGE_MARGINS,
    edt4,  IDH_PAGE_MARGINS,
    stc16, IDH_PAGE_MARGINS,
    edt6,  IDH_PAGE_MARGINS,
    stc17, IDH_PAGE_MARGINS,
    edt5,  IDH_PAGE_MARGINS,
    stc18, IDH_PAGE_MARGINS,
    edt7,  IDH_PAGE_MARGINS,

    psh3,  IDH_PAGE_PRINTER,

    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0, 0
};




//
//  Macro Definitions.
//

#define IS_KEY_PRESSED(key)       ( GetKeyState(key) & 0x8000 )

#define ISDIGIT(c)                ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
//  SetField is used to modify new-for-ver-4.0 DEVMODE fields.
//  We don't have to worry about the GET case, because we always check for
//  the existance-of-field bit before looking at the field.
//
#define SetField(_pdm, _fld, _val)     \
        ((_pdm)->dmSpecVersion >= 0x0400 ? (((_pdm)->_fld = (_val)), TRUE) : FALSE)




#ifdef __cplusplus
extern "C" {
#endif



//
//  Function Prototypes.
//

BOOL
PrintDlgX(
    PPRINTINFO pPI);

BOOL
PageSetupDlgX(
    PPRINTINFO pPI);

BOOL
PrintLoadIcons();

int
PrintDisplayPrintDlg(
    PPRINTINFO pPI);

int
PrintDisplaySetupDlg(
    PPRINTINFO pPI);

BOOL_PTR CALLBACK
PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR CALLBACK
PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
PrintEditNumberOnlyProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

HANDLE
PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType);

VOID
PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize);

BOOL
PrintReturnDefault(
    PPRINTINFO pPI);

BOOL
PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

DWORD
PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

DWORD
PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

VOID
PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent);

BOOL
PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id);

VOID
PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI);

VOID
PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue);

VOID
PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample);

BOOL
PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD);

BOOL
PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner);

VOID
PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality);

VOID
PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

VOID
PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI);

BOOL
PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD);

PPRINTER_INFO_2
PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName);

VOID
PrintGetExtDeviceMode(
    HWND hDlg,
    PPRINTINFO pPI);

BOOL
PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters);

VOID
PrintBuildDevNames(
    PPRINTINFO pPI);

HANDLE
PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode);

VOID
PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM);

VOID
PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis);

VOID
PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM);

VOID
PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad);

VOID
PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2);

VOID
PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...);

VOID
PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

BOOL
PrintClosePrinters(
    PPRINTINFO pPI);

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl);

VOID
UpdateSpoolerInfo(
    PPRINTINFO pPI);

PPRINTER_INFO_2
PrintGetPrinterInfo2(
    HANDLE hPrinter);

int
ConvertStringToInteger(
    LPCTSTR pSrc);

VOID
FreePrinterArray(
    PPRINTINFO pPI);

VOID
TermPrint(void);

VOID
TransferPSD2PD(
    PPRINTINFO pPI);

VOID
TransferPD2PSD(
    PPRINTINFO pPI);

VOID
TransferPSD2PDA(
    PPRINTINFO pPI);

VOID
TransferPDA2PSD(
    PPRINTINFO pPI);

BOOL
ThunkPageSetupDlg(
    PPRINTINFO pPI,
    LPPAGESETUPDLGA pPSDA);

VOID
FreeThunkPageSetupDlg(
    PPRINTINFO pPI);

BOOL
ThunkPrintDlg(
    PPRINTINFO pPI,
    LPPRINTDLGA pPDA);

VOID
FreeThunkPrintDlg(
    PPRINTINFO pPI);

VOID
ThunkPrintDlgA2W(
    PPRINTINFO pPI);

VOID
ThunkPrintDlgW2A(
    PPRINTINFO pPI);

VOID
ThunkDevModeA2W(
    LPDEVMODEA pDMA,
    LPDEVMODEW pDMW);

VOID
ThunkDevModeW2A(
    LPDEVMODEW pDMW,
    LPDEVMODEA pDMA);

LPDEVMODEW
AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode);

LPDEVMODEA
AllocateAnsiDevMode(
    LPDEVMODEW pUnicodeDevMode);

WORD
CountDigits(
    DWORD dwNumber);

HRESULT
ComboBoxGetLBText(
    IN HWND     hComboBox,
    IN DWORD    dwIndex,
    IN LPTSTR   pszText,
    IN DWORD    cchText);

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(CCSHELL_DIR)\common.inc

INCLUDES = $(CCSHELL_DIR)\comdlg32;$(INCLUDES);$(PRINTSCAN_INC_PATH);$(NET_INC_PATH)

# need to wait on ..\ntcpp\$O\srccpp.lib
SYNCHRONIZE_DRAIN = 1

TARGETNAME    = comdlg32
TARGETPATH    = obj
TARGETTYPE    = DYNLINK

#VERIFY_LC     = 1
LC_PATH       = $(PROJECT_ROOT)\lcinf

PASS1_PUBLISH={$(O)\comdlg32.lib=$(SDK_LIB_PATH)\comdlg32.lib}

TARGETLIBS = $(SHELL_LIB_PATH)\shlwapip.lib             \
             $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib    \
             $(LIBRARY_PLATFORM_PATH)\*\user32.lib      \
             $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib       \
             $(SDK_LIB_PATH)\advapi32.lib               \
             $(SDK_LIB_PATH)\ole32.lib                  \
             $(SDK_LIB_PATH)\version.lib                \
             $(SDK_LIB_PATH)\imm32.lib                  \
             $(SHELL_LIB_PATH)\comctlp.lib              \
             $(SDK_LIB_PATH)\shell32.lib                \
             $(SHELL_LIB_PATH)\shell32p.lib             \
             $(NET_LIB_PATH)\mprp.lib                   \
             $(SDK_LIB_PATH)\winspool.lib               \
             $(SDK_LIB_PATH)\uuid.lib                   \
             $(SDK_LIB_PATH)\uxtheme.lib                \
             $(CCSHELL_DIR)\lib\$(O)\shguidp.lib        \
             $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib        \
             $(CCSHELL_DIR)\lib\$(O)\stock.lib

DELAYLOAD = winspool.drv;UxTheme.dll;ole32.dll;version.dll;imm32.dll;mpr.dll
DLOAD_ERROR_HANDLER = kernel32

LINKLIBS = ..\ntcpp\$O\srccpp.lib

DLLDEF   = $(O)\comdlg32.def

DLLENTRY = LibMain

SOURCES = ..\comdlg32.rc  \
          ..\color.c      \
          ..\color2.c     \
          ..\data.c       \
          ..\dlgs.c       \
          ..\fileopen.c   \
          ..\find.c       \
          ..\font.c       \
          ..\init.c       \
          ..\parse.c      \
          ..\prnsetup.c   \
          ..\debug.c

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\util.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module implements utility functions for the common dialog.

Revision History:
    02-20-98          arulk                 created

--*/
#ifndef _UTIL_H_
#define _UTIL_H_

#include <shlobjp.h>


////////////////////////////////////////////////////////////////////////////
//  Autocomplete 
//
////////////////////////////////////////////////////////////////////////////
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags);

////////////////////////////////////////////////////////////////////////////
//  Common Dilaog Restrictions
//
////////////////////////////////////////////////////////////////////////////
typedef enum
{
    REST_NULL                       = 0x00000000,
    REST_NOBACKBUTTON               = 0x00000001,
    REST_NOFILEMRU                  = 0x00000002,
    REST_NOPLACESBAR                = 0x00000003,
}COMMDLG_RESTRICTIONS;

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest);
BOOL ILIsFTP(LPCITEMIDLIST pidl);

////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
////////////////////////////////////////////////////////////////////////////

#define CDBindToObject          SHBindToObject
#define CDBindToIDListParent    SHBindToParent
#define CDGetNameAndFlags       SHGetNameAndFlags
#define CDGetAttributesOf       SHGetAttributesOf
#define CDGetUIObjectFromFullPIDL SHGetUIObjectFromFullPIDL

//CDGetAppCompatFlags
#define CDACF_MATHCAD             0x00000001
#define CDACF_NT40TOOLBAR         0x00000002
#define CDACF_FILETITLE           0x00000004

EXTERN_C DWORD CDGetAppCompatFlags();
EXTERN_C HRSRC FindResourceExFallback(HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage);

EXTERN_C HRESULT StringCopyOverlap(WCHAR *szDest, WCHAR *szSource);
EXTERN_C HRESULT StringCchCopyOverlap(WCHAR *szDest, size_t cchDest, WCHAR *szSource);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comdlg32\util.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.cpp

Abstract:

    This module implements utility functions for the common dialog.

Author:

    Arul Kumaravel              (arulk@microsoft.com)

History:

    Mar-07-2001 - Lazar Ivanov (LazarI) 
        reimplemented ThunkDevNamesW2A & ThunkDevNamesA2W

--*/

// precompiled headers
#include "precomp.h"
#pragma hdrstop

#include "cdids.h"
#include "fileopen.h"
#include "filenew.h"
#include "util.h"

// crtfree.h is located in shell\inc and it defines new and delete
// operators to do LocalAlloc and LocalFree, so you don't have to
// link to MSVCRT in order to get those. i tried to remove this code
// and link to MSVCRT, but there are some ugly written code here 
// which relies on the new operator to zero initialize the returned
// memory block so the class don't bother to initialize its members
// in the constructor. as i said this is quite ugly, but nothing i can
// do about this at the moment.
//
// LazarI - 2/21/2001
//
#define DECL_CRTFREE
#include <crtfree.h>

#ifndef ASSERT
#define ASSERT Assert
#endif


#define USE_AUTOCOMPETE_DEFAULT         TRUE
#define SZ_REGKEY_USEAUTOCOMPLETE       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_FILEDLGAUTOCOMPLETE TEXT("AutoComplete In File Dialog")
#define BOOL_NOT_SET                        0x00000005
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")

/****************************************************\
    FUNCTION: AutoComplete

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.
\****************************************************/
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    IUnknown * punkACLISF;
    static BOOL fUseAutoComplete = -10; // Not inited.
    
    if (-10 == fUseAutoComplete)
        fUseAutoComplete = (SHRegGetBoolUSValue(SZ_REGKEY_USEAUTOCOMPLETE, SZ_REGVALUE_FILEDLGAUTOCOMPLETE, FALSE, USE_AUTOCOMPETE_DEFAULT));

    // WARNING: If you want to disable AutoComplete by default, 
    //          turn USE_AUTOCOMPETE_DEFAULT to FALSE
    if (fUseAutoComplete)
    {
        Assert(!dwFlags);	// Not yet used.
        hr = SHCoCreateInstance(NULL, &CLSID_ACListISF, NULL, IID_PPV_ARG(IUnknown, &punkACLISF));
        if (SUCCEEDED(hr))
        {
            IAutoComplete2 * pac;
            // Create the AutoComplete Object
            hr = SHCoCreateInstance(NULL, &CLSID_AutoComplete, NULL, IID_PPV_ARG(IAutoComplete2, &pac));
            if (SUCCEEDED(hr))
            {
                DWORD dwOptions = 0;

                hr = pac->Init(hwndEdit, punkACLISF, NULL, NULL);

                // Set the autocomplete options
                if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
                {
                    dwOptions |= ACO_AUTOAPPEND;
                }

                if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
                {
                    dwOptions |= ACO_AUTOSUGGEST;
                }

                // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
                // operating systems that use AutoComplete have traditionally used the TAB key to
                // iterate thru the AutoComplete possibilities.  We need to default to disable the
                // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
                // turn it on 
                static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
                if (BOOL_NOT_SET == s_fAlwaysUseTab)
                    s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_USEAUTOCOMPLETE, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
                    
                if (s_fAlwaysUseTab)
                    dwOptions |= ACO_USETAB;
                    
                pac->SetOptions(dwOptions);

                pac->Release();
            }

            if (ppcwd)
            {
                punkACLISF->QueryInterface(IID_PPV_ARG(ICurrentWorkingDirectory, ppcwd));
            }

            punkACLISF->Release();
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// 
//  Common Dialog Administrator Restrictions
//
////////////////////////////////////////////////////////////////////////////

const SHRESTRICTIONITEMS c_rgRestItems[] =
{
    {REST_NOBACKBUTTON,            L"Comdlg32", L"NoBackButton"},
    {REST_NOFILEMRU ,              L"Comdlg32", L"NoFileMru"},
    {REST_NOPLACESBAR,             L"Comdlg32", L"NoPlacesBar"},
    {0, NULL, NULL},
};

#define NUMRESTRICTIONS  ARRAYSIZE(c_rgRestItems)


DWORD g_rgRestItemValues[NUMRESTRICTIONS - 1 ] = { -1 };

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest)
{
    static BOOL bFirstTime = TRUE;

    if (bFirstTime)
    {
        memset((LPBYTE)g_rgRestItemValues, (BYTE)-1, sizeof(g_rgRestItemValues));
        bFirstTime = FALSE;
    }
    return SHRestrictionLookup(rest, NULL, c_rgRestItems, g_rgRestItemValues);
}

#define MODULE_NAME_SIZE    128
#define MODULE_VERSION_SIZE  15

typedef struct tagAPPCOMPAT
{
    LPCTSTR pszModule;
    LPCTSTR pszVersion;
    DWORD  dwFlags;
} APPCOMPAT, FAR* LPAPPCOMPAT;
    
DWORD CDGetAppCompatFlags()
{
    static BOOL  bInitialized = FALSE;
    static DWORD dwCachedFlags = 0;
    static const APPCOMPAT aAppCompat[] = 
    {   //Mathcad
        {TEXT("MCAD.EXE"), TEXT("6.00b"), CDACF_MATHCAD},
        //Picture Publisher
        {TEXT("PP70.EXE"),NULL, CDACF_NT40TOOLBAR},
        {TEXT("PP80.EXE"),NULL, CDACF_NT40TOOLBAR},
        //Code Wright
        {TEXT("CW32.exe"),TEXT("5.1"), CDACF_NT40TOOLBAR},
        //Designer.exe
        {TEXT("ds70.exe"),NULL, CDACF_FILETITLE}
    };
    
    if (!bInitialized)
    {    
        TCHAR  szModulePath[MODULE_NAME_SIZE];
        TCHAR* pszModuleName;
        DWORD  dwHandle;
        int i;

        GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath));
        pszModuleName = PathFindFileName(szModulePath);

        if (pszModuleName)
        {
            for (i=0; i < ARRAYSIZE(aAppCompat); i++)
            {
                if (lstrcmpi(aAppCompat[i].pszModule, pszModuleName) == 0)
                {
                    if (aAppCompat[i].pszVersion == NULL)
                    {
                        dwCachedFlags = aAppCompat[i].dwFlags;
                    }
                    else
                    {
                        CHAR  chBuffer[3072]; // hopefully this is enough... lotus smart center needs 3000
                        TCHAR* pszVersion = NULL;
                        UINT  cb;

                        // get module version here!
                        cb = GetFileVersionInfoSize(szModulePath, &dwHandle); 
                        if (cb <= ARRAYSIZE(chBuffer) &&
                            GetFileVersionInfo(szModulePath, dwHandle, ARRAYSIZE(chBuffer), (LPVOID)chBuffer) &&
                            VerQueryValue((LPVOID)chBuffer, TEXT("\\StringFileInfo\\040904E4\\ProductVersion"), (void **) &pszVersion, &cb))
                        {   
                            DebugMsg(0x0004, TEXT("product: %s\n version: %s"), pszModuleName, pszVersion);
                            if (lstrcmpi(pszVersion, aAppCompat[i].pszVersion) == 0)
                            {
                                dwCachedFlags = aAppCompat[i].dwFlags;
                                break;
                            }
                        }
                    }
                }
            }
        }
        bInitialized = TRUE;
    }
    
    return dwCachedFlags; 
}


BOOL ILIsFTP(LPCITEMIDLIST pidl)
{
    IShellFolder * psf;
    BOOL fIsFTPFolder = FALSE;

    if (SUCCEEDED(CDBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf))))
    {
        CLSID clsid;

        if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) &&
            (IsEqualIID(clsid, CLSID_FtpFolder)))
        {
            fIsFTPFolder = TRUE;
        }

        psf->Release();
    }

    return fIsFTPFolder;
}


#ifdef __cplusplus
extern "C" {
#endif

// this is weak.
// a long time ago somebody changed all the FindResources to call FindResourceEx, specifying
// a language.  thatd be cool except FindResource already has logic to get the right language.
// whatever was busted should have probably been fixed some other way.
// not only that but it's broken because MUI needs to fall back to US if it can't get the resource
// from the MUI language-specific files.
// thus force a fallback to US.  really everything should be rewritten to be normal like every other
// DLL but there's a lot of weird TLS stuff that would break and its risky for this late in XP.
HRSRC FindResourceExFallback(HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage)
{
    HRSRC hrsrc = FindResourceEx(hModule, lpType, lpName, wLanguage);
    if (!hrsrc)
    {
        LANGID langid = GetSystemDefaultUILanguage();
        if (langid && (langid != wLanguage))
        {
            hrsrc = FindResourceEx(hModule, lpType, lpName, langid);
        }
    }
    return hrsrc;
}

// Win32Error2HRESULT: converts Win32 error to HRESULT
inline HRESULT Win32Error2HRESULT(DWORD dwError = GetLastError())
{
    return (ERROR_SUCCESS == dwError) ? E_FAIL : HRESULT_FROM_WIN32(dwError);
}

/*++

Routine Name:

    ThunkDevNamesA2W

Routine Description:

    Converts ANSI DEVNAMES structure to UNICODE
    on failure we don't release *phDevNamesW

Arguments:

    hDevNamesA  - [in]   handle to ANSI DEVNAMES
    phDevNamesW - [in, out]  handle to UNICODE DEVNAMES

Return Value:

    S_OK if succeded and OLE error otherwise

History:

    Lazar Ivanov (LazarI), Mar-07-2001 - created.

--*/

HRESULT
ThunkDevNamesA2W(
    IN      HGLOBAL hDevNamesA,
    IN OUT  HGLOBAL *phDevNamesW
    )
{
    HRESULT hr = E_FAIL;
    if (hDevNamesA && phDevNamesW)
    {
        LPDEVNAMES pDNA = (LPDEVNAMES )GlobalLock(hDevNamesA);
        if (pDNA)
        {
            // calculate the input string pointers
            LPSTR pszDriver = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDriverOffset;
            LPSTR pszDevice = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDeviceOffset;
            LPSTR pszOutput = reinterpret_cast<LPSTR>(pDNA) + pDNA->wOutputOffset;

            // calculate the lengths of the ANSI strings
            SIZE_T iDriverLenW = MultiByteToWideChar(CP_ACP, 0, pszDriver, -1, NULL, 0);
            SIZE_T iDeviceLenW = MultiByteToWideChar(CP_ACP, 0, pszDevice, -1, NULL, 0);
            SIZE_T iOutputLenW = MultiByteToWideChar(CP_ACP, 0, pszOutput, -1, NULL, 0);

            // calculate the output buffer length
            SIZE_T iBytesTotal = sizeof(DEVNAMES) + sizeof(WCHAR) * 
                ((iDriverLenW + 1) + (iDeviceLenW + 1) + (iOutputLenW + 1) + DN_PADDINGCHARS);

            HGLOBAL hDevNamesW = (*phDevNamesW) ? 
                                    GlobalReAlloc(*phDevNamesW, iBytesTotal, GHND) :
                                    GlobalAlloc(GHND, iBytesTotal);

            if (hDevNamesW)
            {
                // thunk DEVNAMES...
                LPDEVNAMES pDNW = (LPDEVNAMES )GlobalLock(hDevNamesW);
                if (pDNW)
                {
                    // calculate the offsets 
                    // note: the offsets are in chars not bytes!!
                    pDNW->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
                    pDNW->wDeviceOffset = pDNW->wDriverOffset + iDriverLenW + 1;
                    pDNW->wOutputOffset = pDNW->wDeviceOffset + iDeviceLenW + 1;
                    pDNW->wDefault = pDNA->wDefault;

                    // calculate the output string pointers
                    LPWSTR pwszDriver = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDriverOffset;
                    LPWSTR pwszDevice = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDeviceOffset;
                    LPWSTR pwszOutput = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wOutputOffset;

                    // convert from ansi to uniciode
                    MultiByteToWideChar(CP_ACP, 0, pszDriver, -1, pwszDriver, iDriverLenW + 1);
                    MultiByteToWideChar(CP_ACP, 0, pszDevice, -1, pwszDevice, iDeviceLenW + 1);
                    MultiByteToWideChar(CP_ACP, 0, pszOutput, -1, pwszOutput, iOutputLenW + 1);

                    // unlock hDevNamesW
                    GlobalUnlock(hDevNamesW);

                    // declare success
                    *phDevNamesW = hDevNamesW;
                    hr = S_OK;
                }
                else
                {
                    // GlobalLock failed
                    hr = Win32Error2HRESULT(GetLastError());
                    GlobalFree(hDevNamesW);
                }
            }
            else
            {
                // GlobalAlloc failed
                hr = E_OUTOFMEMORY;
            }

            // unlock hDevNamesA
            GlobalUnlock(hDevNamesA);
        }
        else
        {
            // GlobalLock failed
            hr = Win32Error2HRESULT(GetLastError());
        }
    }
    else
    {
        // some of the arguments are invalid (NULL)
        hr = E_INVALIDARG;
    }
    return hr;
}

/*++

Routine Name:

    ThunkDevNamesW2A

Routine Description:

    Converts UNICODE DEVNAMES structure to ANSI
    on failure we don't release *phDevNamesA

Arguments:

    hDevNamesW  - [in]   handle to UNICODE DEVNAMES
    phDevNamesA - [in, out]  handle to ANSI DEVNAMES

Return Value:

    S_OK if succeded and OLE error otherwise

History:

    Lazar Ivanov (LazarI), Mar-07-2001 - created.

--*/
HRESULT
ThunkDevNamesW2A(
    IN      HGLOBAL hDevNamesW,
    IN OUT  HGLOBAL *phDevNamesA
    )
{
    HRESULT hr = E_FAIL;
    if (hDevNamesW && phDevNamesA)
    {
        LPDEVNAMES pDNW = (LPDEVNAMES)GlobalLock(hDevNamesW);
        if (pDNW)
        {
            // calculate the input string pointers
            LPWSTR pwszDriver = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDriverOffset;
            LPWSTR pwszDevice = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wDeviceOffset;
            LPWSTR pwszOutput = reinterpret_cast<LPWSTR>(pDNW) + pDNW->wOutputOffset;

            // calculate the lengths of the ANSI strings
            SIZE_T iDriverLenA = WideCharToMultiByte(CP_ACP, 0, pwszDriver, -1, NULL, 0, NULL, NULL);
            SIZE_T iDeviceLenA = WideCharToMultiByte(CP_ACP, 0, pwszDevice, -1, NULL, 0, NULL, NULL);
            SIZE_T iOutputLenA = WideCharToMultiByte(CP_ACP, 0, pwszOutput, -1, NULL, 0, NULL, NULL);

            // calculate the output buffer length
            SIZE_T iBytesTotal = sizeof(DEVNAMES) + sizeof(CHAR) * 
                ((iDriverLenA + 1) + (iDeviceLenA + 1) + (iOutputLenA + 1) + DN_PADDINGCHARS);

            HGLOBAL hDevNamesA = (*phDevNamesA) ? 
                                    GlobalReAlloc(*phDevNamesA, iBytesTotal, GHND) :
                                    GlobalAlloc(GHND, iBytesTotal);
            if (hDevNamesA)
            {
                // thunk DEVNAMES...
                LPDEVNAMES pDNA = (LPDEVNAMES )GlobalLock(hDevNamesA);
                if (pDNA)
                {
                    // calculate the offsets 
                    // note: the offsets are in chars not bytes!!
                    pDNA->wDriverOffset = sizeof(DEVNAMES) / sizeof(CHAR);
                    pDNA->wDeviceOffset = pDNA->wDriverOffset + iDriverLenA + 1;
                    pDNA->wOutputOffset = pDNA->wDeviceOffset + iDeviceLenA + 1;
                    pDNA->wDefault = pDNW->wDefault;

                    // calculate the output string pointers
                    LPSTR pszDriver = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDriverOffset;
                    LPSTR pszDevice = reinterpret_cast<LPSTR>(pDNA) + pDNA->wDeviceOffset;
                    LPSTR pszOutput = reinterpret_cast<LPSTR>(pDNA) + pDNA->wOutputOffset;

                    // convert from uniciode to ansi
                    WideCharToMultiByte(CP_ACP, 0, pwszDriver, -1, pszDriver, iDriverLenA + 1, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, pwszDevice, -1, pszDevice, iDeviceLenA + 1, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, pwszOutput, -1, pszOutput, iOutputLenA + 1, NULL, NULL);

                    // unlock hDevNamesA
                    GlobalUnlock(hDevNamesA);

                    // declare success
                    *phDevNamesA = hDevNamesA;
                    hr = S_OK;
                }
                else
                {
                    // GlobalLock failed
                    hr = Win32Error2HRESULT(GetLastError());
                    GlobalFree(hDevNamesW);
                }
            }
            else
            {
                // GlobalAlloc failed
                hr = E_OUTOFMEMORY;
            }

            // unlock hDevNamesW
            GlobalUnlock(hDevNamesW);
        }
        else
        {
            // GlobalLock failed
            hr = Win32Error2HRESULT(GetLastError());
        }
    }
    else
    {
        // some of the arguments are invalid (NULL)
        hr = E_INVALIDARG;
    }
    return hr;
}

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shell32 to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "priv.h"       // Don't use precompiled header here
#include "appwiz.h"

#define c_szARPJob  TEXT("ARP Job")


// Return: hIOPort for the CompletionPort
HANDLE _SetJobCompletionPort(HANDLE hJob)
{
    HANDLE hRet = NULL;

    HANDLE hIOPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, (ULONG_PTR)hJob, 1 );
    if ( hIOPort != NULL )
    {
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT CompletionPort;
        CompletionPort.CompletionKey = hJob ;

        CompletionPort.CompletionPort = hIOPort;

        if (SetInformationJobObject( hJob,JobObjectAssociateCompletionPortInformation,
                                     &CompletionPort, sizeof(CompletionPort) ) )
        {   
            hRet = hIOPort;
        }
    }
    return hRet;
}


STDAPI_(DWORD) WaitingThreadProc(void *pv)
{
    HANDLE hIOPort = (HANDLE)pv;

    // RIP(hIOPort);
    
    DWORD dwCompletionCode;
    PVOID pCompletionKey;
    LPOVERLAPPED lpOverlapped;
    
    while (TRUE)
    {
        // Wait for all the processes to finish...
        if (!GetQueuedCompletionStatus( hIOPort, &dwCompletionCode, (PULONG_PTR) &pCompletionKey,
                                        &lpOverlapped, INFINITE ) || (dwCompletionCode == JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO))
        {
            break;
        }
    }
    
    return 0;
}


/*-------------------------------------------------------------------------
Purpose: Creates a process and waits for it to finish
*/
STDAPI_(BOOL) NT5_CreateAndWaitForProcess(LPTSTR pszExeName)
{
    PROCESS_INFORMATION pi = {0};
    STARTUPINFO si = {0};
    BOOL fWorked = FALSE;
#ifdef WX86
    DWORD  cchArch;
    WCHAR  szArchValue[32];
#endif    

    // CreateJobObject does not follow the win32 convention because even if the function succeeds, it can
    // still SetLastError to ERROR_ALREADY_EXISTS
    HANDLE hJob = CreateJobObject(NULL, c_szARPJob);
    
    if (hJob) 
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            HANDLE hIOPort = _SetJobCompletionPort(hJob);
            if (hIOPort)
            {
                DWORD dwCreationFlags = 0;
                // Create the install process
                si.cb = sizeof(si);

    #ifdef WX86
                if (bWx86Enabled && bForceX86Env) {
                    cchArch = GetEnvironmentVariableW(ProcArchName,
                        szArchValue,
                        sizeof(szArchValue)
                        );

                    if (!cchArch || cchArch >= sizeof(szArchValue)) {
                        szArchValue[0]=L'\0';
                    }

                    SetEnvironmentVariableW(ProcArchName, L"x86");
                }
    #endif

                dwCreationFlags = CREATE_SUSPENDED | CREATE_SEPARATE_WOW_VDM;
            
                // Create the process
                fWorked = CreateProcess(NULL, pszExeName, NULL, NULL, FALSE, dwCreationFlags, NULL, NULL, &si, &pi);
                if (fWorked)
                {
                    HANDLE hWait = NULL;
            
                    if (AssignProcessToJobObject(hJob, pi.hProcess))
                    {   
                        hWait = CreateThread(NULL, 0, WaitingThreadProc, (LPVOID)hIOPort, 0, NULL);
                    }

                    if (hWait == NULL)
                    {
                        // We might get here if the call to AssignProcessToJobObject has failed because
                        // the process already has a job assigned to it, or because we couldn't create the
                        // waiting thread. Try a more direct approach by just watching the process handle.
                        // This method won't catch spawned processes, but it is better than nothing.

                        hWait = pi.hProcess;
                    }
                    else
                    {
                        // we are not waiting on the process handle, so we are done /w it.
                        CloseHandle(pi.hProcess);
                    }

                    ResumeThread(pi.hThread);
                    CloseHandle(pi.hThread);

    #ifdef WX86
                    if (bWx86Enabled && bForceX86Env)
                    {
                        SetEnvironmentVariableW(ProcArchName, szArchValue);
                    }
    #endif

                    // we should have a valid handle at this point for sure
                    ASSERT(hWait && (hWait != INVALID_HANDLE_VALUE));

                    SHProcessSentMessagesUntilEvent(NULL, hWait, INFINITE);
                    CloseHandle(hWait);
                }

                CloseHandle(hIOPort);
            }
        }

        CloseHandle(hJob);
    }

    return fWorked;
}





#define PFN_FIRSTTIME   ((void *)-1)


// VerSetConditionMask
typedef ULONGLONG (WINAPI * PFNVERSETCONDITIONMASK)(ULONGLONG conditionMask, DWORD dwTypeMask, BYTE condition); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's VerSetConditionMask
*/
ULONGLONG NT5_VerSetConditionMask(ULONGLONG conditionMask, DWORD dwTypeMask, BYTE condition)
{
    static PFNVERSETCONDITIONMASK s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle KERNEL32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("KERNEL32.DLL");

        if (hinst)
            s_pfn = (PFNVERSETCONDITIONMASK)GetProcAddress(hinst, "VerSetConditionMask");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(conditionMask, dwTypeMask, condition);

    return 0;       // failure
}



typedef HRESULT (__stdcall * PFNRELEASEAPPCATEGORYINFOLIST)(APPCATEGORYINFOLIST *pAppCategoryList);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's ReleaseAppCategoryInfoList
*/
HRESULT NT5_ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryList)
{
    static PFNRELEASEAPPCATEGORYINFOLIST s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("APPMGMTS.DLL");

        if (hinst)
            s_pfn = (PFNRELEASEAPPCATEGORYINFOLIST)GetProcAddress(hinst, "ReleaseAppCategoryInfoList");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pAppCategoryList);

    return E_NOTIMPL;    
}

/*----------------------------------------------------------
Purpose: Thunk for NT 5's AllowSetForegroundWindow
*/
typedef UINT (WINAPI * PFNALLOWSFW) (DWORD dwPRocessID);  

BOOL NT5_AllowSetForegroundWindow(DWORD dwProcessID)
{
    static PFNALLOWSFW s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("USER32.DLL");

        if (hinst)
        {
            s_pfn = (PFNALLOWSFW)GetProcAddress(hinst, "AllowSetForegroundWindow");
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(dwProcessID);

    return FALSE;
}




// InstallApplication
typedef DWORD (WINAPI * PFNINSTALLAPP)(PINSTALLDATA pInstallInfo); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's InstallApplication
*/
DWORD NT5_InstallApplication(PINSTALLDATA pInstallInfo)
{
    static PFNINSTALLAPP s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNINSTALLAPP)GetProcAddress(hinst, "InstallApplication");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pInstallInfo);

    return ERROR_INVALID_FUNCTION;       // failure
}


// UninstallApplication
typedef DWORD (WINAPI * PFNUNINSTALLAPP)(WCHAR * pszProductCode, DWORD dwStatus); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's UninstallApplication
*/
DWORD NT5_UninstallApplication(WCHAR * pszProductCode, DWORD dwStatus)
{
    static PFNUNINSTALLAPP s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNUNINSTALLAPP)GetProcAddress(hinst, "UninstallApplication");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszProductCode, dwStatus);

    return ERROR_INVALID_FUNCTION;       // failure
}


// GetManagedApplications
typedef DWORD (WINAPI * PFNGETAPPS)(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's GetManagedApplications
*/
DWORD NT5_GetManagedApplications(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps)
{
    static PFNGETAPPS s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        // It is safe to GetModuleHandle ADVAPI32 because we implicitly link
        // to it, so it is guaranteed to be loaded in every thread.
        
        HINSTANCE hinst = GetModuleHandleA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETAPPS)GetProcAddress(hinst, "GetManagedApplications");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pCategory, dwQueryFlags, dwInfoLevel, pdwApps, prgManagedApps);

    return ERROR_INVALID_FUNCTION;       // failure
}


typedef DWORD (__stdcall * PFNGETMANAGEDAPPLICATIONCATEGORIES)(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's CsGetAppCategories
*/
DWORD NT5_GetManagedApplicationCategories(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList)
{
    static PFNGETMANAGEDAPPLICATIONCATEGORIES s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("ADVAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETMANAGEDAPPLICATIONCATEGORIES)GetProcAddress(hinst, "GetManagedApplicationCategories");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(dwReserved, pAppCategoryList);

    return ERROR_INVALID_FUNCTION;
}


// NetGetJoinInformation
typedef NET_API_STATUS (WINAPI * PFNGETJOININFO)(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's NetGetJoinInformation
*/
NET_API_STATUS NT5_NetGetJoinInformation(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType)
{
    static PFNGETJOININFO s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("NETAPI32.DLL");

        if (hinst)
            s_pfn = (PFNGETJOININFO)GetProcAddress(hinst, "NetGetJoinInformation");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(lpServer, lpNameBuffer, BufferType);

    return NERR_NetNotStarted;       // failure
}

// NetApiBufferFree
typedef NET_API_STATUS (WINAPI * PFNNETFREEBUFFER)(LPVOID lpBuffer); 

/*----------------------------------------------------------
Purpose: Thunk for NT 5's NetApiBufferFree
*/
NET_API_STATUS NT5_NetApiBufferFree(LPVOID lpBuffer)
{
    static PFNNETFREEBUFFER s_pfn = PFN_FIRSTTIME;

    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("NETAPI32.DLL");

        if (hinst)
            s_pfn = (PFNNETFREEBUFFER)GetProcAddress(hinst, "NetApiBufferFree");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(lpBuffer);

    return NERR_NetNotStarted;       // failure
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

INCLUDES = $(INCLUDES);..\winnt\$(O)

NO_BROWSER_FILE = 1

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

STDAPI_(BOOL) NT5_CreateAndWaitForProcess(LPTSTR pszExeName);


// Appmgmts APIs
STDAPI  NT5_ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryList);

// Advapi APIs
STDAPI_(DWORD) NT5_InstallApplication(PINSTALLDATA pInstallInfo);
STDAPI_(DWORD) NT5_UninstallApplication(WCHAR * ProductCode, DWORD dwStatus);
STDAPI_(DWORD) NT5_GetManagedApplications(GUID * pCategory, DWORD dwQueryFlags, DWORD dwInfoLevel, LPDWORD pdwApps, PMANAGEDAPPLICATION* prgManagedApps);
STDAPI_(DWORD) NT5_GetManagedApplicationCategories(DWORD dwReserved, APPCATEGORYINFOLIST *pAppCategoryList);

// Kernel APIs
STDAPI_(ULONGLONG) NT5_VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);

// User32 APIs
STDAPI_(BOOL) NT5_AllowSetForegroundWindow( DWORD dwProcessID );

// NetApi32
STDAPI_(NET_API_STATUS) NT5_NetGetJoinInformation(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS  BufferType);
STDAPI_(NET_API_STATUS) NT5_NetApiBufferFree(LPVOID lpBuffer);


#define AllowSetForegroundWindow  NT5_AllowSetForegroundWindow

#define ReleaseAppCategoryInfoList  NT5_ReleaseAppCategoryInfoList

#define VerSetConditionMask     NT5_VerSetConditionMask

#define InstallApplication              NT5_InstallApplication
#define UninstallApplication            NT5_UninstallApplication

#define GetManagedApplications          NT5_GetManagedApplications
#define GetManagedApplicationCategories NT5_GetManagedApplicationCategories
#define NetGetJoinInformation           NT5_NetGetJoinInformation
#define NetApiBufferFree                NT5_NetApiBufferFree

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appmgr.inc ===
#
# Common makefile include for this project
#

TARGET_BOTH     = 1

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

                  
# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF       
!endif

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

CONDITIONAL_INCLUDES = \
                  macocidl.h \
                  version.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appmgr.cpp ===
// Appmgr.cpp : Implementation of CShellAppManager
#include "priv.h"

#include "appmgr.h"
#include "instenum.h"
#include "util.h"
#include "pubenum.h"
#include "sccls.h"

const TCHAR c_szTSMsiHackKey[] = TEXT("Software\\Policies\\Microsoft\\Windows\\Installer\\Terminal Server");
const TCHAR c_szTSMsiHackValue[] = TEXT("EnableAdminRemote");

/////////////////////////////////////////////////////////////////////////////
// CShellAppManager

// constructor
CShellAppManager::CShellAppManager() : _cRef(1)
{
    DllAddRef();
    TraceAddRef(CShellAppManager, _cRef);
    
    ASSERT(_hdpaPub == NULL);
    InitializeCriticalSection(&_cs);
    
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        // Enumerate all of the Application Publishers
        DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPUBLISHER);
        if (DCA_GetItemCount(hdca) > 0)
        {
            _Lock();
            // Create our internal list of IAppPublisher *  
            _hdpaPub = DPA_Create(4);

            if(_hdpaPub)
            {
                int idca;
                for (idca = 0; idca < DCA_GetItemCount(hdca); idca++)
                {
                    IAppPublisher * pap;
                    if (FAILED(DCA_CreateInstance(hdca, idca, IID_IAppPublisher, (LPVOID *) &pap)))
                        continue;

                    ASSERT(IS_VALID_CODE_PTR(pap, IAppPublisher));

                    if (DPA_AppendPtr(_hdpaPub, pap) == DPA_ERR)
                    {
                        pap->Release();
                        break;
                    }
                }

                // if we have no pointers in this array, don't bother create one
                if (DPA_GetPtrCount(_hdpaPub) == 0)
                {
                    DPA_Destroy(_hdpaPub);
                    _hdpaPub = NULL;
                }
            }
            _Unlock();
        }

        DCA_Destroy(hdca);
    }

    
    if (IsTerminalServicesRunning())
    {
        // Hack for MSI work on Terminal Server
        HKEY hkeyMsiHack = NULL; 
        DWORD lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyMsiHack);
        if (lRet == ERROR_FILE_NOT_FOUND)
        {
            lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  NULL, &hkeyMsiHack, NULL);
        }

        if (lRet == ERROR_SUCCESS)
        {
            DWORD dwType = 0;
            DWORD dwTSMsiHack = 0;
            DWORD cbSize = SIZEOF(dwTSMsiHack);

            if ((ERROR_SUCCESS != RegQueryValueEx(hkeyMsiHack, c_szTSMsiHackValue, 0, &dwType, (LPBYTE)&dwTSMsiHack, &cbSize))
                || (dwType != REG_DWORD) || (dwTSMsiHack != 1))
            {
                dwTSMsiHack = 1;
                if (RegSetValueEx(hkeyMsiHack, c_szTSMsiHackValue, 0, REG_DWORD, (LPBYTE)&dwTSMsiHack, SIZEOF(dwTSMsiHack)) == ERROR_SUCCESS)
                    _bCreatedTSMsiHack = TRUE;
            }

            RegCloseKey(hkeyMsiHack);
        }
    }
}


// destructor
CShellAppManager::~CShellAppManager()
{
    if (_bCreatedTSMsiHack)
    {
        ASSERT(IsTerminalServicesRunning());
        HKEY hkeyMsiHack;
        DWORD lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szTSMsiHackKey, 0, KEY_SET_VALUE, &hkeyMsiHack);
        if (ERROR_SUCCESS == lRet)
        {
            RegDeleteValue(hkeyMsiHack, c_szTSMsiHackValue);
            RegCloseKey(hkeyMsiHack);
        }
    }

    _Lock();
    // The order below is important
    if (_hdsaCategoryList)
        _DestroyInternalCategoryList();

    if (_hdpaPub)
        _DestroyAppPublisherList();

    _Unlock();

    DeleteCriticalSection(&_cs);
    DllRelease();
}


// Recursively destroys a GUIDLIST
void CShellAppManager::_DestroyGuidList(GUIDLIST * pGuidList)
{
    ASSERT(IS_VALID_WRITE_PTR(pGuidList, GUIDLIST));
    if (pGuidList->pNextGuid)
        _DestroyGuidList(pGuidList->pNextGuid);

    LocalFree(pGuidList);
}

void CShellAppManager::_DestroyCategoryItem(CATEGORYITEM * pci)
{
    ASSERT(IS_VALID_WRITE_PTR(pci, CATEGORYITEM));
    if (pci->pszDescription)
        LocalFree(pci->pszDescription);
    if (pci->pGuidList)
        _DestroyGuidList(pci->pGuidList);
}

// Destroys our Category List Table
void CShellAppManager::_DestroyInternalCategoryList()
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    ASSERT(IS_VALID_HANDLE(_hdsaCategoryList, DSA));
    int idsa;
    for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
    {
        CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
        if (pci)
            _DestroyCategoryItem(pci);
    }    
    DSA_Destroy(_hdsaCategoryList);
}

// Destroys our list of IAppPublisher *
void CShellAppManager::_DestroyAppPublisherList()
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);
    ASSERT(IS_VALID_HANDLE(_hdpaPub, DPA));
    int idpa;
    for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
    {
        IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
        if (EVAL(pap))
            pap->Release();
    }

    DPA_Destroy(_hdpaPub);
    _hdpaPub = NULL;
}

// IShellAppManager::QueryInterface
HRESULT CShellAppManager::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CShellAppManager, IShellAppManager),                  // IID_IShellAppManager
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IShellAppManager::AddRef
ULONG CShellAppManager::AddRef()
{
    ULONG cRef = InterlockedIncrement(&_cRef);
    TraceAddRef(CShellAppManager, cRef);
    return cRef;
}

// IShellAppManager::Release
ULONG CShellAppManager::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    TraceRelease(CShellAppManager, cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

void CShellAppManager::_Lock(void)
{
    EnterCriticalSection(&_cs);
    DEBUG_CODE( _cRefLock++; )
}

void CShellAppManager::_Unlock(void)
{
    DEBUG_CODE( _cRefLock--; )
    LeaveCriticalSection(&_cs);
}


STDMETHODIMP CShellAppManager::GetNumberofInstalledApps(DWORD * pdwResult)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellAppManager::EnumInstalledApps(IEnumInstalledApps ** ppeia)
{
    HRESULT hres = E_FAIL;
    CEnumInstalledApps * peia = new CEnumInstalledApps();
    if (peia)
    {
        *ppeia = SAFECAST(peia, IEnumInstalledApps *);
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}


HRESULT CShellAppManager::_AddCategoryToList(APPCATEGORYINFO * pai, IAppPublisher * pap)
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    if (pai == NULL || _hdsaCategoryList == NULL)
        return E_FAIL;

    ASSERT(IS_VALID_CODE_PTR(pap, IAppPublisher));
    
    // Allocate a GUIDLIST item first
    GUIDLIST * pgl  = (GUIDLIST *)LocalAlloc(LPTR, SIZEOF(GUIDLIST));
    if (!pgl)
        return E_OUTOFMEMORY;
    
    pgl->CatGuid    = pai->AppCategoryId;
    pgl->papSupport = pap;

    // Search in the CategoryList
    int idsa;
    for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
    {
        CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);

        if (pci)
        {
            // If we find an empty spot, fill it
            if (pci->pszDescription == NULL)
            {
                CATEGORYITEM ci = {0};
                ci.pszDescription = StrDupW(pai->pszDescription);
                ci.pGuidList    = pgl;

                pgl->pNextGuid  = NULL;

                if (DSA_InsertItem(_hdsaCategoryList, idsa, &ci) == -1)
                {
                    LocalFree(ci.pszDescription);
                    break;
                }
            }
            // If we find an entry with the same description text, add our GUID to the GuidList
            else if(!lstrcmpi(pai->pszDescription, pci->pszDescription))
            {
                pgl->pNextGuid  = pci->pGuidList;
                pci->pGuidList  = pgl;
                break;
            }
        }
        else
            ASSERT(0);
    }

    // We ran out of items in the list, and didn't run into an identical category string
    if (idsa == DSA_GetItemCount(_hdsaCategoryList))
    {
        CATEGORYITEM ci = {0};
        ci.pszDescription = StrDupW(pai->pszDescription);
        ci.pGuidList    = pgl;

        pgl->pNextGuid  = NULL;
        if (DSA_AppendItem(_hdsaCategoryList, &ci) == -1)
            LocalFree(ci.pszDescription);
    }
    
    return S_OK;
}


HRESULT CShellAppManager::_BuildInternalCategoryList()
{
    HRESULT hres = E_OUTOFMEMORY;
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    ASSERT(IsValidHDPA(_hdpaPub));

    // We have just one valid version of _hdsaCategoryList, so we should never call this function
    // again once _hdsaCategoryList is created.
    ASSERT(_hdsaCategoryList == NULL);

    // Is the structure automatically filled with zero?
    _hdsaCategoryList =  DSA_Create(SIZEOF(CATEGORYITEM), CATEGORYLIST_GROW);

    if (_hdsaCategoryList)
    {
        int idpa;
        for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
        {
            IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
            ASSERT(pap);

            if (pap)
            {
                UINT i;
                APPCATEGORYINFOLIST AppCatList;
                if (SUCCEEDED(pap->GetCategories(&AppCatList)))
                {
                    if ((AppCatList.cCategory > 0) && AppCatList.pCategoryInfo)
                    {
                        for (i = 0; i < AppCatList.cCategory; i++)
                            _AddCategoryToList(&AppCatList.pCategoryInfo[i], pap);

                        _DestroyCategoryList(&AppCatList);
                    }
                }
            }

            hres = S_OK;
        }
    }

    return hres;
}


// Compile a multi string of categories and return it to the caller
HRESULT CShellAppManager::_CompileCategoryList(PSHELLAPPCATEGORYLIST psacl)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(psacl, SHELLAPPCATEGORYLIST));
    
    // Don't do anything if we have an empty list
    if (_hdsaCategoryList && (DSA_GetItemCount(_hdsaCategoryList) > 0))
    {
        psacl->pCategory = (PSHELLAPPCATEGORY) SHAlloc(DSA_GetItemCount(_hdsaCategoryList) * SIZEOF(SHELLAPPCATEGORY));
        if (psacl->pCategory)
        {
            int idsa;
            for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
            {
                CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
                if (pci && pci->pszDescription)
                {
                    if (SUCCEEDED(SHStrDup(pci->pszDescription, &psacl->pCategory[idsa].pszCategory)))
                    {
                        ASSERT(IS_VALID_STRING_PTR(psacl->pCategory[idsa].pszCategory, -1));
                        psacl->cCategories++;
                    }
                    else
                        break;
                }
            }
            hres = S_OK;
        }
        else          
            hres = E_OUTOFMEMORY;
    }

    return hres;
}

// IShellAppManager::GetPublishedAppCategories
STDMETHODIMP CShellAppManager::GetPublishedAppCategories(PSHELLAPPCATEGORYLIST psacl)
{
    HRESULT hres = E_INVALIDARG;
    if (psacl)
    {
        ASSERT(IS_VALID_READ_PTR(psacl, SHELLAPPCATEGORYLIST));
        ZeroMemory(psacl, SIZEOF(SHELLAPPCATEGORYLIST));

        // NOTE: keep the check inside the lock! So that only one thread
        // is allowed in.
        
        _Lock();
        // Do we have any app publishers in our list at all
        if (_hdpaPub)
        {
            if (_hdsaCategoryList == NULL)
                _BuildInternalCategoryList();

            hres = _CompileCategoryList(psacl);
        }
        _Unlock();
    }
    return hres;
}


GUIDLIST * CShellAppManager::_FindGuidListForCategory(LPCWSTR pszDescription)
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);

    if (_hdsaCategoryList)
    {
        int idsa;
        for (idsa = 0; idsa < DSA_GetItemCount(_hdsaCategoryList); idsa++)
        {
            CATEGORYITEM * pci = (CATEGORYITEM *)DSA_GetItemPtr(_hdsaCategoryList, idsa);
            if (pci && pci->pszDescription && !lstrcmpi(pszDescription, pci->pszDescription))
                return pci->pGuidList;
        }
    }
    return NULL;
}


extern void _DestroyHdpaEnum(HDPA hdpaEnum);

// IShellAppManager::EnumPublishedApps
STDMETHODIMP CShellAppManager::EnumPublishedApps(LPCWSTR pszCategory, IEnumPublishedApps ** ppepa)
{
    HRESULT hres = E_OUTOFMEMORY;

    ASSERT(pszCategory == NULL || IS_VALID_STRING_PTRW(pszCategory, -1));

    // hdpaEnum is the list of IEnumPublishedApp * we pass to the constructor of CShellEnumPublishedApps
    HDPA hdpaEnum = DPA_Create(4);

    if (hdpaEnum)
    {
        // If no category is required, we enumerate all 
        if (pszCategory == NULL)
        {
            _Lock();
            if (_hdpaPub)
            {
                int idpa;
                for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaPub); idpa++)
                {
                    IAppPublisher * pap = (IAppPublisher *)DPA_GetPtr(_hdpaPub, idpa);
                    IEnumPublishedApps * pepa; 
                    if (pap && SUCCEEDED(pap->EnumApps(NULL, &pepa)))
                    {
                        ASSERT(IS_VALID_CODE_PTR(pepa, IEnumPublishedApps));
                        if (DPA_AppendPtr(hdpaEnum, pepa) == DPA_ERR)
                        {
                            pepa->Release();
                            break;
                        }
                    }
                }
            }
            _Unlock();
        }
        else
        {
            _Lock();
            // If there is no Category list, let's build one
            if (_hdsaCategoryList == NULL)
                _BuildInternalCategoryList();

            // Otherwise we find the GuidList and enumerate all the guys in the list
            GUIDLIST * pgl = _FindGuidListForCategory(pszCategory);
            
            while (pgl && pgl->papSupport)
            {
                ASSERT(IS_VALID_READ_PTR(pgl, GUIDLIST) && IS_VALID_CODE_PTR(pgl->papSupport, IAppPulisher));
                IEnumPublishedApps * pepa; 
                if (SUCCEEDED(pgl->papSupport->EnumApps(&pgl->CatGuid, &pepa)))
                {
                    ASSERT(IS_VALID_CODE_PTR(pepa, IEnumPublishedApps));
                    if (DPA_AppendPtr(hdpaEnum, pepa) == DPA_ERR)
                    {
                        pepa->Release();
                        break;
                    }
                }
                pgl = pgl->pNextGuid;
            }

            _Unlock();
        }
                
    }

    // Even if we have no enumerators we return success and pass back an empty enumerator
        
    CShellEnumPublishedApps * psepa = new CShellEnumPublishedApps(hdpaEnum);
    if (psepa)
    {
        *ppepa = SAFECAST(psepa, IEnumPublishedApps *);
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
        if (hdpaEnum)
            _DestroyHdpaEnum(hdpaEnum);
    }
    return hres;
}

EXTERN_C STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd);
STDMETHODIMP CShellAppManager::InstallFromFloppyOrCDROM(HWND hwndParent)
{
    return InstallAppFromFloppyOrCDROM(hwndParent);
}



/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CShellAppManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CShellAppManager* pObj = new CShellAppManager();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellAppManager *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appmgr.h ===
#ifndef __APPMGR_H_
#define __APPMGR_H_

#define REGSTR_PATH_APPPUBLISHER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\Publishers")

// Structure to contain the list of GUIDs for a category
typedef struct _GuidList
{
    GUID CatGuid;
    IAppPublisher * papSupport;
    struct _GuidList * pNextGuid;
} GUIDLIST;

/////////////////////////////////////////////////////////////////////////////
// CShellAppManager
class CShellAppManager : public IShellAppManager
{
public:
    CShellAppManager();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellAppManager
    STDMETHODIMP GetNumberofInstalledApps(DWORD * pdwResult);
    STDMETHODIMP EnumInstalledApps(IEnumInstalledApps ** ppeia);
    STDMETHODIMP GetPublishedAppCategories(PSHELLAPPCATEGORYLIST psacl);
    STDMETHODIMP EnumPublishedApps(LPCWSTR pszCategory, IEnumPublishedApps ** ppepa);
    STDMETHODIMP InstallFromFloppyOrCDROM(HWND hwndParent);

protected:

    virtual ~CShellAppManager();

    LONG _cRef;

    // App Publisher List
    HDPA _hdpaPub;

    // Item of the Internal Category List 
#define CATEGORYLIST_GROW 16
    typedef struct _CategoryItem
    {
        LPWSTR pszDescription;
        GUIDLIST * pGuidList;
    } CATEGORYITEM;

    // Category List
    HDSA _hdsaCategoryList;

    void    _Lock(void);
    void    _Unlock(void);
    
    CRITICAL_SECTION _cs;
    DEBUG_CODE( LONG _cRefLock; )

    // Internal structure funcitons
    void       _DestroyGuidList(GUIDLIST * pGuidList);
    
    HRESULT    _AddCategoryToList(APPCATEGORYINFO * pai, IAppPublisher * pap);
    HRESULT    _BuildInternalCategoryList(void);
    HRESULT    _CompileCategoryList(PSHELLAPPCATEGORYLIST pascl);

    void       _DestroyCategoryItem(CATEGORYITEM * pci);
    void       _DestroyInternalCategoryList(void);
    void       _DestroyAppPublisherList(void);

    GUIDLIST * _FindGuidListForCategory(LPCWSTR pszDescription);

    BOOL       _bCreatedTSMsiHack; // The "EnableAdminRemote" value for MSI to work on TS
};

#endif //__APPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appsize.h ===
#ifndef __APPSIZE_H_
#define __APPSIZE_H_

#include <runtask.h>

// Folder size computation tree walker callback class
class CAppFolderSize : public IShellTreeWalkerCallBack
{
public:
    CAppFolderSize(ULONGLONG * puSize);
    virtual ~CAppFolderSize();

    // *** IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd); 
    STDMETHODIMP LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, HRESULT hrError);

    // *** Initailze the IShellTreeWalker * by CoCreateInstacing it
    HRESULT Initialize();

protected:
    ULONGLONG * _puSize;
    IShellTreeWalker * _pstw;

    UINT    _cRef;
    HRESULT _hrCoInit;
}; 

#endif // _APPSIZE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\applist.c ===
//
//  AppList.C
//
//  Copyright (C) Microsoft, 1994, 1995, All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  ral 9/09/94 - Clean up
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"
#include "regstr.h"


//
//  Executes the appropriate setup program
//

BOOL ExecSetupProg(LPWIZDATA lpwd, BOOL ForceWx86, BOOL bMinimizeWiz)
{
    SHELLEXECUTEINFO ei;
    BOOL fWorked= FALSE;

#ifdef WX86
    DWORD  Len;
    WCHAR  ProcArchValue[32];
#endif

    HWND hDlgPropSheet = GetParent(lpwd->hwnd);
    LPTSTR lpszTarget = NULL;

    ei.cbSize = sizeof(ei);
    ei.hwnd = lpwd->hwnd;
    ei.lpVerb = NULL;
    ei.fMask = 0;

    lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;
    if (lpszTarget[0] == TEXT('*'))
    {
        ei.lpFile = CharNext(lpszTarget);
        ei.fMask |= SEE_MASK_CONNECTNETDRV;
    }
    else
    {
        ei.lpFile = lpszTarget;
    }

    if (lpwd->szParams[0] == 0)
    {
        ei.lpParameters = NULL;
    }
    else
    {
        ei.lpParameters = lpwd->szParams;
    }

    if (lpwd->szWorkingDir[0] == TEXT('\0'))
    {
        ei.lpDirectory = NULL;
    }
    else
    {
        ei.lpDirectory = lpwd->szWorkingDir;
    }

    ei.lpClass = NULL;
    ei.nShow = SW_SHOWDEFAULT;
    ei.hInstApp = g_hinst;

    if (bMinimizeWiz)
        SetWindowPos(hDlgPropSheet, 0, 0, 0, 0, 0, SWP_HIDEWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);


#ifdef WX86
    if (ForceWx86) {
        Len = GetEnvironmentVariableW(ProcArchName,
                                      ProcArchValue,
                                      sizeof(ProcArchValue)
                                      );

        if (!Len || Len >= sizeof(ProcArchValue)) {
            ProcArchValue[0]=L'\0';
        }

        SetEnvironmentVariableW(ProcArchName, L"x86");
        ei.fMask |= SEE_MASK_FLAG_SEPVDM;

    }
#endif


    fWorked = ShellExecuteEx(&ei);


#ifdef WX86
    if (ForceWx86) {
        SetEnvironmentVariableW(ProcArchName, ProcArchValue);
    }
#endif



    if (!fWorked)
    {
        //
        // Something went wrong. Put the dialog back up.
        //

        SetWindowPos(hDlgPropSheet, 0, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADSETUP),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }

    return(fWorked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appsize.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: appsize.cpp
//
// Compute the size of an application 
// 
// History:
//         2-17-98  by dli implemented CAppFolderSize
//------------------------------------------------------------------------
#include "priv.h"
#include "appsize.h"

// NOTE: CAppFolderSize and CAppFolderFinder are very similar to C*TreeWalkCB in Shell32.

CAppFolderSize::CAppFolderSize(ULONGLONG * puSize): _cRef(1), _puSize(puSize)
{
    _hrCoInit = CoInitialize(NULL);
}

CAppFolderSize::~CAppFolderSize()
{
    if (_pstw)
        _pstw->Release();

    if (SUCCEEDED(_hrCoInit))
    {
        CoUninitialize();
    }
}

HRESULT CAppFolderSize::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CAppFolderSize, IShellTreeWalkerCallBack),       // IID_IShellTreeWalkerCallBack
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}


ULONG CAppFolderSize::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CAppFolderSize::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAppFolderSize::Initialize()
{
    HRESULT hr = _hrCoInit;
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_IShellTreeWalker, (LPVOID *)&_pstw);
    }
    return hr;
}   

//
// IShellTreeWalkerCallBack::FoundFile 
//
HRESULT CAppFolderSize::FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    if (_puSize)
        *_puSize = ptws->ulActualSize;
    return hres;
}

HRESULT CAppFolderSize::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

//
// IShellTreeWalkerCallBack::LeaveFolder
//
HRESULT CAppFolderSize::LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws)
{
    return E_NOTIMPL;
}

//
// IShellTreeWalkerCallBack::HandleError 
//
HRESULT CAppFolderSize::HandleError(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, HRESULT ErrorCode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appwiz.c ===
//
//  APPWIZ.C        Application installation wizard CPL
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  ral 8/09/94 - Clean up
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include <cpl.h>
#include "util.h"
#include "resource.h"
#include <tsappcmp.h>       // for TermsrvAppInstallMode

//
// (tedm) Header files for Setup
//
#include <setupapi.h>
#include <syssetup.h>
    
TCHAR const c_szPIF[] = TEXT(".pif");
TCHAR const c_szLNK[] = TEXT(".lnk");

#ifdef WX86

BOOL
IsWx86Enabled(
    VOID
    )

//
// Consults the registry to determine if Wx86 is enabled in the system
// NOTE: this should be changed post SUR to call kernel32 which maintanes
//       this information, Instead of reading the registry each time.
//

{
    LONG Error;
    HKEY hKey;
    WCHAR ValueBuffer[MAX_PATH];
    DWORD ValueSize;
    DWORD dwType;

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\Wx86",
                        0, KEY_READ,
                        &hKey
                        );

    if (Error != ERROR_SUCCESS) {
        return FALSE;
        }

    ValueSize = sizeof(ValueBuffer);
    Error = RegQueryValueExW(hKey,
                             L"cmdline",
                             NULL,
                             &dwType,
                             (LPBYTE)ValueBuffer,
                             &ValueSize
                             );
    RegCloseKey(hKey);

    return (Error == ERROR_SUCCESS &&
            dwType == REG_SZ &&
            ValueSize &&
            *ValueBuffer
            );

}
#endif

const LPCTSTR g_szStartPages[] = { TEXT("remove"), TEXT("install"), TEXT("configurewindows") };
    
int ParseStartParams(LPCTSTR pcszStart)
{
    int iStartPage = 0;
    if (IsInRange(*pcszStart, TEXT('0'), TEXT('9')))
        return StrToInt(pcszStart);

    if (g_bRunOnNT5)
    {
        int i;
        for (i = 0; i < ARRAYSIZE(g_szStartPages); i++)
        {
            if (!StrCmpI(g_szStartPages[i], pcszStart))
            {
                iStartPage = i;
                break;
            }
        }
    }

    return iStartPage;
}

LONG CALLBACK CPlApplet(HWND hwnd, UINT Msg, LPARAM lParam1, LPARAM lParam2 )
{
    UINT nStartPage = MAX_PAGES;
//  not currently used by chicago   LPNEWCPLINFO lpNewCPlInfo;
    LPTSTR lpStartPage;

    switch (Msg)
    {
    case CPL_INIT:
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:
#define lpCPlInfo ((LPCPLINFO)lParam2)
        lpCPlInfo->idIcon = IDI_CPLICON;
        lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->idInfo = IDS_INFO;
        lpCPlInfo->lData  = 0;
#undef lpCPlInfo
        break;

    case CPL_DBLCLK:
        OpenAppMgr(hwnd, 0);
        break;

    case CPL_STARTWPARMS:
        lpStartPage = (LPTSTR)lParam2;

        if (*lpStartPage)
            nStartPage = ParseStartParams(lpStartPage);

        //
        // Make sure that the requested starting page is less than the max page
        //        for the selected applet.

        if (nStartPage >= MAX_PAGES) return FALSE;

        OpenAppMgr(hwnd, nStartPage);

        return TRUE;  // return non-zero to indicate message handled

    default:
        return FALSE;
    }
    return TRUE;
}  // CPlApplet


//
//  Adds a page to a property sheet.
//

void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPWIZDATA lpwd, DWORD dwPageFlags)
{
    if (ppsh->nPages < MAX_PAGES)
    {
       PROPSHEETPAGE psp;

       psp.dwSize = sizeof(psp);
       psp.dwFlags = dwPageFlags;
       psp.hInstance = g_hinst;
       psp.pszTemplate = MAKEINTRESOURCE(id);
       psp.pfnDlgProc = pfn;
       psp.lParam = (LPARAM)lpwd;

       ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);

       if (ppsh->phpage[ppsh->nPages])
           ppsh->nPages++;
    }
}  // AddPage



// This function disables auto-run during the add from floppy or CD wizard.
// It is a subclass of the property sheet window.

LRESULT CALLBACK WizParentWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                        UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    static UINT msgQueryCancelAutoPlay = 0;

    if (!msgQueryCancelAutoPlay)
        msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));

    if (uMsg == msgQueryCancelAutoPlay)
    {
        return TRUE; // Yes, cancel auto-play when wizard is running
    }
    else
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);        
    }

}

// The following callback is specified when a wizard wants to disable auto-run.
// The callback subclasses the wizard's window, to catch the QueryCancelAutoRun
// message sent by the shell when it wants to auto-run a CD.

int CALLBACK DisableAutoRunCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        SetWindowSubclass(hwnd, WizParentWindowProc, 0, 0);
    }

    return 0;
}

//
//  Common code used by the Link and Setup wizards to initialize the
//  property sheet header and wizard data.
//

void InitWizHeaders(LPPROPSHEETHEADER ppd,
                          HPROPSHEETPAGE *rPages,
                          LPWIZDATA lpwd, int iBmpID, DWORD dwFlags)
{
    lpwd->hbmpWizard = LoadBitmap(g_hinst, MAKEINTRESOURCE(iBmpID));

    //PROPSHEETHEADER_V1_SIZE: needs to run on downlevel platform (NT4, Win95)

    ppd->dwSize = PROPSHEETHEADER_V1_SIZE;
    ppd->dwFlags = dwFlags;
    ppd->hwndParent = lpwd->hwnd;
    ppd->hInstance = g_hinst;
    ppd->pszCaption = NULL;
    ppd->nPages = 0;
    ppd->nStartPage = 0;
    ppd->phpage = rPages;

    if (lpwd->dwFlags & WDFLAG_NOAUTORUN)
    {
        ppd->dwFlags |= PSH_USECALLBACK;
        ppd->pfnCallback = DisableAutoRunCallback;
    }
}


//
//  Called when a wizard is dismissed.       Cleans up any garbage left behind.
//

void FreeWizData(LPWIZDATA lpwd)
{
    if (lpwd->hbmpWizard)
    {
       DeleteObject(lpwd->hbmpWizard);
       lpwd->hbmpWizard = NULL;
    }
}

typedef struct _WIZPAGE {
    int     id;
    DLGPROC pfn;
} WIZPAGE;


//
//  Common code used by the Link Wizard and App Wizard (PIF
//  wizard).
//

BOOL DoWizard(LPWIZDATA lpwd, int iIDBitmap, const WIZPAGE *wp, int PageCount, 
              DWORD dwWizardFlags, DWORD dwPageFlags)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    int i;
    HWND    hwnd, hwndT;
    BOOL    bResult = FALSE;
    BOOL    bChangedIcon = FALSE;
    HICON   hicoPrev;

    if (SUCCEEDED(CoInitialize(NULL)))
    {
        InitWizHeaders(&psh, rPages, lpwd, iIDBitmap, dwWizardFlags);

        for (i = 0; i < PageCount; i++)
        {
           AddPage(&psh, wp[i].id, wp[i].pfn, lpwd, dwPageFlags);
        }

        // Walk up the parent/owner chain until we find the master owner.
        //
        // We need to walk the parent chain because sometimes we are given
        // a child window as our lpwd->hwnd.  And we need to walk the owner
        // chain in order to find the owner whose icon will be used for
        // Alt+Tab.
        //
        // GetParent() returns either the parent or owner.  Normally this is
        // annoying, but we luck out and it's exactly what we want.

        hwnd = lpwd->hwnd;
        while ((hwndT = GetParent(hwnd)) != NULL)
        {
            hwnd = hwndT;
        }

        // If the master owner isn't visible we can futz his icon without
        // screwing up his appearance.
        if (!IsWindowVisible(hwnd))
        {
            HICON hicoNew = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON));
            hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
            bChangedIcon = TRUE;
        }

        bResult = (BOOL)PropertySheet(&psh);
        FreeWizData(lpwd);

        // Clean up our icon now that we're done
        if (bChangedIcon)
        {
            // Put the old icon back
            HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
            if (hicoNew)
                DestroyIcon(hicoNew);
        }

        CoUninitialize();
    }

    return bResult;
}

//
//The same as DoWizard except that it returns FALSE only in case of an error.
//Used by SetupWizard.
//(DoWizard is buggy. In case of an error it may return either 0 or -1 and it
// returns 0 when user hits "Cancel" button)
//
BOOL DoWizard2(LPWIZDATA lpwd, int iIDBitmap, const WIZPAGE *wp, int PageCount, 
              DWORD dwWizardFlags, DWORD dwPageFlags)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    int i;
    HWND    hwnd, hwndT;
    BOOL    bResult = FALSE;
    BOOL    bChangedIcon = FALSE;
    HICON   hicoPrev;
    
    //
    //No support for modeless dialogs
    //
    ASSERT(!(dwWizardFlags & PSH_MODELESS));

    if(dwWizardFlags & PSH_MODELESS)
    {
        return FALSE;
    }

    if (SUCCEEDED(CoInitialize(NULL)))
    {
        InitWizHeaders(&psh, rPages, lpwd, iIDBitmap, dwWizardFlags);

        for (i = 0; i < PageCount; i++)
        {
           AddPage(&psh, wp[i].id, wp[i].pfn, lpwd, dwPageFlags);
        }

        // Walk up the parent/owner chain until we find the master owner.
        //
        // We need to walk the parent chain because sometimes we are given
        // a child window as our lpwd->hwnd.  And we need to walk the owner
        // chain in order to find the owner whose icon will be used for
        // Alt+Tab.
        //
        // GetParent() returns either the parent or owner.  Normally this is
        // annoying, but we luck out and it's exactly what we want.

        hwnd = lpwd->hwnd;
        while ((hwndT = GetParent(hwnd)) != NULL)
        {
            hwnd = hwndT;
        }

        // If the master owner isn't visible we can futz his icon without
        // screwing up his appearance.
        if (!IsWindowVisible(hwnd))
        {
            HICON hicoNew = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON));
            hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
            bChangedIcon = TRUE;
        }

        bResult = (PropertySheet(&psh) != -1);
        FreeWizData(lpwd);

        // Clean up our icon now that we're done
        if (bChangedIcon)
        {
            // Put the old icon back
            HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
            if (hicoNew)
                DestroyIcon(hicoNew);
        }

        CoUninitialize();
    }

    return bResult;
}

//
//  Link Wizard
//

BOOL LinkWizard(LPWIZDATA lpwd)
{
    BOOL fSuccess;

    static const WIZPAGE wp[] = {
                   {DLG_BROWSE,         BrowseDlgProc},
                   {DLG_PICKFOLDER,     PickFolderDlgProc},
                   {DLG_GETTITLE,       GetTitleDlgProc},
                   {DLG_PICKICON,       PickIconDlgProc} };

    // Don't set lpwd->hwnd to NULL!
    // We must create the link wizard with a parent or you end up with one
    // thread displaying two independent top-level windows and things get
    // really weird really fast.

    fSuccess = DoWizard(lpwd, IDB_SHORTCUTBMP, wp, ARRAYSIZE(wp), 
                        PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD_LITE,
                        PSP_DEFAULT | PSP_HIDEHEADER);
    
    return fSuccess;
}


BOOL SetupWizard(LPWIZDATA lpwd)
{
    // This is what the user normally sees when using the Add/Remove Programs
    // control panel.
    static const WIZPAGE wp_normal[] = {
                   {DLG_SETUP, SetupDlgProc},
                   {DLG_SETUPBROWSE, SetupBrowseDlgProc},
                   {DLG_CHGUSRFINISH_PREV, ChgusrFinishPrevDlgProc},
                   {DLG_CHGUSRFINISH, ChgusrFinishDlgProc}
    };

    // This is the wizard that is used when the user double clicks on a setup
    // program and the shell uses us to enter Install Mode if Terminal Server
    // is installed.
    static const WIZPAGE wp_TSAutoInstall[] = {
                   {DLG_CHGUSRFINISH_PREV, ChgusrFinishPrevDlgProc},
                   {DLG_CHGUSRFINISH, ChgusrFinishDlgProc}
    };

    BOOL fResult;
    static const WIZPAGE * pwpToUse = wp_normal;
    DWORD dwPages = ARRAYSIZE(wp_normal);
    
    if (WDFLAG_AUTOTSINSTALLUI & lpwd->dwFlags)
    {
        pwpToUse = wp_TSAutoInstall;
        dwPages = ARRAYSIZE(wp_TSAutoInstall);
    }

    lpwd->dwFlags |= WDFLAG_SETUPWIZ;

    if (g_bRunOnNT5)
    {
        fResult = DoWizard2(lpwd, IDB_INSTALLBMP, pwpToUse, dwPages, 
                           PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD_LITE,
                           PSP_DEFAULT | PSP_HIDEHEADER);
    }
    else
    {
        fResult = DoWizard2(lpwd, IDB_LEGACYINSTALLBMP, pwpToUse, dwPages, 
                           PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_WIZARD,
                           PSP_DEFAULT);
    }

    lpwd->dwFlags &= ~WDFLAG_SETUPWIZ;
    return(fResult);
}


STDAPI InstallAppFromFloppyOrCDROMEx(IN HWND hwnd, IN OPTIONAL DWORD dwAdditionalFlags,
  IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN LPVOID lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo, 
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    WIZDATA wd = {0};
    HRESULT hr = S_OK;
    BOOL bModeChanged = FALSE;
    wd.hwnd = hwnd;
    wd.dwFlags |= (WDFLAG_NOAUTORUN | dwAdditionalFlags);

    if (IsTerminalServicesRunning() && !IsUserAnAdmin()) 
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_RESTRICTION),
           MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
        return S_FALSE;
    }

    if (WDFLAG_AUTOTSINSTALLUI & wd.dwFlags)
    {
        // Remember the previous "InstallMode"
        wd.bPrevMode = TermsrvAppInstallMode();

        // Set the "InstallMode"
        SetTermsrvAppInstallMode(TRUE);
        
        if (!CreateProcessW(lpApplicationName,  (LPWSTR)lpCommandLine, lpProcessAttributes, lpThreadAttributes,
                        bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                        lpProcessInformation))
        {
            SetTermsrvAppInstallMode(wd.bPrevMode);
            hr = E_FAIL;
        }

        bModeChanged = TRUE;
    }

    if (SUCCEEDED(hr) && !SetupWizard(&wd))
    {
        if(bModeChanged)
        {
            //
            //SetupWizard that suppose to return system to EXECUTE mode failed.
            //make sure that it does not remain in INSTALL mode.
            //
            SetTermsrvAppInstallMode(wd.bPrevMode);
        }

        hr = E_FAIL;
    }

    return hr;
}


STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd)
{
    return InstallAppFromFloppyOrCDROMEx(hwnd, 0, NULL, NULL, NULL, NULL, FALSE, 0, NULL, NULL, NULL, NULL);
}


//

//
//  RUNDLL entry point to create a new link.  An empty file has already been
//  created and is the only parameter passed in lpszCmdLine.
//
//  hAppInstance is never used.

void WINAPI NewLinkHere_Common(HWND hwnd, HINSTANCE hAppInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    WIZDATA wd;
    TCHAR   szFolder[MAX_PATH];

    memset(&wd, 0, sizeof(wd));

    wd.hwnd = hwnd;
    wd.dwFlags |= WDFLAG_LINKHEREWIZ | WDFLAG_DONTOPENFLDR;
    wd.lpszOriginalName = lpszCmdLine;

    lstrcpyn(szFolder, lpszCmdLine, ARRAYSIZE(szFolder));

    PathRemoveFileSpec(szFolder);

    wd.lpszFolder = szFolder;

    //
    // If the filename passed in is not valid then we'll just silently fail.
    //

    if (PathFileExists(lpszCmdLine))
    {
       if (!LinkWizard(&wd))
       {
           DeleteFile(lpszCmdLine);
       }
    }
    else
    {
       #define lpwd (&wd)
       TraceMsg(TF_ERROR, "%s", "APPWIZ ERORR:  Bogus file name passed to NewLinkHere");
       TraceMsg(TF_ERROR, "%s", lpszCmdLine);
       #undef lpwd
    }
}

void WINAPI NewLinkHere(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*SIZEOF(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        NewLinkHere_Common( hwndStub,
                            hAppInstance,
                            lpwszCmdLine,
                            nCmdShow );
        LocalFree(lpwszCmdLine);
    }
}

void WINAPI NewLinkHereW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    NewLinkHere_Common( hwndStub,
                             hAppInstance,
                             lpwszCmdLine,
                             nCmdShow );
}

//
//  Called directly by Cabinet
//

BOOL ConfigStartMenu(HWND hwnd, BOOL bDelete)
{
    if (bDelete)
    {
       return(RemoveItemsDialog(hwnd));
    }
    else
    {
       WIZDATA wd;

       memset(&wd, 0, sizeof(wd));

       wd.hwnd = hwnd;
       wd.dwFlags |= WDFLAG_DONTOPENFLDR;

       return(LinkWizard(&wd));
    }
}


//
//  This is a generic function that all the app wizard sheets call
//  to do basic initialization.
//

LPWIZDATA InitWizSheet(HWND hDlg, LPARAM lParam, DWORD dwFlags)
{
    LPPROPSHEETPAGE ppd  = (LPPROPSHEETPAGE)lParam;
    LPWIZDATA       lpwd = (LPWIZDATA)ppd->lParam;
    HWND            hBmp = GetDlgItem(hDlg, IDC_WIZBMP);

    lpwd->hwnd = hDlg;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    SendMessage(hBmp, STM_SETIMAGE,
              IMAGE_BITMAP, (LPARAM)lpwd->hbmpWizard);

    return(lpwd);
}

void CleanUpWizData(LPWIZDATA lpwd)
{
    //
    // Release any INewShortcutHook.
    //

    if (lpwd->pnshhk)
    {
        lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
        lpwd->pnshhk = NULL;
    }

    return;
}

HRESULT InstallOnTerminalServerWithUI(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes, 
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN LPVOID lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo, 
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    return InstallAppFromFloppyOrCDROMEx(hwnd, WDFLAG_AUTOTSINSTALLUI, lpApplicationName, lpCommandLine, lpProcessAttributes, 
                        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, 
                        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appwiz.inc ===
#
# Common makefile include for this project
#

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

# Use the NT product version numbers
USE_NT_PRODUCT_VER = 1
                  
# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF       
!endif

INCLUDES = $(INCLUDES);$(BASEDIR)\private\inc

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                    dlldata.c       \
                    shappmgr_p.c    \
                    statreg.h       \
                    statreg.cpp     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appwiz.h ===
//
//  APPWIZ.H -- App install wizard header file
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - Copied from INTL CPL
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//  3/14/98  [scotth] - reworked into shell 5 project
//

#ifndef _APPWIZ_H_
#define _APPWIZ_H_

#include <pif.h>        // for PROPPRG
#include <apwizhlp.h>
#include "appwizid.h"
#include <shsemip.h>    // for RestartDialog

#define CPLMODE_NORMAL            0
#define CPLMODE_AUTOMSDOS   1
#define CPLMODE_PROPWIZ     2

#define MAX_PAGES  15           // limit on number of pages we can have

#define WDFLAG_NOBROWSEPAGE 0x00000001        // Don't let user pick exe name
#define WDFLAG_APPKNOWN     0x00000002        // Finish after selecting folder
#define WDFLAG_DOSAPP       0x00000004        // Exe is a DOS program
//      -- notused          0x00000008
//      -- notused          0x00000010
#define WDFLAG_LINKHEREWIZ  0x00000020        // Create empty link (NOT IMPLEMENTED!)
#define WDFLAG_INEDITMODE   0x00000040        // Editing a folder label
#define WDFLAG_DONTOPENFLDR 0x00000080        // Don't open folder when link made
#define WDFLAG_REALMODEONLY 0x00000100        // Don't use any prot mode drivers
#define WDFLAG_COPYLINK     0x00000200        // Copy link, don't create new one.
#define WDFLAG_SETUPWIZ     0x00000400        // Setup from disk wizard
#define WDFLAG_READOPTFLAGS 0x00000800        // Value in dwDosOptGlobalFlags is valid
#define WDFLAG_NOAUTORUN    0x00001000        // Disable autorun while wizard is running
#define WDFLAG_AUTOTSINSTALLUI 0x00002000        // Automate Install Mode (For people double clicking or calling ShellExecute() on setup programs)
#define WDFLAG_EXPSZ        0x10000000        // WizData contains expanded strings

typedef struct _DOSOPT {
    HKEY        hk;
    DWORD        dwFlags;
    UINT        uOrder;
    DWORD        dwStdOpt;

} DOSOPT, FAR * LPDOSOPT;


//////////////////////////////////////////////////////////////////////////////
//
// UNINSTALL_ITEM -- more info kept in an array paralell to the listbox
//
//////////////////////////////////////////////////////////////////////////////

typedef struct
{
    TCHAR command[ MAX_PATH ];  // command to run which will nuke the app

} UNINSTALL_ITEM, FAR * LPUNINSTALL_ITEM;



typedef struct _WIZDATA {
    HWND        hwnd;
    DWORD       dwFlags;
    TCHAR       szExeName[MAX_PATH];
    TCHAR       szExpExeName[MAX_PATH];
    TCHAR       szParams[MAX_PATH];
    TCHAR       szProgDesc[MAX_PATH];
    TCHAR       szWorkingDir[MAX_PATH];
    HBITMAP     hbmpWizard;
    HIMAGELIST  himl;
    LPTSTR      lpszFolder;
    PROPPRG     PropPrg;
    LPTSTR      lpszOriginalName;       // if non-null then link exists already
    LPUNINSTALL_ITEM        lpUItem;

#ifndef NO_NEW_SHORTCUT_HOOK
    INewShortcutHook *pnshhk;
    TCHAR     szExt[MAX_PATH];
    INewShortcutHookA *pnshhkA;
#endif

    BOOL        bTermSrvAndAdmin;
    BOOL        bPrevMode;

} WIZDATA, FAR * LPWIZDATA;

//
// Private messages
//
#define WMPRIV_POKEFOCUS    WM_APP+0

//
// Wizard entry points.
//
BOOL LinkWizard(LPWIZDATA);
BOOL SetupWizard(LPWIZDATA);

//
// Main appwiz property sheet
//
BOOL_PTR CALLBACK AppListDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK InstallUninstallDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
//  Pushes the "OK" button on a property sheet.
//
void DismissCPL(LPWIZDATA);

//
// Setup wizard pages
//
BOOL_PTR CALLBACK SetupDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrFinishDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK ChgusrFinishPrevDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
// Shortcut wizard pages
//
BOOL_PTR CALLBACK BrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK SetupBrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK PickFolderDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK GetTitleDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

//
// Function in Folder.C that is used for removing folders from the task bar
// property sheet.
//
BOOL RemoveItemsDialog(HWND hParent);


//
// Strips "@" characters from a string resource and replaces them with NULLs
// Returns TRUE if succeeded
//
EXTERN_C BOOL LoadAndStrip(int id, LPTSTR lpsz, int cbstr);

//
// Exec the program.  Used by Setup and AppList
//
BOOL ExecSetupProg(LPWIZDATA lpwd, BOOL ForceWx86, BOOL bMinWiz);

//
// Skip to next string in doubly null terminated string
//
LPTSTR SkipStr(LPTSTR);

//
// Used by all wizard sheets at WM_INITDIALOG
//
LPWIZDATA InitWizSheet(HWND hDlg, LPARAM lParam, DWORD dwFlags);

//
// Used by all wizard sheets at PSN_RESET
//
void CleanUpWizData(LPWIZDATA lpwd);

//
// Thunked exports for 16-bit apps/dlls
//
void InstallCPL(HWND hwnd, UINT nStartPage);

//
// Functions for links
//
BOOL CreateLink(LPWIZDATA);
BOOL GetLinkName(LPTSTR, UINT cch, LPWIZDATA);


//
// Created by the thunk scripts
//
BOOL WINAPI Pif3216_ThunkConnect32(LPCTSTR pszDll16, LPCTSTR pszDll32, HANDLE hIinst, DWORD dwReason);
BOOL WINAPI Pif1632_ThunkConnect32(LPCTSTR pszDll16, LPCTSTR pszDll32, HANDLE hIinst, DWORD dwReason);


BOOL GetSingleAppInfo(LPWIZDATA);

//
// Gets the INF name for install programs.  Returns false if none.
//
BOOL AppListGetInfName(LPWIZDATA);

//
//  Functions determine info about lpwd->szExeName
//
void DetermineExeType(LPWIZDATA);

//
//  Fills in the szProgDesc field of the wizdata structure.
//
BOOL DetermineDefaultTitle(LPWIZDATA);

//
//  Strip the extension off of a file name.
//
void StripExt(LPTSTR lpsz);

//
// Global data
//
extern int g_cxIcon;
extern int g_cyIcon;

extern TCHAR const c_szPIF[];
extern TCHAR const c_szLNK[];


#ifdef WX86
//
// from uninstal.c
//
extern BOOL bWx86Enabled;
extern BOOL bForceX86Env;
extern const WCHAR ProcArchName[];
#endif

#endif // _APPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\appwizid.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by WIZ.RC
//

#define DLG_APPLIST             100
#define DLG_INSTUNINSTALL       101

#define DLG_BROWSE              200
#define DLG_PICKFOLDER          201
#define DLG_GETTITLE            202
#define DLG_PICKICON            203

#define DLG_SETUP               300
#define DLG_SETUPBROWSE         301

#define DLG_CHGUSR                      302
#define DLG_CHGUSR_UNINSTALL            303
#define DLG_CHGUSRFINISH                304
#define DLG_CHGUSRFINISH_PREV           305

#define DLG_UNCUNINSTALLBROWSE  306
#define DLG_MULTIUSERWARNING    307

#define DLG_DELITEM             400

#define IDC_RADIO1                      1001
#define IDC_RADIO2                      1002

#define IDC_BUTTONSETUPFROMLIST 1000
#define IDC_BUTTONSETUP         1001
#define IDC_CMDSTATIC           1002
#define IDC_COMMAND             1003
#define IDC_BROWSE              1004
#define IDC_SEARCHNAME          1005
#define IDC_SEARCHICON          1006
#define IDC_FROMLIST            1009
#define IDC_FROMDISK            1010
#define IDC_APPLIST             1011
#define IDC_SETUPMSG            1012
#define IDC_ICON_WARNING        1013
#define IDC_SWITCHUSER          1014
#define IDC_SWITCHUSER_TEXT     1017

#define IDC_WIZBMP              1019
#define IDC_TITLE               1020
#define IDC_ICONLIST            1021
#define IDC_FOLDERTREE          1022

#define IDC_REGISTERED_APPS     1025
#define IDC_MODIFYUNINSTALL     1026

#define IDC_BASEBUTTONS         1060
#define IDC_MODIFY              IDC_BASEBUTTONS
#define IDC_REPAIR              IDC_BASEBUTTONS + 1
#define IDC_UNINSTALL           IDC_BASEBUTTONS + 2

#define IDC_NEWFOLDER           1027
#define IDC_DELFOLDER           1028

#define IDC_DELETEITEM          1030
#define IDC_TEXT                1031

#define IDC_INSTINSTR           1040
#define IDC_INSTICON            1041
#define IDC_UNINSTINSTR         1042
#define IDC_UNINSTICON          1043

#define IDC_FORCEX86ENV         1045

#define IDC_NETINSTINSTR        1050
#define IDC_NETINSTICON         1051

#define IDS_UNINSTINSTR         1065
#define IDS_UNINSTINSTR_NEW     1066
#define IDS_UNINSTINSTR_LEGACY  1067

//#define IDC_

#define IDC_STATIC              -1

//
//  Icons
//
#define IDI_CPLICON             1500
#define IDI_LISTINST            1501
#define IDI_DISKINST            1502
#define IDI_UNINSTALL           1503
#define IDI_DEFPROGS            1504    // used by syssetup.inx

#define IDS_NAME                2001
#define IDS_INFO                2002
#define IDS_BADPATHMSG          2003
#define IDS_SETUPPRGNAMES       2004
#define IDS_HAVESETUPPRG        2005
#define IDS_NOSETUPPRG          2006
#define IDS_TSHAVESETUPPRG      2007

#define IDS_INSERTDISK          2008
#define IDS_SEARCHING           2009
#define IDS_EXTENSIONS          2010
#define IDS_BADSETUP            2011
#define IDS_DUPLINK             2012
#define IDS_BROWSEEXT           2014
#define IDS_BROWSEFILTER        2015
#define IDS_BROWSETITLE         2016
//      -- unused --            2017
//      -- unused --            2018
#define IDS_SPECIALCASE         2019
#define IDS_BROWSEFILTERMSI     2020

//      -- unused --            2021
//      -- unused --            2022
//      -- unused --            2023
//      -- unused --            2024
//      -- unused --            2025
//      -- unused --            2026
#define IDS_NOSHORTCUT          2027

#define IDS_SETUPAPPNAMES       2028

#define IDS_UNINSTALL_ERROR         2030
#define IDS_UNINSTALL_FAILED        2031
//      -- unused --                2032
//      -- unused --                2033
#define IDS_CANTDELETE              2035
#define IDS_NEWFOLDERSHORT          2036
#define IDS_NEWFOLDERLONG           2037
#define IDS_NONESEL                 2038
//      -- unused --                2040
//      -- unused --                2041
#define IDS_UNINSTALL_UNCUNACCESSIBLE 2042
#define IDS_CONFIGURE_FAILED        2043
#define IDS_CANT_REMOVE_FROM_REGISTRY 2044

#define IDS_MODNAME                 2060

#define IDS_FILEFOLDERBROWSE_TITLE  2072

#define IDS_CHGUSROPT               2081
#define IDS_CHGUSRINSTALL           2082
#define IDS_CHGUSREXECUTE           2083
#define IDS_CHGUSRTITLE             2084
#define IDS_GETINI_FAILED           2085
#define IDS_SETINI_FAILED           2086
#define IDS_CHGUSRUNINSTALL         2087
#define IDS_CHGUSRUNEXECUTE         2088
#define IDS_CHGUSRUNINSTALLMSG		2089
#define IDS_QUERYVALUE_FAILED       2090
#define IDS_CHGUSRFINISH		    2091
#define IDS_CHGUSRFINISH_PREV		2092

#define IDS_INSTALL_ERROR_GENERIC   2100
#define IDS_INSTALL_TRANSFORMCONFLICTS      2101
#define IDS_UNINSTALL_ERROR_GENERIC   2102
#define IDS_MODIFY_ERROR_GENERIC   2103
#define IDS_REPAIR_ERROR_GENERIC   2104

#define IDB_INSTALLBMP          5000
#define IDB_SHORTCUTBMP         5001
//      -- unused ---           5002
#define IDB_LEGACYINSTALLBMP    5003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\arp.h ===
// ARP.h
//

// Default position and size
#define ARP_DEFAULT_POS_X    35
#define ARP_DEFAULT_POS_Y    10
#define ARP_DEFAULT_WIDTH    730
#define ARP_DEFAULT_HEIGHT   530

// Class definitions

// Frame

// Thread-safe API types
#define ARP_SETINSTALLEDITEMCOUNT             0   // pData is count
#define ARP_DECREMENTINSTALLEDITEMCOUNT       1   
#define ARP_INSERTINSTALLEDITEM               2   // InsertItemData struct
#define ARP_INSERTPUBLISHEDITEM               3
#define ARP_INSERTOCSETUPITEM                 4
#define ARP_SETPUBLISHEDFEEDBACKEMPTY         5
#define ARP_POPULATECATEGORYCOMBO             6
#define ARP_PUBLISHEDLISTCOMPLETE             7
#define ARP_SETPUBLISHEDITEMCOUNT             8
#define ARP_DECREMENTPUBLISHEDITEMCOUNT       9
#define ARP_DONEINSERTINSTALLEDITEM           10

#define WM_ARPWORKERCOMPLETE                  WM_USER + 1024

Element* FindDescendentByName(Element* peRoot, LPCWSTR pszName);
Element* GetNthChild(Element *peRoot, UINT index);

// Thread-safe API structures
struct InsertItemData
{
    IInstalledApp* piia;
    IPublishedApp* pipa;
    PUBAPPINFO* ppai;
    COCSetupApp* pocsa;

    WCHAR pszTitle[MAX_PATH];
    WCHAR pszImage[MAX_PATH];
    int iIconIndex;
    ULONGLONG ullSize;
    FILETIME ftLastUsed;
    int iTimesUsed;    
    DWORD dwActions;
    bool bSupportInfo;
    bool bDuplicateName;
};

enum SortType
{
    SORT_NAME = 0,
    SORT_SIZE,
    SORT_TIMESUSED,
    SORT_LASTUSED,
};

class ARPClientCombo;
class Expando;
class Clipper;
class ClientBlock;

enum CLIENTFILTER {
        CLIENTFILTER_OEM,
    CLIENTFILTER_MS,
    CLIENTFILTER_NONMS,
};

class ARPSelector: public Selector
{
public:
    static HRESULT Create(OUT Element** ppElement);
   
    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // Bypass Selector::OnKeyFocusMoved because Selector will change the
    // selection when focus changes, but we don't want that.
    virtual void OnKeyFocusMoved(Element *peFrom, Element *peTo) {Element::OnKeyFocusMoved(peFrom, peTo);}

    virtual Element *GetAdjacent(Element *peFrom, int iNavDir, NavReference const *pnr, bool bKeyable);
};

class ARPFrame : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, bool bDblBuffer, OUT Element** ppElement);

    // Initialize IDs and hold parser, called after contents are filled
    bool Setup(Parser* pParser, int uiStartPane);

    // Thread-safe APIs (do any additional work on callers thread and then marshal)
    void SetInstalledItemCount(UINT cItems);
    void DecrementInstalledItemCount();
    void SetPublishedItemCount(UINT cItems);
    void DecrementPublishedItemCount();
    void SortItemList();
    void SortList(int iNew, int iOld);
    CompareCallback GetCompareFunction();
    void InsertInstalledItem(IInstalledApp* piia);
    void InsertPublishedItem(IPublishedApp* pipa, bool bDuplicateName);
    void InsertOCSetupItem(COCSetupApp* pocsa);
    void PopulateCategoryCombobox();
    SHELLAPPCATEGORYLIST* GetShellAppCategoryList() {return _psacl;}
    void SetShellAppCategoryList(SHELLAPPCATEGORYLIST* psacl) {_psacl = psacl;}
    LPCWSTR GetCurrentPublishedCategory();
    void FeedbackEmptyPublishedList();
    void DirtyPublishedListFlag();
    void DirtyInstalledListFlag();
    void RePopulateOCSetupItemList();
    bool OnClose();     // return 0 to fail

    // Generic events
    virtual void OnEvent(Event* pEvent);
//
// NTRAID#NTBUG9-314154-2001/3/12-brianau   Handle Refresh
//
//    Need to finish this for Whistler.
//
    virtual void OnInput(InputEvent *pEvent);
//
    virtual void OnKeyFocusMoved(Element* peFrom, Element* peTo);
    void OnPublishedListComplete();
    virtual void RestoreKeyFocus() { if(peLastFocused) peLastFocused->SetKeyFocus();}    
    virtual bool CanSetFocus();
    bool GetPublishedComboFilled() {return _bPublishedComboFilled;}
    void SetPublishedComboFilled(bool bPublishedComboFilled) {_bPublishedComboFilled = bPublishedComboFilled;}
    bool GetPublishedListFilled () {return _bPublishedListFilled;}
    void SetPublishedListFilled (bool bPublishedListFilled) {_bPublishedListFilled = bPublishedListFilled;}
    bool IsChangeRestricted();
    virtual SetModalMode(bool ModalMode) { _bInModalMode = ModalMode;}
    HWND GetHostWindow() {if (_pnhh) return _pnhh->GetHWND(); return NULL;}
    void SelectInstalledApp(IInstalledApp* piia);
    void SelectClosestApp(IInstalledApp* piia);
    void UpdateInstalledItems();    
    void RunOCManager();
    void ChangePane(Element *pePane);
    void PutFocusOnList(Selector* peList);

    // If all else fails, focus goes to the Places pane
    Element* FallbackFocus() { return _peOptionList->GetSelection(); }

    HRESULT InitClientCombos(Expando* pexParent, CLIENTFILTER cf);

    HRESULT CreateStyleParser(Parser** ppParser);

    Parser* GetStyleParser() { return _pParserStyle; }
    HRESULT CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement)
    {
        return _pParser->CreateElement(pszResID, peSubstitute, ppElement);
    }

    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // We allocate zero-initialized so you don't need to set things to 0.
    ARPFrame() {_bInDomain = true; _curCategory = CB_ERR; }
    virtual ~ARPFrame();
    HRESULT Initialize(NativeHWNDHost* pnhh, bool fDlbBuffer);

    // Callee thread-safe invoke sink
    virtual void OnInvoke(UINT nType, void* pData);

    // HACK!  The value of 350ms is hard-coded here and in DirectUI
    void ManageAnimations();
    bool IsFrameAnimationEnabled() { return _bAnimationEnabled; }
    int GetAnimationTime() { return IsFrameAnimationEnabled() ? 350 : 0; }

    ClientBlock* FindClientBlock(LPCWSTR pwszType);
    HRESULT LaunchClientCommandAndWait(UINT ids, LPCTSTR pszName, LPTSTR pszCommand);
    void InitProgressDialog();
    void SetProgressFakeMode(bool bFake) { _bFakeProgress = bFake; }
    void SetProgressDialogText(UINT ids, LPCTSTR pszName);
    void EndProgressDialog();

    // Managing the OK button.
    void BlockOKButton()
    {
        if (++_cBlockOK == 1) {
            _peOK->SetEnabled(false);
        }
    }
    void UnblockOKButton()
    {
        if (--_cBlockOK == 0) {
            _peOK->SetEnabled(true);
        }
    }

private:
    NativeHWNDHost* _pnhh;

    // ARP parser (tree resources)
    Parser* _pParser;
    
    // ARP parser for styles (multiple UI files available for different looks)
    Parser* _pParserStyle;
    BOOL _fThemedStyle;
    HANDLE _arH[LASTHTHEME+1];

    // ARP frame option list (navigation bar)
    ARPSelector* _peOptionList;

    // ARP installed item list
    Selector* _peInstalledItemList;
    HDSA _hdsaInstalledItems;
    int _cMaxInstalledItems;

    // ARP published item list
    Selector* _pePublishedItemList;
    HDSA _hdsaPublishedItems;
    int _cMaxPublishedItems;

    // ARP OC Setup item list
    Selector* _peOCSetupItemList;        

    // ARP Current item list
    Selector* _peCurrentItemList;

    // ARP Sort by Combobox
    Combobox* _peSortCombo;

    SHELLAPPCATEGORYLIST* _psacl;
    
    // ARP Published Category Combobox
    Combobox* _pePublishedCategory;
    Element*  _pePublishedCategoryLabel;
    int _curCategory;
    
    Element* peFloater;
    Element* peLastFocused;

    // ARP "customization block" element
    ARPSelector* _peClientTypeList;         // The outer selector

    Expando*     _peOEMClients;             // The four "big switches"
    Expando*     _peMSClients;
    Expando*     _peNonMSClients;
    Expando*     _peCustomClients;

    Element*     _peOK;                     // How to get out
    Element*     _peCancel;

    // ARP Panes
    Element* _peChangePane;
    Element* _peAddNewPane;
    Element* _peAddRmWinPane;
    Element* _pePickAppPane;

    // Number of items blocking the OK button from being enabled
    // (If this is 0, then OK is enabled)
    int      _cBlockOK;

    // ARP Current Sort Type
    SortType CurrentSortType;

    bool _bTerminalServer;
    bool _bPublishedListFilled;
    bool _bInstalledListFilled;
    bool _bOCSetupListFilled;    
    bool _bPublishedComboFilled;
    bool _bDoubleBuffer;
    bool _bInModalMode;
    bool _bSupportInfoRestricted;
    bool _bOCSetupNeeded;
    bool _bInDomain;
    bool _bAnimationEnabled;
    bool _bPickAppInitialized;
    bool _bFakeProgress;
    UINT _uiStartPane;
    class ARPHelp* _pah;

    IProgressDialog* _ppd;
    DWORD   _dwProgressTotal;
    DWORD   _dwProgressSoFar;

    bool ShowSupportInfo(APPINFODATA *paid);
    void PrepareSupportInfo(Element* peHelp, APPINFODATA *paid);
    void RePopulatePublishedItemList();

    // Check for policies, apply as needed.
    void ApplyPolices();

public:

    // ARPFrame IDs (for identifying targets of events)
    static ATOM _idChange;
    static ATOM _idAddNew;
    static ATOM _idAddRmWin;
    static ATOM _idClose;
    static ATOM _idAddFromDisk;
    static ATOM _idAddFromMsft;
    static ATOM _idComponents;
    static ATOM _idSortCombo;
    static ATOM _idCategoryCombo;
    static ATOM _idAddFromCDPane;
    static ATOM _idAddFromMSPane;
    static ATOM _idAddFromNetworkPane;
    static ATOM _idAddWinComponent;
    static ATOM _idPickApps;
    static ATOM _idOptionList;

    // Helper thread handles
    static HANDLE htPopulateInstalledItemList;
    static HANDLE htPopulateAndRenderOCSetupItemList;    
    static HANDLE htPopulateAndRenderPublishedItemList;

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

// Item
class ARPItem : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    void SortBy(int iNew, int iOld);

    // ARP item IDs
    static ATOM _idTitle;
    static ATOM _idIcon;
    static ATOM _idSize;
    static ATOM _idFreq;
    static ATOM _idLastUsed;
    static ATOM _idExInfo;
    static ATOM _idInstalled;    
    static ATOM _idChgRm;
    static ATOM _idChg;
    static ATOM _idRm;
    static ATOM _idAdd;
    static ATOM _idConfigure;
    static ATOM _idSupInfo;
    static ATOM _idItemAction;
    static ATOM _idRow[3];

    IInstalledApp* _piia;
    IPublishedApp* _pipa;
    PUBAPPINFO* _ppai;

    COCSetupApp* _pocsa;

    ARPFrame*    _paf;
    UINT           _iTimesUsed;
    FILETIME       _ftLastUsed;
    ULONGLONG      _ullSize;
    UINT         _iIdx;

    ARPItem() { _piia = NULL; _pipa = NULL; _ppai =  NULL; _paf = NULL; _pocsa = NULL;}
    virtual ~ARPItem();
    HRESULT Initialize();
    void ShowInstalledString(BOOL bInstalled);

};

// Help box
class ARPHelp : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement);
    
    NativeHWNDHost* GetHost() {return _pnhh;}

    virtual void OnDestroy();

    // Generic events
    virtual void OnEvent(Event* pEvent);
    void ARPHelp::SetDefaultFocus();

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPHelp() {_paf =  NULL;}
    virtual ~ARPHelp();
    HRESULT Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer);

private:
    NativeHWNDHost* _pnhh;
    ARPFrame* _paf;
    HRESULT Initialize();
};

class ARPSupportItem : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // Property definitions
    static PropertyInfo* URLProp;

    // Quick property accessors
    const LPWSTR GetURL(Value** ppv)                   DUIQuickGetterInd(GetString(), URL, Specified)
    HRESULT SetURL(LPCWSTR v)                          DUIQuickSetter(CreateString(v), URL)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPSupportItem() { }
    virtual ~ARPSupportItem() { }
    HRESULT Initialize();    

private:
    Element* GetChild(UINT index);
};

class CLIENTINFO
{
public:
    static CLIENTINFO* Create(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey);
    void Delete() { HDelete(this); }

    static int __cdecl QSortCMP(const void*, const void*);
    bool IsSentinel() { return _pszKey == NULL; }
    bool IsKeepUnchanged() { return IsSentinel() && _pe; }
    bool IsPickFromList() { DUIAssertNoMsg(_pe || IsSentinel()); return !_pe; }

    void SetFriendlyName(LPCWSTR pszName)
    {
        FindDescendentByName(_pe, L"radiotext")->SetContentString(pszName);
        FindDescendentByName(_pe, L"setdefault")->SetAccName(pszName);
    }

    void SetMSName(LPCWSTR pszMSName);

    LPCWSTR GetFilteredName(CLIENTFILTER cf)
    {
        LPCWSTR pszName = _pszName;
        if (cf == CLIENTFILTER_MS && _pvMSName && _pvMSName->GetString())
        {
            pszName = _pvMSName->GetString();
        }
        return pszName;
    }

    Element* GetSetDefault()
    {
        return FindDescendentByName(_pe, L"setdefault");
    }

    Element* GetShowCheckbox()
    {
        return FindDescendentByName(_pe, L"show");
    }

    HRESULT SetShowCheckbox(bool bShow)
    {
        return GetShowCheckbox()->SetSelected(bShow);
    }

    bool IsShowChecked()
    {
        return GetShowCheckbox()->GetSelected();
    }

    bool GetInstallFile(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf, bool fFile);
    bool GetInstallCommand(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf);

public:
    ~CLIENTINFO(); // to be used only by HDelete()

private:
    bool Initialize(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey);

public:
    LPWSTR  _pszKey;
    LPWSTR  _pszName;
    Value * _pvMSName;
    Element*_pe;
    bool    _bShown;            // Actual show/hide state
    bool    _bOEMDefault;       // Is this the OEM default client?
    TRIBIT  _tOEMShown;         // OEM desired show/hide state
};

class StringList
{
public:
    StringList() { DUIAssertNoMsg(_pdaStrings == NULL && _pszBuf == NULL); }
    HRESULT SetStringList(LPCTSTR pszInit); // semicolon-separated list
    void Reset();
    ~StringList() { Reset(); }
    bool IsStringInList(LPCTSTR pszFind);

private:
    DynamicArray<LPTSTR>*   _pdaStrings;
    LPTSTR                  _pszBuf;
};

class ClientPicker: public Element
{
    typedef Element super;         // name for our superclass

public:
    static HRESULT Create(OUT Element** ppElement);

    // overrides
    virtual ~ClientPicker();
    HRESULT Initialize();

    // Property definitions
    static PropertyInfo* ClientTypeProp;
    static PropertyInfo* ParentExpandedProp;

    // Quick property accessors
    const LPWSTR GetClientTypeString(Value** ppv) { return (*ppv = GetValue(ClientTypeProp, PI_Specified))->GetString(); }
    HRESULT SetClientTypeString(LPCWSTR v) DUIQuickSetter(CreateString(v), ClientType)
    bool GetParentExpanded() DUIQuickGetter(bool, GetBool(), ParentExpanded, Specified)
    HRESULT SetParentExpanded(bool v) DUIQuickSetter(CreateBool(v), ParentExpanded)

    // System events
    virtual void OnEvent(Event* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // Customization
    CLIENTFILTER GetFilter() { return _cf; }
    HRESULT SetFilter(CLIENTFILTER cf, ARPFrame* paf);

    HRESULT TransferToCustom();

    // to be used by ClientBlock::InitializeClientPicker
    DynamicArray<CLIENTINFO*>* GetClientList() { return _pdaClients; }
    void AddClientToOEMRow(LPCWSTR pszName, CLIENTINFO* pci);
    HRESULT AddKeepUnchanged(CLIENTINFO* pciKeepUnchanged);
    void SetNotEmpty() { _bEmpty = false; }

    // to be used by SetFilterCB
    bool IsEmpty() { return _bEmpty; }

    // to be used by ClientBlock::TransferFromClientPicker
    CLIENTINFO* GetSelectedClient();

    // to be used by ARPFrame when metrics change
    void CalculateWidth();

private:
    static void CALLBACK s_DelayShowCombo(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    void _DelayShowCombo();
    void _CancelDelayShowCombo();
    bool _NeedsCombo() { return GetClientList()->GetSize() > 1; }
    void _SyncUIActive();
    void _SetStaticText(LPCWSTR pszText);
    void _CheckBlockOK(bool bSelected);

private:
    int                       _iSel;
    CLIENTFILTER              _cf;
    bool                      _bFilledCombo;
    bool                      _bEmpty;
    bool                      _bUIActive;
    bool                      _bBlockedOK;      // did I block the OK button?
    HWND                      _hwndHost;
    DynamicArray<CLIENTINFO*>*_pdaClients;
    Element*                  _peStatic;
    Combobox*                 _peCombo;
    ClientBlock*              _pcb;             // associated client block
public:                                         // manipulated from ClientBlock
    Element*                  _peShowHide;
};

class ClientBlock : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Property definitions
    static PropertyInfo* ClientTypeProp;
    static PropertyInfo* WindowsClientProp;
    static PropertyInfo* OtherMSClientsProp;
    static PropertyInfo* KeepTextProp;
    static PropertyInfo* KeepMSTextProp;
    static PropertyInfo* PickTextProp;

    // Quick property accessors
    const LPWSTR GetClientTypeString(Value** ppv) DUIQuickGetterInd(GetString(), ClientType, Specified)
    HRESULT SetClientTypeString(LPCWSTR v) DUIQuickSetter(CreateString(v), ClientType)
    const LPWSTR GetWindowsClientString(Value** ppv) DUIQuickGetterInd(GetString(), WindowsClient, Specified)
    HRESULT SetWindowsClientString(LPCWSTR v) DUIQuickSetter(CreateString(v), WindowsClient)
    const LPWSTR GetOtherMSClientsString(Value** ppv) DUIQuickGetterInd(GetString(), OtherMSClients, Specified)
    HRESULT SetOtherMSClientsString(LPCWSTR v) DUIQuickSetter(CreateString(v), OtherMSClients)
    const LPWSTR GetKeepTextString(Value** ppv) DUIQuickGetterInd(GetString(), KeepText, Specified)
    HRESULT SetKeepTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), KeepText)
    const LPWSTR GetKeepMSTextString(Value** ppv) DUIQuickGetterInd(GetString(), KeepMSText, Specified)
    HRESULT SetKeepMSTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), KeepMSText)
    const LPWSTR GetPickTextString(Value** ppv) DUIQuickGetterInd(GetString(), PickText, Specified)
    HRESULT SetPickTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), PickText)

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // overrides
    HRESULT Initialize();
    ~ClientBlock();

    // post-parse initialization
    HRESULT ParseCompleted(ARPFrame* paf);
    HRESULT AddStaticClientInfoToTop(PropertyInfo* ppi);
    HRESULT InitializeClientPicker(ClientPicker* pcp);
    HRESULT TransferFromClientPicker(ClientPicker* pcp);

    // doing actual work
    HRESULT Apply(ARPFrame* paf);

private:
    void _EnableShowCheckbox(Element* peRadio, bool fEnable);

    enum CBTIER {           // clients fall into one of these three tiers
        CBT_NONMS,          // third-party client
        CBT_MS,             // Microsoft client but not Windows default
        CBT_WINDOWSDEFAULT, // Windows default client
    };
    inline bool IsThirdPartyClient(CBTIER cbt) { return cbt == CBT_NONMS; }
    inline bool IsMicrosoftClient(CBTIER cbt) { return cbt >= CBT_MS; }
    inline bool IsWindowsDefaultClient(CBTIER cbt) { return cbt == CBT_WINDOWSDEFAULT; }

    CBTIER _GetClientTier(LPCTSTR pszClient);
    TRIBIT _GetFilterShowAdd(CLIENTINFO* pci, ClientPicker* pcp, bool* pbAdd);

    HKEY _OpenClientKey(HKEY hkRoot = HKEY_LOCAL_MACHINE, DWORD dwAccess = KEY_READ);
    bool _GetDefaultClient(HKEY hkClient, HKEY hkRoot, LPTSTR pszBuf, LONG cchBuf);
    bool _IsCurrentClientNonWindowsMS();
    void _RemoveEmptyOEMRow(Element* peShowHide, LPCWSTR pszName);

private:
    DynamicArray<CLIENTINFO*>*  _pdaClients;
    StringList                  _slOtherMSClients;
    Selector*                   _peSel;
};

class Expandable : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element; we just have a new property

    // Property definitions
    static PropertyInfo* ExpandedProp;

    // Quick property accessors
    bool GetExpanded()          DUIQuickGetter(bool, GetBool(), Expanded, Specified)
    HRESULT SetExpanded(bool v) DUIQuickSetter(CreateBool(v), Expanded)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

class Expando : public Expandable
{
    typedef Expandable super;       // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Event types
    static UID Click; // no parameters

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HRESULT Initialize();
    Clipper* GetClipper();

private:
    void FireClickEvent();

private:
    bool        _fExpanding;
};


class Clipper: public Expandable
{
    typedef Expandable super;       // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HRESULT Initialize();

private:
};

class AutoButton : public Button
{
    typedef Button super;           // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // misc public stuff
    void SyncDefAction();

private:
};

class GradientLine : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element
    // We use the foreground as the center color
    // and the background as the edge color

    // Rendering callbacks
    void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

private:
    COLORREF GetColorProperty(PropertyInfo* ppi);
};

class BigElement : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element; we just have a new property

    // Property definitions
    static PropertyInfo* StringResIDProp;

    // Quick property accessors
    int GetStringResID()            DUIQuickGetter(int, GetInt(), StringResID, Specified)
    HRESULT SetStringResID(int ids) DUIQuickSetter(CreateInt(ids), StringResID)

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

class ARPParser : public Parser
{
public:
    static HRESULT Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    HRESULT Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB);

    virtual Value* GetSheet(LPCWSTR pszResID);

private:
    ARPFrame* _paf;
    HANDLE    _arH[2];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\arp.cpp ===
// ARP.cpp : Add Remove Programs
//
#include "priv.h"
#define GADGET_ENABLE_TRANSITIONS

// Related services
#include <duser.h>
#include <directui.h>
#include "stdafx.h"
#include "appwizid.h"
#include "resource.h"

#include <winable.h>            // BlockInput
#include <process.h>            // Multi-threaded routines
#include "setupenum.h"
#include <tsappcmp.h>           // for TermsrvAppInstallMod
#include <comctrlp.h>           // for DPA stuff
#include "util.h"
#include <shstyle.h>

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);    // used by ScrollBar
UsingDUIClass(Thumb);           // used by ScrollBar
UsingDUIClass(ScrollBar);       // used by ScrollViewer
UsingDUIClass(Selector);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Combobox);

#include "shappmgrp.h"

#include "arp.h"

#define HRCHK(r)  if (FAILED(r)) goto Cleanup;

// Primary thread run flag
bool g_fRun = true;

// Appliction shutting down after run flag goes false
bool g_fAppShuttingDown = false;

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

inline void StrFree(LPWSTR psz)
{
    CoTaskMemFree(psz); // CoTaskMemFree handles NULL parameter
}

// Need this weirdo helper function to avoid compiler complaining that
// "bool is smaller than LPARAM, you're truncating!"  Do this only if
// you know that the LPARAM came from a bool originally.

bool UNCASTLPARAMTOBOOL(LPARAM lParam)
{
    return (bool&)lParam;
}

extern "C" void inline SetElementAccessability(Element* pe, bool bAccessible, int iRole, LPCWSTR pszAccName);

//  Client names are compared in English to avoid weirdness
//  with collation rules of certain languages.
inline bool AreEnglishStringsEqual(LPCTSTR psz1, LPCTSTR psz2)
{
    return CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, psz1, -1, psz2, -1) == CSTR_EQUAL;
}

//
//  Set the default action based on a resource ID in oleacc.
//

HRESULT SetDefAction(Element* pe, UINT oleacc)
{
    WCHAR szBuf[80];
    if (!GetRoleTextW(oleacc, szBuf, DUIARRAYSIZE(szBuf)))
    {
        szBuf[0] = TEXT('\0');
    }
    return pe->SetAccDefAction(szBuf);
}

////////////////////////////////////////////////////////
//  Tree traversal upwards
//

Element* _FindAncestorElement(Element* pe, IClassInfo* Class)
{
    while (pe && !pe->GetClassInfo()->IsSubclassOf(Class))
    {
        pe = pe->GetParent();
    }
    return pe;
}

template<class T>
T* FindAncestorElement(Element *pe)
{
    return (T*)_FindAncestorElement(pe, T::Class);
}

////////////////////////////////////////////////////////
//  Tree traversal downwards
//

typedef HRESULT (CALLBACK *_TRAVERSETREECB)(Element*, LPARAM);

//
//  _TraverseTree is the worker function for TraverseTree<T>.

HRESULT _TraverseTree(Element* pe, IClassInfo* Class, _TRAVERSETREECB lpfnCB, LPARAM lParam)
{
    HRESULT hr = S_OK;
    Value* pv;

    if (pe->GetClassInfo()->IsSubclassOf(Class)) {
        hr = lpfnCB(pe, lParam);
    }

    if (SUCCEEDED(hr))
    {
        ElementList* peList = pe->GetChildren(&pv);

        if (peList)
        {
            Element* peChild;
            for (UINT i = 0; SUCCEEDED(hr) && i < peList->GetSize(); i++)
            {
                peChild = peList->GetItem(i);
                hr = _TraverseTree(peChild, Class, lpfnCB, lParam);
            }

            pv->Release();
        }
    }

    return hr;
}


//  TraverseTree<T> walks the tree starting at pe and calls the callback
//  for each element of type T.  T is inferred from the callback function,
//  but for readability, it is suggested that you state it explicitly.
//
//  Callback should return S_OK to continue enumeration or a COM error
//  to stop enumeration, in which case the COM error code is returned as
//  the return value from TraverseTree.
//

template <class T>
HRESULT TraverseTree(Element* pe,
                     HRESULT (CALLBACK *lpfnCB)(T*, LPARAM), LPARAM lParam = 0)
{
    return _TraverseTree(pe, T::Class, (_TRAVERSETREECB)lpfnCB, lParam);
}

////////////////////////////////////////////////////////
//
//  When chunks of the tree go UI-inactive, you must manually
//  enable and disable accessibility on them.


HRESULT DisableElementAccessibilityCB(Element* pe, LPARAM)
{
    pe->SetAccessible(false);
    return S_OK;
}

HRESULT CheckAndEnableElementAccessibilityCB(Element* pe, LPARAM)
{
    if ( 0 != pe->GetAccRole())
    {
        pe->SetAccessible(true);
    }
    return S_OK;
}

void DisableElementTreeAccessibility(Element* pe)
{
    TraverseTree(pe, DisableElementAccessibilityCB);
}

void EnableElementTreeAccessibility(Element* pe)
{
    TraverseTree(pe, CheckAndEnableElementAccessibilityCB);
}

HRESULT DisableElementShortcutCB(Element* pe, LPARAM)
{
    pe->SetShortcut(0);
    return S_OK;
}

// When a tree is hidden or removed from layout permanently (due to
// restriction), we also have to remove all keyboard shortcuts so the
// user doesn't have a backdoor.
//
void DisableElementTreeShortcut(Element* pe)
{
    pe->SetVisible(false);
    TraverseTree(pe, DisableElementShortcutCB);
}

////////////////////////////////////////////////////////
// ARPFrame class
////////////////////////////////////////////////////////

// ARPFrame IDs (for identifying targets of events)
ATOM ARPFrame::_idChange = 0;
ATOM ARPFrame::_idAddNew = 0;
ATOM ARPFrame::_idAddRmWin = 0;
ATOM ARPFrame::_idClose = 0;
ATOM ARPFrame::_idAddFromDisk = 0;
ATOM ARPFrame::_idAddFromMsft = 0;
ATOM ARPFrame::_idComponents = 0;
ATOM ARPFrame::_idSortCombo = 0;
ATOM ARPFrame::_idCategoryCombo = 0;
ATOM ARPFrame::_idAddFromCDPane = 0;
ATOM ARPFrame::_idAddFromMSPane = 0;
ATOM ARPFrame::_idAddFromNetworkPane = 0;
ATOM ARPFrame::_idAddWinComponent = 0;
ATOM ARPFrame::_idPickApps = 0;
ATOM ARPFrame::_idOptionList = 0;

HANDLE ARPFrame::htPopulateInstalledItemList = NULL;
HANDLE ARPFrame::htPopulateAndRenderOCSetupItemList = NULL;    
HANDLE ARPFrame::htPopulateAndRenderPublishedItemList = NULL;

ARPFrame::~ARPFrame()
{
    UINT i;

    if (_psacl)
    {
        for (i = 0; i < _psacl->cCategories; i++)
        {
           if (_psacl->pCategory[i].pszCategory)
           {
               StrFree(_psacl->pCategory[i].pszCategory);
           }
        }
        delete _psacl;
    }

    if (_pParserStyle)
        _pParserStyle->Destroy();
    
    // Close theme handles (if applicable)
    for (i = FIRSTHTHEME; i <= LASTHTHEME; i++)
    {
        if (_arH[i])
            CloseThemeData(_arH[i]);
    }

    if (_arH[SHELLSTYLEHINSTANCE])
    {
        FreeLibrary((HMODULE)_arH[SHELLSTYLEHINSTANCE]);
    }

    EndProgressDialog();
}

HRESULT ARPFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPFrame::Create(NativeHWNDHost* pnhh, bool fDblBuffer, OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPFrame* paf = HNewAndZero<ARPFrame>();
    if (!paf)
        return E_OUTOFMEMORY;

    HRESULT hr = paf->Initialize(pnhh, fDblBuffer);
    if (FAILED(hr))
    {
        paf->Destroy();
        return hr;
    }

    *ppElement = paf;

    return S_OK;
}

HRESULT ARPFrame::Initialize(NativeHWNDHost* pnhh, bool fDblBuffer)
{
    // Initialize
    _pnhh = pnhh;
    _bDoubleBuffer = fDblBuffer;
    _pParserStyle = NULL;
    ZeroMemory(_arH, sizeof(_arH));
    _fThemedStyle = FALSE;
    _pParserStyle = NULL;
    _hdsaInstalledItems = NULL;
    _hdsaPublishedItems = NULL;
    _bAnimationEnabled = true;

    if (IsOS(OS_TERMINALSERVER))
    {
        _bTerminalServer = true;
    }
    else
    {
        _bTerminalServer = false;
    }

    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), fDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    CurrentSortType = SORT_NAME;

    hr = CreateStyleParser(&_pParserStyle);

    if (FAILED(hr) || !_pParserStyle || _pParserStyle->WasParseError())
        return hr;

    ManageAnimations();

    return S_OK;
}

HRESULT ARPFrame::CreateStyleParser(Parser** ppParser)
{
    HRESULT hr;

    // We always need these two
    _arH[THISDLLHINSTANCE] = g_hinst; // Default HINSTANCE
    _arH[XPSP1HINSTANCE] = g_hinst; // same HINSTANCE

    // And this one
    if (_arH[SHELLSTYLEHINSTANCE])
    {
        FreeLibrary((HMODULE)_arH[SHELLSTYLEHINSTANCE]);
    }
    _arH[SHELLSTYLEHINSTANCE] = SHGetShellStyleHInstance();

    // Store style and theme information
    // We cannot trust IsAppThemed() or IsThemeActive() because WindowBlinds
    // patches them to return hard-coded TRUE.  If we trusted it, then
    // we would think that we're using a theme-enabled shellstyle.dll and
    // fail when we try to load resources out of it.  Instead, sniff
    // the DLL to see if it has a control panel watermark bitmap.

    if (FindResource((HMODULE)_arH[SHELLSTYLEHINSTANCE],
                     MAKEINTRESOURCE(IDB_CPANEL_WATERMARK), RT_BITMAP))
    {
        _fThemedStyle = TRUE;
        // Populate handle list for theme style parsing
        _arH[BUTTONHTHEME] = OpenThemeData(GetHWND(), L"Button");
        _arH[SCROLLBARHTHEME] = OpenThemeData(GetHWND(), L"Scrollbar");
        _arH[TOOLBARHTHEME] = OpenThemeData(GetHWND(), L"Toolbar");

        hr = Parser::Create(IDR_ARPSTYLETHEME, _arH, ARPParseError, ppParser);
    }
    else
    {
        _fThemedStyle = FALSE;
        hr = Parser::Create(IDR_ARPSTYLESTD, _arH, ARPParseError, ppParser);
    }

    return hr;
}

extern "C" DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy);
extern "C" bool _cdecl ARPIsOnDomain();

//  Handy helper functions.

// Finds a descendent and asserts if not found.

Element* FindDescendentByName(Element* peRoot, LPCWSTR pszName)
{
    Element* pe = peRoot->FindDescendent(StrToID(pszName));
    DUIAssertNoMsg(pe);
    return pe;
}

// Finds a descendent but doesn't complain if not found.

Element* MaybeFindDescendentByName(Element* peRoot, LPCWSTR pszName)
{
    Element* pe = peRoot->FindDescendent(StrToID(pszName));
    return pe;
}

HRESULT _SendParseCompleted(ClientBlock* pcb, LPARAM lParam)
{
    return pcb->ParseCompleted((ARPFrame*)lParam);
}

// Initialize IDs and hold parser, called after contents are filled
bool ARPFrame::Setup(Parser* pParser, int uiStartPane)
{
    WCHAR szTemp[1024];

    _pParser = pParser;
    if (uiStartPane >= 0 && uiStartPane <= 3)
    {
        _uiStartPane = uiStartPane;
    }

    // Initialize ID cache
    _idChange = StrToID(L"change");
    _idAddNew = StrToID(L"addnew");
    _idAddRmWin = StrToID(L"addrmwin");
    _idClose = StrToID(L"close");
    _idAddFromDisk = StrToID(L"addfromdisk");
    _idAddFromMsft = StrToID(L"addfrommsft");
    _idComponents = StrToID(L"components");
    _idSortCombo = StrToID(L"sortcombo");
    _idCategoryCombo = StrToID(L"categorycombo");
    _idAddFromCDPane = StrToID(L"addfromCDPane");
    _idAddFromMSPane = StrToID(L"addfromMSpane");
    _idAddFromNetworkPane = StrToID(L"addfromNetworkpane");    
    _idAddWinComponent = StrToID(L"addwincomponent");
    _idPickApps = StrToID(L"pickapps");
    _idOptionList = StrToID(L"optionlist");

    // Find children
    _peOptionList             = (ARPSelector*)   FindDescendentByName(this, L"optionlist");
    _peInstalledItemList      = (Selector*)      FindDescendentByName(this, L"installeditemlist");
    _pePublishedItemList      = (Selector*)      FindDescendentByName(this, L"publisheditemlist");
    _peOCSetupItemList        = (Selector*)      FindDescendentByName(this, L"ocsetupitemlist");
    _peSortCombo              = (Combobox*)      FindDescendentByName(this, L"sortcombo");
    _pePublishedCategory      = (Combobox*)      FindDescendentByName(this, L"categorycombo");
    _pePublishedCategoryLabel = (Element*)       FindDescendentByName(this, L"categorylabel");
    _peClientTypeList         = (ARPSelector*)   FindDescendentByName(this, L"clienttypelist");
    _peOEMClients             = (Expando*)       FindDescendentByName(_peClientTypeList, L"oemclients");
    _peMSClients              = (Expando*)       FindDescendentByName(_peClientTypeList, L"msclients");
    _peNonMSClients           = (Expando*)       FindDescendentByName(_peClientTypeList, L"nonmsclients");
    _peCustomClients          = (Expando*)       FindDescendentByName(_peClientTypeList, L"customclients");
    _peOK                     =                  FindDescendentByName(this, L"ok");
    _peCancel                 =                  FindDescendentByName(this, L"cancel");
    _peCurrentItemList = NULL;

    _peChangePane   = FindDescendentByName(this, L"changepane");
    _peAddNewPane   = FindDescendentByName(this, L"addnewpane");
    _peAddRmWinPane = FindDescendentByName(this, L"addrmwinpane");
    _pePickAppPane  = FindDescendentByName(this, L"pickapppane");

    if (NULL != _peSortCombo)
    {
        LoadStringW(_pParser->GetHInstance(), IDS_APPNAME, szTemp, DUIARRAYSIZE(szTemp));     
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_SIZE, szTemp, DUIARRAYSIZE(szTemp));
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCY, szTemp, DUIARRAYSIZE(szTemp));
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_DATELASTUSED, szTemp, DUIARRAYSIZE(szTemp));    
        _peSortCombo->AddString(szTemp);
        _peSortCombo->SetSelection(0);
    }

    _bInDomain = ARPIsOnDomain();

    _bOCSetupNeeded = !!COCSetupEnum::s_OCSetupNeeded();

    // Apply polices as needed
    ApplyPolices();

    if(!_bOCSetupNeeded)
    {
        Element* pe = FindDescendentByName(this, L"addrmwinoc");
        DUIAssertNoMsg(pe);
        pe->SetLayoutPos(LP_None);
    }
    // Set initial selection of option list
    Element* peSel;
    switch(_uiStartPane)
    {
    case 3:
        peSel = FindDescendent(_idPickApps);
        break;

    case 2:
        peSel = FindDescendent(_idAddRmWin);        
        break;
    case 1:
        peSel = FindDescendent(_idAddNew);
        break;
    case 0:
    default:
        peSel = FindDescendent(_idChange);
        break;
    }

    // Set initial selection of style list
    DUIAssertNoMsg(peSel);
    _peOptionList->SetSelection(peSel);

    // initialize focus-following floater window
    peLastFocused = NULL;
    Element::Create(0, &peFloater);
    peFloater->SetLayoutPos(LP_Absolute);
    Add(peFloater);
    peFloater->SetBackgroundColor(ARGB(64, 255, 255, 0));

    ///////////////////////////////////////////////////////////////
    // Initialize the Pick Apps pane

    // Tell the clientblock elements that it's safe to initialize now
    if (FAILED(TraverseTree<ClientBlock>(this, _SendParseCompleted, (LPARAM)this)))
    {
        return false;
    }

    // Fill the client type lists
    InitClientCombos(_peOEMClients,    CLIENTFILTER_OEM);
    InitClientCombos(_peMSClients,     CLIENTFILTER_MS);
    InitClientCombos(_peNonMSClients,  CLIENTFILTER_NONMS);

    _peClientTypeList->SetSelection(_peCustomClients);
    _peCustomClients->SetExpanded(false);

    return true;
}

struct SETFILTERINFO {
    CLIENTFILTER   _cf;
    BOOL           _fHasApp;
    ARPFrame*      _paf;
};

HRESULT SetFilterCB(ClientPicker *pe, LPARAM lParam)
{
    SETFILTERINFO* pfi = (SETFILTERINFO*)lParam;
    HRESULT hr = pe->SetFilter(pfi->_cf, pfi->_paf);
    if (SUCCEEDED(hr) && !pe->IsEmpty())
    {
        pfi->_fHasApp = TRUE;
    }
    return hr;
}

HRESULT ARPFrame::InitClientCombos(Expando* pexParent, CLIENTFILTER cf)
{
    HRESULT hr;
    Element* pe;
    hr = _pParser->CreateElement(L"clientcategoryblock", NULL, &pe);
    if (SUCCEEDED(hr))
    {
        //
        // The client combos appear as the last element in the
        // clipped block.  The clipped block is the first (only)
        // child of the clipper.
        //
        GetNthChild(pexParent->GetClipper(), 0)->Add(pe);

        SETFILTERINFO sfi = { cf, FALSE, this };
        hr = TraverseTree<ClientPicker>(pe, SetFilterCB, (LPARAM)&sfi);
        if (sfi._cf == CLIENTFILTER_OEM && !sfi._fHasApp)
        {
            pexParent->SetLayoutPos(LP_None);
        }
    }
    pexParent->SetExpanded(false);

    return hr;
}

//
//  ARPFrame::FindClientBlock locates a ClientBlock by client type.
//
struct FINDCLIENTBLOCKINFO {
    LPCWSTR         _pwszType;
    ClientBlock*    _pcb;
};

HRESULT FindClientBlockCB(ClientBlock* pcb, LPARAM lParam)
{
    FINDCLIENTBLOCKINFO* pfcbi = (FINDCLIENTBLOCKINFO*)lParam;
    Value* pv;
    LPWSTR pwszType = pcb->GetClientTypeString(&pv);

    // Use LOCALE_INVARIANT so we aren't bitten by locales that do not
    // collate the same way as English.

    if (pwszType &&
        AreEnglishStringsEqual(pwszType, pfcbi->_pwszType))
    {
        pfcbi->_pcb = pcb;      // found it!
    }
    pv->Release();

    return S_OK;
}


ClientBlock* ARPFrame::FindClientBlock(LPCWSTR pwszType)
{
    FINDCLIENTBLOCKINFO fcbi = { pwszType, NULL };
    TraverseTree<ClientBlock>(this, FindClientBlockCB, (LPARAM)&fcbi);
    return fcbi._pcb;
}

/*
 *  You must be a member of the Administrators group in order to
 *  configure programs.  Being Power User isn't good enough because
 *  Power Users can't write to %ALLUSERSPROFILE%.
 */
BOOL CanConfigurePrograms()
{
    return IsUserAnAdmin();
}

void ARPFrame::ApplyPolices()
{
   Element* pe;

   if (ARPIsRestricted(L"NoSupportInfo"))
   {
       _bSupportInfoRestricted = true;
   }


   if (ARPIsRestricted(L"ShowPostSetup"))
   {
       _bOCSetupNeeded = true;
   }
   else if (ARPIsRestricted(L"NoServices"))
   {
       _bOCSetupNeeded = false;
   }
   
   pe = FindDescendent(_idChange);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoRemovePage"))
   {
       pe->SetLayoutPos(LP_None);
       if (0 == _uiStartPane)
        {
           _uiStartPane++;
        }
    }
   pe = FindDescendent(_idAddNew);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoAddPage"))
   {
       pe->SetLayoutPos(LP_None);
       if (1 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }
   else
   {
       if (ARPIsRestricted(L"NoAddFromCDorFloppy"))
       {
           pe = FindDescendent(_idAddFromCDPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);
           DisableElementTreeShortcut(pe);
       }
       if (ARPIsRestricted(L"NoAddFromInternet"))
       {
           pe = FindDescendent(_idAddFromMSPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
           DisableElementTreeShortcut(pe);
       }
       if (!_bInDomain || ARPIsRestricted(L"NoAddFromNetwork"))
       {
           pe = FindDescendent(_idAddFromNetworkPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
           DisableElementTreeShortcut(pe);
       }
   }
   pe = FindDescendent(_idAddRmWin);
   DUIAssertNoMsg(pe);

   // Note that in real ARP, we will never end up here with all thre panes disabled since we check for that before doing anything elese.
   if (ARPIsRestricted(L"NoWindowsSetupPage"))
   {
       pe->SetLayoutPos(LP_None);
       DisableElementTreeShortcut(pe);
       if (2 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }

  pe = FindDescendent(_idAddWinComponent);
  DUIAssertNoMsg(pe);
  if (ARPIsRestricted(L"NoComponents"))
  {
      pe->SetVisible(false);
      DisableElementTreeShortcut(pe);
  }

   // Remove the "pick apps" page entirely if we are on Server or embedded
   // ("Choose Programs" is a workstation-only feature)
   // or it is restricted
   // (
   pe = FindDescendent(_idPickApps);
   DUIAssertNoMsg(pe);

   if (IsOS(OS_ANYSERVER) ||
       IsOS(OS_EMBEDDED) ||
       ARPIsRestricted(L"NoChooseProgramsPage"))
   {
       pe->SetLayoutPos(LP_None);
       DisableElementTreeShortcut(pe);
       if (3 == _uiStartPane)
        {
           _uiStartPane++;
        }
    }
    else
    {
       // DUI doesn't support content=rcicon so we have to set it manually
       HICON hico = (HICON)LoadImage(g_hinst, MAKEINTRESOURCE(IDI_DEFPROGS), IMAGE_ICON, 32, 32, 0);
       if (hico)
       {
           Value *pv = Value::CreateGraphic(hico);
           if (pv)
           {
               GetNthChild(pe, 0)->SetValue(ContentProp, PI_Local, pv);
               pv->Release();
           }
       }

       // Neuter the "pick apps" page if the user can't configure apps
       if (!CanConfigurePrograms()) {
            pe = FindDescendentByName(_pePickAppPane, L"pickappadmin");
            pe->SetVisible(false);
            DisableElementTreeShortcut(pe);
            pe = FindDescendentByName(_pePickAppPane, L"pickappnonadmin");
            pe->SetVisible(true);
       }
    }

}

bool ARPFrame::IsChangeRestricted()
{
   return ARPIsRestricted(L"NoRemovePage")? true : false;
}

void ARPFrame::RunOCManager()
{
    // Invoke Add/Remove Windows components
    // Command to invoke and OCMgr: "sysocmgr /y /i:%systemroot%\system32\sysoc.inf"
    WCHAR szInf[MAX_PATH];
    WCHAR szPath[MAX_PATH];
    if ( GetSystemDirectoryW(szPath, MAX_PATH) && PathCombineW(szInf, szPath, L"sysoc.inf") &&
         PathCombineW(szPath, szPath, L"sysocmgr.exe") )
    {
        WCHAR szParam[MAX_PATH];
        StringCchPrintf(szParam, ARRAYSIZE(szParam), L"/y /i:%s", szInf);
        ShellExecuteW(NULL, NULL, szPath, szParam, NULL, SW_SHOWDEFAULT);
    }
}

DWORD WINAPI PopulateInstalledItemList(void* paf);

void ARPFrame::UpdateInstalledItems()
{
    if (!IsChangeRestricted())
    {
        _peInstalledItemList->RemoveAll();
        _bInstalledListFilled = false;

        // Start second thread for item population
        //_beginthread(PopulateInstalledItemList, 0, (void*)this);
        if (!htPopulateInstalledItemList && g_fRun)
            htPopulateInstalledItemList = CreateThread(NULL, 0, PopulateInstalledItemList, (void*)this, 0, NULL);
    }
}

////////////////////////////////////////////////////////
// Generic eventing

// Helper
inline void _SetElementSheet(Element* peTarget, ATOM atomID, Value* pvSheet, bool bSheetRelease = true)
{
    if (pvSheet)
    {
        Element* pe = peTarget->FindDescendent(atomID);
        DUIAssertNoMsg(pe);
        pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
        if (bSheetRelease)
            pvSheet->Release();
    }
} 

BOOL IsValidFileTime(FILETIME ft)
{
    return ft.dwHighDateTime || ft.dwLowDateTime;
}

BOOL IsValidSize(ULONGLONG ull)
{
    return ull != (ULONGLONG)-1;
}

BOOL IsValidFrequency(int iTimesUsed)
{
    return iTimesUsed >= 0;
}

void CALLBACK
_UnblockInputCallback(HWND /*hwnd*/, UINT /*uMsg*/, UINT_PTR idEvent, DWORD /*dwTime*/)
{
    BlockInput(FALSE);
    KillTimer(NULL, idEvent);
}

void _BlockDoubleClickInput(void)
{
    if (SetTimer(NULL, 0, GetDoubleClickTime(), _UnblockInputCallback))
    {
        BlockInput(TRUE);
    }
}


//#ifdef NEVER
//
// NTRAID#NTBUG9-314154-2001/3/12-brianau   Handle Refresh
//
//    Need to finish this for Whistler.
//

DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf);
DWORD WINAPI PopulateAndRenderOCSetupItemList(void* paf);
void EnablePane(Element* pePane, bool fEnable);

void ARPFrame::OnInput(InputEvent *pEvent)
{
    if (GMF_BUBBLED == pEvent->nStage)
    {
        if (GINPUT_KEYBOARD == pEvent->nCode)
        {
            KeyboardEvent *pke = (KeyboardEvent *)pEvent;
            if (VK_F5 == pke->ch)
            {
                if (_peCurrentItemList)
                {
                    if (_peCurrentItemList == _peInstalledItemList)
                    {
                        UpdateInstalledItems();
                    }
                    else if (_peCurrentItemList == _pePublishedItemList)
                    {
                        RePopulatePublishedItemList();
                    }
                    else if (_peCurrentItemList == _peOCSetupItemList)
                    {
                        RePopulateOCSetupItemList();
                    }
                }
            }
        }
    }
    HWNDElement::OnInput(pEvent);
}
//#endif

HRESULT SetVisibleClientCB(ClientPicker *pe, LPARAM lParam)
{
    pe->SetVisible(UNCASTLPARAMTOBOOL(lParam));
    return TRUE;
}

//
//  This hides the controls that belong to the old pane and shows the
//  controls that belong to the new pane.
//
void ARPFrame::ChangePane(Element *pePane)
{
    bool fEnable;

    // Show/hide elements that belong to _peChangePane...
    fEnable = pePane == _peChangePane;
    // TODO: Zero size ancestors need to cause adaptors (HWNDHosts) to hide
    _peSortCombo->SetVisible(fEnable);
    EnablePane(_peChangePane, fEnable);

    // Show/hide elements that belong to _peAddNewPane
    fEnable = pePane == _peAddNewPane;
    _pePublishedCategory->SetVisible(fEnable);
    _pePublishedCategoryLabel->SetVisible(fEnable);
    EnablePane(_peAddNewPane, fEnable);

    // Show/hide elements that belong to _peAddRmWinPane
    fEnable = pePane == _peAddRmWinPane;
    EnablePane(_peAddRmWinPane, fEnable);

    // Show/hide elements that belong to _pePickAppPane
    fEnable = pePane == _pePickAppPane;
    TraverseTree<ClientPicker>(_pePickAppPane, SetVisibleClientCB, fEnable);

    EnablePane(_pePickAppPane, fEnable);
}

//  If we can't put focus on the list, it will go to the fallback location
void ARPFrame::PutFocusOnList(Selector* peList)
{
    Element* pe;
    if (pe = peList->GetSelection())
    {
       pe->SetKeyFocus();
    }
    else
    {
        pe = FallbackFocus();

        if (pe)
        {
            pe->SetKeyFocus();
        }
    }
}

void ARPFrame::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;

            if (pbce->peTarget->GetID() == _idClose ||
                pbce->peTarget == _peOK)
            {
                // Close button
                if (OnClose())
                {
                    _pnhh->DestroyWindow();
                }
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget == _peCancel)
            {
                // Do not call OnClose; nothing will be applied
                _pnhh->DestroyWindow();
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromDisk)
            {
                // Add from disk button
                HRESULT hr;
                IShellAppManager* pisam = NULL;
                hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
                if (SUCCEEDED(hr))
                {
                    pisam->InstallFromFloppyOrCDROM(GetHWND());
                }
                if (pisam)
                {
                    pisam->Release();
                }    
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromMsft)
            {
                // Windows update button
                WCHAR szPath[MAX_PATH];
                
                if ( GetSystemDirectory(szPath, MAX_PATH) && PathCombineW(szPath, szPath, L"wupdmgr.exe") )
                {
                    ShellExecuteW(NULL, NULL, szPath, NULL, NULL, SW_SHOWDEFAULT);
                    pEvent->fHandled = true;
                }
                return;
            }
            else if (pbce->peTarget->GetID() == _idComponents)
            {
                RunOCManager();
            }
            else if (pbce->peTarget->GetID() == ARPItem::_idSize ||
                     pbce->peTarget->GetID() == ARPItem::_idFreq ||
                     pbce->peTarget->GetID() == ARPItem::_idSupInfo)
            {
                // Help requests
                ARPHelp* peHelp;
                NativeHWNDHost* pnhh = NULL;
                Element* pe = NULL;
                WCHAR szTitle[1024];
                if (pbce->peTarget->GetID() == ARPItem::_idSize)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_SIZETITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"sizehelp", peHelp, &pe);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for size info window.\n");
                    }
                }    
                else if (pbce->peTarget->GetID() == ARPItem::_idFreq)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCYTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"freqhelp", peHelp, &pe);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for frequency info window.\n");
                    }
                }    
                else
                {
                    // Support information, add additional fields
                    LoadStringW(_pParser->GetHInstance(), IDS_SUPPORTTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"suphelp", peHelp, &pe);

                        // Get application info
                        APPINFODATA aid = {0};

                        // Query
                        aid.cbSize = sizeof(APPINFODATA);
                        aid.dwMask = AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                                     AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                                     AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                                     AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

                        // There must be a selection
                        ARPItem* peSel = (ARPItem*)_peInstalledItemList->GetSelection();

                        peSel->_piia->GetAppInfo(&aid);
                        ((ARPHelp*)peHelp)->_piia = peSel->_piia;                    
                        PrepareSupportInfo(peHelp, &aid);

                        // Clean up
                        ClearAppInfoData(&aid);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for support info window.\n");
                    }
                }
                
                if (pe && pnhh) // Fill contents using substitution
                {
                     // Set visible and host
                     _pah = peHelp;
                     _bInModalMode = true;                     
                     EnableWindow(GetHWND(), FALSE);                     
                     pnhh->Host(peHelp);
                     peHelp->SetVisible(true);                     
                     peHelp->SetDefaultFocus();

                   // Do initial show
                   pnhh->ShowWindow();
                }


                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Selector::SelectionChange)
        {
            SelectionChangeEvent* sce = (SelectionChangeEvent*)pEvent;

            //
            // NTRAID#NTBUG9-294015-2001/02/08-jeffreys
            //
            // If the user double-clicks, weird things can happen.
            //
            //
            // NTRAID#NTBUG9-313888-2001/2/14-brianau
            // 
            // This fix for 294015 caused more strange things to happen.  The most notable
            // is that sometimes you click a button and it remains depressed
            // but nothing happens.  Disabling this call to block double
            // click input fixes this problem.  We need to devise a better way
            // of handling double-click input in DUI.
            //
//            _BlockDoubleClickInput();

            if (sce->peTarget == _peOptionList)
            {
                // ARP options
                StartDefer();

                Element* peAddContentHeader = FindDescendentByName(this, L"addcontentheader");

                ASSERT(peAddContentHeader != NULL);

                if (sce->peNew->GetID() == _idChange)
                {
                    if (!_bInstalledListFilled)
                    {
                        UpdateInstalledItems();
                    }

                    ChangePane(_peChangePane);

                    _peCurrentItemList = _peInstalledItemList;
                    _peInstalledItemList->SetContentString(L"");
                    PutFocusOnList(_peInstalledItemList);
                }
                else if (sce->peNew->GetID() == _idAddNew)
                {
                    if (!_bPublishedListFilled)
                    {
                        WCHAR szTemp[1024];
                        LoadStringW(_pParser->GetHInstance(), IDS_WAITFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
                        _pePublishedItemList->SetContentString(szTemp);
                        SetElementAccessability(_pePublishedItemList, true, ROLE_SYSTEM_STATICTEXT, szTemp);
                        RePopulatePublishedItemList();
                    }

                    ChangePane(_peAddNewPane);

                    _peCurrentItemList = _pePublishedItemList;

                    PutFocusOnList(_pePublishedItemList);
                }
                else if (sce->peNew->GetID() == _idAddRmWin)
                {
                    ChangePane(_peAddRmWinPane);

                    _peCurrentItemList = _peOCSetupItemList;

                    if (!_bOCSetupNeeded)
                    {
                        RunOCManager();
                        if (sce->peOld) {
                            _peOptionList->SetSelection(sce->peOld);
                        }
                    }
                    else 
                    {
                        if (!_bOCSetupListFilled)
                        {
                            //_beginthread(PopulateAndRenderOCSetupItemList, 0, (void*)this);
                            if (!htPopulateAndRenderOCSetupItemList && g_fRun)
                                htPopulateAndRenderOCSetupItemList = CreateThread(NULL, 0, PopulateAndRenderOCSetupItemList, (void*)this, 0, NULL);        

                            _bOCSetupListFilled = true;
                        }

                        PutFocusOnList(_peOCSetupItemList);
                    }
                }
                else if (sce->peNew->GetID() == _idPickApps)
                {
                    ChangePane(_pePickAppPane);
                    _peCurrentItemList = _peClientTypeList;
                    PutFocusOnList(_peClientTypeList);
                }

                EndDefer();

            }
            else if (sce->peTarget == _peInstalledItemList)
            {
                if (sce->peOld)
                {
                   sce->peOld->FindDescendent(ARPItem::_idRow[0])->SetEnabled(false);
                }
                if (sce->peNew)
                {
                   sce->peNew->FindDescendent(ARPItem::_idRow[0])->RemoveLocalValue(EnabledProp);
                }
            }

            pEvent->fHandled = true;
            return;
        }
        else if (pEvent->uidType == Combobox::SelectionChange)
        {
            SelectionIndexChangeEvent* psice = (SelectionIndexChangeEvent*)pEvent;
            if (psice->peTarget->GetID() == _idSortCombo)
            {
                SortList(psice->iNew, psice->iOld);
            }
            else if (psice->peTarget->GetID() == _idCategoryCombo)
            {
                _curCategory = psice->iNew;
                if (_bPublishedComboFilled)
                {
                    if (_bPublishedListFilled)
                    {
                        RePopulatePublishedItemList();
                    }
                }    
            }
        }
    }
    
    HWNDElement::OnEvent(pEvent);
}

void ARPFrame::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    if(peTo && IsDescendent(peTo))
    {
        peLastFocused = peTo;
    }
    Element::OnKeyFocusMoved(peFrom, peTo);

/*  uncomment when JStall's message fixing is done
    if (peTo != peLastFocused)
    {
        // transition focus-following floater element from old to new

        if (!peTo)
            peFloater->SetVisible(false);
        else
        {
            Value* pvSize;
            const SIZE* psize = peTo->GetExtent(&pvSize);
            peFloater->SetWidth(psize->cx);
            peFloater->SetHeight(psize->cy);
            pvSize->Release();

            POINT pt = { 0, 0 };
            MapElementPoint(peTo, &pt, &pt);
            peFloater->SetX(pt.x);
            peFloater->SetY(pt.y);

            if (!peLastFocused)
                peFloater->SetVisible(true);
        }

        peLastFocused = peTo;
    }
*/
}

void ARPFrame::OnPublishedListComplete()
{
    Invoke(ARP_PUBLISHEDLISTCOMPLETE, NULL);
}

void ARPFrame::RePopulatePublishedItemList()
{
    //_beginthread(::PopulateAndRenderPublishedItemList, 0, (void*)this);
    if (!htPopulateAndRenderPublishedItemList && g_fRun)
    {
        // Disable the category combo until we are done populating the list
        _pePublishedCategory->SetEnabled(false);

        _bPublishedListFilled = false;
        _pePublishedItemList->DestroyAll();

        htPopulateAndRenderPublishedItemList = CreateThread(NULL, 0, PopulateAndRenderPublishedItemList, (void*)this, 0, NULL);        
    }
}

void ARPFrame::RePopulateOCSetupItemList()
{
    if (!htPopulateAndRenderOCSetupItemList && g_fRun)
    {
        _peOCSetupItemList->DestroyAll();
        _bOCSetupListFilled = false;

        htPopulateAndRenderOCSetupItemList = CreateThread(NULL, 0, PopulateAndRenderOCSetupItemList, (void*)this, 0, NULL);

        _bOCSetupListFilled = true;
    }
}

bool ARPFrame::CanSetFocus()
{
    if (_bInModalMode)
    {
        HWND hWnd = _pah->GetHost()->GetHWND();
        FLASHWINFO fwi = {
        sizeof(FLASHWINFO),               // cbSize
            hWnd,   // hwnd
            FLASHW_CAPTION,               // flags
            5,                            // uCount
            75                            // dwTimeout
            };
        FlashWindowEx(&fwi);
        SetFocus(hWnd);
        return false;
    }
    return true;
}

HRESULT TransferToCustomCB(ClientPicker *pe, LPARAM)
{
    return pe->TransferToCustom();
}

HRESULT ApplyClientBlockCB(ClientBlock* pcb, LPARAM lParam)
{
    return pcb->Apply((ARPFrame*)lParam);
}

bool ARPFrame::OnClose()
{
    if (_peClientTypeList)
    {
        Element *peSelected = _peClientTypeList->GetSelection();
        if (peSelected)
        {
            // Get all the client pickers in the user's selection
            // to transfer their settings to the Custom pane.
            // (This is a NOP if the current selection is itself the custom pane.)
            TraverseTree<ClientPicker>(peSelected, TransferToCustomCB);

            InitProgressDialog();

            // To get the progress bar right, we apply in two passes.
            // The first pass is "fake mode" where all we do is count up
            // how much work we are going to do.
            SetProgressFakeMode(true);
            TraverseTree<ClientBlock>(this, ApplyClientBlockCB, (LPARAM)this);

            // Okay now we know what the progress bar limit should be.
            _dwProgressTotal = _dwProgressSoFar;
            _dwProgressSoFar = 0;

            // The second pass is "real mode" where we do the actualy work.
            SetProgressFakeMode(false);
            TraverseTree<ClientBlock>(this, ApplyClientBlockCB, (LPARAM)this);


            EndProgressDialog();
        }
    }
    return true;
}

void ARPFrame::InitProgressDialog()
{
    TCHAR szBuf[MAX_PATH];

    EndProgressDialog();

    _dwProgressTotal = _dwProgressSoFar = 0;

    if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IProgressDialog, &_ppd))))
    {
        _ppd->SetAnimation(GetModuleHandle(TEXT("SHELL32")), 165);
        LoadString(g_hinst, IDS_APPLYINGCLIENT, szBuf, SIZECHARS(szBuf));
        _ppd->SetTitle(szBuf);
        _ppd->StartProgressDialog(GetHostWindow(), NULL, PROGDLG_MODAL | PROGDLG_NOTIME | PROGDLG_NOMINIMIZE, NULL);
    }
}

void ARPFrame::SetProgressDialogText(UINT ids, LPCTSTR pszName)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szFormat[MAX_PATH];

    if (_ppd)
    {
        LoadString(g_hinst, ids, szFormat, SIZECHARS(szFormat));
        wnsprintf(szBuf, SIZECHARS(szBuf), szFormat, pszName);
        _ppd->SetLine(1, szBuf, FALSE, NULL);
        _ppd->SetProgress(_dwProgressSoFar, _dwProgressTotal);
    }
}

void ARPFrame::EndProgressDialog()
{
    if (_ppd)
    {
        _ppd->StopProgressDialog();
        _ppd->Release();
        _ppd = NULL;
    }
}


HRESULT ARPFrame::LaunchClientCommandAndWait(UINT ids, LPCTSTR pszName, LPTSTR pszCommand)
{
    HRESULT hr = S_OK;

    if (!_bFakeProgress)
    {
        if (_ppd && _ppd->HasUserCancelled())
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            SetProgressDialogText(ids, pszName);

            PROCESS_INFORMATION pi;
            STARTUPINFO si = { 0 };
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_SHOWNORMAL;
            if (CreateProcess(NULL, pszCommand, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                while (SHWaitForSendMessageThread(pi.hProcess, 1000) == WAIT_TIMEOUT)
                {
                    if (_ppd && _ppd->HasUserCancelled())
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;
                    }
                }
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
    }
    _dwProgressSoFar++;

    return hr;
}

////////////////////////////////////////////////////////
// Caller thread-safe APIs (do any additional work on callers thread and then marshal)

// Sets the range for the total number of installed items
void ARPFrame::SetInstalledItemCount(UINT cItems)
{
    Invoke(ARP_SETINSTALLEDITEMCOUNT, (void*)(UINT_PTR)cItems);
}
   
void  ARPFrame::DecrementInstalledItemCount()
{
    Invoke(ARP_DECREMENTINSTALLEDITEMCOUNT, NULL);
}

// Sets the range for the total number of installed items
void ARPFrame::SetPublishedItemCount(UINT cItems)
{
    Invoke(ARP_SETPUBLISHEDITEMCOUNT, (void*)(UINT_PTR)cItems);
}
   
void  ARPFrame::DecrementPublishedItemCount()
{
    Invoke(ARP_DECREMENTPUBLISHEDITEMCOUNT, NULL);
}

// Inserts in items, sorted into the ARP list
void ARPFrame::InsertInstalledItem(IInstalledApp* piia)
{
    if (piia == NULL)
    {
        Invoke(ARP_DONEINSERTINSTALLEDITEM, NULL);
    }
    else
    {
        // Setup marshalled call, do as much work as possible on caller thread
        InsertItemData iid;

        APPINFODATA aid = {0};
        SLOWAPPINFO sai = {0};

        // Query only for display name and support URL
        aid.cbSize = sizeof(APPINFODATA);
        aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                      AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                      AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                      AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

        piia->GetAppInfo(&aid);
        if(FAILED(piia->GetCachedSlowAppInfo(&sai)))
        {
            piia->GetSlowAppInfo(&sai);
        }

        // Set data
        iid.piia = piia;

        if (aid.pszDisplayName && aid.pszDisplayName[0])
        {
            // Title
            CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

            // Image
            if (aid.pszImage && aid.pszImage[0])
            {
                iid.iIconIndex = PathParseIconLocationW(aid.pszImage);
                CopyMemory(iid.pszImage, aid.pszImage, min(sizeof(iid.pszImage), (wcslen(aid.pszImage) + 1) * sizeof(WCHAR)));    
            }
            else if (sai.pszImage && sai.pszImage[0])
            {
                iid.iIconIndex = PathParseIconLocationW(sai.pszImage);
                CopyMemory(iid.pszImage, sai.pszImage, min(sizeof(iid.pszImage), (wcslen(sai.pszImage) + 1) * sizeof(WCHAR)));
            }
            else
            {
                *iid.pszImage = NULL;
            }

            // Size, Frequency, and Last Used On
            iid.ullSize = sai.ullSize;
            iid.iTimesUsed = sai.iTimesUsed;
            iid.ftLastUsed = sai.ftLastUsed;

            // Possible actions (change, remove, etc.)
            piia->GetPossibleActions(&iid.dwActions);

            // Flag if support information is available
            iid.bSupportInfo = ShowSupportInfo(&aid);

            Invoke(ARP_INSERTINSTALLEDITEM, &iid);
        }
        else
        // Adjust Status bar size.
        {
            DecrementInstalledItemCount();
        }

        // Free query memory
        ClearAppInfoData(&aid);
    }
}

void ARPFrame::InsertPublishedItem(IPublishedApp* pipa, bool bDuplicateName)
{
    PUBAPPINFO* ppai;
    APPINFODATA aid = {0};
    InsertItemData iid= {0};
   
    ppai = new PUBAPPINFO;
    if (ppai == NULL)
    {
        return;
    }
    ppai->cbSize = sizeof(PUBAPPINFO);
    ppai->dwMask = PAI_SOURCE | PAI_ASSIGNEDTIME | PAI_PUBLISHEDTIME | PAI_EXPIRETIME | PAI_SCHEDULEDTIME;

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    pipa->GetAppInfo(&aid);
    pipa->GetPublishedAppInfo(ppai);
    
    // Title
    if (bDuplicateName)
    {
        //
        // Duplicate entries have their publisher name appended 
        // to the application name so that they can be differentiated
        // from one another in the UI.
        //
        StringCchPrintf(iid.pszTitle, 
                  ARRAYSIZE(iid.pszTitle), 
                  L"%ls: %ls", 
                  aid.pszDisplayName, 
                  ppai->pszSource);                    
    }
    else
    {
        //
        // iid.pszTitle, despite the name is a character buffer, not a pointer.
        //
        lstrcpyn(iid.pszTitle, aid.pszDisplayName, ARRAYSIZE(iid.pszTitle));
    }

    iid.pipa = pipa;
    iid.ppai = ppai;

    Invoke(ARP_INSERTPUBLISHEDITEM, &iid);

    // Free query memory
    ClearAppInfoData(&aid);
}

void ARPFrame::InsertOCSetupItem(COCSetupApp* pocsa)
{
    APPINFODATA aid = {0};
    InsertItemData iid= {0};

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME;
    pocsa->GetAppInfo(&aid);

    iid.pocsa = pocsa;
    // Title
    CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

    Invoke(ARP_INSERTOCSETUPITEM, &iid);

     // Free query memory
    ClearAppInfoData(&aid);
}
void ARPFrame::FeedbackEmptyPublishedList()
{
    Invoke(ARP_SETPUBLISHEDFEEDBACKEMPTY, 0);
}

void ARPFrame::DirtyInstalledListFlag()
{
    _bInstalledListFilled=false;

    // Refresh if we are on the published list
    if (_peCurrentItemList == _peInstalledItemList)
    {
        UpdateInstalledItems();
    }
}

void ARPFrame::DirtyPublishedListFlag()
{
    _bPublishedListFilled=false;

    // Refresh if we are on the published list
    if (_peCurrentItemList == _pePublishedItemList)
    {
        RePopulatePublishedItemList();
    }
}

void  ARPFrame::PopulateCategoryCombobox()
{
    Invoke(ARP_POPULATECATEGORYCOMBO, NULL);
}

LPCWSTR ARPFrame::GetCurrentPublishedCategory()
{
    int iCurrentCategory = _curCategory;
    if (iCurrentCategory == 0 || iCurrentCategory == CB_ERR || _psacl == NULL)
    {
        return NULL;
    }
    return _psacl->pCategory[iCurrentCategory - 1].pszCategory;
}

inline bool ARPFrame::ShowSupportInfo(APPINFODATA *paid)
{
   if (_bSupportInfoRestricted)
   {
       return false;
   }
   if (paid->pszVersion && paid->pszVersion ||
      paid->pszPublisher && paid->pszPublisher ||
      paid->pszProductID && paid->pszProductID ||
      paid->pszRegisteredOwner && paid->pszRegisteredOwner ||
      paid->pszRegisteredCompany && paid->pszRegisteredCompany ||
      paid->pszSupportUrl && paid->pszSupportUrl ||
      paid->pszHelpLink && paid->pszHelpLink ||
      paid->pszContact && paid->pszContact ||
      paid->pszReadmeUrl && paid->pszReadmeUrl ||
      paid->pszComments && paid->pszComments)
   {
       return TRUE;
   }
   return FALSE;
}

void ARPFrame::PrepareSupportInfo(Element* peHelp, APPINFODATA *paid)
{
    DWORD dwAction = 0;
    Element* pe;
    pe = FindDescendentByName(peHelp, L"title");
    pe->SetContentString(paid->pszDisplayName);
    SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, paid->pszDisplayName);
    
    pe = FindDescendentByName(peHelp, L"prodname");
    pe->SetContentString(paid->pszDisplayName); 
    SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, paid->pszDisplayName);

    ARPSupportItem* pasi;
    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"publisher");
    pasi->SetAccValue(paid->pszPublisher);
    pasi->SetURL(paid->pszSupportUrl);

    FindDescendentByName(peHelp, L"version")->SetAccValue(paid->pszVersion);

    FindDescendentByName(peHelp, L"contact")->SetAccValue(paid->pszContact);

    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"support");
    pasi->SetAccValue(paid->pszHelpLink);
    pasi->SetURL(paid->pszHelpLink);

    FindDescendentByName(peHelp, L"telephone")->SetAccValue(paid->pszSupportTelephone);
    
    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"readme");
    pasi->SetAccValue(paid->pszReadmeUrl);
    pasi->SetURL(paid->pszReadmeUrl);

    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"update");
    pasi->SetAccValue(paid->pszUpdateInfoUrl);
    pasi->SetURL(paid->pszUpdateInfoUrl);

    FindDescendentByName(peHelp, L"productID")->SetAccValue(paid->pszProductID);

    FindDescendentByName(peHelp, L"regCompany")->SetAccValue(paid->pszRegisteredCompany);

    FindDescendentByName(peHelp, L"regOwner")->SetAccValue(paid->pszRegisteredOwner);

    FindDescendentByName(peHelp, L"comments")->SetAccValue(paid->pszComments);

    ((ARPHelp*)peHelp)->_piia->GetPossibleActions(&dwAction);
    if (!(dwAction & APPACTION_REPAIR))
        FindDescendentByName(peHelp, L"repairblock")->SetLayoutPos(LP_None);
}

extern "C" int __cdecl CompareElementDataName(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataSize(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataFreq(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataLast(const void* pA, const void* pB);

CompareCallback ARPFrame::GetCompareFunction()
{
    switch(CurrentSortType)
    {
        case SORT_SIZE:      return CompareElementDataSize;
        case SORT_TIMESUSED: return CompareElementDataFreq;
        case SORT_LASTUSED:  return CompareElementDataLast;
        default:             return CompareElementDataName;
    }
}

void ARPFrame::SortList(int iNew, int iOld)
{
    if ((iNew >= 0) && (iNew != CurrentSortType))
    {
        CurrentSortType = (SortType) iNew;

        StartDefer();

        if (((iNew != SORT_NAME) || (iOld != SORT_SIZE)) &&
            ((iNew != SORT_SIZE) || (iOld != SORT_NAME)))
        {
            Value* pvChildren;
            ElementList* pel = _peInstalledItemList->GetChildren(&pvChildren);
            if (NULL == pel)
            {
                EndDefer();
                return;
            }

            for (UINT i = 0; i < pel->GetSize(); i++)
                ((ARPItem*) pel->GetItem(i))->SortBy(iNew, iOld);

            pvChildren->Release();
        }

        _peInstalledItemList->SortChildren(GetCompareFunction());

        if (!_peInstalledItemList->GetSelection())
        {
            Value* pv;
            ElementList* peList = _peInstalledItemList->GetChildren(&pv);
            if (NULL == peList)
            {
                EndDefer();
                return;
            }

            _peInstalledItemList->SetSelection(peList->GetItem(0));
            pv->Release();
        }

        EndDefer();
    }
}

void ARPFrame::SelectInstalledApp(IInstalledApp* piia)
{
    Value* pv;
    ElementList* peList = _peInstalledItemList->GetChildren(&pv);

    for (UINT i = 0; i < peList->GetSize(); i++)
    {
        ARPItem* pai = (ARPItem*) peList->GetItem(i);
        if (pai->_piia == piia)
        {
            pai->SetKeyFocus();
            break;
        }
    }
    pv->Release();
}

// Selects an app adjacent in the list to piia if possible, or to the fallback otherwise.
// First preference is for the app immediately following piia, if available.
void ARPFrame::SelectClosestApp(IInstalledApp* piia)
{
    Value* pv;
    ElementList* peList = _peInstalledItemList->GetChildren(&pv);

    for (UINT i = 0; i < peList->GetSize(); i++)
    {
        ARPItem* pai = (ARPItem*) peList->GetItem(i);
        if (pai->_piia == piia)
        {
            Element* peFocus = FallbackFocus();

            // If there is an app after piia, select it.
            if ((i + 1) < peList->GetSize())
            {
                peFocus = (Element*) peList->GetItem(i + 1);
            }
            // else if there is an app before piia, select it
            else if (i != 0)
            {
                peFocus = (Element*) peList->GetItem(i - 1);
            }

            peFocus->SetKeyFocus();
            break;
        }
    }
    pv->Release();
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke (override)
void ARPFrame::OnInvoke(UINT nType, void* pData)
{
    // We are shutting down, ignore any requests from other threads
    if (!g_fRun)
        return;

    // Initialize ID cache if first pass
    if (!ARPItem::_idTitle)
    {
        ARPItem::_idTitle = StrToID(L"title");
        ARPItem::_idIcon = StrToID(L"icon");
        ARPItem::_idSize = StrToID(L"size");
        ARPItem::_idFreq = StrToID(L"freq");
        ARPItem::_idLastUsed = StrToID(L"lastused");
        ARPItem::_idInstalled = StrToID(L"installed");
        ARPItem::_idExInfo = StrToID(L"exinfo");
        ARPItem::_idSupInfo = StrToID(L"supinfo");
        ARPItem::_idItemAction = StrToID(L"itemaction");
        ARPItem::_idRow[0] = StrToID(L"row1");
        ARPItem::_idRow[1] = StrToID(L"row2");
        ARPItem::_idRow[2] = StrToID(L"row3");
    }

    switch (nType)
    {
    case ARP_SETINSTALLEDITEMCOUNT:
        // pData is item count
        _cMaxInstalledItems = (int)(INT_PTR)pData;
        break;

    case ARP_DECREMENTINSTALLEDITEMCOUNT:
        _cMaxInstalledItems--;
        break;

    case ARP_SETPUBLISHEDITEMCOUNT:
        // pData is item count
        _cMaxPublishedItems = (int)(INT_PTR)pData;
        break;

    case ARP_DECREMENTPUBLISHEDITEMCOUNT:
        _cMaxPublishedItems--;
        break;

    case ARP_SETPUBLISHEDFEEDBACKEMPTY:
        {
        WCHAR szTemp[1024];

        if (_bTerminalServer)
        {
            // We are running terminal server
            // This means no applications are displayed by design (not because there aren't any available)

            LoadStringW(_pParser->GetHInstance(), IDS_TERMSERVFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
        }
        else
        {
            LoadStringW(_pParser->GetHInstance(), IDS_EMPTYFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
        }

        _pePublishedItemList->SetContentString(szTemp);
        SetElementAccessability(_pePublishedItemList, true, ROLE_SYSTEM_STATICTEXT, szTemp);
        }
        break;
    case ARP_INSERTINSTALLEDITEM:
        {
        WCHAR szTemp[1024] = {0};
        
        // pData is InsertItemData struct
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();
        
        // Create ARP item
        DUIAssertNoMsg(_pParser);

        ARPItem* peItem;
        Element* pe;

        if (_hdsaInstalledItems == NULL)
        {
            LoadStringW(_pParser->GetHInstance(), IDS_PLEASEWAIT, szTemp, DUIARRAYSIZE(szTemp));      
            _hdsaInstalledItems = DSA_Create(sizeof(ARPItem*), _cMaxInstalledItems);
            _peInstalledItemList->SetContentString(szTemp);
        }

        _pParser->CreateElement(L"installeditem", NULL, (Element**)&peItem);
        peItem->_paf = this;
        
        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        if (!(piid->dwActions & APPACTION_MODIFYREMOVE))
        {
            // It isn't marked with modify/remove (the default)
            // Somebody gave us some special instructions from the registry
            if (!(piid->dwActions & APPACTION_UNINSTALL))
            {
                // NoRemove is set to 1
                if (piid->dwActions & APPACTION_MODIFY)
                {
                    // NoModify is not set so we can show the change button
                    _pParser->CreateElement(L"installeditemchangeonlyaction", NULL, &peAction);
                    if (!ARPItem::_idChg)
                    {
                        ARPItem::_idChg = StrToID(L"chg");
                    }
                    LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGE, szTemp, DUIARRAYSIZE(szTemp));
                }
            }
            else if (!(piid->dwActions & APPACTION_MODIFY))
            {
                // NoModify is set to 1
                // The only way we get here is if NoRemove is not set
                // so we don't have to check it again
                _pParser->CreateElement(L"installeditemremoveonlyaction", NULL, &peAction);
                if (!ARPItem::_idRm)
                {
                    ARPItem::_idRm = StrToID(L"rm");
                }
                LoadStringW(_pParser->GetHInstance(), IDS_HELPREMOVE, szTemp, DUIARRAYSIZE(szTemp));
            }
            else
            {
                // Just display both Change and Remove buttons
                _pParser->CreateElement(L"installeditemdoubleaction", NULL, &peAction);
                if (!ARPItem::_idChg)
                {
                    ARPItem::_idChg = StrToID(L"chg");
                    ARPItem::_idRm = StrToID(L"rm");
                }
                LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEORREMOVE, szTemp, DUIARRAYSIZE(szTemp));
            }
        }
        else
        {
            // Display the default "Change/Remove" button
            _pParser->CreateElement(L"installeditemsingleaction", NULL, &peAction);
            if (!ARPItem::_idChgRm)
                ARPItem::_idChgRm = StrToID(L"chgrm");
            LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEREMOVE, szTemp, DUIARRAYSIZE(szTemp));                
        }

        // Common steps for all cases above
        if (peAction)
        {
            // If peAction is not set, we are not displaying any buttons...
            pe = FindDescendentByName(peItem, L"instruct");
            pe->SetContentString(szTemp);
            SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, szTemp);
            peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);
        }

        // Support information
        if (!piid->bSupportInfo)
            peItem->FindDescendent(ARPItem::_idSupInfo)->SetLayoutPos(LP_None);

        // Set fields

        // Installed app interface pointer
        peItem->_piia = piid->piia;
        peItem->_piia->AddRef();

        // should just be call into the peItem: peItem->SetTimesUsed(piid->iTimesUsed); etc.
        peItem->_iTimesUsed = piid->iTimesUsed;
        peItem->_ftLastUsed = piid->ftLastUsed;
        peItem->_ullSize    = piid->ullSize;

        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);
        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
        SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, piid->iIconIndex, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                if (NULL != pvIcon)
                {
                    peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                    pvIcon->Release();
                }
            }    
        }
        *szTemp = NULL;
        // Size
        peField = peItem->FindDescendent(ARPItem::_idSize);
        DUIAssertNoMsg(peField);
        if (IsValidSize(piid->ullSize))
        {
            WCHAR szMBLabel[5] = L"MB";
            WCHAR szSize[15] = {0};
            double fSize = (double)(__int64)piid->ullSize;

            fSize /= 1048576.;  // 1MB
            LoadStringW(_pParser->GetHInstance(), IDS_SIZEUNIT, szMBLabel, DUIARRAYSIZE(szMBLabel));

            if (fSize > 100.)
            {
                StringCchPrintfW(szTemp, ARRAYSIZE(szTemp), L"%d", (__int64)fSize); // Clip
            }    
            else
            {
                StringCchPrintfW(szTemp, ARRAYSIZE(szTemp), L"%.2f", fSize);
            }    

            // Format the number for the current user's locale
            if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, NULL, szSize, DUIARRAYSIZE(szSize)) == 0)
            {
                lstrcpyn(szSize, szTemp, DUIARRAYSIZE(szSize));
            }

            if (SUCCEEDED(StringCchCat(szSize, ARRAYSIZE(szSize), szMBLabel)))
            {
                peField->SetContentString(szSize);
                SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szTemp);
            }
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"sizelabel")->SetVisible(false);
        }

        // Frequency
        peField = peItem->FindDescendent(ARPItem::_idFreq);
        DUIAssertNoMsg(peField);
        if (IsValidFrequency(piid->iTimesUsed))
        {
            if (piid->iTimesUsed <= 2)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDREARELY, szTemp, DUIARRAYSIZE(szTemp));
            else if (piid->iTimesUsed <= 10)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDOCCASIONALLY, szTemp, DUIARRAYSIZE(szTemp));
            else
                LoadStringW(_pParser->GetHInstance(), IDS_USEDFREQUENTLY, szTemp, DUIARRAYSIZE(szTemp));

            peField->SetContentString(szTemp);
            SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szTemp);
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"freqlabel")->SetVisible(false);
        }

        // Last used on
        peField = peItem->FindDescendent(ARPItem::_idLastUsed);
        DUIAssertNoMsg(peField);
        if (IsValidFileTime(piid->ftLastUsed))
        {
            LPWSTR szDate;
            SYSTEMTIME stLastUsed;
            DWORD dwDateSize = 0;
            BOOL bFailed=FALSE;

            // Get the date it was last used on
            FileTimeToSystemTime(&piid->ftLastUsed, &stLastUsed);

            dwDateSize = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stLastUsed, NULL, NULL, dwDateSize);
            if (dwDateSize)
            {
                szDate = new WCHAR[dwDateSize];

                if (szDate)
                {
                    dwDateSize = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stLastUsed, NULL, szDate, dwDateSize);
                    if (dwDateSize)
                    {
                        peField->SetContentString(szDate);
                        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szDate);
                    }
                    else
                    {
                        bFailed=TRUE;
                    }

                    delete szDate;
                }
                else
                {
                    bFailed=TRUE;
                }
            }
            else
            {
                bFailed=TRUE;
            }
            
            if (bFailed)
            {
                peField->SetVisible(false);
                FindDescendentByName(peItem, L"lastlabel")->SetVisible(false);
            }
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"lastlabel")->SetVisible(false);
        }

        // Insert item into DSA
        int cNum = DSA_InsertItem(_hdsaInstalledItems, INT_MAX, &peItem);

        // Insert failed
        if (cNum < 0)
        {
            _cMaxInstalledItems--;

            // We're out of items to insert so remove the wait string
            if (!_cMaxInstalledItems)
            {
                _peInstalledItemList->SetContentString(L"");
            }
        }

        EndDefer();
        }
        break;

    case ARP_DONEINSERTINSTALLEDITEM:
        {
            DUITrace(">> ARP_DONEINSERTINSTALLEDITEM STARTED.\n");

            StartDefer();

            if (_hdsaInstalledItems != NULL)
            {
                int iMax = DSA_GetItemCount(_hdsaInstalledItems);

                // Just to be safe so if all items get removed we won't be
                // stuck with the please wait string.
                _peInstalledItemList->SetContentString(L"");
                
                for (int i=0; i < iMax; i++)
                {
                    ARPItem* aItem;
                    if (DSA_GetItem(_hdsaInstalledItems, i, &aItem))
                    {
                        _peInstalledItemList->Add(aItem, GetCompareFunction());
                    }
                }
                DSA_Destroy(_hdsaInstalledItems);
                _hdsaInstalledItems = NULL;

                // Set focus to first item
                // once list is populated, move focus to list
                GetNthChild(_peInstalledItemList, 0)->SetKeyFocus();

                _bInstalledListFilled = true;
            }

            EndDefer();

            DUITrace(">> ARP_DONEINSERTINSTALLEDITEM DONE.\n");
        }
        break;
    
    case ARP_INSERTPUBLISHEDITEM:
        {
        WCHAR szTemp[MAX_PATH] = {0};
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Need a DSA so we can add them all to the list at one time to avoid
        // having lots of redrawing of the layout.  This method is much much faster.
        if (_hdsaPublishedItems == NULL)
        {
            LoadStringW(_pParser->GetHInstance(), IDS_PLEASEWAIT, szTemp, DUIARRAYSIZE(szTemp));      
            _hdsaPublishedItems = DSA_Create(sizeof(ARPItem*), _cMaxPublishedItems);
            _pePublishedItemList->SetContentString(szTemp);
        }

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        Element* pe;
        _pParser->CreateElement(L"publisheditem", NULL, (Element**)&peItem);
        peItem->_paf = this;

        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        _pParser->CreateElement(L"publisheditemsingleaction", NULL, &peAction);
        if (!ARPItem::_idAdd)
            ARPItem::_idAdd = StrToID(L"add");
        peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);

        if (S_OK == piid->pipa->IsInstalled())
        {
            peItem->ShowInstalledString(TRUE);
        }
        
        // Published app interface pointer
        peItem->_pipa = piid->pipa;
        peItem->_pipa->AddRef();        
        peItem->_ppai = piid->ppai;


        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);
        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
        SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, NULL, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                pvIcon->Release();
            }    
        }

        // Insert into DSA, alphabetically
        if (_hdsaPublishedItems != NULL)
        {
            int iInsert;
            int cNum = DSA_GetItemCount(_hdsaPublishedItems);

            // Search for place to insert
            for (iInsert = 0; iInsert < cNum; iInsert++)
            {
                ARPItem* fItem;

                if (DSA_GetItem(_hdsaPublishedItems, iInsert, &fItem))
                {
                    Value* pvTitle;

                    pe = fItem->FindDescendent(ARPItem::_idTitle);
                    DUIAssertNoMsg(pe);
                
                    if (wcscmp(pe->GetContentString(&pvTitle), piid->pszTitle) > 0)
                    {
                        pvTitle->Release();
                        break;
                    }

                    pvTitle->Release();
                }
            }

            // Insert item into DSA
            if (DSA_InsertItem(_hdsaPublishedItems, iInsert, &peItem) < 0)
            {
                // Failed to insert the item
                // Bring the total down by 1
                _cMaxPublishedItems--;
            }
        }

        // We only want to start actually adding the items to the list
        // when we reach our last item.  If we insert each item into the list
        // as we process these messages, it can take upwards of 4 minutes to populate
        // if there are a lot of items.
        if (_hdsaPublishedItems != NULL &&
            DSA_GetItemCount(_hdsaPublishedItems) == _cMaxPublishedItems)
        {
            for (int i=0; i < _cMaxPublishedItems; i++)
            {
                ARPItem* aItem;
                if (DSA_GetItem(_hdsaPublishedItems, i, &aItem))
                {
                    _pePublishedItemList->Insert(aItem, i);
                }
            }
            DSA_Destroy(_hdsaPublishedItems);
            _hdsaPublishedItems = NULL;
        
            _pePublishedItemList->SetSelection(GetNthChild(_pePublishedItemList, 0));
        }
           
        EndDefer();
    }
        break;
    case ARP_INSERTOCSETUPITEM:
    {
        WCHAR szTemp[MAX_PATH] = {0};
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        if (SUCCEEDED(_pParser->CreateElement(L"ocsetupitem", NULL, (Element**)&peItem)))
        {
            peItem->_paf = this;

            if (!ARPItem::_idConfigure)
                ARPItem::_idConfigure = StrToID(L"configure");

            // Add appropriate change, remove buttons
            Element* peAction = NULL;
            if (SUCCEEDED(_pParser->CreateElement(L"ocsetupitemsingleaction", NULL, &peAction)))
            {
                Element *peItemAction = peItem->FindDescendent(ARPItem::_idItemAction);
                if (NULL != peItemAction && SUCCEEDED(peItemAction->Add(peAction)))
                {
                    peAction = NULL; // Action successfully added.
                    
                    // OCSetup pointer
                    peItem->_pocsa = piid->pocsa;

                    // Title
                    Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
                    DUIAssertNoMsg(peField);
                    peField->SetContentString(piid->pszTitle);
                    SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
                    SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

                    // Insert into list, alphabetically
                    Value* pvElList;
                    ElementList* peElList = _peOCSetupItemList->GetChildren(&pvElList);

                    Value* pvTitle;
                    Element* pe;
                    UINT iInsert = 0;

                    if (peElList)
                    {
                        for (; iInsert < peElList->GetSize(); iInsert++)
                        {
                            pe = peElList->GetItem(iInsert)->FindDescendent(ARPItem::_idTitle);
                            DUIAssertNoMsg(pe);

                            if (wcscmp(pe->GetContentString(&pvTitle), piid->pszTitle) > 0)
                            {
                                pvTitle->Release();
                                break;
                            }

                            pvTitle->Release();
                        }
                    }
                    
                    pvElList->Release();

                    // Insert item into list
                    if (FAILED(_peOCSetupItemList->Insert(peItem, iInsert)))
                    {
                        //
                        // Failed to insert item into list.  Need to delete
                        // the OCSetupApp object.
                        //
                        delete peItem->_pocsa;
                        peItem->_pocsa = NULL;
                    }
                    else
                    {
                        peItem = NULL;  // Successfully added to list.
                        _peOCSetupItemList->SetSelection(GetNthChild(_peOCSetupItemList, 0));
                    }
                }
                if (NULL != peAction)
                {
                    peAction->Destroy();
                    peAction = NULL;
                }
            }
            if (NULL != peItem)
            {
                peItem->Destroy();
                peItem = NULL;
            }
        }
       
        EndDefer();

    }
        break;
    case ARP_POPULATECATEGORYCOMBO:
    {
    UINT i;
    WCHAR szTemp[1024];
    UINT iSelection = 0; // Default to "All Categories"

    SHELLAPPCATEGORY *psac = _psacl->pCategory;
    LoadStringW(_pParser->GetHInstance(), IDS_ALLCATEGORIES, szTemp, DUIARRAYSIZE(szTemp));
    _pePublishedCategory->AddString(szTemp);

    szTemp[0] = 0;
    ARPGetPolicyString(L"DefaultCategory", szTemp, ARRAYSIZE(szTemp));
    
    StartDefer();
    for (i = 0; i < _psacl->cCategories; i++, psac++)
    {
        if (psac->pszCategory)
        {
            _pePublishedCategory->AddString(psac->pszCategory);
            if (0 == lstrcmpi(psac->pszCategory, szTemp))
            {
                //
                // Policy says default to this category.
                // i + 1 is required since element 0 is "All Categories"
                // and is ALWAYS present at element 0.
                //
                iSelection = i + 1;
            }
        }
    }
    _pePublishedCategory->SetSelection(iSelection);

    EndDefer();
    }
        break;
    case ARP_PUBLISHEDLISTCOMPLETE:
    {
        _pePublishedCategory->SetEnabled(true);
        break;
    }    
    }
}

void ARPFrame::ManageAnimations()
{
    BOOL fAnimate = TRUE;
    SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
    if (fAnimate)
    {
        if (!IsFrameAnimationEnabled())
        {
            _bAnimationEnabled = true;
            EnableAnimations();
        }
    }
    else
    {
        if (IsFrameAnimationEnabled())
        {
            _bAnimationEnabled = false;
            DisableAnimations();
        }
    }

    DUIAssertNoMsg((fAnimate != FALSE) == IsFrameAnimationEnabled());
}

HRESULT CalculateWidthCB(ClientPicker* pcp, LPARAM)
{
    pcp->CalculateWidth();
    return S_OK;
}

LRESULT ARPFrame::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_THEMECHANGED:
    case WM_SETTINGCHANGE:
        {
            LockWindowUpdate(_pnhh->GetHWND());
        
            Parser* pOldStyle = _pParserStyle;
            Parser* pNewStyle = NULL;

            if (!pOldStyle)
                break;

            // System parameter changing, reload style sheets so to sync
            // up with changes
            if (_fThemedStyle)
            {
                for (int i = FIRSTHTHEME; i <= LASTHTHEME; i++)
                {
                    if (_arH[i])
                    {
                        CloseThemeData(_arH[i]);
                        _arH[i] = NULL;
                    }
                }
            }

            CreateStyleParser(&pNewStyle);

            // Replace all style sheets
            if (pNewStyle)
            {
                Parser::ReplaceSheets(this, pOldStyle, pNewStyle);
            }

            // New style parser
            _pParserStyle = pNewStyle;

            // Destroy old
            pOldStyle->Destroy();

            // Animation setting may have changed
            ManageAnimations();

            TraverseTree<ClientPicker>(this, CalculateWidthCB);

            LockWindowUpdate(NULL);
        }
        break;
    }

    return HWNDElement::WndProc(hWnd, uMsg, wParam, lParam);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPFrame::Class = NULL;
HRESULT ARPFrame::Register()
{
    return ClassInfo<ARPFrame,HWNDElement>::Register(L"ARPFrame", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPItem class
////////////////////////////////////////////////////////


// ARP item IDs
ATOM ARPItem::_idTitle = 0;
ATOM ARPItem::_idIcon = 0;
ATOM ARPItem::_idSize = 0;
ATOM ARPItem::_idFreq = 0;
ATOM ARPItem::_idLastUsed = 0;
ATOM ARPItem::_idExInfo = 0;
ATOM ARPItem::_idInstalled = 0;
ATOM ARPItem::_idChgRm = 0;
ATOM ARPItem::_idChg = 0;
ATOM ARPItem::_idRm = 0;
ATOM ARPItem::_idAdd = 0;
ATOM ARPItem::_idConfigure = 0;
ATOM ARPItem::_idSupInfo = 0;
ATOM ARPItem::_idItemAction = 0;
ATOM ARPItem::_idRow[3] = { 0, 0, 0 };


////////////////////////////////////////////////////////
// ARPItem

HRESULT ARPItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPItem* pai = HNew<ARPItem>();
    if (!pai)
        return E_OUTOFMEMORY;

    HRESULT hr = pai->Initialize();
    if (FAILED(hr))
    {
        pai->Destroy();
        return hr;
    }

    *ppElement = pai;

    return S_OK;
}

HRESULT ARPItem::Initialize()
{
    _piia = NULL; // Init before base in event of failure (invokes desstructor)
    _pipa = NULL; // Init before base in event of failure (invokes desstructor)


    // Do base class initialization
    HRESULT hr = Button::Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
        return hr;

    return S_OK;
}


ARPItem::~ARPItem()
{
    if (_piia)
        _piia->Release();

    if (_pipa)
        _pipa->Release();

    if (_pocsa)
        delete _pocsa;

    if (_ppai)
    {
        ClearPubAppInfo(_ppai);
        delete _ppai;
    }
}

void ARPItem::ShowInstalledString(BOOL bInstalled)
{
    WCHAR szTemp[MAX_PATH] = L"";
    Element* pe = FindDescendent(ARPItem::_idInstalled);

    if (pe != NULL)
    {
        if (bInstalled)
        {
            LoadStringW(g_hinst, IDS_INSTALLED, szTemp, DUIARRAYSIZE(szTemp));
        }

        pe->SetContentString(szTemp);
        SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, szTemp);         
    }
}

HWND _CreateTransparentStubWindow(HWND hwndParent);

////////////////////////////////////////////////////////
// Generic eventing

void ARPItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->uidType == Element::KeyboardNavigate)
    {
        KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*)pEvent;
        if (pkne->iNavDir & NAV_LOGICAL)
        {
            if (pEvent->nStage == GMF_DIRECT)
            {
            }
        }
        else
        {
            if (pEvent->nStage == GMF_ROUTED)
            {
                pEvent->fHandled = true;

                KeyboardNavigateEvent kne;
                kne.uidType = Element::KeyboardNavigate;
                kne.peTarget = this;
                kne.iNavDir = pkne->iNavDir;

                FireEvent(&kne);  // Will route and bubble
            }
            return;
        }
    }

    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;
            ATOM id = pbce->peTarget->GetID();
            if (id == _idChgRm || id == _idRm || id == _idChg || id == _idAdd || id == _idConfigure)
            {
                HWND hwndStub = NULL;
                HWND hwndHost = NULL;
                DUIAssertNoMsg(_paf);
                
                if (_paf)
                {
                    hwndHost = _paf->GetHostWindow();
                }    
                if (hwndHost)
                {
                    hwndStub = _CreateTransparentStubWindow(hwndHost);
                    EnableWindow(hwndHost, FALSE);
                    SetActiveWindow(hwndStub);                    
                }

                if (id == _idAdd)
                {
                    
                    HRESULT hres = S_OK;
                    // Does the app have an expired publishing time?
                    if (_ppai->dwMask & PAI_EXPIRETIME)
                    {
                        // Yes, it does. Let's compare the expired time with our current time
                        SYSTEMTIME stCur = {0};
                        GetLocalTime(&stCur);

                        // Is "now" later than the expired time?
                        if (CompareSystemTime(&stCur, &_ppai->stExpire) > 0)
                        {
                            // Yes, warn the user and return failure
                            ShellMessageBox(g_hinst, hwndHost, MAKEINTRESOURCE(IDS_EXPIRED),
                                            MAKEINTRESOURCE(IDS_ARPTITLE), MB_OK | MB_ICONEXCLAMATION);
                            hres = E_FAIL;
                        }    
                    }
                    // if hres is not set by the above code, preceed with installation
                    if (hres == S_OK)
                    {
                        HCURSOR hcur = ::SetCursor(LoadCursor(NULL, IDC_WAIT));
                        // On NT,  let Terminal Services know that we are about to install an application.
                        // NOTE: This function should be called no matter the Terminal Services
                        // is running or not.
                        BOOL bPrevMode = TermsrvAppInstallMode();
                        SetTermsrvAppInstallMode(TRUE);
                        if (SUCCEEDED(_pipa->Install(NULL)))
                        {
                            // Show this item as installed
                            ShowInstalledString(TRUE);

                            // update installed items list
                            _paf->DirtyInstalledListFlag();
                        }
                        SetTermsrvAppInstallMode(bPrevMode);
                        ::SetCursor(hcur);
                    }                        
                }
                else
                {
                    HRESULT hr = E_FAIL;

                    if ((id == _idChgRm) || (id == _idRm))
                        hr = _piia->Uninstall(hwndHost);

                    else if (id == _idChg)
                        hr = _piia->Modify(hwndHost);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE == _piia->IsInstalled())
                        {
                            _paf->DirtyPublishedListFlag();
                        }
                    }
                }
                if (id == _idConfigure)
                {
                    _pocsa->Run();
                    _paf->RePopulateOCSetupItemList();
                }
                
                if (hwndHost)
                {
                    if (!_piia)
                    {
                        EnableWindow(hwndHost, TRUE);
                        SetForegroundWindow(hwndHost);
                    }

                    if (hwndStub)
                    {
                        DestroyWindow(hwndStub);
                    }    

                    EnableWindow(hwndHost, TRUE);
                }

                if (_piia)
                {
                    if (S_OK == _piia->IsInstalled())
                    {
                        SetKeyFocus();
                    }
                    else
                    {
                        // remove from installed items list
                        _paf->SelectClosestApp(_piia);
                        Destroy();
                    }
                }

                pEvent->fHandled = true;
                return;
            }
        }
    }

    Button::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// System events

void ARPItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selected))
    {
        // Display of extended information
        Element* peExInfo = FindDescendent(_idExInfo);
        DUIAssertNoMsg(peExInfo);

        peExInfo->SetLayoutPos(pvNew->GetBool() ? BLP_Top : LP_None);

        // Do default processing in this case
    }

    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void GetOrder(int iSortBy, int* iOrder)
{
    switch (iSortBy)
    {
        case SORT_NAME:
        case SORT_SIZE:      iOrder[0] = 0; iOrder[1] = 1; iOrder[2] = 2; break;
        case SORT_TIMESUSED: iOrder[0] = 1; iOrder[1] = 0; iOrder[2] = 2; break;
        case SORT_LASTUSED:  iOrder[0] = 2; iOrder[1] = 0; iOrder[2] = 1; break;
    }
}

void ARPItem::SortBy(int iNew, int iOld)
{
    Element* pe[3][2];     // size, timesused, lastused
    int iOrderOld[3];      // size, timesused, lastused
    int iOrderNew[3];      // size, timesused, lastused

    GetOrder(iOld, iOrderOld);
    GetOrder(iNew, iOrderNew);

    //
    // First get all the DUI elements to be sorted.  If we
    // can't get all of them, this sort fails.
    //
    bool bAllFound = true;
    int i;
    Element* peRow[3];     // row1, row2, row3
    for (i = 0; i < ARRAYSIZE(peRow); i++)
    {
        if (iOrderOld[i] != iOrderNew[i])
        {
            peRow[i] = FindDescendent(ARPItem::_idRow[i]);
            if (NULL == peRow[i])
            {
                bAllFound = false;
            }
        }
    }

    if (bAllFound)
    {
        for (i = 0; i < ARRAYSIZE(iOrderOld); i++) // loop through rows
        {
            int row = iOrderOld[i];
            if (row == iOrderNew[i])
                iOrderNew[i] = -1;
            else
            {
                DUIAssertNoMsg(NULL != peRow[i]);
                                
                Value* pvChildren;
                ElementList* pel;

                pel = peRow[i]->GetChildren(&pvChildren);
                pe[row][0] = pel->GetItem(0);
                pe[row][1] = pel->GetItem(1);
                pvChildren->Release();
            }
        }

        for (i = 0; i < 3; i++)
        {
            int row = iOrderNew[i];
            if (row != -1) // meaning that this row doesn't change
                peRow[i]->Add(pe[row], 2);
        }
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPItem::Class = NULL;
HRESULT ARPItem::Register()
{
    return ClassInfo<ARPItem,Button>::Register(L"ARPItem", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPHelp
////////////////////////////////////////////////////////

HRESULT ARPHelp::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPHelp::Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement)
{

    *ppElement = NULL;

    ARPHelp* pah = HNew<ARPHelp>();
    if (!pah)
        return E_OUTOFMEMORY;

    HRESULT hr = pah->Initialize(pnhh, paf, bDblBuffer);
    if (FAILED(hr))
    {
        pah->Destroy();
        return hr;
    }

    *ppElement = pah;

    return S_OK;
}

HRESULT ARPHelp::Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer)
{
    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), bDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    // Initialize
    // SetActive(AE_MouseAndKeyboard);
    _pnhh = pnhh;
    _paf = paf;

    return S_OK;
}
void ARPHelp::SetDefaultFocus()
{
    Element* pe = FindDescendentByName(this, L"close");
    if (pe)
    {
        pe->SetKeyFocus();
    }
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPHelp::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ATOM id = pEvent->peTarget->GetID();
            if (id == StrToID(L"repair")) 
                _piia->Repair(NULL);
            if (pEvent->peTarget->GetID() == StrToID(L"close")) 
            {
                _pnhh->DestroyWindow();
            }
            pEvent->fHandled = true;
            return;
        }
    }

    HWNDElement::OnEvent(pEvent);
}

void ARPHelp::OnDestroy()
{
    HWNDElement::OnDestroy();
    if (_paf)
    {
        _paf->SetModalMode(false);
    }

}

ARPHelp::~ARPHelp()
{
    if (_paf)
    {
        EnableWindow(_paf->GetHWND(), TRUE);
        SetFocus(_paf->GetHWND());
        _paf->RestoreKeyFocus();        
    }
    if (_pnhh)
    {
        _pnhh->Destroy();
    }
}
////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPHelp::Class = NULL;
HRESULT ARPHelp::Register()
{
    return ClassInfo<ARPHelp,HWNDElement>::Register(L"ARPHelp", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPSupportItem
////////////////////////////////////////////////////////

HRESULT ARPSupportItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSupportItem* pasi = HNew<ARPSupportItem>();
    if (!pasi)
        return E_OUTOFMEMORY;

    HRESULT hr = pasi->Initialize();
    if (FAILED(hr))
    {
        pasi->Destroy();
        return hr;
    }

    *ppElement = pasi;

    return S_OK;
}

Value* _pvRowLayout = NULL;

HRESULT ARPSupportItem::Initialize()
{
    // Do base class initialization
    HRESULT hr = Element::Initialize(0);
    if (FAILED(hr))
        return hr;

    // Initialize
    bool fCreateLayout = !_pvRowLayout;

    if (fCreateLayout)
    {
        int ari[3] = { -1, 0, 3 };
        hr = RowLayout::Create(3, ari, &_pvRowLayout);
        if (FAILED(hr))
            return hr;
    }

    Element* peName;
    hr = Element::Create(AE_Inactive, &peName);
    if (FAILED(hr))
        return hr;

    Button* peValue;
    hr = Button::Create((Element**) &peValue);
    if (FAILED(hr))
    {
        peName->Destroy();
        return hr;
    }

    peValue->SetEnabled(false);

    Add(peName);
    Add(peValue);

    SetValue(LayoutProp, PI_Local, _pvRowLayout);
    SetLayoutPos(LP_None);

    if (fCreateLayout)
    {
        // todo:  need to track in propertychanged to know when it reaches null, which is
        // when we need to set it to NULL
    }

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

#define ASI_Name  0
#define ASI_Value 1

Element* GetNthChild(Element *peRoot, UINT index)
{
    Value* pvChildren;
    ElementList* pel = peRoot->GetChildren(&pvChildren);
    Element* pe = NULL;
    if (pel && (pel->GetSize() > index))
        pe = pel->GetItem(index);
    pvChildren->Release();
    return pe;
}

Element* ARPSupportItem::GetChild(UINT index)
{
    return GetNthChild(this, index);
}


void ARPSupportItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    int index = -1;
    if (IsProp(AccName))
        index = ASI_Name;
    else if (IsProp(AccValue))
        index = ASI_Value;
    else if (IsProp(URL))
    {
        Element* pe = GetChild(ASI_Value);
        if (pe)
        {
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                pe->RemoveLocalValue(EnabledProp);
            else
                pe->SetEnabled(false);
        }
    }

    if (index != -1)
    {
        Element* pe = GetChild(index);
        if (index == ASI_Value)
        {
            // WARNING -- this code assumes you will not put a layoutpos on this element
            // as this code toggles between LP_None and unset, ignoring any previous setting
            // to the property -- verify this with Mark -- could be that this is local
            // and the markup is specified?  then there wouldn't be a problem
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                RemoveLocalValue(LayoutPosProp);
            else
                SetLayoutPos(LP_None);
        }
        if (pe)
        pe->SetValue(ContentProp, PI_Local, pvNew);

    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPSupportItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            Value* pvURL;
            LPCWSTR lpszURL = GetURL(&pvURL);
            if (*lpszURL)
            {
                ShellExecuteW(NULL, NULL, lpszURL, NULL, NULL, SW_SHOWDEFAULT);
            }
            pvURL->Release();

            pEvent->fHandled = true;
            return;
        }
    }

    Element::OnEvent(pEvent);
}

// URL property
static int vvURL[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultURL, DUIV_STRING, (void*)L"");
static PropertyInfo impURLProp = { L"URL", PF_Normal|PF_Cascade, 0, vvURL, NULL, (Value*)&svDefaultURL };
PropertyInfo* ARPSupportItem::URLProp = &impURLProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ARPSupportItem::URLProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ARPSupportItem::Class = NULL;
HRESULT ARPSupportItem::Register()
{
    return ClassInfo<ARPSupportItem,Element>::Register(L"ARPSupportItem", _aPI, DUIARRAYSIZE(_aPI));
}

////////////////////////////////////////////////////////
//
//  ARPSelector
//
//  A Selector whose children are all buttons.  If the user clicks
//  any of the buttons, that button automatically becomes the new
//  selection.

// Define class info with type and base type, set static class pointer
HRESULT ARPSelector::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSelector* ps = HNew<ARPSelector>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppElement = ps;

    return S_OK;
}

////////////////////////////////////////////////////////
// Generic eventing

HRESULT CALLBACK CollapseExpandosExceptCB(Expando* pex, LPARAM lParam)
{
    if (pex != (Expando*)lParam)
    {
        pex->SetExpanded(false);
    }
    return S_OK;
}

void CALLBACK s_Repaint(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(hwnd, idEvent);
    ARPSelector* self = (ARPSelector*)idEvent;
    Element* pe;
    if (SUCCEEDED(Element::Create(0, &pe)))
    {
        pe->SetLayoutPos(BLP_Client);
        if (SUCCEEDED(self->Add(pe)))
        {
            self->Remove(pe);
        }
        pe->Destroy();
    }
}

void ARPSelector::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        // Selection occurs only for Button::Click or Expando::Click events
        if (pEvent->uidType == Button::Click ||
            pEvent->uidType == Expando::Click)
        {
            pEvent->fHandled = true;
            SetSelection(pEvent->peTarget);

            // If it was a Click from an Expando, then unexpand all the
            // other Expandos and expand this expando
            if (pEvent->uidType == Expando::Click)
            {
                TraverseTree<Expando>(this, CollapseExpandosExceptCB, (LPARAM)pEvent->peTarget);
                Expando* pex = (Expando*)pEvent->peTarget;
                pex->SetExpanded(true);

                // Hack for DUI painting weirdness
                // After the animation is over, repaint ourselves
                // to get rid of the detritus.
                ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
                if (paf->GetHostWindow())
                {
                    SetTimer(paf->GetHostWindow(),
                             (UINT_PTR)this,
                             paf->GetAnimationTime(), s_Repaint);
                }

            }
            return;
        }
    }
    Selector::OnEvent(pEvent);
}

// If we are not the option list, bypass Selector::GetAdjacent because
// Selector navigates from the selected element but we want to navigate
// from the focus element because the focus element has interesting
// subelements...

Element *ARPSelector::GetAdjacent(Element *peFrom, int iNavDir, NavReference const *pnr, bool bKeyable)
{
    if (GetID() == ARPFrame::_idOptionList)
    {
        // Let the option list navigate normally
        return Selector::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
    }
    else
    {
        // All other selectors navigate from selection
        return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
    }
}

IClassInfo* ARPSelector::Class = NULL;
HRESULT ARPSelector::Register()
{
    return ClassInfo<ARPSelector,Selector>::Register(L"ARPSelector", NULL, 0);
}

////////////////////////////////////////////////////////
//
//  CLIENTINFO
//
//  Tracks information about a specific client.
//

bool CLIENTINFO::GetInstallFile(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf, bool fFile)
{
    DWORD dwType;
    DWORD cb = cchBuf * sizeof(TCHAR);
    if (SHQueryValueEx(hkInfo, pszValue, NULL, &dwType, pszBuf, &cb) != ERROR_SUCCESS ||
        dwType != REG_SZ)
    {
        // If a file, then failure is okay (it means nothing to verify)
        return fFile;
    }

    TCHAR szBuf[MAX_PATH];

    lstrcpyn(szBuf, pszBuf, DUIARRAYSIZE(szBuf));

    if (!fFile)
    {
        // Now validate that the program exists
        PathRemoveArgs(szBuf);
        PathUnquoteSpaces(szBuf);
    }

    // Must be fully-qualified
    if (PathIsRelative(szBuf))
    {
        return false;
    }

    // File must exist, but don't hit the network to validate it
    if (!PathIsNetworkPath(szBuf) &&
        !PathFileExists(szBuf))
    {
        return false;
    }

    return true;
}

bool CLIENTINFO::GetInstallCommand(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf)
{
    return GetInstallFile(hkInfo, pszValue, pszBuf, cchBuf, FALSE);
}


LONG RegQueryDWORD(HKEY hk, LPCTSTR pszValue, DWORD* pdwOut)
{
    DWORD dwType;
    DWORD cb = sizeof(*pdwOut);
    LONG lRc = RegQueryValueEx(hk, pszValue, NULL, &dwType, (LPBYTE)pdwOut, &cb);
    if (lRc == ERROR_SUCCESS && dwType != REG_DWORD)
    {
        lRc = ERROR_INVALID_DATA;
    }
    return lRc;
}

//
//  hkInfo = NULL means that pzsKey is actually the friendlyname for
//  "keep this item"
//
bool CLIENTINFO::Initialize(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey)
{
    LPCWSTR pszName;
    WCHAR szBuf[MAX_PATH];

    DUIAssertNoMsg(_tOEMShown == TRIBIT_UNDEFINED);

    if (hkInfo)
    {
        _pszKey = StrDupW(pszKey);
        if (!_pszKey) return false;

        // Program must have properly registered IconsVisible status

        DWORD dwValue;
        if (RegQueryDWORD(hkInfo, TEXT("IconsVisible"), &dwValue) != ERROR_SUCCESS)
        {
            return false;
        }

        // If there is a VerifyFile, the file must exist
        if (!GetInstallFile(hkInfo, TEXT("VerifyFile"), szBuf, DUIARRAYSIZE(szBuf), TRUE))
        {
            return false;
        }

        _bShown = BOOLIFY(dwValue);

        // Program must have properly registered Reinstall, HideIcons and ShowIcons commands

        if (!GetInstallCommand(hkInfo, TEXT("ReinstallCommand"), szBuf, DUIARRAYSIZE(szBuf)) ||
            !GetInstallCommand(hkInfo, TEXT("HideIconsCommand"), szBuf, DUIARRAYSIZE(szBuf)) ||
            !GetInstallCommand(hkInfo, TEXT("ShowIconsCommand"), szBuf, DUIARRAYSIZE(szBuf)))
        {
            return false;
        }

        // Get the OEM's desired hide/show setting for this app, if any
        if (RegQueryDWORD(hkInfo, TEXT("OEMShowIcons"), &dwValue) == ERROR_SUCCESS)
        {
            _tOEMShown = dwValue ? TRIBIT_TRUE : TRIBIT_FALSE;
        }

        // See if this is the OEM's default client
        if (RegQueryDWORD(hkInfo, TEXT("OEMDefault"), &dwValue) == ERROR_SUCCESS &&
            dwValue != 0)
        {
            _bOEMDefault = BOOLIFY(dwValue);
        }

        SHLoadLegacyRegUIStringW(hkApp, NULL, szBuf, ARRAYSIZE(szBuf));
        if (!szBuf[0]) return false;
        pszName = szBuf;
    }
    else
    {
        pszName = pszKey;
    }

    _pszName = StrDupW(pszName);
    if (!_pszName) return false;

    return true;
}

CLIENTINFO* CLIENTINFO::Create(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey)
{
    CLIENTINFO* pci = HNewAndZero<CLIENTINFO>();
    if (pci)
    {
        if (!pci->Initialize(hkApp, hkInfo, pszKey))
        {
            pci->Delete();
            pci = NULL;
        }
    }
    return pci;
}

CLIENTINFO::~CLIENTINFO()
{
    LocalFree(_pszKey);
    LocalFree(_pszName);
    if (_pvMSName)
    {
        _pvMSName->Release();
    }
}

int CLIENTINFO::QSortCMP(const void* p1, const void* p2)
{
    CLIENTINFO* pci1 = *(CLIENTINFO**)p1;
    CLIENTINFO* pci2 = *(CLIENTINFO**)p2;
    return lstrcmpi(pci1->_pszName, pci2->_pszName);
}

////////////////////////////////////////////////////////
//
//  StringList
//
//  A list of strings.  The buffer for all the strings is allocated
//  in _pszBuf; the DynamicArray contains pointers into that buffer.
//

void StringList::Reset()
{
    if (_pdaStrings)
    {
        _pdaStrings->Destroy();
        _pdaStrings = NULL;
    }
    LocalFree(_pszBuf);
    _pszBuf = NULL;
}

//  pszInit is a semicolon-separated list

HRESULT StringList::SetStringList(LPCTSTR pszInit)
{
    HRESULT hr;
    Reset();
    if (!pszInit)
    {
        hr = S_OK;              // empty list
    }
    else if (SUCCEEDED(hr = DynamicArray<LPTSTR>::Create(0, false, &_pdaStrings)))
    {
        _pszBuf = StrDup(pszInit);
        if (_pszBuf)
        {
            LPTSTR psz = _pszBuf;

            hr = S_OK;
            while (SUCCEEDED(hr) && psz && *psz)
            {
                LPTSTR pszT = StrChr(psz, L';');
                if (pszT)
                {
                    *pszT++ = L'\0';
                }
                hr = _pdaStrings->Add(psz);
                psz = pszT;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

bool StringList::IsStringInList(LPCTSTR pszFind)
{
    if (_pdaStrings)
    {
        for (UINT i = 0; i < _pdaStrings->GetSize(); i++)
        {
            if (AreEnglishStringsEqual(_pdaStrings->GetItem(i), pszFind))
            {
                return true;
            }
        }
    }
    return false;
}

////////////////////////////////////////////////////////
//
//  ClientPicker
//
//  An element which manages a list of registered clients.
//
//  If there is only one item in the list, then the element is static.
//  Otherwise, the element hosts a combo box.
//
//  The clienttype attribute is the name of the registry key under Clients.
//

HRESULT ClientPicker::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ClientPicker* pcc = HNewAndZero<ClientPicker>();
    if (!pcc)
        return E_OUTOFMEMORY;

    HRESULT hr = pcc->Initialize();
    if (FAILED(hr))
    {
        pcc->Destroy();
        return hr;
    }

    *ppElement = pcc;

    return S_OK;
};

HRESULT ClientPicker::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize members
    hr = DynamicArray<CLIENTINFO*>::Create(0, false, &_pdaClients);
    if (FAILED(hr))
        return hr;

    hr = Element::Create(0, &_peStatic);
    if (FAILED(hr))
        return hr;

    if (FAILED(hr = _peStatic->SetClass(L"clientstatic")) ||
        FAILED(hr = Add(_peStatic)))
    {
        _peStatic->Destroy();
        return hr;
    }
    _peStatic->SetAccessible(true);
    _peStatic->SetAccRole(ROLE_SYSTEM_STATICTEXT);

    hr = Combobox::Create((Element**)&_peCombo);
    if (FAILED(hr))
        return hr;

    if (FAILED(hr = Add(_peCombo)) ||
        FAILED(hr = _peCombo->SetVisible(false)))
    {
        _peCombo->Destroy();
        return hr;
    }

    // JeffBog says I should mess with the width here
    SetWidth(10);

    return S_OK;
}

ClientPicker::~ClientPicker()
{
    _CancelDelayShowCombo();
    if (_pdaClients)
    {
        _pdaClients->Destroy();
    }
}

void ClientPicker::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{

    super::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Since UIActive = Selected && ParentEnabled, we need to call
    // _SyncUIActive if either property changes.

    if (IsProp(Selected))
    {
        // Change in selection may require us to block or unblock the OK button.
        _CheckBlockOK(pvNew->GetBool());

        _SyncUIActive();
    }
    else if (IsProp(ParentExpanded))
    {
        _SyncUIActive();
    }
}

//  To keep accessibility happy, we reflect content in the AccName.

void _SetStaticTextAndAccName(Element* pe, Value* pv)
{
    pe->SetValue(Element::ContentProp, PI_Local, pv);
    pe->SetValue(Element::AccNameProp, PI_Local, pv);
}

void _SetStaticTextAndAccName(Element* pe, LPCWSTR pszText)
{
    Value* pv = Value::CreateString(pszText);
    _SetStaticTextAndAccName(pe, pv);
    pv->Release();
}

//
//  When UI Active, show the combo box.
//  When not UI Active, hide our combo box so animation doesn't tube it.
//
void ClientPicker::_SyncUIActive()
{
    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
    bool bUIActive = GetSelected() && GetParentExpanded();

    if (_bUIActive != bUIActive)
    {
        _bUIActive = bUIActive;
        if (_bUIActive)
        {
            // Normally we would just _peCombo->SetVisible(_NeedsCombo())
            // and go home. Unfortunately, DirectUI gets confused if a
            // combo box moves around, so we have to change the visibility
            // after the world has gone quiet

            _hwndHost = paf->GetHostWindow();
            if (_hwndHost)
            {
                SetTimer(_hwndHost,
                         (UINT_PTR)this,
                         paf->GetAnimationTime(), s_DelayShowCombo);
            }
        }
        else
        {
            // Inactive - copy current combo selection to static
            // and hide the combo
            UINT iSel = _peCombo->GetSelection();
            if (iSel < GetClientList()->GetSize())
            {
                _SetStaticTextAndAccName(_peStatic, GetClientList()->GetItem(iSel)->GetFilteredName(GetFilter()));
            }
            _peCombo->SetVisible(false);
            _peStatic->SetVisible(true);
            _CancelDelayShowCombo();
        }
    }
}

void ClientPicker::_DelayShowCombo()
{
    // Tell DirectUI to let the combo participate in layout again
    bool bNeedsCombo = _NeedsCombo();
    _peCombo->SetVisible(bNeedsCombo);
    _peStatic->SetVisible(!bNeedsCombo);

    // Force a relayout by shrinking the combo box a teensy bit, then
    // returning it to normal size. This cannot be done inside a
    // Defer because that ends up optimizing out the relayout.

    _peCombo->SetWidth(_peCombo->GetWidth()-1);
    _peCombo->RemoveLocalValue(WidthProp);

    if (!_bFilledCombo)
    {
        _bFilledCombo = true;

        SendMessage(_peCombo->GetHWND(), CB_RESETCONTENT, 0, 0);
        for (UINT i = 0; i < GetClientList()->GetSize(); i++)
        {
            _peCombo->AddString(GetClientList()->GetItem(i)->GetFilteredName(GetFilter()));
        }
        _peCombo->SetSelection(0);
    }
}

// If the user picked "Choose from list" and we are selected,
// then block OK since the user actually needs to choose something.

void ClientPicker::_CheckBlockOK(bool bSelected)
{
    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
    CLIENTINFO* pci = GetSelectedClient();
    if (pci)
    {
        if (bSelected && pci->IsPickFromList())
        {
            if (!_bBlockedOK)
            {
                _bBlockedOK = true;
                paf->BlockOKButton();
            }
        }
        else
        {
            if (_bBlockedOK)
            {
                _bBlockedOK = false;
                paf->UnblockOKButton();
            }
        }
    }
}

void ClientPicker::s_DelayShowCombo(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(hwnd, idEvent);
    ClientPicker* self = (ClientPicker*)idEvent;
    self->_DelayShowCombo();
}

void ClientPicker::_CancelDelayShowCombo()
{
    if (_hwndHost)
    {
        KillTimer(_hwndHost, (UINT_PTR)this);
        _hwndHost = NULL;
    }
}

void ClientPicker::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        // If the selection changed, then see if it's a change
        // that should block the OK button.
        if (pEvent->uidType == Combobox::SelectionChange)
        {
            _CheckBlockOK(GetSelected());
        }
    }

    super::OnEvent(pEvent);
}

//
//  CLIENTFILTER_OEM - add one if marked OEM, else "Keep unchanged"
//  CLIENTFILTER_MS  - add any that are marked MS, else "Keep unchanged"
//  CLIENTFILTER_NONMS - add any that are not marked MS, else "Keep unchanged"
//                       furthermore, if more than one non-MS, then
//                       add and select "Choose from list"
//
//  On success, returns the number of items added
//  (not counting "Keep unchanged" / "Choose from list")
//
HRESULT ClientPicker::SetFilter(CLIENTFILTER cf, ARPFrame* paf)
{
    HRESULT hr = E_FAIL;

    DUIAssert(_cf == 0, "SetFilter called more than once");
    _cf = cf;
    _bEmpty = true;
    _bFilledCombo = false;

    Value* pv;
    LPWSTR pszType = GetClientTypeString(&pv);
    if (pszType)
    {
        _pcb = paf->FindClientBlock(pszType);
        if (_pcb)
        {
            hr = _pcb->InitializeClientPicker(this);
        }
    }
    pv->Release();

    // The static element gets the first item in the list
    if (SUCCEEDED(hr) && GetClientList()->GetSize())
    {
        _SetStaticTextAndAccName(_peStatic, GetClientList()->GetItem(0)->_pszName);
    }

    if (SUCCEEDED(hr))
    {
        CalculateWidth();
        _SyncUIActive();
    }

    return hr;
}

//  Set our width to the width of the longest string in our combo box.
//  Combo boxes don't do this themselves, so they need our help.  We have
//  to set the width on ourselves and not on the combobox because
//  RowLayout will change the width of the combobox and HWNDHost will
//  treat the HWND width as authoritative, overwriting the combobox width
//  we had set.

void ClientPicker::CalculateWidth()
{
    HWND hwndCombo = _peCombo->GetHWND();
    HDC hdc = GetDC(hwndCombo);
    if (hdc)
    {
        HFONT hfPrev = SelectFont(hdc, GetWindowFont(hwndCombo));
        int cxMax = 0;
        SIZE siz;
        for (UINT i = 0; i < GetClientList()->GetSize(); i++)
        {
            LPCTSTR pszName = GetClientList()->GetItem(i)->GetFilteredName(GetFilter());
            if (GetTextExtentPoint(hdc, pszName, lstrlen(pszName), &siz) &&
                cxMax < siz.cx)
            {
                cxMax = siz.cx;
            }
        }
        SelectFont(hdc, hfPrev);
        ReleaseDC(hwndCombo, hdc);

        //  Add in the borders that USER adds to the combo box.
        //  Unfortunately, we get called when the combo box has been
        //  squished to zero width, so GetComboBoxInfo is of no use.
        //  We have to replicate the computations.
        //
        //  The client space is arranged horizontally like so:
        //
        //   SM_CXFIXEDFRAME
        //   v            v
        //  | |  edit    | | |
        //                  ^
        //       SM_CXVSCROLL

        RECT rc = { 0, 0, cxMax, 0 };
        rc.right += 2 * GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXVSCROLL);
        rc.right += GetSystemMetrics(SM_CXEDGE);    // extra edge for Hebrew/Arabic
        AdjustWindowRect(&rc, GetWindowStyle(hwndCombo), FALSE);
        SetWidth(rc.right - rc.left);
    }
}


HRESULT ClientPicker::TransferToCustom()
{
    HRESULT hr = E_FAIL;

    if (_pcb)
    {
        hr = _pcb->TransferFromClientPicker(this);
    }

    return hr;
}

CLIENTINFO* ClientPicker::GetSelectedClient()
{
    if (_peCombo)
    {
        UINT iSel = _peCombo->GetSelection();
        if (iSel < GetClientList()->GetSize())
        {
            return GetClientList()->GetItem(iSel);
        }
    }

    return NULL;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// ClientType property
static int vvCCClientType[] = { DUIV_STRING, -1 };
static PropertyInfo impCCClientTypeProp = { L"ClientType", PF_Normal, 0, vvCCClientType, NULL, Value::pvStringNull };
PropertyInfo* ClientPicker::ClientTypeProp = &impCCClientTypeProp;

// ParentExpanded property
static int vvParentExpanded[] = { DUIV_BOOL, -1 };
static PropertyInfo impParentExpandedProp = { L"parentexpanded", PF_Normal, 0, vvParentExpanded, NULL, Value::pvBoolFalse };
PropertyInfo* ClientPicker::ParentExpandedProp = &impParentExpandedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aClientPickerPI[] = {
    ClientPicker::ClientTypeProp,
    ClientPicker::ParentExpandedProp,
};

// Define class info with type and base type, set static class pointer

IClassInfo* ClientPicker::Class = NULL;
HRESULT ClientPicker::Register()
{
    return ClassInfo<ClientPicker,super>::Register(L"clientpicker", _aClientPickerPI, DUIARRAYSIZE(_aClientPickerPI));
}

////////////////////////////////////////////////////////
// ARP Parser

HRESULT ARPParser::Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    ARPParser* ap = HNew<ARPParser>();
    if (!ap)
        return E_OUTOFMEMORY;
    
    HRESULT hr = ap->Initialize(paf, uRCID, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        ap->Destroy();
        return hr;
    }

    *ppParser = ap;

    return S_OK;
}

HRESULT ARPParser::Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB)
{
    _paf = paf;
    return Parser::Initialize(uRCID, hInst, pfnErrorCB);
}

Value* ARPParser::GetSheet(LPCWSTR pszResID)
{
    // All style sheet mappings go through here. Redirect sheet queries to appropriate
    // style sheets (i.e. themed or standard look). _pParserStyle points to the
    // appropriate stylesheet-only Parser instance
    return _paf->GetStyleParser()->GetSheet(pszResID);
}

////////////////////////////////////////////////////////
//
//  AutoButton
//
//  A button that does a bunch of stuff that USER does automagically,
//  if it were a regular button control.
//
//  -   Automatically updates its own accessibility state and action
//  -   If a checkbox, autotoggles on click

HRESULT AutoButton::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    AutoButton* pb = HNew<AutoButton>();
    if (!pb)
        return E_OUTOFMEMORY;

    HRESULT hr = pb->Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
    {
        pb->Destroy();
        return hr;
    }

    *ppElement = pb;

    return S_OK;
}

void AutoButton::OnEvent(Event* pev)
{
    // Checkboxes auto-toggle on click

    if (pev->nStage == GMF_DIRECT &&
        pev->uidType == Button::Click &&
        GetAccRole() == ROLE_SYSTEM_CHECKBUTTON)
    {
        pev->fHandled = true;

        // Toggle the selected state
        SetSelected(!GetSelected());
    }

    super::OnEvent(pev);
}

//
//  Reflect the selected state to accessibility.
//
void AutoButton::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    super::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        int state = GetAccState();
        if (GetAccRole() == ROLE_SYSTEM_OUTLINEBUTTON)
        {
            // Outline buttons expose Selection as expanded/collapsed
            state &= ~(STATE_SYSTEM_EXPANDED | STATE_SYSTEM_COLLAPSED);
            if (pvNew->GetBool())
            {
                state |= STATE_SYSTEM_EXPANDED;
            }
            else
            {
                state |= STATE_SYSTEM_COLLAPSED;
            }
        }
        else
        {
            // Radio buttons and checkboxes expose Selection as checked/unchecked
            if (pvNew->GetBool())
            {
                state |= STATE_SYSTEM_CHECKED;
            }
            else
            {
                state &= ~STATE_SYSTEM_CHECKED;
            }
        }
        SetAccState(state);

        SyncDefAction();
    }
    else if (IsProp(AccRole))
    {
        SyncDefAction();
    }
}

//
//  Role strings from oleacc.  They are biased by 1100 since that is
//  where roles begin.
//
#define OLEACCROLE_EXPAND       (305-1100)
#define OLEACCROLE_COLLAPSE     (306-1100)
#define OLEACCROLE_CHECK        (309-1100)
#define OLEACCROLE_UNCHECK      (310-1100)

// Default action is "Check" if a radio button or an unchecked
// checkbox.  Default action is "Uncheck" if an unchecked checkbox.

void AutoButton::SyncDefAction()
{
    UINT idsAction;
    switch (GetAccRole())
    {
    // Checkbuttons will check or uncheck depending on state
    case ROLE_SYSTEM_CHECKBUTTON:
        idsAction = (GetAccState() & STATE_SYSTEM_CHECKED) ?
                            OLEACCROLE_UNCHECK :
                            OLEACCROLE_CHECK;
        break;

    // Radiobutton always checks.
    case ROLE_SYSTEM_RADIOBUTTON:
        idsAction = OLEACCROLE_CHECK;
        break;

    // Expando button expands or collapses.
    case ROLE_SYSTEM_OUTLINEBUTTON:
        idsAction = (GetAccState() & STATE_SYSTEM_EXPANDED) ?
                            OLEACCROLE_COLLAPSE :
                            OLEACCROLE_EXPAND;
        break;

    default:
        DUIAssert(0, "Unknown AccRole");
        return;

    }

    SetDefAction(this, idsAction);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer

IClassInfo* AutoButton::Class = NULL;
HRESULT AutoButton::Register()
{
    return ClassInfo<AutoButton,super>::Register(L"AutoButton", NULL, 0);
}

////////////////////////////////////////////////////////
// ClientBlock class
//
//  Manages a block of elements which expose all the clients registered
//  to a particular client category.

HRESULT ClientBlock::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ClientBlock* pcb = HNewAndZero<ClientBlock>();
    if (!pcb)
        return E_OUTOFMEMORY;

    HRESULT hr = pcb->Initialize();
    if (FAILED(hr))
    {
        pcb->Destroy();
        return hr;
    }

    *ppElement = pcb;

    return S_OK;
}

HRESULT ClientBlock::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize members
    hr = DynamicArray<CLIENTINFO*>::Create(0, false, &_pdaClients);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

ClientBlock::~ClientBlock()
{
    if (_pdaClients)
    {
        for (UINT i = 0; i < _pdaClients->GetSize(); i++)
        {
            _pdaClients->GetItem(i)->Delete();
        }
        _pdaClients->Destroy();
    }
}

//
//  If the user clicks a new default application, force it to be checked
//  and disable it so it cannot be unchecked.  Also re-enable the old one.
//
void ClientBlock::OnEvent(Event* pev)
{
    if (pev->nStage == GMF_BUBBLED &&
        pev->uidType == Selector::SelectionChange)
    {
        SelectionChangeEvent* sce = (SelectionChangeEvent*)pev;

        // Re-enable the previous guy, if any
        _EnableShowCheckbox(sce->peOld, true);

        // Disable the new guy, if any
        _EnableShowCheckbox(sce->peNew, false);
    }

    super::OnEvent(pev);
}

void ClientBlock::_EnableShowCheckbox(Element* peRadio, bool fEnable)
{
    if (peRadio)
    {
        Element* peRow = peRadio->GetParent();
        if (peRow)
        {
            Element* peShow = MaybeFindDescendentByName(peRow, L"show");
            if (peShow)
            {
                peShow->SetEnabled(fEnable);
                peShow->SetSelected(true); // force checked

                // HACKHACK - DUI doesn't realize that the checkbox needs
                // to be repainted so I have to kick it.
                InvalidateGadget(peShow->GetDisplayNode());
            }
        }
    }
}

//
//  ClientBlock initialization / apply methods...
//

HKEY ClientBlock::_OpenClientKey(HKEY hkRoot, DWORD dwAccess)
{
    HKEY hkClient = NULL;

    Value *pv;
    LPCWSTR pszClient = GetClientTypeString(&pv);
    if (pszClient)
    {
        WCHAR szBuf[MAX_PATH];
        wnsprintfW(szBuf, ARRAYSIZE(szBuf), TEXT("Software\\Clients\\%s"),
                   pszClient);
        RegOpenKeyExW(hkRoot, szBuf, 0, dwAccess, &hkClient);
        pv->Release();
    }
    return hkClient;
}

bool ClientBlock::_GetDefaultClient(HKEY hkClient, HKEY hkRoot, LPTSTR pszBuf, LONG cchBuf)
{
    bool bResult = false;
    HKEY hk = _OpenClientKey(hkRoot);
    if (hk)
    {
        DWORD cbSize = cchBuf * sizeof(*pszBuf);
        DWORD dwType;
        // Client must be defined, be of type REG_SZ, be non-NULL, and have
        // a corresponding entry in HKLM\Software\Clients.  RegQueryValue
        // is a handy abbreviatio for RegQueryKeyExists.
        LONG l;
        if (SHGetValue(hk, NULL, NULL, &dwType, pszBuf, &cbSize) == ERROR_SUCCESS &&
            dwType == REG_SZ && pszBuf[0] &&
            RegQueryValue(hkClient, pszBuf, NULL, &l) == ERROR_SUCCESS)
        {
            bResult = true;
        }
        RegCloseKey(hk);
    }
    return bResult;
}

//  Determines whether the current client is a Microsoft client different
//  from the Windows default client.  Usually, this is when the current
//  client is Outlook but the Windows default client is Outlook Express.

bool ClientBlock::_IsCurrentClientNonWindowsMS()
{
    bool bResult = false;

    HKEY hkClient = _OpenClientKey();
    if (hkClient)
    {
        TCHAR szClient[MAX_PATH];
        if (_GetDefaultClient(hkClient, HKEY_CURRENT_USER, szClient, ARRAYSIZE(szClient)) ||
            _GetDefaultClient(hkClient, HKEY_LOCAL_MACHINE, szClient, ARRAYSIZE(szClient)))
        {
            // Is it a Microsoft client that isn't the Windows default?
            if (_GetClientTier(szClient) == CBT_MS)
            {
                bResult = true;
            }
        }
        RegCloseKey(hkClient);
    }
    return bResult;
}

//
//  Called after the entire tree has been parsed and hosted.
//  (Sort of like readystatecomplete.)
//
HRESULT ClientBlock::ParseCompleted(ARPFrame *paf)
{
    HRESULT hr = S_OK;

    Value* pv;
    hr = _slOtherMSClients.SetStringList(GetOtherMSClientsString(&pv));
    pv->Release();

    if (SUCCEEDED(hr))
    {
        hr = paf->CreateElement(L"clientblockselector", NULL, (Element**)&_peSel);
        if (SUCCEEDED(hr))
        {
            hr = Add(_peSel);
            if (SUCCEEDED(hr))
            {
                // Failure to open the client key is not fatal; it just means that
                // there are vacuously no clients.

                HKEY hkClient = _OpenClientKey();
                if (hkClient)
                {
                    //  Enumerate each app under the client key and look for those which
                    //  have a "InstallInfo" subkey.
                    TCHAR szKey[MAX_PATH];
                    for (DWORD dwIndex = 0;
                         SUCCEEDED(hr) &&
                         RegEnumKey(hkClient, dwIndex, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS;
                         dwIndex++)
                    {
                        HKEY hkApp;
                        if (RegOpenKeyEx(hkClient, szKey, 0, KEY_READ, &hkApp) == ERROR_SUCCESS)
                        {
                            HKEY hkInfo;
                            if (RegOpenKeyEx(hkApp, TEXT("InstallInfo"), 0, KEY_READ, &hkInfo) == ERROR_SUCCESS)
                            {
                                // Woo-hoo, this client provided install info
                                // Let's see if it's complete.
                                CLIENTINFO* pci = CLIENTINFO::Create(hkApp, hkInfo, szKey);
                                if (pci)
                                {
                                    if (SUCCEEDED(hr = _pdaClients->Add(pci)))
                                    {
                                        // success
                                    }
                                    else
                                    {
                                        pci->Delete();
                                    }
                                }

                                RegCloseKey(hkInfo);
                            }
                            RegCloseKey(hkApp);
                        }
                    }

                    RegCloseKey(hkClient);

                    //
                    //  Sort the clients alphabetically to look nice.
                    //  (Otherwise they show up alphabetical by registry key name,
                    //  which is not very useful to an end-user.)
                    //
                    _pdaClients->Sort(CLIENTINFO::QSortCMP);

                }

                //
                //  Insert "Keep unchanged" and "Pick from list".
                //  Do this after sorting because we want those two
                //  to be at the top.  Since we are adding to the top,
                //  we add them in the reverse order so
                //  "Keep unchanged" = 1, "Pick from list" = 0.
                hr = AddStaticClientInfoToTop(KeepTextProp);
                if (SUCCEEDED(hr))
                {
                    hr = AddStaticClientInfoToTop(PickTextProp);
                }

                //  Now create one row for each client we found
                //  Start at i=1 to skip over "Pick from list"
                for (UINT i = 1; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
                {
                    CLIENTINFO* pci = _pdaClients->GetItem(i);
                    Element* pe;
                    hr = paf->CreateElement(L"clientitem", NULL, &pe);
                    if (SUCCEEDED(hr))
                    {
                        hr = _peSel->Add(pe);
                        if (SUCCEEDED(hr))
                        {
                            pci->_pe = pe;

                            // Set friendly name
                            pci->SetFriendlyName(pci->_pszName);

                            if (pci->IsSentinel())
                            {
                                // "Keep Unchanged" loses the checkboxes and defaults selected
                                // Merely hide the checkboxes instead of destroying them;
                                // this keeps RowLayout happy.
                                FindDescendentByName(pe, L"show")->SetVisible(false);
                                _peSel->SetSelection(pe);
                            }
                            else
                            {
                                // Others initialize the checkbox and default unselected
                                pci->SetShowCheckbox(pci->_bShown);
                            }

                        }
                        else // _peSel->Add(pe) failed
                        {
                            pe->Destroy();
                        }
                    }
                }
            }
            else // Add(_peSel) failed
            {
                _peSel->Destroy();
                _peSel = NULL;
            }

        }
    }

    return hr;
}

HRESULT ClientBlock::AddStaticClientInfoToTop(PropertyInfo* ppi)
{
    HRESULT hr;
    Value* pv;
    pv = GetValue(ppi, PI_Specified);
    CLIENTINFO* pci = CLIENTINFO::Create(NULL, NULL, pv->GetString());
    pv->Release();

    if (pci)
    {
        if (SUCCEEDED(hr = _pdaClients->Insert(0, pci)))
        {
            // maybe this block has a custom replacement text for the
            // Microsoft section if the current app is a Microsoft app.
            GetKeepMSTextString(&pci->_pvMSName);
        }
        else
        {
            pci->Delete();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

ClientBlock::CBTIER ClientBlock::_GetClientTier(LPCTSTR pszClient)
{
    Value* pv;
    LPWSTR pwsz;

    // Highest tier is "Windows default client"

    pwsz = GetWindowsClientString(&pv);
    bool bRet = pwsz && AreEnglishStringsEqual(pwsz, pszClient);
    pv->Release();

    if (bRet)
    {
        return CBT_WINDOWSDEFAULT;
    }

    // next best is "Microsoft client"
    if (_slOtherMSClients.IsStringInList(pszClient))
    {
        return CBT_MS;
    }

    // otherwise, it's a thirdparty app
    return CBT_NONMS;
}

//
//  Based on the filter, determine whether the specified item should
//  be shown, hidden, or left alone (returned as a TRIBIT), and optionally
//  determine whether the item should be added to the client picker.
//
TRIBIT ClientBlock::_GetFilterShowAdd(CLIENTINFO* pci, ClientPicker* pcp, bool* pbAdd)
{
    bool bAdd = false;
    TRIBIT tShow = TRIBIT_UNDEFINED;

    CBTIER cbt = _GetClientTier(pci->_pszKey);

    switch (pcp->GetFilter())
    {
    case CLIENTFILTER_OEM:
        //
        // Add the one that is marked "OEM Default".
        // (Caller will catch the "more than one" scenario.)
        // Set show/hide state according to OEM preference.
        //
        bAdd = pci->_bOEMDefault;
        if (bAdd) {
            tShow = TRIBIT_TRUE;
        } else {
            tShow = pci->_tOEMShown;
        }
        break;

    case CLIENTFILTER_MS:
        //
        //  Add the Windows preferred client.
        //  Show all applications except for "keep unchanged" (which
        //  isn't really an application anyway).
        //
        bAdd = IsWindowsDefaultClient(cbt);
        tShow = TRIBIT_TRUE;
        break;

    case CLIENTFILTER_NONMS:
        //
        //  Hide all Microsoft clients.
        //  Add all thirdparty clients and show them.
        //
        if (IsMicrosoftClient(cbt))
        {
            bAdd = false;
            tShow = TRIBIT_FALSE;
        }
        else
        {
            bAdd = true;
            tShow = TRIBIT_TRUE;
        }
        break;

    default:
        DUIAssert(0, "Invalid client filter category");
        break;
    }

    if (pbAdd)
    {
        *pbAdd = bAdd;
    }

    if (pci->IsSentinel())
    {
        tShow = TRIBIT_UNDEFINED;
    }

    return tShow;
}

//
//  On success, returns the number of items added
//  (not counting "Keep unchanged")
//

HRESULT ClientBlock::InitializeClientPicker(ClientPicker* pcp)
{
    HRESULT hr = S_OK;

    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);

    // Walk our children looking for ones that match the filter.
    HKEY hkClient = _OpenClientKey();
    if (hkClient)
    {
        if (SUCCEEDED(paf->CreateElement(L"oemclientshowhide", NULL, &pcp->_peShowHide)))
        {
            // Insert the template after our parent
            Element* peParent = pcp->GetParent();
            peParent->GetParent()->Insert(pcp->_peShowHide, peParent->GetIndex() + 1);
        }

        // Note!  Start loop with 2 because we don't care about
        // "Pick from list" or "Keep Unchanged" yet
        DUIAssert(_pdaClients->GetItem(0)->IsPickFromList(), "GetItem(0) must be 'Pick from list'");
        DUIAssert(_pdaClients->GetItem(1)->IsKeepUnchanged(), "GetItem(1) must be 'Keep unchanged'");
        for (UINT i = 2; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
        {
            CLIENTINFO* pci = _pdaClients->GetItem(i);
            bool bAdd;
            TRIBIT tShow = _GetFilterShowAdd(pci, pcp, &bAdd);

            if (pcp->_peShowHide)
            {
                switch (tShow)
                {
                case TRIBIT_TRUE:
                    pcp->AddClientToOEMRow(L"show", pci);
                    pcp->SetNotEmpty();
                    break;

                case TRIBIT_FALSE:
                    pcp->AddClientToOEMRow(L"hide", pci);
                    pcp->SetNotEmpty();
                    break;
                }
            }

            if (bAdd)
            {
                hr = pcp->GetClientList()->Add(pci);
                pcp->SetNotEmpty();
            }

        }

        RegCloseKey(hkClient);
    }

    if (SUCCEEDED(hr))
    {
        // Now some wacko cleanup rules.

        switch (pcp->GetFilter())
        {
        case CLIENTFILTER_OEM:
            // There can be only one OEM default item.
            // If there's more than one (OEM or app trying to cheat),
            // then throw them all away.
            if (pcp->GetClientList()->GetSize() != 1)
            {
                pcp->GetClientList()->Reset(); // throw away everything
            }
            break;

        case CLIENTFILTER_MS:
            // If the current client is not the default client but
            // does belong to Microsoft, then add "Keep unchanged"
            // and select it.  What's more, save the current string
            // to be used if the user picks the Windows client,
            // then append the Windows app to the "Also Show" string
            // and save that too.
            if (_IsCurrentClientNonWindowsMS())
            {
                hr = pcp->AddKeepUnchanged(_pdaClients->GetItem(1));
            }
            break;

        case CLIENTFILTER_NONMS:
            // If there is more than one available, then insert
            // "Pick an app"
            if (pcp->GetClientList()->GetSize() > 1)
            {
                hr = pcp->GetClientList()->Insert(0, _pdaClients->GetItem(0)); // insert "pick an app"
            }
            break;
        }

        // If there are no items, then add "Keep unchanged"
        if (pcp->GetClientList()->GetSize() == 0)
        {
            hr = pcp->GetClientList()->Add(_pdaClients->GetItem(1)); // add "keep unchanged"
        }
    }

    if (pcp->_peShowHide)
    {
        _RemoveEmptyOEMRow(pcp->_peShowHide, L"show");
        _RemoveEmptyOEMRow(pcp->_peShowHide, L"hide");
    }

    return hr;
}

HRESULT ClientPicker::AddKeepUnchanged(CLIENTINFO* pciKeepUnchanged)
{
    HRESULT hr = GetClientList()->Insert(0, pciKeepUnchanged); // insert "keep unchanged"
    return hr;
}

void ClientPicker::AddClientToOEMRow(LPCWSTR pszName, CLIENTINFO* pci)
{
    Element* peRow = FindDescendentByName(_peShowHide, pszName);
    Element* peList = FindDescendentByName(peRow, L"list");
    Value* pv;

    LPCWSTR pszContent = peList->GetContentString(&pv);
    if (!pszContent)
    {
        _SetStaticTextAndAccName(peList, pci->_pszName);
    }
    else
    {
        TCHAR szFormat[20];
        LPCWSTR rgpszInsert[2] = { pszContent, pci->_pszName };
        LoadString(g_hinst, IDS_ADDITIONALCLIENTFORMAT, szFormat, SIZECHARS(szFormat));
        LPWSTR pszFormatted;

        if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           szFormat, 0, 0, (LPWSTR)&pszFormatted, 0, (va_list*)rgpszInsert))
        {
            _SetStaticTextAndAccName(peList, pszFormatted);
            LocalFree(pszFormatted);
        }
    }
    pv->Release();
}

void ClientBlock::_RemoveEmptyOEMRow(Element* peShowHide, LPCWSTR pszName)
{
    Element* peRow = FindDescendentByName(peShowHide, pszName);
    Element* peList = FindDescendentByName(peRow, L"list");
    Value* pv;

    LPCWSTR pszContent = peList->GetContentString(&pv);
    if (!pszContent || !pszContent[0])
    {
        peRow->Destroy();
    }
    pv->Release();
}

// Take the setting from the ClientPicker and copy it to the Custom item
// This is done in preparation for Apply()ing the custom item to make the
// changes stick.
HRESULT ClientBlock::TransferFromClientPicker(ClientPicker* pcp)
{
    HRESULT hr = S_OK;
    CLIENTINFO* pciSel = pcp->GetSelectedClient();

    for (UINT i = 0; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
    {
        CLIENTINFO* pci = _pdaClients->GetItem(i);

        // If this is the one the guy selected, then select it here too
        if (pci == pciSel && _peSel)
        {
            if (pci->IsPickFromList())
            {
                // "Pick from list" -> "Keep unchanged"
                _peSel->SetSelection(_pdaClients->GetItem(1)->GetSetDefault());
            }
            else
            {
                _peSel->SetSelection(pci->GetSetDefault());
            }
        }

        // Transfer the hide/show setting into the element
        TRIBIT tShow = _GetFilterShowAdd(pci, pcp, NULL);

        if (tShow != TRIBIT_UNDEFINED)
        {
            pci->SetShowCheckbox(tShow == TRIBIT_TRUE);
        }
    }
    return hr;
}

//
//  Okay, here it is, the whole reason we're here.  Apply the user's
//  choices.
//
HRESULT ClientBlock::Apply(ARPFrame* paf)
{
    HRESULT hr = S_OK;
    HKEY hkClient = _OpenClientKey(HKEY_LOCAL_MACHINE, KEY_READ | KEY_WRITE);
    if (hkClient)
    {
        // Note!  Start loop with 2 because we don't care about applying "Keep Unchanged"
        // or "Pick an app"
        DUIAssert(_pdaClients->GetItem(0)->IsPickFromList(), "GetItem(0) must be 'Pick from list'");
        DUIAssert(_pdaClients->GetItem(1)->IsKeepUnchanged(), "GetItem(1) must be 'Keep unchanged'");
        for (UINT i = 2; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
        {
            CLIENTINFO* pci = _pdaClients->GetItem(i);

            TCHAR szBuf[MAX_PATH];
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\\InstallInfo"), pci->_pszKey);
            HKEY hkInfo;
            if (RegOpenKeyEx(hkClient, szBuf, 0, KEY_READ, &hkInfo) == ERROR_SUCCESS)
            {
                // Always do hide/show first.  That way, an application being
                // asked to set itself as the default always does so while its
                // icons are shown.

                bool bShow = pci->IsShowChecked();
                if (bShow != pci->_bShown)
                {
                    if (pci->GetInstallCommand(hkInfo, bShow ? TEXT("ShowIconsCommand") : TEXT("HideIconsCommand"),
                                               szBuf, DUIARRAYSIZE(szBuf)))
                    {
                        hr = paf->LaunchClientCommandAndWait(bShow ? IDS_SHOWINGICONS : IDS_HIDINGICONS, pci->_pszName, szBuf);
                    }
                }

                if (pci->GetSetDefault()->GetSelected())
                {
                    if (pci->GetInstallCommand(hkInfo, TEXT("ReinstallCommand"),
                                               szBuf, DUIARRAYSIZE(szBuf)))
                    {
                        FILETIME ft;
                        GetSystemTimeAsFileTime(&ft);
                        SHSetValue(hkClient, NULL, TEXT("LastUserInitiatedDefaultChange"),
                                   REG_BINARY, &ft, sizeof(ft));
                        hr = paf->LaunchClientCommandAndWait(IDS_SETTINGDEFAULT, pci->_pszName, szBuf);
                    }
                }

                RegCloseKey(hkInfo);
            }
        }
        RegCloseKey(hkClient);
    }
    return hr;
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// ClientType property
static int vvClientType[] = { DUIV_STRING, -1 };
static PropertyInfo impClientTypeProp = { L"ClientType", PF_Normal, 0, vvClientType, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::ClientTypeProp = &impClientTypeProp;

// WindowsClient property
static int vvWindowsClient[] = { DUIV_STRING, -1 };
static PropertyInfo impWindowsClientProp = { L"WindowsClient", PF_Normal, 0, vvWindowsClient, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::WindowsClientProp = &impWindowsClientProp;

// OtherMSClients property
static int vvOtherMSClients[] = { DUIV_STRING, -1 };
static PropertyInfo impOtherMSClientsProp = { L"OtherMSClients", PF_Normal, 0, vvOtherMSClients, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::OtherMSClientsProp = &impOtherMSClientsProp;

// KeepText property
static int vvKeepText[] = { DUIV_STRING, -1 };
static PropertyInfo impKeepTextProp = { L"KeepText", PF_Normal, 0, vvKeepText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::KeepTextProp = &impKeepTextProp;

// KeepMSText property
static int vvKeepMSText[] = { DUIV_STRING, -1 };
static PropertyInfo impKeepMSTextProp = { L"KeepMSText", PF_Normal, 0, vvKeepMSText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::KeepMSTextProp = &impKeepMSTextProp;

// PickText property
static int vvPickText[] = { DUIV_STRING, -1 };
static PropertyInfo impPickTextProp = { L"PickText", PF_Normal, 0, vvPickText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::PickTextProp = &impPickTextProp;

// Class properties
PropertyInfo* _aClientBlockPI[] = {
    ClientBlock::ClientTypeProp,
    ClientBlock::WindowsClientProp,
    ClientBlock::OtherMSClientsProp,
    ClientBlock::KeepTextProp,
    ClientBlock::KeepMSTextProp,
    ClientBlock::PickTextProp,
};

// Define class info with type and base type, set static class pointer
IClassInfo* ClientBlock::Class = NULL;
HRESULT ClientBlock::Register()
{
    return ClassInfo<ClientBlock,super>::Register(L"clientblock", _aClientBlockPI, DUIARRAYSIZE(_aClientBlockPI));
}


////////////////////////////////////////////////////////
// Expandable class
//
//  Base class for Expando and Clipper.  It is just an element
//  with an "expanded" property.  This property inherits from parent
//  to child.  This is used so Clipper can inherit (and therefore
//  react to) the expanded state of its parent Expando.
//

HRESULT Expandable::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expandable* pe = HNew<Expandable>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Expanded property
static int vvExpanded[] = { DUIV_BOOL, -1 };
static PropertyInfo impExpandedProp = { L"Expanded", PF_Normal|PF_Inherit, 0, vvExpanded, NULL, Value::pvBoolTrue };
PropertyInfo* Expandable::ExpandedProp = &impExpandedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aExpandablePI[] = { Expandable::ExpandedProp };

// Define class info with type and base type, set static class pointer
IClassInfo* Expandable::Class = NULL;
HRESULT Expandable::Register()
{
    return ClassInfo<Expandable,super>::Register(L"Expandable", _aExpandablePI, DUIARRAYSIZE(_aExpandablePI));
}

////////////////////////////////////////////////////////
// Expando class
//
//  An Expando element works in conjunction with a Clipper element
//  to provide expand/collapse functionality.
//
//  The Expando element manages the expanded/contracted state.
//  The Expando element has two child elements:
//
//      The first element is a button (the "header").
//      The second element is a Clipper.
//
//  The Clipper vanishes when contracted and is shown when expanded.
//  The header is always shown.
//
//  One of the elements in the header must be a button of type "arrow".
//  Clicking this button causes the Expando to expand/collapse.
//
//  A click on any other element causes an Expando::Click event
//  to fire (to be caught by an ancestor element.)
//
//  The "selected" property on the "arrow" tracks the "expanded"
//  property on the Expando.
//

DefineClassUniqueID(Expando, Click)

HRESULT Expando::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expando* pex = HNewAndZero<Expando>();
    if (!pex)
        return E_OUTOFMEMORY;

    HRESULT hr = pex->Initialize();
    if (FAILED(hr))
    {
        pex->Destroy();
        return hr;
    }

    *ppElement = pex;

    return S_OK;
}

HRESULT Expando::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    _fExpanding = false;

    return S_OK;
}

Clipper* Expando::GetClipper()
{
    Element* pe = GetNthChild(this, 1);
    DUIAssertNoMsg(pe->GetClassInfo()->IsSubclassOf(Clipper::Class));
    return (Clipper*)pe;
}

//
//  Do this so ARPSelector will select us and deselect our siblings
//
void Expando::FireClickEvent()
{
    Event e;
    e.uidType = Expando::Click;
    FireEvent(&e);      // Will route and bubble
}

void Expando::OnEvent(Event* pev)
{
    if (pev->nStage == GMF_BUBBLED)
    {
        if (pev->uidType == Button::Click)
        {
            pev->fHandled = true;

            // Clicking the arrow toggles the expanded state
            if (pev->peTarget->GetID() == StrToID(L"arrow"))
            {
                SetExpanded(!GetExpanded());
            }
            else
            {
                // Clicking anything else activates our section
                FireClickEvent();
            }
        }
    }

    Element::OnEvent(pev);
}

////////////////////////////////////////////////////////
// System events

HRESULT _SetParentExpandedProp(ClientPicker* pcp, LPARAM lParam)
{
    Value* pv = (Value*)lParam;
    pcp->SetValue(ClientPicker::ParentExpandedProp, PI_Local, pv);
    return S_OK;
}

void Expando::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        // BUGBUG something goes here?
    }
    else if (IsProp(Expanded))
    {
        // Update height of clipper based on expanded state
        Element* pe = GetClipper();
        if (pe)
        {
            // The following will cause a relayout, mark object so that
            // when the expando's Extent changes, it'll go through
            // with the EnsureVisible. Otherwise, it's being resized
            // as a result of something else. In which case, do nothing.
            _fExpanding = true;

            // To achieve "pulldown" animation, we use a clipper control that will
            // size it's child based on it's unconstrained desired size in its Y direction.
            // We also push the Expanded property into all child ClientPicker
            // elements as the Selected property so they can turn static when
            // collapsed.
            if (pvNew->GetBool())
            {
                pe->RemoveLocalValue(HeightProp);
            }
            else
            {
                pe->SetHeight(0);
            }
            TraverseTree<ClientPicker>(pe, _SetParentExpandedProp, (LPARAM)pvNew);
        }
        // child Clipper object inherits the Expanded state

        // Push the Expanded state as the arrow's Selected state
        FindDescendentByName(this, L"arrow")->SetValue(SelectedProp, PI_Local, pvNew);

    }
    else if (IsProp(Extent))
    {
        if (_fExpanding && GetExpanded())
        {
            _fExpanding = false;

            // On extent, we want to ensure that not just the client area but
            // also the bottom margin of the expando is visible.  Why?  Simply
            // because it looks better to scroll the expando plus its margin
            // into view versus just the expando.
            //
            Value* pvSize;
            Value* pvMargin;
            const SIZE* psize = GetExtent(&pvSize);
            const RECT* prect = GetMargin(&pvMargin);
            EnsureVisible(0, 0, psize->cx, psize->cy + prect->bottom);
            pvSize->Release();
            pvMargin->Release();
        }
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Expando::Class = NULL;
HRESULT Expando::Register()
{
    return ClassInfo<Expando,super>::Register(L"Expando", NULL, 0);
}

////////////////////////////////////////////////////////
//
//  Clipper class
//
//  Used to do the smooth hide/show animation.
//
//  The Clipper element animates away its one child, typically
//  an <element> with layout and inner child elements.
//

HRESULT Clipper::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Clipper* pc = HNewAndZero<Clipper>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT Clipper::Initialize()
{
    // Initialize base
    HRESULT hr = super::Initialize(EC_SelfLayout); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    return S_OK;
}

////////////////////////////////////////////////////////
// Self-layout methods

SIZE Clipper::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(cyConstraint);

    SIZE size = { 0, 0 };

    // Desired size of this is based solely on it's first child.
    // Width is child's width, height is unconstrained height of child.
    Element* pec = GetNthChild(this, 0);
    if (pec)
    {
        size = pec->_UpdateDesiredSize(cxConstraint, INT_MAX, psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    return size;
}

void Clipper::_SelfLayoutDoLayout(int cx, int cy)
{

    // Layout first child giving it's desired height and aligning
    // it with the clipper's bottom edge
    Element* pec = GetNthChild(this, 0);
    if (pec)
    {
        const SIZE* pds = pec->GetDesiredSize();

        pec->_UpdateLayoutPosition(0, cy - pds->cy);
        pec->_UpdateLayoutSize(cx, pds->cy);
    }
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Clipper::Class = NULL;
HRESULT Clipper::Register()
{
    return ClassInfo<Clipper,super>::Register(L"Clipper", NULL, 0);
}

////////////////////////////////////////////////////////
// GradientLine class
//
//  This is necessary for two reasons.
//
//  1.  gradient(...) doesn't support FILLTYPE_TriHGradient.
//      The code to implement tri-gradients exists only in
//      the GdiPlus version.  We can fake it by putting two
//      FILLTYPE_HGradient elements next to each other, except
//      for the second problem...
//  2.  gradient(...) doesn't support system colors like "buttonface".
//

HRESULT GradientLine::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    GradientLine* pe = HNew<GradientLine>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

COLORREF GradientLine::GetColorProperty(PropertyInfo* ppi)
{
    // on failure, use transparent color (i.e., nothing happens)
    COLORREF cr = ARGB(0xFF, 0, 0, 0);

    Value* pv = GetValue(ppi, PI_Specified);
    switch (pv->GetType())
    {
    case DUIV_INT:
        cr = ColorFromEnumI(pv->GetInt());
        break;

    case DUIV_FILL:
        {
            const Fill* pf = pv->GetFill();
            if (pf->dType == FILLTYPE_Solid)
            {
                cr = pf->ref.cr;
            }
            else
            {
                DUIAssert(0, "GradientLine supports only solid colors");
            }
        }
        break;

    default:
        DUIAssert(0, "GradientLine supports only solid colors");
    }
    pv->Release();

    return cr;
}

void GradientLine::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    // Paint default except content
    RECT rcContent;
    Element::Paint(hDC, prcBounds, prcInvalid, prcSkipBorder, &rcContent);

    // Render gradient content if requested
    if (!prcSkipContent)
    {
        //
        //  Vertices are as indicated.  The two rectangles are (0-1) and (1-2).
        //
        //  0(bgcolor)                         2(bgcolor)
        //  +-----------------+----------------+
        //  |                                  |
        //  |                                  |
        //  |                                  |
        //  +-----------------+----------------+
        //                    1(fgcolor)

        TRIVERTEX rgvert[3];
        GRADIENT_RECT rggr[2];
        COLORREF cr;

        cr = GetColorProperty(BackgroundProp);
        rgvert[0].x     = rcContent.left;
        rgvert[0].y     = rcContent.top;
        rgvert[0].Red   = GetRValue(cr) << 8;
        rgvert[0].Green = GetGValue(cr) << 8;
        rgvert[0].Blue  = GetBValue(cr) << 8;
        rgvert[0].Alpha = GetAValue(cr) << 8;

        rgvert[2] = rgvert[0];
        rgvert[2].x     = rcContent.right;

        cr = GetColorProperty(ForegroundProp);
        rgvert[1].x     = (rcContent.left + rcContent.right) / 2;
        rgvert[1].y     = rcContent.bottom;
        rgvert[1].Red   = GetRValue(cr) << 8;
        rgvert[1].Green = GetGValue(cr) << 8;
        rgvert[1].Blue  = GetBValue(cr) << 8;
        rgvert[1].Alpha = GetAValue(cr) << 8;

        rggr[0].UpperLeft = 0;
        rggr[0].LowerRight = 1;
        rggr[1].UpperLeft = 1;
        rggr[1].LowerRight = 2;
        GradientFill(hDC, rgvert, DUIARRAYSIZE(rgvert), rggr, DUIARRAYSIZE(rggr), GRADIENT_FILL_RECT_H);
    }
    else
    {
        *prcSkipContent = rcContent;
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* GradientLine::Class = NULL;
HRESULT GradientLine::Register()
{
    return ClassInfo<GradientLine,super>::Register(L"GradientLine", NULL, 0);
}


////////////////////////////////////////////////////////
// BigElement class
//
//  This is necessary because the DUI parser limits rcstr() to 256
//  characters and we have strings that are dangerously close to that
//  limit.  (So localization will likely push them over the limit.)
//

HRESULT BigElement::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    BigElement* pe = HNew<BigElement>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

void BigElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(StringResID))
    {
        UINT uID = pvNew->GetInt();
        HRSRC hrsrc = FindResource(g_hinst, (LPTSTR)(LONG_PTR)(1 + uID / 16), RT_STRING);
        if (hrsrc)
        {
            PWCHAR pwch = (PWCHAR)LoadResource(g_hinst, hrsrc);
            if (pwch)
            {
                // Now skip over strings until we hit the one we want.
                for (uID %= 16; uID; uID--)
                {
                    pwch += *pwch + 1;
                }

                // Found it -- load the entire string and set it
                LPWSTR pszString = new WCHAR[*pwch + 1];
                if (pszString)
                {
                    memcpy(pszString, pwch+1, *pwch * sizeof(WCHAR));
                    pszString[*pwch] = L'\0';
                    SetContentString(pszString);
                    SetAccName(pszString);
                    delete[] pszString;
                }
            }
        }
    }
}


////////////////////////////////////////////////////////
// Property definitions

// StringResID property
static int vvStringResID[] = { DUIV_INT, -1 };
static PropertyInfo impStringResIDProp = { L"StringResID", PF_Normal, 0, vvStringResID, NULL, Value::pvIntZero };
PropertyInfo* BigElement::StringResIDProp = &impStringResIDProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aBigElementPI[] = { BigElement::StringResIDProp };

// Define class info with type and base type, set static class pointer
IClassInfo* BigElement::Class = NULL;
HRESULT BigElement::Register()
{
    return ClassInfo<BigElement,super>::Register(L"BigElement", _aBigElementPI, DUIARRAYSIZE(_aBigElementPI));
}


////////////////////////////////////////////////////////
// ARP Parser callback

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
    {
        StringCchPrintfW(buf, ARRAYSIZE(buf), L"%s '%s' at line %d", pszError, pszToken, dLine);
    }
    else
    {
        StringCchPrintfW(buf, ARRAYSIZE(buf), L"%s '%s'", pszError, pszToken);
    }

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

void inline SetElementAccessability(Element* pe, bool bAccessible, int iRole, LPCWSTR pszAccName)
{
    if (pe) 
    {
        pe->SetAccessible(bAccessible);
        pe->SetAccRole(iRole);
        pe->SetAccName(pszAccName);
    }
}

void EnablePane(Element* pePane, bool fEnable)
{
    if (fEnable)
    {
        pePane->SetLayoutPos(BLP_Client);
        EnableElementTreeAccessibility(pePane);
    }
    else
    {
        pePane->SetLayoutPos(LP_None);
        DisableElementTreeAccessibility(pePane);
    }
}

void BestFitOnDesktop(RECT* r)
{
    ASSERT(r != NULL);
    
    RECT wr; // Rect to hold size of work area
    
    if (SystemParametersInfo(SPI_GETWORKAREA, 0, &wr, 0)) 
    {
        if ((wr.right-wr.left) < ARP_DEFAULT_WIDTH) 
        {
            // Default width is too large, use the entire width of the desktop area
            r->left = wr.left;
            r->right = wr.right - wr.left;
        }
        else 
        {
            // Center on screen using default width
            r->left = wr.left + (((wr.right-wr.left) - ARP_DEFAULT_WIDTH) / 2);
            r->right = ARP_DEFAULT_WIDTH;
        }

        if ((wr.bottom-wr.top) < ARP_DEFAULT_HEIGHT)
        {
            // Default height is too large, use the entire height of the desktop area
            r->top = wr.top;
            r->bottom = wr.bottom - wr.top;
        }
        else
        {
            // Center on screen using default height
            r->top = wr.top + (((wr.bottom-wr.top) - ARP_DEFAULT_HEIGHT) / 2); 
            r->bottom = ARP_DEFAULT_HEIGHT;
        }
    }
    else
    {
        // Don't know why the function would fail, but if it does just use the default size
        // and position
        SetRect(r, 
                ARP_DEFAULT_POS_X,
                ARP_DEFAULT_POS_Y,
                ARP_DEFAULT_WIDTH,
                ARP_DEFAULT_HEIGHT);
    }
}
    
////////////////////////////////////////////////////////
// ARP entry point

DWORD WINAPI PopulateInstalledItemList(void* paf);

STDAPI ARP(HWND hWnd, int nPage)
{
    HRESULT hr;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    ARPFrame* paf = NULL;
    Element* pe = NULL;
    RECT rect;
    
    WCHAR szTemp[1024];

    // DirectUI init process
    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    // Register classes
    hr = ARPFrame::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPHelp::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSupportItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSelector::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ClientPicker::Register();
    if (FAILED(hr))
        goto Failure;

    hr = AutoButton::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ClientBlock::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expandable::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expando::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Clipper::Register();
    if (FAILED(hr))
        goto Failure;

    hr = GradientLine::Register();
    if (FAILED(hr))
        goto Failure;

    hr = BigElement::Register();
    if (FAILED(hr))
        goto Failure;

    // DirectUI init thread
    hr = InitThread();
    if (FAILED(hr))
        goto Failure;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        goto Failure;

    Element::StartDefer();

    // Create host
    LoadStringW(g_hinst, IDS_ARPTITLE, szTemp, DUIARRAYSIZE(szTemp));

    BestFitOnDesktop(&rect);
    hr = NativeHWNDHost::Create(szTemp, hWnd, LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON)), rect.left, rect.top, rect.right, rect.bottom, WS_EX_APPWINDOW, WS_OVERLAPPEDWINDOW, 0, &pnhh);
    if (FAILED(hr))
        goto Failure;   

    hr = ARPFrame::Create(pnhh, true, (Element**)&paf);
    if (FAILED(hr))
        goto Failure;

    // Load resources
    ARPParser::Create(paf, IDR_ARP, g_hinst, ARPParseError, &pParser);

    if (!pParser || pParser->WasParseError())
        goto Failure;

    pParser->CreateElement(L"main", paf, &pe);
    if (pe && // Fill contents using substitution
        paf->Setup(pParser, nPage)) // Set ARPFrame state (incluing ID initialization)
    {
        // Set visible and host
        paf->SetVisible(true);
        pnhh->Host(paf);

        Element::EndDefer();

        // Do initial show
        pnhh->ShowWindow();
        Element* peClose = ((ARPFrame*)pe)->FallbackFocus();
        if (peClose)
        {
            peClose->SetKeyFocus();
        }

        if (!paf->IsChangeRestricted())
        {
            paf->UpdateInstalledItems();
        }

        // Pump messages
        MSG msg;
        bool fDispatch = true;
        while (GetMessageW(&msg, 0, 0, 0) != 0)
        {
            // Check for destruction of top-level window (always async)
            if (msg.hwnd == pnhh->GetHWND() && msg.message == NHHM_ASYNCDESTROY)
            {
                // Async destroy requested, clean up secondary threads

                // Signal that secondary threads should complete as soon as possible
                // Any requests from secondary threads will be ignored
                // No more secondary threads will be allowed to start
                g_fRun = false;

                // Hide window, some threads may need more time to exit normally
                pnhh->HideWindow();

                // Don't dispatch this one
                if (!g_fAppShuttingDown)
                    fDispatch = false;
            }

            // Check for pending threads
            if (!g_fRun)
            {
                if (!ARPFrame::htPopulateInstalledItemList && 
                    !ARPFrame::htPopulateAndRenderOCSetupItemList &&
                    !ARPFrame::htPopulateAndRenderPublishedItemList)
                {
                    if (!g_fAppShuttingDown)
                    {
                        // Done, reissue async destroy
                        DUITrace(">> App shutting down, async destroying main window\n");
                        g_fAppShuttingDown = true;
                        pnhh->DestroyWindow();
                    }
                }
            }
        
            if (fDispatch)
            {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            else
                fDispatch = true;
        }

        // paf will be deleted by native HWND host when destroyed
    }
    else
        Element::EndDefer();

Failure:

    if (pnhh)
    {
        if (pnhh->GetHWND())
        {
            // In the error case we didn't destroy the window cleanly, so
            // we need to do it viciously.  Cannot use pnhh->DestroyWindow()
            // because that defers the destroy but we need it to happen now.
            DestroyWindow(pnhh->GetHWND());
        }
        pnhh->Destroy();
    }
    if (pParser)
        pParser->Destroy();

    CoUninitialize();
    UnInitThread();
    UnInitProcess();

    return 0;
}

DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy)
{
    return SHGetRestriction(NULL, L"Uninstall", pszPolicy);
}

bool _cdecl ARPIsOnDomain()
{
    // NOTE: assume it's on the domain 
    bool bRet = true;
    LPWSTR pszDomain;
    NETSETUP_JOIN_STATUS nsjs;
    
    if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
    {
        if (nsjs != NetSetupDomainName)
            bRet = FALSE;
        NetApiBufferFree(pszDomain);
    }
    return bRet;
}

////////////////////////////////////////////////////////
// Async ARP item population thread

////////////////////////////////////////////////////////
// Query system and enumerate installed apps

HRESULT BuildPublishedAppArray(IEnumPublishedApps *penum, HDSA *phdsaPubApps);
HRESULT InstallPublishedAppArray(ARPFrame *paf, HDSA hdsaPubApps, UINT *piCount);
HRESULT InsertPubAppInPubAppArray(HDSA hdsa, IPublishedApp *ppa);
HRESULT GetPubAppName(IPublishedApp *ppa, LPWSTR *ppszName);
int CALLBACK DestroyPublishedAppArrayEntry(void *p, void *pData);

DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateAndRenderPublishedItemList' STARTED.\n");

    HRESULT hr;
    UINT iCount = 0;
    IShellAppManager* pisam = NULL;
    IEnumPublishedApps* piepa = NULL;
    IPublishedApp* pipa = NULL;
    HDCONTEXT hctx = NULL;

    // Initialize
    HRESULT hrOle = CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    if (!((ARPFrame*)paf)->GetPublishedComboFilled())
    {
        // Get the list of categories
        SHELLAPPCATEGORYLIST* psacl = ((ARPFrame*)paf)->GetShellAppCategoryList();
        if (psacl == NULL)
        {
            psacl = new SHELLAPPCATEGORYLIST; 
        }
        if (psacl == NULL)
        {
            goto Cleanup;
        }
        else
        {
            ((ARPFrame*)paf)->SetShellAppCategoryList(psacl);
        }
        hr = pisam->GetPublishedAppCategories(psacl);
        ((ARPFrame*)paf)->PopulateCategoryCombobox();
        ((ARPFrame*)paf)->SetPublishedComboFilled(true);
    }

    hr = pisam->EnumPublishedApps(((ARPFrame*)paf)->GetCurrentPublishedCategory(), &piepa);
    HRCHK(hr);

    HDSA hdsaPubApps = NULL;
    hr = BuildPublishedAppArray(piepa, &hdsaPubApps);
    HRCHK(hr);
    
    hr = InstallPublishedAppArray((ARPFrame *)paf, hdsaPubApps, &iCount);
    HRCHK(hr);

    if (iCount == 0)
    {
        ((ARPFrame*)paf)->FeedbackEmptyPublishedList();
    }

Cleanup:

    if (NULL != hdsaPubApps)
    {
        DSA_DestroyCallback(hdsaPubApps, DestroyPublishedAppArrayEntry, NULL);
        hdsaPubApps = NULL;
    }

    if (paf)
    {
        ((ARPFrame*)paf)->OnPublishedListComplete();
        ((ARPFrame*)paf)->SetPublishedListFilled(true);
    }

    if (pisam)
        pisam->Release();
    if (piepa)
        piepa->Release();

    if (hctx)
        DeleteHandle(hctx);

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    // Thread is done
    ARPFrame::htPopulateAndRenderPublishedItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateAndRenderPublishedItemList' DONE.\n");

    return 0;
}


// ----------------------------------------------------------------------------
// Handling published apps with duplicate names
// ----------------------------------------------------------------------------
//
// Entry in dynamic array of published app items.
// Entries with duplicate application names must be identifed
// in the UI by appending the applicable publishing source name
// to the display name of the application.  In order to do this,
// we need to assemble all of the published entries in a sorted
// array then mark as such those that have duplicate names.
// When the array items are added to the ARP frame, the items
// marked 'duplicate' have their publisher's name appended to
// their application name.
//
struct PubItemListEntry
{
    IPublishedApp *ppa;  // The published app object.
    bool bDuplicateName; // Does it have a duplicate name?
};


//
// Build the dynamic array of app/duplicate information.
// One entry for each published app.  If this function succeeds,
// the caller is responsible for destroying the returnd DSA.
//
HRESULT
BuildPublishedAppArray(
    IEnumPublishedApps *penum,
    HDSA *phdsaPubApps
    )
{
    ASSERT(NULL != penum);
    ASSERT(NULL != phdsaPubApps);
    
    HRESULT hr = S_OK;
    //
    // Create a large DSA so that we minimize resizing.
    //
    HDSA hdsa = DSA_Create(sizeof(PubItemListEntry), 512);
    if (NULL != hdsa)
    {
        IPublishedApp *ppa;
        while(g_fRun)
        {
            hr = THR(penum->Next(&ppa));
            if (S_OK == hr)
            {
                //
                // Ignore any errors related to a specific published app.
                //
                THR(InsertPubAppInPubAppArray(hdsa, ppa));
                ppa->Release();
            }
            else
            {
                break;
            }
        }
        if (FAILED(hr))
        {
            DSA_DestroyCallback(hdsa, DestroyPublishedAppArrayEntry, NULL);
            hdsa = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    ASSERT(FAILED(hr) || NULL != hdsa);
    *phdsaPubApps = hdsa;
    return THR(hr);
}


//
// Retrieve the application name string for a given published app.
// If this function succeeds, the caller is responsible for freeing
// the name string by using SHFree.
//
HRESULT
GetPubAppName(
    IPublishedApp *ppa,
    LPWSTR *ppszName
    )
{
    ASSERT(NULL != ppa);
    ASSERT(NULL != ppszName);
    
    APPINFODATA aid;
    aid.cbSize = sizeof(aid);
    aid.dwMask = AIM_DISPLAYNAME;

    *ppszName = NULL;

    HRESULT hr = THR(ppa->GetAppInfo(&aid));
    if (SUCCEEDED(hr))
    {
        if (AIM_DISPLAYNAME & aid.dwMask)
        {
            *ppszName = aid.pszDisplayName;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return THR(hr);
}
    
    
//
// Insert a published app into the published app array.
// Upon return, the dynamic array is sorted by published app name 
// and all duplicate entries are marked with their bDuplicateName
// member set to 'true'.
//
HRESULT
InsertPubAppInPubAppArray(
    HDSA hdsa,
    IPublishedApp *ppa
    )
{
    ASSERT(NULL != hdsa);
    ASSERT(NULL != ppa);

    LPWSTR pszAppName;
    HRESULT hr = THR(GetPubAppName(ppa, &pszAppName));
    if (SUCCEEDED(hr))
    {
        //
        // Create the new entry.  We'll addref the COM pointer
        // only after the item is successfully inserted into the array.
        //
        PubItemListEntry entryNew = { ppa, false };
        //
        // Find the insertion point so that the array is 
        // sorted by app name.
        //
        const int cEntries = DSA_GetItemCount(hdsa);
        int iInsertHere = 0; // Insertion point.
        PubItemListEntry *pEntry = NULL;

        for (iInsertHere = 0; iInsertHere < cEntries; iInsertHere++)
        {
            pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsa, iInsertHere);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                LPWSTR psz;
                hr = THR(GetPubAppName(pEntry->ppa, &psz));
                if (SUCCEEDED(hr))
                {
                    int iCompare = lstrcmpi(psz, pszAppName);
                    SHFree(psz);
                    psz = NULL;
                    
                    if (0 <= iCompare)
                    {
                        //
                        // This is the insertion point.
                        //
                        if (0 == iCompare)
                        {
                            //
                            // This entry has the same name.
                            //
                            entryNew.bDuplicateName = true;
                            pEntry->bDuplicateName  = true;
                        }
                        break;
                    }
                }
            }
        }
        //
        // Now mark all other duplicates.  Note that if the entry
        // currently at the insertion point is a duplicate of the
        // entry we're inserting, we've already marked it as a duplicate
        // above.  Therefore, we can start with the next entry.
        //
        for (int i = iInsertHere + 1; i < cEntries; i++)
        {
            pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsa, i);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                LPWSTR psz;
                hr = THR(GetPubAppName(pEntry->ppa, &psz));
                if (SUCCEEDED(hr))
                {
                    int iCompare = lstrcmpi(psz, pszAppName);
                    SHFree(psz);
                    psz = NULL;
                    //
                    // Assert that the array is sorted alphabetically.
                    //
                    ASSERT(0 <= iCompare);
                    if (0 == iCompare)
                    {
                        //
                        // Yep, another duplicate.
                        //
                        pEntry->bDuplicateName = true;
                    }
                    else
                    {
                        break; // No need to look further.
                    }
                }
            }
        }

        //
        // Insert the new item.
        //
        if (-1 != DSA_InsertItem(hdsa, iInsertHere, &entryNew))
        {
            entryNew.ppa->AddRef();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        SHFree(pszAppName);
    }
    return THR(hr);
}
                
    
//
// Given a DSA of application/duplicate-flag pairs, install
// the items in the ARP frame.
//
HRESULT
InstallPublishedAppArray(
    ARPFrame *paf,
    HDSA hdsaPubApps, 
    UINT *piCount     // optional.  Can be NULL.
    )
{
    ASSERT(NULL != paf);
    ASSERT(NULL != hdsaPubApps);
    
    int cEntries = DSA_GetItemCount(hdsaPubApps);
    paf->SetPublishedItemCount(cEntries);

    UINT iCount = 0;
    for (int i = 0; i < cEntries && g_fRun; i++)
    {
        PubItemListEntry *pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsaPubApps, i);
        TBOOL(NULL != pEntry);
        if (NULL != pEntry)
        {
            //
            // Unfortunately, InsertPublishedItem() doesn't return a value.
            //
            paf->InsertPublishedItem(pEntry->ppa, pEntry->bDuplicateName);
            iCount++;
        }
    }

    if (NULL != piCount)
    {
        *piCount = iCount;
    }
    return S_OK;
}

//
// Callback for destroying the DSA of application/duplicate-flag pairs.
// Need to release the IPublishedApp ptr for each entry.
//
int CALLBACK
DestroyPublishedAppArrayEntry(
    void *p, 
    void *pData
    )
{
    PubItemListEntry *pEntry = (PubItemListEntry *)p;
    ASSERT(NULL != pEntry && NULL != pEntry->ppa);
    ATOMICRELEASE(pEntry->ppa);
    return 1;
}



DWORD WINAPI PopulateAndRenderOCSetupItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateAndRenderOCSetupItemList' STARTED.\n");

    HDCONTEXT hctx = NULL;

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

   // Create an object that enums the OCSetup items
    COCSetupEnum * pocse = new COCSetupEnum;
    if (pocse)
    {
        if (pocse->EnumOCSetupItems())
        {
            COCSetupApp* pocsa;

            while (g_fRun && pocse->Next(&pocsa))
            {
                APPINFODATA ai = {0};
                ai.cbSize = sizeof(ai);
                ai.dwMask = AIM_DISPLAYNAME;

                if ( pocsa->GetAppInfo(&ai) && (lstrlen(ai.pszDisplayName) > 0) )
                {
                    //
                    // InsertOCSetupItem doesn't return a status value
                    // so we have no way of knowing if the item was
                    // added to ARP or not.  So... we have no way of knowing
                    // if we should delete it to prevent a leak.
                    // I've added code to ARPFrame::OnInvoke to delete
                    // the pocsa object if it cannot be added to ARP.
                    // [brianau - 2/27/01]
                    //
                    // Insert item
                    ((ARPFrame*)paf)->InsertOCSetupItem(pocsa);
                }
                else
                {
                    delete pocsa;
                    pocsa = NULL;
                }
            }
        }
        delete pocse;
        pocse = NULL;
    }

Cleanup:

    if (hctx)
        DeleteHandle(hctx);

    // Thread is done
    ARPFrame::htPopulateAndRenderOCSetupItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateAndRenderOCSetupItemList' DONE.\n");

    return 0;
}

DWORD WINAPI PopulateInstalledItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateInstalledItemList' STARTED.\n");

    HRESULT hr;
    IShellAppManager* pisam = NULL;
    IEnumInstalledApps* pieia = NULL;
    IInstalledApp* piia = NULL;
    DWORD dwAppCount = 0;
    APPINFODATA aid = {0};
    HDCONTEXT hctx = NULL;

    // Initialize
    CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Count installed apps, IShellAppManager::GetNumberofInstalledApps() not impl
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        dwAppCount++;
    }

    // IEnumInstalledApps::Reset() doesn't work
    pieia->Release();
    pieia = NULL;
    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Set app count in frame
    ((ARPFrame*)paf)->SetInstalledItemCount(dwAppCount);

    // Enumerate apps
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        // Insert item
        if (piia != NULL)
        {
            ((ARPFrame*)paf)->InsertInstalledItem(piia);
        }
    }

    // Passing NULL to InsertInstalledItem signals ARP that it is finished
    // inserting items and should now display the list.
    if (dwAppCount > 0)
    {
        ((ARPFrame*)paf)->InsertInstalledItem(NULL);
    }

Cleanup:

    if (pisam)
        pisam->Release();
    if (pieia)
        pieia->Release();

    if (hctx)
        DeleteHandle(hctx);

    CoUninitialize();

    if (g_fRun)
        ((ARPFrame*)paf)->FlushWorkingSet();

    // Thread is done
    ARPFrame::htPopulateInstalledItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateInstalledItemList' DONE.\n");

    return 0;
}

// Sorting
int __cdecl CompareElementDataName(const void* pA, const void* pB)
{
    Value* pvName1   = NULL;
    Value* pvName2   = NULL;
    LPCWSTR pszName1 = NULL;
    LPCWSTR pszName2 = NULL;
    Element *pe;
    if (NULL != pA)
    {
        pe = (*(ARPItem**)pA)->FindDescendent(ARPItem::_idTitle);
        if (NULL != pe)
        {
            pszName1 = pe->GetContentString(&pvName1);
        }
    }
    if (NULL != pB)
    {
        pe = (*(ARPItem**)pB)->FindDescendent(ARPItem::_idTitle);
        if (NULL != pe)
        {
            pszName2 = pe->GetContentString(&pvName2);
        }
    }

    static const int rgResults[2][2] = {
                            /*  pszName2 == NULL,    pszName2 != NULL  */
     /* pszName1 == NULL */  {        0,                      1   },
     /* pszName1 != NULL */  {       -1,                      2   }
        };

    int iResult = rgResults[int(NULL != pszName1)][int(NULL != pszName2)];
    if (2 == iResult)
    {
        iResult = StrCmpW(pszName1, pszName2);
    }
    
    if (NULL != pvName1)
    {
        pvName1->Release();
    }
    if (NULL != pvName2)
    {
       pvName2->Release();
    }
    return iResult;
}

int __cdecl CompareElementDataSize(const void* pA, const void* pB)
{
    ULONGLONG ull1 = (*(ARPItem**)pA)->_ullSize;
    ULONGLONG ull2 = (*(ARPItem**)pB)->_ullSize;
    if (!IsValidSize(ull1))
        ull1 = 0;
    if (!IsValidSize(ull2))
        ull2 = 0;

    // Big apps come before smaller apps
    if (ull1 > ull2)
        return -1;
    else if (ull1 < ull2)
        return 1;

    return   CompareElementDataName(pA, pB);
}

int __cdecl CompareElementDataFreq(const void* pA, const void* pB)
{
    // Rarely used apps come before frequently used apps.  Blank
    // (unknown) apps go last.  Unknown apps are -1, so those sort
    // to the bottom if we simply compare unsigned values.
    UINT u1 = (UINT)(*(ARPItem**)pA)->_iTimesUsed;
    UINT u2 = (UINT)(*(ARPItem**)pB)->_iTimesUsed;

   if (u1 < u2)
       return -1;
   else if (u1 > u2)
       return 1;
   return   CompareElementDataName(pA, pB);

}

int __cdecl CompareElementDataLast(const void* pA, const void* pB)
{
   FILETIME ft1 = (*(ARPItem**)pA)->_ftLastUsed;
   FILETIME ft2 = (*(ARPItem**)pB)->_ftLastUsed;

   BOOL bTime1 = IsValidFileTime(ft1);
   BOOL bTime2 = IsValidFileTime(ft2);

   if (!bTime1 || !bTime2)
   {
       if (bTime1)
           return -1;
       if (bTime2)
           return 1;
       // else they're both not set -- use name
   }
   else
   {
       LONG diff = CompareFileTime(&ft1, &ft2);
       if (diff)
           return diff;
   }

   return   CompareElementDataName(pA, pB);
}

//
// Stuff imported from other modules which have been deleted.
//



const TCHAR c_szStubWindowClass[] = TEXT("Add/Remove Stub Window");

HWND _CreateTransparentStubWindow(HWND hwndParent)
{
    WNDCLASS wc;
    RECT rc = {0};
    if (hwndParent)
    {
        RECT rcParent = {0};
        GetWindowRect(hwndParent, &rcParent);
        rc.left = (rcParent.left + RECTWIDTH(rcParent)) / 2;
        rc.top = (rcParent.top + RECTHEIGHT(rcParent)) / 2;
    }
    else
    {
        rc.left = CW_USEDEFAULT;
        rc.top = CW_USEDEFAULT;
    }
        
    if (!GetClassInfo(HINST_THISDLL, c_szStubWindowClass, &wc))
    {
        wc.style         = 0;
        wc.lpfnWndProc   = DefWindowProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = SIZEOF(DWORD) * 2;
        wc.hInstance     = HINST_THISDLL;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szStubWindowClass;

        RegisterClass(&wc);
    }

    // WS_EX_APPWINDOW makes this show up in ALT+TAB, but not the tray.
        
    return CreateWindowEx(WS_EX_TRANSPARENT, c_szStubWindowClass, TEXT(""), WS_POPUP | WS_VISIBLE, rc.left,
                          rc.top, 1, 1, hwndParent, NULL, HINST_THISDLL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\awthunk.h ===
#ifndef _AWTHUNK_H_
#define _AWTHUNK_H_

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

// Define the prototypes for each of these forwarders...

EXTERN_C BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);

#endif // _AWTHUNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\chgusr.c ===
//
//  Chgusr.C
//
//  Copyright (C) Citrix, 1996 All Rights Reserved.
//
//  History:
//  scottn 11/19/96 - First pass
//
//  scottn 12/5/96  - Add storage of chgusr option into registry.
//
//  scottn 12/13/96 - Create the UNINSTALL key if necessary (upon
//			first install of an uninstallable)
//
//  scottn 12/17/96 - Remove cwait (hangs on 16-bit installs).  Now
//			just exec and go to next page.  Add Finish page
//			which will turn option back and end tracking thread.
//
#include "priv.h"
#include "appwiz.h"
#include "regstr.h"
#include <uastrfnc.h>
#include <stdio.h>
#include <process.h>
#include <tsappcmp.h>       // for TermsrvAppInstallMode
#include "scripts.h"

static LPVOID g_pAppScripts = NULL;

//
//  Initialize the chgusr property sheet.  Check the "install" radio control.
//

void ChgusrFinishInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);
}

void ChgusrFinishPrevInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);
}

//
//  Sets the appropriate wizard buttons.
//
void SetChgusrFinishButtons(LPWIZDATA lpwd)
{
    // no BACK button so that they don't relaunch the app and
    // start a new thread, etc.

    int iBtns = PSWIZB_FINISH | PSWIZB_BACK;

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}

void SetChgusrFinishPrevButtons(LPWIZDATA lpwd)
{
    // no BACK button so that they don't relaunch the app and
    // start a new thread, etc.

    int iBtns = PSWIZB_NEXT;

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}

//
//  NOTES: 1) This function assumes that lpwd->hwnd has already been set to
//           the dialogs hwnd.
//

void ChgusrFinishSetActive(LPWIZDATA lpwd)
{
    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, IDS_CHGUSRFINISH, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetChgusrFinishButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}

void ChgusrFinishPrevSetActive(LPWIZDATA lpwd)
{
    g_pAppScripts = ScriptManagerInitScripts();

    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, IDS_CHGUSRFINISH_PREV, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetChgusrFinishPrevButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}

//
//  Main dialog procedure for fourth page of setup wizard.
//
BOOL_PTR CALLBACK ChgusrFinishPrevDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    if (lpwd)
                    {
                        lpwd->hwnd = hDlg;
                        ChgusrFinishPrevSetActive(lpwd);
                    }
                    break;

                case PSN_WIZNEXT:
                    break;

                case PSN_RESET:
                    if (lpwd)
                    {
                        SetTermsrvAppInstallMode(lpwd->bPrevMode);
                        CleanUpWizData(lpwd);
                    }
                    if(g_pAppScripts)
                    {
                        ScriptManagerRunScripts(&g_pAppScripts);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            ChgusrFinishPrevInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
        {
            break;
        }

        case WM_ENDSESSION:
            KdPrint(("ChgusrFinishPrevDlgProc - WM_ENDSESSION message received!\n"));
            if(g_pAppScripts)
            {
                ScriptManagerRunScripts(&g_pAppScripts);
            }
            return FALSE;

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // ChgusrFinishDlgProc

//
//  Main dialog procedure for last page of setup wizard.
//
BOOL_PTR CALLBACK ChgusrFinishDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    if (lpwd)
                    {
                        lpwd->hwnd = hDlg;
                        ChgusrFinishSetActive(lpwd);
                    }
                    break;

                case PSN_WIZFINISH:
                case PSN_RESET:
                    if (lpwd)
                    {
                        SetTermsrvAppInstallMode(lpwd->bPrevMode);

                        if (lpnm->code == PSN_RESET)
                            CleanUpWizData(lpwd);
                    }
                    if(g_pAppScripts)
                    {
                        ScriptManagerRunScripts(&g_pAppScripts);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            ChgusrFinishInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
        {
            break;
        }


        case WM_ENDSESSION:
            KdPrint(("ChgusrFinishDlgProc - WM_ENDSESSION message received!\n"));
            if(g_pAppScripts)
            {
                ScriptManagerRunScripts(&g_pAppScripts);
            }
            return FALSE;

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // ChgusrFinishDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\awthunk.c ===
#include "priv.h"


//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

#define PFN_FIRSTTIME   ((void *)-1)

// First undefine everything that we are intercepting as to not forward back to us...
#undef SHGetSpecialFolderPath



// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

typedef BOOL (WINAPI * PFNGETSPECIALFOLDERPATH)(HWND hwndOwner, LPTSTR pwszPath, int nFolder, BOOL fCreate); 

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, /*OUT*/ LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    // The classic shell exported a non-decorated SHGetSpecialFolderPath
    // that took TCHAR parameters.  The IE4 shell exported additional
    // decorated versions.  Try to use the explicit decorated versions if
    // we can.
    
    static PFNGETSPECIALFOLDERPATH s_pfn = PFN_FIRSTTIME;

    *pszPath = 0;
    
    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("SHELL32.DLL");
        if (hinst)
        {
            s_pfn = (PFNGETSPECIALFOLDERPATH)GetProcAddress(hinst, "SHGetSpecialFolderPathW");
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
    {
        return s_pfn(hwndOwner, pszPath, nFolder, fCreate);
    }
    else
    {
        return SHGetSpecialFolderPath(hwndOwner, pszPath, nFolder, fCreate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darapp.h ===
#ifndef __DARAPP_H_
#define __DARAPP_H_


/////////////////////////////////////////////////////////////////////////////
// CDarwinPublishedApp
class CDarwinPublishedApp : public IPublishedApp
{
public:
    // Constructor for Darwin Apps
    CDarwinPublishedApp(MANAGEDAPPLICATION * ppdi);
    ~CDarwinPublishedApp();

    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellApp
    STDMETHODIMP GetAppInfo(PAPPINFODATA pai);
    STDMETHODIMP GetPossibleActions(DWORD * pdwActions);
    STDMETHODIMP GetSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP GetCachedSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP IsInstalled(void);
    
    // *** IPublishedApp
    STDMETHODIMP Install(LPSYSTEMTIME pftInstall);
    STDMETHODIMP GetPublishedAppInfo(PPUBAPPINFO ppai);
    STDMETHODIMP Unschedule(void);
    
protected:

    LONG _cRef;
    DWORD _dwAction;

    // Specific info on this Darwin App
    MANAGEDAPPLICATION _ma;
};

#endif //__DARAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\browse.c ===
//
//  Browse.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include "util.h"
#include <uastrfnc.h>

#include <tsappcmp.h>       // for TermsrvAppInstallMode

// Copied from shelldll\ole2dup.h
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

//
//  Initialize the browse property sheet.  Limit the size of the edit control.
//

void BrowseInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);

    Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lpwd->szExeName)-1);

    if (FAILED(SHAutoComplete(GetDlgItem(hDlg, IDC_COMMAND), 0)))
    {
        TraceMsg(TF_WARNING, "%s", "WARNING: Create Shortcut wizard won't AutoComplete because: 1) bad registry, 2) bad OleInit, or 3) Out of memory.");
    }
}

//
//  Sets the appropriate wizard buttons.  If there's any text in the
//  edit control then Next is enabled.  Otherwise, Next and Back are both
//  grey.
//
void SetBrowseButtons(LPWIZDATA lpwd)
{
    BOOL fIsText = GetWindowTextLength(GetDlgItem(lpwd->hwnd, IDC_COMMAND)) > 0;
    BOOL fIsSetup = (lpwd->dwFlags & WDFLAG_SETUPWIZ);
    int iBtns = fIsSetup ? PSWIZB_BACK : 0;

    if (fIsSetup)
    {
        // Are we running Terminal Service? Is this user an Admin?
        if (IsTerminalServicesRunning() && IsUserAnAdmin())
        {
            lpwd->bTermSrvAndAdmin = TRUE;
            iBtns |= fIsText ? PSWIZB_NEXT : PSWIZB_DISABLEDFINISH;
        }
        else
            iBtns |= fIsText ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH;
    }
    else
    {
        if (fIsText)
        {
            iBtns |= PSWIZB_NEXT;
        }
    }
    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}


//
//  NOTES: 1) This function assumes that lpwd->hwnd has already been set to
//           the dialogs hwnd.  2) This function is called from NextPushed
//           if the application specified can not be found.
//
//  BrowseSetActive enables the next button and sets the focus to the edit
//  control by posting a POKEFOCUS message.
//

void BrowseSetActive(LPWIZDATA lpwd)
{
    //
    // NOTE: We re-use the szProgDesc string since it will always be reset
    //       when this page is activated.  Use it to construct a command line.
    //

    #define   szCmdLine lpwd->szProgDesc

    StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), lpwd->szExeName);

    PathQuoteSpaces(szCmdLine);

    if (lpwd->szParams[0] != 0)
    {
        StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), TEXT(" "));
        StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), lpwd->szParams);
    }

    Edit_SetText(GetDlgItem(lpwd->hwnd, IDC_COMMAND), szCmdLine);

    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        int   iHaveHeader = IsTerminalServicesRunning() ? IDS_TSHAVESETUPPRG : IDS_HAVESETUPPRG;
        int   iHeader = szCmdLine[0] != 0 ? iHaveHeader : IDS_NOSETUPPRG;
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, iHeader, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetBrowseButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);

    szCmdLine[0] = 0;            // Reset progdesc to empty string
    #undef szCmdLine
}


//
//  Returns TRUE if able to get properties for szExeName from PifMgr.  The
//  program properties will be read into lpwd->PropPrg.
//

BOOL ReadPifProps(LPWIZDATA lpwd)
{
    HANDLE hPifProp;
    LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

    hPifProp = PifMgr_OpenProperties(lpszName, NULL, 0, OPENPROPS_INHIBITPIF);
    if (!hPifProp)
    {
        TraceMsg(TF_ERROR, "%s", "Unable to open properties for DOS exe.");
    }

    if (hPifProp == 0)
        return(FALSE);

    PifMgr_GetProperties(hPifProp, (LPSTR)GROUP_PRG, &(lpwd->PropPrg),
                         sizeof(lpwd->PropPrg), GETPROPS_NONE);

    PifMgr_CloseProperties(hPifProp, CLOSEPROPS_DISCARD);

    return(TRUE);
}


//
//  Returns TRUE if lpwd->szExeName points to a valid exe type.  It also sets
//  the appropriate flags, such as APPKNOWN and DOSAPP in the wizdata structure
//  if the exe is valid.
//

void DetermineExeType(LPWIZDATA lpwd)
{

    DWORD   dwExeType;
    LPTSTR  lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

    lpwd->dwFlags &= ~(WDFLAG_APPKNOWN | WDFLAG_DOSAPP);

    dwExeType = (DWORD)SHGetFileInfo(lpszName, 0, NULL, 0, SHGFI_EXETYPE);

    if (LOWORD(dwExeType) != ('M' | ('Z' << 8)))
    {
        lpwd->dwFlags |= WDFLAG_APPKNOWN;

        if (lstrcmpi(PathFindExtension(lpszName), c_szPIF) == 0)
        {
            lpwd->dwFlags |= WDFLAG_DOSAPP;
        }
    }
    else
    {
        lpwd->dwFlags |= WDFLAG_DOSAPP;

        if (ReadPifProps(lpwd))
        {
            if ((lpwd->PropPrg.flPrgInit & PRGINIT_INFSETTINGS) ||
                ((lpwd->PropPrg.flPrgInit &
                     (PRGINIT_NOPIF | PRGINIT_DEFAULTPIF)) == 0))
            {
                lpwd->dwFlags |= WDFLAG_APPKNOWN;
            }
        }
    }
}


//
//  Removes the filename extension (if any) from the string.
//

void StripExt(LPTSTR lpsz)
{
    if(lpsz)
    {
        LPTSTR pExt = PathFindExtension(lpsz);

        if (*pExt)
            *pExt = 0;    // null out the "."
    }
}



//
//  Sets the working directory as appropriate for the file type.
//

void FindWorkingDir(LPWIZDATA lpwd)
{
    LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;
    TCHAR szWindir[ MAX_PATH ];
    DWORD dwLen;

    if (PathIsUNC(lpszName) || PathIsDirectory(lpszName))
    {
        lpwd->szWorkingDir[0] = 0;
    }
    else
    {
        StringCchCopy(lpwd->szWorkingDir, ARRAYSIZE(lpwd->szWorkingDir), lpszName);
        PathRemoveFileSpec(lpwd->szWorkingDir);
    }

    //
    // Okay, at this point we should have the absolute path for the
    // working directory of the link.  On NT, if the working dir happens to be for
    // something in the %Windir% directory (or a subdir of %windir%),
    // then store the path as %windir%\blah\blah\blah instead of as an
    // absolute path.  This will help with interoperability of shortcuts
    // across different machines, etc.  But only do this for shortcuts that
    // are already marked as having expandable env strings...
    //

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
    {
        dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                          szWindir,
                                          ARRAYSIZE(szWindir)
                                         );
        if (dwLen &&
            dwLen < ARRAYSIZE(szWindir) &&
            lstrlen(szWindir) <= lstrlen(lpwd->szWorkingDir)
           )
        {
            //
            // we use dwLen-1 because dwLen includes the '\0' character
            //
            if (CompareString( LOCALE_SYSTEM_DEFAULT,
                               NORM_IGNORECASE,
                               szWindir, dwLen-1 ,
                               lpwd->szWorkingDir, dwLen-1
                              ) == 2)
            {
                TCHAR szWorkingDir[ MAX_PATH ];
                //
                // We should substitute the env variable for the
                // actual string here...
                //
                StringCchCopy(szWorkingDir, ARRAYSIZE(szWorkingDir), lpwd->szWorkingDir);
                StringCchCopy(lpwd->szWorkingDir, ARRAYSIZE(lpwd->szWorkingDir), TEXT("%windir%"));

                // 8 == lstrlen("%windir%")
                StringCchCopy( lpwd->szWorkingDir + 12, ARRAYSIZE(lpwd->szWorkingDir)-12, szWorkingDir+dwLen-1 );

            }
        }
    }
}


#ifndef NO_NEW_SHORTCUT_HOOK

//
// Returns:
//    Hook result or error.
//
// S_OK:
//    *pnshhk is the INewShortcutHook of the object to use to save the new Shortcut.
//    szProgDesc[] and szExt[] are filled in.
//    szExeName[] may be translated.
// otherwise:
//    *pnshhk is NULL.
//    szProgDesc[] and szExt[] are empty strings.
//

HRESULT QueryNewLinkHandler(LPWIZDATA lpwd, LPCLSID pclsidHook)
{
   HRESULT   hr;
   IUnknown *punk;
   LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

   lpwd->pnshhk = NULL;
   lpwd->pnshhkA = NULL;

   *(lpwd->szProgDesc) = TEXT('\0');
   *(lpwd->szExt) = TEXT('\0');

   hr = CoCreateInstance(pclsidHook, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, &punk);

   if (hr == S_OK)
   {
      INewShortcutHook *pnshhk;

      hr = punk->lpVtbl->QueryInterface(punk, &IID_INewShortcutHook, &pnshhk);

      if (hr == S_OK)
      {
         hr = pnshhk->lpVtbl->SetReferent(pnshhk, lpszName, lpwd->hwnd);

         if (hr == S_OK)
         {
            hr = pnshhk->lpVtbl->SetFolder(pnshhk, lpwd->lpszFolder);

            if (hr == S_OK)
            {
               hr = pnshhk->lpVtbl->GetName(pnshhk, lpwd->szProgDesc,
                                            ARRAYSIZE(lpwd->szProgDesc));

               if (hr == S_OK)
               {
                  hr = pnshhk->lpVtbl->GetExtension(pnshhk, lpwd->szExt,
                                                    ARRAYSIZE(lpwd->szExt));

                  if (hr == S_OK)
                     hr = pnshhk->lpVtbl->GetReferent(pnshhk, lpszName,
                                                      ARRAYSIZE(lpwd->szExeName));
               }
            }
         }

         if (hr == S_OK)
            lpwd->pnshhk = pnshhk;
         else
            pnshhk->lpVtbl->Release(pnshhk);
      }
      else
      {
          INewShortcutHookA *pnshhkA;
          hr = punk->lpVtbl->QueryInterface(punk, &IID_INewShortcutHookA, &pnshhkA);

          if (hr == S_OK)
          {
             UINT   cFolderA = WideCharToMultiByte(CP_ACP,0,lpwd->lpszFolder,-1,NULL,0,0,0)+1;
             LPSTR  lpszFolderA = (LPSTR)LocalAlloc(LPTR,cFolderA*SIZEOF(CHAR));

             if (NULL == lpszFolderA)
             {
                 hr = E_OUTOFMEMORY;
             }
             else
             {
                 CHAR   szNameA[MAX_PATH];
                 CHAR   szProgDescA[MAX_PATH];
                 CHAR   szExtA[MAX_PATH];

                 WideCharToMultiByte(CP_ACP, 0,
                                     lpszName, -1,
                                     szNameA, ARRAYSIZE(szNameA),
                                     0, 0);

                 WideCharToMultiByte(CP_ACP, 0,
                                     lpwd->lpszFolder, -1,
                                     lpszFolderA, cFolderA,
                                     0, 0);

                 hr = pnshhkA->lpVtbl->SetReferent(pnshhkA, szNameA, lpwd->hwnd);

                 if (hr == S_OK)
                 {
                    hr = pnshhkA->lpVtbl->SetFolder(pnshhkA, lpszFolderA);

                    if (hr == S_OK)
                    {
                       hr = pnshhkA->lpVtbl->GetName(pnshhkA, szProgDescA,
                                                    ARRAYSIZE(szProgDescA));

                       if (hr == S_OK)
                       {
                          MultiByteToWideChar(CP_ACP, 0,
                                              szProgDescA, -1,
                                              lpwd->szProgDesc, ARRAYSIZE(lpwd->szProgDesc));

                          hr = pnshhkA->lpVtbl->GetExtension(pnshhkA, szExtA,
                                                            ARRAYSIZE(szExtA));

                          if (hr == S_OK)
                          {
                             MultiByteToWideChar(CP_ACP, 0,
                                                 szExtA, -1,
                                                 lpwd->szExt, ARRAYSIZE(lpwd->szExt));

                             hr = pnshhkA->lpVtbl->GetReferent(pnshhkA, szNameA,
                                                              ARRAYSIZE(szNameA));

                             MultiByteToWideChar(CP_ACP, 0,
                                                 szExtA, -1,
                                                 lpszName, ARRAYSIZE(lpwd->szExeName));
                          }
                       }
                    }
                 }

                 if (hr == S_OK)
                    lpwd->pnshhkA = pnshhkA;
                 else
                    pnshhkA->lpVtbl->Release(pnshhkA);

                 LocalFree(lpszFolderA);
             }
          }
      }
      punk->lpVtbl->Release(punk);
   }

   return(hr);
}


const TCHAR c_szNewLinkHandlers[] = REGSTR_PATH_EXPLORER TEXT("\\NewShortcutHandlers");


//
// Sets lpwd->pnshhk to NULL for CLSID_ShellLink (default) or to the
// INewShortcutHook of the object to be used.
//
// If lpwd->pnshhk is returned non-NULL, szProgDesc[] and szExt[] are also
// filled in.
//

void DetermineLinkHandler(LPWIZDATA lpwd)
{
   HKEY hkeyHooks;

   // Lose any previously saved external new Shortcut handler.

   if (lpwd->pnshhk)
   {
      lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
      lpwd->pnshhk = NULL;
   }
   if (lpwd->pnshhkA)
   {
      lpwd->pnshhkA->lpVtbl->Release(lpwd->pnshhkA);
      lpwd->pnshhkA = NULL;
   }

   //
   // Enumerate the list of new link handlers.  Each new link handler is
   // registered as a GUID value under c_szNewLinkHandlers.
   //

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNewLinkHandlers, 0, KEY_READ, &hkeyHooks)
       == ERROR_SUCCESS)
   {
      DWORD dwiValue;
      TCHAR szCLSID[GUIDSTR_MAX];
      DWORD dwcbCLSIDLen;

      //
      // Invoke each hook.  A hook returns S_FALSE if it does not wish to
      // handle the new link.  Stop if a hook returns S_OK.
      //

      for (dwcbCLSIDLen = ARRAYSIZE(szCLSID), dwiValue = 0;
           RegEnumValue(hkeyHooks, dwiValue, szCLSID, &dwcbCLSIDLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS;
           dwcbCLSIDLen = ARRAYSIZE(szCLSID), dwiValue++)
      {
         CLSID clsidHook;

         if (SHCLSIDFromString(szCLSID, &clsidHook) == S_OK &&
             QueryNewLinkHandler(lpwd, &clsidHook) == S_OK)
            break;
      }

      RegCloseKey(hkeyHooks);
   }

   return;
}

#endif


//
//  Returns TRUE if it's OK to go to the next wizard dialog.
//

BOOL NextPushed(LPWIZDATA lpwd)
{
    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // Is the string a path with spaces, without arguments, but isn't correctly
    // quoted?  NT #d: >C:\Program Files\Windows NT\dialer.exe< is treated like
    // "C:\Program" with "Files\Windows NT\dialer.exe" as args.
    if (PathFileExists(lpwd->szExeName))
    {
        // Yes, so let's quote it so we don't treat the stuff after
        // the space like args.
        PathQuoteSpaces(lpwd->szExeName);
    }
    
    PathRemoveBlanks(lpwd->szExeName);

    if (lpwd->szExeName[0] != 0)
    {
        BOOL    bUNC;
        LPTSTR  lpszTarget = NULL;
        HCURSOR hcurOld  = SetCursor(LoadCursor(NULL, IDC_WAIT));
        LPTSTR  lpszArgs = PathGetArgs(lpwd->szExeName);

        StringCchCopy(lpwd->szParams, ARRAYSIZE(lpwd->szParams), lpszArgs);

        if (*lpszArgs)
        {
            *(lpszArgs - 1) = 0;   // clobber the ' ' in the exe name field
        }

        ExpandEnvironmentStrings( lpwd->szExeName,
                                  lpwd->szExpExeName,
                                  ARRAYSIZE(lpwd->szExpExeName)
                                 );
        lpwd->szExpExeName[ MAX_PATH-1 ] = TEXT('\0');
        if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
            lpwd->dwFlags |= WDFLAG_EXPSZ;


        lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;


        PathUnquoteSpaces(lpszTarget);
        if (lpwd->dwFlags & WDFLAG_EXPSZ)
            PathUnquoteSpaces(lpwd->szExeName);

        lpwd->dwFlags &= ~WDFLAG_COPYLINK;

#ifndef NO_NEW_SHORTCUT_HOOK

        //
        // Figure out who wants to handle this string as a link referent.
        //

        DetermineLinkHandler(lpwd);

        if (lpwd->pnshhk)
        {
            //
            // We are using an external link handler.  Skip file system
            // validation.
            //

            lpwd->dwFlags |= WDFLAG_APPKNOWN;
            SetCursor(hcurOld);
            return(TRUE);
        }
        if (lpwd->pnshhkA)
        {
            //
            // We are using an external link handler.  Skip file system
            // validation.
            //

            lpwd->dwFlags |= WDFLAG_APPKNOWN;
            SetCursor(hcurOld);
            return(TRUE);
        }

#endif

        bUNC = PathIsUNC(lpszTarget);

        if (bUNC && !SHValidateUNC(lpwd->hwnd, lpszTarget, FALSE))
            goto Done;

        //
        //  If the user tries to make a link to A:\ and there's no disk
        //  in the drive, PathResolve would fail.  So, for drive roots, we
        //  don't try to resolve it.
        //

        if ((PathIsRoot(lpszTarget) && !bUNC &&
             DriveType(DRIVEID(lpszTarget))) ||
             PathResolve(lpszTarget, NULL,
                         PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
        {
            //
            // If we found a PIF file then we'll try to convert it to the
            // name of the file it points to.
            //

            if (lstrcmpi(PathFindExtension(lpszTarget), c_szPIF) == 0)
            {
                if (!ReadPifProps(lpwd))
                {
                    goto Done;
                }

                MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achCmdLine, -1,
                                    lpszTarget, ARRAYSIZE(lpwd->szExeName));

                PathRemoveArgs(lpszTarget);

                if (!PathResolve(lpszTarget, NULL,
                                 PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
                {
                    goto Done;
                }
            }

            //
            // Okay, at this point we should have the absolute path for the
            // target of the link.  On NT, if the target happens to be for
            // something in the %Windir% directory (or a subdir of %Windir%),
            // AND the user didn't type in an expandable path already, then
            // store the path as %windir%\blah\blah\blah instead of as an
            // absolute path.  This will help with interoperability of shortcuts
            // across different machines, etc.
            //

            if (!(lpwd->dwFlags & WDFLAG_EXPSZ))
            {
                TCHAR szWindir[ MAX_PATH ];
                DWORD dwLen;

                //
                // What did the user type in?
                //
                GetDlgItemText(lpwd->hwnd, IDC_COMMAND, szWindir, ARRAYSIZE(szWindir));
                if (ualstrcmpi(szWindir, lpwd->szExeName)==0)
                {
                    //
                    // If we didn't change it, it means the user typed in an
                    // exact path.  In that case, don't try to map anyting.
                    //
                    goto LinkToALinkCase;
                }
                dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                                  szWindir,
                                                  ARRAYSIZE(szWindir)
                                                 );
                if (dwLen &&
                    dwLen < ARRAYSIZE(szWindir) &&
                    lstrlen(szWindir) <= lstrlen(lpszTarget)
                   )
                {
                    //
                    // we use dwLen-1 because dwLen includes the '\0' character
                    //
                    if (CompareString( LOCALE_SYSTEM_DEFAULT,
                                       NORM_IGNORECASE,
                                       szWindir, dwLen-1 ,
                                       lpszTarget, dwLen-1
                                      ) == 2)
                    {
                        //
                        // We should substitute the env variable for the
                        // actual string here...
                        //
                        StringCchCopy(lpwd->szExpExeName, ARRAYSIZE(lpwd->szExpExeName), lpwd->szExeName);
                        StringCchCopy(lpwd->szExeName, ARRAYSIZE(lpwd->szExeName), TEXT("%windir%"));

                        // 8 == lstrlen("%windir%")
                        StringCchCopy( lpwd->szExeName + 8, ARRAYSIZE(lpwd->szExeName)-8, lpwd->szExpExeName+dwLen-1 );
                        lpwd->dwFlags |= WDFLAG_EXPSZ;
                        lpszTarget = lpwd->szExpExeName;

                    }
                }
            }

            //
            // Okay, at this point we should have the absolute path for the
            // target of the link.  On NT, if the target happens to be for
            // something in the %Windir% directory (or a subdir of %Windir%),
            // AND the user didn't type in an expandable path already, then
            // store the path as %windir%\blah\blah\blah instead of as an
            // absolute path.  This will help with interoperability of shortcuts
            // across different machines, etc.
            //

            if (!(lpwd->dwFlags & WDFLAG_EXPSZ))
            {
                TCHAR szWindir[ MAX_PATH ];
                DWORD dwLen;

                //
                // What did the user type in?
                //
                GetDlgItemText(lpwd->hwnd, IDC_COMMAND, szWindir, ARRAYSIZE(szWindir));
                if (ualstrcmpi(szWindir, lpwd->szExeName)==0)
                {
                    //
                    // If we didn't change it, it means the user typed in an
                    // exact path.  In that case, don't try to map anyting.
                    //
                    goto LinkToALinkCase;
                }
                dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                                  szWindir,
                                                  ARRAYSIZE(szWindir)
                                                 );
                if (dwLen &&
                    dwLen < ARRAYSIZE(szWindir) &&
                    lstrlen(szWindir) <= lstrlen(lpszTarget)
                   )
                {
                    //
                    // we use dwLen-1 because dwLen includes the '\0' character
                    //
                    if (CompareString( LOCALE_SYSTEM_DEFAULT,
                                       NORM_IGNORECASE,
                                       szWindir, dwLen-1 ,
                                       lpszTarget, dwLen-1
                                      ) == 2)
                    {
                        //
                        // We should substitute the env variable for the
                        // actual string here...
                        //
                        StringCchCopy(lpwd->szExpExeName, ARRAYSIZE(lpwd->szExpExeName), lpwd->szExeName);
                        StringCchCopy(lpwd->szExeName, ARRAYSIZE(lpwd->szExeName), TEXT("%windir%"));

                        // 8 == lstrlen("%windir%")
                        StringCchCopy( lpwd->szExeName + 8, ARRAYSIZE(lpwd->szExeName)-8, lpwd->szExpExeName+dwLen-1 );
                        lpwd->dwFlags |= WDFLAG_EXPSZ;
                        lpszTarget = lpwd->szExpExeName;

                    }
                }
            }
LinkToALinkCase:


            //
            //  Really, really obscure case. The user creates "New Shortcut" and
            //  tries to point it to itself. Don't allow it.  We'd be confused
            //  later. Since it's so obscure, just give a generic error about
            //  "Can't find this file"
            //

            if (!(lpwd->lpszOriginalName &&
                  lstrcmpi(lpwd->lpszOriginalName, lpszTarget) == 0))
            {
                DetermineExeType(lpwd);
                FindWorkingDir(lpwd);

                lpwd->szProgDesc[0] = 0;  // Reset description
                                          // EVEN IF WE DON'T RECREATE IT HERE!

                if (lpwd->lpszFolder && lpwd->lpszFolder[0] != 0 &&
                    !DetermineDefaultTitle(lpwd))
                {
                    goto Done;
                }

                if (lpwd->dwFlags & WDFLAG_EXPSZ)
                {
                    LPTSTR lpszExt = PathFindExtension( lpwd->szExeName );

                    if (!(*lpszExt))
                    {
                        // do simple check to make sure there was a file name
                        // at the end of the original entry.  we assume that
                        // if we got this far, lpszExt points to the end of
                        // the string pointed to by lpwd->szExeName, and that
                        // lpwd->szExeName has at least one character in it.
                        if (lpwd->szExeName &&
                            (*lpwd->szExeName) &&
                            (*(lpszExt-1)!=TEXT('%'))
                            )
                        {
                            lstrcpy( lpszExt, PathFindExtension( lpszTarget ) );
                        }
                    }
                }

                SetCursor(hcurOld);
                return(TRUE);
            }

        }
Done:

        SetCursor(hcurOld);
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, lpwd->szExeName);
    }

    BrowseSetActive(lpwd);
    return(FALSE);
}


//
//  Returns TRUE if it's OK to run the setup program.
//

BOOL SetupCleanupExePath(LPWIZDATA lpwd)
{
    BOOL fValidPrg = FALSE;

    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // Is the string a path with spaces, without arguments, but isn't correctly
    // quoted?  NT #d: >C:\Program Files\Windows NT\dialer.exe< is treated like
    // "C:\Program" with "Files\Windows NT\dialer.exe" as args.
    if (PathFileExists(lpwd->szExeName))
    {
        // Yes, so let's quote it so we don't treat the stuff after
        // the space like args.
        PathQuoteSpaces(lpwd->szExeName);
    }

    PathRemoveBlanks(lpwd->szExeName);

    if (lpwd->szExeName[0] != 0)
    {
        LPTSTR lpszTarget = NULL;
        LPTSTR lpszArgs = NULL;
        HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));


        ExpandEnvironmentStrings( lpwd->szExeName,
                                  lpwd->szExpExeName,
                                  ARRAYSIZE(lpwd->szExpExeName)
                                 );
        if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
            lpwd->dwFlags |= WDFLAG_EXPSZ;

        lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

        lpszArgs = PathGetArgs(lpszTarget);
        StringCchCopy(lpwd->szParams, ARRAYSIZE(lpwd->szParams), lpszArgs);
        if (*lpszArgs)
        {
            *(lpszArgs - 1) = 0;   // clobber the ' ' in the exe name field
        }
   
        PathUnquoteSpaces(lpszTarget);
        if (lpwd->dwFlags & WDFLAG_EXPSZ)
            PathUnquoteSpaces(lpwd->szExeName);

        if (PathResolve(lpszTarget, NULL,
                        PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
        {
            LPTSTR lpszExt = PathFindExtension( lpszTarget );
            fValidPrg = TRUE;
            FindWorkingDir(lpwd);
            if (lpwd->dwFlags & WDFLAG_EXPSZ)
            {
                if (!(*lpszExt))
                {
                    lstrcpy( lpszExt, PathFindExtension( lpszTarget ) );
                }
            }
            
            if ((*lpszExt) && lpwd->bTermSrvAndAdmin && (!lstrcmpi(lpszExt, TEXT(".msi"))))
            {
                StringCchCat(lpwd->szParams, ARRAYSIZE(lpwd->szParams), TEXT(" ALLUSERS=1"));   
            }

            PathQuoteSpaces( lpszTarget );
        }
        SetCursor(hcurOld);
    }


    if (!fValidPrg)
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, lpwd->szExeName);
        BrowseSetActive(lpwd);
    }
    return(fValidPrg);
}


BOOL DetermineDefaultTitle(LPWIZDATA lpwd)
{
    TCHAR   szFullName[MAX_PATH];
    BOOL    fCopy;
    LPTSTR  lpszName;

    lpwd->dwFlags &= ~WDFLAG_COPYLINK;

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
        lpszName = lpwd->szExpExeName;
    else
        lpszName = lpwd->szExeName;

    if (!SHGetNewLinkInfo(lpszName, lpwd->lpszFolder, szFullName,
                     &fCopy, 0))
    {
        //
        // failure...
        //

        return(FALSE);
    }

    lpszName = PathFindFileName(szFullName);

    StripExt(lpszName);

    lstrcpyn(lpwd->szProgDesc, lpszName, ARRAYSIZE(lpwd->szProgDesc));

    //
    // We will never copy PIF files since they often do not contain
    // the appropriate current directory.  This is becuase they are
    // automatically created when you run a DOS application from the
    // shell.
    //

    if ((lpwd->dwFlags & WDFLAG_DOSAPP) == 0)
    {
        if (fCopy)
        {
            lpwd->dwFlags |= WDFLAG_COPYLINK;
        }
#ifndef NO_NEW_SHORTCUT_HOOK
        StringCchCopy(lpwd->szExt, ARRAYSIZE(lpwd->szExt), c_szLNK);
    }
    else
    {
        StringCchCopy(lpwd->szExt, ARRAYSIZE(lpwd->szExt), c_szPIF);
#endif
    }

    return(TRUE);
}

//
// paranoia: evaluate each time in case it is installed after ARP was first open, but
//           before it is closed and re-opened
//
BOOL MSI_IsMSIAvailable()
{
    BOOL bAvailable = FALSE;

    HINSTANCE hinst = LoadLibraryA("MSI.DLL");
    
    if (hinst)
    {
        bAvailable = TRUE;

        FreeLibrary(hinst);
    }

    return bAvailable;
}

//
//  Call the common dialog code for File Open
//
BOOL BrowseForExe(HWND hwnd, LPTSTR pszName, DWORD cchName, LPCTSTR pszInitDir)
{
    TCHAR szExt[80];
    TCHAR szFilter[200];
    TCHAR szTitle[80];
    TCHAR szBootDir[64];

    // we want to pass in an initial directory since GetFileNameFromBrowse
    // try to determine an initial directory by doing a PathRemoveFileSpec
    // on pszName.  If pszName is already a directory then the last directory
    // is removed (even though it's not a file).  E.g.: "c:\winnt" -> "c:\"
    lstrcpyn(szBootDir, pszInitDir, ARRAYSIZE(szBootDir));

    if (MSI_IsMSIAvailable())
        LoadAndStrip(IDS_BROWSEFILTERMSI, szFilter, ARRAYSIZE(szFilter));
    else
        LoadAndStrip(IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter));

    LoadString(g_hinst, IDS_BROWSEEXT,    szExt,    ARRAYSIZE(szExt));
    LoadString(g_hinst, IDS_BROWSETITLE,  szTitle,  ARRAYSIZE(szTitle));

    // we need to set pszName to NULL or else GetFileNameFromBrowse will use it
    // to find the initial directory even though we explicitly pass in an initial
    // dir.
    *pszName = 0;

    return(GetFileNameFromBrowse(hwnd, pszName, cchName,
                                 szBootDir, szExt, szFilter, szTitle));
}

//
//  Use the common open dialog to browse for program. Used by SetupBrowseDlgProc
//

void BrowsePushed(LPWIZDATA lpwd)
{
    LPTSTR lpszName;
    DWORD cchName = 0;

    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));
    ExpandEnvironmentStrings( lpwd->szExeName, lpwd->szExpExeName, ARRAYSIZE(lpwd->szExpExeName) );
    if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
        lpwd->dwFlags |= WDFLAG_EXPSZ;

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
    {
        lpszName = lpwd->szExpExeName;
        cchName = ARRAYSIZE(lpwd->szExpExeName);
    }
    else
    {
        lpszName = lpwd->szExeName;
        cchName = ARRAYSIZE(lpwd->szExeName);
    }

    if (BrowseForExe(lpwd->hwnd, lpszName, cchName, lpszName))
    {
        lpwd->szParams[0] = 0;
        BrowseSetActive(lpwd);
    }
}


void EnableOKButton(HWND hwndDlg, LPITEMIDLIST pidl)
{
    DWORD dwFlags = SFGAO_FILESYSTEM;
    WCHAR szName[MAX_PATH] = L"";
    HRESULT hr = E_FAIL;
            
    if (pidl)
    {
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName), &dwFlags)))
        {
            if ((dwFlags & SFGAO_FILESYSTEM) != 0 ||
                !lstrncmp(szName, L"\\\\", 2))
            {
                hr = S_OK;
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Path is either a valid local path
        // or a valid network path, enable the ok button
        SendMessage(hwndDlg, BFFM_ENABLEOK, (WPARAM)0, (LPARAM)1);
    }
    else
    {
        // Path does not exist, disable the ok button
        // This could be My Computer or an empty floppy drive etc...
        SendMessage(hwndDlg, BFFM_ENABLEOK, (WPARAM)0, (LPARAM)0);
    }
}

int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData
    )
{
    LPITEMIDLIST pidlNavigate;

    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        // Check if we should navigate to a folder on initialize
        pidlNavigate = (LPITEMIDLIST) lpData;
        if (pidlNavigate != NULL)
        {
            // Yes! We have a folder to navigate to; send the message
            SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) FALSE, (LPARAM) pidlNavigate);
        }
        
        EnableOKButton(hwnd, pidlNavigate);
        
        break;

    case BFFM_SELCHANGED:
        // Check if we should enable/disable the Ok button
        pidlNavigate = (LPITEMIDLIST)lParam;
        if (pidlNavigate != NULL)
        {
            EnableOKButton(hwnd, pidlNavigate);
        }
    }
     
    return 0;
}

// This implementation of 'Browse' uses SHBrowseForFolder to find a file or folder
// for the shortcut wizard - used by BrowseDlgProc
void BrowseForFileOrFolder(LPWIZDATA lpwd)
{
    TCHAR szBrowseTitle[256];
    TCHAR szName[MAX_PATH];
    BROWSEINFO bi = {0};
    LPITEMIDLIST pidlSelected;
    LPITEMIDLIST pidlStartBrowse;
    IShellFolder* pdesktop;

    // Try to start the browse at a location indicated by the typed-in command line,
    // if possible
    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // ..Get the desktop folder
    if (SUCCEEDED(SHGetDesktopFolder(&pdesktop)))
    {
        // ..Now try to parse the path the user entered into a pidl to start at
        ULONG chEaten;

        if (FAILED(pdesktop->lpVtbl->ParseDisplayName(pdesktop, lpwd->hwnd, NULL,
            lpwd->szExeName, &chEaten, &pidlStartBrowse, NULL)))
        {
            // The path the user entered didn't make any sense
            // pidlStartBrowse should already be NULL, but we want to make sure
            pidlStartBrowse = NULL;
        }

        // Now we can continue and display the browse window

        // Load the title string for the browse window
        LoadString(g_hinst, IDS_FILEFOLDERBROWSE_TITLE, szBrowseTitle, ARRAYSIZE(szBrowseTitle));

        // Note that bi = {0} for all other members except:
        bi.hwndOwner = lpwd->hwnd;
        bi.pszDisplayName = szName;
        bi.lpszTitle = szBrowseTitle;
        bi.ulFlags = BIF_BROWSEINCLUDEFILES | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

        // Ensure the pidl we want to start at is passed to the callback function
        bi.lpfn = BrowseCallbackProc;
        bi.lParam = (LPARAM) pidlStartBrowse;

        pidlSelected = SHBrowseForFolder(&bi);

        if (pidlSelected != NULL)
        {
            STRRET strret;
            if (SUCCEEDED(pdesktop->lpVtbl->GetDisplayNameOf(pdesktop, pidlSelected, SHGDN_NORMAL | SHGDN_FORPARSING, &strret)))
            {
                StrRetToBuf(&strret, pidlSelected, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

                // Assume no parameters for this new file
                lpwd->szParams[0] = 0;
                
                // Populate the text box with the new file, etc.
                BrowseSetActive(lpwd);
            }
            // Free the pidl
            ILFree(pidlSelected);
        }

        if (pidlStartBrowse != NULL)
        {
            ILFree(pidlStartBrowse);
        }
            
        pdesktop->lpVtbl->Release(pdesktop);
    }
    else
    {
        // This really shouldn't happen; SHGetDesktopdesktop failed; out of memory?
    }
}

//
//  Main dialog procedure for first page of shortcut wizard.
//

//
//  Note that there are now two BrowseDlgProcs, the one below and
//  'SetupBrowseDlgProc'. This is because BrowseDlgProc now uses
//  a different method for implementing the 'Browse' button and I
//  wanted to do this without affecting the Setup Wizard which will
//  now use SetupBrowseDlgProc. - dsheldon 6/16/98
//

BOOL_PTR CALLBACK BrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                   case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            if (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                BrowseSetActive(lpwd);
                            }
                        }
                        break;

                   case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!NextPushed(lpwd) ||
                                ((lpwd->dwFlags & WDFLAG_SETUPWIZ) && !SetupCleanupExePath(lpwd)))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            BOOL ForceWx86;

#ifdef WX86
                            ForceWx86 = bWx86Enabled && bForceX86Env;
#else
                            ForceWx86 = FALSE;
#endif

                            if (!SetupCleanupExePath(lpwd) ||
                                !ExecSetupProg(lpwd, ForceWx86, TRUE))
                            {
                                BrowseSetActive(lpwd);
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                   default:
                      return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            BrowseInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hCmd = GetDlgItem(hDlg, IDC_COMMAND);

            SetFocus(hCmd);

            Edit_SetSel(hCmd, 0, -1);

            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                SetBrowseButtons(lpwd);
                            }
                            break;
                    }
                    break;

                case IDC_BROWSE:
                    if(lpwd)
                    {
                        BrowseForFileOrFolder(lpwd);
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // BrowseDlgProc


BOOL_PTR CALLBACK SetupBrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                   BOOL bForceWx86;
                   case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            if (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                BrowseSetActive(lpwd);
                            }
                        }
                        break;

                   case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            // Remember the previous "InstallMode"
                            lpwd->bPrevMode = TermsrvAppInstallMode();

                            // Set the "InstallMode"
                            SetTermsrvAppInstallMode(TRUE);

#ifdef WX86
                            bForceWx86 = bWx86Enabled && bForceX86Env;
#else
                            bForceWx86 = FALSE;
#endif
                            if (!NextPushed(lpwd) || !SetupCleanupExePath(lpwd) ||
                                  !ExecSetupProg(lpwd, bForceWx86, FALSE))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_WIZFINISH:
                       if(lpwd)
                       {
#ifdef WX86
                           bForceWx86 = bWx86Enabled && bForceX86Env;
#else
                           bForceWx86 = FALSE;
#endif

                           if (!SetupCleanupExePath(lpwd) ||
                               !ExecSetupProg(lpwd, bForceWx86, TRUE))
                           {
                               BrowseSetActive(lpwd);
                               SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                           }
                       }
                       break;

                   case PSN_RESET:
                       if(lpwd)
                       {
                           CleanUpWizData(lpwd);
                       }
                       break;

                   default:
                      return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            BrowseInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hCmd = GetDlgItem(hDlg, IDC_COMMAND);

            SetFocus(hCmd);

            Edit_SetSel(hCmd, 0, -1);

            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                        break;

                case IDC_COMMAND:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                SetBrowseButtons(lpwd);
                            }
                            break;
                    }
                    break;

                case IDC_BROWSE:
                    if(lpwd)
                    {
                        BrowsePushed(lpwd);
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // SetupBrowseDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instapp.cpp
//
// Installed applications 
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

#include "darapp.h"
#include "util.h"   
#include "appwizid.h"

// constructor
CDarwinPublishedApp::CDarwinPublishedApp(MANAGEDAPPLICATION * pma) : _cRef(1)
{
    DllAddRef();

    TraceAddRef(CDarwinPublishedApp, _cRef);
    
    hmemcpy(&_ma, pma, SIZEOF(_ma));
    _dwAction  |= APPACTION_INSTALL;
}


// destructor
CDarwinPublishedApp::~CDarwinPublishedApp()
{
    ClearManagedApplication(&_ma);
    DllRelease();
}



// IShellApps::GetAppInfo
STDMETHODIMP CDarwinPublishedApp::GetAppInfo(PAPPINFODATA pai)
{
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return E_FAIL;

    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPackageName, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }

    if ((dwInfoFlags & AIM_PUBLISHER) && _ma.pszPublisher && _ma.pszPublisher[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPublisher, &pai->pszPublisher)))
            pai->dwMask |= AIM_PUBLISHER;
    }

    if ((dwInfoFlags & AIM_SUPPORTURL) && _ma.pszSupportUrl && _ma.pszSupportUrl[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszSupportUrl, &pai->pszSupportUrl)))
            pai->dwMask |= AIM_SUPPORTURL;
    }

    if ((dwInfoFlags & AIM_VERSION) && (_ma.dwVersionHi != 0))
    {
        pai->pszVersion = (LPWSTR)SHAlloc(SIZEOF(WCHAR) * MAX_PATH);
        if (pai->pszVersion)
        {
            StringCchPrintf(pai->pszVersion, MAX_PATH, L"%d.%d.%d.%d", HIWORD(_ma.dwVersionHi), LOWORD(_ma.dwVersionHi), HIWORD(_ma.dwVersionLo), LOWORD(_ma.dwVersionLo));
        }
        pai->dwMask |= AIM_VERSION;
    }

    
    // REARCHITECT: get more info for Darwin apps
    // original comment: don't know how to retrieve other infomation, need to talk to the Darwin guys about it
    TraceMsg(TF_GENERAL, "(DarPubApp) GetAppInfo with %x but got %x", dwInfoFlags, pai->dwMask);
    
    return S_OK;
}

// IShellApps::GetPossibleActions
STDMETHODIMP CDarwinPublishedApp::GetPossibleActions(DWORD * pdwActions)
{
    ASSERT(pdwActions);
    *pdwActions = _dwAction;
    return S_OK;
}
        
// IShellApps::GetSlowAppInfo
STDMETHODIMP CDarwinPublishedApp::GetSlowAppInfo(PSLOWAPPINFO psai)
{
    return E_NOTIMPL;
}

// IShellApps::GetSlowAppInfo
STDMETHODIMP CDarwinPublishedApp::GetCachedSlowAppInfo(PSLOWAPPINFO psai)
{
    return E_NOTIMPL;
}

// IShellApps::IsInstalled
STDMETHODIMP CDarwinPublishedApp::IsInstalled()
{
    return _ma.bInstalled ? S_OK : S_FALSE;
}

// IPublishedApps::Install
STDMETHODIMP CDarwinPublishedApp::Install(LPSYSTEMTIME pftInstall)
{
    INSTALLDATA id;
    id.Type = APPNAME;
    id.Spec.AppName.Name = _ma.pszPackageName;
    id.Spec.AppName.GPOId = _ma.GpoId;
    LONG lRet = InstallApplication(&id);

    HRESULT hres = HRESULT_FROM_WIN32(lRet);
    // Tell the users what is wrong with this install. 
    if (FAILED(hres))
        _ARPErrorMessageBox(lRet);
    else
        _ma.bInstalled = TRUE;
    
    return hres;
}

// IPublishedApps::GetPublishedTime
STDMETHODIMP CDarwinPublishedApp::GetPublishedAppInfo(PPUBAPPINFO ppai)
{
    if (ppai->cbSize != SIZEOF(PUBAPPINFO))
        return E_FAIL;

    DWORD dwInfoFlags = ppai->dwMask;
    ppai->dwMask = 0;
    
    if ((dwInfoFlags & PAI_SOURCE) && _ma.pszPolicyName && _ma.pszPolicyName[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPolicyName, &ppai->pszSource)))
            ppai->dwMask |= PAI_SOURCE;
    }
    return S_OK;
}

// IPublishedApps::GetAssignedTime
STDMETHODIMP CDarwinPublishedApp::Unschedule(void)
{
    return E_NOTIMPL;
}

// IPublishedApp::QueryInterface
HRESULT CDarwinPublishedApp::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CDarwinPublishedApp, IPublishedApp),                  // IID_IPublishedApp
        QITABENTMULTI(CDarwinPublishedApp, IShellApp, IPublishedApp),  // IID_IShellApp
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IPublishedApp::AddRef
ULONG CDarwinPublishedApp::AddRef()
{
    ULONG cRef = InterlockedIncrement(&_cRef);
    TraceAddRef(CDarwinPublishedApp, cRef);
    return cRef;
}

// IPublishedApp::Release
ULONG CDarwinPublishedApp::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    TraceRelease(CDarwinPublishedApp, cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: darenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         2-03-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

#include "darenum.h"
#include "darapp.h"
#include "util.h"

CDarwinEnumPublishedApps::CDarwinEnumPublishedApps(GUID * pAppCategoryId) : _cRef(1)
{
    ASSERT(_bGuidUsed == FALSE);

    // Do we have a Catogory GUID?
    if (pAppCategoryId)
    {
        // Yes
        _CategoryGUID = *pAppCategoryId;
        _bGuidUsed = TRUE;
    }

    GetManagedApplications(_bGuidUsed ? &_CategoryGUID : NULL, _bGuidUsed ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_USERAPPLICATIONS,
                           MANAGED_APPS_INFOLEVEL_DEFAULT, &_dwNumApps, &_prgApps);
}

CDarwinEnumPublishedApps::~CDarwinEnumPublishedApps() 
{
    if (_prgApps && (_dwNumApps > 0))
    {
        LocalFree(_prgApps);
    }
}

// IEnumPublishedApps::QueryInterface
HRESULT CDarwinEnumPublishedApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CDarwinEnumPublishedApps, IEnumPublishedApps),                  // IID_IEnumPublishedApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IEnumPublishedApps::AddRef
ULONG CDarwinEnumPublishedApps::AddRef()
{
    _cRef++;
    TraceMsg(TF_OBJLIFE, "CDarwinEnumPublishedApps()::AddRef called, new _cRef=%lX", _cRef);
    return _cRef;
}

// IEnumPublishedApps::Release
ULONG CDarwinEnumPublishedApps::Release()
{
    _cRef--;
    TraceMsg(TF_OBJLIFE, "CDarwinEnumPublishedApps()::Release called, new _cRef=%lX", _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


// IEnumPublishedApps::Next
// PERF: we should do some optimization instead of enumerating these apps
// one by one.
// S_FALSE means end of enumeration
HRESULT CDarwinEnumPublishedApps::Next(IPublishedApp ** ppia)
{
    HRESULT hres = S_FALSE;
    *ppia = NULL;
    if (_prgApps && (_dwNumApps > 0) && (_dwIndex < _dwNumApps))
    {
        BOOL bContinue = FALSE;
        do {
            PMANAGEDAPPLICATION pma = &_prgApps[_dwIndex];

            // NOTE: no Hydra machines (_bTSSession == TRUE) we filter out all the
            // Darwin apps. 
            if (pma->pszPackageName && pma->pszPackageName[0])
            {
                CDarwinPublishedApp *pdpa = new CDarwinPublishedApp(pma);
                if (pdpa)
                {
                    *ppia = SAFECAST(pdpa, IPublishedApp *);
                    hres = S_OK;
                }
                else
                    hres = E_OUTOFMEMORY;
                bContinue = FALSE;
            }   
            else
            {
                ClearManagedApplication(pma);
                bContinue = TRUE;
            }
            
            _dwIndex++;
        } while (bContinue && (_dwIndex < _dwNumApps));
    }
    
    return hres;
}


// IEnumPublishedApps::Reset
HRESULT CDarwinEnumPublishedApps::Reset(void)
{
    if (_prgApps && (_dwNumApps > 0))
    {
        LocalFree(_prgApps);
    }

    GetManagedApplications(_bGuidUsed ? &_CategoryGUID : NULL, MANAGED_APPS_USERAPPLICATIONS,
                           _bGuidUsed ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_INFOLEVEL_DEFAULT, &_dwNumApps, &_prgApps);

    _dwIndex = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darenum.h ===
#ifndef __DARENUM_H_
#define __DARENUM_H_


class CDarwinEnumPublishedApps : public IEnumPublishedApps
{
public:

    CDarwinEnumPublishedApps(GUID * pAppCategoryId);
    ~CDarwinEnumPublishedApps();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumPublishedApps
    STDMETHODIMP Next(IPublishedApp ** ppia);
    STDMETHODIMP Reset(void);
    //STDMETHODIMP SetCategory(GUID * pAppCategoryId);

protected:

    UINT    _cRef;
    GUID    _CategoryGUID;
    BOOL    _bGuidUsed;
    DWORD   _dwNumApps;
    DWORD   _dwIndex;
    PMANAGEDAPPLICATION _prgApps;
};

#endif //__DARENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darpub.h ===
#ifndef __APPPUB_H_
#define __APPPUB_H_

/////////////////////////////////////////////////////////////////////////////
// CDarwinAppPublisher
class CDarwinAppPublisher : public IAppPublisher
{
public:
    CDarwinAppPublisher();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAppPublisher
    STDMETHODIMP GetNumberOfCategories(DWORD * pdwCat);
    STDMETHODIMP GetCategories(APPCATEGORYINFOLIST * pAppCategoryList);
    STDMETHODIMP GetNumberOfApps(DWORD * pdwApps);
    STDMETHODIMP EnumApps(GUID * pAppCategoryId, IEnumPublishedApps ** ppepa);

protected:

    virtual ~CDarwinAppPublisher();

    UINT _cRef;
};

#endif //__APPPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\darpub.cpp ===
#include "priv.h"

#include "darpub.h"
#include "darenum.h"
#include "sccls.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
// CDarwinAppPublisher
// Very thin layer around the darwin CoGet* API's


// constructor
CDarwinAppPublisher::CDarwinAppPublisher() : _cRef(1)
{
    DllAddRef();

    TraceAddRef(CDarwinAppPub, _cRef);
}


// destructor
CDarwinAppPublisher::~CDarwinAppPublisher()
{
    DllRelease();
}


// IAppPublisher::QueryInterface
HRESULT CDarwinAppPublisher::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
     static const QITAB qit[] = {
        QITABENT(CDarwinAppPublisher, IAppPublisher),                  // IID_IAppPublisher
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IAppPublisher::AddRef
ULONG CDarwinAppPublisher::AddRef()
{
    _cRef++;
    TraceAddRef(CDarwinAppPub, _cRef);
    return _cRef;
}

// IAppPublisher::Release
ULONG CDarwinAppPublisher::Release()
{
    _cRef--;
    TraceRelease(CDarwinAppPub, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// IAppPublisher::GetNumberOfCategories
STDMETHODIMP CDarwinAppPublisher::GetNumberOfCategories(DWORD * pdwCat)
{
    return E_NOTIMPL;
}

// IAppPublisher::GetCategories
STDMETHODIMP CDarwinAppPublisher::GetCategories(APPCATEGORYINFOLIST * pAppCategoryList)
{
    HRESULT hres = E_FAIL;
    DWORD   dwStatus;
    RIP(pAppCategoryList);

    ZeroMemory(pAppCategoryList, SIZEOF(APPCATEGORYINFOLIST));
    APPCATEGORYINFOLIST acil = {0};
    dwStatus = GetManagedApplicationCategories(0, &acil);
    
    hres = HRESULT_FROM_WIN32( dwStatus );

    if (SUCCEEDED(hres) && (acil.cCategory > 0))
    {
        hres = _DuplicateCategoryList(&acil, pAppCategoryList);
        ReleaseAppCategoryInfoList(&acil);
    }
    
    return hres;
}

// IAppPublisher::GetNumberOfApps
STDMETHODIMP CDarwinAppPublisher::GetNumberOfApps(DWORD * pdwApps)
{
    return E_NOTIMPL;
}

// IAppPublisher::EnumApps
STDMETHODIMP CDarwinAppPublisher::EnumApps(GUID * pAppCategoryId, IEnumPublishedApps ** ppepa)
{
    HRESULT hres = E_FAIL;
    CDarwinEnumPublishedApps * pdepa = new CDarwinEnumPublishedApps(pAppCategoryId);
    if (pdepa)
    {
        *ppepa = SAFECAST(pdepa, IEnumPublishedApps *);
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
    
}

/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CDarwinAppPublisher_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CDarwinAppPublisher* pObj = new CDarwinAppPublisher();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IAppPublisher *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\debug.cpp ===
#include "priv.h"
#include "iface.h"

// These have to come before dump.h otherwise dump.h won't declare
// some of the prototypes.  Failure to do this will cause the compiler
// to decorate some of these functions with C++ mangling.

#include "dump.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "appwiz.ini"
#define SZ_DEBUGSECTION     "appwiz"
#define SZ_MODULE           "APPWIZ"
#define DECLARE_DEBUG
#include <debug.h>


#ifdef DEBUG

LPCTSTR Dbg_GetGuid(REFGUID rguid, LPTSTR pszBuf, int cch)
{
    SHStringFromGUID(rguid, pszBuf, cch);
    return pszBuf;
}

LPCTSTR Dbg_GetBool(BOOL bVal)
{
    return bVal ? TEXT("TRUE") : TEXT("FALSE");
}



LPCTSTR Dbg_GetAppCmd(APPCMD appcmd)
{
    LPCTSTR pcsz = TEXT("<Unknown APPCMD>");
    
    switch (appcmd)
    {
    STRING_CASE(APPCMD_UNKNOWN);
    STRING_CASE(APPCMD_INSTALL);
    STRING_CASE(APPCMD_UNINSTALL);
    STRING_CASE(APPCMD_REPAIR);
    STRING_CASE(APPCMD_UPGRADE);
    STRING_CASE(APPCMD_MODIFY);
    STRING_CASE(APPCMD_GENERICINSTALL);
    }

    ASSERT(pcsz);

    return pcsz;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dlinst.cpp ===
//
// Downlevel (NT4, win9X) Install/Unistall page
//

#include "priv.h"
#include "appwizid.h"
#include "dlinst.h"
#include "sccls.h"

//
// DonwLevelManager: Ugly singleton class
//
// Mainly there to keep state info and for its destructor
//

class CDLManager* g_pDLManager = NULL;

class CDLManager
{
public:
    // Rely on the fact that shell "new" zero out memory
    CDLManager() : _hrInit(E_FAIL)
    {
        _hrInit = CoInitialize(0);
        _szStatic[0] = 0;
        _szStatic2[0] = 0;
        _uiStatic = 0;
    }
    ~CDLManager()
    {
        if (_peia)
            _peia->Release();

        if (SUCCEEDED(_hrInit))
            CoUninitialize();
    }
public:
    void InitButtonsHandle(HWND hwndPage)
    {
        // No check for success: check before using

        if (!_hwndModifyUninstall)
        {
            _hwndModifyUninstall = GetDlgItem(hwndPage, IDC_MODIFYUNINSTALL);
            _rghwndButtons[IDC_MODIFY-IDC_BASEBUTTONS]    = GetDlgItem(hwndPage, IDC_MODIFY);
            _rghwndButtons[IDC_REPAIR-IDC_BASEBUTTONS]    = GetDlgItem(hwndPage, IDC_REPAIR);
            _rghwndButtons[IDC_UNINSTALL-IDC_BASEBUTTONS] = GetDlgItem(hwndPage, IDC_UNINSTALL);
        }
    }
    void SetVisibleButtons(BOOL bShow3Buttons)
    {
        // bShow3Buttons == TRUE will show the three buttons

        if (_hwndModifyUninstall)
            ShowWindow(_hwndModifyUninstall, bShow3Buttons?SW_HIDE:SW_SHOW);

        for (int i=0;i<3;++i)
        {
            if (_rghwndButtons[i])
                ShowWindow(_rghwndButtons[i], bShow3Buttons?SW_SHOW:SW_HIDE);
        }
    }
public:
    IEnumInstalledApps* _peia;

    HWND _hwndModifyUninstall;
    HWND _rghwndButtons[3];

    HRESULT _hrInit;

    TCHAR _szStatic[250];
    TCHAR _szStatic2[50];

    UINT _uiStatic;
};

//
// pcApps has to be already initialized, we only increment it
//
STDAPI DL_FillAppListBox(HWND hwndListBox, DWORD* pdwApps)
{
    ASSERT(IsWindow(hwndListBox));

    static CDLManager DLManager;

    g_pDLManager = &DLManager;

    ASSERT(g_pDLManager);

    HRESULT hres = E_FAIL;

    IShellAppManager * pam;

    if (SUCCEEDED(g_pDLManager->_hrInit))
    {
        hres = CoCreateInstance(CLSID_ShellAppManager, NULL, CLSCTX_INPROC_SERVER,
            IID_IShellAppManager, (LPVOID *)&pam);

        if (SUCCEEDED(hres))
        {
            // Initialize InstalledApp Enum if required

            if (!g_pDLManager->_peia)
                hres = pam->EnumInstalledApps(&g_pDLManager->_peia);

            if (SUCCEEDED(hres))
            {
                IInstalledApp* pia;

                while ((hres = g_pDLManager->_peia->Next(&pia)) == S_OK)
                {
                    APPINFODATA ais = {0};
                    ais.cbSize = sizeof(ais);
                    ais.dwMask = AIM_DISPLAYNAME;

                    pia->GetAppInfo(&ais);
            
                    if (ais.dwMask & AIM_DISPLAYNAME)
                    {
                        int iIndex = LB_ERR;
                        iIndex = ListBox_AddString(hwndListBox, ais.pszDisplayName);

                        // Did the operation succeed?
                        if (LB_ERR != iIndex)
                        {
                            // Is memory OK?
                            if (LB_ERRSPACE != iIndex)
                            {
                                // Yes
                                ListBox_SetItemData(hwndListBox, iIndex, pia);

                                ++(*pdwApps);
                            }
                            else
                            {
                                // No, better get out
                                pia->Release();
                                break;                         
                            }
                        }
                    }
                    else
                        pia->Release();

                }
            }
            pam->Release();
        }
    }

    return hres;
}

STDAPI_(BOOL) DL_ConfigureButtonsAndStatic(HWND hwndPage, HWND hwndListBox, int iSel)
{
    ASSERT(IsWindow(hwndPage));
    ASSERT(IsWindow(hwndListBox));
    ASSERT(0 <= iSel);

    UINT uiStatic = IDS_UNINSTINSTR_LEGACY;

    BOOL fret = FALSE;

    if (LB_ERR != iSel)
    {
        LRESULT lres = ListBox_GetItemData(hwndListBox, iSel);

        if (LB_ERR != lres)
        {
            fret = TRUE;

            IInstalledApp* pia = (IInstalledApp*)lres;

            DWORD dwActions = 0;

            pia->GetPossibleActions(&dwActions);

            dwActions &= (APPACTION_MODIFY|APPACTION_REPAIR|APPACTION_UNINSTALL|APPACTION_MODIFYREMOVE);

            g_pDLManager->InitButtonsHandle(hwndPage);

            if (dwActions & APPACTION_MODIFYREMOVE)
            {
                // Manage to show the right buttons

                g_pDLManager->SetVisibleButtons(FALSE);

                EnableWindow(g_pDLManager->_hwndModifyUninstall, TRUE);
            }
            else
            {
                if (dwActions & (APPACTION_MODIFY|APPACTION_REPAIR|APPACTION_UNINSTALL))
                {
                    // Manage to show the right buttons

                    g_pDLManager->SetVisibleButtons(TRUE);

                    // Enable the applicable buttons

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_MODIFY-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_MODIFY)?TRUE:FALSE);

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_REPAIR-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_REPAIR)?TRUE:FALSE);

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_UNINSTALL-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_UNINSTALL)?TRUE:FALSE);

                    uiStatic = IDS_UNINSTINSTR_NEW;
                }
                else
                {
                    // Manage to show the right buttons

                    g_pDLManager->SetVisibleButtons(FALSE);

                    EnableWindow(g_pDLManager->_hwndModifyUninstall, FALSE);
                }
            }
        }
    }

    if (!(*g_pDLManager->_szStatic))
    {
        if(!LoadString(g_hinst, IDS_UNINSTINSTR, g_pDLManager->_szStatic, ARRAYSIZE(g_pDLManager->_szStatic)))
            *(g_pDLManager->_szStatic) = 0;
    }   
    
    if (*g_pDLManager->_szStatic && (g_pDLManager->_uiStatic != uiStatic))
    {
        TCHAR szMergedStatic[250];

        LoadString(g_hinst, uiStatic, g_pDLManager->_szStatic2, ARRAYSIZE(g_pDLManager->_szStatic2));

        StringCchPrintf(szMergedStatic, ARRAYSIZE(szMergedStatic), g_pDLManager->_szStatic, g_pDLManager->_szStatic2);

        SetDlgItemText(hwndPage, IDC_UNINSTINSTR, szMergedStatic);

        g_pDLManager->_uiStatic = uiStatic;
    }

    return fret;
}

STDAPI_(BOOL) DL_InvokeAction(int iButtonID, HWND hwndPage, HWND hwndListBox, int iSel)
{
    BOOL fret = FALSE;

    // Get app from listbox selection

    LRESULT lres = ListBox_GetItemData(hwndListBox, iSel);
    
    if (LB_ERR != lres)
    {
        fret = TRUE;

        IInstalledApp* pia = (IInstalledApp*)lres;

        // Invoke action from button ID

        if (pia)
        {

            HWND hwndPropSheet = GetParent(hwndPage);

            ::EnableWindow(hwndPropSheet, FALSE);

            switch(iButtonID)
            {
                case IDC_MODIFY:
                    pia->Modify(hwndPropSheet);
                    break;
                case IDC_REPAIR:
                    // Pass FALSe, we don't want to reinstall, only repair
                    pia->Repair(FALSE);
                    break;
                case IDC_MODIFYUNINSTALL:
                case IDC_UNINSTALL:
                    pia->Uninstall(hwndPropSheet);
                    break;
                default:
                    //???
                    break;
            }

            ::EnableWindow(hwndPropSheet , TRUE);
        }
    }

    return fret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dump.c ===
#include "priv.h"
#include "shdguid.h"
#include "shguidp.h"

// REARCHITECT (scotth): someday convert dump.c to dump.cpp

#include "..\..\inc\dump.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "shappmgrp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dlinst.h ===
//
// Downlevel (NT4, win9X) Install/Unistall page
//

STDAPI DL_FillAppListBox(HWND hwndListBox, DWORD* pdwApps);
STDAPI_(BOOL) DL_ConfigureButtonsAndStatic(HWND hwndPage, HWND hwndListBox, int iSel);
STDAPI_(BOOL) DL_InvokeAction(int iButtonID, HWND hwndPage, HWND hwndListBox, int iSel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dump.h ===
//
// Prototypes for debug dump functions
//

#ifndef _DUMP_H_
#define _DUMP_H_

#ifdef DEBUG

EXTERN_C LPCTSTR Dbg_GetGuid(REFGUID rguid, LPTSTR pszBuf, int cch);

EXTERN_C LPCTSTR Dbg_GetBool(BOOL bVal);

#else

#define Dbg_GetGuid(rguid, pszBuf, cch)     TEXT("")

#define Dbg_GetBool(bVal)                   TEXT("")
#define Dbg_GetAppCmd(appcmd)               TEXT("")

#endif // DEBUG

#endif // _DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\dll.cpp ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions 
 *
 ***************************************************************************/

// Note: Proxy/Stub Information from ATL
//
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for shappmgr.idl by adding the following 
//      files to the Outputs.
//          shappmgr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f shappmgrps.mk in the project directory.


#include "priv.h"
#include "sccls.h"

#include <ntverp.h>
#include <advpub.h>         // For REGINSTALL

// Define GUIDs

extern "C" 
{
HINSTANCE g_hinst = NULL;

int g_cxIcon;
int g_cyIcon;
BOOL g_bMirroredOS;
LONG    g_cRefThisDll = 0;      // per-instance

#ifdef WX86
//
// from uninstal.c
//
extern BOOL bWx86Enabled;
BOOL IsWx86Enabled(VOID);
#endif

};

CComModule _Module;         // ATL module object


/*----------------------------------------------------------
Purpose: DllEntryPoint

*/
BOOL 
APIENTRY 
DllMain(
    IN HINSTANCE hinst, 
    IN DWORD dwReason, 
    IN LPVOID lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinst);
        SHFusionInitializeFromModule(hinst);
     
#ifdef DEBUG
        CcshellGetDebugFlags();
        
        if (g_dwBreakFlags & BF_ONDLLLOAD)
            DebugBreak();
#endif

        g_hinst = hinst;

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);
        g_bMirroredOS = IS_MIRRORING_ENABLED();
#ifdef WX86
        bWx86Enabled = IsWx86Enabled();
#endif
        break;
        

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        // We shouldn't get these because we called 
        // DisableThreadLibraryCalls(). 
        ASSERT_MSG(0, "DllMain received DLL_THREAD_ATTACH/DETACH!  We're not expecting this.");
        break;

    default:
        break;
    } 

    return TRUE;
} 


/*----------------------------------------------------------
Purpose: This function provides the DLL version info.  This 
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         The caller must GetProcAddress this function.  

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hinst, szSection, &stReg);

            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}


//
// Remove any legacy registry information.
//
void _RemoveLegacyRegistryEntries(void)
{
    //
    // Windows XP made the ADCCtl ActiveX control obsolete.
    // Remove the registration of this control.
    //
    SHDeleteKey(HKEY_CLASSES_ROOT, TEXT("ADCCtl.ADCCtl.1"));
    SHDeleteKey(HKEY_CLASSES_ROOT, TEXT("ADCCtl.ADCCtl"));
    SHDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{3964D9A0-AC96-11D1-9851-00C04FD91972}"));
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        hr = THR(_CallRegInstall("RegDll", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;
    }
    else
    {
        hr = THR(_CallRegInstall("UnregDll", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;
    }

    return hrExternal;
}


/*----------------------------------------------------------
Purpose: Returns a class factory to create an object of
         the requested type.

*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    TraceMsg(TF_OBJLIFE, "DllGetClassObject called with riid=%x (%x)", riid, &riid);

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        // Try our native class factory
        HRESULT hres = GetClassObject(rclsid, riid, ppv);

        if (FAILED(hres))
        {
            // Try the ATL class factory
            hres = _Module.GetClassObject(rclsid, riid, ppv);
        }
        return hres;
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}


STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif

    // This component uses ATL and natively-implemented COM objects
    if (0 != g_cRefThisDll || 0 != _Module.GetLockCount())
        return S_FALSE;

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}


STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
    ASSERT(g_cRefThisDll < 1000);   // reasonable upper limit
}


STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}


STDAPI DllRegisterServer(void)
{
    HRESULT hres = S_OK;

    //
    // We have some old registry entries that must be removed on upgrade.
    //
    _RemoveLegacyRegistryEntries();
    
#ifdef _MERGE_PROXYSTUB
    hres = THR(PrxDllRegisterServer());
    if (FAILED(hres))
        return hres;
#endif
    return hres;
}


STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\events.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_ARPCtlEvents
template <class T>
class CProxy_ARPCtlEvents : public IConnectionPointImpl<T, &DIID__ARPCtlEvents, CComDynamicUnkArray>
{
public:
//methods:
//_ARPCtlEvents : IDispatch
public:
	void Fire_OnSyncDataReady()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	void Fire_OnAsyncDataReady(
		long row)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= row;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_OnRowReady(
		long row)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= row;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\findapp.h ===
#ifndef __FINDAPP_H_
#define __FINDAPP_H_

// Match Levels
#define MATCH_LEVEL_NOMATCH 0
#define MATCH_LEVEL_LOW     1
#define MATCH_LEVEL_NORMAL  2
#define MATCH_LEVEL_HIGH    3

// Parse a string to find the possible path in it
BOOL ParseInfoString(LPCTSTR pszInfo, LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszOut);

// Match the app folder or exe name
int MatchAppName(LPCTSTR pszName, LPCTSTR pszAppFullName, LPCTSTR pszAppShortName, BOOL bStrict);

// Find the best match for an app folder give a path name
int FindBestMatch(LPCTSTR pszFolder, LPCTSTR pszAppFullName, LPCTSTR pszAppShortName, BOOL bStrict, LPTSTR pszResult);

// Find a sub word
LPCTSTR FindSubWord(LPCTSTR pszStr, LPCTSTR pszSrch);

// is the path a setup path, cStripLevel is the maximum level we go up in the
// directory chain
BOOL PathIsSetup(LPCTSTR pszFolder, int cStripLevel);

BOOL PathIsCommonFiles(LPCTSTR pszPath);

BOOL PathIsUnderWindows(LPCTSTR pszPath);
#endif // _FINDAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\findapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: findapp.cpp
//
// Implements hueristics to find the folder of an application 
//            
// History:
//         2-17-98  by dli implemented FindAppFolder
//         5-01-98  added lots of little functioins 
//------------------------------------------------------------------------
#include "priv.h"

#include "appwiz.h"
#include "appsize.h"
#include "findapp.h"
#include "util.h"


// Things to do:
// 1. Move special strings into the RC file


/*-------------------------------------------------------------------------
Purpose: This function searches and returns the sub word (if one is found).
         pszStr is the big string, pszSrch is the candidate substring used
         in the search.

         Returns NULL if no subword is found.
*/
LPCTSTR FindSubWord(LPCTSTR pszStr, LPCTSTR pszSrch)
{
    LPCTSTR pszRet = NULL;

    LPCTSTR pszBegin = pszStr;
    // Search for the sub string from the beginning
    LPCTSTR pszSub;
    while (NULL != (pszSub = StrStrI(pszBegin, pszSrch)))
    {
        LPCTSTR pszPrev;
        LPCTSTR pszEnd = pszSub + lstrlen(pszSrch);
        
        // Is the previous character alphanumeric?
        if (pszSub != pszBegin)
        {
            ASSERT(pszSub > pszBegin);
            pszPrev = CharPrev(pszBegin, pszSub);
            ASSERT(pszPrev >= pszBegin);
            if (IsCharAlphaNumeric(*pszPrev))
            {
                // yes, go on searching
                pszBegin = pszEnd;
                continue;
            }
        }

        // Is the character after the sub string we found
        // alpha numeric? 
        if (IsCharAlphaNumeric(*pszEnd))
        {
            // yes, go on searching
            pszBegin = pszEnd;
            continue;
        }

        // No to both questions above, it is a sub word!!
        pszRet = pszSub;
        break;
    }

    return pszRet;
}

int MatchMultipleSubWords(LPCTSTR pszStr, LPCTSTR pszSubWords)
{
    if (!StrChrI(pszSubWords, TEXT(' ')))
        return 0;

    TCHAR szSubWords[MAX_PATH];
    StringCchCopy(szSubWords, ARRAYSIZE(szSubWords), pszSubWords);
    LPTSTR pszStart = szSubWords;

    LPTSTR pszSpace;
    int iNumMatches = 0;
    while (pszSpace = StrChrI(pszStart, TEXT(' ')))
    {
        *pszSpace = 0;
        if (FindSubWord(pszStr, pszStart))
            iNumMatches++;
        pszStart = ++pszSpace;
    }

    if (FindSubWord(pszStr, pszStart))
        iNumMatches++;
    
    return iNumMatches;
}




/*-------------------------------------------------------------------------
Purpose: Removes the spaces from pszPath, including spaces in the middle
         of the folder or filespec.  The resulting string is placed in
         pszBuf.

         Example:
         
         (before)
         "C:\Program Files\Microsoft Office\Word.exe"
         (after)
         "C:\ProgramFiles\MicrosoftOffice\Word.exe"
         
*/
void PathRemoveSpaces(LPCTSTR pszPath, LPTSTR pszBuf, int cchBuf)
{
    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));

    --cchBuf; // Leave room for terminating NUL.

    while(0 < cchBuf && TEXT('\0') != *pszPath)
    {
        //
        // Skip beyond spaces.
        //
        while(TEXT(' ') == *pszPath)
            ++pszPath;

        if (TEXT('\0') != *pszPath)
        {
            //
            // Copy to output.
            //
            *pszBuf++ = *pszPath++;
            --cchBuf;
        }
    }
    *pszBuf = TEXT('\0');
}


// Returns TRUE if all chars in pszCharGroup is in pszString
BOOL AllCharsInString(LPCTSTR pszString, LPCTSTR pszCharGroup)
{
    if (!pszCharGroup || !pszCharGroup[0])
        return FALSE;

    LPCTSTR pszT = pszCharGroup;
    while (*pszT && StrChrI(pszString, *pszT))
        pszT++;

    return (*pszT == 0) ? TRUE : FALSE;
}



/*-------------------------------------------------------------------------
Purpose: Given the full name (and sometimes the short name) of the app,
         this function determines whether the given pszName is a match.
         If bStrict is TRUE, the heuristic skips the slinky checks.

         Returns a ranking of the accuracy of the match:
            MATCH_LEVEL_NOMATCH - pszName does not match whatsoever
            MATCH_LEVEL_LOW     - pszName somewhat matches
            MATCH_LEVEL_NORMAL  - pszName matches pretty good
            MATCH_LEVEL_HIGH    - pszName definitely matches
*/
int MatchAppNameExact(
    LPCTSTR pszName, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName, 
    BOOL bStrict)
{
    TraceMsg(TF_FINDAPP, "MatchAppName ---- %s | %s | %s ", pszName, pszAppShortName, pszAppFullName);

    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    // In the heuristic below, we never degrade from a better match
    // to a lower match.
    int iMatch = MATCH_LEVEL_NOMATCH;

    // Since the long fullname has the most accuracy, check that first.
    if (pszAppFullName && *pszAppFullName)
    {
        // Is pszName equivalent to the full name of the app?
        if (!lstrcmpi(pszAppFullName, pszName))
            iMatch = MATCH_LEVEL_HIGH;        // Yes, definitely a high match
        else
        {
            // No, okay let's see if there are multiple (> 1) number of sub 
            // words from pszName that match the subwords in the app's full name 
            int iSubMatches = MatchMultipleSubWords(pszAppFullName, pszName);

            // More than three matches, definitely high match
            // NOTE: there could be a risk here, but I have not found a 
            // counter example yet. 
            if (iSubMatches > 3)
                iMatch = MATCH_LEVEL_HIGH;

            // NOTE: there is a risk here. For example: 
            //
            // Microsoft Internet Explorer Setup Files vs. 
            // Microsoft Internet Explorer ... 
            
            else if ((iSubMatches > 1) && (!bStrict || (iSubMatches > 2)))
                iMatch = MATCH_LEVEL_NORMAL;

            // All these are turned off if we have a strict matching
            else if (!bStrict)
            {
                // If the potential folder name is a subset of the full name or 
                // if all of the characters of the potential folder name can 
                // be found in the full name, we have a low match 
                // (Counter Ex: Microsoft vs. Microsoft Office)

                // NOTE: The reason for AllCharsInString is to detect case like 
                // Ex: "PM65 vs. Adobe Page Maker 6.5"
                // There might be a risk in this, but I have not found a counter 
                // example, yet.
                if (StrStrI(pszAppFullName, pszName) || AllCharsInString(pszAppFullName, pszName))
                    iMatch = MATCH_LEVEL_LOW;
            }
        }
    }

    // Association between folder name and the reg key name(short name)
    // This is given second priority because the reg key name is unreliable (could be an ID)
    if (MATCH_LEVEL_HIGH > iMatch && pszAppShortName && *pszAppShortName)
    {
        // Does the string exactly match the app's shortname?
        if (!lstrcmpi(pszAppShortName, pszName))
            iMatch = MATCH_LEVEL_HIGH;      // yes

        // All these are turned off if we have strict matching
        else if (!bStrict)
        {
            // Does the string contain the app's shortname?
            if (iMatch < MATCH_LEVEL_NORMAL && StrStrI(pszName, pszAppShortName))
                iMatch = MATCH_LEVEL_NORMAL;        // yes

            // Or does the app's shortname contain the string?
            else if (iMatch < MATCH_LEVEL_LOW && StrStrI(pszAppShortName, pszName))
                iMatch = MATCH_LEVEL_LOW;           // yes
        }
    }
    
    return iMatch;
}


/*-------------------------------------------------------------------------
Purpose: This function tries some different heuristics to see how well
         pszCandidate matches the given variations of the app name
         (short and long names).

         If bStrict is TRUE, the heuristic skips the slinky checks.

         Returns a ranking of the accuracy of the match:
            MATCH_LEVEL_NOMATCH - pszName does not match whatsoever
            MATCH_LEVEL_LOW     - pszName somewhat matches
            MATCH_LEVEL_NORMAL  - pszName matches pretty good
            MATCH_LEVEL_HIGH    - pszName definitely matches
*/
int MatchAppName(
    LPCTSTR pszCandidate, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName,    OPTIONAL
    BOOL bStrict)
{
    int iMatch = MATCH_LEVEL_NOMATCH;
    if (pszCandidate && *pszCandidate)
    {
        // Clean up all the strings MAX_PATH+1, in this case, we only stick a
        // ' ' on 
        TCHAR szCleanFolderName[MAX_PATH+1];
        InsertSpaceBeforeVersion(pszCandidate, szCleanFolderName);
        
        // Now match the exact name
        iMatch = MatchAppNameExact(szCleanFolderName, pszAppFullName, pszAppShortName, bStrict);

        // Is there still no match, and do we have some flexibility to fudge?
        if (!bStrict)
        {
            int iNewMatch = MATCH_LEVEL_NOMATCH;
            // Yes; try finding it without the spaces in the filename and paths
            TCHAR szCandidate[MAX_PATH];
            TCHAR szFullName[MAX_PATH];
            TCHAR szShortName[MAX_PATH];
            
            PathRemoveSpaces(pszCandidate, szCandidate, ARRAYSIZE(szCandidate));
            PathRemoveSpaces(pszAppFullName, szFullName, ARRAYSIZE(szFullName));

            if (pszAppShortName && pszAppShortName[0])
            {
                PathRemoveSpaces(pszAppShortName, szShortName, ARRAYSIZE(szShortName));
                pszAppShortName = szShortName;
            }
            
            iNewMatch = MatchAppNameExact(szCandidate, szFullName, pszAppShortName, bStrict);

            if (iNewMatch > iMatch)
                iMatch = iNewMatch;
        }
    }

    return iMatch;
}


// This function returns a pointer to the beginning of the right most string 
// which looks like folder path.  This only looks for paths with fixed drive
// letters.
//
// NOTES: 
//  1. This funcion damages pszString 
//  2. We are really cracking the string, what happens
//     in localized versions? Are these going to be international char strings?
//
// Returns NULL if it could not find a legit-looking path.

LPTSTR GetRightMostFolderPathInString(LPTSTR pszString)
{
    // Reverse find the ':' in the path
    LPTSTR pszRoot = StrRChr(pszString, NULL, TEXT(':'));

    // Make sure what we found is not at the beginning of the whole 
    // string or the last character of the string
    if (pszRoot && (pszRoot > pszString) && (*CharNext(pszRoot) == TEXT('\\')))
    {
        // Okay, now move back one, we should be pointing to the drive letter
        pszRoot--;          // Don't have to use CharPrev since we're on a ':'
        
        TCHAR szDrive[2];
        szDrive[0] = *pszRoot;
        szDrive[1] = 0;
        CharUpper(szDrive);
        if ((szDrive[0] >= TEXT('C')) && (szDrive[0] <= TEXT('Z')))
        {
            // Yes, it is a real drive letter
            TCHAR atch[4];
            StringCchPrintf(atch, ARRAYSIZE(atch), TEXT("%c:\\"), *pszRoot);

            // We are only interested in fixed drives and let's check the path
            if (GetDriveType(atch) == DRIVE_FIXED)
            {
                PathRemoveFileSpec(pszRoot);
                return pszRoot;
            }
        }
    }

    return NULL;
}


// Given a full path, an app name, an app short name, finds the best match in this path
// EX: App Name: Microsoft Office  Short Name: Office
// C:\Microsoft Office\Office --> C:\Microsoft Office

int FindBestMatch(
    LPCTSTR pszFolder, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName, 
    BOOL bStrict, 
    LPTSTR pszResult)
{
    // This can't be a root directory 
    ASSERT(!PathIsRoot(pszFolder));

    int iBest = MATCH_LEVEL_NOMATCH;
    int iPre  = MATCH_LEVEL_NOMATCH;
    int iThis  = MATCH_LEVEL_NOMATCH;
    
    TCHAR szPrefix[MAX_PATH];
    StringCchCopy(szPrefix, ARRAYSIZE(szPrefix), pszFolder);

    if (PathRemoveFileSpec(szPrefix) && !PathIsRoot(szPrefix))
        iPre = FindBestMatch(szPrefix, pszAppFullName, pszAppShortName, bStrict, pszResult);
    
    LPTSTR pszName = PathFindFileName(pszFolder);
    if (pszName)
        iThis = MatchAppName(pszName, pszAppFullName, pszAppShortName, bStrict);

    iBest = (iPre > iThis) ? iPre : iThis;
    
    // In case there is both match in the current folder and the previous folder
    // take this current one because:
    // 1. This folder is closer to the "Uninstall" or "Modify" string
    // 2. It costs less to walk this folder;
    if ((iThis > MATCH_LEVEL_NOMATCH) && (iThis >= iPre))
    {
        lstrcpy(pszResult, pszFolder);
    }
    
    return iBest;
}


/*--------------------------------------------------------------------------
Purpose: Given a file name or a folder name, compare it with our list of setup
app names.

NOTE: the comparason are done as the following: We compare the name with the first portion
and the last portion of our setup name EX:
name --> myuninst.exe or uninstall.exe
Setup Name --> uninst

should bother return TRUE 
*/
BOOL IsFileOrFolderSetup(LPTSTR pszName, LPCTSTR pszDoubleString)
{       
    ASSERT(pszName);
    ASSERT(pszDoubleString);

    BOOL bRet = FALSE;

    // Neither pszName of pszDoubleString should be NULL
    if (pszName && pszDoubleString)
    {
        PathRemoveExtension(pszName);
        int cchName = lstrlen(pszName);
        LPCTSTR pszT = pszDoubleString;
        while (*pszT)
        {
            int cch = lstrlen(pszT);
            // NOTE: we compare from the beginning and from the end
            if (!StrCmpNI(pszName, pszT, cch) ||
                ((cchName > cch) && !StrCmpNI(pszName + cchName - cch, pszT, cch)))
            {
                bRet = TRUE;
                break;
            }
            
            pszT += lstrlen(pszT) + 1;
        }
    }

    return bRet;
}
/*-------------------------------------------------------------------------
Purpose: Sniffs the pszFolder for any signs that the path refers to a setup
         program.  Paths that have foldernames or filespecs with the word
         "setup" or "install" are suspect.  Returns TRUE if it looks like
         it might be a setup app or folder.

         An example is "c:\program files\microsoft office\office\setup\outlook\olmaint.exe".
         This function will return TRUE because "setup" is one of the parent
         folder names.

         cStripLevel means how many levels we will go up the directory ladder
*/
BOOL PathIsSetup(LPCTSTR pszFolder, int cStripLevel)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    ASSERT(cStripLevel > 0);
            
    BOOL bRet = FALSE;
    TCHAR szPath[MAX_PATH];
    TCHAR szName[MAX_PATH];
    StringCchCopy(szPath, ARRAYSIZE(szPath), pszFolder);

    static TCHAR s_szNames[MAX_PATH];
    static BOOL s_bNamesLoaded = FALSE;

    if (!s_bNamesLoaded)
    {
        LoadAndStrip(IDS_SETUPAPPNAMES, s_szNames, ARRAYSIZE(s_szNames));
        s_bNamesLoaded = TRUE;
    }
    
    LPTSTR pszName;
    int iStripLevel = cStripLevel;
    while ((iStripLevel-- > 0) && (NULL != (pszName = PathFindFileName(szPath))))
    {
        StringCchCopy(szName, ARRAYSIZE(szName), pszName);
        if (IsFileOrFolderSetup(szName, s_szNames))
        {
            bRet = TRUE;
            break;
        }
        else if (!PathRemoveFileSpec(szPath) || PathIsRoot(szPath))
            break;
    }

    return bRet;
}

BOOL PathIsCommonFiles(LPCTSTR pszPath)
{
    TCHAR szCommonFiles[MAX_PATH];
    TCHAR szShortCommonFiles[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    
    // This definitely need to be put in the RC file
    StringCchPrintf(szCommonFiles, ARRAYSIZE(szCommonFiles), TEXT("%c:\\Program Files\\Common Files"), pszPath[0]);

    BOOL bShort = GetShortPathName(szCommonFiles, szShortCommonFiles, ARRAYSIZE(szShortCommonFiles));
    if (bShort)
    {
        ASSERT(szShortCommonFiles[0] == szCommonFiles[0]);
    }
    
    return PathIsPrefix(szCommonFiles, pszPath) || (bShort && PathIsPrefix(szShortCommonFiles, pszPath));
}


// returns TRUE if windows directory is the prefix of pszPath
BOOL PathIsUnderWindows(LPCTSTR pszPath)
{
    TCHAR szWindows[MAX_PATH];

    if (GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows)))
    {
        // Is this path somewhere below the windows directory?
        return PathIsPrefix(szWindows, pszPath);
    }
    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: This function looks for a valid-looking path in the given pszInfo
         string that may indicate where the app is installed.  This attempts
         to weed out suspect paths like references to setup programs in 
         other folders.

         Returns TRUE if a useful path was found.  pszOut will contain the
         path.
*/
BOOL ParseInfoString(LPCTSTR pszInfo, LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszOut)
{
    ASSERT(IS_VALID_STRING_PTR(pszInfo, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1));
    ASSERT(pszOut);

    *pszOut = 0;
    
    // if it starts with rundll, forget it!
    if (!StrCmpNI(pszInfo, TEXT("rundll"), SIZECHARS(TEXT("rundll"))))
        return FALSE;

    // more strings we bail on ...
    
    TCHAR szInfoT[MAX_INFO_STRING];
    lstrcpyn(szInfoT, pszInfo, SIZECHARS(szInfoT));

    // The algorithm: we crack the string, and go from the right most path inside the string
    // to the left most one by one and guess which one is a more reasonable
    LPTSTR pszFolder;
    while (NULL != (pszFolder = GetRightMostFolderPathInString(szInfoT)))
    {
        TCHAR szFullPath[MAX_PATH];
        // GetLongPathName does not work on Win 95
        if (StrChrI(pszFolder, TEXT('\\')) && GetLongPathName(pszFolder, szFullPath, ARRAYSIZE(szFullPath)))
        {
            // Make sure this actually is a path and not a root drive
            if (PathIsDirectory(szFullPath) && !PathIsRoot(szFullPath) && !PathIsUnderWindows(szFullPath))
            {
                // No; then we'll consider it

                LPTSTR pszFolderName;
                BOOL bStop = FALSE;
                // Find out the last folder name
                // If it is "setup" or "install", move up until it's not or we can't move up any more
                while(NULL != (pszFolderName = PathFindFileName(szFullPath)) &&
                      PathIsSetup(pszFolderName, 1))
                {
                    // Have we reached the root of the path?
                    if (!PathRemoveFileSpec(szFullPath) || PathIsRoot(szFullPath))
                    {
                        // Yes; don't go any further
                        bStop = TRUE;
                        break;
                    }
                }

                // We still reject those strings with "setup" or "install" in the middle,
                // or those under the program files common files
                if (!bStop && !PathIsRoot(szFullPath) && 
                    !PathIsSetup(szFullPath, 3) && !PathIsCommonFiles(szFullPath))
                {
                    if (MATCH_LEVEL_NOMATCH < FindBestMatch(szFullPath, pszFullName, pszShortName, FALSE, pszOut))
                        return TRUE;
                }
            }
        }
        
        *pszFolder = 0;
        continue;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\iface.h ===
// iface.h : Definition of private interfaces

// {DB89BD6D-FCCD-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IAppData, 0xdb89bd6d, 0xfccd, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);


#ifndef __IFACE_H_
#define __IFACE_H_


// IAppData
//      This provides an interface to an appdata object.

// commands for DoCommand()
typedef enum tagAPPCMD 
{
    APPCMD_UNKNOWN          = 0,
    APPCMD_INSTALL          = 1,        // "install"
    APPCMD_UNINSTALL        = 2,        // "uninstall"
    APPCMD_MODIFY           = 3,        // "modify"
    APPCMD_REPAIR           = 4,        // "repair"
    APPCMD_UPGRADE          = 5,        // "upgrade"
    APPCMD_GENERICINSTALL   = 6,        // "generic install" (install from floppy or CD)
    APPCMD_NTOPTIONS        = 7,        // "nt options"
    APPCMD_WINUPDATE        = 8,        // "update windows"
    APPCMD_ADDLATER         = 9,        // "add later"
} APPCMD;


#undef  INTERFACE
#define INTERFACE   IAppData

DECLARE_INTERFACE_(IAppData, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IAppData ***
    STDMETHOD(DoCommand)        (THIS_ HWND hwndParent, APPCMD appcmd) PURE;
    STDMETHOD(ReadSlowData)     (THIS) PURE;
    STDMETHOD_(APPINFODATA *, GetDataPtr)(THIS) PURE;
    STDMETHOD_(SLOWAPPINFO *, GetSlowDataPtr)(THIS) PURE;
    STDMETHOD(GetFrequencyOfUse)(THIS_ LPWSTR pszBuf, int cchBuf) PURE;
    STDMETHOD(SetNameDupe)      (THIS_ BOOL bDupe) PURE;
};




#endif //__IFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\folder.c ===
//
//  Folder.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"
#include "help.h"        // Help context IDs

typedef struct _FILEITEMDATA {
    DWORD   dwFlags;
    TCHAR   szPath[1];
} FILEITEMDATA, * LPFILEITEMDATA;

#define FIDFLAG_CANADDNEW      0x00000001
#define FIDFLAG_CANDEL         0x00000002
#define FIDFLAG_ISFOLDER       0x00000004
#define FIDFLAG_ISPROGS        0x00000008


//
//
//

int CALLBACK CompareFolderCB(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    #define lpfid1  ((LPFILEITEMDATA)lParam1)
    #define lpfid2  ((LPFILEITEMDATA)lParam2)
    #define b1IsDir (lpfid1->dwFlags & FIDFLAG_ISFOLDER)
    #define b2IsDir (lpfid2->dwFlags & FIDFLAG_ISFOLDER)

    //
    // Programs folder always goes to top
    //

    if (lpfid1->dwFlags & FIDFLAG_ISPROGS)
    {
        return(-1);
    }

    if (lpfid2->dwFlags & FIDFLAG_ISPROGS)
    {
        return(1);
    }

    if (b1IsDir == b2IsDir)
    {
        return(lstrcmpi(lpfid1->szPath, lpfid2->szPath));
    }
    else
    {
        if (b1IsDir)
        {
            return(-1);
        }
        else
        {
            return(1);
        }
    }

    #undef  b1IsDir
    #undef  b2IsDir
    #undef  lpfid1
    #undef  lpfid2
}


//
//  Sorts the specified folder so that folders appear at the top and all
//  files appear in alphabetical order below.
//

void SortFolder(HWND hwndTree, HTREEITEM hParent)
{
    TV_SORTCB sSortCB;

    sSortCB.hParent = hParent;
    sSortCB.lpfnCompare = CompareFolderCB;
    sSortCB.lParam = 0;

    TreeView_SortChildrenCB(hwndTree, &sSortCB, FALSE);
}



//
//  Adds a new folder for the specifed path and returns its HTREEITEM.        If
//  it is unable to add the item then NULL is returned.
//  NOTE:  If dwFileAttributes == AI_NOATTRIB (-1) then no attributes specified.
//           If pidl is NULL then no pidl specified.
//

HTREEITEM AddItem(HWND hwndTree, LPCTSTR pszPath,
                    HTREEITEM hParent, LPITEMIDLIST pidl,
                    DWORD dwFlags)
{
    HTREEITEM       newhti = NULL;
    int cchPath = lstrlen(pszPath) + 1;
    LPFILEITEMDATA  lpfid = (LPFILEITEMDATA)LocalAlloc(LMEM_FIXED,
                             sizeof(FILEITEMDATA) + (cchPath*sizeof(TCHAR)) );
    if (lpfid)
    {
        TV_INSERTSTRUCT tvis;
        lpfid->dwFlags = dwFlags;
        
        StringCchCopy(lpfid->szPath, cchPath, pszPath);

        tvis.item.pszText = LPSTR_TEXTCALLBACK;
        tvis.item.iImage = tvis.item.iSelectedImage = I_IMAGECALLBACK;
        tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvis.item.lParam = (LPARAM)lpfid;

        tvis.hParent = hParent;
        tvis.hInsertAfter = TVI_LAST;

        newhti = TreeView_InsertItem(hwndTree, &tvis);
        if (!newhti)
            LocalFree((LPVOID)lpfid);
    }
    return newhti;
}

//
//  Flags for FillFolder
//

#define FFF_AddFiles                1
#define FFF_AddDirs                2

//
//  Recursively add all folders below CurDir to the tree below hParent
//

BOOL IsFolderShortcut(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    CLSID clsid = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID;
    fcs.pclsid = &clsid;

    if (SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_READ)))
    {
        return IsEqualGUID(&clsid, &CLSID_FolderShortcut);
    }
    return FALSE;
}

void FillFolder(HWND hwndTree, LPTSTR lpszCurDir, UINT cchCurDir, LPTSTR lpszExclude,
                    HTREEITEM hParent, DWORD dwFlags)
{
    int     iStrTerm = lstrlen(lpszCurDir);
    WIN32_FIND_DATA fd;
    HANDLE  hfind;
    HTREEITEM hNewItem = NULL;
    #define bAddFiles (dwFlags & FFF_AddFiles)
    #define bAddDirs  (dwFlags & FFF_AddDirs)

    StringCchCat(lpszCurDir, cchCurDir, TEXT("\\*.*"));

    hfind = FindFirstFile(lpszCurDir, &fd);

    if (hfind != INVALID_HANDLE_VALUE)
    {
        do
        {
            BOOL bIsDir = (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

            if (((bAddFiles && !bIsDir) ||
                // skip "." and ".." and hidden files
                (bAddDirs && bIsDir && (fd.cFileName[0] != TEXT('.')))) &&
                !(fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                lpszCurDir[iStrTerm] = TEXT('\\');
                lstrcpy(lpszCurDir + iStrTerm + 1, fd.cFileName);

                // let's fudge it -- if it's a folder shortcut, don't treat it
                // like a real folder, since we can't navigate into it anyway
                // and it's not worth the trouble to try.
                if (bIsDir && IsFolderShortcut(lpszCurDir))
                {
                    bIsDir = FALSE;
                }

                //
                // Don't add this if it's supposed to be excluded
                //

                if (!lpszExclude || !bIsDir ||
                    lstrcmpi(lpszExclude, lpszCurDir) != 0)
                {
                    hNewItem = AddItem(hwndTree, lpszCurDir, hParent, NULL,
                                        FIDFLAG_CANADDNEW | FIDFLAG_CANDEL |
                                        (bIsDir ? FIDFLAG_ISFOLDER : 0));
                    if (bIsDir)
                    {
                        FillFolder(hwndTree, lpszCurDir, cchCurDir, NULL,
                                   hNewItem, dwFlags);
                    }
                }
            }
        } while (FindNextFile(hfind, &fd));

        FindClose(hfind);
    }

    lpszCurDir[iStrTerm] = 0;

    //
    //  Non-null if any items added to folder.
    //

    if (hNewItem)
    {
        SortFolder(hwndTree, hParent);
        if (!bAddFiles)
        {
            TreeView_Expand(hwndTree, hParent, TVE_EXPAND);
        }
    }
    #undef  bAddFiles
    #undef  bRecurse
}


//
//  Returns a pointer to the directory string for the currently selected
//  item.
//

LPFILEITEMDATA GetCurSel(HWND hwndTree, HTREEITEM * lphtiSel)
{
    TV_ITEM  tvi;

    tvi.hItem = TreeView_GetSelection(hwndTree);

    if (lphtiSel)
    {
        *lphtiSel = tvi.hItem;
    }

    if (tvi.hItem == NULL)
    {
        return(NULL);
    }

    tvi.mask = TVIF_PARAM;
    TreeView_GetItem(hwndTree, &tvi);

    return((LPFILEITEMDATA)tvi.lParam);
}


//
//  Add the specified special folder..
//

HTREEITEM AddSpecialFolder(HWND hwndTree, HTREEITEM htiParent, int nFolder,
                           LPTSTR pszPath, DWORD dwFlags)
{
    LPITEMIDLIST pidl = NULL;
    HTREEITEM    hti = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hwndTree, nFolder, &pidl)))
    {
        if (SHGetPathFromIDList(pidl, pszPath))
        {
            //
            //  For the desktop, we want the desktop directory, but the icon
            //  for the magic desktop PIDL.
            //
            if (nFolder == CSIDL_DESKTOPDIRECTORY)
            {
                SHFree(pidl);
                if (FAILED(SHGetSpecialFolderLocation(hwndTree, CSIDL_DESKTOP, &pidl)))
                {
                    pidl = NULL;
                }
            }

            if (NULL != pidl)
            {
                hti = AddItem(hwndTree, pszPath, htiParent, pidl,
                              FIDFLAG_ISFOLDER | dwFlags);
            }
        }
    }
    if (NULL != pidl)
    {
        SHFree(pidl);
    }
    return(hti);
}


BOOL _inline MakePrgIcon0Index(HWND hwndTree, HIMAGELIST himl)
{
    LPITEMIDLIST pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hwndTree, CSIDL_PROGRAMS, &pidl)))
    {
        SHFILEINFO   fi;
        BOOL_PTR fOk = SHGetFileInfo( (LPTSTR) pidl, 0, &fi, sizeof( fi ),
                                      SHGFI_ICON | SHGFI_SMALLICON | SHGFI_PIDL );

        SHFree( pidl );
        
        if (fOk)
        {
            ImageList_AddIcon(himl, fi.hIcon);
            DestroyIcon(fi.hIcon);
            return(TRUE);
        }
    }
    return FALSE;
}


//
//  Initialize the tree
//

void InitFolderTree( HWND hwndTree, BOOL bAddFiles, HIMAGELIST *phiml )
{
    HCURSOR    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HTREEITEM  htiStart = NULL;
    HTREEITEM  htiPrgs = NULL;
    TCHAR      szPathStart[MAX_PATH];
    TCHAR      szPathPrgs[MAX_PATH];
    UINT       flags = ILC_MASK | ILC_COLOR32;
    HIMAGELIST himl;
    
    if(IS_WINDOW_RTL_MIRRORED(hwndTree))
    {
        flags |= ILC_MIRROR;
    }
    himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                       GetSystemMetrics(SM_CYSMICON),
                                       flags, 10, 1);

    if (phiml)
        *phiml = himl;

    if (!himl)
    {
        return;
    }

    TreeView_SetImageList(hwndTree, himl, TVSIL_NORMAL);

    //
    // Add the programs folder as index 0.  All sub-folders of programs
    // will also have the same icon.  This saves both memory and time.
    //

    if (!MakePrgIcon0Index(hwndTree, himl))
    {
        return;
    }

    if (!bAddFiles)
    {
        AddSpecialFolder(hwndTree, TVI_ROOT, CSIDL_DESKTOPDIRECTORY, szPathStart, 0);
    }

    htiStart = AddSpecialFolder(hwndTree, TVI_ROOT, CSIDL_STARTMENU, szPathStart, FIDFLAG_CANADDNEW);

    if (htiStart)
    {
        htiPrgs = AddSpecialFolder(hwndTree, htiStart, CSIDL_PROGRAMS, szPathPrgs, FIDFLAG_CANADDNEW | FIDFLAG_ISPROGS);
        if (htiPrgs)
        {
            FillFolder(hwndTree, szPathPrgs, ARRAYSIZE(szPathPrgs), NULL, htiPrgs,
                       FFF_AddDirs | (bAddFiles ? FFF_AddFiles : 0));
            //
            // Now fill in the rest of the start menu, excluding programs
            //

            FillFolder(hwndTree, szPathStart, ARRAYSIZE(szPathStart), szPathPrgs, htiStart,
                       FFF_AddDirs | (bAddFiles ? FFF_AddFiles : 0));
        }
    }

    //
    // Now select and expand the programs folder.
    //

    if (htiPrgs)
    {
        TreeView_SelectItem(hwndTree, htiPrgs);
        if (bAddFiles)
        {
            TreeView_Expand(hwndTree, htiPrgs, TVE_EXPAND);
        }
    }
    SetCursor(hcurOld);
}


//
//  Delete Selected Item
//

VOID RemoveSelItem(HWND hDlg, HWND hwndTree)
{
    HTREEITEM hCur;
    LPFILEITEMDATA lpfid = GetCurSel(hwndTree, &hCur);

    if (!lpfid)
    {
        ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_NONESEL),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        if (lpfid->dwFlags & FIDFLAG_CANDEL)
        {
            TCHAR szFileDblNull[MAX_PATH+1];

            SHFILEOPSTRUCT sFileOp =
            {
                hDlg,
                FO_DELETE,
                szFileDblNull,
                NULL,
                (lpfid->dwFlags & FIDFLAG_ISFOLDER) ?
                FOF_ALLOWUNDO :
                FOF_SILENT | FOF_ALLOWUNDO,
            };

            StringCchCopy(szFileDblNull, ARRAYSIZE(szFileDblNull), lpfid->szPath);

            szFileDblNull[lstrlen(szFileDblNull)+1] = 0;

            if (!SHFileOperation(&sFileOp))
            {
                if (!(sFileOp.fAnyOperationsAborted))
                {
                    TreeView_DeleteItem(hwndTree, hCur);
                }
            }

        }
        else
        {
            ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_CANTDELETE),
                            0, MB_OK | MB_ICONEXCLAMATION, PathFindFileName(lpfid->szPath));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//  END SHARED CODE.  BEGIN WIZARD SPECIFIC CODE.
/////////////////////////////////////////////////////////////////////////////


//
//  Returns -1 if no item is selected, otherwise, sets lpwd->lpszFolder
//  to point to the appropriate string, and returns 0.
//

LPARAM PickFolderNextHit(LPWIZDATA lpwd)
{
    LPFILEITEMDATA lpfid = GetCurSel(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), NULL);

    if (lpfid)
    {
        lpwd->lpszFolder = (LPTSTR)&(lpfid->szPath);
        lpwd->szProgDesc[0] = 0;
        return(0);
    }
    else
    {
        return(-1);
    }
}


//
//  Creates a new, empty folder.
//

VOID CreateNewFolder(LPWIZDATA lpwd)
{
    TCHAR          szNewName[MAX_PATH];
    HTREEITEM      hParent;
    LPFILEITEMDATA lpfidParent = GetCurSel(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), &hParent);

    if (lpfidParent && (lpfidParent->dwFlags & FIDFLAG_CANADDNEW))
    {
        int   iDirLen = lstrlen(lpfidParent->szPath);
        TCHAR szNewShort[10];
        TCHAR szNewLong[80];

        LoadString(g_hinst, IDS_NEWFOLDERSHORT, szNewShort, ARRAYSIZE(szNewShort));
        LoadString(g_hinst, IDS_NEWFOLDERLONG, szNewLong, ARRAYSIZE(szNewLong));

        PathMakeUniqueName(szNewName, ARRAYSIZE(szNewName),
                           szNewShort, szNewLong, lpfidParent->szPath);
        if (CreateDirectory(szNewName, NULL))
        {
            HWND    hwndTree = GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE);
            HTREEITEM hNewDude = AddItem(hwndTree, szNewName, hParent, NULL,
                              FIDFLAG_ISFOLDER | FIDFLAG_CANADDNEW | FIDFLAG_CANDEL);

            if (hNewDude == NULL)
            {
                TraceMsg(TF_ERROR, "%s", "Unable to add new folder to tree.");
            }

            if (hNewDude)
            {
                SortFolder(hwndTree, hParent);
                TreeView_SelectItem(hwndTree, hNewDude);
                TreeView_EditLabel(hwndTree, hNewDude);
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "%s", "Unable to create new directory");
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "%s", "No group selected.  Can't create directory.");
    }
}


//
//  Begin editing a tree label.  This function returns FALSE for success, and
//  TRUE for failure.
//

BOOL BeginEdit(LPWIZDATA lpwd, TV_DISPINFO * lptvdi)
{
    if (TreeView_GetParent(lptvdi->hdr.hwndFrom, lptvdi->item.hItem))
    {
        lpwd->dwFlags |= WDFLAG_INEDITMODE;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//
//  Return FALSE if rename can't happen.  True if it worked.
//

BOOL EndEdit(LPWIZDATA lpwd, TV_DISPINFO * lptvdi)
{
    BOOL bWorked = FALSE;
    #define lpszNewName (LPTSTR)lptvdi->item.pszText
    #define lpfidOld ((LPFILEITEMDATA)(lptvdi->item.lParam))
    #define hCurItem lptvdi->item.hItem;

    lpwd->dwFlags &= ~WDFLAG_INEDITMODE;

    if (lpszNewName)
    {
        int cchPath = MAX_PATH;
        LPFILEITEMDATA lpfidNew = (LPFILEITEMDATA)LocalAlloc(LMEM_FIXED,
                                   sizeof(LPFILEITEMDATA)+ (cchPath*sizeof(TCHAR)) );

        if (lpfidNew)
        {
            lpfidNew->dwFlags = lpfidOld->dwFlags;

            StringCchCopy(lpfidNew->szPath, cchPath, lpfidOld->szPath);

            PathRemoveFileSpec(lpfidNew->szPath);

            PathCleanupSpec(lpfidNew->szPath, lpszNewName);

            if ( PathCombine(lpfidNew->szPath, lpfidNew->szPath, lpszNewName) && 
                 MoveFile(lpfidOld->szPath, lpfidNew->szPath) )
            {
                TV_ITEM tvi;
                tvi.hItem = hCurItem;
                tvi.mask = TVIF_PARAM;
                tvi.lParam = (LPARAM)lpfidNew;
                TreeView_SetItem(lptvdi->hdr.hwndFrom, &tvi);
                bWorked = TRUE;
            }
            else
            {
                TraceMsg(TF_ERROR, "%s", "Unable to rename directory");
            }
            LocalFree(bWorked ? lpfidOld : lpfidNew);
        }
    }

    return(bWorked);

    #undef lpszNewName
    #undef lpfidOld
    #undef hCurItem
}


//
//  Called when Next or Back is hit to force the end of label editing.
//

void ForceEndEdit(LPWIZDATA lpwd)
{
    if (lpwd->dwFlags & WDFLAG_INEDITMODE)
    {
        TreeView_EndEditLabelNow(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), FALSE);
    }
}


void FillInItem(TV_DISPINFO * ptvdi)
{
    SHFILEINFO fi;

    #define lpfid ((LPFILEITEMDATA)(ptvdi->item.lParam))
    if (SHGetFileInfo(lpfid->szPath, 0, &fi, sizeof(fi),
                      SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_SMALLICON))
    {
        if (ptvdi->item.mask & TVIF_IMAGE)
        {
            ptvdi->item.iImage = ptvdi->item.iSelectedImage =
                  ImageList_AddIcon(TreeView_GetImageList(ptvdi->hdr.hwndFrom, TVSIL_NORMAL),
                                    fi.hIcon);
            ptvdi->item.mask |= TVIF_SELECTEDIMAGE;
        }

        if (ptvdi->item.mask & TVIF_TEXT)
        {
            StringCchCopy(ptvdi->item.pszText, ptvdi->item.cchTextMax, fi.szDisplayName);
        }

        DestroyIcon(fi.hIcon);

        ptvdi->item.mask |= TVIF_DI_SETITEM;
    }
}



//
//  Main dialog procedure for tree of folders
//

BOOL_PTR CALLBACK PickFolderDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            if (lpwd->dwFlags & WDFLAG_LINKHEREWIZ)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                lpwd->hwnd = hDlg;
                                PropSheet_SetWizButtons(GetParent(hDlg),
                                                        (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE) ?
                                                          PSWIZB_NEXT : PSWIZB_BACK | PSWIZB_NEXT);

                                PostMessage(hDlg, WMPRIV_POKEFOCUS, 0, 0);
                            }
                        }
                        break;

                    case PSN_WIZBACK:
                        if(lpwd)
                        {
                            ForceEndEdit(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            ForceEndEdit(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, PickFolderNextHit(lpwd));
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    case NM_DBLCLK:
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                        break;

                    #define lpfidNew ((LPFILEITEMDATA)(((LPNM_TREEVIEW)lParam)->itemNew.lParam))

                    case TVN_SELCHANGED:
                        Button_Enable(GetDlgItem(hDlg, IDC_NEWFOLDER),
                                      (lpfidNew->dwFlags & FIDFLAG_CANADDNEW));
                        break;
                    #undef lpfidNew

                    #define lptvdi ((TV_DISPINFO *)lParam)

                    case TVN_BEGINLABELEDIT:
                        if(lpwd)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, BeginEdit(lpwd, lptvdi));
                        }
                        break;

                    case TVN_ENDLABELEDIT:
                        if(lpwd)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, EndEdit(lpwd, lptvdi));
                        }
                        break;
                    #undef lptvdi

                    #define lptvn ((LPNM_TREEVIEW)lParam)

                    case TVN_ITEMEXPANDING:
                        if (lptvn->action != TVE_EXPAND)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                        }
                        break;

                    case TVN_DELETEITEM:
                        if (lptvn->itemOld.lParam)
                        {
                            LocalFree((LPVOID)lptvn->itemOld.lParam);
                        }
                        break;
                    #undef lptvn

                    case TVN_GETDISPINFO:
                        FillInItem(((TV_DISPINFO *)lParam));
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            lpwd = InitWizSheet(hDlg, lParam, 0);
            if(lpwd)
            {
                lpwd->himl = NULL;

                if( !( lpwd->dwFlags & WDFLAG_LINKHEREWIZ ) )
                {
                    InitFolderTree( GetDlgItem( hDlg, IDC_FOLDERTREE ),
                                    FALSE, &lpwd->himl );
                }
            }
            break;


        case WM_NCDESTROY:
            //
            //  See if we should destroy the himl...
            //

            if(lpwd)
            {
                if (lpwd->himl)
                {
                    ImageList_Destroy(lpwd->himl);
                    lpwd->himl = NULL;  // make sure not twice
                }
            }
            return FALSE;


        case WMPRIV_POKEFOCUS:
            SetFocus(GetDlgItem(hDlg, IDC_FOLDERTREE));
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_NEWFOLDER:
                    if(lpwd)
                    {
                        CreateNewFolder(lpwd);
                    }
                    break;

             ///   case IDC_DELFOLDER:
             ///   {
             ///       HWND    hTree = GetDlgItem(hDlg, IDC_FOLDERTREE);
             ///       RemoveSelItem(hDlg, hTree);
             ///       SetFocus(hTree);
             ///       break;
             ///   }
            }

        default:
            return FALSE;

    }
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
//  END WIZARD SPECIFIC CODE.  BEGIN DELETE ITEM DIALOG CODE.
/////////////////////////////////////////////////////////////////////////////

typedef struct _FOLDERTHREADINFO {
    HANDLE     hThread;
    HWND       hwndTree;
    HIMAGELIST himl;
} FOLDERTHREADINFO, * PFOLDERTHREADINFO;


void CALLBACK FolderEnumItems(PFOLDERTHREADINFO pfti, HTREEITEM hParent)
{
    HTREEITEM hitem;

    hitem = hParent;
    while (hitem && pfti->hThread)
    {
        TV_ITEM tvi;
        tvi.mask  = TVIF_IMAGE;
        tvi.hItem = hitem;
        TreeView_GetItem(pfti->hwndTree, &tvi);
        hitem = TreeView_GetNextSibling(pfti->hwndTree, hitem);
    }

    hitem = TreeView_GetChild(pfti->hwndTree, hParent);

    while (hitem && pfti->hThread)
    {
        FolderEnumItems(pfti, hitem);
        hitem = TreeView_GetNextSibling(pfti->hwndTree, hitem);
    }
}


DWORD CALLBACK FolderThread(PFOLDERTHREADINFO pfti)
{
    HANDLE hThread = pfti->hThread;

    FolderEnumItems(pfti, TreeView_GetRoot(pfti->hwndTree));

    CloseHandle(hThread);

    pfti->hThread = 0;

    return 0;
}


VOID CreateFolderThread(PFOLDERTHREADINFO pfti)
{
    //
    // Create background thread to force list view to draw items
    //

    DWORD idThread;

    if (pfti->hThread)
    {
        return;
    }

    pfti->hThread = CreateThread(NULL, 0, FolderThread, pfti, 0, &idThread);

    if(pfti->hThread)
    {
        SetThreadPriority(pfti->hThread, THREAD_PRIORITY_BELOW_NORMAL);
    }
}


//
//  Main dialog procedure for delete items dialog.
//

const static DWORD aDelItemHelpIDs[] = {  // Context Help IDs
    IDC_TEXT,         NO_HELP,
    IDC_FOLDERTREE,   IDH_TRAY_REMOVEDLG_LIST,
    IDC_DELETEITEM,   IDH_TRAY_REMOVEDLG_DEL,

    0, 0
};

void WaitForThreadToFinish(HWND hDlg, FOLDERTHREADINFO *pfti)
{
    if (pfti->hThread)
    {
        SHProcessSentMessagesUntilEvent(hDlg, pfti->hThread, 10000);
        CloseHandle(pfti->hThread);
        pfti->hThread = NULL;
    }
}

BOOL_PTR CALLBACK DelItemDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    PFOLDERTHREADINFO pfti = (PFOLDERTHREADINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_NOTIFY:
            #define lpnm ((NMHDR *)lParam)

            switch(lpnm->code)
            {
                #define lpfidNew ((LPFILEITEMDATA)(((LPNM_TREEVIEW)lParam)->itemNew.lParam))

                case TVN_SELCHANGED:
                {
                    BOOL fCanDel = (lpfidNew->dwFlags & FIDFLAG_CANDEL);
                    HWND hwndDelItem = GetDlgItem(hDlg, IDC_DELETEITEM);

                    if ((!fCanDel) && (GetFocus() == hwndDelItem))
                    {
                        SetFocus(GetDlgItem(hDlg, IDOK));
                        SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                    }
                    Button_Enable(hwndDelItem, fCanDel);
                    break;
                }

                #undef lpfidNew

                #define lptvn ((LPNM_TREEVIEW)lParam)

                case TVN_DELETEITEM:
                    if (lptvn->itemOld.lParam)
                    {
                        LocalFree((LPVOID)lptvn->itemOld.lParam);
                    }
                    break;

                #undef lptvn

                #define lptkd ((TV_KEYDOWN *)lParam)

                case TVN_KEYDOWN:
                    if (lptkd->wVKey == VK_DELETE)
                    {
                        WaitForThreadToFinish(hDlg, pfti);
                        RemoveSelItem(hDlg, GetDlgItem(hDlg, IDC_FOLDERTREE));
                        CreateFolderThread(pfti);
                        return TRUE;
                    }
                    break;

                #undef lptkd

                case TVN_GETDISPINFO:
                    FillInItem(((TV_DISPINFO *)lParam));
                    break;

                default:
                    return FALSE;

            #undef lpnm
            }
            break;

        case WM_INITDIALOG:

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pfti = (PFOLDERTHREADINFO)lParam;

            InitFolderTree(GetDlgItem(hDlg, IDC_FOLDERTREE), TRUE, &pfti->himl);

            pfti->hwndTree = GetDlgItem(hDlg, IDC_FOLDERTREE);
            pfti->hThread = 0;

            CreateFolderThread(pfti);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aDelItemHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aDelItemHelpIDs);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    WaitForThreadToFinish(hDlg, pfti);                    
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                case IDC_DELETEITEM:
                    WaitForThreadToFinish(hDlg, pfti);                    
                    
                    RemoveSelItem(hDlg, GetDlgItem(hDlg, IDC_FOLDERTREE));
                    CreateFolderThread(pfti);
                    break;
            }

        default:
            return FALSE;

    }
    return TRUE;
}


BOOL RemoveItemsDialog( HWND hParent )
{
    BOOL fReturn;

    FOLDERTHREADINFO fti;

    fti.himl = NULL;    // incase we can not create the window

    fReturn = (int)DialogBoxParam( g_hinst, MAKEINTRESOURCE( DLG_DELITEM ),
                                   hParent, DelItemDlgProc, (LPARAM) &fti );

    if( fti.himl )
        ImageList_Destroy( fti.himl );

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\gettitle.c ===
//
//  GetTitle.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"


//
//  Enables the appropriate buttons depending upon the state of the
//  description edit control and what type of shortcut we're trying to
//  make.
//

void EnableNextFinish(LPWIZDATA lpwd)
{
    DWORD dwEnable = PSWIZB_BACK;
    if (GetWindowTextLength(GetDlgItem(lpwd->hwnd, IDC_TITLE)) > 0)
    {
        //
        //  If this is a "known" application then enalble finish, else next.
        //

        dwEnable |= (lpwd->dwFlags & (WDFLAG_APPKNOWN | WDFLAG_COPYLINK)) ?
                                           PSWIZB_FINISH : PSWIZB_NEXT;
    }
    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), dwEnable);
}


//
//  Called from PSN_SETACTIVE.        Assumes lpwd->hwnd already initialized.
//

void GetTitleSetActive(LPWIZDATA lpwd)
{
    //
    // Most of the code to process this was moved into the Next button
    // processing of the previous page as there were some failure cases
    // that we could not get a title that we should detect before we
    // allow the user to change to this page...  HOWEVER, there are some
    // cases where we can't determine the name until we get to this page.
    // If we don't have a name for the sortcut, try to figure one out here.
    //

    if (lpwd->szProgDesc[0] == 0)
    {
        DetermineDefaultTitle(lpwd);
    }

    SetDlgItemText(lpwd->hwnd, IDC_TITLE, lpwd->szProgDesc);
    EnableNextFinish(lpwd);
    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}


//
//  Check to see if link name is a duplicate.  If it is then ask the user
//  if they want to replace the old link.  If they say "no" then this function
//  returns FALSE.
//

BOOL GetTitleNextPushed(LPWIZDATA lpwd)
{
    TCHAR szLinkName[MAX_PATH];

    GetDlgItemText(lpwd->hwnd, IDC_TITLE, lpwd->szProgDesc, ARRAYSIZE(lpwd->szProgDesc));
    if (lpwd->szProgDesc[0] == 0)
    {
        return(FALSE);
    }

    if( ( PathCleanupSpec( lpwd->lpszFolder, lpwd->szProgDesc ) != 0 ) ||
        !GetLinkName( szLinkName, ARRAYSIZE(szLinkName), lpwd ) )
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_MODNAME),
                        0, MB_OK | MB_ICONEXCLAMATION);
        return(FALSE);
    }

    if (PathFileExists(szLinkName))
    {
        //
        //  Obscure boundary case.  If we're creating a new link and the user
        //  happens to want to name it exactly it's current name then we'll let
        //  them do it without a warning.
        //

        if (lpwd->lpszOriginalName && lstrcmpi(lpwd->lpszOriginalName, szLinkName) == 0)
        {
            TraceMsg(TF_ERROR, "%s", "Unbelieveable!  User selected exactly the same name");
            return(TRUE);
        }
        return(IDYES == ShellMessageBox(g_hinst, lpwd->hwnd,
                                    MAKEINTRESOURCE(IDS_DUPLINK), 0,
                                    MB_YESNO | MB_DEFBUTTON1 | MB_ICONHAND,
                                    lpwd->szProgDesc));
    }
    return(TRUE);
}


//
//  Dialog procedure for title dialog
//
BOOL_PTR CALLBACK GetTitleDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            GetTitleSetActive(lpwd);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!GetTitleNextPushed(lpwd))
                            {
                                GetTitleSetActive(lpwd);
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            int        iResult = -1;

                            if (GetTitleNextPushed(lpwd))
                            {
                                if (CreateLink(lpwd))
                                {
                                    iResult = 0;
                                }
                            }
                            if (iResult != 0)
                            {
                                GetTitleSetActive(lpwd);
                            }
                            SetDlgMsgResult(hDlg, WM_NOTIFY, iResult);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            lpwd = InitWizSheet(hDlg, lParam, 0);
            if(lpwd)
            {
                Edit_LimitText(GetDlgItem(hDlg, IDC_TITLE), ARRAYSIZE(lpwd->szProgDesc)-1);
            }
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hTitle = GetDlgItem(hDlg, IDC_TITLE);
            SetFocus(hTitle);
            Edit_SetSel(hTitle, 0, -1);
            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                        break;

                case IDC_TITLE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                EnableNextFinish(lpwd);
                            }
                            break;
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;

}  // GetTitleDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\instapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instapp.cpp
//
// Installed applications 
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"
#include "instapp.h"
#include "sccls.h"
#include "util.h"
#include "findapp.h"
#include "tasks.h"
#include "slowfind.h"
#include "appsize.h"
#include "appwizid.h"
#include "resource.h"
#include "uemapp.h"

const TCHAR c_szInstall[]  = TEXT("Software\\Installer\\Products\\%s");
const TCHAR c_szTSInstallMode[]  = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Change User Option");
const TCHAR c_szUpdateInfo[] = TEXT("URLUpdateInfo");
const TCHAR c_szSlowInfoCache[] = TEXT("SlowInfoCache");
const TCHAR c_szRegstrARPCache[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\ARPCache");


#ifdef WX86
EXTERN_C BOOL bWx86Enabled;
EXTERN_C BOOL bForceX86Env;
#endif

#include <tsappcmp.h>       // for TermsrvAppInstallMode
#include "scripts.h"
#include <winsta.h>         // WinStation* APIs
#include <allproc.h>        // TS_COUNTER
#include <msginaexports.h>  // ShellIsMultipleUsersEnabled, ShellSwitchUser


#define APPACTION_STANDARD  (APPACTION_UNINSTALL | APPACTION_MODIFY | APPACTION_REPAIR)
// overloaded constructor (for legacy apps)
CInstalledApp::CInstalledApp(HKEY hkeySub, LPCTSTR pszKeyName, LPCTSTR pszProduct, LPCTSTR pszUninstall, DWORD dwCIA) : _cRef(1), _dwSource(IA_LEGACY), _dwCIA(dwCIA), _guid(GUID_NULL)
{
    DWORD dwType;
    ULONG cbModify;
    LONG lRet;
        
    ASSERT(IS_VALID_HANDLE(hkeySub, KEY));
    ASSERT(_bTriedToFindFolder == FALSE);

    TraceAddRef(CInstalledApp, _cRef);

    DllAddRef();
    
    TraceMsg(TF_INSTAPP, "(CInstalledApp) Legacy App Created key name = %s, product name = %s, uninstall string = %s",
             pszKeyName, pszProduct, pszUninstall);
    StringCchCopy(_szKeyName, ARRAYSIZE(_szKeyName), pszKeyName);
    InsertSpaceBeforeVersion(_szKeyName, _szCleanedKeyName);
    
    StringCchCopy(_szProduct, ARRAYSIZE(_szProduct), pszProduct);
#ifdef FULL_DEBUG
    if (_dwCIA & CIA_ALT)
    {
        StringCchCat(_szProduct, ARRAYSIZE(_szProduct), TEXT(" (32-bit)"));
    }
#endif
    StringCchCopy(_szUninstall, ARRAYSIZE(_szUninstall), pszUninstall);

    DWORD dwActionBlocked = _QueryBlockedActions(hkeySub);
    if (dwActionBlocked != 0)
    {
        // NoRemove, NoModify, or NoRepair has been specified 
        _dwAction |= APPACTION_STANDARD & (~dwActionBlocked);
    }
    else
    {
        // Start with the basics.  For legacy apps, we assume they don't distinguish between
        // modify and remove functions.
        _dwAction |= APPACTION_MODIFYREMOVE;
    }
    
    // If there is no "uninstall" key, we could try to find other hints as where
    // this app lives, if we could find that hint, as the uninstall process, we could
    // just delete that directory and the registry entry.

    // What if we find no hints at all? Should we just delete this thing from the
    // registry?
    if (!(dwActionBlocked & APPACTION_UNINSTALL) && _szUninstall[0])
        _dwAction |= APPACTION_UNINSTALL;

    // Does this app have an explicit modify path?
    cbModify = SIZEOF(_szModifyPath);
    lRet = SHQueryValueEx(hkeySub, TEXT("ModifyPath"), 0, &dwType, (PBYTE)_szModifyPath, &cbModify);
    if ((ERROR_SUCCESS == lRet) && (TEXT('\0') != _szModifyPath[0]))
    {
        // Yes; remove the legacy modify/remove combination.
        _dwAction &= ~APPACTION_MODIFYREMOVE;

        // Does policy prevent this?
        if (!(dwActionBlocked & APPACTION_MODIFY))
            _dwAction |= APPACTION_MODIFY;          // No
    }
    
    _GetInstallLocationFromRegistry(hkeySub);
    _GetUpdateUrl();
    RegCloseKey(hkeySub);
}


// overloaded constructor (for darwin apps)
CInstalledApp::CInstalledApp(LPTSTR pszProductID) : _cRef(1), _dwSource(IA_DARWIN), _guid(GUID_NULL)
{
    ASSERT(_bTriedToFindFolder == FALSE);

    TraceAddRef(CInstalledApp, _cRef);

    DllAddRef();
    
    TraceMsg(TF_INSTAPP, "(CInstalledApp) Darwin app created product name = %s", pszProductID);
    StringCchCopy(_szProductID, ARRAYSIZE(_szProductID), pszProductID);

    // Get the information from the ProductId
    ULONG cchProduct = ARRAYSIZE(_szProduct);
    MsiGetProductInfo(pszProductID, INSTALLPROPERTY_PRODUCTNAME, _szProduct, &cchProduct);

    BOOL bMachineAssigned = FALSE;
    
    // For Machine Assigned Darwin Apps, only admins should be allowed
    // to modify the app
    if (!IsUserAnAdmin())
    {
        TCHAR szAT[5];
        DWORD cchAT = ARRAYSIZE(szAT);

        // NOTE: according to chetanp, the first character of szAT should be "0" or "1"
        // '0' means it's user assigned, '1' means it's machine assigned
        if ((ERROR_SUCCESS == MsiGetProductInfo(pszProductID, INSTALLPROPERTY_ASSIGNMENTTYPE,
                                               szAT, &cchAT))
            && (szAT[0] == TEXT('1')))
            bMachineAssigned = TRUE;
    }    

    // Query the install state and separate the cases where this app is
    // installed on the machine or assigned...
    // In the assigned case we allow only Uninstall operation. 
    if (INSTALLSTATE_ADVERTISED == MsiQueryProductState(pszProductID))
    {   
        _dwAction |= APPACTION_UNINSTALL;
    }
    else
    {
        DWORD dwActionBlocked = 0;
        HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);
        if (hkeySub)
        {
            dwActionBlocked = _QueryBlockedActions(hkeySub);
            _GetInstallLocationFromRegistry(hkeySub);
            RegCloseKey(hkeySub);
            if (bMachineAssigned)
                _dwAction |= APPACTION_REPAIR & (~dwActionBlocked);
            else
            {
                _dwAction |= APPACTION_STANDARD & (~dwActionBlocked);
                _GetUpdateUrl();
            }
        }
    }
}


// destructor
CInstalledApp::~CInstalledApp()
{
    if (_pszUpdateUrl)
    {
        ASSERT(_dwSource & IA_DARWIN);
        LocalFree(_pszUpdateUrl);
    }

    DllRelease();
}



// The UpdateUrl info is optional for both Darwin and Legacy apps. 
void CInstalledApp::_GetUpdateUrl()
{
    TCHAR szInstall[MAX_PATH];
    HKEY hkeyInstall;
    StringCchPrintf(szInstall, ARRAYSIZE(szInstall), c_szInstall, _szProductID);
    if (RegOpenKeyEx(_MyHkeyRoot(), szInstall, 0, KEY_READ, &hkeyInstall) == ERROR_SUCCESS)
    {
        ULONG cbUrl;
        if (SHQueryValueEx(hkeyInstall, c_szUpdateInfo, NULL, NULL, NULL, &cbUrl) == ERROR_SUCCESS)
        {
            _pszUpdateUrl = (LPTSTR) LocalAlloc(LPTR, cbUrl);
            if (ERROR_SUCCESS != SHQueryValueEx(hkeyInstall, TEXT(""), NULL, NULL, (PBYTE)_pszUpdateUrl, &cbUrl))
            {
                LocalFree(_pszUpdateUrl);
                _pszUpdateUrl = NULL;
            }
            else
                _dwAction |= APPACTION_UPGRADE;
        }
        RegCloseKey(hkeyInstall);
    }
}

// Queries policy restrictions on the action info
DWORD CInstalledApp::_QueryActionBlockInfo(HKEY hkey)
{
    DWORD dwRet = 0;
    DWORD dwType = 0;
    DWORD dwData = 0;
    ULONG cbData = SIZEOF(dwData);
    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoRemove"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_UNINSTALL;

    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoModify"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_MODIFY;

    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoRepair"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_REPAIR;

    return dwRet;
}

DWORD CInstalledApp::_QueryBlockedActions(HKEY hkey)
{
    DWORD dwRet = _QueryActionBlockInfo(hkey);
    
    if (dwRet != APPACTION_STANDARD)
    {
        HKEY hkeyPolicy = _OpenRelatedRegKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), KEY_READ, FALSE);
        if (hkeyPolicy)
        {
            dwRet |= _QueryActionBlockInfo(hkeyPolicy);
            RegCloseKey(hkeyPolicy);
        }
    }

    return dwRet;
}

void CInstalledApp::_GetInstallLocationFromRegistry(HKEY hkeySub)
{
    DWORD dwType;
    ULONG cbInstallLocation = SIZEOF(_szInstallLocation);
    LONG lRet = SHQueryValueEx(hkeySub, TEXT("InstallLocation"), 0, &dwType, (PBYTE)_szInstallLocation, &cbInstallLocation);
    PathUnquoteSpaces(_szInstallLocation);
    
    if (lRet == ERROR_SUCCESS)
    {
        ASSERT(IS_VALID_STRING_PTR(_szInstallLocation, -1));
        _dwAction |= APPACTION_CANGETSIZE;
    }
}


HKEY CInstalledApp::_OpenRelatedRegKey(HKEY hkey, LPCTSTR pszRegLoc, REGSAM samDesired, BOOL bCreate)
{
    HKEY hkeySub = NULL;
    LONG lRet;
    
    TCHAR szRegKey[MAX_PATH];

    RIP (pszRegLoc);
    
    // For Darwin apps, use the ProductID as the key name
    LPTSTR pszKeyName = (_dwSource & IA_DARWIN) ? _szProductID : _szKeyName;
    StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), pszRegLoc, pszKeyName, ARRAYSIZE(szRegKey));
    
    // Open this key in the registry
    lRet = RegOpenKeyEx(hkey, szRegKey, 0, samDesired, &hkeySub);
    if (bCreate && (lRet == ERROR_FILE_NOT_FOUND))
    {
        lRet = RegCreateKeyEx(hkey, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, samDesired,
                              NULL, &hkeySub, NULL);
    }

    if (lRet != ERROR_SUCCESS)
        hkeySub = NULL;

    return hkeySub;
}


HKEY CInstalledApp::_OpenUninstallRegKey(REGSAM samDesired)
{
    LPCTSTR pszSubkey = (_dwCIA & CIA_ALT) ? REGSTR_PATH_ALTUNINSTALL : REGSTR_PATH_UNINSTALL;
    return _OpenRelatedRegKey(_MyHkeyRoot(), pszSubkey, samDesired, FALSE);
}

// Helper function to query the registry for legacy app info strings
LPWSTR CInstalledApp::_GetLegacyInfoString(HKEY hkeySub, LPTSTR pszInfoName)
{
    DWORD cbSize;
    DWORD dwType;
    LPWSTR pwszInfo = NULL;
    if (SHQueryValueEx(hkeySub, pszInfoName, 0, &dwType, NULL, &cbSize) == ERROR_SUCCESS)
    {
        LPTSTR pszInfoT = (LPTSTR)LocalAlloc(LPTR, cbSize);
        if (pszInfoT && (SHQueryValueEx(hkeySub, pszInfoName, 0, &dwType, (PBYTE)pszInfoT, &cbSize) == ERROR_SUCCESS))
        {
            if ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))
            {
                if (FAILED(SHStrDup(pszInfoT, &pwszInfo)))
                {
                    ASSERT(pwszInfo == NULL);
                }

                // For the "DisplayIcon" case, we need to make sure the path of
                // the icon actually exists.
                if (pwszInfo && !lstrcmp(pszInfoName, TEXT("DisplayIcon")))
                {
                    PathParseIconLocation(pszInfoT);
                    if (!PathFileExists(pszInfoT))
                    {
                        SHFree(pwszInfo);
                        pwszInfo = NULL;
                    }
                }
                    
            }
            LocalFree(pszInfoT);
        }
    }

    return pwszInfo;
}

// IShellApps::GetAppInfo
STDMETHODIMP CInstalledApp::GetAppInfo(PAPPINFODATA pai)
{
    ASSERT(pai);
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return E_FAIL;
    
    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    // We cache the product name in all cases(Legacy, Darwin, SMS). 
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDup(_szProduct, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }

    if (dwInfoFlags & ~AIM_DISPLAYNAME)
    {
        HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);
        if (hkeySub != NULL)
        {
            const static struct {
                DWORD dwBit;
                LPTSTR szRegText;
                DWORD ibOffset;
            } s_rgInitAppInfo[] = {
                //
                // WARNING: If you add a new field that is not an LPWSTR type,
                // revisit the loop below.  It only knows about LPWSTR.
                //
                {AIM_VERSION,         TEXT("DisplayVersion"),   FIELD_OFFSET(APPINFODATA, pszVersion)   },
                {AIM_PUBLISHER,       TEXT("Publisher"),        FIELD_OFFSET(APPINFODATA, pszPublisher) },
                {AIM_PRODUCTID,       TEXT("ProductID"),        FIELD_OFFSET(APPINFODATA, pszProductID) },
                {AIM_REGISTEREDOWNER,  TEXT("RegOwner"),        FIELD_OFFSET(APPINFODATA, pszRegisteredOwner) },
                {AIM_REGISTEREDCOMPANY, TEXT("RegCompany"),     FIELD_OFFSET(APPINFODATA, pszRegisteredCompany) },
                {AIM_SUPPORTURL,      TEXT("UrlInfoAbout"),     FIELD_OFFSET(APPINFODATA, pszSupportUrl) },
                {AIM_SUPPORTTELEPHONE,TEXT("HelpTelephone"),    FIELD_OFFSET(APPINFODATA, pszSupportTelephone) },
                {AIM_HELPLINK,        TEXT("HelpLink"),         FIELD_OFFSET(APPINFODATA, pszHelpLink) },
                {AIM_INSTALLLOCATION, TEXT("InstallLocation"),  FIELD_OFFSET(APPINFODATA, pszInstallLocation) },
                {AIM_INSTALLSOURCE,   TEXT("InstallSource"),    FIELD_OFFSET(APPINFODATA, pszInstallSource) },
                {AIM_INSTALLDATE,     TEXT("InstallDate"),      FIELD_OFFSET(APPINFODATA, pszInstallDate) },
                {AIM_CONTACT,         TEXT("Contact"),          FIELD_OFFSET(APPINFODATA, pszContact) },
                {AIM_COMMENTS,        TEXT("Comments"),         FIELD_OFFSET(APPINFODATA, pszComments) },
                {AIM_IMAGE,           TEXT("DisplayIcon"),      FIELD_OFFSET(APPINFODATA, pszImage) },
                {AIM_READMEURL,       TEXT("Readme"),           FIELD_OFFSET(APPINFODATA, pszReadmeUrl) },
                {AIM_UPDATEINFOURL,   TEXT("UrlUpdateInfo"),    FIELD_OFFSET(APPINFODATA, pszUpdateInfoUrl) },
                };

            ASSERT(IS_VALID_HANDLE(hkeySub, KEY));

            int i;
            for (i = 0; i < ARRAYSIZE(s_rgInitAppInfo); i++)
            {
                if (dwInfoFlags & s_rgInitAppInfo[i].dwBit)
                {
                    LPWSTR pszInfo = _GetLegacyInfoString(hkeySub, s_rgInitAppInfo[i].szRegText);
                    if (pszInfo)
                    {
                        // We are assuming each field is a LPWSTR.
                        LPBYTE pbField = (LPBYTE)pai + s_rgInitAppInfo[i].ibOffset;
                        
                        pai->dwMask |= s_rgInitAppInfo[i].dwBit;
                        *(LPWSTR *)pbField = pszInfo;
                    }
                }
            }    

            // If we want a image path but did not get it, and we are a darwin app
            if ((dwInfoFlags & AIM_IMAGE) && !(pai->dwMask & AIM_IMAGE) && (_dwSource & IA_DARWIN))
            {
                TCHAR szProductIcon[MAX_PATH*2];
                DWORD cchProductIcon = ARRAYSIZE(szProductIcon);
                // Okay, call Darwin to get the image
                if ((ERROR_SUCCESS == MsiGetProductInfo(_szProductID, INSTALLPROPERTY_PRODUCTICON, szProductIcon, &cchProductIcon))
                    && szProductIcon[0])
                {
                    // Expand any embedded environment strings while copying
                    // to return buffer.
                    TCHAR szTemp[1];
                    int cchExp = ExpandEnvironmentStrings(szProductIcon, szTemp, ARRAYSIZE(szTemp));
                    pai->pszImage = (TCHAR *)CoTaskMemAlloc(cchExp * sizeof(TCHAR));
                    if (NULL != pai->pszImage)
                    {
                        ExpandEnvironmentStrings(szProductIcon, pai->pszImage, cchExp);
                        pai->dwMask |= AIM_IMAGE;
                    }
                }
            }

            RegCloseKey(hkeySub);
        }
    }

    // Software installation policy settings can override the default display name
    // and help link url which are authored into a windows installer package.
    if ( (_dwSource & IA_DARWIN) && (dwInfoFlags & (AIM_DISPLAYNAME | AIM_HELPLINK)) )
    {
        LPWSTR  pwszDisplayName = 0;
        LPWSTR  pwszSupportUrl = 0;

        GetLocalManagedApplicationData( _szProductID, &pwszDisplayName, &pwszSupportUrl ); 
        
        if ( pwszDisplayName && (dwInfoFlags & AIM_DISPLAYNAME) )
        {
            LPWSTR  pwszNewDisplayName;

            if ( SUCCEEDED(SHStrDup(pwszDisplayName, &pwszNewDisplayName)) )
            {
                if ( pai->dwMask & AIM_DISPLAYNAME )
                    SHFree( pai->pszDisplayName );

                pai->pszDisplayName = pwszNewDisplayName;
                pai->dwMask |= AIM_DISPLAYNAME;
            }
        }

        if ( pwszSupportUrl && (dwInfoFlags & AIM_HELPLINK) )
        {
            LPWSTR  pwszNewHelpLink;

            if ( SUCCEEDED(SHStrDup(pwszSupportUrl, &pwszNewHelpLink)) )
            {
                if ( pai->dwMask & AIM_HELPLINK )
                    SHFree( pai->pszHelpLink );

                pai->pszHelpLink = pwszNewHelpLink;
                pai->dwMask |= AIM_HELPLINK;
            }
        }

        LocalFree( pwszDisplayName );
        LocalFree( pwszSupportUrl );
    }

    TraceMsg(TF_INSTAPP, "(CInstalledApp) GetAppInfo with %x but got %x", dwInfoFlags, pai->dwMask);
    
    return S_OK;
}


// IShellApps::GetPossibleActions
STDMETHODIMP CInstalledApp::GetPossibleActions(DWORD * pdwActions)
{
    ASSERT(IS_VALID_WRITE_PTR(pdwActions, DWORD));
    *pdwActions = _dwAction;
    return S_OK;
}

/*-------------------------------------------------------------------------
Purpose: This method finds the application folder for this app.  If a
         possible folder is found, it is stored in the _szInstallLocation
         member variable.

         Returns TRUE if a possible path is found.
*/
BOOL CInstalledApp::_FindAppFolderFromStrings()
{
    TraceMsg(TF_INSTAPP, "(CInstalledApp) FindAppFolderFromStrings ---- %s  %s  %s  %s",
            _szProduct, _szCleanedKeyName, _szUninstall, _szModifyPath);

    // Try to determine from the "installlocation", "uninstall", or "modify"
    // regvalues.
    
    // Say we have tried
    _bTriedToFindFolder = TRUE;

    // First try out the location string, this is most likely to give us some thing
    // and probably is the correct location for logo 5 apps. 
    if (_dwAction & APPACTION_CANGETSIZE)
    {
        if (!IsValidAppFolderLocation(_szInstallLocation))
        {
            // We got bad location string from the registry, set it to empty string
            _dwAction &= ~APPACTION_CANGETSIZE;
            _szInstallLocation[0] = 0;
        }
        else
            // The string from the registry is fine
            return TRUE;
    }
    
    // We didn't have a location string or failed to get anything from it.
    // logo 3 apps are typically this case...
    LPTSTR pszShortName  = (_dwSource & IA_LEGACY) ? _szCleanedKeyName : NULL;
    TCHAR  szFolder[MAX_PATH];
    
    // Let's take a look at the uninstall string, 2nd most likely to give hints
    if ((_dwAction & APPACTION_UNINSTALL) &&
        (ParseInfoString(_szUninstall, _szProduct, pszShortName, szFolder)))
    {
        // remember this string and set the Action bit to get size
        StringCchCopy(_szInstallLocation, ARRAYSIZE(_szInstallLocation), szFolder);
        _dwAction |= APPACTION_CANGETSIZE;
        return TRUE;
    }

    // Now try the modify string
    if ((_dwAction & APPACTION_MODIFY) &&
        (ParseInfoString(_szModifyPath, _szProduct, pszShortName, szFolder)))
    {
        // remember this string and set the Action bit to get size
        StringCchCopy(_szInstallLocation, ARRAYSIZE(_szInstallLocation), szFolder);
        _dwAction |= APPACTION_CANGETSIZE;
        return TRUE;
    }

    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: Persists the slow app info under the "uninstall" key in the registry
         EX: HKLM\\...\\Uninstall\\Word\\ARPCache 
         Returns S_OK if successfully saved it to the registry
         E_FAIL if failed. 
*/
HRESULT CInstalledApp::_PersistSlowAppInfo(PSLOWAPPINFO psai)
{
    HRESULT hres = E_FAIL;
    ASSERT(psai);
    HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_SET_VALUE, TRUE);
    if (hkeyARPCache)
    {
        PERSISTSLOWINFO psi = {0};
        DWORD dwType = 0;
        DWORD cbSize = SIZEOF(psi);
        // Read in the old cached info, and try to preserve the DisplayIcon path
        // Note if the PERSISTSLOWINFO structure is not what we are looking for, we
        // ignore the old icon path. 
        if ((ERROR_SUCCESS != RegQueryValueEx(hkeyARPCache, c_szSlowInfoCache, 0, &dwType, (LPBYTE)&psi, &cbSize))
            || (psi.dwSize != SIZEOF(psi)))
            ZeroMemory(&psi, SIZEOF(psi));
        
        psi.dwSize = SIZEOF(psi);
        psi.ullSize = psai->ullSize;
        psi.ftLastUsed = psai->ftLastUsed;
        psi.iTimesUsed = psai->iTimesUsed;
        
        if (!(psi.dwMasks & PERSISTSLOWINFO_IMAGE) && psai->pszImage && psai->pszImage[0])
        {
            psi.dwMasks |= PERSISTSLOWINFO_IMAGE;
            StringCchCopy(psi.szImage, ARRAYSIZE(psi.szImage), psai->pszImage);
        }

        if (RegSetValueEx(hkeyARPCache, c_szSlowInfoCache, 0, REG_BINARY, (LPBYTE)&psi, sizeof(psi)) == ERROR_SUCCESS)
            hres = S_OK;

        _SetSlowAppInfoChanged(hkeyARPCache, 0);
        RegCloseKey(hkeyARPCache);
    }    
    return hres;
}



/*-------------------------------------------------------------------------
Purpose: _SetSlowAppInfoChanged

         Set in the registry that this app has been changed. 
*/
HRESULT CInstalledApp::_SetSlowAppInfoChanged(HKEY hkeyARPCache, DWORD dwValue)
{
    HRESULT hres = E_FAIL;
    BOOL bNewKey = FALSE;
    if (!hkeyARPCache)
    {
        hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
        if (hkeyARPCache)
            bNewKey = TRUE;
    }
    
    if (hkeyARPCache)
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkeyARPCache, TEXT("Changed"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue)))
            hres = S_OK;

        if (bNewKey)
            RegCloseKey(hkeyARPCache);
    }

    return hres;
}

// IShellApps::GetSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::_IsSlowAppInfoChanged

         Retrieve whether the slow app info has been changed from the registry
*/
HRESULT CInstalledApp::_IsSlowAppInfoChanged()
{
    HRESULT hres = S_FALSE;
    HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
    if (hkeyARPCache)
    {
        DWORD dwValue;
        DWORD dwType;
        DWORD cbSize = SIZEOF(dwValue);
        if (ERROR_SUCCESS == SHQueryValueEx(hkeyARPCache, TEXT("Changed"), 0, &dwType, &dwValue, &cbSize)
            && (dwType == REG_DWORD) && (dwValue == 1))
            hres = S_OK;

        RegCloseKey(hkeyARPCache);
    }
    else
        hres = S_OK;
    return hres;
}

BOOL CInstalledApp::_GetDarwinAppSize(ULONGLONG * pullTotal)
{
    BOOL bRet = FALSE;
    HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);

    RIP(pullTotal);
    *pullTotal = 0;
    if (hkeySub)
    {
        DWORD dwSize = 0;
        DWORD dwType = 0;
        DWORD cbSize = SIZEOF(dwSize);

        if (ERROR_SUCCESS == SHQueryValueEx(hkeySub, TEXT("EstimatedSize"), 0, &dwType, &dwSize, &cbSize)
            && (dwType == REG_DWORD))
        {
            // NOTE: EstimatedSize is in "kb"
            *pullTotal = dwSize * 1024;
            bRet = TRUE;
        }

        RegCloseKey(hkeySub);
    }
    
    return bRet;
}

// IShellApps::GetSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::GetSlowAppInfo

         Gets the appinfo that may take awhile.  This includes the amount
         of diskspace that the app might take up, etc.

         Returns S_OK if some valid info was obtained.  S_FALSE is returned
         if nothing useful was found.  Errors may be returned as well.
*/
STDMETHODIMP CInstalledApp::GetSlowAppInfo(PSLOWAPPINFO psai)
{
    HRESULT hres = E_INVALIDARG;
    if (psai)
    {
        // Is this an app that we know we can't get info for?
        // In this case this is a darwin app that has not changed
        BOOL bFoundFolder = FALSE;
        LPCTSTR pszShortName = NULL;
        BOOL bSlowAppInfoChanged = (S_OK == _IsSlowAppInfoChanged());

        // Nothing should have changed except for the usage info, so get the cached one first
        if (FAILED(GetCachedSlowAppInfo(psai)))
        {
            ZeroMemory(psai, sizeof(*psai));
            psai->iTimesUsed = -1;
            psai->ullSize = (ULONGLONG) -1;
        }

        // No; have we tried to determine this app's installation location?    
        switch (_dwSource) {
            case IA_LEGACY:
            {
                if (!_bTriedToFindFolder)
                {
                    // No; try to find out now
                    BOOL bRet = _FindAppFolderFromStrings();
                    if (bRet)
                        TraceMsg(TF_ALWAYS, "(CInstalledApp) App Folder Found %s --- %s", _szProduct, _szInstallLocation);
                    else
                    {
                        ASSERT(!(_dwAction & APPACTION_CANGETSIZE));
                        ASSERT(_szInstallLocation[0] == 0);
                    }
                }

                pszShortName = _szCleanedKeyName;

                bFoundFolder = _dwAction & APPACTION_CANGETSIZE;
                if (!bFoundFolder) 
                    bFoundFolder = SlowFindAppFolder(_szProduct, pszShortName, _szInstallLocation);
            }
            break;

            case IA_DARWIN:
            {                    
                if (bSlowAppInfoChanged)
                {
                    // Can we get the Darwin app size?
                    if (!_GetDarwinAppSize(&psai->ullSize))
                        // No, let's set it back to the default value
                        psai->ullSize = (ULONGLONG) -1;
                }

                // Get the "times used" info from UEM
                UEMINFO uei = {0};
                uei.cbSize = SIZEOF(uei);
                uei.dwMask = UEIM_HIT | UEIM_FILETIME;
                if(SUCCEEDED(UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1, (LPARAM)_szProductID, &uei)))
                {
                    // Is there a change to the times used?
                    if (uei.cHit > psai->iTimesUsed)
                    {
                        // Yes, then overwrite the times used field 
                        psai->iTimesUsed = uei.cHit;
                    }

                    if (CompareFileTime(&(uei.ftExecute), &psai->ftLastUsed) > 0)
                        psai->ftLastUsed = uei.ftExecute;
                }
            }   
            break;

            default:
                break;
        }

        LPCTSTR pszInstallLocation = bFoundFolder ? _szInstallLocation : NULL; 
        hres = FindAppInfo(pszInstallLocation, _szProduct, pszShortName, psai, bSlowAppInfoChanged);
        _PersistSlowAppInfo(psai);
    }
    return hres;
}

// IShellApps::GetCachedSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::GetCachedSlowAppInfo

         Gets the cached appinfo, to get the real info might take a while

         Returns S_OK if some valid info was obtained.
         Returns E_FAIL if can't find the cached info. 
*/
STDMETHODIMP CInstalledApp::GetCachedSlowAppInfo(PSLOWAPPINFO psai)
{
    HRESULT hres = E_FAIL;
    if (psai)
    {
        ZeroMemory(psai, sizeof(*psai));
        HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
        if (hkeyARPCache)
        {
            PERSISTSLOWINFO psi = {0};
            DWORD dwType;
            DWORD cbSize = SIZEOF(psi);
            if ((RegQueryValueEx(hkeyARPCache, c_szSlowInfoCache, 0, &dwType, (LPBYTE)&psi, &cbSize) == ERROR_SUCCESS)
                && (psi.dwSize == SIZEOF(psi)))
            {
                psai->ullSize = psi.ullSize;
                psai->ftLastUsed = psi.ftLastUsed;
                psai->iTimesUsed = psi.iTimesUsed;
                if (psi.dwMasks & PERSISTSLOWINFO_IMAGE)
                    SHStrDupW(psi.szImage, &psai->pszImage);
                hres = S_OK;
            } 
            RegCloseKey(hkeyARPCache);
        }
    }
        return hres;
}


// IShellApp::IsInstalled
STDMETHODIMP CInstalledApp::IsInstalled()
{
    HRESULT hres = S_FALSE;

    switch (_dwSource)
    {
        case IA_LEGACY:
        {
            // First Let's see if the reg key is still there
            HKEY hkey = _OpenUninstallRegKey(KEY_READ);
            if (hkey)
            {
                // Second we check the "DisplayName" and the "UninstallString"
                LPWSTR pszName = _GetLegacyInfoString(hkey, REGSTR_VAL_UNINSTALLER_DISPLAYNAME);
                if (pszName)
                {
                    if (pszName[0])
                    {
                        LPWSTR pszUninstall = _GetLegacyInfoString(hkey, REGSTR_VAL_UNINSTALLER_COMMANDLINE);
                        if (pszUninstall)
                        {
                            if (pszUninstall[0])
                                hres = S_OK;

                            SHFree(pszUninstall);
                        }
                    }

                    SHFree(pszName);
                }
                RegCloseKey(hkey);
            }
        }
        break;

        case IA_DARWIN:
            if (MsiQueryProductState(_szProductID) == INSTALLSTATE_DEFAULT)
                hres = S_OK;
            break;

        case IA_SMS:
            break;

        default:
            break;
    }

    return hres;

}



/*-------------------------------------------------------------------------
Purpose: Creates a process and waits for it to finish
*/
STDAPI_(BOOL) CreateAndWaitForProcess(LPTSTR pszExeName)
{
    return NT5_CreateAndWaitForProcess(pszExeName);
}


// Returns FALSE if "pszPath" contains a network app that can not be accessed
// TRUE for all other pathes
BOOL PathIsNetAndCreatable(LPCTSTR pszPath, LPTSTR pszErrExe, UINT cchErrExe)
{
    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    BOOL bRet = TRUE;
    TCHAR szExe[MAX_PATH];
    lstrcpyn(szExe, pszPath, ARRAYSIZE(szExe));
    LPTSTR pSpace = PathGetArgs(szExe);
    if (pSpace)
        *pSpace = 0;
    
    if (!PathIsLocalAndFixed(szExe))
        bRet = PathFileExists(szExe);

    if (!bRet)
    {
        lstrcpyn(pszErrExe, szExe, cchErrExe);
    }
    
    return bRet;
}

EXTERN_C BOOL BrowseForExe(HWND hwnd, LPTSTR pszName, DWORD cchName,
                                   LPCTSTR pszInitDir);
/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
BOOL_PTR CALLBACK NewUninstallProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    LPTSTR pszExe = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
    switch (msg)
    {
    case WM_INITDIALOG:
        RIP (lp);
        if (lp != NULL)
        {
            pszExe = (LPTSTR)lp;
            SetWindowText(GetDlgItem(hDlg, IDC_TEXT), pszExe);
            pszExe[0] = 0;
            SetWindowLongPtr(hDlg, DWLP_USER, lp);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        ASSERT(pszExe);
        RIP (lp);
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDC_BROWSE:
            if (BrowseForExe(hDlg, pszExe, MAX_PATH, NULL))
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), pszExe);
            break;
            
        case IDOK:
            // NOTE: we are assuming the size of the buffer is at least MAX_PATH
            GetDlgItemText(hDlg, IDC_COMMAND, pszExe, MAX_PATH);

        case IDCANCEL:
            EndDialog(hDlg, (GET_WM_COMMAND_ID(wp, lp) == IDOK));
            break;


        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// Assumes pszExePath is of size MAX_PATH
int GetNewUninstallProgram(HWND hwndParent, LPTSTR pszExePath, DWORD cchExePath)
{
    int iRet = 0;
    RIP(pszExePath);
    if (cchExePath >= MAX_PATH)
    {
        iRet = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_UNCUNINSTALLBROWSE),
                              hwndParent, NewUninstallProc, (LPARAM)(int *)pszExePath);
    }

    return iRet;
}

// CreateProcess the app modification of uninstall process
BOOL CInstalledApp::_CreateAppModifyProcessNative(HWND hwndParent, LPTSTR pszExePath)
{
    BOOL bRet = FALSE;
    TCHAR szModifiedExePath[MAX_PATH + MAX_INFO_STRING];

    // PPCF_LONGESTPOSSIBLE does not exist on down level platforms
    if (0 >= PathProcessCommand( pszExePath, szModifiedExePath,
                                 ARRAYSIZE(szModifiedExePath), PPCF_ADDQUOTES | PPCF_NODIRECTORIES | PPCF_LONGESTPOSSIBLE) )
    {
        StringCchCopy(szModifiedExePath, ARRAYSIZE(szModifiedExePath), pszExePath);
    }

    TCHAR szErrExe[MAX_PATH];
    if (!PathIsNetAndCreatable(szModifiedExePath, szErrExe, ARRAYSIZE(szErrExe)))
    {
        TCHAR szExplain[MAX_PATH];
        LoadString(g_hinst, IDS_UNINSTALL_UNCUNACCESSIBLE, szExplain, ARRAYSIZE(szExplain));

        StringCchPrintf(szModifiedExePath, ARRAYSIZE(szModifiedExePath), szExplain, _szProduct, szErrExe, ARRAYSIZE(szModifiedExePath));
        if (!GetNewUninstallProgram(hwndParent, szModifiedExePath, ARRAYSIZE(szModifiedExePath))) 
            return FALSE;
    }
    
    bRet = CreateAndWaitForProcess(szModifiedExePath);
    if (!bRet)
    {
        if (ShellMessageBox( HINST_THISDLL, hwndParent, MAKEINTRESOURCE( IDS_UNINSTALL_FAILED ),
                             MAKEINTRESOURCE( IDS_UNINSTALL_ERROR ),
                             MB_YESNO | MB_ICONEXCLAMATION, _szProduct, _szProduct) == IDYES)
        {
            // If we are unable to uninstall the app, give the user the option of removing
            // it from the Add/Remove programs list.  Note that we only know an uninstall
            // has failed if we are unable to execute its command line in the registry.  This
            // won't cover all possible failed uninstalls.  InstallShield, for instance, passes
            // an uninstall path to a generic C:\WINDOWS\UNINST.EXE application.  If an
            // InstallShield app has been blown away, UNINST will still launch sucessfully, but
            // will bomb out when it can't find the path, and we have no way of knowing it failed
            // because it always returns an exit code of zero.
            // A future work item (which I doubt will ever be done) would be to investigate
            // various installer apps and see if any of them do return error codes that we could
            // use to be better at detecting failure cases.
            HKEY hkUninstall;
            if (RegOpenKeyEx(_MyHkeyRoot(), REGSTR_PATH_UNINSTALL, 0, KEY_WRITE, &hkUninstall) == ERROR_SUCCESS)
            {
                if (ERROR_SUCCESS == SHDeleteKey(hkUninstall, _szKeyName))
                    bRet = TRUE;
                else
                {
                    ShellMessageBox( HINST_THISDLL, hwndParent, MAKEINTRESOURCE( IDS_CANT_REMOVE_FROM_REGISTRY ),
                                     MAKEINTRESOURCE( IDS_UNINSTALL_ERROR ),
                                     MB_OK | MB_ICONEXCLAMATION, _szProduct);
                }
                RegCloseKey(hkUninstall);
            }
        }
    }
    return bRet;
}

// CreateProcess the app modification of uninstall process
BOOL CInstalledApp::_CreateAppModifyProcess(HWND hwndParent, DWORD dwCAMP)
{
    if (_dwCIA & CIA_ALT)
    {
        return _CreateAppModifyProcessWow64(hwndParent, dwCAMP);
    }
    else
    {
        switch (dwCAMP)
        {
        case CAMP_UNINSTALL:
            return _CreateAppModifyProcessNative(hwndParent, _szUninstall);
        case CAMP_MODIFY:
            return _CreateAppModifyProcessNative(hwndParent, _szModifyPath);
        }
        return FALSE;
    }
}

//
//  Command line to the rundll32 is
//
//  %SystemRoot%\SysWOW64\rundll32.exe %SystemRoot%\SysWOW64\appwiz.cpl,
//      WOW64Uninstall_RunDLL,<hwnd>,<CIA>,<CAMP>,<KeyName>
//
//  The KeyName must come last because it might contain a comma.
//
//
BOOL CInstalledApp::_CreateAppModifyProcessWow64(HWND hwndParent, DWORD dwCAMP)
{
    TCHAR szSysWow64[MAX_PATH];
    TCHAR szRundll32[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH * 2];
    BOOL fSuccess = FALSE;

    if (GetWindowsDirectory(szSysWow64, ARRAYSIZE(szSysWow64)) &&
        PathAppend(szSysWow64, TEXT("SysWOW64")))
    {
        StringCchPrintf(szRundll32, ARRAYSIZE(szRundll32), TEXT("%s\\rundll32.exe"), szSysWow64);
        StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine),
                  TEXT("\"%s\" \"%s\\appwiz.cpl\",WOW64Uninstall_RunDLL %d,%d,%d,%s"),
                  szRundll32, szSysWow64, hwndParent, _dwCIA, dwCAMP, _szKeyName);
        STARTUPINFO si = { 0 };
        si.cb = sizeof(si);
        PROCESS_INFORMATION pi;
        if (CreateProcess(szRundll32, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            SHProcessMessagesUntilEvent(NULL, pi.hProcess, INFINITE);
            DWORD dwExitCode;
            if (GetExitCodeProcess(pi.hProcess, &dwExitCode) && dwExitCode == 0)
            {
                fSuccess = TRUE;
            }
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }

    return fSuccess;
}

//  Helper function for command line parsing...

int _ParseCmdLineIntegerAndComma(LPWSTR *ppwsz)
{
    LPWSTR psz = *ppwsz;
    if (!psz)
    {
        return -1;
    }

    int i = StrToInt(psz);
    psz = StrChr(psz, TEXT(','));
    if (!psz)
    {
        *ppwsz = NULL;
        return -1;
    }
    *ppwsz = psz + 1;
    return i;
}

//
//  Special export that the 64-bit version of appwiz uses to force an app
//  uninstaller to run in 32-bit mode.
//
//  Command line arguments are as described above.

STDAPI_(void) WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    BOOL fSuccess = FALSE;
    HWND hwndParent = (HWND)IntToPtr(_ParseCmdLineIntegerAndComma(&lpszCmdLine));
    int dwCIA = _ParseCmdLineIntegerAndComma(&lpszCmdLine);
    int dwCAMP = _ParseCmdLineIntegerAndComma(&lpszCmdLine);

    if (lpszCmdLine && *lpszCmdLine)
    {
        dwCIA &= ~CIA_ALT; // We *are* the alternate platform

        HKEY hkRoot = (dwCIA & CIA_CU) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
        HKEY hkSub;
        TCHAR szBuf[MAX_PATH];
        TCHAR szName[MAX_PATH];
        // Note: This is running on the 32-bit side so we don't use ALT
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\\%s"), REGSTR_PATH_UNINSTALL, lpszCmdLine);
        if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot, szBuf, 0, KEY_READ, &hkSub))
        {
            DWORD cb;
            szBuf[0] = 0;
            cb = SIZEOF(szBuf);
            SHQueryValueEx(hkSub, REGSTR_VAL_UNINSTALLER_COMMANDLINE, 0, NULL, (PBYTE)szBuf, &cb);

            szName[0] = 0;
            cb = SIZEOF(szName);
            SHQueryValueEx(hkSub, REGSTR_VAL_UNINSTALLER_DISPLAYNAME, 0, NULL, (PBYTE)szName, &cb);

            CInstalledApp * pia = new CInstalledApp(hkSub, lpszCmdLine, szName, szBuf, dwCIA);
            if (pia)
            {
                fSuccess = pia->_CreateAppModifyProcess(hwndParent, dwCAMP);
                pia->Release();
            }

            RegCloseKey(hkSub);
        }
    }

    // Let my parent regain foreground activation now that I'm finished
    DWORD dwPid;
    if (GetWindowThreadProcessId(hwndParent, &dwPid))
    {
        AllowSetForegroundWindow(dwPid);
    }

    // Return 0 on success, 1 on failure (exit codes are like that)
    ExitProcess(!fSuccess);
}

// Uinstalls legacy apps
BOOL CInstalledApp::_LegacyUninstall(HWND hwndParent)
{
    LPVOID pAppScripts = ScriptManagerInitScripts();

    BOOL bRet = FALSE;
    if (_dwAction & APPACTION_UNINSTALL)
        bRet = _CreateAppModifyProcess(hwndParent, CAMP_UNINSTALL);

    if(pAppScripts)
    {
        ScriptManagerRunScripts(&pAppScripts);
    }

    return bRet;
}

DWORD _QueryTSInstallMode(LPTSTR pszKeyName)
{
    // NOTE: Terminal Server guys confirmed this, when this value is 0, it means
    // we were installed in install mode. 1 means not installed in "Install Mode"

    // Set default to "install mode"
    DWORD dwVal = 0;
    DWORD dwValSize = SIZEOF(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szTSInstallMode, pszKeyName,
                                   NULL, &dwVal, &dwValSize))
    {
        dwVal = 0;
    }
    
    return dwVal;
}


void _MyShow(HWND hwndParent, int idControl, BOOL fShow)
{
    HWND hwndChild = GetDlgItem(hwndParent, idControl);
    if (NULL != hwndChild)
    {
        ShowWindow(hwndChild, fShow ? SW_SHOW : SW_HIDE);
        EnableWindow(hwndChild, fShow);
    }
}

BOOL_PTR CALLBACK _MultiUserWarningProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(hDlg, IDC_ICON_WARNING, STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_WARNING), 0);
        if (IsOS(OS_ANYSERVER))
        {
            // Switch User is only valid on client (FUS)
            _MyShow(hDlg, IDC_SWITCHUSER, FALSE);
            _MyShow(hDlg, IDC_SWITCHUSER_TEXT, FALSE);
        }
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDC_SWITCHUSER:
            ShellSwitchUser(FALSE);
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wp, lp));
            break;
        }
        break;
    }

    return FALSE;
}

int _GetLoggedOnUserCount(void)
{
    int iCount = 0;
    HANDLE hServer;

    //  Open a connection to terminal services and get the number of sessions.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        TS_COUNTER tsCounters[2] = {0};

        tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
        tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

        if (WinStationGetTermSrvCountersValue(hServer, ARRAYSIZE(tsCounters), tsCounters))
        {
            int i;

            for (i = 0; i < ARRAYSIZE(tsCounters); i++)
            {
                if (tsCounters[i].counterHead.bResult)
                {
                    iCount += tsCounters[i].dwValue;
                }
            }
        }

        WinStationCloseServer(hServer);
    }

    return iCount;
}

int _ShowMultiUserWarning(HWND hwndParent)
{
    int iRet = IDOK;

    if (ShellIsMultipleUsersEnabled() && _GetLoggedOnUserCount() > 1)
    {
        iRet = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_MULTIUSERWARNING),
                              hwndParent, _MultiUserWarningProc, 0);
    }

    return iRet;
}


// IInstalledApps::Uninstall
STDMETHODIMP CInstalledApp::Uninstall(HWND hwndParent)
{
    HRESULT hres = E_FAIL;

    if (!_IsAppFastUserSwitchingCompliant() && (IDOK != _ShowMultiUserWarning(hwndParent)))
        return hres;

    // Default to turn install mode off (1 is off)
    DWORD dwTSInstallMode = 1;
    BOOL bPrevMode = FALSE;
    
    if (IsTerminalServicesRunning())
    {
        // On NT,  let Terminal Services know that we are about to uninstall an application.
        dwTSInstallMode = _QueryTSInstallMode((_dwSource & IA_DARWIN) ? _szProductID : _szKeyName);
        if (dwTSInstallMode == 0)
        {
            bPrevMode = TermsrvAppInstallMode();
            SetTermsrvAppInstallMode(TRUE);
        }
    }
    
    switch (_dwSource)
    {
        case IA_LEGACY:
            if (_LegacyUninstall(hwndParent))
                hres = S_OK;
            break;

        case IA_DARWIN:
        {
            TCHAR   szFinal[512], szPrompt[256];

            LoadString(g_hinst, IDS_CONFIRM_REMOVE, szPrompt, ARRAYSIZE(szPrompt));
            StringCchPrintf(szFinal, ARRAYSIZE(szFinal), szPrompt, _szProduct);
            if (ShellMessageBox(g_hinst, hwndParent, szFinal, MAKEINTRESOURCE(IDS_NAME),
                                MB_YESNO | MB_ICONQUESTION, _szProduct, _szProduct) == IDYES)
            {
                LONG lRet;
                INSTALLUILEVEL OldUI = MsiSetInternalUI(INSTALLUILEVEL_BASIC, NULL);
                lRet = MsiConfigureProduct(_szProductID, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
                MsiSetInternalUI(OldUI, NULL);
                hres = HRESULT_FROM_WIN32(lRet);


                // Is this an ophaned assigned app? If so, say we succeeded and call
                // Class Store to remove it. 
                // REARCHITECT: This is too Class Store specific, what if the app is from
                // SMS? 
                if ((lRet == ERROR_INSTALL_SOURCE_ABSENT) &&
                    (INSTALLSTATE_ADVERTISED == MsiQueryProductState(_szProductID)))
                {
                    hres = S_OK;
                    lRet = ERROR_SUCCESS;
                }
                
                // Tell the software installation service  we are uninstalling a Darwin app
                // NOTE: We call this function for every Darwin app, which is not right because
                // some darwin apps could be from a different source, such as SMS, we need a better
                // way to do this. 

                // We call this regardless of failure or success -- this is needed so that
                // RSoP can record both success and failure status for this uninstall
                WCHAR wszProductID[GUIDSTR_MAX];
                StringCchCopy(wszProductID, ARRAYSIZE(wszProductID), _szProductID);

                UninstallApplication(
                    wszProductID,
                    lRet);
  
                if (FAILED(hres))
                {
                    _ARPErrorMessageBox(lRet);
                }

            }
            else
            {
                hres = E_ABORT;      // works for user cancelled
            }
            break;
        }
        
        case IA_SMS:
            break;

        default:
            break;
    }

    // Get rid of the ARP Cache for this app. 
    if (SUCCEEDED(hres))
    {
        HKEY hkeyARPCache;
        if (ERROR_SUCCESS == RegOpenKeyEx(_MyHkeyRoot(), c_szRegstrARPCache, 0, KEY_WRITE, &hkeyARPCache))
        {
            LPTSTR pszKeyName = (_dwSource & IA_DARWIN) ? _szProductID : _szKeyName;
            SHDeleteKey(hkeyARPCache, pszKeyName);
            RegCloseKey(hkeyARPCache);
        }
    }
    
    if (dwTSInstallMode == 0)
        SetTermsrvAppInstallMode(bPrevMode);

    return hres;
}

BOOL CInstalledApp::_LegacyModify(HWND hwndParent)
{
    ASSERT(_dwAction & APPACTION_MODIFY);
    ASSERT(_dwSource & (IA_LEGACY | IA_DARWIN));
//    ASSERT(IS_VALID_STRING_PTR(_szProductID, 39));

    return _CreateAppModifyProcess(hwndParent, CAMP_MODIFY);
}

// IInstalledApps::Modify
STDMETHODIMP CInstalledApp::Modify(HWND hwndParent)
{
    HRESULT hres = E_FAIL;

    if (!_IsAppFastUserSwitchingCompliant() && (IDOK != _ShowMultiUserWarning(hwndParent)))
        return hres;

    // On NT,  let Terminal Services know that we are about to modify an application.
    DWORD dwTSInstallMode = _QueryTSInstallMode((_dwSource & IA_DARWIN) ? _szProductID : _szKeyName);
    BOOL bPrevMode = FALSE;
    if (dwTSInstallMode == 0)
    {
        bPrevMode = TermsrvAppInstallMode();
        SetTermsrvAppInstallMode(TRUE);
    }

    if (_dwAction & APPACTION_MODIFY)
    {
        if ((_dwSource & IA_LEGACY) && _LegacyModify(hwndParent))
            hres = S_OK;
        else if (_dwSource & IA_DARWIN)
        {
            // For modify operations we need to use the FULL UI level to give user
            // more choices
            // NOTE: we are currently not setting this back to the original after the
            // modify operation. This seems to be okay with the Darwin guys
            INSTALLUILEVEL OldUI = MsiSetInternalUI(INSTALLUILEVEL_FULL, NULL);
            LONG lRet = MsiConfigureProduct(_szProductID, INSTALLLEVEL_DEFAULT,
                                            INSTALLSTATE_DEFAULT);
            MsiSetInternalUI(OldUI, NULL);
            hres = HRESULT_FROM_WIN32(lRet);
            if (FAILED(hres))
                _ARPErrorMessageBox(lRet);
            else
                _SetSlowAppInfoChanged(NULL, 1);
        }
    }

    if (dwTSInstallMode == 0)
        SetTermsrvAppInstallMode(bPrevMode);

    return hres;
}

// Repair Darwin apps. 
LONG CInstalledApp::_DarRepair(BOOL bReinstall)
{
    DWORD dwReinstall;

    dwReinstall = REINSTALLMODE_USERDATA | REINSTALLMODE_MACHINEDATA |
                  REINSTALLMODE_SHORTCUT | REINSTALLMODE_FILEOLDERVERSION |
                  REINSTALLMODE_FILEVERIFY | REINSTALLMODE_PACKAGE;
    
    return MsiReinstallProduct(_szProductID, dwReinstall);
}

// IInstalledApps::Repair 
STDMETHODIMP CInstalledApp::Repair(BOOL bReinstall)
{
    HRESULT hres = E_FAIL;
    if (_dwSource & IA_DARWIN)
    {
        LONG lRet = _DarRepair(bReinstall);
        hres = HRESULT_FROM_WIN32(lRet);
        if (FAILED(hres))
            _ARPErrorMessageBox(lRet);
        else
            _SetSlowAppInfoChanged(NULL, 1);
    }
    
    // don't know how to do SMS stuff

    return hres;
}

// IInstalledApp::Upgrade
STDMETHODIMP CInstalledApp::Upgrade()
{
    HRESULT hres = E_FAIL;
    if ((_dwAction & APPACTION_UPGRADE) && (_dwSource & IA_DARWIN))
    {
        ShellExecute(NULL, NULL, _pszUpdateUrl, NULL, NULL, SW_SHOWDEFAULT);
        hres = S_OK;
        _SetSlowAppInfoChanged(NULL, 1);
    }


    return hres;
}

// IInstalledApp::QueryInterface
HRESULT CInstalledApp::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CInstalledApp, IInstalledApp),                  // IID_IInstalledApp
        QITABENTMULTI(CInstalledApp, IShellApp, IInstalledApp),  // IID_IShellApp
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IInstalledApp::AddRef
ULONG CInstalledApp::AddRef()
{
    ULONG cRef = InterlockedIncrement(&_cRef);
    TraceAddRef(CInstalledApp, cRef);
    return cRef;
}

// IInstalledApp::Release
ULONG CInstalledApp::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    TraceRelease(CInstalledApp, cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//
// As of this first release of Windows XP, most applications are 
// not going to be aware of Fast User Switching in the sense that if
// User 'A' is running the application and User 'B' tries to 
// uninstall that application, the application may be damaged.
// To protect against this, we display a warning message informing
// the user of this potential problem.  See function _ShowMultiUserWarning().
// If an application is aware of Fast User Switching, they make that
// indication by setting a registry value in their "Uninstall" key.
// This function queries for that value and returns TRUE/FALSE to indicate
// it's presence.  So that we err on the conservative side, any
// failure to read this value is equivalent to it's absence.
//
BOOL 
CInstalledApp::_IsAppFastUserSwitchingCompliant(
    void
    )
{
    BOOL bCompliant = FALSE;
    HKEY hkey = _OpenUninstallRegKey(KEY_QUERY_VALUE);
    if (NULL != hkey)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbData = sizeof(dwValue);
        DWORD dwResult = RegQueryValueEx(hkey, 
                                         TEXT("FastUserSwitchingCompliant"),
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwValue,
                                         &cbData);
        if (ERROR_SUCCESS == dwResult)
        {
            if (REG_DWORD == dwType)
            {
                if (1 == dwValue)
                {
                    bCompliant = TRUE;
                }
            }
            else
            {
                TraceMsg(TF_ERROR, "FastUserSwitchingCompliant reg value is invalid type (%d).  Expected REG_DWORD.", dwType);
            }
        }
        else if (ERROR_FILE_NOT_FOUND != dwResult)
        {
            TraceMsg(TF_ERROR, "Error %d reading FastUserSwitchingCompliant reg value.", dwResult);
        }
        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error opening application Uninstall reg key");
    }
    return bCompliant;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\instapp.h ===
#ifndef __INSTAPP_H_
#define __INSTAPP_H_

/////////////////////////////////////////////////////////////////////////////
// CInstalledApp

//
//  There are four classes of legacy applications...
//
//  Uninstall keys can go into either HKLM or HKCU, on either the native
//  platform or the alternate platform.
//
//  For Win64, the alternate platform is Win32.
//  For Win32, there is no alternate platform.
//
#define CIA_LM              0x0000
#define CIA_CU              0x0001
#define CIA_NATIVE          0x0000
#define CIA_ALT             0x0002

#define CIA_LM_NATIVE       (CIA_LM | CIA_NATIVE)
#define CIA_CU_NATIVE       (CIA_CU | CIA_NATIVE)
#define CIA_LM_ALT          (CIA_LM | CIA_ALT)
#define CIA_CU_ALT          (CIA_CU | CIA_ALT)

#define REGSTR_PATH_ALTUNINSTALL TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall")

STDAPI_(void) WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

class CInstalledApp : public IInstalledApp
{
public:
    // Constructor for Legacy Apps
    CInstalledApp(HKEY hkeySub, LPCTSTR pszKeyName, LPCTSTR pszProducts, LPCTSTR pszUninstall, DWORD dwCIA);

    // Constructor for Darwin Apps
    CInstalledApp(LPTSTR pszProductID);

    ~CInstalledApp(void);

    // Helper function for SysWOW64 execution
    friend void WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellApp
    STDMETHODIMP GetAppInfo(PAPPINFODATA pai);
    STDMETHODIMP GetPossibleActions(DWORD * pdwActions);
    STDMETHODIMP GetSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP GetCachedSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP IsInstalled(void);
    
    // *** IInstalledApp
    STDMETHODIMP Uninstall(HWND hwndParent);
    STDMETHODIMP Modify(HWND hwndParent);
    STDMETHODIMP Repair(BOOL bReinstall);
    STDMETHODIMP Upgrade(void);
    
protected:

    LONG _cRef;
#define IA_LEGACY     1
#define IA_DARWIN     2
#define IA_SMS        4

    DWORD _dwSource;            // App install source (IA_*)  
    DWORD _dwAction;            // APPACTION_*
    DWORD _dwCIA;               // CIA_*

    // products name
    TCHAR _szProduct[MAX_PATH];

    // action strings 
    TCHAR _szModifyPath[MAX_INFO_STRING];
    TCHAR _szUninstall[MAX_INFO_STRING];

    // info strings
    TCHAR _szInstallLocation[MAX_PATH];

    // for Darwin apps only
    TCHAR _szProductID[GUIDSTR_MAX];
    LPTSTR _pszUpdateUrl;
    
    // for Legacy apps only 
    TCHAR _szKeyName[MAX_PATH];
    TCHAR _szCleanedKeyName[MAX_PATH];
    
    // app size
    BOOL _bTriedToFindFolder;        // TRUE: we have attempted to find the 
                                     //   install folder already

    // GUID identifying this InstalledApp
    GUID _guid;

#define PERSISTSLOWINFO_IMAGE 0x00000001
    // Structure used to persist SLOWAPPINFO
    typedef struct _PersistSlowInfo
    {
        DWORD dwSize;
        DWORD dwMasks;
        ULONGLONG ullSize;
        FILETIME  ftLastUsed;
        int       iTimesUsed;
        WCHAR     szImage[MAX_PATH];
    } PERSISTSLOWINFO;

    HKEY _MyHkeyRoot() { return (_dwCIA & CIA_CU) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE; };
    BOOL _LegacyUninstall(HWND hwndParent);
    BOOL _LegacyModify(HWND hwndParent);
    LONG _DarRepair(BOOL bReinstall);

    HKEY    _OpenRelatedRegKey(HKEY hkey, LPCTSTR pszRegLoc, REGSAM samDesired, BOOL bCreate);
    HKEY    _OpenUninstallRegKey(REGSAM samDesired);
    void    _GetUpdateUrl();
    void    _GetInstallLocationFromRegistry(HKEY hkeySub);
    LPWSTR  _GetLegacyInfoString(HKEY hkeySub, LPTSTR pszInfoName);
    BOOL    _GetDarwinAppSize(ULONGLONG * pullTotal);
    BOOL    _IsAppFastUserSwitchingCompliant(void);
    
    DWORD   _QueryActionBlockInfo(HKEY hkey);
    DWORD   _QueryBlockedActions(HKEY hkey);
            
    BOOL    _FindAppFolderFromStrings();
    HRESULT _DarwinGetAppInfo(DWORD dwInfoFlags, PAPPINFODATA pai);
    HRESULT _LegacyGetAppInfo(DWORD dwInfoFlags, PAPPINFODATA pai);
    HRESULT _PersistSlowAppInfo(PSLOWAPPINFO psai);

#define CAMP_UNINSTALL  0
#define CAMP_MODIFY     1

    BOOL    _CreateAppModifyProcess(HWND hwndParent, DWORD dwCAMP);
    BOOL    _CreateAppModifyProcessWow64(HWND hwndParent, DWORD dwCAMP);
    BOOL    _CreateAppModifyProcessNative(HWND hwndParent, LPTSTR pszExePath);

    HRESULT _SetSlowAppInfoChanged(HKEY hkeyCache, DWORD dwValue);
    HRESULT _IsSlowAppInfoChanged();
};

#endif //__INSTAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc

UI_FILES = \
             $(O)\arp.uipp            \
             $(O)\arpstylestd.uipp    \
             $(O)\arpstyletheme.uipp


..\appwiz.rc : $(UI_FILES) $(SELFREGNAME)

{..}.ui{$(O)}.uipp:
    cl /nologo /EP $(INCPATH0) /I$(WINDOWS_INC_PATH)\DUser $< | perl -pe "s/^^\s+//;s/ +/ /g" > $@

#
# Inference rules
#

.SUFFIXES: .ui .uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\instenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"
#include "instenum.h"
#include "instapp.h"
#include "sccls.h"



// constructor
CEnumInstalledApps::CEnumInstalledApps(void) : _cRef(1), _bEnumLegacy(TRUE), _dwCIA(-1) //_bEnumDarwin(FALSE)
{
    DllAddRef();

    TraceAddRef(CEnumInstalledApps, _cRef);
    
    // Start off enumerating legacy apps, then switch to
    // enumerating darwin apps.
    ASSERT(_hkeyUninstall == NULL);

}


// destructor
CEnumInstalledApps::~CEnumInstalledApps()
{
    if (_hkeyUninstall)
    {
        RegCloseKey(_hkeyUninstall);
        _hkeyUninstall = NULL;
    }

    DllRelease();
}


// IEnumInstalledApps::QueryInterface
HRESULT CEnumInstalledApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CEnumInstalledApps, IEnumInstalledApps),                  // IID_IEnumInstalledApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IUnknown::AddRef
ULONG CEnumInstalledApps::AddRef()
{
    _cRef++;
    TraceAddRef(CEnumInstalledApps, _cRef);
    return _cRef;
}

// IUnknown::Release
ULONG CEnumInstalledApps::Release()
{
    _cRef--;
    TraceRelease(CEnumInstalledApps, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

#define REGSTR_VAL_UNINSTALLER_WINDOWSINSTALLER TEXT("WindowsInstaller")
#define REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT TEXT("SystemComponent")


HRESULT CEnumInstalledApps::_GetNextLegacyAppFromRegistry(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    LONG lRet;
    HKEY hkeySub = NULL;
    TCHAR szKeyName[MAX_PATH];
    DWORD dwType;
    BOOL bTryAgain;

    do
    {
        ULONG cchKeyName = ARRAYSIZE(szKeyName);
        FILETIME ftLast;

        bTryAgain = FALSE;
        
        // Start enumerationg subkeys under _hkeyUninstall
        if (RegEnumKeyEx(_hkeyUninstall, _iIndexEach, szKeyName, &cchKeyName, NULL,
                         NULL, NULL, &ftLast) == ERROR_SUCCESS)
        {
            _iIndexEach++;

            // Open the key and get the subkey name
            lRet = RegOpenKeyEx(_hkeyUninstall, szKeyName, 0, KEY_READ, &hkeySub);
            if (lRet == ERROR_SUCCESS)
            {
                TCHAR szProduct[MAX_PATH];

                // Don't enumerate system components 
                DWORD dwSysComponent = 0;
                DWORD cbSysComponent = SIZEOF(dwSysComponent);
                lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT, 0, &dwType,
                                       (PBYTE)&dwSysComponent, &cbSysComponent); 
                if ((lRet != ERROR_SUCCESS) || (dwSysComponent != 1))
                {
                    // Don't enumerate Darwin apps, who has WindowsInstaller set to 1
                    ULONG uDarwin;
                    ULONG cbDarwin = SIZEOF(uDarwin);
                    lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_WINDOWSINSTALLER, 0, &dwType,
                                          (PBYTE)&uDarwin, &cbDarwin); 
                    if ((lRet != ERROR_SUCCESS) || (uDarwin != 1))
                    {

                        // Get the DisplayName value
                        ULONG cbProductName = SIZEOF(szProduct);
                        lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_DISPLAYNAME, 0, &dwType,
                                              (PBYTE)szProduct, &cbProductName); 
                        if (lRet == ERROR_SUCCESS)
                        {
                            TCHAR szUninstall[MAX_INFO_STRING];

                            // we proceed even if the below SHQueryValueEx fails, so we need
                            // to zero initialize
                            szUninstall[0] = 0;

                            // Get the uninstaller string
                            ULONG cbUninstall = SIZEOF(szUninstall);
                            lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_COMMANDLINE, 0, &dwType, (PBYTE)szUninstall, &cbUninstall);

                            // NOTE: We don't create CInstalledApp Object if there is no "Uninstall" key 
                            // should we just delete this from registry?
                            if (lRet == ERROR_SUCCESS)
                            {
                                // Create new CInstalledApp Object 
                                CInstalledApp * pia = new CInstalledApp(hkeySub, szKeyName, szProduct, szUninstall, _dwCIA);
                                if (pia)
                                {
                                    *ppia = SAFECAST(pia, IInstalledApp *);
                                    hres = S_OK;
                                }
                                else
                                    hres = E_OUTOFMEMORY;
                                break;  // We found an app, return
                            }
                        }
                    }
                }
                
                // In failure cases, go to the next one and try again
                RegCloseKey(hkeySub);
                bTryAgain = TRUE;
                continue;
                
                // (hkeySub is owned and closed by the CInstalledApp object)
            }
        }
        else
        {
            RegCloseKey(_hkeyUninstall);
            _hkeyUninstall = NULL;
        }
    } while (bTryAgain);

    return hres;
}

typedef struct LEGACYAPPREGKEY {
    HKEY hkRoot;
    LPCTSTR pszSubkey;
} LEGACYAPPREGKEY;

const LEGACYAPPREGKEY c_rgLegacy[] = {
    {   HKEY_LOCAL_MACHINE, REGSTR_PATH_UNINSTALL }, // CIA_LM_NATIVE
    {   HKEY_CURRENT_USER,  REGSTR_PATH_UNINSTALL }, // CIA_CU_NATIVE
#ifdef _WIN64
    {   HKEY_LOCAL_MACHINE, REGSTR_PATH_ALTUNINSTALL }, // CIA_LM_ALT
    {   HKEY_CURRENT_USER,  REGSTR_PATH_ALTUNINSTALL }, // CIA_CU_ALT
#endif
};

// Gets the next legacy app from the registry "uninstall" key

HRESULT CEnumInstalledApps::_GetNextLegacyApp(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;

restart:
    // If we don't have an active enumeration key, then try to make a new one
    while (_hkeyUninstall == NULL && ++_dwCIA < ARRAYSIZE(c_rgLegacy))
    {
        _iIndexEach = 0; // restart the RegEnumKey
        RegOpenKeyEx(c_rgLegacy[_dwCIA].hkRoot,
                     c_rgLegacy[_dwCIA].pszSubkey,
                     0, KEY_READ, &_hkeyUninstall);
    }

    if (_hkeyUninstall)
    {
        // Enumerate the next one
        hres = _GetNextLegacyAppFromRegistry(ppia);

        if (hres == S_FALSE)
        {
            // No more from that key, try another one
            // (_GetNextLegacyAppFromRegistry sets _hkeyUninstall = NULL when it returns S_FALSE)
            goto restart;
        }
    }

    return hres;
}


HRESULT CEnumInstalledApps::_GetNextDarwinApp(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    TCHAR szProductID[GUIDSTR_MAX];

    BOOL bContinue;
    do
    {
        bContinue = FALSE;
        
        UINT uRet = TW32(MsiEnumProducts(_iIndexEach, szProductID));
        if (uRet == ERROR_SUCCESS)
        {
            BOOL bTake = TRUE; // Do we want to show this app, default to yes. 
            _iIndexEach++; // increment the counter
            
            HKEY hkeySub = NULL;
            DWORD dwType;
            TCHAR szRegKey[MAX_PATH];
            StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), REGSTR_PATH_UNINSTALL, szProductID);

            // Open this key in the registry
            uRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, KEY_READ, &hkeySub);
            if (uRet == ERROR_SUCCESS)
            {
                // Don't enumerate system components 
                DWORD dwSysComponent = 0;
                DWORD cbSysComponent = SIZEOF(dwSysComponent);
                uRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT, 0, &dwType,
                                      (PBYTE)&dwSysComponent, &cbSysComponent);
                if ((uRet == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwSysComponent == 1))
                    bTake = FALSE;

                RegCloseKey(hkeySub);
            }

            if (bTake)
            {
                INSTALLSTATE is = MsiQueryProductState(szProductID);

                if ((is != INSTALLSTATE_DEFAULT) && (is != INSTALLSTATE_ADVERTISED))
                    bTake = FALSE;

                // NOTE: INSTALLSTATE_ADVERTISED means assigned apps
                if (bTake)
                {
                    CInstalledApp * pia = new CInstalledApp(szProductID);
                    if (pia)
                    {
                        *ppia = SAFECAST(pia, IInstalledApp *);
                        hres = S_OK;
                    }
                    else
                        hres = E_OUTOFMEMORY;
                    break;
                }
            } 
            bContinue = TRUE;
        }
        else
        {
            switch(uRet)
            {
                //
                // MsiEnumProducts can return ERROR_CALL_NOT_IMPLEMENTED
                // on embedded SKU.  Act as if enumeration is complete.
                //
                case ERROR_CALL_NOT_IMPLEMENTED:
                case ERROR_NO_MORE_ITEMS:
                    //
                    // Enumeration is complete.
                    //
                    break;

                case ERROR_ACCESS_DENIED:
                    hres = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                    break;
                    
                default:
                    //
                    // Some error other than "access denied" occured.
                    // Continue enumerating products.
                    //
                    _iIndexEach++;
                    bContinue = TRUE;
                    break;
            }
        }
    } while (bContinue);
    
    return hres;
}


// IEnumInstalledApps::Next
// We allow only one app at a time. 
STDMETHODIMP CEnumInstalledApps::Next(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    if (_bEnumLegacy)
    {
        hres = _GetNextLegacyApp(ppia);
        if (hres == S_FALSE)
        {
            // End of the enumeration for legacy apps
            _bEnumLegacy = FALSE;
            _iIndexEach = 0;
            goto EnumDarwinNow;
        }
    }
    else
    {    
EnumDarwinNow:
        hres = _GetNextDarwinApp(ppia);
    }
    
    return hres;
}

// IEnumInstalledApps::Reset
STDMETHODIMP CEnumInstalledApps::Reset(void)
{
    // Start off enumerating legacy apps, then switch to
    // enumerating darwin apps.
    _bEnumLegacy = TRUE;
    _dwCIA = -1;
    _iIndexEach = 0;

    return S_OK;
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CEnumInstalledApps_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CEnumInstalledApps * pObj = new CEnumInstalledApps();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IEnumInstalledApps *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\instenum.h ===
#ifndef __INSTENUM_H_
#define __INSTENUM_H_

/////////////////////////////////////////////////////////////////////////////
// CEnumInstalledApps
class CEnumInstalledApps : public IEnumInstalledApps
{
public:

    CEnumInstalledApps(void);
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumInstalledApps
    STDMETHODIMP Next(IInstalledApp ** ppia);
    STDMETHODIMP Reset(void);

protected:

    virtual ~CEnumInstalledApps(void);

    HRESULT _GetNextLegacyAppFromRegistry(IInstalledApp ** ppia);
    HRESULT _GetNextLegacyApp(IInstalledApp ** ppia);
    HRESULT _GetNextDarwinApp(IInstalledApp ** ppia);
    
    UINT _cRef;
    
    DWORD    _iEnumIndex;     // Total Application Enumeration index.
    DWORD    _iIndexEach;     // Shared index by Legacy or Darwin or SMS 
    BOOL     _bEnumLegacy;
    DWORD    _dwCIA;          // What kind of legacy enumeration are we doing?
    HKEY     _hkeyUninstall;
};

#endif //__INSTENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\pickicon.c ===
//
//  PickIcon.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"


//
//  Size?
//
#define MAX_ICONS   75


//
//  Adds icons to the list box.
//

void PutIconsInList(HWND hLB, LPWIZDATA lpwd)
{
    HICON   rgIcons[MAX_ICONS];
    int     iTempIcon;
    int     cIcons;
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    RECT    rc;
    int     cy;

    ListBox_SetColumnWidth(hLB, g_cxIcon+12);

    //
    // compute the height of the listbox based on icon dimensions
    //

    GetWindowRect(hLB, &rc);

    cy = g_cyIcon + GetSystemMetrics(SM_CYHSCROLL) + GetSystemMetrics(SM_CYEDGE) * 3;

    SetWindowPos(hLB, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    ListBox_ResetContent(hLB);

    SendMessage(hLB, WM_SETREDRAW, FALSE, 0L);

#ifdef DEBUG
    {
    //
    //  This is necessary for Unicode (i.e. NT) builds because the shell32
    //  library does not support ShellMessageBoxA and W versions.
    //
    TCHAR szTemp[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achIconFile, -1, szTemp, ARRAYSIZE(szTemp));

    TraceMsg(TF_ERROR, "%s", szTemp);
    }
#endif  //  DEBUG

    cIcons = (int)ExtractIconExA(lpwd->PropPrg.achIconFile, 0, rgIcons, NULL, MAX_ICONS);

    for (iTempIcon = 0; iTempIcon < cIcons; iTempIcon++)
    {
        ListBox_AddString(hLB, rgIcons[iTempIcon]);
    }

    ListBox_SetCurSel(hLB, 0);

    SendMessage(hLB, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hLB, NULL, TRUE);

    SetCursor(hcurOld);
}


//
//
//

void PickIconInitDlg(HWND hDlg, LPARAM lParam)
{
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)lParam;
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);

    PutIconsInList(GetDlgItem(hDlg, IDC_ICONLIST), lpwd);
}


//
//  Returns TRUE if a vaild icon is selected.
//

BOOL PickIconNextPressed(LPWIZDATA lpwd)
{
    int iIconIndex = ListBox_GetCurSel(GetDlgItem(lpwd->hwnd, IDC_ICONLIST));

    lpwd->PropPrg.wIconIndex = (WORD)iIconIndex;

    return(iIconIndex != LB_ERR);
}


//
//
//

BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            //
                            // If PIFMGR has assigned an icon for this app then
                            // we'll skip it.  This condition only happens when
                            // creating a shortcut to a single MS-DOS session.
                            //

                            if (lpwd->dwFlags & WDFLAG_APPKNOWN)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                lpwd->hwnd = hDlg;
                                PropSheet_SetWizButtons(GetParent(hDlg),
                                                        PSWIZB_BACK | PSWIZB_FINISH);
                            }
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!PickIconNextPressed(lpwd))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            if (!(PickIconNextPressed(lpwd) && CreateLink(lpwd)))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            PickIconInitDlg(hDlg, lParam);
            break;

        case WM_COMMAND:
            if(lpwd)
            {
                if ((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ICONLIST) &&
                    ((GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)))
                {
                    PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
                }
            }
            break;

        //
        // owner draw messages for icon listbox
        //

        case WM_DRAWITEM:
            #define lpdi ((DRAWITEMSTRUCT FAR *)lParam)

            if (lpdi->itemState & ODS_SELECTED)
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            else
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_WINDOW));

            //
            // repaint the selection state
            //

            ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

            //
            // draw the icon
            //

            if ((int)lpdi->itemID >= 0)
              DrawIcon(lpdi->hDC, (lpdi->rcItem.left + lpdi->rcItem.right - g_cxIcon) / 2,
                                  (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cyIcon) / 2, (HICON)lpdi->itemData);

            // InflateRect(&lpdi->rcItem, -1, -1);

            //
            // if it has the focus, draw the focus
            //

            if (lpdi->itemState & ODS_FOCUS)
                DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

            #undef lpdi
            break;

        case WM_MEASUREITEM:
            #define lpmi ((MEASUREITEMSTRUCT FAR *)lParam)

            lpmi->itemWidth = g_cxIcon + 12;
            lpmi->itemHeight = g_cyIcon + 4;

            #undef lpmi
            break;

        case WM_DELETEITEM:
            #define lpdi ((DELETEITEMSTRUCT FAR *)lParam)

            DestroyIcon((HICON)lpdi->itemData);

            #undef lpdi
            break;

        default:
            return FALSE;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\link.c ===
//
//  Link.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"

const static TCHAR szExplorer[] = TEXT("Explorer");
const static TCHAR szExpSelParams[] = TEXT("/Select,");

//
//  Returns the fully-qualified path name of the link.
//
BOOL GetLinkName(LPTSTR lpszLinkName, UINT cchLinkName, LPWIZDATA lpwd)
{
    if (PathCombine(lpszLinkName, lpwd->lpszFolder, lpwd->szProgDesc) == NULL )
        return( FALSE );

#ifdef NO_NEW_SHORTCUT_HOOK
    StringCchCat(lpszLinkName, cchLinkName, (lpwd->dwFlags & WDFLAG_DOSAPP) ? c_szPIF : c_szLNK);
#else
    if ((lstrlen(lpszLinkName) + lstrlen(lpwd->szExt)) >= MAX_PATH)
        return FALSE;

    StringCchCat(lpszLinkName, cchLinkName, lpwd->szExt);
#endif

    return( TRUE );
}


//
//  Opens the folder of the newly created link.
//

BOOL OpenLinkFolder(LPWIZDATA lpwd, LPTSTR lpszLinkName)
{
    SHELLEXECUTEINFO ei;

    TCHAR szParams[MAX_PATH];

    StringCchPrintf(szParams, ARRAYSIZE(szParams), TEXT("%s%s"), szExpSelParams, lpszLinkName);

    ei.cbSize = sizeof(ei);
    ei.hwnd = lpwd->hwnd;
    ei.fMask = 0;
    ei.lpVerb = NULL;
    ei.lpFile = szExplorer;
    ei.lpParameters = szParams;
    ei.lpDirectory = NULL;
    ei.lpClass = NULL;
    ei.nShow = SW_SHOWDEFAULT;
    ei.hInstApp = g_hinst;

    return(ShellExecuteEx(&ei));
}


//
//  Cretates a link.
//

BOOL CreateLink(LPWIZDATA lpwd)
{
    BOOL          bWorked = FALSE;
    IShellLink   *psl;
    HCURSOR       hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    IPersistFile *ppf;
    TCHAR         szLinkName[MAX_PATH];
    WCHAR         wszPath[MAX_PATH];

    szLinkName[0] = TEXT('\0');
    GetLinkName(szLinkName, ARRAYSIZE(szLinkName), lpwd);

    if (lpwd->lpszOriginalName)
    {
        if (PathFileExists(szLinkName))
        {
            DeleteFile(lpwd->lpszOriginalName);
            SHChangeNotify(SHCNE_DELETE, SHCNF_FLUSH | SHCNF_PATH,
                        lpwd->lpszOriginalName, NULL);
        }
        else
        {
            // we use full pidls here since simple net pidls fail to compare to full net pidls,
            // and thus the changenotify will never make it to the client and it will not update.
            LPITEMIDLIST pidlOriginal = ILCreateFromPath(lpwd->lpszOriginalName);   // need to do this before the move!
            LPITEMIDLIST pidlLink = NULL;

            if (MoveFile(lpwd->lpszOriginalName, szLinkName))
            {
                pidlLink = ILCreateFromPath(szLinkName);    // need to do this after the move (or it won't exist)!

                if (pidlOriginal && pidlLink)
                {
                    SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_IDLIST, pidlOriginal, pidlLink);
                }
                else
                {
                    TraceMsg(TF_ERROR, "%s", "Unable to generate pidls for rename notify");
                    SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_PATH, lpwd->lpszOriginalName, szLinkName);
                }
            }
            else
            {
                TraceMsg(TF_ERROR, "%s", "Unable to rename link -- Will end up with two");
                TraceMsg(TF_ERROR, "%s", szLinkName);
            }
            
            if (pidlOriginal)
                ILFree(pidlOriginal);

            if (pidlLink)
                ILFree(pidlLink);
        }

        //
        // Now get rid of this in case we fail later and then re-enter
        // this routine later.
        //

        lpwd->lpszOriginalName = NULL;
    }

    //
    //    If we're just supposed to copy it, it's simple!
    //

    if (lpwd->dwFlags & WDFLAG_COPYLINK)
    {
        bWorked = CopyFile(lpwd->szExeName, szLinkName, FALSE);
        goto ExitNoFree;
    }

#ifndef NO_NEW_SHORTCUT_HOOK
    if (lpwd->pnshhk)
    {
        //
        // The object is ready to be saved to a file.
        //

        if (FAILED(lpwd->pnshhk->lpVtbl->QueryInterface(lpwd->pnshhk, &IID_IPersistFile, &ppf)))
            goto ExitFreePSL;
    }
    else
        if (lpwd->pnshhkA)
        {
            //
            // The object is ready to be saved to a file.
            //

            if (FAILED(lpwd->pnshhkA->lpVtbl->QueryInterface(lpwd->pnshhkA, &IID_IPersistFile, &ppf)))
                goto ExitFreePSL;
        }
        else
    {
#endif
        //
        //    We didn't do a simple copy.  Now do the full-blown create.
        //
        if (FAILED(CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLink, (void **)&psl)))
        {
            TraceMsg(TF_ERROR, "%s", "Could not create instance of IShellLink");
            goto ExitNoFree;
        }

        if (FAILED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
        {
            goto ExitFreePSL;
        }

        psl->lpVtbl->SetPath(psl, lpwd->szExeName);

        psl->lpVtbl->SetArguments(psl, lpwd->szParams);

        psl->lpVtbl->SetWorkingDirectory(psl, lpwd->szWorkingDir);

        if (lpwd->dwFlags & WDFLAG_DOSAPP)
        {
            MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achIconFile, -1, wszPath, ARRAYSIZE(wszPath));

            psl->lpVtbl->SetIconLocation(psl, wszPath, (int)(lpwd->PropPrg.wIconIndex));
        }
#ifndef NO_NEW_SHORTCUT_HOOK
    }
#endif

    bWorked = SUCCEEDED(ppf->lpVtbl->Save(ppf, szLinkName, TRUE));

    ppf->lpVtbl->Release(ppf);

ExitFreePSL:

#ifndef NO_NEW_SHORTCUT_HOOK
    if (lpwd->pnshhk)
    {
        lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
        lpwd->pnshhk = NULL;
    }
    else
          if (lpwd->pnshhkA)
          {
              lpwd->pnshhkA->lpVtbl->Release(lpwd->pnshhkA);
              lpwd->pnshhkA = NULL;
          }
          else
#endif
        psl->lpVtbl->Release(psl);

ExitNoFree:

    if (bWorked)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_FLUSH | SHCNF_PATH,
                       szLinkName, NULL);
    }
    SetCursor(hcurOld);

    if (bWorked)
    {
        if (!(lpwd->dwFlags & WDFLAG_DONTOPENFLDR))
        {
            OpenLinkFolder(lpwd, szLinkName);
        }
    }
    else
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_NOSHORTCUT),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }

    return(bWorked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#define STRICT

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

// Define these before including dldecl.h
#define DL_OLEAUT32
#define DL_OLE32

#include "dldecl.h"             // dldecl.h needs to go before everything else

#define CC_INTERNAL             // This is for some internal prshtp.h stuff


//
// need Wx86 definitions from ntpsapi.h
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#ifdef __cplusplus
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component
#endif

#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include "..\inc\port32.h"
#include <winerror.h>
#include <winnlsp.h>
#include <docobj.h>
#include <lm.h>
#include <shlobj.h>

#define _SHLWAPI_
#include <shlwapi.h>

#include <ccstock.h>
#include <crtfree.h>
#define DISALLOW_Assert
#include <debug.h>
#include <regstr.h>
#define _WIN32_MSI 110
#include <msi.h>                // Darwin APIs
#include <msiquery.h>           // Darwin Datebase Query APIs
#include <wininet.h>            // For INTERNET_MAX_URL_LENGTH

#include "shappmgrp.h"
#include "shellp.h"

#include <appmgmt.h>
#include "apithk.h"
#include "awthunk.h"

#include <uxtheme.h>


#include <shfusion.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// Local includes
//

#define StrCmpIW            lstrcmpiW


// This DLL needs to run correctly on Win95.  CharNextW is only stubbed
// on Win95, so we need to do this...
#define CharNextW(x)        ((x) + 1)
#define CharPrevW(y, x)     ((x) - 1)

// This is a TCHAR export on win9x and NT4, and since we need to link to
// the old shell32.nt4/shell32.w95 we #undef it here
#undef ILCreateFromPath
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath);


//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in debug.h)
//

// Trace flags
#define TF_OBJLIFE          0x00000010      // Object lifetime
#define TF_DSO              0x00000020      // Data source object
#define TF_FINDAPP          0x00000040      // Find app heuristic stuff
#define TF_INSTAPP          0x00000080      
#define TF_SLOWFIND         0x00000100
#define TF_TASKS            0x00000200
#define TF_CTL              0x00000400
#define TF_VERBOSEDSO       0x00000800      // squirts html and stuff

// Break flags
#define BF_ONDLLLOAD        0x00000010


// Prototype flags
#define PF_NEWADDREMOVE     0x00000001
#define PF_NOSECURITYCHECK  0x00000002
#define PF_FAKEUNINSTALL    0x00000004

// Debug functions
#ifdef DEBUG
#define TraceAddRef(classname, cref)    TraceMsg(TF_OBJLIFE, #classname "(%#08lx) %d>", (DWORD_PTR)this, cref)
#define TraceRelease(classname, cref)   TraceMsg(TF_OBJLIFE, #classname "(%#08lx) %d<", (DWORD_PTR)this, cref)
#else
#define TraceAddRef(classname, cref)    
#define TraceRelease(classname, cref)   
#endif

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


//
// Info string MAX length
//
#define MAX_INFO_STRING MAX_PATH * 3

//
// Global variables
//
EXTERN_C HINSTANCE g_hinst;

#define HINST_THISDLL   g_hinst

#define g_bRunOnNT  TRUE
#define g_bRunOnNT5 TRUE

EXTERN_C BOOL g_bRunOnIE4Shell;

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\pubenum.h ===
#ifndef __PUBENUM_H_
#define __PUBENUM_H_


class CShellEnumPublishedApps : public IEnumPublishedApps
{
public:

    CShellEnumPublishedApps(HDPA hdpaEnum);
    ~CShellEnumPublishedApps();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumPublishedApps
    STDMETHODIMP Next(IPublishedApp ** ppia);
    STDMETHODIMP Reset(void);
    //STDMETHODIMP SetCategory(GUID * pAppCategoryId);

protected:

    UINT _cRef;

    // Internal list of all IEnumPublishedApps * 
    HDPA _hdpaEnum;
    int  _iEnum;  
};

#endif //__PUBENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\pubenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: pubenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

#include "pubenum.h"


void _DestroyHdpaEnum(HDPA hdpaEnum)
{
    ASSERT(IsValidHDPA(hdpaEnum));
    IEnumPublishedApps * pepa;
    int idpa;
    for (idpa = 0; idpa < DPA_GetPtrCount(hdpaEnum); idpa++)
    {
        pepa = (IEnumPublishedApps *)DPA_GetPtr(hdpaEnum, idpa);
        if (EVAL(pepa))
            pepa->Release();
    }

    DPA_Destroy(hdpaEnum);
}

CShellEnumPublishedApps::CShellEnumPublishedApps(HDPA hdpaEnum) : _cRef(1), _hdpaEnum(hdpaEnum)
{
}

CShellEnumPublishedApps::~CShellEnumPublishedApps()
{
    if (_hdpaEnum)
        _DestroyHdpaEnum(_hdpaEnum);
}

// IEnumPublishedApps::QueryInterface
HRESULT CShellEnumPublishedApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CShellEnumPublishedApps, IEnumPublishedApps),                  // IID_IEnumPublishedApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IEnumPublishedApps::AddRef
ULONG CShellEnumPublishedApps::AddRef()
{
    _cRef++;
    TraceMsg(TF_OBJLIFE, "CShellEnumPublishedApps()::AddRef called, new _cRef=%lX", _cRef);
    return _cRef;
}

// IEnumPublishedApps::Release
ULONG CShellEnumPublishedApps::Release()
{
    _cRef--;
    TraceMsg(TF_OBJLIFE, "CShellEnumPublishedApps()::Release called, new _cRef=%lX", _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


// IEnumPublishedApps::Next
HRESULT CShellEnumPublishedApps::Next(IPublishedApp ** ppia)
{
    HRESULT hres = E_FAIL;
    if (_hdpaEnum)
    {
        IEnumPublishedApps * pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, _iEnum);

        //
        // If pepa is not valid or pepa->Next failed, or at the end of the current enumerator, 
        // we skip this Enumerator, and go on to the next one until we hit the limit
        
        while ((!pepa || S_OK != (hres = pepa->Next(ppia))) && (_iEnum < DPA_GetPtrCount(_hdpaEnum)))
        {
            _iEnum++;
            pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, _iEnum);
        }
    }    
    return hres;
}


// IEnumPublishedApps::Reset
HRESULT CShellEnumPublishedApps::Reset(void)
{
    // Call reset on everyone in the list and set our index iEnum to 0;
    if (_hdpaEnum)
    {
        IEnumPublishedApps * pepa;
        int idpa;
        for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaEnum); idpa++)
        {
            pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, idpa);
            if (pepa)
                pepa->Reset();
        }

        _iEnum = 0;

        return S_OK;
    }
    
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_

//
// global object array - used for class factory, auto registration, type libraries, oc information
//
typedef struct tagOBJECTINFO
{
#ifdef __cplusplus
    void *cf;
#else
    const IClassFactoryVtbl *cf;
#endif
    CLSID const* pclsid;
    HRESULT (*pfnCreateInstance)(IUnknown* pUnkOuter, IUnknown** ppunk, const struct tagOBJECTINFO *);

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;

typedef OBJECTINFO const * LPCOBJECTINFO;

#define OIF_ALLOWAGGREGATION  0x0001



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags



STDAPI  CShellAppManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CEnumInstalledApps_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDarwinAppPublisher_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern const OBJECTINFO g_ObjectInfo[]; // sccls.c

STDAPI GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\scripts.h ===
EXTERN_C LPVOID ScriptManagerInitScripts();
EXTERN_C void ScriptManagerRunScripts(LPVOID *ppScriptManager);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\sccls.c ===
#include "priv.h"
#include "sccls.h"

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// This array holds information needed for ClassFactory.
//
// PERF: this table should be ordered in most-to-least used order
//
const OBJECTINFO g_ObjectInfo[] =
{
    
    &c_CFVtbl, &CLSID_ShellAppManager,         CShellAppManager_CreateInstance,
        COCREATEONLY,

    &c_CFVtbl, &CLSID_DarwinAppPublisher,      CDarwinAppPublisher_CreateInstance,
        COCREATEONLY,

    &c_CFVtbl, &CLSID_EnumInstalledApps,       CEnumInstalledApps_CreateInstance,
        COCREATEONLY, 

    NULL, NULL, NULL, NULL, NULL, 0, 0,0,
} ;


// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, &IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        OBJECTINFO *this = IToClass(OBJECTINFO, cf, pcf);
        IUnknown *punk;
        HRESULT hres;
        
        if (punkOuter) {

            if (!(this->dwClassFactFlags & OIF_ALLOWAGGREGATION))
                return CLASS_E_NOAGGREGATION;
        }

        // if we're aggregated, then we know we're looking for an
        // IUnknown so we should return punk directly. otherwise
        // we need to QI.
        //
        hres = this->pfnCreateInstance(punkOuter, &punk, this);
        if (SUCCEEDED(hres))
        {
            if (punkOuter)
            {
                *ppv = (LPVOID)punk;
            }
            else
            {
                hres = punk->lpVtbl->QueryInterface(punk, riid, ppv);
                punk->lpVtbl->Release(punk);
            }
        }
    
        ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    extern LONG g_cRefThisDll;

    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};


STDAPI GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hres = CLASS_E_CLASSNOTAVAILABLE;
    
    extern IClassFactory *CInstClassFactory_Create(const CLSID *pInstID);

    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJECTINFO *pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\scripts.cpp ===
//+-------------------------------------------------------------------------
//
//  AppWiz.cpl - "Add or Remove Programs" CPL.
//  Copyright (C) Microsoft
//
//  File:       Scripts.CPP 
//              authomates running of TS application compatibility scripts
//
//  History:    Nov-14-2000   skuzin  Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <regapi.h>
#include <tsappcmp.h>
#include <strsafe.h>
#include "Scripts.h"

#include <list>
using namespace std;
  
#ifndef ARRAYSIZE
#define ARRAYSIZE(sz)   (sizeof(sz)/sizeof(sz[0]))
#endif

//
//Struct to establish correspondence between app. name (key name)
//and install and uninstall script names
//
class CAppScript
{
private:
    LPWSTR m_szKeyName; //key name that represents installed application
    LPWSTR m_szInstallScript; //install script name
    LPWSTR m_szUninstallScript; //uninstall script name
    DWORD m_bNeedReboot; //If set - then scripts must be run after reboot.
    BOOL m_bAlreadyInstalled; // 
public:
    //
    CAppScript() : 
        m_szKeyName(NULL), m_szInstallScript(NULL), m_szUninstallScript(NULL),
        m_bNeedReboot(FALSE), m_bAlreadyInstalled(FALSE)
    {
    }
    ~CAppScript()
    {
        if(m_szKeyName)
        {
            LocalFree(m_szKeyName);
        }

        if(m_szInstallScript)
        {
            LocalFree(m_szInstallScript);
        }

        if(m_szUninstallScript)
        {
            LocalFree(m_szUninstallScript);
        }
    }

    BOOL Load(HKEY hKeyParent,LPCWSTR szKeyName);
    BOOL RunScriptIfApplicable();

private:
    BOOL RunScript(LPCWSTR szDir, LPCWSTR szScript);
    BOOL PrepareScriptForReboot(LPCWSTR szInstallDir, LPCWSTR szScript);
    //BUGBUG this function is public for test only
};

//This class describes a list of pointers 
//to objects of class CAppScript
class CAppScriptList : public list<CAppScript*>
{
public:
    //Deletes all CAppScript objects 
    //before destroing the list itself.
    ~CAppScriptList()
    {
        CAppScriptList::iterator it;
            
        for(it=begin();it!=end(); it++)
        {
            delete (*it);
        }
    }
};

class CAppScriptManager
{
private:
    CAppScriptList m_AppScriptList;
public:
    CAppScriptManager(){};
    ~CAppScriptManager(){};

    BOOL Init();
    BOOL RunScripts();
private:
    BOOL LoadSupportedAppList();
    BOOL IsAppCompatOn();
};


//Functions - helpers.
DWORD RegLoadString(HKEY hKey, LPCWSTR szValueName, LPWSTR *pszValue);
DWORD RegLoadDWORD(HKEY hKey, LPCWSTR szValueName, DWORD *pdwValue);
BOOL  RegIsKeyExist(HKEY hKeyParent, LPCWSTR szKeyName);
DWORD RegGetKeyInfo(HKEY hKey, LPDWORD pcSubKeys, LPDWORD pcMaxNameLen);
DWORD RegKeyEnum(HKEY hKey, DWORD dwIndex, LPWSTR szSubKeyName, DWORD cSubKeyName);

///////////////////////////////////////////////////////////////////////////////
//Exports
///////////////////////////////////////////////////////////////////////////////
extern "C"
LPVOID 
ScriptManagerInitScripts()
{
    CAppScriptManager *pScriptManager = new CAppScriptManager();
    if(pScriptManager)
    {
        if(!pScriptManager->Init())
        {
            delete pScriptManager;
            pScriptManager = NULL;
        }
    }

    return pScriptManager; 
}

extern "C"
void 
ScriptManagerRunScripts(
        LPVOID *ppScriptManager)
{
    if(*ppScriptManager)
    {
        CAppScriptManager *pScriptManager = reinterpret_cast<CAppScriptManager *>(*ppScriptManager);
        pScriptManager->RunScripts();
        delete pScriptManager;
        *ppScriptManager = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//class CAppScript
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
CAppScript::Load()
Purpose:
Loads script information from the registry
Sets m_bIsInitiallyInstalled to TRUE if app already installed
******************************************************************************/
BOOL 
CAppScript::Load(
        HKEY hKeyParent,
        LPCWSTR szKeyName)
{
    DWORD err;
    HKEY hKey;

    err = RegOpenKeyExW(hKeyParent, szKeyName, 0, KEY_QUERY_VALUE, &hKey );

    if(err == ERROR_SUCCESS)
    {
        RegLoadString(hKey, L"KeyName", &m_szKeyName);
        RegLoadString(hKey, L"InstallScript", &m_szInstallScript);
        RegLoadString(hKey, L"UninstallScript", &m_szUninstallScript);
        RegLoadDWORD(hKey, L"NeedReboot", &m_bNeedReboot);

        RegCloseKey(hKey);

        if(m_szKeyName)
        {
            m_bAlreadyInstalled = RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName);
            return TRUE;
        }
    }
    
    return FALSE;
}

/******************************************************************************
CAppScript::RunScriptIfApplicable()
Purpose:
Checks if the application was installed or uninstalled and runs the script.
If m_bNeedReboot flag is set - schedules the script to run after reboot.
******************************************************************************/
BOOL 
CAppScript::RunScriptIfApplicable()
{
    KdPrint(("CAppScript::RunScriptIfApplicable() - ENTER\n"));

    const WCHAR szInstallSubDir[] = L"\\Application Compatibility Scripts\\Install";
    const WCHAR szUninstallSubDir[] = L"\\Application Compatibility Scripts\\Uninstall";
    static WCHAR szInstallDir[MAX_PATH+sizeof(szInstallSubDir)/sizeof(WCHAR)+1] = L"";
    static WCHAR szUninstallDir[MAX_PATH+sizeof(szUninstallSubDir)/sizeof(WCHAR)+1] = L"";
    
    if(!szInstallDir[0])
    {
        //Get the scripts location
        //We need to do it only once
        
        //get Windows directory name
        if(!GetSystemWindowsDirectoryW(szInstallDir,MAX_PATH))
        {
            KdPrint(("CAppScript::RunScriptIfApplicable() - GetWindowsDirectoryW() FAILED\n"));
            return FALSE;
        }
        
        StringCchCopy(szUninstallDir, ARRAYSIZE(szUninstallDir), szInstallDir);
        StringCchCat(szInstallDir, ARRAYSIZE(szInstallDir), szInstallSubDir);
        StringCchCat(szUninstallDir, ARRAYSIZE(szUninstallDir), szUninstallSubDir);
    }

    if(!m_bAlreadyInstalled && RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName) && m_szInstallScript)
    {
        //Application was installed
        if(m_bNeedReboot)
        {
            //Setup will continue after reboot
            //Create RunOnce entry to run script after system is rebooted
            KdPrint(("CAppScript::RunScriptIfApplicable() - PrepareScriptForReboot %ws\n",m_szInstallScript));
            if(!PrepareScriptForReboot(szInstallDir, m_szInstallScript))
            {
                KdPrint(("CAppScript::PrepareScriptForReboot() - FAILED\n",m_szInstallScript));
                return FALSE;
            }

        }
        else
        {
            KdPrint(("CAppScript::RunScriptIfApplicable() - executing script %ws\n",m_szInstallScript));
            if(!RunScript(szInstallDir,m_szInstallScript))
            {
                KdPrint(("CAppScript::RunScriptIfApplicable() - executing script FAILED\n",m_szInstallScript));
                return FALSE;
            }
        }

        m_bAlreadyInstalled = TRUE;
    }
    else
    {
        if(m_bAlreadyInstalled && !RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName) && m_szUninstallScript)
        {
            //Application was uninstalled
            
            KdPrint(("CAppScript::RunScriptIfApplicable() - executing script %ws\n",m_szUninstallScript));
            if(!RunScript(szUninstallDir,m_szUninstallScript))
            {
                KdPrint(("CAppScript::RunScriptIfApplicable() - executing script FAILED\n",m_szUninstallScript));
                return FALSE;
            }

            m_bAlreadyInstalled = FALSE;
        }
    }

    return TRUE;
}

/******************************************************************************
CAppScript::RunScript()
Purpose:
Runs script
Waits untill script finishes
******************************************************************************/
BOOL 
CAppScript::RunScript(
        LPCWSTR szDir, 
        LPCWSTR szScript)
{
    BOOL bRet = FALSE;
    WCHAR szCmdLineTemplate[] = L"cmd.exe /C %s";
    LPWSTR pszCmdLine;
    DWORD cchCmdLine = wcslen(szScript) + ARRAYSIZE(szCmdLineTemplate);  // null terminator taken care of by ARRAYSIZE()

    pszCmdLine = (LPWSTR)LocalAlloc(LPTR, cchCmdLine * sizeof(WCHAR));
    if (pszCmdLine)
    {
        if (SUCCEEDED(StringCchPrintf(pszCmdLine,
                                      cchCmdLine,
                                      szCmdLineTemplate,
                                      szScript)))
        {
            STARTUPINFO si = {0};
            PROCESS_INFORMATION pi;

            si.cb = sizeof(STARTUPINFO);

            bRet = CreateProcessW(NULL,
                                  pszCmdLine,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  CREATE_NEW_CONSOLE,
                                  NULL,
                                  szDir,
                                  &si,
                                  &pi);
            if (bRet)
            {
                WaitForSingleObject(pi.hProcess, INFINITE);
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            } 
        }
        
        LocalFree(pszCmdLine);
    }
    
    return bRet;
}

/******************************************************************************
CAppScript::PrepareScriptForReboot()
Purpose:
Creates CMD file that will change current directory to 
...\Application Compatibility Scripts\Install 
and then run the script.
Schedules this CMD file to be run after reboot by creating an entry uder 
"HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" key.
******************************************************************************/
BOOL 
CAppScript::PrepareScriptForReboot(
        LPCWSTR szInstallDir, 
        LPCWSTR szScript)
{
    BOOL bRet = FALSE;
    BOOL bCreatedFile = FALSE;
    WCHAR szFileNameTemplate[] = L"%s\\RunOnce.cmd";
    LPWSTR pszFullFileName;
    size_t cchFullFileName = wcslen(szInstallDir) + ARRAYSIZE(szFileNameTemplate);  // null terminator taken care of by ARRAYSIZE()

    pszFullFileName = (LPWSTR)LocalAlloc(LPTR, cchFullFileName * sizeof(WCHAR));
    if (pszFullFileName)
    {
        // Assemble full file name
        if (SUCCEEDED(StringCchPrintfW(pszFullFileName,
                                       cchFullFileName,
                                       szFileNameTemplate,
                                       szInstallDir)))
        {
            HANDLE hFile = CreateFile(pszFullFileName,
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      CREATE_NEW,   // only create it if it does not already exist
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // File did not exist before - create code and write it into the file.
                char szCodeTemplate[] = "cd %S\r\n%%1\r\n";
                LPSTR pszFileCode;
                DWORD cchFileCode = wcslen(szInstallDir) + ARRAYSIZE(szCodeTemplate);   // null terminator taken care of by ARRAYSIZE()

                pszFileCode = (LPSTR)LocalAlloc(LPTR, cchFileCode * sizeof(char));
                if (pszFileCode)
                {
                    if SUCCEEDED(StringCchPrintfA(pszFileCode,
                                                  cchFileCode,
                                                  szCodeTemplate,
                                                  szInstallDir)) // unicode->ansi conversion taken care of by "%S"
                    {
                        DWORD cbToWrite = strlen(pszFileCode);
                        DWORD cbWritten;

                        if (WriteFile(hFile,
                                      (void*)pszFileCode,
                                      cbToWrite,
                                      &cbWritten,
                                      NULL) &&
                            (cbToWrite == cbWritten))
                        {
                            bCreatedFile = TRUE;
                        }
                    }

                    LocalFree(pszFileCode);
                }

                CloseHandle(hFile);

                if (bCreatedFile == FALSE)
                {
                    DeleteFile(pszFullFileName);
                }
            }
            else
            {
                // If file already exists - do only registry changes.
                if (GetLastError() == ERROR_FILE_EXISTS)
                {
                    bCreatedFile = TRUE;
                }
            }
        }

        LocalFree(pszFullFileName);
    }

    if (bCreatedFile)
    {
        // Registry changes:
        WCHAR szCommandTemplate[] = L"\"%s\\RunOnce.cmd\" %s";
        LPWSTR pszCommand;
        DWORD cchCommand = (wcslen(szInstallDir) + wcslen(szScript) + ARRAYSIZE(szCommandTemplate));  // null terminator taken care of by ARRAYSIZE()
        
        pszCommand = (LPWSTR)LocalAlloc(LPTR, cchCommand * sizeof(WCHAR));
        if (pszCommand)
        {        
            if (SUCCEEDED(StringCchPrintfW(pszCommand,
                                           cchCommand,
                                           szCommandTemplate,
                                           szInstallDir,
                                           szScript)))
            {
                HKEY hKey;

                if (RegCreateKeyExW(HKEY_CURRENT_USER,
                                    L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                                    0,
                                    NULL,
                                    0,
                                    KEY_SET_VALUE,
                                    NULL,
                                    &hKey,
                                    NULL) == ERROR_SUCCESS)
                {
                    DWORD cbCommand = (wcslen(pszCommand) + 1) * sizeof(WCHAR);

                    if (RegSetValueExW(hKey,
                                       L"ZZZAppCompatScript",
                                       0,
                                       REG_SZ,
                                       (CONST BYTE *)pszCommand,
                                       cbCommand) == ERROR_SUCCESS)
                    {
                        bRet = TRUE;
                    }

                    RegCloseKey(hKey);
                }
            }

            LocalFree(pszCommand);
        }
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//class CAppScriptManager
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
CAppScriptManager::Init()
Purpose:
Initialization. 
Returns FALSE if TS Application Compatibility if OFF or list of supported
applications was not found in the registry.
******************************************************************************/
BOOL 
CAppScriptManager::Init()
{
    //DebugBreak();
    KdPrint(("CAppScriptManager::Init() - ENTER\n"));

    if(!IsAppCompatOn())
    {
        KdPrint(("CAppScriptManager::Init() - TS App Compat is off!\n"));
        return FALSE;
    }

    if(!LoadSupportedAppList())
    {
        KdPrint(("CAppScriptManager::Init() - LoadSupportedAppList() FAILED\n"));
        return FALSE;
    }
    
    KdPrint(("CAppScriptManager::Init() - OK\n"));
    return TRUE;
}

/******************************************************************************
CAppScriptManager::LoadSupportedAppList()
Purpose:
Loads from the registry the list of applications we care about
along with their script names. Save this information in array of 
APP_SCRIPT structures.
******************************************************************************/
BOOL 
CAppScriptManager::LoadSupportedAppList()
{
    HKEY hKey;
    LONG err;
    DWORD cSubKeys;
    DWORD cMaxSubKeyLen;

    KdPrint(("CAppScriptManager::LoadSupportedAppList() - ENTER\n"));
    
    err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Scripts",
        0, KEY_READ, &hKey );
    
    if(err == ERROR_SUCCESS)
    {

        err = RegGetKeyInfo(hKey, &cSubKeys, &cMaxSubKeyLen);

        if(err == ERROR_SUCCESS)
        {
            cMaxSubKeyLen+=1; //to include terminating NULL character
            KdPrint(("CAppScriptManager::LoadSupportedAppList() - %d apps supported\n",cSubKeys));
            //Allocate buffer for subkey names
            LPWSTR szKeyName = (LPWSTR)LocalAlloc(LPTR,cMaxSubKeyLen*sizeof(WCHAR));
        
            if(!szKeyName)
            {
                RegCloseKey(hKey);
                return FALSE;
            }
            
            

            CAppScript *pAppScript = NULL;

            for(DWORD i=0;i<cSubKeys;i++)
            {
                //Get the key name
                err = RegKeyEnum(hKey, i, szKeyName, cMaxSubKeyLen );
                
                if(err != ERROR_SUCCESS)
                {
                    break;
                }

                KdPrint(("CAppScriptManager::LoadSupportedAppList() - loading %ws\n",szKeyName));

                pAppScript = new CAppScript();
                if(!pAppScript)
                {
                    break;
                }
                
                if(pAppScript->Load(hKey, szKeyName))
                {
                    m_AppScriptList.push_back(pAppScript);
                }
                else
                {
                    KdPrint(("CAppScriptManager::LoadSupportedAppList() - FAILED to load\n"));
                    delete pAppScript;
                }
                
            }

            LocalFree(szKeyName);
        }
        
        RegCloseKey(hKey);
    }
    
    if(err != ERROR_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/******************************************************************************
CAppScriptManager::RunScripts()
Purpose:
Runs scripts for all installed or uninstalled applications.
******************************************************************************/
BOOL 
CAppScriptManager::RunScripts()
{

    BOOL bInstallMode = FALSE;
    KdPrint(("CAppScriptManager::RunScripts() - ENTER\n"));
    //system must be now in INSTALL mode, set EXECUTE mode
    if(TermsrvAppInstallMode())
    {
        bInstallMode = TRUE;
        KdPrint(("CAppScriptManager::RunScripts() - set EXECUTE mode\n"));
        if(!SetTermsrvAppInstallMode(FALSE))
        {
            KdPrint(("CAppScriptManager::RunScripts() - SetTermsrvAppInstallMode() FAILED\n"));
            return FALSE;
        }
    }
    
    CAppScriptList::iterator it;
            
    for(it=m_AppScriptList.begin();it!=m_AppScriptList.end(); it++)
    {
        (*it)->RunScriptIfApplicable();
    }

    if(bInstallMode)
    {
        //Restore INSTALL mode
        KdPrint(("CAppScriptManager::RunScripts() - return to INSTALL mode\n"));
        if(!SetTermsrvAppInstallMode(TRUE))
        {
            KdPrint(("CAppScriptManager::RunScripts() - SetTermsrvAppInstallMode() FAILED\n"));
            return FALSE;
        }
    }

    KdPrint(("CAppScriptManager::RunScripts() - FINISH\n"));
    return TRUE;
}

/******************************************************************************
CAppScriptManager::IsAppCompatOn()
Purpose:
Checks if TS Application Compatibility mode is enabled.
Returns TRUE if enabled, 
otherwise, as well as in case of any error, returns FALSE.
******************************************************************************/
BOOL 
CAppScriptManager::IsAppCompatOn()
{
    HKEY hKey;
    DWORD dwData;
    BOOL fResult = FALSE;
    
    KdPrint(("CAppScriptManager::IsAppCompatOn() - ENTER\n"));

    if( RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                  REG_CONTROL_TSERVER,
                  0,
                  KEY_QUERY_VALUE,
                  &hKey) == ERROR_SUCCESS )
    {
	
        if(RegLoadDWORD(hKey, L"TSAppCompat", &dwData) == ERROR_SUCCESS )
        {
            KdPrint(("CAppScriptManager::IsAppCompatOn() - OK; Result=%d\n",dwData));
            fResult = dwData;
        }
    
        RegCloseKey(hKey);
    }

    return fResult;
}

///////////////////////////////////////////////////////////////////////////////
//Functions - helpers.
///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
RegLoadString()
Purpose:
Loads a REG_SZ value from the registry
Allocates buffer.
Buffer then need to be freed using LocalFree function.
******************************************************************************/
DWORD
RegLoadString(
        HKEY hKey, 
        LPCWSTR szValueName, 
        LPWSTR *pszValue)
{
    
    DWORD cbData = 0;
    
    *pszValue = NULL;

    DWORD err = RegQueryValueExW(
                    hKey,            // handle to key
                    szValueName,  // value name
                    NULL,   // reserved
                    NULL,       // type buffer
                    NULL,        // data buffer
                    &cbData      // size of data buffer
                    );
    if(err == ERROR_SUCCESS)
    {
        *pszValue = (LPWSTR)LocalAlloc(LPTR,cbData);
        if(!*pszValue)
        {
            return GetLastError();
        }

        err = RegQueryValueExW(
                    hKey,            // handle to key
                    szValueName,  // value name
                    NULL,   // reserved
                    NULL,       // type buffer
                    (LPBYTE)*pszValue,        // data buffer
                    &cbData      // size of data buffer
                    );
        if(err !=ERROR_SUCCESS)
        {
            LocalFree(*pszValue);
            *pszValue = NULL;
        }

    }

    return err;
}

/******************************************************************************
RegLoadDWORD()
Purpose:
Loads a REG_DWORD value from the registry
******************************************************************************/
DWORD 
RegLoadDWORD(
        HKEY hKey, 
        LPCWSTR szValueName, 
        DWORD *pdwValue)
{
    DWORD cbData = sizeof(DWORD);

    return RegQueryValueExW(
              hKey,            // handle to key
              szValueName,  // value name
              NULL,   // reserved
              NULL,       // type buffer
              (LPBYTE)pdwValue,        // data buffer
              &cbData      // size of data buffer
            );
}

/******************************************************************************
RegIsKeyExist()
Purpose:
Checks if key exists
******************************************************************************/
BOOL 
RegIsKeyExist(
        HKEY hKeyParent, 
        LPCWSTR szKeyName)
{
    LONG    err;
    HKEY    hKey;
    
    KdPrint(("RegIsKeyExist() - Opening key: hKeyParent=%d Key: %ws\n",hKeyParent,szKeyName));
    
    err = RegOpenKeyExW(hKeyParent, szKeyName, 0, MAXIMUM_ALLOWED, &hKey );

    if(err == ERROR_SUCCESS)
    {
        KdPrint(("RegIsKeyExist() - Key Exists!\n",err));
        RegCloseKey(hKey);
        return TRUE;
    }
    else
    {
        KdPrint(("RegIsKeyExist() - err=%d\n",err));
        return FALSE;
    }
}

/******************************************************************************
RegGetKeyInfo()
Purpose:
Gets key's number of sub keys and max sub key name length
******************************************************************************/
DWORD
RegGetKeyInfo(
        HKEY hKey,
        LPDWORD pcSubKeys,
        LPDWORD pcMaxNameLen)
{
    return RegQueryInfoKey(
              hKey,                      // handle to key
              NULL,                 // class buffer
              NULL,               // size of class buffer
              NULL,             // reserved
              pcSubKeys,             // number of subkeys
              pcMaxNameLen,        // longest subkey name (in TCHARs)
              NULL,         // longest class string
              NULL,              // number of value entries
              NULL,     // longest value name
              NULL,         // longest value data
              NULL, // descriptor length
              NULL     // last write time
            );
    
}

/******************************************************************************
RegKeyEnum()
Purpose:
Enumerates sub keys of the registry key
******************************************************************************/
DWORD
RegKeyEnum(
        HKEY hKey,                  // handle to key to enumerate
        DWORD dwIndex,              // subkey index
        LPWSTR szSubKeyName,              // subkey name
        DWORD cSubKeyName)
{
    FILETIME ftLastWriteTime;

    return RegEnumKeyExW(
              hKey,                  // handle to key to enumerate
              dwIndex,              // subkey index
              szSubKeyName,              // subkey name
              &cSubKeyName,            // size of subkey buffer
              NULL,         // reserved
              NULL,             // class string buffer
              NULL,           // size of class string buffer
              &ftLastWriteTime // last write time
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\resource.h ===
#ifndef _IDS_H_
#define _IDS_H_

#define IDS_FONTFACE0                        1
#define IDS_FONTFACE1                        2
#define IDS_FONTFACE2                        3
#define IDS_CLOSE                            4
#define IDS_CHANGEORREMOVEP                  5
#define IDS_ADDPROGRAMS                      6
#define IDS_ADDREMOVEWINDOWS                 7
#define IDS_CURRENTINSTALLED                 8 
#define IDS_ADDFROMCD                        9
#define IDS_CDHELP                          10
#define IDS_CDORFLOPPY                      11 
#define IDS_ADDFROMMS                       12
#define IDS_ADDWUPDATEHELP                  13
#define IDS_WINDOWSUPDATE                   14
#define IDS_LOADING                         15
#define IDS_SUPPORT                         16
#define IDS_CHANGE                          17
#define IDS_REMOVE                          18
#define IDS_CHANGEORREMOVE                  19
#define IDS_ADD                             20
#define IDS_SIZE                            21
#define IDS_SIZEHELP                        22
#define IDS_FREQUENCY                       23
#define IDS_FREQUENCYHELP                   24
#define IDS_FREQUENCYHELP1                  25
#define IDS_FREQUENCYHELP2                  26
#define IDS_TECHSUPPORT                     27
#define IDS_PUBLISHER                       28
#define IDS_VERSION                         29
#define IDS_CONTACT                         30
#define IDS_SUPPORTINFO                     31
#define IDS_README                          32
#define IDS_UPDATE                          33
#define IDS_PRODUCTID                       34
#define IDS_REGCOMPANY                      35
#define IDS_REGOWNER                        36
#define IDS_COMMENTS                        37
#define IDS_REPAIRDESC                      38
#define IDS_REPAIR                          39
#define IDS_SORTBY                          40
#define IDS_GATEGORY                        41 
#define IDS_ADDFROMNETWORK                  42
#define IDS_APPNAME                         43
#define IDS_DATELASTUSED                    44
#define IDS_ALLCATEGORIES                   45
#define IDS_HELPCHANGEORREMOVE              46
#define IDS_HELPCHANGEREMOVE                47
#define IDS_SIZEUNIT                        48
#define IDS_TERMSERVFEEDBACK                49
#define IDS_USEDREARELY                     50
#define IDS_USEDOCCASIONALLY                51
#define IDS_USEDFREQUENTLY                  52
#define IDS_ADDHELP                         54          
#define IDS_APPINSTALLED                    55
#define IDS_ARPTITLE                        56
#define IDS_WAITFEEDBACK                    57
#define IDS_EMPTYFEEDBACK                   58
#define IDS_DEFINITION                      59
#define IDS_SIZELABEL                       60
#define IDS_FREQUENCYLABEL                  61
#define IDS_LASTUSEDLABEL                   62
#define IDS_SIZETITLE                       63
#define IDS_FREQUENCYTITLE                  64
#define IDS_SUPPORTTITLE                    65
#define IDS_CONFIGURE                       66
#define IDS_OCSETUPHELP                     67
#define IDS_OCSETUPWARNING                  68
#define IDS_ADDREMOVEWIN                    69
#define IDS_WINHELP                         70
#define IDS_COMPONENTS                      71
#define IDS_SERVICELABEL                    72
#define IDS_FONTSIZEFRAME                   73
#define IDS_FONTSIZEHELP                    74
#define IDS_FONTSIZEHELPTITLE               75
#define IDS_SHORTCUTCLOSE                   76
#define IDS_SHORTCUTSORT                    77
#define IDS_SHORTCUTCDORFLOPPY              78
#define IDS_SHORTCUTWINUPDATE               79
#define IDS_SHORTCUTCATEGORY                80
#define IDS_FONTWEIGHTSEL                   82
#define IDS_FONTWEIGHTHELPTITLE             83
#define IDS_SHORTCUTCHANE                   84
#define IDS_SHORTCUTADD                     85
#define IDS_SHORTCUTWINDOWS                 86
#define IDS_HELPCHANGE                      87
#define IDS_HELPREMOVE                      88
#define IDS_PLEASEWAIT                      89
#define IDS_SORTBY_WIDTH                    90

#define IDS_TELEPHONE                       92

#define IDS_PICKAPPS                        93
#define IDS_SHORTCUTPICKAPPS                94
#define IDS_PICKINTRO                       95
#define IDS_PICKOK                          96
#define IDS_PICKCANCEL                      97
#define IDS_APPLYINGCLIENT                  98
#define IDS_SHOWINGICONS                    99
#define IDS_HIDINGICONS                    100
#define IDS_SETTINGDEFAULT                 101
#define IDS_GROUPOEM                       102
#define IDS_GROUPOEMBLURB                  103
#define IDS_GROUPMS                        104
#define IDS_GROUPMSBLURB                   105
#define IDS_GROUPNONMS                     106
#define IDS_GROUPNONMSBLURB                107
#define IDS_GROUPCUSTOM                    108
#define IDS_GROUPCUSTOMBLURB               109
#define IDS_CLIENTWEB                      110
#define IDS_KEEPWEB                        111
#define IDS_PICKWEB                        112
#define IDS_CLIENTMAIL                     113
#define IDS_KEEPMAIL                       114
#define IDS_PICKMAIL                       115
#define IDS_CLIENTMEDIA                    116
#define IDS_KEEPMEDIA                      117
#define IDS_PICKMEDIA                      118
#define IDS_CLIENTIM                       119
#define IDS_KEEPIM                         120
#define IDS_PICKIM                         121
#define IDS_CLIENTJAVAVM                   122
#define IDS_KEEPJAVAVM                     123
#define IDS_PICKJAVAVM                     124
#define IDS_SHOWAPP                        125
#define IDS_ALSOSHOW                       126
#define IDS_HIDE                           127
#define IDS_ADDITIONALCLIENTFORMAT         128
#define IDS_NOTADMIN                       129
#define IDS_CONFIGUREPROGRAMS              130 // used by syssetup.inx
#define IDS_CONFIGUREPROGRAMSTIP           131 // used by syssetup.inx
#define IDS_CUSTOMWEB                      132
#define IDS_CUSTOMMAIL                     133
#define IDS_CUSTOMMEDIA                    134
#define IDS_CUSTOMIM                       135
#define IDS_CUSTOMJAVAVM                   136
#define IDS_KEEPMSMAIL                     137

#define IDB_PROGRESS                       100
#define IDB_ARP0                           101
#define IDB_ARP1                           102
#define IDB_ARP2                           103
#define IDB_ARP3                           104
// -- not used - recycle me --
#define IDB_ARPX                           106
#define IDB_ARPX1                          107

#define IDR_ARP                            300
#define IDR_ARPSTYLESTD                    301
#define IDR_ARPSTYLETHEME                  302

// hTheme identification from within the resource
#define THISDLLHINSTANCE                   0
#define XPSP1HINSTANCE                     1
#define SHELLSTYLEHINSTANCE                2
#define FIRSTHTHEME                        3
#define BUTTONHTHEME                       3
#define SCROLLBARHTHEME                    4
#define TOOLBARHTHEME                      5
#define LASTHTHEME                         5

#define IDS_BYTES           0x3000
#define IDS_ORDERKB         0x3001
#define IDS_ORDERMB         0x3002
#define IDS_ORDERGB         0x3003
#define IDS_ORDERTB         0x3004
#define IDS_ORDERPB         0x3005
#define IDS_ORDEREB         0x3006

#define IDS_UNKNOWN         0x3010
#define IDS_NOTUSED         0x3011
#define IDS_LABEL_SIZE      0x3012
#define IDS_LABEL_INSTALLEDON 0x3013
#define IDS_LABEL_TIMESUSED 0x3014
#define IDS_LABEL_LASTUSED  0x3015
#define IDS_RARELY          0x3016
#define IDS_SOMETIMES       0x3017
#define IDS_OFTEN           0x3018
#define IDS_RESTRICTION     0x3019
#define IDS_EXPIRED         0x3020
#define IDS_PASSASSIGNED    0x3021
#define IDS_PASSEXPIRED     0x3022
#define IDS_ADDLATER        0x3023
#define IDS_INSTALLED       0x3024
#define IDS_CONFIRM_REMOVE  0x3025
#define IDS_WINUPD_URL      0x3026

#define IDC_PICKER          0x3050
#define IDC_ADDLATER        0x3051
#define IDC_UNSCHEDULE      0x3052
#define DLG_ADDLATER        0x3100

////////////////////////////////////////////////////////////////////////////
//
//  Macros for the *.ui files.
//

// Alignments for rowlayout (second and third parameters)
// These are dups of the values in duilayout.h but we need to repeat
// them so the resource compiler can see them.

#define ALIGN_LEFT      0
#define ALIGN_TOP       0
#define ALIGN_RIGHT     1
#define ALIGN_BOTTOM    1
#define ALIGN_CENTER    2
#define ALIGN_JUSTIFY   3

// Rowlayout numbers (arbitrary but must be distinct)
// with optional horizontal and vertical alignment
#define RL_INSTITEM         22                          // ARP installed item
#define RL_CUSTOMCLIENT     23                          // custom clients table
#define RL_CLIENTBLOCK      24,ALIGN_JUSTIFY,ALIGN_JUSTIFY// ms and non-ms table

// Object roles. These are dups of the values in oleacc.h but we need
// to repeat them so the resource compiler can see them.  What's more,
// we need to declare them as plain integers because the DUI parser
// will barf on parenthesized hex.

#define DUIROLE_STATICTEXT      41
#define DUIROLE_PUSHBUTTON      43
#define DUIROLE_CHECKBUTTON     44
#define DUIROLE_RADIOBUTTON     45
#define DUIROLE_COMBOBOX        46
#define DUIROLE_OUTLINEBUTTON   64

//
//  Common attribute text for static text elements.
//
#define ATTR_STATICTEXT(ids) \
    accessible=true accRole=DUIROLE_STATICTEXT \
    accName=rcstr(ids) content=rcstr(ids)

#define ATTR_STATICTEXTSP1(ids) \
    accessible=true accRole=DUIROLE_STATICTEXT \
    accName=rcstr(ids) content=rcstrsp1(ids)

//  Stolen from shellstyle\common.h

#define IDB_UP                       100
#define IDB_UPHOT                    101
#define IDB_DOWN                     102
#define IDB_DOWNHOT                  103
#define IDB_UPMAIN                   104
#define IDB_UPHOTMAIN                105
#define IDB_DOWNMAIN                 106
#define IDB_DOWNHOTMAIN              107

//
//  Common attribute text for big static text elements.
//  DUI cannot load text strings bigger than MAX_PATH, so we must do it
//  manually.
//

#define ATTR_BIGSTATICTEXT(ids) \
    accessible=true accRole=DUIROLE_STATICTEXT \
    stringresid=ids

#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\setup.c ===
//
//  Setup.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"



void _inline InitSetupWiz(HWND hDlg, LPARAM lParam)
{
    InitWizSheet(hDlg, lParam, 0);
}


//
//  Loads the specified resource ID string and replaces all ';' characters
//  with NULL.        The end of the string will be doubly null-teminated.
//

BOOL LoadAndStrip(int id, LPTSTR lpsz, int cbstr)
{
    ASSERT(lpsz);
    ASSERT(cbstr != 0);

    if (!LoadString(g_hinst, id, lpsz, cbstr-1))
    {
        return FALSE;
    }
    else
    {
        while (*lpsz)
        {
            if (*lpsz == TEXT('@'))
            {
                *lpsz = 0;
                lpsz++;
            }
            else
            {
                lpsz = CharNext(lpsz);
            }
        }
        *(lpsz+1) = 0;
        return TRUE;
    }
}


//
//  Skips to the first charcter of the next string in a list of null-terminated
//  strings.  The caller should check to see if the pointer returned points to
//  a null.  If so, the end of the table has been reached.
//

LPTSTR SkipStr(LPTSTR lpsz)
{
    while (*lpsz)
    {
        lpsz = CharNext(lpsz);
    }
    lpsz++;

    return(lpsz);
}


void SetStaticStr(HWND hCtl, int id)
{
    TCHAR szText[MAX_PATH];

    LoadString(g_hinst, id, szText, ARRAYSIZE(szText));

    Static_SetText(hCtl, szText);
}


void FreeIcon(HWND hDlg)
{
    HICON hicon = Static_SetIcon(GetDlgItem(hDlg, IDC_SEARCHICON), NULL);

    if (hicon)
    {
        DestroyIcon(hicon);
    }
}


//
//  ProgramExists returns TRUE if the specified file exists.  This function
//  accepts wildcards, and if a file matches the specified name then
//  the file name buffer will be updated to the actual name of the first
//  matching file.  This allows FindBestSetupPrg to pass in *setup to find
//  programs such as WPSETUP.EXE.
//
//  This function assumes that szFindName is of size MAX_PATH.
//

BOOL ProgramExists(LPTSTR lpszFindName, UINT cchFindName)
{
    HANDLE hfind;
    WIN32_FIND_DATA fd;

    hfind = FindFirstFile(lpszFindName, &fd);

    if (hfind == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    FindClose(hfind);

    StringCchCopy(lpszFindName+3, cchFindName-3, fd.cFileName);

    return(TRUE);
}


//
//  This function searches for the "best" setup program.  Once a windows app
//  with the appropriate name is found it stops.  If it finds a install/setup
//  program that is a DOS program, it remembers the first one, but continues
//  searching for a Windows setup program.
//  Games like Math Rabbit have a DOS Install.Exe and a Windows Setup.Exe.
//

BOOL FindBestSetupPrg(LPTSTR lpszExeName, UINT cchExeName, LPTSTR lpszDriveRoot, LPTSTR lpszSpecialCase,
                      LPTSTR lpszAppNames, LPTSTR lpszExtensions)
{
    LPTSTR  lpszCurApp, lpszCurExt;
    TCHAR   szThisOne[MAX_PATH];

    *lpszExeName = 0;

    //
    //        Look for special-case programs first
    //

    lpszCurApp = lpszSpecialCase;

    while(*lpszCurApp)
    {
        StringCchPrintf(szThisOne, ARRAYSIZE(szThisOne), TEXT("%s%s"), lpszDriveRoot, lpszCurApp);

        if (ProgramExists(szThisOne, ARRAYSIZE(szThisOne)))
        {
            StringCchCopy(lpszExeName, cchExeName, szThisOne);
            return(TRUE);
        }

        lpszCurApp = SkipStr(lpszCurApp);
    }

    //
    //        Now look for generic setup program names
    //

    lpszCurApp = lpszAppNames;

    while (*lpszCurApp)
    {
        lpszCurExt = lpszExtensions;

        while (*lpszCurExt)
        {
            StringCchPrintf(szThisOne, ARRAYSIZE(szThisOne), TEXT("%s%s.%s"), lpszDriveRoot, lpszCurApp, lpszCurExt);

            if (ProgramExists(szThisOne, ARRAYSIZE(szThisOne)))
            {
                BOOL fIsWinApp = HIWORD(SHGetFileInfo(szThisOne, 0, NULL,
                                                      0, SHGFI_EXETYPE)) > 0;

                if (*lpszExeName == 0 || fIsWinApp)
                {
                    StringCchCopy(lpszExeName, cchExeName, szThisOne);
                }

                if (fIsWinApp)
                {
                    return(TRUE);
                }
            }

            lpszCurExt = SkipStr(lpszCurExt);
        }

        lpszCurApp = SkipStr(lpszCurApp);
    }

    return(*lpszExeName != 0);
}


//
//  Gets information about the specified file/drive root and sets the
//  icon and description fields in the dialog.
//

void _inline UpdateFileInfo(LPWIZDATA lpwd, LPTSTR lpszFileName)
{
    HWND        hKiddie;
    HICON       hOldIcon;
    SHFILEINFO  fi;
    DWORD_PTR   pdwRes;

    pdwRes = SHGetFileInfo(lpszFileName, 0, &fi, sizeof(fi),
                           SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_LARGEICON);
    
    if (pdwRes)
    {
        hKiddie = GetDlgItem(lpwd->hwnd, IDC_SEARCHICON);

        hOldIcon = Static_SetIcon(hKiddie, fi.hIcon);

        if (hOldIcon)
        {
            DestroyIcon(hOldIcon);
        }

        UpdateWindow(hKiddie);

        hKiddie = GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME);

        Static_SetText(hKiddie, fi.szDisplayName);

        UpdateWindow(hKiddie);
    }
}


//
//  Search for the setup program
//

BOOL SetupNextPressed(LPWIZDATA lpwd)
{
    int   iDrive, iDrvType;
    BOOL  fFoundExe = FALSE;
    HWND  hMainMsg = GetDlgItem(lpwd->hwnd, IDC_SETUPMSG);
    HWND  hSetupName = GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME);
    TCHAR szAppNames[MAX_PATH];
    TCHAR szExtensions[100];
    TCHAR szSpecialCase[MAX_PATH];
    TCHAR szDriveRoot[4];

    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //BOOL fFoundDisk = FALSE;

    lpwd->szExeName[0] = 0;        // Reset any existing name

    SetStaticStr(hMainMsg, IDS_SEARCHING);

    LoadAndStrip(IDS_SETUPPRGNAMES, szAppNames,    ARRAYSIZE(szAppNames));
    LoadAndStrip(IDS_EXTENSIONS,    szExtensions,  ARRAYSIZE(szExtensions));
    LoadAndStrip(IDS_SPECIALCASE,   szSpecialCase, ARRAYSIZE(szSpecialCase));

    for (iDrive = 0; (!fFoundExe) && (iDrive < 26); iDrive++)
    {
        iDrvType = DriveType(iDrive);

        if ((iDrvType == DRIVE_REMOVABLE) || (iDrvType == DRIVE_CDROM))
        {

            PathBuildRoot(szDriveRoot, iDrive);
            UpdateFileInfo(lpwd, szDriveRoot);
            if (PathFileExists(szDriveRoot))
            {
                //fFoundDisk = TRUE;

                fFoundExe = FindBestSetupPrg(lpwd->szExeName, ARRAYSIZE(lpwd->szExeName), szDriveRoot,
                                             szSpecialCase,
                                             szAppNames, szExtensions);
            }
        }
    }

    FreeIcon(lpwd->hwnd);
    SetCursor(hcurOld);

    return(fFoundExe);
}


void SetupSetToDefault(LPWIZDATA lpwd)
{
    SetStaticStr(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), IDS_INSERTDISK);

    Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME), NULL);

    FreeIcon(lpwd->hwnd);

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), PSWIZB_NEXT);

    //
    // To make sure that the next button always has the focus, we post
    // this message that sets the wiz buttons AFTER we're active.  We have
    // to do the one above to make sure that Back is disabled to avoid any
    // random window where the back button could be hit.
    //

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}



BOOL_PTR CALLBACK SetupDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            SetupSetToDefault(lpwd);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            SetupNextPressed(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WMPRIV_POKEFOCUS:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            break;

        case WM_INITDIALOG:
            InitSetupWiz(hDlg, lParam);
            break;

        case WM_DESTROY:
            FreeIcon(hDlg);
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;

}  // SetupdlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\setupenum.h ===
#ifndef __SETUPENUM_H_
#define __SETUPENUM_H_

class COCSetupApp
{
public:

    COCSetupApp();
    ~COCSetupApp();
    
    BOOL GetAppInfo(APPINFODATA *pai);
    BOOL ReadFromKey(HKEY hkey);
    BOOL Run();

    TCHAR _szDisplayName[MAX_PATH];

protected:
    TCHAR _szApp[MAX_PATH];
    TCHAR _szArgs[MAX_PATH];
};

class COCSetupEnum
{
public:
    COCSetupEnum();
    ~COCSetupEnum();

    BOOL EnumOCSetupItems();
    BOOL Next(COCSetupApp **);

    static BOOL s_OCSetupNeeded();

protected:
    HKEY _hkeyRoot;
    int _iRegEnumIndex;     // used to walk through the items
};

#endif //__SETUPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\slowfind.h ===
#ifndef __SLOWFIND_H_
#define __SLOWFIND_H_

#include "appsize.h"

#define MAX_PROGFILES_SEARCH_DEPTH 1
#define MAX_STARTMENU_SEARCH_DEPTH 2

HRESULT GetShortcutTarget(LPCWSTR pszPath, LPTSTR pszTarget, UINT cch);
BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);

class CStartMenuAppFinder : public CAppFolderSize
{
    friend BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);
public:
    CStartMenuAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    
    HRESULT SearchInFolder(LPCTSTR pszStart);

protected:
    BOOL _MatchSMLinkWithApp(LPCTSTR pszLnkFile);

    LPCTSTR _pszFullName;
    LPCTSTR _pszShortName;

    // The Result
    LPTSTR  _pszFolder;

    // Best match found
    int _iBest;
}; 


#endif // _SLOWFIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SELFREGNAME     = $(O)\selfreg_appwiz.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

# Don't include core Windows resource header
C_DEFINES       = $(C_DEFINES) -DNOWINRES

LINKER_FLAGS = $(LINKER_FLAGS) -VERBOSE -ignore:4049,4217

TARGETNAME    = appwiz
TARGETPATH    = obj
TARGETTYPE    = DYNLINK
TARGETEXT     = cpl

# Note:  Do >not< link to ntdll.  Win95 has an extremely minimal
#        implementation of ntdll.
TARGETLIBS      = \
                  $(WINDOWS_LIB_PATH)\obj\duser.lib          \
!if $(FREEBUILD)
                  $(WINDOWS_LIB_PATH)\directui.lib                   \
!else
                  $(WINDOWS_LIB_PATH)\directuid.lib                  \
!endif
                  $(SDK_LIB_PATH)\GdiPlus.lib                        \
                  $(SDK_LIB_PATH)\msimg32.lib                        \
                  $(SDK_LIB_PATH)\oleacc.lib                         \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\msi.lib           \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\winsta.lib        \
                  $(SDK_LIB_PATH)\uxtheme.lib       \
                  $(DS_LIB_PATH)\msgina.lib         \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(CCSHELL_DIR)\lib\$O\shguidp.lib \
                  $(CCSHELL_DIR)\lib\$O\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$O\ieguidp.lib \
                  $(SHELL_LIB_PATH)\shfusion.lib     \
                  $(SDK_LIB_PATH)\kernl32p.lib     \
                  $(SHELL_LIB_PATH)\shell32p.lib

DELAYLOAD = OLE32.DLL;OLEAUT32.DLL;WINSTA.DLL;MSGINA.DLL
DLOAD_ERROR_HANDLER=KERNEL32.DLL

# nt5api must be finished before this one
SYNCHRONIZE_DRAIN=1

LINKLIBS        = $(CCSHELL_DIR)\lib\$O\stock.lib \
                  ..\nt5api\$O\apithk.lib   \
                  ..\ntc\$O\srcc.lib

USE_MSVCRT      = 1

DLLENTRY        = _DllMainCRTStartup

USE_STATIC_ATL  = 1

DLLDEF          = $(O)\appwiz.def
DLLBASE         = 0x71900000

# For RC to find shappmgr.TLB files, $(O) must come first
INCLUDES        = $(O);$(PROJECT_ROOT)\lib\$(O);$(WINDOWS_INC_PATH)\DUser;$(INCLUDES);$(DS_INC_PATH);$(SDK_INC_PATH)

# Pass zero stuff
NTTARGETFILE0   = $(SELFREGNAME)

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\priv.h

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)


# Maintain the sources list in the alphabetical order
SOURCES         = \
                  ..\arp.cpp       \
                  ..\appmgr.cpp    \
                  ..\appsize.cpp   \
                  ..\appwiz.rc     \
                  ..\awthunk.c     \
                  ..\darpub.cpp    \
                  ..\darenum.cpp   \
                  ..\darapp.cpp    \
                  ..\debug.cpp     \
                  ..\dlinst.cpp    \
                  ..\dll.cpp       \
                  ..\dlldatax.c    \
                  ..\findapp.cpp   \
                  ..\instapp.cpp   \
                  ..\instenum.cpp  \
                  ..\pubenum.cpp   \
                  ..\sccls.c       \
                  ..\setupenum.cpp \
                  ..\shappmgrp.idl \
                  ..\shappmgrp_i.c \
                  ..\slowfind.cpp  \
                  ..\stdafx.cpp    \
                  ..\tasks.cpp     \
                  ..\util.cpp 

# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=123 
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\setupenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: setupenum.cpp
//
// The current order of enumeration is whatever order we read from the registry
//
// History:
//         6-11-98  by toddb
//------------------------------------------------------------------------
#include "priv.h"

#include <shellp.h>     // for IsUserAnAdmin
#include "setupenum.h"
#include "appwizid.h"

#define c_szOCSetupKey  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList")

//-----------------------------------------------------------------------
// OCSetupApp
//-----------------------------------------------------------------------

COCSetupApp::COCSetupApp()
{
    // This must be heap alloced so everything should be zero'ed out.
    // Make sure this wasn't stack alloced using these asserts:
    ASSERT(0 == _szDisplayName[0]);
    ASSERT(0 == _szApp[0]);
    ASSERT(0 == _szArgs[0]);
}

COCSetupApp::~COCSetupApp()
{
}

//-----------------------------------------------------------------------
// GetAppInfo
//
// Fills in the only valid field in our psuedo APPINFODATA structure.

BOOL COCSetupApp::GetAppInfo(PAPPINFODATA pai)
{
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return FALSE;

    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDup(_szDisplayName, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }
    return TRUE;
}

//-----------------------------------------------------------------------
// ReadFromKey
//
// This function reads the actual data from the given reg key.  It returns
// TRUE if all required fields contained string data.

BOOL COCSetupApp::ReadFromKey( HKEY hkey )
{
    DWORD dwType;
    DWORD dwSize;

    dwSize = sizeof(_szDisplayName);
    if ( ERROR_SUCCESS != RegQueryValueEx( hkey, TEXT("Title"), 0, &dwType, (LPBYTE)_szDisplayName, &dwSize ) ||
         dwType != REG_SZ )
    {
        // DisplayName is required
        return FALSE;
    }

    dwSize = sizeof(_szApp);
    if ( ERROR_SUCCESS == RegQueryValueEx( hkey, TEXT("ConfigCommand"), 0, &dwType, (LPBYTE)_szApp, &dwSize ) &&
         (dwType == REG_SZ || dwType == REG_EXPAND_SZ) )
    {
        if ( dwType == REG_EXPAND_SZ )
        {
            TCHAR szBuf[MAX_PATH];
            ExpandEnvironmentStrings(_szApp, szBuf, ARRAYSIZE(szBuf));
            lstrcpyn(_szApp, szBuf, ARRAYSIZE(_szApp));
        }
    }
    else
    {
        // ConfigCommand is required
        return FALSE;
    }

    dwSize = sizeof(_szArgs);
    if ( ERROR_SUCCESS == RegQueryValueEx( hkey, TEXT("ConfigArgs"), 0, &dwType, (LPBYTE)_szArgs, &dwSize ) &&
         (dwType == REG_SZ || dwType == REG_EXPAND_SZ) )
    {
        if ( dwType == REG_EXPAND_SZ )
        {
            TCHAR szBuf[MAX_PATH];
            ExpandEnvironmentStrings(_szArgs, szBuf, ARRAYSIZE(szBuf));
            lstrcpyn(_szArgs, szBuf, ARRAYSIZE(_szArgs));
        }
    }
    else
    {
        // This is optional so we don't fail.  Instead simply insure that _szArgs is an empty string.
        _szArgs[0] = 0;
    }

    return TRUE;
}

BOOL COCSetupApp::Run()
{
    // REARCHITECT: (stephstm, 03/17/99) we should probably wait on a job object in case
    // the spawned process spawns some other process(es) and then exits before them.

    BOOL fRet = FALSE;
    SHELLEXECUTEINFO sei = {0};

    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = GetDesktopWindow();
    sei.lpFile = _szApp;
    sei.lpParameters = _szArgs[0] ? _szArgs : NULL;
    sei.nShow = SW_SHOWDEFAULT; 

    fRet = ShellExecuteEx(&sei);

    if (fRet)
    {
        DWORD dwRet;

        do
        {
            MSG msg;

            // Get and process the messages!
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // MsgWaitForMultipleObjects can fail with -1 being returned!
            dwRet = MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT);
        }
        while ((WAIT_OBJECT_0 != dwRet) && (-1 != dwRet));

        // Did MsgWait... failed?
        if (-1 == dwRet)
        {
            // Yes, kill the process
            TerminateProcess(sei.hProcess, 0);

            fRet = FALSE;
        }

        CloseHandle(sei.hProcess);
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, sei.hwnd,  MAKEINTRESOURCE( IDS_CONFIGURE_FAILED ),
                             MAKEINTRESOURCE( IDS_NAME ),
                             MB_OK | MB_ICONEXCLAMATION);
    }

    return fRet;
}


//-----------------------------------------------------------------------
// OCSetupEnum
//-----------------------------------------------------------------------

COCSetupEnum::COCSetupEnum()
{
    _hkeyRoot = 0;
    _iRegEnumIndex = -1;
}

COCSetupEnum::~COCSetupEnum()
{
    if ( _hkeyRoot )
    {
        RegCloseKey( _hkeyRoot );
    }
}

//-----------------------------------------------------------------------
// s_OCSetupNeeded
//
// This checks for the neccessaary conditions to display the OC Setup portion of the ARP.
// This section is only shown if the current user is a member of the administrators group
// AND there are any items listed in the registry that need to be displayed.

BOOL COCSetupEnum::s_OCSetupNeeded()
{
    BOOL fResult = FALSE;
    HKEY hkey;
    // Temporarily open the reg key to see if it exists and has any sub keys
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szOCSetupKey, 0, KEY_READ, &hkey ) )
    {
        TCHAR szBuf[MAX_PATH];
        if ( ERROR_SUCCESS == RegEnumKey( hkey, 0, szBuf, ARRAYSIZE(szBuf) ) )
        {
            // Yes, there are OCSetup items, but is the current user an administrator?
            if ( IsUserAnAdmin() )
            {
                fResult = TRUE;
            }
        }
        RegCloseKey( hkey );
    }
    return fResult;
}

//-----------------------------------------------------------------------
// EnumOCSetupItems
//
// This begins the enumeration by opening the required registry key.  This does
// not attempt to read any of the sub items so there is no garentee that the
// first call to Next() will succeed.

BOOL COCSetupEnum::EnumOCSetupItems()
{
    ASSERT( NULL == _hkeyRoot );
    // Open the reg key, return true if it's open.  We leave the key open until
    // our destructor is called since we need this key to do the enumeration.
    if ( ERROR_SUCCESS == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            c_szOCSetupKey,
            0,
            KEY_READ,
            &_hkeyRoot ) )
    {
        return TRUE;
    }
    return FALSE;
}

//-----------------------------------------------------------------------
// Next
//
// Reads the data from the next sub key of _hkeyRoot and returns the data in the
// out pointer.  Returns TRUE if the out pointer is a valid COCSetupApp object.

BOOL COCSetupEnum::Next(COCSetupApp **ppocsa)
{
    HKEY hkeySub;
    TCHAR szSubKeyName[MAX_PATH];

    // We open each subkey of the root key and attempt to read an OCSetup item from the subkey.
    if ( ERROR_SUCCESS == RegEnumKey( _hkeyRoot, ++_iRegEnumIndex, szSubKeyName, ARRAYSIZE(szSubKeyName) ) )
    {
        if ( ERROR_SUCCESS == RegOpenKeyEx( _hkeyRoot, szSubKeyName, 0, KEY_READ, &hkeySub ) )
        {
            *ppocsa = new COCSetupApp();
            if ( *ppocsa )
            {
                if ( (*ppocsa)->ReadFromKey( hkeySub ) )
                {
                    RegCloseKey( hkeySub );
                    return TRUE;
                }

                delete *ppocsa;
            }
            RegCloseKey( hkeySub );
        }
        // fall through
    }

    *ppocsa = NULL;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "priv.h"

#include "stdafx.h"


// HACKHACK (scotth): windowsx.h #define SubclassWindow.  ATL 2.1 headers
//  (namely atlwin.h and atlwin.cpp) have a member function with the
//  same name.
#ifdef SubclassWindow
#undef SubclassWindow
#endif


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\srcc.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

INCLUDES        = $(INCLUDES);..\winnt\$(O)


NO_BROWSER_FILE = 1
USE_NATIVE_EH=1
USE_STL=1

TARGETNAME      = srcc
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

PRECOMPILED_INCLUDE = ..\priv.h

SOURCES         = \
                  ..\applist.c  \
                  ..\appwiz.c   \
                  ..\browse.c   \
                  ..\dump.c     \
                  ..\folder.c   \
                  ..\gettitle.c \
                  ..\link.c     \
                  ..\pickicon.c \
                  ..\setup.c    \
                  ..\scripts.cpp \
                  ..\chgusr.c




 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ControlPanel.ApplicationWizard
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT



//#define _WIN32_WINNT 0x0400       // (scotth): Use what is defined in priv.h
#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities
#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\slowfind.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: slowfind.cpp
//
// Implements CProgFilesAppFinder
//            CStartMenuAppFinder
// History:
//         3-01-98  by dli implemented CProgFilesAppFinder
//         4-15-98  by dli implemented CStartMenuAppFinder
//------------------------------------------------------------------------
#include "priv.h"

#include "appsize.h"
#include "findapp.h"
#include "slowfind.h"


// Todo: Remember the find result somewhere in the registry or cache it in code
// so that we don't waste time repeatedly computing it. 

//
//  App Folder Finder tree walker callback class
//
class CProgFilesAppFinder : public CAppFolderSize
{
    friend BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);
public:
    CProgFilesAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, BOOL * pfFound, LPTSTR pszFolder);

    // *** IShellTreeWalkerCallBack methods ***
    virtual STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

    HRESULT SearchInFolder(LPCTSTR pszStart);
    void    SetRootSearch(BOOL bRootSearch);
protected:

    LPCTSTR _pszFullName;
    LPCTSTR _pszShortName;

    // The Result
    LPTSTR  _pszFolder;

    // Best match found
    int _iBest;
    int _iCurDepth;

    // found it or not?
    BOOL * _pfFound;

    // are we searching from root dirs like c:?
    BOOL _fRootSearch;

    // system directory used by the root search
    TCHAR _szSystemDir[MAX_PATH];
}; 

CProgFilesAppFinder::CProgFilesAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, BOOL * pfFound, LPTSTR pszFolder) :
   CAppFolderSize(NULL), _pszFullName(pszFullName), _pszShortName(pszShortName), _pfFound(pfFound), _pszFolder(pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    
    ASSERT(pfFound);
    ASSERT(*pfFound == FALSE);
    ASSERT(_fRootSearch == FALSE);
}


void CProgFilesAppFinder::SetRootSearch(BOOL bRootSearch)
{
    _fRootSearch = bRootSearch;
    GetSystemDirectory(_szSystemDir, ARRAYSIZE(_szSystemDir));
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CProgFilesAppFinder::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    TCHAR szFolder[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFolder, -1));

    StringCchCopy(szFolder, ARRAYSIZE(szFolder), pwszFolder);

    TraceMsg(TF_SLOWFIND, "Enter Folder: %s -- %s  Depth %d", _pszFullName, szFolder, ptws->nDepth);

    LPTSTR pszName = PathFindFileName(szFolder);

    // Don't go into common files or where we already have seen
    // FEATURE: These should be in the registry.
    if (_fRootSearch)
    {
        if (!lstrcmpi(pszName, TEXT("Program Files")) || !lstrcmpi(pszName, TEXT("Windows")) ||
            !lstrcmpi(pszName, TEXT("Temp")) || !lstrcmpi(pszName, TEXT("Users")) || StrStrI(pszName, TEXT("WINNT")) ||
            !lstrcmpi(_szSystemDir, szFolder))
            return S_FALSE;
    }
    else if (!lstrcmpi(pszName, TEXT("Common Files")) || !lstrcmpi(pszName, TEXT("Windows NT"))
             || !lstrcmpi(pszName, TEXT("Plus!")) || !lstrcmpi(pszName, TEXT("Uninstall Information")))
        return S_FALSE;

    if (pszName)
    {
        int iMatch = MatchAppName(pszName, _pszFullName, _pszShortName, TRUE);

        // The deeper the match folder is down the tree, the better a match
        // it is.
        if ((iMatch > _iBest) || ((iMatch > 0) && (ptws->nDepth > _iCurDepth)))
        {
            _iBest = iMatch;
            _iCurDepth = ptws->nDepth;
            
            TraceMsg(TF_SLOWFIND, "Slow Match Found: %s -- %s Depth %d", _pszFullName, szFolder, _iCurDepth); 
            ASSERT(IS_VALID_STRING_PTR(_pszFolder, -1));
            lstrcpy(_pszFolder, szFolder);

            if (iMatch == MATCH_LEVEL_HIGH)
            {
                *_pfFound = TRUE;
                hres = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hres))
        hres = CAppFolderSize::EnterFolder(pwszFolder, ptws, pwfd);

    return hres;
}

//
// Wrapper around WalkTree
//
HRESULT CProgFilesAppFinder::SearchInFolder(LPCTSTR pszStart)
{
    HRESULT hres = E_FAIL;
    WCHAR wszDir[MAX_PATH];
    DWORD dwSearchFlags = WT_MAXDEPTH | WT_NOTIFYFOLDERENTER | WT_FOLDERONLY;

    SHTCharToUnicode(pszStart, wszDir, SIZECHARS(wszDir));

    if (_pstw)
        hres = _pstw->WalkTree(dwSearchFlags, wszDir, NULL, MAX_PROGFILES_SEARCH_DEPTH, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}

CStartMenuAppFinder::CStartMenuAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder) :
   CAppFolderSize(NULL), _pszFullName(pszFullName), _pszShortName(pszShortName), _pszFolder(pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    
}

//
// get the target of a shortcut. 
//
// NOTE: pszPath is WCHAR string
//
HRESULT GetShortcutTarget(LPCWSTR pszLinkPath, LPTSTR pszTargetPath, UINT cchTargetPath)
{
    IShellLink* psl;
    HRESULT hres = E_FAIL;
    HRESULT hresT = LoadFromFile(CLSID_ShellLink, pszLinkPath, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hresT)) 
    { 
        IShellLinkDataList* psldl;
        hresT = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl));
        if (SUCCEEDED(hresT)) 
        {
            EXP_DARWIN_LINK* pexpDarwin;
            BOOL bDarwin = FALSE;
            hresT = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
            if (SUCCEEDED(hresT))
            {
                // This is a darwin link, so we return S_FALSE here. 
                LocalFree(pexpDarwin);
                bDarwin = TRUE;
            }
            
            hresT = psl->GetPath(pszTargetPath, cchTargetPath, NULL, NULL);
            if (hresT == S_OK)
            {
                // Return S_FALSE for the darwin apps. 
                hres = bDarwin ? S_FALSE : hresT;
            }
            
            psldl->Release();
        }
        psl->Release();
    }

    return hres;
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CStartMenuAppFinder::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    TCHAR szFolder[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFolder, -1));

    SHUnicodeToTChar(pwszFolder, szFolder, SIZECHARS(szFolder));

    LPTSTR pszName = PathFindFileName(szFolder);

    // Skip menus like the "Administrative Tools" and the "Accessories"
    // FEATURE (scotth): these strings should be resourced-based
    if (FindSubWord(pszName, TEXT("Administrative")) || 
        FindSubWord(pszName, TEXT("Accessories")))
    {
        return  S_FALSE;
    }
    return CAppFolderSize::EnterFolder(pwszFolder, ptws, pwfd);
}


/*-------------------------------------------------------------------------
Purpose: Checks if the given shortcut filename closely matches this
         app's fullname or shortname.  Returns TRUE if it does.
*/
BOOL CStartMenuAppFinder::_MatchSMLinkWithApp(LPCTSTR pszLnkFile)
{
    TCHAR szLnkFile[MAX_PATH];
    
    ASSERT(IS_VALID_STRING_PTR(pszLnkFile, -1));
    
    lstrcpyn(szLnkFile, pszLnkFile, SIZECHARS(szLnkFile));
    LPTSTR pszFileName = PathFindFileName(szLnkFile);
    PathRemoveExtension(pszFileName);
    
    if (MATCH_LEVEL_NORMAL <= MatchAppName(pszFileName, _pszFullName, _pszShortName, FALSE))
        return TRUE;
    
    PathRemoveFileSpec(szLnkFile);
    LPTSTR pszDirName = PathFindFileName(szLnkFile);
    if (MatchAppName(pszFileName, _pszFullName, _pszShortName, FALSE) >= MATCH_LEVEL_NORMAL)
        return TRUE;
    
    return FALSE;
}

//
// IShellTreeWalkerCallBack::FoundFile
//
HRESULT CStartMenuAppFinder::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    TCHAR szLnkFile[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    SHUnicodeToTChar(pwszFile, szLnkFile, ARRAYSIZE(szLnkFile));
    TraceMsg(TF_SLOWFIND, "CSMAF:Lnk %s -- %s %s", _pszFullName, szLnkFile);

    if (!_MatchSMLinkWithApp(szLnkFile))
        return S_FALSE;

    
    TCHAR szTargetFile[MAX_PATH];
    HRESULT hresT = GetShortcutTarget(pwszFile, szTargetFile, ARRAYSIZE(szTargetFile));
    if (hresT == S_OK) 
    {
        if(!PathIsRoot(szTargetFile) && !PathIsUnderWindows(szTargetFile) && !PathIsSetup(szTargetFile, 3)
           && !PathIsCommonFiles(szTargetFile))
        {
            TraceMsg(TF_SLOWFIND, "CSMAF:Target %s -- %s %s", _pszFullName, szTargetFile);
            PathRemoveFileSpec(szTargetFile);
            if (!PathIsRoot(szTargetFile))
            {
                int iMatch = FindBestMatch(szTargetFile, _pszFullName, _pszShortName, FALSE, _pszFolder);
                // The deeper the match folder is down the tree, the better a match
                // it is.
                if (iMatch > _iBest)
                {
                    _iBest = iMatch;

                    ASSERT(IS_VALID_STRING_PTR(_pszFolder, -1));
                    ASSERT(PathIsPrefix(_pszFolder, szTargetFile));
                    TraceMsg(TF_SLOWFIND, "CSMAF: Slow Match Found: %s -- %s", _pszFullName, szLnkFile); 

                    if (iMatch == MATCH_LEVEL_HIGH)
                        hres = E_FAIL;
                }
            }
        }
    }
    
    if (SUCCEEDED(hres))
        hres = CAppFolderSize::FoundFile(pwszFile, ptws, pwfd);

    return hres;
}

//
// Wrapper around WalkTree
//
HRESULT CStartMenuAppFinder::SearchInFolder(LPCTSTR pszStart)
{
    HRESULT hres = E_FAIL;
    DWORD dwSearchFlags = WT_MAXDEPTH | WT_NOTIFYFOLDERENTER | WT_FOLDERFIRST;

    if (_pstw)
        hres = _pstw->WalkTree(dwSearchFlags, pszStart, L"*.lnk", MAX_STARTMENU_SEARCH_DEPTH, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}

//
// NOTE: assuming pszFolder was allocated MAX_PATH long
// pszFolder will contain the result as return
// 
BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));

    int iMatch = MATCH_LEVEL_NOMATCH;
    
    // Search from the start menu
    CStartMenuAppFinder * psmaf = new CStartMenuAppFinder(pszFullName, pszShortName, pszFolder);
    if (psmaf)
    {
        if (SUCCEEDED(psmaf->Initialize()))
        {
            TCHAR szStartMenu[MAX_PATH];
            if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_COMMON_STARTMENU, FALSE))
                psmaf->SearchInFolder(szStartMenu);

            if ((psmaf->_iBest == MATCH_LEVEL_NOMATCH) && (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_STARTMENU, FALSE)))
                psmaf->SearchInFolder(szStartMenu);

            iMatch = psmaf->_iBest;
        }
        psmaf->Release();
    }

    if (iMatch == MATCH_LEVEL_NOMATCH)
    {
        BOOL fFound = FALSE;

        // Start searching from stratch, no hints on where to start what so ever
        CProgFilesAppFinder * psaff = new CProgFilesAppFinder(pszFullName, pszShortName, &fFound, pszFolder);
        if (psaff)
        {
            if (SUCCEEDED(psaff->Initialize()))
            {
                // search down from "Program Files" directory under root of all fixed drives
                TCHAR szDrive[4];
                TCHAR szProgFiles[30];
                StringCchCopy(szDrive, ARRAYSIZE(szDrive), TEXT("A:\\"));
                StringCchCopy(szProgFiles, ARRAYSIZE(szProgFiles), TEXT("A:\\Program Files"));
                for (; !fFound && szDrive[0] <= TEXT('Z'); szProgFiles[0]++, szDrive[0]++)
                {
                    ASSERT(szDrive[0] == szProgFiles[0]);
                    if (GetDriveType(szDrive) == DRIVE_FIXED)
                        psaff->SearchInFolder(szProgFiles);
                }

            }

            if (!fFound)
            {
                psaff->SetRootSearch(TRUE);
                
                TCHAR szDrive[4];
                StringCchCopy(szDrive, ARRAYSIZE(szDrive), TEXT("A:\\"));
                for (; !fFound && szDrive[0] <= TEXT('Z'); szDrive[0]++)
                {
                    if (GetDriveType(szDrive) == DRIVE_FIXED)
                        psaff->SearchInFolder(szDrive);
                }
            }

            iMatch = psaff->_iBest;
            psaff->Release();
        }
        
        if (iMatch > MATCH_LEVEL_NOMATCH)
            TraceMsg(TF_ALWAYS, "CPFAF: Found %s at %s", pszFullName, pszFolder);
    }
    else
        TraceMsg(TF_ALWAYS, "CSMAF: Found %s at %s", pszFullName, pszFolder);

    return iMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\tasks.h ===
#ifndef __TASKS_H_
#define __TASKS_H_

#include <runtask.h>

// Search Depth
#define MAX_EXE_SEARCH_DEPTH 2
HRESULT FindAppInfo(LPCTSTR pszFolder, LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai, BOOL bDarwin);

#endif // _TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\w95c\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\tasks.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: tasks.cpp
// App Management tasks running on the secondary thread
// 
// History:
//         2-26-98  by dli implemented CAppUemInfoTask
//------------------------------------------------------------------------
#include "priv.h"

#include "shguidp.h"
#include "uemapp.h"
#include "appsize.h"
#include "findapp.h"
#include "tasks.h"
#include "slowfind.h"
#include "dump.h"
#include "util.h"


// Utility function to get times used or last used time for "exe" files
void ExtractExeInfo(LPCTSTR pszExe, PSLOWAPPINFO psai, BOOL bNoImageChange)
{
    ASSERT(IS_VALID_STRING_PTR(pszExe, -1));
    
    // Got to have a legal psai
    ASSERT(psai);

    // Get the "times used" info
    UEMINFO uei = {0};
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT;
    if (SUCCEEDED(UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1, (LPARAM)pszExe, &uei)))
    {
        if (uei.cHit > psai->iTimesUsed)
            psai->iTimesUsed = uei.cHit;
    }

    // Get the most recent access time
    HANDLE hFile = CreateFile(pszExe, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               NULL, OPEN_EXISTING, 0, NULL ); 
    if( INVALID_HANDLE_VALUE != hFile )
    {
        FILETIME ftCreate, ftAccessed, ftWrite;
        if (GetFileTime(hFile, &ftCreate, &ftAccessed, &ftWrite))
        {
            // Is the creation and accessed dates identical, and is the
            // UEM's statistic useless?
            if (0 == CompareFileTime(&ftAccessed, &ftCreate) && 
                0 == psai->ftLastUsed.dwHighDateTime)
            {
                // Yes; then it doesn't look like anyone has used it
                psai->ftLastUsed.dwHighDateTime = NOTUSED_HIGHDATETIME;
                psai->ftLastUsed.dwLowDateTime = NOTUSED_LOWDATETIME;
                if (!bNoImageChange && (psai->pszImage == NULL))
                    SHStrDup(pszExe, &psai->pszImage);
            }
            else if (CompareFileTime(&ftAccessed, &psai->ftLastUsed) > 0)
            {
                // No; someone must have used this program
                psai->ftLastUsed = ftAccessed;

                if (!bNoImageChange)
                {
                    // If there was an exe file for the icon, release that
                    if (psai->pszImage)
                        SHFree(psai->pszImage);

                    // Set the icon image of this app to this exe's icon
                    // because this exe is the most recently used one.

                    SHStrDup(pszExe, &psai->pszImage);
                }
            }
        }

        CloseHandle(hFile);
    }
}

const static struct {
    LPTSTR szAppName;
    LPTSTR szExeName;
} s_rgAppHacks[] = {
    { TEXT("Microsoft Office"), TEXT("msoffice.exe")},
};

//--------------------------------------------------------------------------------
//  CAppInfoFinder class
//--------------------------------------------------------------------------------

static const WCHAR sc_wszStarDotExe[] = L"*.exe";

// Use the TreeWalker to find the application "exe" file
class CAppInfoFinder : public CAppFolderSize
{
public:
    CAppInfoFinder(PSLOWAPPINFO psai, BOOL fSize, LPCTSTR pszHintExe, BOOL fNoImageChange);
    
    // *** IShellTreeWalkerCallBack methods (override) ***
    STDMETHOD(FoundFile)    (LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

    HRESULT SearchInFolder(LPCTSTR pszFolder);

protected:
    PSLOWAPPINFO _psai;
    BOOL _fComputeSize;         // Compute size or not
    BOOL _fNoImageChange;       // Do not change image from now on.
    TCHAR _szHintExe[MAX_PATH];
}; 


// constructor
CAppInfoFinder::CAppInfoFinder(PSLOWAPPINFO psai, BOOL fSize, LPCTSTR pszHintExe, BOOL fNoImageChange) :
   _fComputeSize(fSize), _fNoImageChange(fNoImageChange), _psai(psai), CAppFolderSize(&psai->ullSize)
{
    if (pszHintExe)
    {
        lstrcpyn(_szHintExe, pszHintExe, ARRAYSIZE(_szHintExe));
    }
}


/*-------------------------------------------------------------------------
Purpose: IShellTreeWalkerCallBack::FoundFile

         Extracts the exe info that we want if the given file matches
         an exe spec.  The info is stored in the _psai member variable.
*/
HRESULT CAppInfoFinder::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfdw)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    if (PathMatchSpecW(pwfdw->cFileName, sc_wszStarDotExe))
    {
        TCHAR szPath[MAX_PATH];
        TraceMsg(TF_SLOWFIND, "Found Exe File: %s", pwszFile);
        
        SHUnicodeToTChar(pwszFile, szPath, ARRAYSIZE(szPath));

        if (!PathIsSetup(szPath, 2))
        {
            ExtractExeInfo(szPath, _psai, _fNoImageChange);

            if (_szHintExe[0] != TEXT('\0'))
            {
                // Does this exe match our app's Hint icon exe?
                if (!lstrcmpi(_szHintExe, PathFindFileName(szPath)))
                {
                    // Yes, Bingo!! Use this icon. 

                    // If there was an exe file for the icon, release that
                    if (_psai->pszImage)
                        SHFree(_psai->pszImage);

                    // Set the icon image of this app to this exe's icon
                    SHStrDup(szPath, &_psai->pszImage);

                    _fNoImageChange = TRUE;
                }
            }
        }
    }

    if (_fComputeSize)
        hres = CAppFolderSize::FoundFile(pwszFile, ptws, pwfdw);
        
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Method to kick off the tree walk, starting at pszFolder.
*/
HRESULT CAppInfoFinder::SearchInFolder(LPCTSTR pszFolder)
{
    HRESULT hres = E_FAIL;
    WCHAR wszDir[MAX_PATH];

    SHTCharToUnicode(pszFolder, wszDir, SIZECHARS(wszDir));

    if (_pstw)
        hres = _pstw->WalkTree(0, wszDir, NULL, 0, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}


//--------------------------------------------------------------------------------
//  CAppInfoFinderSM class
//--------------------------------------------------------------------------------


// Use the TreeWalker to find the application "exe" file
class CAppInfoFinderSM : public CStartMenuAppFinder
{
public:
    CAppInfoFinderSM(LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai);
    
    // *** IShellTreeWalkerCallBack methods ***
    virtual STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    PSLOWAPPINFO _psai;
    TCHAR _szFakeFolder[MAX_PATH];
}; 


// constructor
CAppInfoFinderSM::CAppInfoFinderSM(LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai) : 
    _psai(psai),CStartMenuAppFinder(pszFullName, pszShortName, _szFakeFolder)
{
}


/*-------------------------------------------------------------------------
Purpose: IShellTreeWalkerCallBack::FoundFile

         Extracts the exe info that we want if the given file matches
         an exe spec.  The info is stored in the _psai member variable.
*/
HRESULT CAppInfoFinderSM::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    TCHAR szLnkFile[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    SHUnicodeToTChar(pwszFile, szLnkFile, ARRAYSIZE(szLnkFile));
    TraceMsg(TF_SLOWFIND, "CSMAF:Lnk %s -- %s %s", _pszFullName, szLnkFile);

    if (!_MatchSMLinkWithApp(szLnkFile))
        return S_OK;

    TCHAR szTargetFile[MAX_PATH];
    HRESULT hresT = GetShortcutTarget(szLnkFile, szTargetFile, ARRAYSIZE(szTargetFile));
    if ((S_FALSE == hresT) || ((S_OK == hresT) && !PathIsRoot(szTargetFile) && !PathIsUnderWindows(szTargetFile) && !PathIsSetup(szTargetFile, 1)))
    {
        LPCTSTR pszName = PathFindFileName(szTargetFile);
        
        if (PathMatchSpec(pszName, sc_wszStarDotExe))
            ExtractExeInfo(szTargetFile, _psai, FALSE);
    }

    return S_OK;
}


LPTSTR LookUpHintExes(LPCTSTR pszAppName, LPTSTR pszHintExe, DWORD cbHintExe)
{
    // Open the reg key
    HKEY hkeyIconHints = NULL;
    LPTSTR pszRet = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\Icon Hints")
                                      , 0, KEY_READ, &hkeyIconHints))
    {
        DWORD dwType;
        // Look up in the registry for this cpl name
        if ((ERROR_SUCCESS == SHQueryValueEx(hkeyIconHints, pszAppName, NULL, &dwType, pszHintExe, &cbHintExe))
            && (dwType == REG_SZ))
        {
            pszRet = pszHintExe;
        }

        RegCloseKey(hkeyIconHints);
    }

    return pszRet;
}

// use the tree walker to find the "exe" file for the application
HRESULT FindAppInfo(LPCTSTR pszFolder, LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai, BOOL bChanged)
{
    // If there is no output string, a folder and a name, we can't do anything
    ASSERT(IS_VALID_WRITE_PTR(psai, SLOWAPPINFO));
    if (pszFolder)
    {
        // We only compute sizes for locally installed apps and apps installed
        // on fixed drives. Ex: On board or external hard drives.
        // We purposely not compute size for network apps, apps on the CD ROMs and so on

        BOOL bGetSize = bChanged && PathIsLocalAndFixed(pszFolder);
        
        TCHAR szHintExe[MAX_PATH];
        LPTSTR pszHintExe = LookUpHintExes(pszFullName, szHintExe, SIZEOF(szHintExe));
        CAppInfoFinder * paef = new CAppInfoFinder(psai, bGetSize, pszHintExe, !bChanged);
        if (paef)
        {
            if (SUCCEEDED(paef->Initialize()))
                paef->SearchInFolder(pszFolder);
            
            paef->Release();
        }
    }

    if (bChanged)
    {
        CAppInfoFinderSM * paifsm = new CAppInfoFinderSM(pszFullName, pszShortName, psai);
        if (paifsm)
        {
            if (SUCCEEDED(paifsm->Initialize()))
            {
                TCHAR szStartMenu[MAX_PATH];
                if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_COMMON_PROGRAMS, FALSE))
                    paifsm->SearchInFolder(szStartMenu);

                if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_PROGRAMS, FALSE))
                    paifsm->SearchInFolder(szStartMenu);
            }            
            paifsm->Release();
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\winnt4\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\wnt4\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\winnt\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\ntc\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\nt4c\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\win95\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include <appmgmt.h>

STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd);

DWORD ARPGetRestricted(LPCWSTR pszPolicy);
void ARPGetPolicyString(LPCWSTR pszPolicy, LPWSTR pszBuf, int cch);

STDAPI ARP(HWND hWnd, int nPage);
STDAPI OpenAppMgr(HWND hwnd, int nPage);

void ClearAppInfoData(APPINFODATA * pdata);
void ClearSlowAppInfo(SLOWAPPINFO * pdata);
void ClearPubAppInfo(PUBAPPINFO * pdata);
void ClearManagedApplication(MANAGEDAPPLICATION * pma);

HRESULT ReleaseShellCategoryList(SHELLAPPCATEGORYLIST * psacl);
HRESULT ReleaseShellCategory(SHELLAPPCATEGORY * psac);

// These values can be set in the FILETIME structure to indicate the
// app has never been used.
#define NOTUSED_HIGHDATETIME    0xFFFFFFFF
#define NOTUSED_LOWDATETIME     0xFFFFFFFF

LPTSTR WINAPI ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);

#define ALD_ASSIGNED    0x00000001
#define ALD_EXPIRE      0x00000002
#define ALD_SCHEDULE    0x00000004

typedef struct tagAddLaterData
{
    DWORD dwMasks;
    SYSTEMTIME stAssigned;         // (in) assigned time 
    SYSTEMTIME stExpire;           // (in) expired time
    SYSTEMTIME stSchedule;         // (in/out) scheduled time 
} ADDLATERDATA, *PADDLATERDATA;

BOOL GetNewInstallTime(HWND hwndParent, PADDLATERDATA pal);
BOOL FormatSystemTimeString(LPSYSTEMTIME pst, LPTSTR pszStr, UINT cchStr);

EXTERN_C BOOL IsTerminalServicesRunning(void);

#define NUMSTARTPAGES 4

// Take an app key name or folder name and separate the number(version) from the name
void InsertSpaceBeforeVersion(LPCTSTR pszIn, LPTSTR pszOut);

// Is this path a valid folder location?
BOOL IsValidAppFolderLocation(LPCTSTR pszFolder);

BOOL PathIsLocalAndFixed(LPCTSTR pszFile);

BOOL IsSlowAppInfoChanged(PSLOWAPPINFO psaiOrig, PSLOWAPPINFO psaiNew);

// Comparison function for systemtimes
int CompareSystemTime(SYSTEMTIME *pst1, SYSTEMTIME *pst2);

void _ARPErrorMessageBox(DWORD dwError);

STDAPI _DuplicateCategoryList(APPCATEGORYINFOLIST * pacl, APPCATEGORYINFOLIST * paclNew);
STDAPI _DestroyCategoryList(APPCATEGORYINFOLIST * pacl);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\appwzdui\util.cpp ===
// 
// Random stuff
//
//


#include "priv.h"
#include "exdisp.h"
#include "mshtml.h"
#include "htiframe.h"
#include "util.h"
#include "resource.h"
#include "appwizid.h"

#define CPP_FUNCTIONS
#include <crtfree.h>        // declare new, delete, etc.

#define DATEFORMAT_MAX 40

#include <shguidp.h>
#include <ieguidp.h>

// is this okay to do?
#ifdef ENTERCRITICAL
#undef ENTERCRITICAL
#endif
#ifdef LEAVECRITICAL
#undef LEAVECRITICAL
#endif

#define ENTERCRITICAL
#define LEAVECRITICAL

#include "..\inc\uassist.cpp"

// Prototype
BOOL _IsARPAllowed(void);

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)
STDAPI OpenAppMgr(HWND hwnd, int nPage)
{
    HRESULT hres = E_FAIL;

    // Make sure we aren't restricted
    if (!_IsARPAllowed())
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_RESTRICTION),
            MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
    }
    else if ((nPage >= 0) && (nPage < NUMSTARTPAGES))
    {
        ARP(hwnd, nPage);        
        hres = S_OK;
    }
    return hres;
}


inline void StrFree(LPWSTR psz)
{
    if (psz)
        SHFree(psz);
}


/*-------------------------------------------------------------------------
Purpose: Clear the given app data structure.  Frees any allocated fields.
*/
void ClearAppInfoData(APPINFODATA * pdata)
{
    if (pdata)
    {
        if (pdata->dwMask & AIM_DISPLAYNAME)
            StrFree(pdata->pszDisplayName);
            
        if (pdata->dwMask & AIM_VERSION)
            StrFree(pdata->pszVersion);

        if (pdata->dwMask & AIM_PUBLISHER)
            StrFree(pdata->pszPublisher);
            
        if (pdata->dwMask & AIM_PRODUCTID)
            StrFree(pdata->pszProductID);
            
        if (pdata->dwMask & AIM_REGISTEREDOWNER)
            StrFree(pdata->pszRegisteredOwner);
            
        if (pdata->dwMask & AIM_REGISTEREDCOMPANY)
            StrFree(pdata->pszRegisteredCompany);
            
        if (pdata->dwMask & AIM_LANGUAGE)
            StrFree(pdata->pszLanguage);
            
        if (pdata->dwMask & AIM_SUPPORTURL)
            StrFree(pdata->pszSupportUrl);
            
        if (pdata->dwMask & AIM_SUPPORTTELEPHONE)
            StrFree(pdata->pszSupportTelephone);
            
        if (pdata->dwMask & AIM_HELPLINK)
            StrFree(pdata->pszHelpLink);
            
        if (pdata->dwMask & AIM_INSTALLLOCATION)
            StrFree(pdata->pszInstallLocation);
            
        if (pdata->dwMask & AIM_INSTALLSOURCE)
            StrFree(pdata->pszInstallSource);
            
        if (pdata->dwMask & AIM_INSTALLDATE)
            StrFree(pdata->pszInstallDate);
            
        if (pdata->dwMask & AIM_CONTACT)
            StrFree(pdata->pszContact);

        if (pdata->dwMask & AIM_COMMENTS)
            StrFree(pdata->pszComments);

        if (pdata->dwMask & AIM_IMAGE)
            StrFree(pdata->pszImage);
    }
}


void ClearSlowAppInfo(SLOWAPPINFO * pdata)
{
    if (pdata)
    {
        StrFree(pdata->pszImage);
        pdata->pszImage = NULL;
    }
}


// NOTE: Returns TRUE only if psaiNew has valid info and different from psaiOrig
BOOL IsSlowAppInfoChanged(PSLOWAPPINFO psaiOrig, PSLOWAPPINFO psaiNew)
{
    BOOL bRet = FALSE;

    ASSERT(psaiOrig && psaiNew);

    if (psaiNew)
    {    
        // Compare size first
        if (psaiOrig == NULL)
        {
            bRet = TRUE;
        }
        else if (((__int64)psaiNew->ullSize > 0) && (psaiNew->ullSize != psaiOrig->ullSize))
        {
            bRet = TRUE;
        }
        // Now compare the file time
        else if (((0 != psaiNew->ftLastUsed.dwHighDateTime) &&
                  (psaiOrig->ftLastUsed.dwHighDateTime != psaiNew->ftLastUsed.dwHighDateTime))
                 || ((0 != psaiNew->ftLastUsed.dwLowDateTime) &&
                     (psaiOrig->ftLastUsed.dwLowDateTime != psaiNew->ftLastUsed.dwLowDateTime)))
        {
            bRet = TRUE;
        }
        // Compare times used
        else if (psaiOrig->iTimesUsed != psaiNew->iTimesUsed)
        {
            bRet = TRUE;
        }
        // Compare the icon image
        else if ((psaiNew->pszImage != NULL) && (psaiOrig->pszImage != NULL) && lstrcmpi(psaiNew->pszImage, psaiOrig->pszImage))
            bRet = TRUE;

    }
    return bRet;
}

void ClearManagedApplication(MANAGEDAPPLICATION * pma)
{
    if (pma)
    {
        if (pma->pszPackageName)
            LocalFree(pma->pszPackageName);

        if (pma->pszPublisher)
            LocalFree(pma->pszPublisher);

        if (pma->pszPolicyName)
            LocalFree(pma->pszPolicyName);

        if (pma->pszOwner)
            LocalFree(pma->pszOwner);

        if (pma->pszCompany)
            LocalFree(pma->pszCompany);

        if (pma->pszComments)
            LocalFree(pma->pszComments);

        if (pma->pszContact)
            LocalFree(pma->pszContact);
    }
}

/*-------------------------------------------------------------------------
Purpose: Clear the given PUBAPPINFO data structure.  Frees any allocated fields.
*/
void ClearPubAppInfo(PUBAPPINFO * pdata)
{
    if (pdata)
    {
        if ((pdata->dwMask & PAI_SOURCE) && pdata->pszSource)
            StrFree(pdata->pszSource);
    }
}

/*-------------------------------------------------------------------------
Purpose: Frees a specific category structure
*/
HRESULT ReleaseShellCategory(SHELLAPPCATEGORY * psac)
{
    ASSERT(psac);

    if (psac->pszCategory)
    {
        SHFree(psac->pszCategory);
        psac->pszCategory = NULL;
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Frees the list of categories
*/
HRESULT ReleaseShellCategoryList(SHELLAPPCATEGORYLIST * psacl)
{
    UINT i;
    SHELLAPPCATEGORY * psac;

    ASSERT(psacl);

    psac = psacl->pCategory;
    
    for (i = 0; i < psacl->cCategories; i++, psac++)
    {
        ReleaseShellCategory(psac);
    }
    return S_OK;
}


#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)
#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)


void Int64ToStr( _int64 n, LPTSTR lpBuffer)
{
    TCHAR   szTemp[MAX_INT64_SIZE];
    _int64  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult, UINT cchResult)
{
    // FEATURE: We should pass in the lenght on pszResult buffer, we assume 40 will be enough
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    // Should have passed in size
    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, MAX_COMMA_NUMBER_SIZE) == 0)
    {
        StringCchCopy(pszResult, cchResult, szTemp);
    }

    return pszResult;
}

//
// Add Peta 10^15 and Exa 10^18 to support 64-bit integers.
//
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */
LPTSTR WINAPI ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    _int64 wInt;
    UINT wLen, wDec;
    TCHAR szTemp[MAX_COMMA_NUMBER_SIZE], szOrder[20], szFormat[5];

    if (dw64 < 1000) 
    {
        StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = dw64 >> 10;
    AddCommas64(wInt, szTemp, ARRAYSIZE(szTemp));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        StringCchCopy(szFormat, ARRAYSIZE(szFormat), TEXT("%02d"));

        szFormat[2] = TEXT('0') + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(HINST_THISDLL, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szOrder, (LPTSTR)szTemp);

    return szBuf;
}


#define c_szUninstallPolicy     L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Uninstall"


/*-------------------------------------------------------------------------
Purpose: Helper function for ARP's policy check
*/
DWORD ARPGetRestricted(LPCWSTR pszPolicy)
{
    return SHGetRestriction(NULL, TEXT("Uninstall"), pszPolicy);
}


/*-------------------------------------------------------------------------
Purpose: Return a policy string value
*/
void ARPGetPolicyString(LPCWSTR pszPolicy, LPWSTR pszBuf, int cch)
{
    DWORD dwSize, dwType;

    *pszBuf = 0;
    
    // Check local machine first and let it override what the
    // HKCU policy has done.
    dwSize = cch * sizeof(WCHAR);
    if (ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE,
                                     c_szUninstallPolicy, pszPolicy,
                                     &dwType, pszBuf, &dwSize))
    {
        // Check current user if we didn't find anything for the local machine.
        dwSize = cch * sizeof(WCHAR);
        SHGetValueW(HKEY_CURRENT_USER,
                    c_szUninstallPolicy, pszPolicy,
                    &dwType, pszBuf, &dwSize);
    }
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if it's okay to start ARP.

*/
BOOL _IsARPAllowed(void)
{
    // ARP is forbidden if the entire CPL is disabled
    if (ARPGetRestricted(L"NoAddRemovePrograms"))
    {
        return FALSE;
    }

    // ARP is permitted if there exists a non-restricted page.

    BOOL fAnyPages = !ARPGetRestricted(L"NoRemovePage") ||
                     !ARPGetRestricted(L"NoAddPage") ||
                     !ARPGetRestricted(L"NoWindowsSetupPage");

    // If we are not a server SKU, then also check the new page.
    if (!fAnyPages && !IsOS(OS_ANYSERVER))
    {
        fAnyPages = !ARPGetRestricted(L"NoChooseProgramsPage");
    }

    return fAnyPages;
}


/*-------------------------------------------------------------------------
Purpose: Take the error message and give user feedback through messagebox
*/
void _ARPErrorMessageBox(DWORD dwError)
{
    TCHAR szErrorMsg[MAX_PATH];
    szErrorMsg[0] = 0;

    LPTSTR pszMsg = NULL;
    switch (dwError) {
        // The following error code cases are ignored.     
        case ERROR_INSTALL_USEREXIT:
        case ERROR_SUCCESS_REBOOT_REQUIRED:
        case ERROR_SUCCESS_REBOOT_INITIATED:            
            ASSERT(pszMsg == NULL);
            break;

        default:
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0L, szErrorMsg,
                          ARRAYSIZE(szErrorMsg), NULL);
            pszMsg = szErrorMsg;
            break;
    }

    if (pszMsg)
    {
        ShellMessageBox( g_hinst, NULL, pszMsg,
                         MAKEINTRESOURCE( IDS_NAME ),
                         MB_OK | MB_ICONEXCLAMATION);
    }
}

/*-------------------------------------------------------------------------
Purpose: Format the SYSTEMTIME into the following format: "mm/dd/yy h:mm"
*/
BOOL FormatSystemTimeString(LPSYSTEMTIME pst, LPTSTR pszStr, UINT cchStr)
{
    BOOL bRet = FALSE;
    FILETIME ft = {0};

    if (SystemTimeToFileTime(pst, &ft))
    {
        DWORD dwFlags = FDTF_SHORTTIME | FDTF_SHORTDATE;
        bRet = SHFormatDateTime(&ft, &dwFlags, pszStr, cchStr);
    }
    return bRet;
}


/*-------------------------------------------------------------------------
Purpose: Get the correct Date time format for specific locale
*/
BOOL _GetLocaleDateTimeFormat(LPTSTR pszFormat, UINT cchFormat)
{
    TCHAR szTime[DATEFORMAT_MAX];
    TCHAR szDate[DATEFORMAT_MAX];
    if (cchFormat >= (ARRAYSIZE(szTime) + ARRAYSIZE(szDate) + 2))
    {
        LCID lcid = LOCALE_USER_DEFAULT;
        if (GetLocaleInfo(lcid, LOCALE_STIMEFORMAT, szTime, ARRAYSIZE(szTime)) && 
            GetLocaleInfo(lcid, LOCALE_SSHORTDATE, szDate, ARRAYSIZE(szDate)))
        {
            StringCchPrintf(pszFormat, cchFormat, TEXT("%s  %s"), szDate, szTime);
            return TRUE;
        }
    }

    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: Compare two SYSTEMTIME data

Returnes : 1 : st1 > st2
           0 : st1 == st2
          -1: st1 < st2

NOTE:  We do not compare seconds since ARP does not need that much precision. 
*/
int CompareSystemTime(SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else if (pst1->wHour < pst2->wHour)
        iRet = -1;
    else if (pst1->wHour > pst2->wHour)
        iRet = 1;
    else if (pst1->wMinute < pst2->wMinute)
        iRet = -1;
    else if (pst1->wMinute > pst2->wMinute)
        iRet = 1;
//    else if (pst1->wSecond < pst2->wSecond)
//        iRet = -1;
//    else if (pst1->wSecond > pst2->wSecond)
//        iRet = 1;
    else
        iRet = 0;

    return(iRet);
}


/*--------------------------------------------------------------------------
Purpose: Window proc for the add later dialog box
*/
BOOL_PTR CALLBACK AddLaterDlgProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            PADDLATERDATA pald = (PADDLATERDATA)lp;

            // We should definitely have this (dli)
            ASSERT(pald);

            SYSTEMTIME stInit = {0};
            // Get the current local time
            GetLocalTime(&stInit);

            // Has this app already expired?
            if ((pald->dwMasks & ALD_EXPIRE) &&
                (CompareSystemTime(&pald->stExpire, &stInit) > 0))
            {
                // NO,
                
                // Assigned time does not make sense if the assigned time has already
                // passed
                if ((pald->dwMasks & ALD_ASSIGNED) &&
                    (CompareSystemTime(&pald->stAssigned, &stInit) <= 0))
                    pald->dwMasks &= ~ALD_ASSIGNED;

                // find the date/time picker window
                HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);

                // always check "add later" radio button initially
                CheckDlgButton(hDlg, IDC_ADDLATER, BST_CHECKED);

                TCHAR szFormat[MAX_PATH];
                if (_GetLocaleDateTimeFormat(szFormat, ARRAYSIZE(szFormat)))
                {
                    // set the locale date time format
                    DateTime_SetFormat(hwndPicker, szFormat);

                    // The new time can only be in the future, so set the current time
                    // as the lower limit
                    DateTime_SetRange(hwndPicker, GDTR_MIN, &stInit);

                    // Do we have a schedule (in the future) already?
                    // Schedule in the past means nothing
                    if ((pald->dwMasks & ALD_SCHEDULE) &&
                        (CompareSystemTime(&pald->stSchedule, &stInit) >= 0))
                    {
                        // Set our initial value to this schedule
                        stInit = pald->stSchedule;
                    }

                    // Set the initial value in date/time picker
                    DateTime_SetSystemtime(hwndPicker, GDT_VALID, &stInit);

                    // Uncheck the SCHEDULE flag so that we know we don't have a new
                    // schedule, yet
                    pald->dwMasks &= ~ALD_SCHEDULE;

                    SetWindowLongPtr(hDlg, DWLP_USER, lp);

                    return TRUE;
                }
            }
            else
            {
                // Yes, it's expired, warn the user
                ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_EXPIRED),
                                MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);

                // Then end the dialog. 
                EndDialog(hDlg, 0);
            }
            return FALSE;
        }
        break;
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wp, lp))
            {
                case IDC_ADDLATER:
                case IDC_UNSCHEDULE:
                {
                    HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);
                    EnableWindow(hwndPicker, IsDlgButtonChecked(hDlg, IDC_ADDLATER));
                }
                break;
                
                case IDOK:
                {
                    PADDLATERDATA pald = (PADDLATERDATA)GetWindowLongPtr(hDlg, DWLP_USER);

                    // we did set window long ptr this should be there. 
                    ASSERT(pald);

                    // did the user choose to add later?
                    if (IsDlgButtonChecked(hDlg, IDC_ADDLATER))
                    {
                        // Yes
                        // Let's find out if the time user has chosen is valid
                        
#define LATER_THAN_ASSIGNED_TIME 1
#define LATER_THAN_EXPIRED_TIME 2
                        int iStatus = 0;
                        HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);
                        DateTime_GetSystemtime(hwndPicker, &pald->stSchedule);

                        // Is this time later than the assigned time?
                        if ((pald->dwMasks & ALD_ASSIGNED) &&
                            (CompareSystemTime(&pald->stSchedule, &pald->stAssigned) > 0))
                            iStatus = LATER_THAN_ASSIGNED_TIME;

                        // Is this time later than the expired time?
                        if ((pald->dwMasks & ALD_EXPIRE) &&
                            (CompareSystemTime(&pald->stSchedule, &pald->stExpire) >= 0))
                            iStatus = LATER_THAN_EXPIRED_TIME;

                        // Is either of the above two cases TRUE?
                        if (iStatus > 0)
                        {
                            TCHAR szDateTime[MAX_PATH];
                            
                            // Is the time user chose passed expired time or assigned?
                            BOOL bExpired = (iStatus == LATER_THAN_EXPIRED_TIME);
                            
                            // Get the time string
                            if (FormatSystemTimeString(bExpired ? &pald->stExpire : &pald->stAssigned,
                                szDateTime, ARRAYSIZE(szDateTime)))
                            {
                                TCHAR szFinal[MAX_PATH * 2];
                                TCHAR szWarn[MAX_PATH];
                                LoadString(g_hinst,  bExpired ? IDS_PASSEXPIRED : IDS_PASSASSIGNED,
                                           szWarn, ARRAYSIZE(szWarn));
                                
                                StringCchPrintf(szFinal, ARRAYSIZE(szFinal), szWarn, szDateTime, szDateTime);
                                ShellMessageBox(g_hinst, hDlg, szFinal, 
                                                MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
                            }
                        }
                        else
                            // No, we are okay to go
                            pald->dwMasks |= ALD_SCHEDULE;
                    }
                }

                //
                // fall through
                //
                case IDCANCEL:
                    EndDialog(hDlg, (GET_WM_COMMAND_ID(wp, lp) == IDOK));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*-------------------------------------------------------------------------
Purpose: GetNewInstallTime

         Start up the Add Later dialog box to get the new install schedule
         (represented by a SYSTEMTIME data struct) 
*/
BOOL GetNewInstallTime(HWND hwndParent, PADDLATERDATA pal)
{
    return (DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_ADDLATER),
                           hwndParent, AddLaterDlgProc, (LPARAM)pal) == IDOK);
}


// Take the name of the potential app folder and see if it ends with numbers or dots
// if it does, let's separate the numbers and see if there is a match.
// It's inspired by cases like Office8.0 or MSVC50 or Bookshelf98
// NOTE: we can't use the key words without the numbers, it might lead to mistake
// in case the user has two versions of the same software on one machine. (there might
// be something we can do though, I am too tired to think about this now)
void InsertSpaceBeforeVersion(LPCTSTR pszIn, LPTSTR pszOut)
{
    ASSERT(IS_VALID_STRING_PTR(pszIn, -1));
    ASSERT(IS_VALID_STRING_PTR(pszOut, -1));

    // Copy the old string into the buffer
    lstrcpy(pszOut, pszIn);

    // Find the end of the string
    LPTSTR pszEnd = pszOut + lstrlen(pszOut);
    ASSERT(pszEnd > pszOut);

    // Go back until we can't see numbers or '.'
    LPTSTR pszLastChar = CharPrev(pszOut, pszEnd);
    LPTSTR pszPrev = pszLastChar;
    while ((pszPrev > pszOut) && (((*pszPrev <= TEXT('9')) && (*pszPrev >= TEXT('0'))) || (*pszPrev == TEXT('.'))))
        pszPrev = CharPrev(pszOut, pszPrev);

    // Did we find any numbers at the end?
    if ((pszPrev < pszLastChar) && IsCharAlphaNumeric(*pszPrev))
    {
        // Yes, let's stick a ' ' in between
        TCHAR szNumbers[MAX_PATH];
        StringCchCopy(szNumbers, ARRAYSIZE(szNumbers), ++pszPrev);
        *(pszPrev++) = TEXT(' ');
        lstrcpy(pszPrev, szNumbers);
    }
}

// 
// Basic sanity check on whether the app folder location is valid. 
// Return Value:
// TRUE does not mean it is valid.
// FALSE means it definitely is not valid.
//
BOOL IsValidAppFolderLocation(LPCTSTR pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    BOOL bRet = FALSE;
    if (!PathIsRoot(pszFolder) && PathFileExists(pszFolder) && PathIsDirectory(pszFolder))
    {
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), pszFolder)) && PathStripToRoot(szPath))
        {
            bRet = (GetDriveType(szPath) == DRIVE_FIXED);
        }
    }

    return bRet;
}

EXTERN_C BOOL IsTerminalServicesRunning(void)
{
    static int s_fIsTerminalServer = -1;

    if (s_fIsTerminalServer == -1)
    {
        BOOL TSAppServer;
        BOOL TSRemoteAdmin;
    
        OSVERSIONINFOEX osVersionInfo;
        DWORDLONG dwlConditionMask = 0;
    
        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
    
        VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    
        TSAppServer = (int)VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);
    
    
        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;
    
        VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    
        TSRemoteAdmin = (int)VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);
    
        if ( !TSRemoteAdmin && TSAppServer )
        {
            s_fIsTerminalServer = TRUE;
        }
        else
        {
            // do not treat tsremoteadmin as TS machine from the application compatability point of view.
            s_fIsTerminalServer = FALSE;
        }
    }

    return s_fIsTerminalServer ? TRUE : FALSE;
}


// returns TRUE if pszFile is a local file and on a fixed drive
BOOL PathIsLocalAndFixed(LPCTSTR pszFile)
{
    if (!pszFile || !pszFile[0])
        return FALSE;

    if (PathIsUNC(pszFile))
        return FALSE;
    
    TCHAR szDrive[MAX_PATH];
    StringCchCopy(szDrive, ARRAYSIZE(szDrive), pszFile); 
    if (PathStripToRoot(szDrive) && GetDriveType(szDrive) != DRIVE_FIXED)
        return FALSE;

    return TRUE;
}


// This function will duplicate an APPCATEGORYINFOLIST and allocate the new copy
// using COM memory allocation functions
STDAPI  _DuplicateCategoryList(APPCATEGORYINFOLIST * pacl, APPCATEGORYINFOLIST * paclNew)
{
    HRESULT hres = E_FAIL;
    ASSERT(pacl && paclNew);
    ZeroMemory(paclNew, SIZEOF(APPCATEGORYINFOLIST));

    if (pacl && (pacl->cCategory > 0) && pacl->pCategoryInfo)
    {
        DWORD dwDesiredSize = pacl->cCategory * SIZEOF(APPCATEGORYINFO);
        APPCATEGORYINFO * paci = pacl->pCategoryInfo;
        paclNew->pCategoryInfo = (APPCATEGORYINFO *)SHAlloc(dwDesiredSize);
        if (paclNew->pCategoryInfo)
        {
            UINT iCategory = 0;
            paclNew->cCategory = 0;
            APPCATEGORYINFO * paciNew = paclNew->pCategoryInfo;
            while (paci && (iCategory < pacl->cCategory))
            {
                if (paci->pszDescription)
                {
                    hmemcpy(paciNew, paci, SIZEOF(APPCATEGORYINFO));
                    if (FAILED(SHStrDup(paci->pszDescription, &(paciNew->pszDescription))))
                    {
                        // We may be out of memory, stop here. 
                        ZeroMemory(paciNew, SIZEOF(APPCATEGORYINFO));
                        break;
                    }
                    
                    paciNew++;
                    paclNew->cCategory++;
                }
                
                iCategory++;
                paci++;
            }

            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}

STDAPI _DestroyCategoryList(APPCATEGORYINFOLIST * pacl)
{
    if (pacl && pacl->pCategoryInfo)
    {
        UINT iCategory = 0;
        APPCATEGORYINFO * paci = pacl->pCategoryInfo;
        while (paci && (iCategory < pacl->cCategory))
        {
            if (paci->pszDescription)
            {
                SHFree(paci->pszDescription);
            }
            iCategory++;
            paci++;
        }
        SHFree(pacl->pCategoryInfo);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\common\deskcplext.h ===
#define DESKCPLEXT_DISPLAY_DEVICE       TEXT("Display Device")  // "\DisplayX"
#define DESKCPLEXT_DISPLAY_NAME         TEXT("Display Name")    // " ATI Mach64 Turbo 3 "
#define DESKCPLEXT_MONITOR_DEVICE       TEXT("Monitor Device")  // " \DisplayX\MonitorX "
#define DESKCPLEXT_MONITOR_NAME         TEXT("Monitor Name")    // " NEC Multi-sync II "
#define DESKCPLEXT_PRUNING_MODE         TEXT("Pruning Mode")    // 1 = on (default value), 0 = off

#define DESKCPLEXT_DISPLAY_DEVICE_KEY   TEXT("Display Key")     // "\REGISTRY\MACHINE\SYSTEM\ControlSet00X\Services\<driver>\DeviceY"
#define DESKCPLEXT_DISPLAY_ID           TEXT("Display ID")      // "ROOT\*PNP0F03\1-0-21-0-31-0"
#define DESKCPLEXT_DISPLAY_STATE_FLAGS  TEXT("Display State Flags")
#define DESKCPLEXT_MONITOR_ID           TEXT("Monitor ID")      // "ROOT\*PNP0F04\1-0-21-0-31-0"
#define DESKCPLEXT_INTERFACE            TEXT("Desk.cpl extension interface")

typedef
LPDEVMODEW
(*LPDESKCPLEXT_ENUM_ALL_MODES) (
    LPVOID pContext,
    DWORD iMode
    );

typedef
LPDEVMODEW
(*LPDESKCPLEXT_GET_SELECTED_MODE) (
    LPVOID pContext
    );

typedef
BOOL
(*LPDESKCPLEXT_SET_SELECTED_MODE) (
    LPVOID pContext,
    LPDEVMODEW lpdm
    );

typedef
VOID 
(*LPDESKCPLEXT_GET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL*  pbCanBePruned,
    BOOL*  pbIsReadOnly,
    BOOL*  pbIsPruningOn
    );
    
typedef
VOID 
(*LPDESKCPLEXT_SET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL   bIsPruningOn
    );


typedef struct _DISPLAY_REGISTRY_HARDWARE_INFO {

    WCHAR MemSize[128];
    WCHAR ChipType[128];
    WCHAR DACType[128];
    WCHAR AdapString[128];
    WCHAR BiosString[128];

} DISPLAY_REGISTRY_HARDWARE_INFO, *PDISPLAY_REGISTRY_HARDWARE_INFO;




typedef struct _DESK_EXTENSION_INTERFACE {

    DWORD   cbSize;
    LPVOID  pContext;

    LPDESKCPLEXT_ENUM_ALL_MODES    lpfnEnumAllModes;
    LPDESKCPLEXT_SET_SELECTED_MODE lpfnSetSelectedMode;
    LPDESKCPLEXT_GET_SELECTED_MODE lpfnGetSelectedMode;
    LPDESKCPLEXT_SET_PRUNING_MODE  lpfnSetPruningMode;
    LPDESKCPLEXT_GET_PRUNING_MODE  lpfnGetPruningMode;
    
    DISPLAY_REGISTRY_HARDWARE_INFO Info;

} DESK_EXTENSION_INTERFACE, *PDESK_EXTENSION_INTERFACE;

#define NORMAL_TIMEOUT  7000
#define SLOW_TIMEOUT   12000

typedef
int
(*LPDISPLAY_SAVE_SETTINGS)   (
    LPVOID pContext,
    HWND   hwnd
    );

typedef
DWORD
(*LPDISPLAY_TEST_SETTINGS) (
    LPDEVMODEW lpDevMode,
    LPWSTR     pwszDevice,
    DWORD      dwTimeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\common\deskcmmn.cpp ===
#include "deskcmmn.h"
#include <regstr.h>
#include <ccstock.h>

LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan)
{
    int i;
    for (i = 0; pszScan[i] != TEXT('\0') && pszTarget[i] != TEXT('\0') &&
            CharUpperChar(pszScan[i]) == CharUpperChar(pszTarget[i]); i++);

    if (pszTarget[i] == TEXT('\0'))
        {
        // we found the substring
        return pszScan + i;
        }

    return pszScan;
}


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey)
{
    if(lstrlen(pstrDeviceKey) >= MAX_PATH)
        return FALSE;

    BOOL bRet = FALSE;

    // copy to local string
    TCHAR szBuffer[MAX_PATH];
    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pstrDeviceKey);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\Services\Jazzg300\Device0
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    LPTSTR pszRegistryPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    if(pszRegistryPath)
    {
        // Open the registry key
        bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             pszRegistryPath,
                             0,
                             KEY_QUERY_VALUE,
                             phKey) == ERROR_SUCCESS);
    }

    return bRet;
}

int GetDisplayCPLPreference(LPCTSTR szRegVal)
{
    int val = -1;
    HKEY hk;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                     0, 
                     KEY_READ, 
                     &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = (int)MyStrToLong(sz);
        }

        RegCloseKey(hk);
    }

    if (val == -1 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                  REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                                  0, 
                                  KEY_READ, 
                                  &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = (int)MyStrToLong(sz);
        }

        RegCloseKey(hk);
    }

    return val;
}


int GetDynaCDSPreference()
{
    int iRegVal = GetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE);
    if (iRegVal == -1)
        iRegVal = DCDSF_DYNA; // Apply dynamically
    return iRegVal;
}


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val)
{
    HKEY hk;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, 
                       REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                       0, 
                       TEXT(""), 
                       0, 
                       KEY_WRITE, 
                       NULL, 
                       &hk, 
                       NULL) == ERROR_SUCCESS)
    {
        TCHAR sz[64];

        StringCchPrintf(sz, ARRAYSIZE(sz), TEXT("%d"), val);
        RegSetValueEx(hk, szRegVal, NULL, REG_SZ,
            (LPBYTE)sz, (lstrlen(sz) + 1) * sizeof(TCHAR));

        RegCloseKey(hk);
    }
}


LONG WINAPI MyStrToLong(LPCTSTR sz)
{
    long l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
        l = l*10 + (*sz++ - TEXT('0'));

    return l;
}

BOOL
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    )
/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInterfaceName

*/
{
    BOOL bSuccess = FALSE;
    LPTSTR pszPath = NULL;
    HKEY hkDevice = 0;
    HKEY hkVolatileSettings = 0;

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkDevice) != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    if (RegOpenKeyEx(hkDevice,
                     SZ_VOLATILE_SETTINGS,
                     0,
                     KEY_READ,
                     &hkVolatileSettings) != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkVolatileSettings,
                                 SZ_DISPLAY_ADAPTER_INTERFACE_NAME,
                                 ppInterfaceName);

Cleanup:

    if (hkVolatileSettings) {
        RegCloseKey(hkVolatileSettings);
    }

    if (hkDevice) {
        RegCloseKey(hkDevice);
    }

    return bSuccess;
}


BOOL
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    )
/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInstanceID

*/
{
    LPTSTR pDeviceKeyCopy = NULL, pDeviceKeyCopy2 = NULL;
    LPTSTR pTemp = NULL, pX = NULL;
    BOOL bSuccess = FALSE;
    HKEY hkEnum = 0;
    HKEY hkService = 0;
    HKEY hkCommon = 0;
    DWORD Count = 0;
    DWORD cb = 0, len = 0;

    //
    // Make a copy of pDeviceKey
    //

    len = max (256, (lstrlen(pDeviceKey) + 6) * sizeof(TCHAR));
    pDeviceKeyCopy2 = pDeviceKeyCopy = (LPTSTR)LocalAlloc(LPTR, len);

    if (pDeviceKeyCopy == NULL) 
    {
        goto Cleanup;
    }

    StringCbCopy(pDeviceKeyCopy, len, pDeviceKey);
    pTemp = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKeyCopy);
    pDeviceKeyCopy = pTemp;

    //
    // Open the service key
    //

    pTemp = pDeviceKeyCopy + lstrlen(pDeviceKeyCopy);

    while ((pTemp != pDeviceKeyCopy) && (*pTemp != TEXT('\\'))) 
    {
        pTemp--;
    }

    if (pTemp == pDeviceKeyCopy) 
    {
        goto Cleanup;
    }

    pX = SubStrEnd(SZ_DEVICE, pTemp);

    if (pX == pTemp) 
    {

        //
        // The new key is used: CCS\Control\Video\[GUID]\000X
        //

        *pTemp = UNICODE_NULL;

        StringCbCat(pDeviceKeyCopy, len, SZ_COMMON_SUBKEY);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pDeviceKeyCopy,
                         0,
                         KEY_READ,
                         &hkCommon) != ERROR_SUCCESS) 
        {            
            goto Cleanup;
        }
    
        pDeviceKeyCopy = pDeviceKeyCopy2;

        ZeroMemory(pDeviceKeyCopy, len);
        
        StringCbCopy(pDeviceKeyCopy, len, SZ_SERVICES_PATH);

        cb = len - (lstrlen(pDeviceKeyCopy) + 1) * sizeof(TCHAR);

        if (RegQueryValueEx(hkCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)(pDeviceKeyCopy + lstrlen(pDeviceKeyCopy)),
                            &cb) != ERROR_SUCCESS) 
        {            
            goto Cleanup;
        }

    } 
    else 
    {

        //
        // The old key is used: CCS\Services\[SrvName]\DeviceX
        //

        *pTemp = UNICODE_NULL;
    }

    //
    // Open the ServiceName key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pDeviceKeyCopy,
                     0,
                     KEY_READ,
                     &hkService) != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }
    
    //
    // Open the "Enum" key under the devicename
    //

    if (RegOpenKeyEx(hkService,
                     SZ_ENUM,
                     0,
                     KEY_READ,
                     &hkEnum) != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    cb = sizeof(Count);
    if ((RegQueryValueEx(hkEnum,
                         SZ_VU_COUNT,
                         NULL,
                         NULL,
                         (LPBYTE)&Count,
                         &cb) != ERROR_SUCCESS) ||
        (Count != 1)) 
    {

        //
        // Igonore the case when there are at least 2 devices.
        //

        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkEnum, TEXT("0"), ppInstanceID);

Cleanup:

    if (hkEnum != 0) 
    {
        RegCloseKey(hkEnum);
    }

    if (hkService != 0) 
    {
        RegCloseKey(hkService);
    }

    if (hkCommon != 0) 
    {
        RegCloseKey(hkCommon);
    }
    
    if (pDeviceKeyCopy2 != NULL) 
    {
        LocalFree(pDeviceKeyCopy2);
    }

    return bSuccess;
}


BOOL
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    )
/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppwValueData

*/
{
    LPWSTR pwValueData = NULL;
    DWORD AllocUnit = 64;
    DWORD cBytes = 0;
    BOOL bSuccess = FALSE;
    LONG Error = ERROR_SUCCESS;

    while (!bSuccess) 
    {
        AllocUnit *= 2;
        cBytes = AllocUnit * sizeof(WCHAR);

        pwValueData = (LPWSTR)(LocalAlloc(LPTR, cBytes));
        if (pwValueData == NULL)
            break;

        Error = RegQueryValueEx(hkKey,
                                pValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pwValueData,
                                &cBytes);

        bSuccess = (Error == ERROR_SUCCESS);

        if (!bSuccess) 
        {
            LocalFree(pwValueData);
            pwValueData = NULL;

            if (Error != ERROR_MORE_DATA)
                break;
        }
    }

    if (bSuccess) 
    {
        *ppwValueData = pwValueData;
    }

    return bSuccess;
}

VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExtList
    )
{
    HKEY hkSubkey = 0;
    DWORD index = 0;
    DWORD ulSize = MAX_PATH;
    APPEXT AppExtTemp;
    PAPPEXT pAppExtBefore = NULL;
    PAPPEXT pAppExtTemp = NULL;

    ulSize = ARRAYSIZE(AppExtTemp.szKeyName);
    while (RegEnumKeyEx(hkExtensions, 
                        index, 
                        AppExtTemp.szKeyName, 
                        &ulSize, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL) == ERROR_SUCCESS) 
    {
        if (RegOpenKeyEx(hkExtensions,
                         AppExtTemp.szKeyName,
                         0,
                         KEY_READ,
                         &hkSubkey) == ERROR_SUCCESS) 
        {
            ulSize = sizeof(AppExtTemp.szDefaultValue);
            if ((RegQueryValueEx(hkSubkey,
                                 NULL,
                                 0,
                                 NULL,
                                 (PBYTE)AppExtTemp.szDefaultValue,
                                 &ulSize) == ERROR_SUCCESS) && 
                (AppExtTemp.szDefaultValue[0] != TEXT('\0'))) 
            {
                PAPPEXT pAppExt = (PAPPEXT)LocalAlloc(LPTR, sizeof(APPEXT));
                
                if (pAppExt != NULL) 
                {
                    *pAppExt = AppExtTemp;

                    pAppExtBefore = pAppExtTemp = *ppAppExtList;
                    
                    while((pAppExtTemp != NULL) &&
                          (lstrcmpi(pAppExtTemp->szDefaultValue,
                                    pAppExt->szDefaultValue) < 0)) 
                    {
                        pAppExtBefore = pAppExtTemp;
                        pAppExtTemp = pAppExtTemp->pNext;
                    }

                    if (pAppExtBefore != pAppExtTemp) 
                    {                       
                        pAppExt->pNext = pAppExtBefore->pNext;
                        pAppExtBefore->pNext = pAppExt;

                    } 
                    else 
                    {
                        pAppExt->pNext = *ppAppExtList;
                        *ppAppExtList = pAppExt;
                    }
                }
            }

            RegCloseKey(hkSubkey);
        }

        ulSize = ARRAYSIZE(AppExtTemp.szKeyName);
        index++;
    }
}


VOID
DeskAECleanup(
    PAPPEXT pAppExt
    )
{
    PAPPEXT pAppExtTemp;

    while (pAppExt) 
    {
        pAppExtTemp = pAppExt->pNext;
        LocalFree(pAppExt);
        pAppExt = pAppExtTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\common\propsext.h ===
//---------------------------------------------------------------------------
//
//  File: propsext.h
//
//  General definition of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//---------------------------------------------------------------------------

#ifndef _COMMONPROPEXT_H
#define _COMMONPROPEXT_H


extern BOOL         g_RunningOnNT;
extern HINSTANCE    g_hInst;
extern LPDATAOBJECT g_lpdoTarget;

// OLE-Registry magic number
extern GUID         g_CLSID_CplExt;

// Someone made a spelling mistake
#define PropertySheeDlgProc         PropertySheetDlgProc

INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
UINT CALLBACK PropertySheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

  
//Type for an object-destroyed callback
typedef void (FAR PASCAL *LPFNDESTROYED)(void);


class CClassFactory : public IClassFactory
{
protected:
        ULONG m_cRef;

public:
        CClassFactory();
        ~CClassFactory();

        //IUnknown members
        STDMETHODIMP         QueryInterface( REFIID, LPVOID* );
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        //IClassFactory members
        STDMETHODIMP         CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
        STDMETHODIMP         LockServer( BOOL );
};


class CPropSheetExt : public IShellPropSheetExt, IShellExtInit
{
private:
        ULONG         m_cRef;
        LPUNKNOWN     m_pUnkOuter;    //Controlling unknown
        LPFNDESTROYED m_pfnDestroy;   //Function closure call

public:
        CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy );
        ~CPropSheetExt(void);

        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //  IShellExtInit methods
        STDMETHODIMP         Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

        //IShellPropSheetExt methods ***
        STDMETHODIMP         AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
        STDMETHODIMP         ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam);
};



#endif // _COMMONPROPEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskadp\deskadp.h ===
/******************************************************************************

  Source File:  deskadp.h

  General include file

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-01-97 AndreVa - Created It

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>

#include <initguid.h>
#include <help.h>
#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "resource.h"

#define STRSAFE_LIB
#include <strsafe.h>

typedef struct _NEW_DESKTOP_PARAM {
    LPDEVMODEW lpdevmode;
    LPWSTR pwszDevice;
} NEW_DESKTOP_PARAM, *PNEW_DESKTOP_PARAM;

VOID DrawBmp(HDC hDC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\common\deskcmmn.h ===
#ifndef _DESKCMMN_H
#define _DESKCMMN_H


//==========================================================================
//                              Guids
//==========================================================================

DEFINE_GUID(GUID_DISPLAY_ADAPTER_INTERFACE, 
            0x5b45201d, 
            0xf2f2, 0x4f3b, 
            0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

#define SZ_DISPLAY_ADAPTER_INTERFACE_NAME TEXT("{5b45201d-f2f2-4f3b-85bb-30ff1f953599}")

//==========================================================================
//                              Macros
//==========================================================================

#define SZ_REGISTRYMACHINE  TEXT("\\REGISTRY\\MACHINE\\")
#define SZ_PRUNNING_MODE    TEXT("PruningMode")

#define SZ_GUID                TEXT("VideoID")
#define SZ_VIDEO_DEVICES       TEXT("System\\CurrentControlSet\\Control\\Video\\")
#define SZ_COMMON_SUBKEY       TEXT("\\Video")
#define SZ_SERVICES_PATH       TEXT("System\\CurrentControlSet\\Services\\")
#define SZ_SERVICE             TEXT("Service")

#define DCDSF_DYNA (0x0001)
#define DCDSF_ASK  (0x0002)

#define DCDSF_PROBABLY      (DCDSF_ASK  | DCDSF_DYNA)
#define DCDSF_PROBABLY_NOT  (DCDSF_ASK  |          0)
#define DCDSF_YES           (0          | DCDSF_DYNA)
#define DCDSF_NO            (0          |          0)


#define REGSTR_VAL_DYNASETTINGSCHANGE    TEXT("DynaSettingsChange")
#define SZ_UPGRADE_FROM_PLATFORM         TEXT("PlatformId")
#define SZ_UPGRADE_FROM_MAJOR_VERSION    TEXT("MajorVersion")
#define SZ_UPGRADE_FROM_MINOR_VERSION    TEXT("MinorVersion")
#define SZ_UPGRADE_FROM_BUILD_NUMBER     TEXT("BuildNumber")
#define SZ_UPGRADE_FROM_VERSION_DESC     TEXT("CSDVersion")
#define SZ_UPGRADE_FROM_PELS_WIDTH       TEXT("PelsWidth")
#define SZ_UPGRADE_FROM_PELS_HEIGHT      TEXT("PelsHeight")
#define SZ_UPGRADE_FROM_BITS_PER_PEL     TEXT("BPP")
#define SZ_UPGRADE_FROM_PLANES           TEXT("Planes")
#define SZ_UPGRADE_FROM_DISPLAY_FREQ     TEXT("VRefresh")
#define SZ_UPGRADE_FAILED_ALLOW_INSTALL  TEXT("FailedAllowInstall")
#define SZ_VIDEOMAP                      TEXT("HARDWARE\\DEVICEMAP\\VIDEO")
#define SZ_DEVICE                        TEXT("\\Device")
#define SZ_ENUM                          TEXT("Enum")

#define SZ_UPDATE_SETTINGS               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\VideoUpgradeDisplaySettings")
#define SZ_UPDATE_SETTINGS_PATH          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define SZ_UPDATE_SETTINGS_KEY           TEXT("VideoUpgradeDisplaySettings")

#define SZ_VU_COUNT                      TEXT("Count")
#define SZ_VU_PHYSICAL                   TEXT("Physical")
#define SZ_VU_LOGICAL                    TEXT("Logical")
#define SZ_VU_BUS_NUMBER                 TEXT("BusNumber")
#define SZ_VU_ADDRESS                    TEXT("Address")
#define SZ_VU_PREFERRED_MODE             TEXT("UsePreferredMode")
#define SZ_VU_ATTACHED_TO_DESKTOP        TEXT("Attach.ToDesktop")
#define SZ_VU_RELATIVE_X                 TEXT("Attach.RelativeX")
#define SZ_VU_RELATIVE_Y                 TEXT("Attach.RelativeY")
#define SZ_VU_BITS_PER_PEL               TEXT("DefaultSettings.BitsPerPel")
#define SZ_VU_X_RESOLUTION               TEXT("DefaultSettings.XResolution")
#define SZ_VU_Y_RESOLUTION               TEXT("DefaultSettings.YResolution")
#define SZ_VU_VREFRESH                   TEXT("DefaultSettings.VRefresh")
#define SZ_VU_FLAGS                      TEXT("DefaultSettings.Flags")

#define SZ_HW_ACCELERATION               TEXT("Acceleration.Level")


#define SZ_VOLATILE_SETTINGS             TEXT("VolatileSettings")

#define SZ_DETECT_DISPLAY                TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY                   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")

#define SZ_SERVICES_TO_DISABLE           TEXT("ServicesToDisable")
#define SZ_APPEXT_TO_DELETE              TEXT("AppletExtensionsToDelete")

#define SZ_SHELLEX                       TEXT("shellex")

#define REGSTR_PATH_CONTROLSFOLDER_DISPLAY REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display")
#define REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET REGSTR_PATH_CONTROLSFOLDER_DISPLAY TEXT("\\shellex\\PropertySheetHandlers")

#define REGSTR_PATH_CONTROLSFOLDER_DEVICE REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device")
#define REGSTR_PATH_CONTROLSFOLDER_DEVICE_SHEX_PROPSHEET REGSTR_PATH_CONTROLSFOLDER_DEVICE TEXT("\\shellex\\PropertySheetHandlers")

//==========================================================================
//                              Functions
//==========================================================================

// LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan )
//
// If pszScan starts with pszTarget, then the function returns the first
// char of pszScan that follows the pszTarget; other wise it returns pszScan.
//
// eg: SubStrEnd("abc", "abcdefg" ) ==> "defg"
//     SubStrEnd("abc", "abZQRT" ) ==> "abZQRT"
LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan);


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey);


int GetDisplayCPLPreference(LPCTSTR szRegVal);


int GetDynaCDSPreference();


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);


LONG WINAPI MyStrToLong(LPCTSTR sz);

BOOL 
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    );

BOOL 
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    );

BOOL 
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    );

typedef struct _APPEXT {
    TCHAR szKeyName[MAX_PATH];
    TCHAR szDefaultValue[MAX_PATH];
    struct _APPEXT* pNext;
} APPEXT, *PAPPEXT;

VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExtList
    );

VOID
DeskAECleanup(
    PAPPEXT pAppExtList
    );

#endif // _DESKCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\common\propsext.cpp ===
//--------------------------------------------------------------------------------
//
//  File:   propsext.cpp
//
//  General handling of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//--------------------------------------------------------------------------------

#include "shfusion.h"

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//
// Count number of objects and number of locks.
//
HINSTANCE    g_hInst = NULL;
BOOL         g_RunningOnNT = FALSE;
LPDATAOBJECT g_lpdoTarget = NULL;

ULONG        g_cObj = 0;
ULONG        g_cLock = 0;



//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if (dwReason == DLL_PROCESS_ATTACH)        // Initializing
    {
        if ((int)GetVersion() >= 0)
        {
            g_RunningOnNT = TRUE;
        }

        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModuleID(hInstance, 124);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }

    return 1;
}
//---------------------------------------------------------------------------
//      DllGetClassObject()
//
//      If someone calls with our CLSID, create an IClassFactory and pass it to
//      them, so they can create and use one of our CPropSheetExt objects.
//
//---------------------------------------------------------------------------
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppvOut )
{
    *ppvOut = NULL; // Assume Failure
    if( IsEqualCLSID( rclsid, g_CLSID_CplExt ) )
    {
        //
        //Check that we can provide the interface
        //
        if( IsEqualIID( riid, IID_IUnknown) ||
            IsEqualIID( riid, IID_IClassFactory )
           )
        {
            //Return our IClassFactory for CPropSheetExt objects
            *ppvOut = (LPVOID* )new CClassFactory();
            if( NULL != *ppvOut )
            {
                //AddRef the object through any interface we return
                ((CClassFactory*)*ppvOut)->AddRef();
                return NOERROR;
            }
            return E_OUTOFMEMORY;
        }
        return E_NOINTERFACE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}

//---------------------------------------------------------------------------
//      DllCanUnloadNow()
//
//      If we are not locked, and no objects are active, then we can exit.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
    SCODE   sc;

    //
    //Our answer is whether there are any object or locks
    //
    sc = (0L == g_cObj && 0 == g_cLock) ? S_OK : S_FALSE;

    return ResultFromScode(sc);
}

//---------------------------------------------------------------------------
//      ObjectDestroyed()
//
//      Function for the CPropSheetExt object to call when it is destroyed.
//      Because we're in a DLL, we only track the number of objects here,
//      letting DllCanUnloadNow take care of the rest.
//---------------------------------------------------------------------------
void FAR PASCAL ObjectDestroyed( void )
{
    g_cObj--;
    return;
}

UINT CALLBACK PropertySheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        if (g_lpdoTarget) {
            g_lpdoTarget->Release();
            g_lpdoTarget = NULL;
        }
        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}



//***************************************************************************
//
//  CClassFactory Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//      Constructor
//---------------------------------------------------------------------------
CClassFactory::CClassFactory()
{
    m_cRef = 0L;
    return;
}

//---------------------------------------------------------------------------
//      Destructor
//---------------------------------------------------------------------------
CClassFactory::~CClassFactory( void )
{
    return;
}

//---------------------------------------------------------------------------
//      QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    //Any interface on this object is the object pointer.
    if( IsEqualIID( riid, IID_IUnknown ) ||
        IsEqualIID( riid, IID_IClassFactory )
       )
    {
        *ppv = (LPVOID)this;
        ++m_cRef;
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//      Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if( 0L == m_cRef ) 
        delete this;

    return cRefT;
}


// Allow the caller to specify another class to use.  The only requirement
// is that there be a contructore with (punk, void FAR PASCAL pfnObjDes(void) )
#ifndef PROPSHEET_CLASS
#define PROPSHEET_CLASS             CPropSheetExt
#endif // PROPSHEET_CLASS

//---------------------------------------------------------------------------
//      CreateInstance()
//---------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR *ppvObj
                              )
{
    CPropSheetExt*  pObj;
    HRESULT         hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    //Verify that a controlling unknown asks for IShellPropSheetExt
    if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
    {
        //Create the object, passing function to notify on destruction
        pObj = new PROPSHEET_CLASS(pUnkOuter, ObjectDestroyed);

        if( NULL == pObj )
        {
            return hr;
        }

        hr = pObj->QueryInterface( riid, ppvObj );

        //Kill the object if initial creation or FInit failed.
        if( FAILED(hr) )
        {
            delete pObj;
        }
        else
        {
            g_cObj++;
        }
        return hr;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      LockServer()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
        g_cLock++;
    }
    else
    {
        g_cLock--;
    }
    return NOERROR;
}



//***************************************************************************
//
//  CPropSheetExt Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//  Constructor
//---------------------------------------------------------------------------
CPropSheetExt::CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;
    return;
}

//---------------------------------------------------------------------------
//  Destructor
//---------------------------------------------------------------------------
CPropSheetExt::~CPropSheetExt( void )
{
    return;
}

//---------------------------------------------------------------------------
//  QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit))
    {
        *ppv = (IShellExtInit *) this;
    }

    if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppv = (LPVOID)this;
    }

    if (*ppv)
    {
        ++m_cRef;
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//---------------------------------------------------------------------------
//  AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::AddRef( void )
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//  Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::Release( void )
{
ULONG cRefT;

    cRefT = --m_cRef;

    if( m_cRef == 0 )
    {
        // Tell the housing that an object is going away so that it
        // can shut down if appropriate.
        if( NULL != m_pfnDestroy )
        {
            (*m_pfnDestroy)();
        }
        delete this;
    }
    return cRefT;
}

//---------------------------------------------------------------------------
//  AddPages()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;
    TCHAR szTitle[ 30 ];

    LoadString( g_hInst, IDS_PAGE_TITLE, szTitle, ARRAYSIZE(szTitle) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hIcon = NULL;
    psp.hInstance = g_hInst;
    psp.pszTemplate =MAKEINTRESOURCE( PROP_SHEET_DLG );
    psp.pfnDlgProc = PropertySheetDlgProc;
    psp.pfnCallback = PropertySheetCallback;
    psp.pszTitle = szTitle;
    psp.lParam = 0;

#ifdef USESLINKCONTROL
    LinkWindow_RegisterClass();
#endif
    
    if( ( hpage = CreatePropertySheetPage( &psp ) ) == NULL )
    {
        return ( E_OUTOFMEMORY );
    }

    if( !lpfnAddPage(hpage, lParam ) )
    {
        DestroyPropertySheetPage(hpage );
        return ( E_FAIL );
    }
    return NOERROR;
}

//---------------------------------------------------------------------------
//  ReplacePage()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    return NOERROR;
}


//---------------------------------------------------------------------------
//  IShellExtInit member function- this interface needs only one
//---------------------------------------------------------------------------

STDMETHODIMP CPropSheetExt::Initialize(LPCITEMIDLIST pcidlFolder,
                                       LPDATAOBJECT pdoTarget,
                                       HKEY hKeyID)
{
    //  The target data object is an HDROP, or list of files from the shell.
    if (g_lpdoTarget)
    {
        g_lpdoTarget->Release();
        g_lpdoTarget = NULL;
    }

    if (pdoTarget)
    {
        g_lpdoTarget = pdoTarget;
        g_lpdoTarget->AddRef();
    }

    return  NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskadp\propsext.cpp ===
#include "deskadp.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskadp\deskadp.cpp ===
/******************************************************************************

  Source File:  deskadp.cpp

  Main code for the advanced desktop adapter page

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-16-97 AndreVa - Created It

******************************************************************************/


#include    "deskadp.h"
#define DECL_CRTFREE
#include <crtfree.h>
#include "shfusion.h"

//
// The function DevicePropertiesW() is implemented in DevMgr.dll; Since we don't have a devmgr.h, we
// explicitly declare it here.
//
typedef int (WINAPI  *DEVPROPERTIESW)(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    BOOL ShowDeviceTree
    );

// OLE-Registry magic number
// 42071712-76d4-11d1-8b24-00a0c9068ff3
//
GUID g_CLSID_CplExt = { 0x42071712, 0x76d4, 0x11d1, 
                        { 0x8b, 0x24, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3 } 
                      };

DESK_EXTENSION_INTERFACE DeskInterface;

static const DWORD sc_AdapterHelpIds[] =
{
    ID_ADP_ADPINFGRP,  IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI1,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI2,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI3,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI4,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI5,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_CHIP,       IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_DAC,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_MEM,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_ADP_STRING, IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_BIOS_INFO,  IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,

    ID_ADP_ADPGRP,     IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,
    IDI_ADAPTER,       IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,
    ID_ADP_ADAPTOR,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,

    IDC_LIST_ALL,      IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LIST_MODES,
    IDC_PROPERTIES,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_PROPERTIES,

    0, 0
};

static const DWORD sc_ListAllHelpIds[] = 
{
    ID_MODE_LIST,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX,
    ID_MODE_LISTGRP, IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX,

    0, 0
};


///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
///////////////////////////////////////////////////////////////////////////////
int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[1500];

    LoadString(g_hInst, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(g_hInst, dwTitleID, Title, ARRAYSIZE(Title));

    return (MessageBox(hwnd, Text, Title, fuStyle));
}



///////////////////////////////////////////////////////////////////////////////
//
// Main dialog box Windows Proc
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
ListAllModesProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPDEVMODEW lpdm, lpdmCur; 
    HWND hList;
    DWORD i;
    LRESULT item;

    switch (uMessage)
    {
    case WM_INITDIALOG:

        //
        // Save the lParam - we will store the new mode here
        //
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        lpdmCur = *((LPDEVMODEW *)lParam);
        Assert (lpdmCur != NULL);

        //
        // Build the list of modes to display
        //
        i = 0;
        hList = GetDlgItem(hDlg, ID_MODE_LIST); 
        while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i))
        {
            TCHAR  achFreData[50];
            TCHAR  achFre[50];
            TCHAR  achStr[80];
            TCHAR  achText[120];
            DWORD  idColor;
            DWORD  idFreq;

            //
            // convert bit count to number of colors and make it a string
            //

            switch (lpdm->dmBitsPerPel)
            {
            case 32: idColor = IDS_MODE_TRUECOLOR32; break;
            case 24: idColor = IDS_MODE_TRUECOLOR24; break;
            case 16: idColor = IDS_MODE_16BIT_COLOR; break;
            case 15: idColor = IDS_MODE_15BIT_COLOR; break;
            case  8: idColor = IDS_MODE_8BIT_COLOR; break;
            case  4: idColor = IDS_MODE_4BIT_COLOR; break;
            default:
                FmtMessageBox(hDlg,
                              MB_OK | MB_ICONINFORMATION,
                              IDS_BAD_COLOR,
                              IDS_BAD_COLOR);

                EndDialog(hDlg, -1);
                break;
            }

            if (lpdm->dmDisplayFrequency == 0)
            {
                FmtMessageBox(hDlg,
                              MB_OK | MB_ICONINFORMATION,
                              IDS_BAD_REFRESH,
                              IDS_BAD_REFRESH);

                EndDialog(hDlg, -1);
                break;
            }
            else if (lpdm->dmDisplayFrequency == 1)
            {
                LoadString(g_hInst, IDS_MODE_REFRESH_DEF, achFre, ARRAYSIZE(achFre));
            }
            else
            {
                if (lpdm->dmDisplayFrequency <= 50)
                    idFreq = IDS_MODE_REFRESH_INT;
                else
                    idFreq = IDS_MODE_REFRESH_HZ;

                LoadString(g_hInst, idFreq, achFreData, ARRAYSIZE(achFreData));
                StringCchPrintf(achFre, ARRAYSIZE(achFre), achFreData, lpdm->dmDisplayFrequency);
            }

            LoadString(g_hInst, idColor, achStr, ARRAYSIZE(achStr));
            StringCchPrintf(achText, ARRAYSIZE(achText), achStr, lpdm->dmPelsWidth, lpdm->dmPelsHeight, achFre);

            item = ListBox_AddString(hList, achText);
            if (lpdm == lpdmCur) 
                ListBox_SetCurSel(hList, item);
            ListBox_SetItemData(hList, item, lpdm);

            i++;
        }

        //
        // If no modes are available, put up a popup and exit.
        //

        if (i == 0)
        {
            EndDialog(hDlg, -1);
        }


        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case ID_MODE_LIST:

            if (HIWORD(wParam) != LBN_DBLCLK)
            {
                return FALSE;
            }

            //
            // fall through, as DBLCLK means select.
            //

        case IDOK:

            //
            // Save the mode back
            //

            item = SendDlgItemMessage(hDlg, ID_MODE_LIST, LB_GETCURSEL, 0, 0);

            if ((item != LB_ERR) &&
                (lpdm = (LPDEVMODEW) SendDlgItemMessage(hDlg, ID_MODE_LIST, LB_GETITEMDATA, item, 0)))
            {
                *((LPDEVMODEW *)GetWindowLongPtr(hDlg, DWLP_USER)) = lpdm;
                EndDialog(hDlg, TRUE);
                break;
            }

            //
            // fall through
            //

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:

            return FALSE;
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_ListAllHelpIds);

        break;

    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_ListAllHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;

}

void Adaptor_OnApply(HWND hDlg)
{
    HINSTANCE               hInst;
    LPDISPLAY_SAVE_SETTINGS lpfnDisplaySaveSettings = NULL;
    long                    lRet = PSNRET_INVALID_NOCHANGEPAGE;

    hInst = LoadLibrary(TEXT("desk.cpl"));
    if (hInst)
    {
        lpfnDisplaySaveSettings = (LPDISPLAY_SAVE_SETTINGS)
                                  GetProcAddress(hInst, "DisplaySaveSettings");
        if (lpfnDisplaySaveSettings)
        {
            LONG lSave = lpfnDisplaySaveSettings(DeskInterface.pContext, hDlg);
            if (lSave == DISP_CHANGE_SUCCESSFUL)
            {
                //
                // Save the current mode - to restore it in case the user cancels the p. sheet
                //
                LPDEVMODEW lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpdmOnCancel);
                lRet = PSNRET_NOERROR;
            }
            else if (lSave == DISP_CHANGE_RESTART)
            {
                //
                // User wants to reboot system.
                //
                PropSheet_RestartWindows(GetParent(hDlg));
                lRet = PSNRET_NOERROR;
            }
        }

        FreeLibrary(hInst);
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lRet);
}

void Adaptor_OnInitDialog(HWND hDlg)
{
    Assert (DeskInterface.cbSize == 0);

    //
    // Get the CPL extension interfaces from IDataObject.
    //
    FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_INTERFACE),
                      (DVTARGETDEVICE FAR *) NULL,
                      DVASPECT_CONTENT,
                      -1,
                      TYMED_HGLOBAL};

    STGMEDIUM stgm;

    HRESULT hres = g_lpdoTarget->GetData(&fmte, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        //
        // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
        //

        PDESK_EXTENSION_INTERFACE pInterface =
            (PDESK_EXTENSION_INTERFACE) GlobalLock(stgm.hGlobal);

        if (pInterface != NULL)
        {
            RtlCopyMemory(&DeskInterface,
                          pInterface,
                          min(pInterface->cbSize,
                              sizeof(DESK_EXTENSION_INTERFACE)));
    
            GlobalUnlock(stgm.hGlobal);
            
            SendDlgItemMessageW(hDlg, ID_ADP_CHIP,       WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.ChipType[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_DAC,        WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.DACType[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_MEM,        WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.MemSize[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_ADP_STRING, WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.AdapString[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_BIOS_INFO,  WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.BiosString[0]));
        
            //
            // Save the initial selected mode - to restore it in case the user cancels the p. sheet
            //

            LPDEVMODEW lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpdmOnCancel);
        }
        
        ReleaseStgMedium(&stgm);
    }

    //
    // Get device description from IDataObject.
    //

    LPWSTR pDeviceDescription;

    FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_NAME),
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte2, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pDeviceDescription = (LPWSTR) GlobalLock(stgm.hGlobal);

        SendDlgItemMessageW(hDlg, ID_ADP_ADAPTOR, WM_SETTEXT, 0, (LPARAM)pDeviceDescription);

        GlobalUnlock(stgm.hGlobal);
        
        ReleaseStgMedium(&stgm);
    }

    //
    // Enable/disable the properties button
    //

    BOOL bEnable = FALSE;
    LPWSTR pwDeviceID = NULL;

    FORMATETC fmte3 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                       (DVTARGETDEVICE FAR *)NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte3, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pwDeviceID = (LPWSTR)GlobalLock(stgm.hGlobal);
        bEnable = ((pwDeviceID != NULL) && (*pwDeviceID != L'\0'));
        GlobalUnlock(stgm.hGlobal);
        ReleaseStgMedium(&stgm);
    }

    HWND hPropButton = GetDlgItem(hDlg, IDC_PROPERTIES);
    if (hPropButton != NULL)
        EnableWindow(hPropButton, bEnable);
}

void Adaptor_OnCancel(HWND hDlg)
{
    //
    // Restore initial mode
    //
    LPDEVMODEW lpdmOnCancel = (LPDEVMODEW) GetWindowLongPtr(hDlg, DWLP_USER);
    DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmOnCancel);
}

void Adaptor_OnListAllModes(HWND hDlg)
{
    LPDEVMODEW lpdmBefore, lpdmAfter;

    lpdmAfter = lpdmBefore = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    if (DialogBoxParam(g_hInst,
                       MAKEINTRESOURCE(DLG_SET_MODE_LIST),
                       hDlg,
                       ListAllModesProc,
                       (LPARAM) &lpdmAfter) == 1 &&
        lpdmAfter && (lpdmAfter != lpdmBefore)) 
    {

        //
        // If the user selected a new setting, tell the property sheet
        // we have outstanding changes. This will enable the Apply button.
        //
        PropSheet_Changed(GetParent(hDlg), hDlg);
        DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmAfter);
    }
}

void Adaptor_OnProperties(HWND hDlg)
{
    // Invoke the device manager property sheets to show the properties of the
    // given hardware.

    LPWSTR pwDeviceID;
    HRESULT hres;
    STGMEDIUM stgm;

    FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                   (DVTARGETDEVICE FAR *) NULL,
                   DVASPECT_CONTENT,
                   -1,
                   TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte2, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pwDeviceID = (LPWSTR) GlobalLock(stgm.hGlobal);

        HINSTANCE hinstDevMgr = LoadLibrary(TEXT("DEVMGR.DLL"));
        if (hinstDevMgr)
        {
            DEVPROPERTIESW pfnDevPropW =
               (DEVPROPERTIESW)GetProcAddress(hinstDevMgr, "DevicePropertiesW");
            if (pfnDevPropW)
            {
                //Display the property sheets for this device.
                (*pfnDevPropW)(hDlg, NULL, pwDeviceID, FALSE);
            }

            FreeLibrary(hinstDevMgr);
        }

        GlobalUnlock(stgm.hGlobal);
        ReleaseStgMedium(&stgm);
    }
}

//---------------------------------------------------------------------------
//
// PropertySheeDlgProc()
//
//  The dialog procedure for the "Adapter" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMessage)
    {
    case WM_INITDIALOG:

        RtlZeroMemory(&DeskInterface, sizeof(DeskInterface));

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            Adaptor_OnInitDialog(hDlg);
        }

        break;

    case WM_COMMAND:

        if (DeskInterface.cbSize > 0) 
        {
            switch( LOWORD(wParam) )
            {
            case IDC_LIST_ALL:
                Adaptor_OnListAllModes(hDlg);
                break;
    
            case IDC_PROPERTIES:
                Adaptor_OnProperties(hDlg);
                break;
    
            default:
                return FALSE;
            }
        }

        break;

    case WM_NOTIFY:

        if (DeskInterface.cbSize > 0) 
        {
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_APPLY: 
                Adaptor_OnApply(hDlg);
                break;
    
            case PSN_RESET:
                Adaptor_OnCancel(hDlg);
                break;
                
            default:
                return FALSE;
            }
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_AdapterHelpIds);

        break;

    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_AdapterHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskadp\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETNAME = deskadp
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll

COFFBASE   = desk

DLLDEF=$(O)\deskadp.def

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskadp.rc   \
          ..\deskadp.cpp  \
          ..\propsext.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\strsafe.lib          \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SHELL_LIB_PATH)\shfusion.lib

UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain

 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskmon\propsext.cpp ===
#include "deskmon.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskmon\deskmon.h ===
/******************************************************************************

  Source File:  deskmon.h

  General include file

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-01-97 AndreVa - Created It

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>
#include <tchar.h>
#include <winuserp.h>
#include <cfgmgr32.h>

#include <initguid.h>
#include <help.h>
#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "..\..\common\deskcmmn.h"
#include "resource.h"

#define STRSAFE_LIB
#include <strsafe.h>


class CMonitorPage
{
public:
    // Constructors / destructor
    CMonitorPage(HWND hDlg);

    // Message handlers
    void OnInitDialog();
    void OnDestroy();
    void OnApply();
    void OnCancel();
    void OnProperties();
    BOOL OnSetActive();
    void OnSelMonitorChanged();
    void OnFrequencyChanged();
    void OnPruningModeChanged();

private:
    // Helpers
    void InitPruningMode();
    void SaveMonitorInstancePath(DEVINST devInstAdapter, LPCTSTR pMonitorID, int nNewItem);
    void RefreshFrequenciesList();

    // Data members
    HWND       m_hDlg;
    LPDEVMODEW m_lpdmPrevious;
    BOOL       m_bCanBePruned;          // true if the raw modes list != pruned modes list
    BOOL       m_bIsPruningReadOnly;    // false if can be pruned and we can write the pruning mode
    BOOL       m_bIsPruningOn;          // non null if pruning mode is on
    int        m_cMonitors;
    HWND       m_hMonitorsList;
    LPDEVMODEW m_lpdmOnCancel;          // device mode to be restored on cancel
    BOOL       m_bOnCancelIsPruningOn;  // pruning mode to be restored on cancel
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskmon\deskmon.cpp ===
/******************************************************************************

  Source File:  deskmon.cpp

  Main code for the advanced desktop Monitor page

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-16-97 AndreVa - Created It

******************************************************************************/


#include    "deskmon.h"
#define DECL_CRTFREE
#include <crtfree.h>


//
// The function DeviceProperties() is implemented in DevMgr.dll; Since we don't have a devmgr.h, we
// explicitly declare it here.
// 
typedef int (WINAPI  *DEVPROPERTIES)(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    BOOL ShowDeviceTree
    );


// OLE-Registry magic number
// 42071713-76d4-11d1-8b24-00a0c9068ff3
//
GUID g_CLSID_CplExt = { 0x42071713, 0x76d4, 0x11d1,
                        { 0x8b, 0x24, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}
                      };


DESK_EXTENSION_INTERFACE DeskInterface;

static const DWORD sc_MonitorHelpIds[] =
{
    IDC_MONITOR_GRP,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDI_MONITOR,        IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDC_MONITORDESC,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDC_MONITORS_LIST,  IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_MONITORTYPE_LISTBOX,
    IDC_PROPERTIES,     IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_PROPERTIES,

    IDC_MONSET_GRP,     IDH_NOHELP, 
    IDC_MONSET_FREQSTR, IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH, 
    IDC_MONSET_FREQ,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH, 
    IDC_MONSET_PRUNNING_MODE,       IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX, 
    IDC_MONSET_PRUNNING_MODE_DESC,  IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX, 

    0, 0
};

///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
///////////////////////////////////////////////////////////////////////////////


int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[1700];

    LoadString(g_hInst, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(g_hInst, dwTitleID, Title, ARRAYSIZE(Title));

    return (MessageBox(hwnd, Text, Title, fuStyle));
}


// Constructors / destructor
CMonitorPage::CMonitorPage(HWND hDlg)
    : m_hDlg(hDlg)
    , m_lpdmPrevious(NULL)
    , m_bCanBePruned(FALSE)
    , m_bIsPruningReadOnly(TRUE)
    , m_bIsPruningOn(FALSE)
    , m_cMonitors(0)
    , m_hMonitorsList(NULL)
    , m_lpdmOnCancel(NULL)
    , m_bOnCancelIsPruningOn(FALSE)
{
}


void CMonitorPage::OnApply()
{
    long lRet = PSNRET_INVALID_NOCHANGEPAGE;
    HINSTANCE hInst;
    LPDISPLAY_SAVE_SETTINGS lpfnDisplaySaveSettings = NULL;

    hInst = LoadLibrary(TEXT("desk.cpl"));
    if (hInst)
    {
        lpfnDisplaySaveSettings = (LPDISPLAY_SAVE_SETTINGS)
                                  GetProcAddress(hInst, "DisplaySaveSettings");
        if (lpfnDisplaySaveSettings)
        {
            long lSave = lpfnDisplaySaveSettings(DeskInterface.pContext, m_hDlg);
            LPDEVMODEW lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);

            if (lSave == DISP_CHANGE_SUCCESSFUL)
            {
                //
                // Save the current mode - to restore it in case the user cancels the p. sheet
                //
                m_lpdmOnCancel = m_lpdmPrevious = lpdmCurrent;
                m_bOnCancelIsPruningOn = m_bIsPruningOn;
                lRet = PSNRET_NOERROR;
            }
            else if (lSave == DISP_CHANGE_RESTART)
            {
                //
                // User wants to reboot system.
                //
                PropSheet_RestartWindows(GetParent(m_hDlg));
                lRet = PSNRET_NOERROR;
            }
            else
            {
                //
                // Keep the apply button active
                //
                lRet = PSNRET_INVALID_NOCHANGEPAGE;
                
                RefreshFrequenciesList();
                
                BOOL bCanBePruned, bIsPruningReadOnly, bIsPruningOn;
                DeskInterface.lpfnGetPruningMode(DeskInterface.pContext, 
                                                 &bCanBePruned, 
                                                 &bIsPruningReadOnly,
                                                 &bIsPruningOn);
                if(m_bIsPruningOn != bIsPruningOn)
                    InitPruningMode();
            }
        }

        FreeLibrary(hInst);
    }

    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, lRet);
}

    
void CMonitorPage::OnCancel()
{
    if (m_bCanBePruned && !m_bIsPruningReadOnly && 
        ((m_bOnCancelIsPruningOn != 0) != (m_bIsPruningOn != 0)))
        DeskInterface.lpfnSetPruningMode(DeskInterface.pContext, m_bOnCancelIsPruningOn);

    DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, m_lpdmOnCancel);
};


void CMonitorPage::OnInitDialog()
{
    m_hMonitorsList = GetDlgItem(m_hDlg, IDC_MONITORS_LIST); 
    HWND hSingleMonitor = GetDlgItem(m_hDlg, IDC_MONITORDESC); 
    ListBox_ResetContent(m_hMonitorsList);

    //
    // Get the CPL extension interfaces from IDataObject.
    //
    STGMEDIUM stgmExt;
    FORMATETC fmteExt = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_INTERFACE),
                         (DVTARGETDEVICE FAR *) NULL,
                         DVASPECT_CONTENT,
                         -1,
                         TYMED_HGLOBAL};

    HRESULT hres = g_lpdoTarget->GetData(&fmteExt, &stgmExt);

    if (SUCCEEDED(hres) && stgmExt.hGlobal)
    {
        //
        // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
        //
        PDESK_EXTENSION_INTERFACE pInterface =
            (PDESK_EXTENSION_INTERFACE) GlobalLock(stgmExt.hGlobal);

        RtlCopyMemory(&DeskInterface,
                      pInterface,
                      min(pInterface->cbSize,
                      sizeof(DESK_EXTENSION_INTERFACE)));

        GlobalUnlock(stgmExt.hGlobal);
        ReleaseStgMedium(&stgmExt);
    }

    //
    // Get the adapter devnode.
    // The adapter is the parent of all monitors in the device tree.
    //
    DEVINST devInstAdapter;
    BOOL bDevInstAdapter = FALSE;

    STGMEDIUM stgmAdpId;
    FORMATETC fmteAdpId = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT,
                           -1,
                           TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmteAdpId, &stgmAdpId);

    if(SUCCEEDED(hres) && stgmAdpId.hGlobal)
    {
        LPWSTR pwDeviceID = (LPWSTR) GlobalLock(stgmAdpId.hGlobal);

        bDevInstAdapter = (CM_Locate_DevNodeW(&devInstAdapter, pwDeviceID, 0) == CR_SUCCESS);

        GlobalUnlock(stgmAdpId.hGlobal);
        ReleaseStgMedium(&stgmAdpId);
    }

    //
    // Get the adapter device and enum all monitors
    //
    STGMEDIUM stgmAdpDev;
    FORMATETC fmteAdpDev = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT,
                           -1,
                           TYMED_HGLOBAL};
    hres = g_lpdoTarget->GetData(&fmteAdpDev, &stgmAdpDev);

    if (SUCCEEDED(hres) && stgmAdpDev.hGlobal)
    {
        LPWSTR pwDisplayDevice = (LPWSTR)GlobalLock(stgmAdpDev.hGlobal);
        LPTSTR pBuffer = pwDisplayDevice;

        if(NULL != pBuffer)
        {
            DISPLAY_DEVICE ddMon;
            BOOL bSuccess = FALSE;
            int cMonitors = 0;

            do 
            {
                ZeroMemory(&ddMon, sizeof(ddMon));
                ddMon.cb = sizeof(ddMon);

                bSuccess = EnumDisplayDevices(pBuffer, cMonitors, &ddMon, 0);
                if (bSuccess) 
                {
                    ++cMonitors;

                    if (ddMon.StateFlags & DISPLAY_DEVICE_ATTACHED)
                    {
                        if(0 == m_cMonitors)
                            SendDlgItemMessage(m_hDlg, IDC_MONITORDESC, WM_SETTEXT, 0, (LPARAM)ddMon.DeviceString);
    
                        int nNewItem = ListBox_AddString(m_hMonitorsList, (LPTSTR)ddMon.DeviceString);
                        if(nNewItem >= 0)
                        {
                            ++m_cMonitors;
    
                            ListBox_SetItemData(m_hMonitorsList, nNewItem, NULL);
                            if(bDevInstAdapter)
                                SaveMonitorInstancePath(devInstAdapter, ddMon.DeviceID, nNewItem);
                        }
                    }
                }
            }
            while (bSuccess);
        }
        
        GlobalUnlock(stgmAdpDev.hGlobal);
        ReleaseStgMedium(&stgmAdpDev);
    }

    if(m_cMonitors <= 0)
    {
        TCHAR szDefaultMonitor[MAX_PATH];
        LoadString(g_hInst, IDS_DEFAULT_MONITOR, szDefaultMonitor, ARRAYSIZE(szDefaultMonitor));
        SendDlgItemMessage(m_hDlg, IDC_MONITORDESC, WM_SETTEXT, 0, (LPARAM)szDefaultMonitor);
        EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), FALSE);
    }
    else if(m_cMonitors == 1)
    {
        BOOL bEnable = ((ListBox_GetCount(m_hMonitorsList) >= 1) &&
                        (NULL != (LPTSTR)ListBox_GetItemData(m_hMonitorsList, 0)));
        EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), bEnable);
    }
    else
    {
        ListBox_SetCurSel(m_hMonitorsList, 0);
        OnSelMonitorChanged();
    }

    ShowWindow(((m_cMonitors <= 1) ? m_hMonitorsList : hSingleMonitor), SW_HIDE);

    //
    // Init the pruning mode check box
    //
    InitPruningMode();
    m_bOnCancelIsPruningOn = m_bIsPruningOn;

    //
    // Save the current mode - in case the user cancels the p. sheet    
    //
    m_lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
}


void CMonitorPage::OnDestroy()
{
    int cMonitors = ListBox_GetCount(m_hMonitorsList);
    for(int nMonitor = 0; nMonitor < cMonitors; ++nMonitor)
    {
        LPTSTR pMonitorInstancePath = (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nMonitor);
        if(NULL != pMonitorInstancePath)
            LocalFree(pMonitorInstancePath);
    }
}


void CMonitorPage::SaveMonitorInstancePath(DEVINST devInstAdapter, LPCTSTR pMonitorID, int nNewItem)
{
    DEVINST devInstChild, devInstPrevChild;
    TCHAR szBuff[256]; // buffer used to concatenate: HARDWAREID, "\" and DRIVER
                       // this is what EnumDisplayDevice returns in DeviceID in case of a monitor
    ULONG lenBuff; // size of the buffer, in bytes

    if (CM_Get_Child(&devInstChild, devInstAdapter, 0) != CR_SUCCESS) 
        return;

    do 
    {
        devInstPrevChild = devInstChild;

        //CM_DRP_HARDWAREID
        lenBuff = ARRAYSIZE(szBuff) - 2 ; // make sure we have place to append "\"
        if (CM_Get_DevNode_Registry_Property(devInstChild,
                                             CM_DRP_HARDWAREID,
                                             NULL,
                                             szBuff,
                                             &lenBuff,
                                             0) != CR_SUCCESS)
            continue;

        // "\"
        StringCchCat(szBuff, ARRAYSIZE(szBuff), TEXT("\\"));

        //CM_DRP_DRIVER
        lenBuff = sizeof(szBuff) - lstrlen(szBuff) * sizeof(TCHAR);
        if (CM_Get_DevNode_Registry_Property(devInstChild,
                                             CM_DRP_DRIVER,
                                             NULL,
                                             szBuff + lstrlen(szBuff),
                                             &lenBuff,
                                             0) != CR_SUCCESS)
            continue;

        if (lstrcmpi(szBuff, pMonitorID) == 0) 
        {
            LPTSTR pMonitorInstancePath = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));
            if((NULL != pMonitorInstancePath) &&
               (CM_Get_Device_ID(devInstChild, pMonitorInstancePath, MAX_PATH, 0) == CR_SUCCESS))
                ListBox_SetItemData(m_hMonitorsList, nNewItem, (LPARAM)pMonitorInstancePath);
            break;
        }

    } 
    while(CM_Get_Sibling(&devInstChild, devInstPrevChild, 0) == CR_SUCCESS);
}


void CMonitorPage::OnSelMonitorChanged()
{
    //
    // Enable / Disable the Properties button
    //
    BOOL bEnable = FALSE;
    if(ListBox_GetCount(m_hMonitorsList) >= 1)
    {
        int nCurSel = ListBox_GetCurSel(m_hMonitorsList);
        if(nCurSel >= 0)
            bEnable = (NULL != (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nCurSel));
    }
    EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), bEnable);
}


void CMonitorPage::OnProperties()
{
    int nSelMonitor;

    if(m_cMonitors <= 0)
        nSelMonitor = -1;
    else if(m_cMonitors == 1)
        nSelMonitor = ((ListBox_GetCount(m_hMonitorsList) >= 1) ? 0 : -1);
    else
        nSelMonitor = ListBox_GetCurSel(m_hMonitorsList);

    if(nSelMonitor < 0)
        return;

    LPTSTR pMonitorInstancePath = (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nSelMonitor);
    if(NULL != pMonitorInstancePath)
    {
        HINSTANCE hinstDevMgr = LoadLibrary(TEXT("DEVMGR.DLL"));

        if (hinstDevMgr)
        {
            DEVPROPERTIES pfnDevProp = (DEVPROPERTIES)GetProcAddress(hinstDevMgr, "DevicePropertiesW");

            if (pfnDevProp)
            {
                //Display the property sheets for this device.
                (*pfnDevProp)(m_hDlg, NULL, pMonitorInstancePath, FALSE);
            }

            FreeLibrary(hinstDevMgr);
        }
    }
}


BOOL CMonitorPage::OnSetActive()
{
    LPDEVMODEW lpdm;
    DWORD      item;
    LPDEVMODEW lpdmCurrent, lpdmPrevious;
    LPDEVMODEW lpdmTmp;
    DWORD      i = 0;
    TCHAR      achFre[50];
    TCHAR      achText[80];
    DWORD      pos;
    HWND       hFreq;
    
    InitPruningMode();
    
    //
    // Build the list of refresh rates for the currently selected mode.
    //
    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    
    if (lpdmCurrent == NULL)
        return -1;

    if (m_lpdmPrevious) 
    {
        if (lpdmCurrent->dmBitsPerPel != m_lpdmPrevious->dmBitsPerPel ||
            lpdmCurrent->dmPelsWidth  != m_lpdmPrevious->dmPelsWidth  ||
            lpdmCurrent->dmPelsHeight != m_lpdmPrevious->dmPelsHeight) 
        {
            ComboBox_ResetContent(hFreq);
        }
    }
    m_lpdmPrevious = lpdmCurrent;
    
    while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i++)) {
    
        //
        // Only show refresh frequencies for current modes.
        //
        if ((lpdmCurrent->dmBitsPerPel != lpdm->dmBitsPerPel)  ||
            (lpdmCurrent->dmPelsWidth  != lpdm->dmPelsWidth)   ||
            (lpdmCurrent->dmPelsHeight != lpdm->dmPelsHeight))
            continue;
    
        //
        // convert bit count to number of colors and make it a string
        //
        // WARNING should this be 0 ?
        if (lpdm->dmDisplayFrequency == 1) {
            LoadString(g_hInst, IDS_DEFFREQ, achText, ARRAYSIZE(achText));
        }
        else {
            DWORD  idFreq = IDS_FREQ;
    
            if (lpdm->dmDisplayFrequency < 50)
            {
                idFreq = IDS_INTERLACED;
            }
    
            LoadString(g_hInst, idFreq, achFre, ARRAYSIZE(achFre));
            StringCchPrintf(achText, ARRAYSIZE(achText), TEXT("%d %s"), lpdm->dmDisplayFrequency, achFre);
        }
    
        //
        // Insert the string in the right place
        //
        pos = 0;
    
        while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))  {
            if ((ULONG_PTR)lpdmTmp != CB_ERR) {
                if (lpdmTmp->dmDisplayFrequency == lpdm->dmDisplayFrequency) {
                    break;
                }
    
                if (lpdmTmp->dmDisplayFrequency < lpdm->dmDisplayFrequency) {
                    pos++;
                    continue;
                }
            }
    
            //
            // Insert it here
            //
            item = ComboBox_InsertString(hFreq, pos, achText);
            ComboBox_SetItemData(hFreq, item, lpdm); 
            break;
        }
    }
    
    //
    // Finally, set the right selection
    //
    pos = 0;
    while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos)) {
    
        if ((ULONG_PTR)lpdmTmp == CB_ERR) {
            FmtMessageBox(m_hDlg,
                          MB_OK | MB_ICONINFORMATION,
                          IDS_BAD_REFRESH,
                          IDS_BAD_REFRESH);
            return -1;
        }
    
        if (lpdmTmp->dmDisplayFrequency == lpdmCurrent->dmDisplayFrequency) {
            ComboBox_SetCurSel(hFreq, pos);
            break;
        }
    
        pos++;
    }
    
    return 0;
}


void CMonitorPage::OnFrequencyChanged()
{
    DWORD       item;
    HWND        hFreq;
    LPDEVMODEW  lpdmSelected = NULL, lpdmCurrent = NULL;

    //
    // Save the mode back
    //
    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    item = ComboBox_GetCurSel(hFreq);
    if (item == LB_ERR) 
        return;

    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    lpdmSelected = (LPDEVMODEW) ComboBox_GetItemData(hFreq, item);

    if (lpdmSelected && (lpdmSelected != lpdmCurrent))
        DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmSelected);
}


void CMonitorPage::OnPruningModeChanged()
{
    if (m_bCanBePruned && !m_bIsPruningReadOnly)
    {
        BOOL bNewIsPruningOn = (BST_UNCHECKED != IsDlgButtonChecked(m_hDlg, IDC_MONSET_PRUNNING_MODE));
        if((m_bIsPruningOn != 0) != bNewIsPruningOn)
        {
            m_bIsPruningOn = bNewIsPruningOn;
            DeskInterface.lpfnSetPruningMode(DeskInterface.pContext, m_bIsPruningOn);
            RefreshFrequenciesList();
        }
    }
}


void CMonitorPage::InitPruningMode()
{
    m_bCanBePruned = FALSE;
    m_bIsPruningReadOnly = TRUE;
    m_bIsPruningOn = FALSE;
    
    DeskInterface.lpfnGetPruningMode(DeskInterface.pContext, 
                                     &m_bCanBePruned, 
                                     &m_bIsPruningReadOnly,
                                     &m_bIsPruningOn);
    
    BOOL bEnable = (m_bCanBePruned && !m_bIsPruningReadOnly);
    EnableWindow(GetDlgItem(m_hDlg, IDC_MONSET_PRUNNING_MODE), bEnable);
    EnableWindow(GetDlgItem(m_hDlg, IDC_MONSET_PRUNNING_MODE_DESC), bEnable);

    BOOL bChecked = (m_bCanBePruned && m_bIsPruningOn);
    CheckDlgButton(m_hDlg, IDC_MONSET_PRUNNING_MODE, bChecked);
}


void CMonitorPage::RefreshFrequenciesList()
{
    LPDEVMODEW lpdm;
    DWORD      item;
    LPDEVMODEW lpdmCurrent, lpdmPrevious;
    LPDEVMODEW lpdmTmp;
    DWORD      i = 0;
    TCHAR      achFre[50];
    TCHAR      achText[80];
    DWORD      pos;
    HWND       hFreq;

    HWND hwndCurr = GetFocus();
    
    //
    // Build the list of refresh rates for the currently selected mode.
    //
    
    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    if (lpdmCurrent == NULL)
        return;

    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    ComboBox_ResetContent(hFreq);
    
    while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i++))
    {

        //
        // Only show refresh frequencies for current modes.
        //
        if ((lpdmCurrent->dmBitsPerPel != lpdm->dmBitsPerPel)  ||
            (lpdmCurrent->dmPelsWidth  != lpdm->dmPelsWidth)   ||
            (lpdmCurrent->dmPelsHeight != lpdm->dmPelsHeight))
            continue;

        //
        // convert bit count to number of colors and make it a string
        //
        // WARNING should this be 0 ?
        if (lpdm->dmDisplayFrequency == 1)
        {
            LoadString(g_hInst, IDS_DEFFREQ, achText, ARRAYSIZE(achText));
        }
        else
        {
            DWORD  idFreq = IDS_FREQ;

            if (lpdm->dmDisplayFrequency < 50)
            {
                idFreq = IDS_INTERLACED;
            }

            LoadString(g_hInst, idFreq, achFre, ARRAYSIZE(achFre));
            StringCchPrintf(achText, ARRAYSIZE(achText), TEXT("%d %s"), lpdm->dmDisplayFrequency, achFre);
        }

        //
        // Insert the string in the right place
        //
        pos = 0;

        while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))
        {
            if ((ULONG_PTR)lpdmTmp != CB_ERR)
            {
                if (lpdmTmp->dmDisplayFrequency == lpdm->dmDisplayFrequency)
                {
                    break;
                }

                if (lpdmTmp->dmDisplayFrequency < lpdm->dmDisplayFrequency)
                {
                    pos++;
                    continue;
                }
            }

            //
            // Insert it here
            //
            item = ComboBox_InsertString(hFreq, pos, achText);
            ComboBox_SetItemData(hFreq, item, lpdm); 
            break;
        }
    }

    //
    // Finally, set the right selection
    //
    pos = 0;
    while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))
    {

        if ((ULONG_PTR)lpdmTmp == CB_ERR)
        {
            FmtMessageBox(m_hDlg,
                          MB_OK | MB_ICONINFORMATION,
                          IDS_BAD_REFRESH,
                          IDS_BAD_REFRESH);
            break;
        }

        if (lpdmTmp->dmDisplayFrequency == lpdmCurrent->dmDisplayFrequency)
        {
            ComboBox_SetCurSel(hFreq, pos);
            break;
        }

        pos++;
    }

    if (hwndCurr)
        SetFocus(hwndCurr);

    return;
}


//---------------------------------------------------------------------------
//
// PropertySheeDlgProc()
//
//  The dialog procedure for the "Monitor" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NMHDR FAR *lpnm;
    CMonitorPage * pMonitorPage = (CMonitorPage*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            pMonitorPage = new CMonitorPage(hDlg);
            if(!pMonitorPage)
                return FALSE;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pMonitorPage);
            pMonitorPage->OnInitDialog();
        }

        break;

    case WM_DESTROY:

        if (pMonitorPage)
        {
            pMonitorPage->OnDestroy();
            SetWindowLongPtr(hDlg, DWLP_USER, NULL);
            delete pMonitorPage;
        }

        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_MONSET_FREQ:

            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                if(pMonitorPage)
                   pMonitorPage->OnFrequencyChanged();
                break;

            default:
                break;
            }
            break;
            
        case IDC_PROPERTIES:
            if(pMonitorPage)
                pMonitorPage->OnProperties();
            break;

        case IDC_MONSET_PRUNNING_MODE:
            PropSheet_Changed(GetParent(hDlg), hDlg);
            if(pMonitorPage)
                pMonitorPage->OnPruningModeChanged();
            break;

        case IDC_MONITORS_LIST:

            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                if(pMonitorPage)
                    pMonitorPage->OnSelMonitorChanged();
                break;

            default:
                return FALSE;
            }
            break;

        default:
            return FALSE;
        }

        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            return (pMonitorPage && pMonitorPage->OnSetActive());

        case PSN_APPLY: 
            if(pMonitorPage)
                pMonitorPage->OnApply();
            break;

        case PSN_RESET: 
            if(pMonitorPage)
                pMonitorPage->OnCancel();
            break;
        
        default:
            return FALSE;
        }

        break;


    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_MonitorHelpIds);

        break;


    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_MonitorHelpIds);

        break;


    default:

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskadp\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for deskctop adapter information

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/

// Icon

#define IDI_ADAPTER           100

// Property sheet

#define PROP_SHEET_DLG        200
#define ID_ADP_ADPGRP         201
#define ID_ADP_ADAPTOR        202
#define ID_ADP_ADPINFGRP      203
#define ID_ADP_CHIP           204
#define ID_ADP_DAC            205
#define ID_ADP_MEM            206
#define ID_ADP_ADP_STRING     207
#define ID_ADP_BIOS_INFO      208
#define ID_ADP_AI1            209
#define ID_ADP_AI2            210
#define ID_ADP_AI3            211
#define ID_ADP_AI4            212
#define ID_ADP_AI5            213
#define IDC_LIST_ALL          215
#define IDC_PROPERTIES        216

#define DLG_SET_MODE_LIST     800
#define ID_MODE_LISTGRP       801
#define ID_MODE_LIST          802

// test bitmap

#define IDS_PAGE_TITLE         1
#define IDS_MODE_4BIT_COLOR    40
#define IDS_MODE_8BIT_COLOR    41
#define IDS_MODE_15BIT_COLOR   42
#define IDS_MODE_16BIT_COLOR   43
#define IDS_MODE_TRUECOLOR24   44
#define IDS_MODE_TRUECOLOR32   45
#define IDS_MODE_REFRESH_DEF   46
#define IDS_MODE_REFRESH_INT   47
#define IDS_MODE_REFRESH_HZ    48
#define IDS_MODE_UNSETTABLE    51
#define IDS_BAD_COLOR          49
#define IDS_BAD_REFRESH        50

// help ids
#define IDH_NOHELP                                                  ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE          4160
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO          4161
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LIST_MODES            4162    
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX    4163
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_PROPERTIES            4164
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskmon\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

TARGETNAME = deskmon
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll


COFFBASE   = desk

DLLDEF=$(O)\deskmon.def


NO_BROWSER_FILE = 1

SOURCES_USED=..\sources.inc $(CCSHELL_DIR)\common.inc $(SOURCES_USED)

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskmon.rc   \
          ..\deskmon.cpp  \
          ..\propsext.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\setupapi.lib         \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\strsafe.lib          \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SHELL_LIB_PATH)\shfusion.lib



UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain

 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskmon\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for desktop monitor information

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/

// Icon 
#define IDI_MONITOR           100


// Property sheet
#define PROP_SHEET_DLG                200
#define IDC_MONITOR_GRP               201
#define IDC_MONITORDESC               202
#define IDC_MONSET_GRP                203
#define IDC_MONSET_FREQSTR            204
#define IDC_MONSET_FREQ               205
#define IDC_PANEL_GRP                 206
#define IDC_PROPERTIES	              207
#define IDC_MONSET_PRUNNING_MODE      208
#define IDC_MONSET_PRUNNING_MODE_DESC 209
#define IDC_MONITORS_LIST             210

// Strings
#define IDS_PAGE_TITLE          1
#define IDS_INTERLACED        301
#define IDS_FREQ              302
#define IDS_DEFFREQ           303
#define IDS_BAD_REFRESH       304
#define IDS_MODE_UNSETTABLE   305
#define IDS_DEFAULT_MONITOR   306

// help
#define IDH_NOHELP                                                  ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE                  4165
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH               4166
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_PROPERTIES            4168
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX     4169
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_MONITORTYPE_LISTBOX   4171
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\backdlg.cpp ===
/*  BACKDLG.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**
**  History:
**
*/

#include "precomp.h"
#include "shlwapi.h"

#define MAX_RHS    256

TCHAR g_szPattern[] = TEXT("pattern");
TCHAR szDesktop[] = TEXT("desktop");
TCHAR szWallpaper[] = TEXT("wallpaper");
TCHAR szTileWall[] = TEXT("TileWallpaper");
TCHAR szDotBMP[] = TEXT(".bmp");
TCHAR szBMP[] = TEXT("\\*.bmp");
TCHAR szDefExt[] = TEXT("bmp");
BOOL g_bValidBitmap = FALSE;    // the currently selected wallpaper is valid

TCHAR g_szCurPattern[MAX_PATH];
TCHAR g_szCurWallpaper[MAX_PATH];
TCHAR g_szTempItem[MAX_PATH];      // which is more of a waste, stack or data?

BOOL g_Back_bInit = TRUE;       // assume we are in initialization process
BOOL g_Back_bChanged = FALSE;   // changes have been made

static void NukeExt(LPTSTR sz);
static LPTSTR NEAR PASCAL NiceName(LPTSTR sz);

INT_PTR CALLBACK PatternDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

#include "help.h"

const static DWORD FAR aBckgrndHelpIds[] = {
        IDC_NO_HELP_1,   IDH_COMM_GROUPBOX,
        IDC_NO_HELP_2,   IDH_COMM_GROUPBOX,
        IDC_PATLIST,     IDH_DSKTPBACKGROUND_PATTLIST,
        IDC_EDITPAT,     IDH_DSKTPBACKGROUND_EDITPAT,
        IDC_WALLLIST,    IDH_DSKTPBACKGROUND_WALLLIST,
        IDC_BROWSEWALL,  IDH_DSKTPBACKGROUND_BROWSE,
        IDC_TXT_DISPLAY, IDH_DSKTPBACKGROUND_DISPLAY,
        IDC_TILE,        IDH_DSKTPBACKGROUND_TILE,
        IDC_CENTER,      IDH_DSKTPBACKGROUND_CENTER,
        IDC_BACKPREV,    IDH_DSKTPBACKGROUND_MONITOR,

        0, 0
};

static const TCHAR szRegStr_Desktop[] = REGSTR_PATH_DESKTOP;
static const TCHAR szRegStr_Setup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
static const TCHAR szSharedDir[] = TEXT("SharedDir");

// we're mainly trying to filter multilingual upgrade cases
// where the text for "(None)" is unpredictable
//
BOOL NEAR PASCAL IsProbablyAValidPattern( LPCTSTR pat )
{
    BOOL sawanumber = FALSE;

    while( *pat )
    {
        if( ( *pat < TEXT('0') ) || ( *pat > TEXT('9') ) )
        {
            // it's not a number, it better be a space
            if( *pat != TEXT(' ') )
                return FALSE;
        }
        else
            sawanumber = TRUE;

        // NOTE: we avoid the need for AnsiNext by only advancing on US TCHARs
        pat++;
    }

    // TRUE if we saw at least one digit and there were only digits and spaces
    return sawanumber;
}


#ifdef DEBUG

#define REG_INTEGER  1000
int  fTraceRegAccess = 0;

void NEAR PASCAL  RegDetails(int iWrite, HKEY hk, LPCTSTR lpszSubKey,
    LPCTSTR lpszValueName, DWORD dwType, LPTSTR  lpszString, int iValue)
{
  TCHAR Buff[256];
  TCHAR far *lpszReadWrite[] = { TEXT("DESK.CPL:Read"), TEXT("DESK.CPL:Write") };

  if(!fTraceRegAccess)
     return;

  switch(dwType)
    {
      case REG_SZ:
          StringCchPrintf(Buff, ARRAYSIZE(Buff), TEXT("%s String:hk=%#08lx, %s:%s=%s\n\r"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, lpszString);
          break;

      case REG_INTEGER:
          StringCchPrintf(Buff, ARRAYSIZE(Buff), TEXT("%s int:hk=%#08lx, %s:%s=%d\n\r"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, iValue);
          break;

      case REG_BINARY:
          StringCchPrintf(Buff, ARRAYSIZE(Buff), TEXT("%s Binary:hk=%#08lx, %s:%s=%#0lx;DataSize:%d\r\n"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, lpszString, iValue);
          break;
    }
  OutputDebugString(Buff);
}

#endif  // DEBUG


//---------------------------------------------------------------------------
//  GetIntFromSubKey
//      hKey is the handle to the subkey
//      (already pointing to the proper location).
//---------------------------------------------------------------------------

int NEAR PASCAL GetIntFromSubkey(HKEY hKey, LPCTSTR lpszValueName, int iDefault)
{
  TCHAR  szValue[20];
  DWORD dwSizeofValueBuff = sizeof(szValue);
  DWORD dwType;
  int   iRetValue = iDefault;

  if((RegQueryValueEx(hKey, lpszValueName, NULL, &dwType,
                      (LPBYTE)szValue,
                      &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
  {
    // BOGUS: This handles only the string type entries now!
    if(dwType == REG_SZ)
        iRetValue = (int)StrToInt(szValue);
#ifdef DEBUG
    else
        OutputDebugString(TEXT("String type expected from Registry\n\r"));
#endif
  }
#ifdef DEBUG
  RegDetails(0, hKey, TEXT(""), lpszValueName, REG_INTEGER, NULL, iRetValue);
#endif
  return(iRetValue);
}

//---------------------------------------------------------------------------
//  GetIntFromReg()
//       Opens the given subkey and gets the int value.
//---------------------------------------------------------------------------

int NEAR PASCAL GetIntFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszNameValue, int iDefault)
{
  HKEY hk;
  int   iRetValue = iDefault;

  // See if the key is present.
  if(RegOpenKeyEx(hKey, lpszSubkey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
      iRetValue = GetIntFromSubkey(hk, lpszNameValue, iDefault);
      RegCloseKey(hk);
    }
  return(iRetValue);
}

BOOL NEAR PASCAL GetStringFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszValueName,
                                        LPCTSTR lpszDefault,
                                        LPTSTR lpszValue,
                                        DWORD cchSizeofValueBuff)
{
  HKEY hk;
  DWORD dwType;
  BOOL  fSuccess = FALSE;
  DWORD cbValueBuff = cchSizeofValueBuff * sizeof(TCHAR);

  // See if the key is present.
  if(RegOpenKeyEx(hKey, lpszSubkey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
      if((RegQueryValueEx(hk, lpszValueName, NULL, &dwType,
                        (LPBYTE)lpszValue,
                &cbValueBuff) == ERROR_SUCCESS) && cbValueBuff)
        {
          // BOGUS: This handles only the string type entries now!
#ifdef DEBUG
          if(dwType != REG_SZ)
            {
              OutputDebugString(TEXT("String type expected from Registry\n\r"));
            }
          else
#endif
            fSuccess = TRUE;
        }
      RegCloseKey(hk);
    }

  // If failure, use the default string.
  if(!fSuccess && lpszDefault)
  {
      StringCchCopy(lpszValue, cchSizeofValueBuff, lpszDefault);
  }

#ifdef DEBUG
  RegDetails(0, hKey, lpszSubkey, lpszValueName, REG_SZ, lpszValue, 0);
#endif
  return(fSuccess);
}

//---------------------------------------------------------------------------
//
//  UpdateRegistry:
//      This updates a given value of any data type at a given
//      location in the registry.
//
//  The value name is passed in as an Id to a string in USER's String table.
//
//---------------------------------------------------------------------------

BOOL FAR PASCAL UpdateRegistry(HKEY     hKey,
                                LPCTSTR   lpszSubkey,
                                LPCTSTR   lpszValueName,
                                DWORD   dwDataType,
                                LPVOID  lpvData,
                                DWORD   dwDataSize)
{
  HKEY  hk;

  if (RegCreateKeyEx(hKey, lpszSubkey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS)
  {
      RegSetValueEx(hk, lpszValueName,
                        0L, dwDataType,
                        (const UCHAR *) lpvData,
                        dwDataSize);
#ifdef DEBUG
      RegDetails(1, hKey, lpszSubkey, lpszValueName, dwDataType, (LPTSTR)lpvData, (int)dwDataSize);
#endif
      RegCloseKey(hk);
      return(TRUE);
  }
  
  return(FALSE);
}

/*-------------------------------------------------------------
** force the update of the preview.
**-------------------------------------------------------------*/
void NEAR PASCAL UpdatePreview(HWND hDlg, WORD flags)
{
    if (IsDlgButtonChecked(hDlg, IDC_TILE))
        flags |= BP_TILE;

    SendDlgItemMessage(hDlg, IDC_BACKPREV, WM_SETBACKINFO, flags, 0L);

    if (!g_Back_bInit && !g_Back_bChanged)
    {
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

        g_Back_bChanged = TRUE;
    }
}

/*------------------------------------------------------------------
** read in all of the entries (LHS only) in a section.
**
** return: handle to local (fixed) memory containing names
**------------------------------------------------------------------*/
HANDLE PASCAL GetSection(LPTSTR lpIniFile, LPTSTR lpSection)
{
    int nCount;
    int cchSize = 4096;
    int cbSize = (cchSize * sizeof(TCHAR));
    HANDLE hLocal, hTemp;

    if (!(hLocal = LocalAlloc(LPTR, cbSize)))
        return(NULL);

    while (1)
    {
        nCount = GetPrivateProfileString(lpSection, NULL, g_szNULL, (LPTSTR)hLocal, cchSize, lpIniFile);

        if (nCount < (cchSize-1))
            break;

        // need to grow the buffer
        cchSize += 2048;
        cbSize = (cchSize * sizeof(TCHAR));
        hTemp = hLocal;
        if (!(hLocal = LocalReAlloc(hTemp, cbSize, LMEM_MOVEABLE)))
        {
            LocalFree(hTemp);
            return(NULL);
        }
    }

    return(hLocal);
}

static void NukeExt(LPTSTR sz)
{
    int len;

    len = lstrlen(sz);

    if (len > 4 && sz[len-4] == TEXT('.'))
        sz[len-4] = 0;
}

static void NameOnly(LPTSTR sz)
{
    LPTSTR p = sz;
    LPTSTR s = NULL;

    while( *p )
    {
        if( ( *p == TEXT('\\') ) || ( *p == TEXT(':') ) )
            s = p;

        p++;
    }

    if( s )
    {
        p = sz;

        while( *s++ )
        {
            *p++ = *s;
        }
    }
}

static BOOL PathOnly(LPTSTR sz)
{
    LPTSTR p = sz;
    LPTSTR s = NULL;

    while( *p )
    {
        if( *p == TEXT('\\') )
        {
            s = p;
        }
        else if( *p == TEXT(':') )
        {
            s = p + 1;
        }

        p++;
    }

    if( s )
    {
        if( s == sz )
            s++;

        *s = TEXT('\0');
        return TRUE;
    }

    return FALSE;
}

static LPTSTR NEAR PASCAL NiceName(LPTSTR sz)
{
    NukeExt(sz);

    if (IsCharUpper(sz[0]) && IsCharUpper(sz[1]))
    {
        CharLower(sz);
        CharUpperBuff(sz, 1);
    }

    return sz;
}

int NEAR PASCAL AddAFileToLB( HWND hwndList, LPCTSTR szDir, LPTSTR szFile )
{
    int index = LB_ERR;

    int nAlloc = MAX_PATH;
    LPTSTR szPath = (LPTSTR)LocalAlloc( LPTR, nAlloc * sizeof(TCHAR) );

    if( szPath )
    {
        if( szDir )
        {
            StringCchPrintf(szPath, nAlloc, TEXT("%s\\"), szDir);
        }
        else
            *szPath = TEXT('\0');

        StringCchCat( (LPTSTR)szPath, nAlloc, szFile );
        NameOnly( szFile );
        NiceName( szFile );

        index = (int)SendMessage( hwndList, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szFile );

        if( index >= 0 )
        {
            SendMessage( hwndList, LB_SETITEMDATA, (WPARAM)index,
                (LPARAM)(LPTSTR)szPath );
        }
        else
            LocalFree( (HANDLE)szPath );
    }

    return index;
}

void NEAR PASCAL AddFilesToLB(HWND hwndList, LPTSTR pszDir, LPTSTR szSpec)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    TCHAR szBuf[MAX_PATH];

    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s%s"), pszDir, szSpec);

    h = FindFirstFile(szBuf, &fd);

    if (h != INVALID_HANDLE_VALUE)
    {
        do
        {
            AddAFileToLB(hwndList, pszDir, fd.cFileName);
        }
        while (FindNextFile(h, &fd));

        FindClose(h);
    }
}

/*-------------------------------------------------------------
** set a new wallpaper and notify the right places.
**
** the new name is in g_szCurWallpaper
**-------------------------------------------------------------*/
void NEAR PASCAL SetNewWallpaper(HWND hDlg, LPTSTR szFile, int cchFile, BOOL bCanAdd)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_WALLLIST);

    if(!szFile || !lstrcmpi(szFile, g_szNone))
        szFile = TEXT("");

    if(szFile[1] == TEXT(':'))
    {
        TCHAR szDrive[3];
        TCHAR szNet[MAX_PATH];
        ULONG lenNet = ARRAYSIZE(szNet);

        StringCchCopy(szDrive, ARRAYSIZE(szDrive), szFile);
        if ((NO_ERROR == WNetGetConnection(szDrive, szNet, &lenNet)) &&
            (szNet[0] == TEXT('\\')) && (szNet[1] == TEXT('\\')))
        {
            StringCchCat(szNet, ARRAYSIZE(szNet), szFile+2);
            StringCchCopy(szFile, cchFile, szNet);
        }
    }

    StringCchCopy(g_szCurWallpaper, ARRAYSIZE(g_szCurWallpaper), szFile);
    UpdatePreview(hDlg, BP_NEWWALL);

    if(bCanAdd && *szFile && g_bValidBitmap)
    {
        TCHAR szName[MAX_PATH];
        int sel;

        StringCchCopy(szName, ARRAYSIZE(szName), szFile);
        NameOnly(szName);
        NiceName(szName);

        if ((sel = (int)SendMessage(hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1,
            (LPARAM)(LPTSTR)szName)) == LB_ERR)
        {
            sel = AddAFileToLB(hwndList, NULL, szFile);
        }

        SendMessage(hwndList, LB_SETCURSEL, (WPARAM)sel, 0L);
    }

    BOOL bEnable = (*szFile) ? TRUE : FALSE;

    EnableWindow( GetDlgItem(hDlg, IDC_TXT_DISPLAY), bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_TILE), bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_CENTER), bEnable );
}

void NEAR PASCAL InitBackgroundDialog(HWND hDlg)
{
    HANDLE hSection;
    HWND hwndList;
    LPTSTR pszBuffer;
    TCHAR szBuf[MAX_PATH];
    TCHAR szCurPatBits[MAX_PATH];

    g_szCurPattern[0] = 0;
    g_szCurWallpaper[0] = 0;
    g_Back_bChanged = FALSE;

    /*
    ** initialize the pattern list
    */
    // get the current pattern.
    szCurPatBits[0] = 0;
    GetStringFromReg(HKEY_CURRENT_USER, szRegStr_Desktop,
                                        g_szPattern, g_szNULL, szCurPatBits,
                                        ARRAYSIZE(szCurPatBits));
    if (!(*szCurPatBits))
        StringCchCopy(g_szCurPattern, ARRAYSIZE(g_szCurPattern), g_szNone);
    else
        *g_szCurPattern = 0;

    hwndList = GetDlgItem(hDlg, IDC_PATLIST);
    if (hSection = GetSection(g_szControlIni, g_szPatterns))
    {
        BOOL bAddedNone = FALSE;
        /* Put the patterns into the combo box. */
        for (pszBuffer = (LPTSTR) LocalLock(hSection); *pszBuffer; pszBuffer += (lstrlen(pszBuffer)+1))
        {
            if (GetPrivateProfileString(g_szPatterns, pszBuffer, g_szNULL, szBuf, ARRAYSIZE(szBuf), g_szControlIni))
            {
                BOOL bIsNone = !bAddedNone && !lstrcmpi( g_szNone, szBuf );

                /* if there's a right-hand side, add it to the list box */
                if( bIsNone || IsProbablyAValidPattern( szBuf ) )
                {
                    if( bIsNone )
                        bAddedNone = TRUE;

                    SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pszBuffer);

                    // if haven't found current pattern name, maybe this is it.
                    if (!(*g_szCurPattern) && (!lstrcmpi(szBuf, szCurPatBits)))
                    {
                        // same pattern bits.  we have a name
                        StringCchCopy(g_szCurPattern, ARRAYSIZE(g_szCurPattern), pszBuffer);
                    }
                }
            }
        }
        LocalUnlock(hSection);
        LocalFree(hSection);
    }

    // if our patternTEXT('s bits weren')t in the list, use a fake name
    if (!(*g_szCurPattern))
        LoadString(hInstance, IDS_UNLISTEDPAT, g_szCurPattern, ARRAYSIZE(g_szCurPattern));

    SendMessage(hwndList, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)(LPTSTR)g_szCurPattern);
    UpdatePreview(hDlg, BP_NEWPAT);

    // exclude TEXT("none") pattern
    if( (int)SendDlgItemMessage(hDlg,IDC_PATLIST,LB_GETCURSEL,0,0l) <= 0 )
    {
        HWND epat = GetDlgItem( hDlg, IDC_EDITPAT );

        if( GetFocus() == epat )
        {
            SendMessage( hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem( hDlg, IDC_PATLIST ), (LPARAM)TRUE );
        }

        EnableWindow( epat, FALSE );
    }

    /*
    ** initialize the tile/center buttons
    */
    if(GetIntFromReg(HKEY_CURRENT_USER, szRegStr_Desktop, szTileWall, 1))
        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, IDC_TILE);
    else
        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, IDC_CENTER);

    /*
    ** initialize the wallpaper list
    */
    hwndList = GetDlgItem(hDlg, IDC_WALLLIST);

    if (!GetWindowsDirectory(szBuf, ARRAYSIZE(szBuf)))
    {
        szBuf[0] = 0;
    }

    // override with net home dir on shared copies of windows
    GetStringFromReg(HKEY_LOCAL_MACHINE, szRegStr_Setup, szSharedDir, (LPTSTR)NULL, szBuf, ARRAYSIZE(szBuf));
    AddFilesToLB(hwndList, szBuf, szBMP);

    GetStringFromReg(HKEY_CURRENT_USER, szRegStr_Desktop, szWallpaper, g_szNone, szBuf, ARRAYSIZE(szBuf));

    SetNewWallpaper(hDlg, szBuf, ARRAYSIZE(szBuf), TRUE); // will add and select if not in list

    // and don't forget the 'none' option
    if (SendMessage(hwndList, LB_INSERTSTRING, 0, (LPARAM)(LPTSTR)g_szNone) !=
        LB_ERR)
    {
        int sel = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);

        if (sel == -1)
            sel = 0;

        SendMessage(hwndList, LB_SETCURSEL, (WPARAM)sel, 0L);
        if (!sel) {
            EnableWindow( GetDlgItem(hDlg, IDC_TILE), FALSE );
            EnableWindow( GetDlgItem(hDlg, IDC_CENTER), FALSE );
            EnableWindow( GetDlgItem(hDlg, IDC_TXT_DISPLAY), FALSE );
        }
    }

    // allow people to drag wallpapers to this page
    DragAcceptFiles(hDlg, TRUE);
}

//the intl tools cannot handle embedded nulls in strings
//hack: use the vertical bar and convert
void NEAR PASCAL
ConvertPipesToNull(LPTSTR szFilter)
{
    while (*szFilter)
    {
        LPTSTR p = CharNext(szFilter);

        if (*szFilter == TEXT('|'))
            *szFilter = TEXT('\0');

        szFilter = p;
    }
}

void NEAR PASCAL BrowseForWallpaper(HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    static TCHAR szWorkDir[MAX_PATH] = TEXT("");
    OPENFILENAME ofn;

    TCHAR szTitle[CCH_MAX_STRING];
    TCHAR szFilter[CCH_MAX_STRING];

    LoadString(hInstance, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
    if (LoadString(hInstance, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)))
        ConvertPipesToNull(szFilter);


    if (!PathOnly(szWorkDir))
    {
        if (!GetWindowsDirectory(szWorkDir, ARRAYSIZE(szWorkDir)))
        {
            szWorkDir[0] = 0;
        }
    }

    szPath[0] = TEXT('\0');

    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.nMaxCustFilter    = 0;
    ofn.lpstrFile         = szPath;
    ofn.nMaxFile          = ARRAYSIZE(szPath);
    ofn.lpstrInitialDir   = (szWorkDir[0] ? szWorkDir : NULL);
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
    ofn.lpfnHook          = NULL;
    ofn.lpstrDefExt       = szDefExt;
    ofn.lpstrFileTitle    = NULL;

    if (GetOpenFileName(&ofn) && (lstrcmpi(g_szCurWallpaper, szPath) != 0))
    {
        CharUpper(szPath); // will be nicenamed (best we can do...)
        SetNewWallpaper(hDlg, szPath, ARRAYSIZE(szPath), TRUE);
    }

    if (!GetCurrentDirectory(ARRAYSIZE(szWorkDir), szWorkDir))
    {
        szWorkDir[0] = 0;
    }
}

void NEAR PASCAL HandleWallpaperDrop(HWND hDlg, HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];

    if (DragQueryFile(hDrop, 1, szPath, ARRAYSIZE(szPath)) &&
        (lstrcmpi(g_szCurWallpaper, szPath) != 0))
    {
        int len = lstrlen(szPath);

        if (len > 4 && !lstrcmpi(szPath+len-4, szDotBMP))
            SetNewWallpaper(hDlg, szPath, ARRAYSIZE(szPath), TRUE);
    }

    DragFinish(hDrop);
}


INT_PTR APIENTRY  BackgroundDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    TCHAR szTiled[] = TEXT("0");
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[50];
    int  iTemp;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY: {
                    DWORD dwRet = PSNRET_NOERROR;
                    if (g_Back_bChanged)
                    {
                        HCURSOR old = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
                        HWND cover;

                        if (!g_bValidBitmap)
                        {
                            LoadString(hInstance, IDS_BADWALLPAPER, szBuf, ARRAYSIZE(szBuf));
                            GetWindowText(GetParent(hDlg), szBuf2, ARRAYSIZE(szBuf2));
                            MessageBox(hDlg, szBuf, szBuf2, MB_OK | MB_ICONEXCLAMATION);
                            dwRet = PSNRET_INVALID_NOCHANGEPAGE;
                        }

                        // do this after whimpering
                        cover = CreateCoverWindow( COVER_NOPAINT );

                        // need to write out tile first
                        szTiled[0] += (TCHAR)IsDlgButtonChecked(hDlg, IDC_TILE);
                        UpdateRegistry(HKEY_CURRENT_USER, szRegStr_Desktop,
                            szTileWall, REG_SZ, szTiled, SIZEOF(TCHAR)*(lstrlen(szTiled)+1));

                        if (g_bValidBitmap)
                        {
                            SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, g_szCurWallpaper,
                                SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
                        }

                        if (GetPrivateProfileString(g_szPatterns, g_szCurPattern, g_szNULL, szBuf, ARRAYSIZE(szBuf), g_szControlIni))
                        {
                            SystemParametersInfo(SPI_SETDESKPATTERN, 0, szBuf,
                                        SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
                        }

                        // we're back to no changes
                        g_Back_bChanged = FALSE;

                        if( cover )
                            PostMessage( cover, WM_CLOSE, 0, 0L );

                        SetCursor( old );
                    }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwRet );
                    return TRUE;
                }

                case PSN_RESET:
                    break;
            }
            break;

        case WM_INITDIALOG:
            g_Back_bInit = TRUE;
            InitBackgroundDialog(hDlg);
            g_Back_bInit = FALSE;               // no longer initializing
            break;

        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            g_Back_bInit = TRUE;    // fake init so we don't do PSM_CHANGED
            UpdatePreview(hDlg, BP_REINIT | BP_NEWPAT );
            g_Back_bInit = FALSE;
            break;

        case WM_DESTROY:
        {
            int count = (int)SendDlgItemMessage(hDlg, IDC_WALLLIST,
                LB_GETCOUNT, 0, 0L);

            while (count--)
            {
                LPTSTR sz = (LPTSTR)SendDlgItemMessage(hDlg, IDC_WALLLIST,
                    LB_GETITEMDATA, count, 0L);

                if (sz)
                    LocalFree ((HANDLE)sz);
            }
            break;
        }


        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, TEXT("display.hlp"),
                HELP_WM_HELP, (DWORD_PTR) (LPTSTR) aBckgrndHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR) (LPTSTR) aBckgrndHelpIds);
            return TRUE;

        case WM_DROPFILES:
            HandleWallpaperDrop(hDlg, (HDROP)wParam);
            return TRUE;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendDlgItemMessage(hDlg, IDC_BACKPREV, message, wParam, lParam);
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PATLIST:
                    if(HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        iTemp = (int)SendDlgItemMessage(hDlg,IDC_PATLIST,
                            LB_GETCURSEL,0,0l);
                        if(iTemp >= 0)
                        {
                            SendDlgItemMessage(hDlg, IDC_PATLIST, LB_GETTEXT,
                                iTemp, (LPARAM)(LPTSTR)szBuf);

                            if (lstrcmpi(szBuf, g_szCurPattern) == 0)
                                break;

                            StringCchCopy(g_szCurPattern, ARRAYSIZE(g_szCurPattern), szBuf);
                            UpdatePreview(hDlg, BP_NEWPAT);
                        }

                        EnableWindow( GetDlgItem( hDlg, IDC_EDITPAT ),
                            ( iTemp > 0 ) );  // exclude "none" pattern
                    }
                    break;

                case IDC_WALLLIST:
                    if(HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        LPTSTR pBuf = NULL;

                        iTemp = (int)SendDlgItemMessage(hDlg,IDC_WALLLIST,
                            LB_GETCURSEL,0,0l);

                        if(iTemp >= 0)
                        {
                            pBuf = (LPTSTR)SendDlgItemMessage(hDlg,
                                IDC_WALLLIST, LB_GETITEMDATA, iTemp, 0L);
                        }

                        SetNewWallpaper(hDlg, pBuf, pBuf ? MAX_PATH : 0, FALSE);
                    }
                    break;

                case IDC_CENTER:
                case IDC_TILE:
                    if ((HIWORD(wParam) == BN_CLICKED) &&
                                (!IsDlgButtonChecked(hDlg, LOWORD(wParam))))
                    {
                        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, LOWORD(wParam));
                        UpdatePreview(hDlg, 0);
                    }
                    break;

                case IDC_BROWSEWALL:
                    BrowseForWallpaper(hDlg);
                    break;
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\deskcmmn.cpp ===
#include "precomp.h"

#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\desk.cpp ===
#include "precomp.h"
#include "winuser.h"
#include <shdguid.h>            // For CLSID_CDeskHtmlProp
#include <shlwapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapip.h>
#include <regapi.h>
#include <ctxdef.h> // hydra stuff
#include <cowsite.h>
#include <theme.h>

#include "cplext.h"
#include "cplp.h"


HWND g_hDlg = NULL;


///////////////////////////////////////////////////////////////////////////////
// Array defining each page in the sheet
///////////////////////////////////////////////////////////////////////////////

typedef struct {
    int id;
    DLGPROC pfnDlgProc;
    RESTRICTIONS dwPolicy1;
    RESTRICTIONS dwPolicy2;
    long nExtensionID;          // The page
} PAGEINFO;

PAGEINFO aPageInfo[] = {
    { 0,                NULL,               REST_NODISPLAYAPPEARANCEPAGE, REST_NOTHEMESTAB, PAGE_DISPLAY_THEMES},       // Theme page
    { DLG_BACKGROUND,   BackgroundDlgProc,  REST_NODISPBACKGROUND, (RESTRICTIONS)0, 0},                                               // Background page
    { DLG_SCREENSAVER,  NULL,               REST_NODISPSCREENSAVEPG, (RESTRICTIONS)0, 0},                                             // Screen Saver page
    { 0,                NULL,               REST_NODISPLAYAPPEARANCEPAGE, (RESTRICTIONS)0, PAGE_DISPLAY_APPEARANCE},                  // Appearance page
    { 0,                NULL,               REST_NODISPSETTINGSPG, (RESTRICTIONS)0, PAGE_DISPLAY_SETTINGS},                           // Settings page
};

#define C_PAGES_DESK    ARRAYSIZE(aPageInfo)
#define IPI_SETTINGS    (C_PAGES_DESK-1)        // Index to "Settings" page
#define SZ_WALLPAPER    L"Wallpaper"

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)


IThemeUIPages * g_pThemeUI = NULL;

// Local Constant Declarations
static const TCHAR sc_szCoverClass[] = TEXT("DeskSaysNoPeekingItsASurprise");
LRESULT CALLBACK CoverWindowProc( HWND, UINT, WPARAM, LPARAM );

// These are actions that can be passed in the cmdline.
// FORMAT: "/Action:<ActionType>" 
#define DESKACTION_NONE             0x00000000
#define DESKACTION_OPENTHEME        0x00000001
#define DESKACTION_OPENMSTHEM       0x00000002

///////////////////////////////////////////////////////////////////////////////
// Globals
///////////////////////////////////////////////////////////////////////////////

TCHAR gszDeskCaption[CCH_MAX_STRING];

TCHAR g_szNULL[] = TEXT("");
TCHAR g_szControlIni[] = TEXT("control.ini");
TCHAR g_szPatterns[] = TEXT("patterns") ;
TCHAR g_szNone[CCH_NONE];                      // this is the '(None)' string
TCHAR g_szSystemIni[] = TEXT("system.ini");
TCHAR g_szWindows[] = TEXT("Windows");

TCHAR szRegStr_Colors[] = REGSTR_PATH_COLORS;

HDC g_hdcMem = NULL;
HBITMAP g_hbmDefault = NULL;
BOOL g_bMirroredOS = FALSE;

///////////////////////////////////////////////////////////////////////////////
// Externs
///////////////////////////////////////////////////////////////////////////////
extern BOOL NEAR PASCAL GetStringFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszValueName,
                                        LPCTSTR lpszDefault,
                                        LPTSTR lpszValue,
                                        DWORD cchSizeofValueBuff);



//============================================================================================================
// Class
//============================================================================================================
class CDisplayControlPanel      : public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);


    void DisplayDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline);

    CDisplayControlPanel(void);
    virtual ~CDisplayControlPanel(void);

private:
    // Private Member Variables
    long                    m_cRef;
    HANDLE                  m_hBackgroundThreads;

    void _ShowDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline);
};



/*---------------------------------------------------------
**
**---------------------------------------------------------*/
BOOL NEAR PASCAL CreateGlobals()
{
    WNDCLASS wc;
    HBITMAP hbm;
    HDC hdc;

    //
    // Check if the mirroring APIs exist on the current
    // platform.
    //
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    if( !GetClassInfo( hInstance, sc_szCoverClass, &wc ) )
    {
        // if two pages put one up, share one dc
        wc.style = CS_CLASSDC;
        wc.lpfnWndProc = CoverWindowProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hIcon = (HICON)( wc.hCursor = NULL );
        // use a real brush since user will try to paint us when we're "hung"
        wc.hbrBackground = (HBRUSH) GetStockObject( NULL_BRUSH );
        wc.lpszMenuName = NULL;
        wc.lpszClassName = sc_szCoverClass;

        if( !RegisterClass( &wc ) )
            return FALSE;
    }

    hdc = GetDC(NULL);
    g_hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!g_hdcMem)
        return FALSE;

    hbm = CreateBitmap(1, 1, 1, 1, NULL);
    if (hbm)
    {
        g_hbmDefault = (HBITMAP) SelectObject(g_hdcMem, hbm);
        SelectObject(g_hdcMem, g_hbmDefault);
        DeleteObject(hbm);
    }

    LoadString(hInstance, IDS_NONE, g_szNone, ARRAYSIZE(g_szNone));

    return TRUE;
}


int DisplaySaveSettings(PVOID pContext, HWND hwnd)
{
    int iRet = 0;

    if (g_pThemeUI)
    {
        g_pThemeUI->DisplaySaveSettings(pContext, hwnd, &iRet);
    }
    
    return iRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// InstallScreenSaver
//
// Provides a RUNDLL32-callable routine to install a screen saver
//
///////////////////////////////////////////////////////////////////////////////


//
// Windows NT:
//
// Thunk ANSI version to the Unicode function
//
void WINAPI InstallScreenSaverW( HWND wnd, HINSTANCE inst, LPWSTR cmd, int shw );

void WINAPI InstallScreenSaverA( HWND wnd, HINSTANCE inst, LPSTR cmd, int shw )
{
    LPWSTR  pwszCmd;
    int     cch;

    cch = MultiByteToWideChar( CP_ACP, 0, cmd, -1, NULL, 0);
    if (cch == 0)
        return;

    pwszCmd = (LPWSTR) LocalAlloc( LMEM_FIXED, cch * SIZEOF(TCHAR) );
    if (pwszCmd == NULL)
        return;

    if (0 != MultiByteToWideChar( CP_ACP, 0, cmd, -1, pwszCmd, cch))
    {
        InstallScreenSaverW(wnd, inst, pwszCmd, shw);
    }

    LocalFree(pwszCmd);
}

#define REAL_INSTALL_SCREEN_SAVER   InstallScreenSaverW

void WINAPI REAL_INSTALL_SCREEN_SAVER( HWND wnd, HINSTANCE inst, LPTSTR cmd, int shw )
{
    TCHAR buf[ MAX_PATH ];
    int timeout;

    StringCchCopy( buf, ARRAYSIZE(buf), cmd );
    PathGetShortPath( buf ); // so msscenes doesn't die
    WritePrivateProfileString( TEXT("boot"), TEXT("SCRNSAVE.EXE"), buf, TEXT("system.ini") );

    SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, TRUE, NULL,
        SPIF_UPDATEINIFILE );

    // make sure the user has a reasonable timeout set
    SystemParametersInfo( SPI_GETSCREENSAVETIMEOUT, 0, &timeout, 0 );
    if( timeout <= 0 )
    {
        // 15 minutes seems like a nice default
        SystemParametersInfo( SPI_SETSCREENSAVETIMEOUT, 900, NULL,
            SPIF_UPDATEINIFILE );
    }

    // bring up the screen saver page on our rundll
    Control_RunDLLW( wnd, inst, TEXT("DESK.CPL,,1"), shw );
}

/*****************************************************************************\
*
* DeskInitCpl( void )
*
\*****************************************************************************/

BOOL DeskInitCpl(void) 
{
    InitCommonControls();

    CreateGlobals();

    return TRUE;
}


HRESULT OpenAdvancedDialog(HWND hDlg, const CLSID * pClsid)
{
    HRESULT hr = E_FAIL;
    IEnumUnknown * pEnumUnknown;

    hr = g_pThemeUI->GetBasePagesEnum(&pEnumUnknown);
    if (SUCCEEDED(hr))
    {
        IUnknown * punk;

        hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
        if (SUCCEEDED(hr))
        {
            IBasePropPage * pBasePage;

            hr = punk->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                IPropertyBag * pPropertyBag;

                hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    if (IsEqualCLSID(PPID_Background, *pClsid))
                    {
                        // We are going to treat the Background tab differently.  We tell it to open
                        // the advanced dialog.  We do this so it can close the dialog if the user
                        // clicks to open the Gallery and we need the CPL to close.
                        hr = SHPropertyBag_WriteBOOL(pPropertyBag, SZ_PBPROP_OPENADVANCEDDLG, TRUE);
                    }
                    else
                    {
                        IAdvancedDialog * pAdvAppearDialog;

                        hr = pBasePage->GetAdvancedDialog(&pAdvAppearDialog);
                        if (SUCCEEDED(hr))
                        {
                            BOOL fEnableApply = FALSE;

                            hr = pAdvAppearDialog->DisplayAdvancedDialog(hDlg, pPropertyBag, &fEnableApply);
                            if (SUCCEEDED(hr) && fEnableApply)
                            {
                                EnableApplyButton(hDlg);
                                g_pThemeUI->UpdatePreview(0);   // The Preview settings may have changed.
                            }

                            pAdvAppearDialog->Release();
                        }
                    }

                    pPropertyBag->Release();
                }

                pBasePage->Release();
            }

            punk->Release();
        }

        pEnumUnknown->Release();
    }

    return hr;
}


HRESULT SetAdvStartPage(LPTSTR pszStartPage, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // Does the caller want us to open the advanced dialog to a certain tab?
    if (g_pThemeUI)
    {
        // Yes, so open the dialog.
        if (!StrCmpI(pszStartPage, TEXT("Theme Settings")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_Theme);
        }
        else if (!StrCmpI(pszStartPage, TEXT("Appearance")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_BaseAppearance);
        }
        else if (!StrCmpI(pszStartPage, TEXT("Web")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_Background);
            StringCchCopy(pszStartPage, cchSize, L"Desktop");
        }
    }

    return hr;
}


typedef struct
{
    LPCTSTR pszCanonical;
    UINT nResourceID;
} CANONICAL_TO_LOCALIZE_TABMAPPING;

CANONICAL_TO_LOCALIZE_TABMAPPING s_TabMapping[] =
{
    {SZ_DISPLAYCPL_OPENTO_THEMES, IDS_TAB_THEMES},
    {SZ_DISPLAYCPL_OPENTO_DESKTOP, IDS_TAB_DESKTOP},
    {TEXT("Background"), IDS_TAB_DESKTOP},                          // These are other names people may use
    {TEXT("Screen Saver"), IDS_TAB_SCREENSAVER},                    // These are other names people may use
    {SZ_DISPLAYCPL_OPENTO_SCREENSAVER, IDS_TAB_SCREENSAVER},
    {SZ_DISPLAYCPL_OPENTO_APPEARANCE, IDS_TAB_APPEARANCE},
    {SZ_DISPLAYCPL_OPENTO_SETTINGS, IDS_TAB_SETTINGS},
};

HRESULT _TabCanonicalToLocalized(IN OUT LPTSTR pszStartPage, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // pszStartPage is an in AND out param
    for (int nIndex = 0; nIndex < ARRAYSIZE(s_TabMapping); nIndex++)
    {
        if (!StrCmpI(s_TabMapping[nIndex].pszCanonical, pszStartPage))
        {
            if (0 == s_TabMapping[nIndex].nResourceID)
            {
                hr = E_FAIL;
            }
            else
            {
                LoadString(hInstance, s_TabMapping[nIndex].nResourceID, pszStartPage, cchSize);
            }
            break;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// SetStartPage checks the command line for start page by name.
///////////////////////////////////////////////////////////////////////////////
#define SZ_ACTIONFLAG_THEME     TEXT("/Action:OpenTheme")
#define SZ_ACTIONFLAG_MSTHEME   TEXT("/Action:OpenMSTheme")

#define SZ_FILEFLAG           TEXT("/File:\"")

void SetStartPage(PROPSHEETHEADER *ppsh, LPCTSTR pszCmdLine, DWORD * pdwAction, LPTSTR pszPath, DWORD cchPathSize, LPTSTR pszStartPage, DWORD cchSize)
{
    pszPath[0] = L'\0';
    pszStartPage[0] = L'\0';

    if (pszCmdLine)
    {
        // Strip spaces
        while (*pszCmdLine == TEXT(' '))
        {
            pszCmdLine++;
        }

        // Check for @ sign.
        if (*pszCmdLine == TEXT('@'))
        {
            LPCTSTR pszBegin;
            BOOL fInQuote = FALSE;
            int cchLen;

            pszCmdLine++;

            // Skip past a quote
            if (*pszCmdLine == TEXT('"'))
            {
                pszCmdLine++;
                fInQuote = TRUE;
            }

            // Save the beginning of the name.
            pszBegin = pszCmdLine;

            // Find the end of the name.
            while (pszCmdLine[0] &&
                   (fInQuote || (pszCmdLine[0] != TEXT(' '))) &&
                   (!fInQuote || (pszCmdLine[0] != TEXT('"'))))
            {
                pszCmdLine++;
            }
            cchLen = (int)(pszCmdLine - pszBegin);

            TCHAR szStartPage[MAX_PATH];

            StringCchCopy(szStartPage, cchLen+1, pszBegin);
            SetAdvStartPage(szStartPage, ARRAYSIZE(szStartPage));

            // Store the name in the pStartPage field.
            StringCchCopy(pszStartPage, cchSize, szStartPage);

            if (StrStrIW(pszCmdLine, SZ_ACTIONFLAG_THEME) || StrStrW(pszCmdLine, SZ_ACTIONFLAG_MSTHEME))
            {
                *pdwAction = (StrStrW(pszCmdLine, SZ_ACTIONFLAG_THEME) ? DESKACTION_OPENTHEME : DESKACTION_OPENMSTHEM);

                pszCmdLine = StrStrIW(pszCmdLine, SZ_FILEFLAG);
                if (pszCmdLine)
                {
                    pszCmdLine += (ARRAYSIZE(SZ_FILEFLAG) - 1);   // Skip past flag

                    LPCWSTR pszEnd = StrStrIW(pszCmdLine, L"\"");
                    if (pszEnd)
                    {
                        DWORD cchSize = (DWORD)((pszEnd - pszCmdLine) + 1);
                        StringCchCopy(pszPath, min(cchPathSize, cchSize), pszCmdLine);
                    }
                }
            }

            if (SUCCEEDED(_TabCanonicalToLocalized(pszStartPage, cchSize)))        // The caller passes a canonical name but the propsheet wants to localized name
            {
                ppsh->dwFlags |= PSH_USEPSTARTPAGE;
                ppsh->pStartPage = pszStartPage;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// _AddDisplayPropSheetPage  adds pages for outside callers...
///////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *) lParam;

    if (ppsh)
    {
        if (hpage && (ppsh->nPages < MAX_PAGES))
        {
            ppsh->phpage[ppsh->nPages++] = hpage;
            return TRUE;
        }
    }

    return FALSE;
}



static int
GetClInt( const TCHAR *p )
{
    BOOL neg = FALSE;
    int v = 0;

    while( *p == TEXT(' ') )
        p++;                        // skip spaces

    if( *p == TEXT('-') )                 // is it negative?
    {
        neg = TRUE;                     // yes, remember that
        p++;                            // skip '-' char
    }

    // parse the absolute portion
    while( ( *p >= TEXT('0') ) && ( *p <= TEXT('9') ) )     // digits only
        v = v * 10 + *p++ - TEXT('0');    // accumulate the value

    return ( neg? -v : v );         // return the result
}



BOOL CheckRestrictionPage(const PAGEINFO * pPageInfo)
{
    BOOL fRestricted = SHRestricted(pPageInfo->dwPolicy1);

    if (!fRestricted && pPageInfo->dwPolicy2)
    {
        fRestricted = SHRestricted(pPageInfo->dwPolicy2);
    }

    return fRestricted;
}


///////////////////////////////////////////////////////////////////////////////
// CreateReplaceableHPSXA creates a new hpsxa that contains only the
// interfaces with valid ReplacePage methods.
// APPCOMPAT - EzDesk only implemented AddPages.  ReplacePage is NULL for them.
///////////////////////////////////////////////////////////////////////////////

typedef struct {
    UINT count, alloc;
    IShellPropSheetExt *interfaces[0];
} PSXA;

HPSXA
CreateReplaceableHPSXA(HPSXA hpsxa)
{
    PSXA *psxa = (PSXA *)hpsxa;
    DWORD cb = SIZEOF(PSXA) + SIZEOF(IShellPropSheetExt *) * psxa->alloc;
    PSXA *psxaRet = (PSXA *)LocalAlloc(LPTR, cb);

    if (psxaRet)
    {
        UINT i;

        psxaRet->count = 0;
        psxaRet->alloc = psxa->alloc;

        for (i=0; i<psxa->count; i++)
        {
            if (psxa->interfaces[i])
            {
                psxaRet->interfaces[psxaRet->count++] = psxa->interfaces[i];
            }
        }
    }

    return (HPSXA)psxaRet;
}


HRESULT AddPropSheetExtArrayToThemePageUI(IThemeUIPages * pThemeUI, HPSXA hpsxa)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeUI && hpsxa)
    {
        PSXA *psxa = (PSXA *)hpsxa;
        IShellPropSheetExt **spsx = psxa->interfaces;
        UINT nIndex;

        for (nIndex = 0; nIndex < psxa->count; nIndex++)
        {
            if (psxa->interfaces[nIndex])
            {
                IBasePropPage * pBasePropPage;

                if (SUCCEEDED(psxa->interfaces[nIndex]->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePropPage))))
                {
                    pThemeUI->AddBasePage(pBasePropPage);
                    pBasePropPage->Release();
                }
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        If the caller gave the page index, we need to open to that page.  The
    order of the pages has changed from Win2k to Whistler, so map the indexes.

    Win2K:
    Index 0: Background
    Index 1: Screen Saver
    Index 2: Appearance
       None: Web
       None: Effects
    Index 3: Settings (Index 3)

    Whistler: (Base Dlg)
       None: Themes
    Index 0: Background
    Index 1: Screen Saver
    Index 2: Appearance
    Index 3: Settings

    Whistler: (Adv Dlg)
       None: Themes Settings
       None: Adv Appearance
       None: Web
       None: Effects
\*****************************************************************************/
int UpgradeStartPageMappping(LPTSTR pszCmdLine, DWORD cchSize)
{
    int nNewStartPage = GetClInt(pszCmdLine);

    if (pszCmdLine)
    {
        switch (nNewStartPage)
        {
        case 0:         // Background
            StringCchCopy(pszCmdLine, cchSize, TEXT("@Desktop"));
            break;
        case 1:         // Screen Saver
        case 2:         // Screen Saver
            StringCchCopy(pszCmdLine, cchSize, TEXT("@ScreenSaver"));
            break;
        case 3:         // Settings
            StringCchCopy(pszCmdLine, cchSize, TEXT("@Settings"));
            break;
        default:
            return nNewStartPage;
            break;
        }
    }
    else
    {
        return nNewStartPage;
    }

    return 0;
}


#define DestroyReplaceableHPSXA(hpsxa) LocalFree((HLOCAL)hpsxa)

/*****************************************************************************\
*
* DeskShowPropSheet( HWND hwndParent )
*
\*****************************************************************************/
void DeskShowPropSheet(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    CDisplayControlPanel displayCPL;

    displayCPL.DisplayDialog(hInst, hwndParent, pszCmdline);
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CDisplayControlPanel::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CDisplayControlPanel::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    else if ((1 == cRef) && m_hBackgroundThreads)
    {
        SetEvent(m_hBackgroundThreads);
    }
    return cRef;
}


HRESULT CDisplayControlPanel::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CDisplayControlPanel, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



CDisplayControlPanel::CDisplayControlPanel(void) : m_cRef(1)
{
    m_hBackgroundThreads = NULL;
}


CDisplayControlPanel::~CDisplayControlPanel(void)
{
    if (m_hBackgroundThreads)
    {
        CloseHandle(m_hBackgroundThreads);
        m_hBackgroundThreads = NULL;
    }
}


// Wait 30 seconds for hung apps to process our message before we give up.
// It would be nice to wait longer, but if the user tries to launch the Display
// Control Panel again, it will not launch because we are still running.  The only
// thing that we will give up on doing after 30 seconds it notifying apps.  In the worse
// case the user will need to log-off and back in to get apps to refresh.
#define MAX_WAITFORHUNGAPPS         (30)

void CDisplayControlPanel::DisplayDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        SHSetInstanceExplorer(SAFECAST(this, IUnknown *));
        _ShowDialog(hInst, hwndParent, pszCmdline);

        // Wait until the background threads finish.
        if (m_cRef > 1)
        {
            m_hBackgroundThreads = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hBackgroundThreads && (m_cRef > 1))
            {
                DWORD dwResult = SHProcessMessagesUntilEvent(NULL, m_hBackgroundThreads, (MAX_WAITFORHUNGAPPS * 1000));

                if (WAIT_TIMEOUT == dwResult)
                {
                    TraceMsg(TF_GENERAL, "A thread hung and we needed to shutdown while it was still running.");
                }
                Sleep(100);
            }
        }

        SHSetInstanceExplorer(NULL);
        CoUninitialize();
    }
}


void CDisplayControlPanel::_ShowDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    HPROPSHEETPAGE hpsp, ahPages[MAX_PAGES];
    HPSXA hpsxa = NULL;
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    int i;
    DWORD exitparam = 0UL;
    HRESULT hr = S_OK;
    TCHAR szCmdLine[MAX_PATH];

    StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), (pszCmdline ? pszCmdline : TEXT("")));

    // check if whole sheet is locked out
    if (SHRestricted(REST_NODISPLAYCPL))
    {
        TCHAR szMessage[255],szTitle[255];

        LoadString( hInst, IDS_DISPLAY_DISABLED, szMessage, ARRAYSIZE(szMessage) );
        LoadString( hInst, IDS_DISPLAY_TITLE, szTitle, ARRAYSIZE(szTitle) );

        MessageBox( hwndParent, szMessage, szTitle, MB_OK | MB_ICONINFORMATION );
        return;
    }

    // Create the property sheet
    ZeroMemory(&psh, sizeof(psh));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = (PSH_PROPTITLE | PSH_USECALLBACK);

    psh.hwndParent = hwndParent;
    psh.hInstance = hInst;

    psh.pszCaption = MAKEINTRESOURCE(IDS_DISPLAY_TITLE);
    psh.nPages = 0;
    psh.phpage = ahPages;
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;

    if (szCmdLine && szCmdLine[0] && (TEXT('@') != szCmdLine[0]))
    {
        psh.nStartPage = UpgradeStartPageMappping(szCmdLine, ARRAYSIZE(szCmdLine));      // We changed the order so do the mapping
    }

    ZeroMemory( &psp, sizeof(psp) );

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hInst;

    // Build the property sheet.  If we are under setup, then just include
    // the "settings" page, and no otheres
    if (!g_pThemeUI)
    {
        // CoCreate Themes, Appearance, and Advanced Appearance tabs
        hr = CoCreateInstance(CLSID_ThemeUIPages, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &g_pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwExecMode;
        if (g_pThemeUI && (SUCCEEDED(g_pThemeUI->GetExecMode(&dwExecMode))) && (dwExecMode == EM_NORMAL))
        {
            if (!GetSystemMetrics(SM_CLEANBOOT))
            {
                hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE,
                                                  REGSTR_PATH_CONTROLSFOLDER TEXT("\\Desk"), 8);
            }

            for (i = 0; i < C_PAGES_DESK; i++)
            {
                BOOL fHideThisPage = FALSE;

                if (CheckRestrictionPage(&aPageInfo[i]))
                {
                    // This page is locked out by admin, don't put it up
                    fHideThisPage = TRUE;
                }

                if (-1 == aPageInfo[i].nExtensionID)
                {
                    psp.pszTemplate = MAKEINTRESOURCE(aPageInfo[i].id);
                    psp.pfnDlgProc = aPageInfo[i].pfnDlgProc;
                    psp.dwFlags = PSP_DEFAULT;
                    psp.lParam = 0L;

                    if (!fHideThisPage && (psp.pfnDlgProc == BackgroundDlgProc))
                    {
                        // This page can be overridden by extensions
                        if( hpsxa )
                        {
                            UINT cutoff = psh.nPages;
                            UINT added = 0;
                            HPSXA hpsxaReplace = CreateReplaceableHPSXA(hpsxa);
                            if (hpsxaReplace)
                            {
                                added = SHReplaceFromPropSheetExtArray( hpsxaReplace, CPLPAGE_DISPLAY_BACKGROUND,
                                    _AddDisplayPropSheetPage, (LPARAM)&psh);
                                DestroyReplaceableHPSXA(hpsxaReplace);
                            }

                            if (added)
                            {
                                if (psh.nStartPage >= cutoff)
                                    psh.nStartPage += added-1;
                                continue;
                            }
                        }
                    }

                    if (!fHideThisPage && (hpsp = CreatePropertySheetPage(&psp)))
                    {
                        psh.phpage[psh.nPages++] = hpsp;
                    }
                }
                else if (g_pThemeUI && !fHideThisPage)
                {
                    IBasePropPage * pBasePage = NULL;

                    // add extensions from the registry
                    // CAUTION: Do not check for "fHideThisPage" here. We need to add the pages for 
                    // property sheet extensions even if the "Settings" page is hidden.
                    if (i == IPI_SETTINGS && hpsxa)
                    {
                        UINT cutoff = psh.nPages;
                        UINT added = SHAddFromPropSheetExtArray(hpsxa, _AddDisplayPropSheetPage, (LPARAM)&psh);

                        if (psh.nStartPage >= cutoff)
                            psh.nStartPage += added;
                    }

                    switch (aPageInfo[i].id)
                    {
                    case 0:
                        hr = g_pThemeUI->AddPage(_AddDisplayPropSheetPage, (LPARAM)&psh, aPageInfo[i].nExtensionID);
                        break;
                    case DLG_SCREENSAVER:
                        hr = CoCreateInstance(CLSID_ScreenSaverPage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
                        break;
                    case DLG_BACKGROUND:
                        hr = CoCreateInstance(CLSID_CDeskHtmlProp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
                        break;
                    default:
                        AssertMsg(0, TEXT("The value must be specified"));
                        break;
                    };

                    if (pBasePage)
                    {
                        IShellPropSheetExt * pspse = NULL;

                        // If they implement IShellPropSheetExt, then add their base pages.
                        if (SUCCEEDED(pBasePage->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse))))
                        {
                            hr = pspse->AddPages(_AddDisplayPropSheetPage, (LPARAM)&psh);
                            pspse->Release();
                        }

                        hr = g_pThemeUI->AddBasePage(pBasePage);
                        pBasePage->Release();
                    }
                }
            }

            if (hpsxa)
            {
                // Have the dynamically added pages added to IThemeUIPages.
                AddPropSheetExtArrayToThemePageUI(g_pThemeUI, hpsxa);
            }

            // add a fake settings page to fool OEM extensions
            // !!! this page must be last !!!
            if (hpsxa)
            {
                g_pThemeUI->AddFakeSettingsPage((LPVOID)&psh);
            }
        }
        else
        {
            // For the SETUP case, only the display page should show up.
            hr = g_pThemeUI->AddPage(_AddDisplayPropSheetPage, (LPARAM)&psh, aPageInfo[IPI_SETTINGS].nExtensionID);
        }

        if (psh.nStartPage >= psh.nPages)
            psh.nStartPage = 0;

        if (psh.nPages)
        {
            DWORD dwAction = DESKACTION_NONE;
            TCHAR szStartPage[MAX_PATH];
            WCHAR szOpenPath[MAX_PATH];
            IPropertyBag * pPropertyBag;

            SetStartPage(&psh, szCmdLine, &dwAction, szOpenPath, ARRAYSIZE(szOpenPath), szStartPage, ARRAYSIZE(szStartPage));

            hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                VARIANT var;

                if (DESKACTION_NONE != dwAction)
                {
                    var.vt = VT_LPWSTR;
                    var.bstrVal = szOpenPath;
                    hr = pPropertyBag->Write(((DESKACTION_OPENTHEME == dwAction) ? SZ_PBPROP_THEME_LAUNCHTHEME : SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME), &var);
                }

                // The following SZ_PBPROP_PREOPEN call will save a "Custom.theme" so users can always go back to
                // their settings if they don't like changes they make in the CPL.
                pPropertyBag->Write(SZ_PBPROP_PREOPEN, NULL);
                pPropertyBag->Release();
            }

            if (PropertySheet(&psh) == ID_PSRESTARTWINDOWS)
            {
                exitparam = EWX_REBOOT;
            }
        }

        if (g_pThemeUI)
        {
            IUnknown_SetSite(g_pThemeUI, NULL); // Tell him to break the ref-count cycle with his children.
            g_pThemeUI->Release();
            g_pThemeUI = NULL;
        }

        // free any loaded extensions
        if (hpsxa)
        {
            SHDestroyPropSheetExtArray(hpsxa);
        }

        if (exitparam == EWX_REBOOT)
        {
            RestartDialogEx(hwndParent, NULL, exitparam, (SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_RECONFIG));
        }
    }

    return;
}




DWORD gdwCoverStyle = WS_EX_TOPMOST | WS_EX_TOOLWINDOW;

HWND FAR PASCAL CreateCoverWindow( DWORD flags )
{
    HWND hwndCover = CreateWindowEx( gdwCoverStyle,
                                     sc_szCoverClass, g_szNULL, WS_POPUP | WS_VISIBLE | flags, 
                                     GetSystemMetrics( SM_XVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_YVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_CXVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_CYVIRTUALSCREEN ),
                                     NULL, NULL, hInstance, NULL );
    if( hwndCover )
    {
        SetForegroundWindow( hwndCover );
        if (flags & COVER_NOPAINT)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        UpdateWindow( hwndCover);
    }

    return hwndCover;
}

///////////////////////////////////////////////////////////////////////////////
// CoverWndProc (see CreateCoverWindow)
///////////////////////////////////////////////////////////////////////////////

#define WM_PRIV_KILL_LATER  (WM_APP + 100)  //Private message to kill ourselves later.

LRESULT CALLBACK
CoverWindowProc( HWND window, UINT message, WPARAM wparam, LPARAM lparam )
{
    switch( message )
    {
        case WM_CREATE:
            SetTimer( window, ID_CVRWND_TIMER, CMSEC_COVER_WINDOW_TIMEOUT, NULL );
            break;

        case WM_TIMER:
            // Times up... Shut ourself down
            if (wparam == ID_CVRWND_TIMER)
                DestroyWindow(window);
            break;

        case WM_ERASEBKGND:
            // NOTE: assumes our class brush is the NULL_BRUSH stock object
            if( !( GetWindowLong( window, GWL_STYLE ) & COVER_NOPAINT ) )
            {
                HDC dc = (HDC)wparam;
                RECT rc;

                if( GetClipBox( dc, (LPRECT)&rc ) != NULLREGION )
                {
                    FillRect( dc, (LPRECT)&rc, (HBRUSH) GetStockObject( BLACK_BRUSH ) );

                    // HACK: make sure fillrect is done before we return
                    // this is to better hide flicker during dynares-crap
                    GetPixel( dc, rc.left + 1, rc.top + 1 );
                }
            }
            break;


        // We post a private message to ourselves because:
        // When WM_CLOSE is processed by this window, it calls DestroyWindow() which results in
        // WM_ACTIVATE (WA_INACTIVE) message to be sent to this window. If this code calls
        // DestroyWindow again, it causes a loop. So, instead of calling DestroyWindow immediately,
        // we post ourselves a message and destroy us letter.
        case WM_ACTIVATE:
            if( GET_WM_ACTIVATE_STATE( wparam, lparam ) == WA_INACTIVE )
            {
                PostMessage( window, WM_PRIV_KILL_LATER, 0L, 0L );
                return 1L;
            }
            break;

        case WM_PRIV_KILL_LATER:
            DestroyWindow(window);
            break;

        case WM_DESTROY:
            KillTimer(window, ID_CVRWND_TIMER);
            break;
    }

    return DefWindowProc( window, message, wparam, lparam );
}

BOOL _FindCoverWindowCallback(HWND hwnd, LPARAM lParam)
{
    TCHAR szClass[MAX_PATH];
    HWND *phwnd = (HWND*)lParam;

    if( !GetClassName(hwnd, szClass, ARRAYSIZE(szClass)) )
        return TRUE;

    if( StrCmp(szClass, sc_szCoverClass) == 0 )
    {
        if( phwnd )
            *phwnd = hwnd;
        return FALSE;
    }
    return TRUE;
}


LONG APIENTRY CPlApplet(
    HWND  hwnd,
    WORD  message,
    LPARAM  wParam,
    LPARAM  lParam)
{
    LPCPLINFO lpCPlInfo;
    LPNEWCPLINFO lpNCPlInfo;
    HWND hwndCover;

    switch (message)
    {
      case CPL_INIT:          // Is any one there ?

        // Init the common controls
        if (!DeskInitCpl())
            return 0;

        // Load ONE string for emergencies.
        LoadString (hInstance, IDS_DISPLAY_TITLE, gszDeskCaption, ARRAYSIZE(gszDeskCaption));
        return !0;

      case CPL_GETCOUNT:        // How many applets do you support ?
        return 1;

      case CPL_INQUIRE:         // Fill CplInfo structure
        lpCPlInfo = (LPCPLINFO)lParam;

        lpCPlInfo->idIcon = IDI_DISPLAY;
        lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->idInfo = IDS_INFO;
        lpCPlInfo->lData  = 0;
        break;

    case CPL_NEWINQUIRE:

        lpNCPlInfo = (LPNEWCPLINFO)lParam;

        lpNCPlInfo->hIcon = LoadIcon(hInstance, (LPTSTR) MAKEINTRESOURCE(IDI_DISPLAY));
        LoadString(hInstance, IDS_NAME, lpNCPlInfo->szName, ARRAYSIZE(lpNCPlInfo->szName));

        if (!LoadString(hInstance, IDS_INFO, lpNCPlInfo->szInfo, ARRAYSIZE(lpNCPlInfo->szInfo)))
            lpNCPlInfo->szInfo[0] = (TCHAR) 0;

        lpNCPlInfo->dwSize = sizeof( NEWCPLINFO );
        lpNCPlInfo->lData  = 0;
        lpNCPlInfo->dwHelpContext = 0;
        lpNCPlInfo->szHelpFile[0] = 0;

        return TRUE;

      case CPL_DBLCLK:          // You have been chosen to run
        /*
         * One of your applets has been double-clicked.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        lParam = 0L;
        // fall through...

      case CPL_STARTWPARMS:
        DeskShowPropSheet( hInstance, hwnd, (LPTSTR)lParam );

        // ensure that any cover windows we've created have been destroyed
        do
        {
            hwndCover = 0;
            EnumWindows( _FindCoverWindowCallback, (LPARAM)&hwndCover );
            if( hwndCover )
            {
                DestroyWindow( hwndCover );
            }
        }
        while( hwndCover );

        return TRUE;            // Tell RunDLL.exe that I succeeded

      case CPL_EXIT:            // You must really die
          if (g_hdcMem)
          {
              ReleaseDC(NULL, g_hdcMem);
              g_hdcMem = NULL;
          }
          // Fall thru...
      case CPL_STOP:            // You must die
        if (g_pThemeUI)
        {
            IUnknown_SetSite(g_pThemeUI, NULL); // Tell him to break the ref-count cycle with his children.
            g_pThemeUI->Release();
            g_pThemeUI = NULL;
        }
        break;

      case CPL_SELECT:          // You have been selected
        /*
         * Sent once for each applet prior to the CPL_EXIT msg.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        break;

      //
      //  Private message sent when this applet is running under "Setup"
      //
      case CPL_SETUP:
      if (g_pThemeUI)
      {
        g_pThemeUI->SetExecMode(EM_SETUP);
      }
      break;

      // Private message used by userenv.dll to refresh the display colors
      case CPL_POLICYREFRESH:
        if (g_pThemeUI) // If this object doesn't exist, then we don't need to refresh anything.
        {
            IPreviewSystemMetrics * ppsm;

            if (SUCCEEDED(g_pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm))))
            {
                ppsm->RefreshColors();
                ppsm->Release();
            }
        }
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 0, FALSE);
        break;
        
    }

    return 0L;
}


BOOL WINAPI DeskSetCurrentSchemeW(IN LPCWSTR pwzSchemeName)
{
    BOOL fSuccess = FALSE;
    IThemeUIPages * pThemeUI = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        IPreviewSystemMetrics * ppsm;

        hr = pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
        if (SUCCEEDED(hr))
        {
            hr = ppsm->DeskSetCurrentScheme(pwzSchemeName);
            ppsm->Release();
        }
        fSuccess = SUCCEEDED(hr);

        pThemeUI->Release();
    }

    SHCoUninitialize(hrOle);
    return fSuccess;
}


//------------------------------------------------------------------------------------------------
//  This function gets the current DPI, reads the last updated DPI from registry and compares 
// these two. If these two are equal, it returns immediately.
//  If these two DPI values are different, then it updates the size of UI fonts to reflect the
// change in the DPI values.
//  
//  This function is called from explorer sothat when DPI value is changed by admin and then every
// other user who logs-in gets this change.
//------------------------------------------------------------------------------------------------
void WINAPI UpdateUIfontsDueToDPIchange(int iOldDPI, int iNewDPI)
{
    BOOL fSuccess = FALSE;
    IThemeManager * pThemeMgr = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeMgr));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeMgr));
    }

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = GetPageByCLSID(pThemeMgr, &PPID_BaseAppearance, &pPropertyBag);
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_APPLIED_VALUE, iOldDPI);        // We are going to pretend we had the old DPI to force the scale to happen.
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, iNewDPI);
            if (SUCCEEDED(hr))
            {
                hr = pThemeMgr->ApplyNow();
            }
            pPropertyBag->Release();
        }
        fSuccess = SUCCEEDED(hr);

        pThemeMgr->Release();
    }

    SHCoUninitialize(hrOle);
}


BOOL DeskSetCurrentSchemeA(IN LPCSTR pszSchemeName)
{
    WCHAR wzSchemeName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pszSchemeName, -1, wzSchemeName, ARRAYSIZE(wzSchemeName));
    return DeskSetCurrentSchemeW(wzSchemeName);
}


STDAPI UpdateCharsetChanges(void)
{
    BOOL fSuccess = FALSE;
    IThemeUIPages * pThemeUI = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeUIPages, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        IPreviewSystemMetrics * ppsm;

        hr = pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
        if (SUCCEEDED(hr))
        {
            hr = ppsm->UpdateCharsetChanges();
            ppsm->Release();
        }
        pThemeUI->Release();
    }

    SHCoUninitialize(hrOle);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\debug.cpp ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "precomp.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "deskcpl"
#define SZ_MODULE           "DESKCPL"
#define DECLARE_DEBUG
#include "debug.h"


// Include the standard helper functions to dump common ADTs
//#include "..\lib\dump.c"


#ifdef DEBUG

//
// Typedefs
//
typedef struct _ALLOCHEADER {
    LIST_ENTRY  ListEntry;
    PTCHAR      File;
    ULONG       Line;
    LONG        AllocNumber;
    ULONG       Size;
} ALLOCHEADER, *PALLOCHEADER;


//
// Globals
//
LIST_ENTRY AllocListHead =
{
    &AllocListHead,
    &AllocListHead
};

#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree

INT g_BreakAtAlloc = -1;
INT g_BreakAtFree = -1;
ULONG g_AllocNumber = 0;

#define TRAP() DbgBreakPoint()

//*****************************************************************************
//
// MyAlloc()
//
//*****************************************************************************

HLOCAL
DeskAllocPrivate (
    const TCHAR *File,
    ULONG       Line,
    ULONG       Flags,
    DWORD       dwBytes
)
{
    static ULONG allocNumber = 0;
    DWORD bytes;
    PALLOCHEADER header;

    if (dwBytes) {
        bytes = dwBytes + sizeof(ALLOCHEADER);

        header = (PALLOCHEADER)LocalAlloc(Flags, bytes);

        if (header != NULL) {
            InsertTailList(&AllocListHead, &header->ListEntry);

            header->File = (TCHAR*) File;
            header->Line = Line;
            header->AllocNumber = ++allocNumber;
            header->Size = dwBytes;

            if (header->AllocNumber == g_BreakAtAlloc) {
                // user set assert
                TRAP();
            }

            return (HLOCAL)(header + 1);
        }
    }

    return NULL;
}

//*****************************************************************************
//
// MyReAlloc()
//
//*****************************************************************************

HLOCAL
DeskReAllocPrivate (
    const TCHAR *File,
    ULONG       Line,
    HLOCAL      hMem,
    DWORD       dwBytes,
    ULONG       Flags
    )
{
    PALLOCHEADER header;
    PALLOCHEADER headerNew;

    if (hMem)
    {
        header = (PALLOCHEADER)hMem;

        header--;

        // Remove the old address from the allocation list
        //
        RemoveEntryList(&header->ListEntry);

        headerNew = (PALLOCHEADER) LocalReAlloc((HLOCAL)header, dwBytes, Flags);

        if (headerNew != NULL)
        {
            // Add the new address to the allocation list
            //
            headerNew->File = (TCHAR*) File;
            headerNew->Line = Line;
            headerNew->AllocNumber = ++g_AllocNumber;
            headerNew->Size = dwBytes;

            if (headerNew->AllocNumber == g_BreakAtAlloc) {
                // user set assert
                TRAP();
            }

            InsertTailList(&AllocListHead, &headerNew->ListEntry);

            return (HLOCAL)(headerNew + 1);
        }
        else
        {
            // If GlobalReAlloc fails, the original memory is not freed,
            // and the original handle and pointer are still valid.
            // Add the old address back to the allocation list.
            //
            InsertTailList(&AllocListHead, &header->ListEntry);
        }

    }

    return NULL;
}


//*****************************************************************************
//
// MyFree()
//
//*****************************************************************************

HLOCAL
DeskFreePrivate (
    HLOCAL hMem
)
{
    PALLOCHEADER header;
    TCHAR buf[128];

    if (hMem)
    {
        header = (PALLOCHEADER)hMem;
        header--;

        if (header->AllocNumber == g_BreakAtFree) {
            TRAP();
        }

        StringCchPrintf(buf, ARRAYSIZE(buf), TEXT("free alloc number %d, size %d\r\n"), 
                 header->AllocNumber, header->Size);

        RemoveEntryList(&header->ListEntry);

        return LocalFree((HLOCAL)header);
    }
 
    return LocalFree(hMem);
}

//*****************************************************************************
//
// MyCheckForLeaks()
//
//*****************************************************************************

VOID
DeskCheckForLeaksPrivate (
    VOID
)
{
    PALLOCHEADER  header;
    TCHAR         buf[1024+40], tmpBuf[512];
    unsigned int  i, size, size2, ic;
    DWORD         *pdw;
    char          *pch, *pch2;
    LPVOID        mem;

    #define DeskIsPrintable iswprint

    while (!IsListEmpty(&AllocListHead))
    {
        header = (PALLOCHEADER)RemoveHeadList(&AllocListHead);
        mem = header + 1;
            
        StringCchPrintf(buf, ARRAYSIZE(buf), TEXT("Desk.cpl mem leak in File:  %s\r\n Line: %d Size:  %d  Allocation:  %d Buffer:  0x%x\r\n"),
                 header->File, header->Line, header->Size, header->AllocNumber, mem);
        OutputDebugString(buf);

        //
        // easy stuff, print out all the 4 DWORDS we can 
        //
        pdw = (DWORD *) mem;
        pch = (char *) mem;
        *buf = TEXT('\0');
        for (i = 0; i < header->Size/16; i++, pdw += 4) {
            StringCchPrintf(tmpBuf, ARRAYSIZE(tmpBuf), TEXT(" %08x %08x %08x %08x   "),
                     pdw[0], pdw[1], pdw[2], pdw[3]);
            StringCchCat(buf, ARRAYSIZE(buf), tmpBuf);

            for (ic = 0; ic < 16; ic++, pch++) {
                tmpBuf[ic] = DeskIsPrintable(*pch) ? *pch : TEXT('.');
            }
            tmpBuf[ic] =  TEXT('\0');
            StringCchCat(buf, ARRAYSIZE(buf), tmpBuf);
            OutputDebugString(buf);
            OutputDebugString(TEXT("\n"));

            *buf = TEXT('\0');
        }

        //
        // Is there less than a 16 byte chunk left?
        //
        size = header->Size % 16;
        if (size) {
            //
            // Print all the DWORDs we can
            //
            for (i = 0; i < size / 4; i++, pdw++) {
                StringCchPrintf(tmpBuf, ARRAYSIZE(tmpBuf), TEXT(" %08x"), *pdw);
                StringCchCat(buf, ARRAYSIZE(buf), tmpBuf);
            }

            if (size % 4) {
                // 
                // Print the remaining bytes
                // 
                StringCchCat(buf, ARRAYSIZE(buf), TEXT(" "));

                pch2 = (char*) pdw;
                for (i = 0; i < size % 4; i++, pch2++) {
                    StringCchPrintf(tmpBuf, ARRAYSIZE(tmpBuf), TEXT("%02x"), (DWORD) *pch2);
                    StringCchCat(buf, ARRAYSIZE(buf), tmpBuf);
                }

                //
                // Align with 4 bytes
                //
                for ( ; i < 4; i++) {
                    StringCchCat(buf, ARRAYSIZE(buf), TEXT("  "));
                }
            }

            //
            // Print blanks for any remaining DWORDs (ie to match the 4 above)
            //
            size2 = (16 - (header->Size % 16)) / 4;
            for (i = 0; i < size2; i++) {
                StringCchCat(buf, ARRAYSIZE(buf), TEXT("         "));
            }

            StringCchCat(buf, ARRAYSIZE(buf), TEXT("   "));
            
            //
            // Print the actual remain bytes as chars
            //
            for (i = 0; i < size; i++, pch++) {
                tmpBuf[i] = DeskIsPrintable(*pch) ? *pch : TEXT('.');
            }
            tmpBuf[i] = TEXT('\0');
            StringCchCat(buf, ARRAYSIZE(buf), tmpBuf);

            OutputDebugString(buf);
            OutputDebugString(TEXT("\n"));
        }

        OutputDebugString(TEXT("\n"));
        ASSERT(0);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\deskdbg.h ===
#ifdef __cplusplus
extern "C" {
#endif

#if DEBUG

#define LocalAlloc(flags, dwBytes)   DeskAllocPrivate(TEXT(__FILE__), __LINE__, flags, (dwBytes))
#define LocalReAlloc(hMem, dwBytes, flags)  DeskReAllocPrivate(TEXT(__FILE__), __LINE__, (hMem), (dwBytes), flags)
#define LocalFree(hMem)              DeskFreePrivate((hMem))
#define DeskCheckForLeaks()         DeskCheckForLeaksPrivate()
#define DirectLocalFree(hMem)       DeskFreeDirect((hMem))

#define ODS(sz) (OutputDebugStringA(sz), OutputDebugStringA("\r\n"))

#else

#define DirectLocalFree(hMem)       LocalFree((hMem))

#define ODS(sz)

#endif

HLOCAL
DeskAllocPrivate(const TCHAR *File, ULONG Line, ULONG Flags, DWORD dwBytes);

HLOCAL
DeskReAllocPrivate(const TCHAR *File, ULONG Line, HLOCAL hMem, DWORD dwBytes, ULONG Flags);

HLOCAL
DeskFreePrivate(HLOCAL hMem);

HLOCAL
DeskFreeDirect(HLOCAL hMem);

VOID
DeskCheckForLeaksPrivate(VOID);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\desk.h ===
#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#ifdef SIZEOF
#undef SIZEOF
#endif

#define CCH_MAX_STRING    256
#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */

#define CMSEC_COVER_WINDOW_TIMEOUT  (15 * 1000)     // 15 second timeout
#define ID_CVRWND_TIMER             0x96F251CC      // somewhat uniq id

//
// Extra bits for the TraceMsg function
//

#define TF_DUMP_DEVMODE     0x20000000
#define TF_DUMP_CSETTINGS   0x40000000
#define TF_DUMP_DEVMODELIST 0x80000000
#define TF_OC               0x01000000
#define TF_SETUP            0x02000000

// Maximum number of pages we will put in the PropertySheets
#define MAX_PAGES 24


// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_W   184
#define MON_H   170
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8

#define CDPI_NORMAL     96      // Arbitrarily, 96dpi is "Normal"



BOOL DeskInitCpl(void);
void DeskShowPropSheet( HINSTANCE hInst, HWND hwndParent, LPCTSTR szCmdLine );
BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);

INT_PTR APIENTRY BackgroundDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ScreenSaverDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AppearanceDlgProc  (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AdvancedAppearanceDlgProc  (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GeneralPageProc    (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MultiMonitorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


BOOL GetAdvMonitorPropPage(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lparam);
BOOL GetAdvMonitorPropPageParam(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lparam, LPARAM lparamPage);

INT_PTR APIENTRY DeskDefPropPageProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);

// logging API
#define DeskOpenLog()   SetupOpenLog(FALSE)
#define DeskCloseLog()  SetupCloseLog()

BOOL
CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ) ;


// fixreg.c
void FixupRegistryHandlers(void);
BOOL GetDisplayKey(int i, LPTSTR szKey, DWORD cb);
void NukeDisplaySettings(void);

// background previewer includes

#define BP_NEWPAT       0x01    // pattern changed
#define BP_NEWWALL      0x02    // wallpaper changed
#define BP_TILE         0x04    // tile the wallpaper (center otherwise)
#define BP_REINIT       0x08    // reload the image (system colors changed)

#define WM_SETBACKINFO (WM_USER + 1)

#define BACKPREV_CLASS TEXT("BackgroundPreview")

BOOL FAR PASCAL RegisterLookPreviewClass(HINSTANCE hInst);

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );



//#define Assert(p)   /* nothing */

#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)


//
// CreateCoverWindow
//
// creates a window which obscures the display
//  flags:
//      0 means erase to black
//      COVER_NOPAINT means "freeze" the display
//
// just post it a WM_CLOSE when you're done with it
//
#define COVER_NOPAINT (0x1)
//
HWND FAR PASCAL CreateCoverWindow( DWORD flags );
void DestroyCoverWindow(HWND hwndCover);
int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID);

typedef struct tagREPLACEPAGE_LPARAM
{
    PROPSHEETHEADER FAR * ppsh;
    IThemeUIPages * ptuiPages;
} REPLACEPAGE_LPARAM;

//
// Macro to replace MAKEPOINT() since points now have 32 bit x & y
//
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = (int)(short)LOWORD(lp), (ppt)->y = (int)(short)HIWORD(lp))

//
// Globals
//
extern HINSTANCE hInstance;
extern TCHAR gszDeskCaption[CCH_MAX_STRING];

extern TCHAR g_szNULL[];
extern TCHAR g_szNone[CCH_NONE];
extern TCHAR g_szControlIni[];
extern TCHAR g_szPatterns[];

extern TCHAR g_szCurPattern[];   // name of currently selected pattern
extern TCHAR g_szCurWallpaper[]; // name of currently selected wallpaper
extern BOOL g_bValidBitmap;     // whether or not wallpaper is valid

extern TCHAR g_szBoot[];
extern TCHAR g_szSystemIni[];
extern TCHAR g_szWindows[];

extern HDC g_hdcMem;
extern HBITMAP g_hbmDefault;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\init.cpp ===
#include "precomp.h"

// global variables
HINSTANCE hInstance;

EXTERN_C BOOL DllInitialize(IN PVOID hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        hInstance = (HINSTANCE) hmod;
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModuleID(hInstance, 124);
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
    }
    else if (ulReason == DLL_PROCESS_DETACH) 
    {
#ifdef DEBUG
        DeskCheckForLeaks();
#endif       
        SHFusionUninitialize();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\deskid.h ===
#ifndef _DESKID_H
#define _DESKID_H


///////////////////////////////////////////////////////////////////////////////
// Icons

#define IDI_DISPLAY              100


///////////////////////////////////////////////////////////////////////////////
// Strings

#define IDS_DISPLAY_TITLE        100
#define IDS_DISPLAY_DISABLED     102

#define IDC_STATIC  -1

#define DLG_SCREENSAVER          150
#define DLG_BACKGROUND           151
#define DLG_WIZPAGE              164

#define IDS_ICON                  40
#define IDS_NAME                  41
#define IDS_INFO                  42
#define IDS_RETURNTOWELCOME       43

#define IDB_ENERGYSTAR           120

#define IDC_NO_HELP_1            200     // Used in place of IDC_STATIC when context Help
#define IDC_NO_HELP_2            201     // should be disabled for a control

// background controls
#define IDC_PATLIST             1100
#define IDC_WALLLIST            1101
#define IDC_EDITPAT             1102
#define IDC_BROWSEWALL          1103
#define IDC_CENTER              1104
#define IDC_TILE                1105
#define IDC_PATTERN             1106
#define IDC_WALLPAPER           1107
#define IDC_BACKPREV            1108
#define IDC_TXT_DISPLAY         1109

// background dialog strings
#define IDS_NONE                1100
#define IDS_UNLISTEDPAT         1101
#define IDS_BITMAPOPENERR       1102
#define IDS_DIB_NOOPEN          1103
#define IDS_DIB_INVALID         1104
#define IDS_BADWALLPAPER        1106
#define IDS_BROWSETITLE         1107
#define IDS_BROWSEFILTER        1108

#define IDS_TAB_THEMES          1240
#define IDS_TAB_DESKTOP         1241
#define IDS_TAB_SCREENSAVER     1242
#define IDS_TAB_APPEARANCE      1243
#define IDS_TAB_SETTINGS        1244

//
// String IDs
//

// setupact.log messages

#define IDS_SETUPLOG_MSG_000                3300
#define IDS_SETUPLOG_MSG_004                3304
#define IDS_SETUPLOG_MSG_006                3306
#define IDS_SETUPLOG_MSG_008                3308
#define IDS_SETUPLOG_MSG_009                3309
#define IDS_SETUPLOG_MSG_010                3310
#define IDS_SETUPLOG_MSG_011                3311
#define IDS_SETUPLOG_MSG_012                3312
#define IDS_SETUPLOG_MSG_013                3313
#define IDS_SETUPLOG_MSG_014                3314
#define IDS_SETUPLOG_MSG_015                3315
#define IDS_SETUPLOG_MSG_016                3316
#define IDS_SETUPLOG_MSG_017                3317
#define IDS_SETUPLOG_MSG_018                3318
#define IDS_SETUPLOG_MSG_019                3319
#define IDS_SETUPLOG_MSG_020                3320
#define IDS_SETUPLOG_MSG_021                3321
#define IDS_SETUPLOG_MSG_022                3322
#define IDS_SETUPLOG_MSG_023                3323
#define IDS_SETUPLOG_MSG_024                3324
#define IDS_SETUPLOG_MSG_025                3325
#define IDS_SETUPLOG_MSG_031                3331
#define IDS_SETUPLOG_MSG_032                3332
#define IDS_SETUPLOG_MSG_033                3333
#define IDS_SETUPLOG_MSG_034                3334
#define IDS_SETUPLOG_MSG_035                3335
#define IDS_SETUPLOG_MSG_039                3339
#define IDS_SETUPLOG_MSG_040                3340
#define IDS_SETUPLOG_MSG_041                3341
#define IDS_SETUPLOG_MSG_046                3346
#define IDS_SETUPLOG_MSG_047                3347
#define IDS_SETUPLOG_MSG_048                3348
#define IDS_SETUPLOG_MSG_057                3357
#define IDS_SETUPLOG_MSG_060                3360
#define IDS_SETUPLOG_MSG_062                3362
#define IDS_SETUPLOG_MSG_064                3364
#define IDS_SETUPLOG_MSG_065                3365
#define IDS_SETUPLOG_MSG_067                3367
#define IDS_SETUPLOG_MSG_068                3368
#define IDS_SETUPLOG_MSG_069                3369
#define IDS_SETUPLOG_MSG_075                3375
#define IDS_SETUPLOG_MSG_076                3376
#define IDS_SETUPLOG_MSG_096                3396
#define IDS_SETUPLOG_MSG_097                3397
#define IDS_SETUPLOG_MSG_098                3398
#define IDS_SETUPLOG_MSG_099                3399
#define IDS_SETUPLOG_MSG_100                3400
#define IDS_SETUPLOG_MSG_101                3401
#define IDS_SETUPLOG_MSG_102                3402
#define IDS_SETUPLOG_MSG_103                3403
#define IDS_SETUPLOG_MSG_104                3404
#define IDS_SETUPLOG_MSG_105                3405
#define IDS_SETUPLOG_MSG_106                3406
#define IDS_SETUPLOG_MSG_107                3407
#define IDS_SETUPLOG_MSG_108                3408
#define IDS_SETUPLOG_MSG_109                3409
#define IDS_SETUPLOG_MSG_110                3410
#define IDS_SETUPLOG_MSG_111                3411
#define IDS_SETUPLOG_MSG_112                3412
#define IDS_SETUPLOG_MSG_113                3413
#define IDS_SETUPLOG_MSG_114                3414
#define IDS_SETUPLOG_MSG_115                3415
#define IDS_SETUPLOG_MSG_116                3416
#define IDS_SETUPLOG_MSG_117                3417
#define IDS_SETUPLOG_MSG_118                3418
#define IDS_SETUPLOG_MSG_119                3419
#define IDS_SETUPLOG_MSG_120                3420
#define IDS_SETUPLOG_MSG_121                3421
#define IDS_SETUPLOG_MSG_122                3422
#define IDS_SETUPLOG_MSG_123                3423
#define IDS_SETUPLOG_MSG_124                3424
#define IDS_SETUPLOG_MSG_125                3425
#define IDS_SETUPLOG_MSG_126                3426
#define IDS_SETUPLOG_MSG_127                3427
#define IDS_SETUPLOG_MSG_128                3428
#define IDS_SETUPLOG_MSG_129                3429
#define IDS_SETUPLOG_MSG_130                3430

//
// Help defines
//

#endif // _DESKID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\look.h ===
#define FONT_NONE	-1
#define FONT_CAPTION	0
#define FONT_SMCAPTION	1
#define FONT_MENU	2
#define FONT_ICONTITLE	3
#define FONT_STATUS	4
#define FONT_MSGBOX	5

#define NUM_FONTS	6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE	-1
extern COLORREF g_rgb[];
extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;

#define SIZE_NONE	-1
#define SIZE_FRAME	0
#define SIZE_SCROLL	1
#define SIZE_CAPTION	2
#define SIZE_SMCAPTION	3
#define SIZE_MENU	4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES	9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;		// id of name in resource (or -1 if duplicate)
    int iBaseElement;	// index of element that this overlaps (or -1)
    int iGradientColor; // index of element for Gradient Caption Bar (or -1)
    RECT rc;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,
    ELEMENT_INACTIVEBORDER,
    ELEMENT_ACTIVEBORDER,
    ELEMENT_INACTIVECAPTION,
    ELEMENT_INACTIVESYSBUT1,
    ELEMENT_INACTIVESYSBUT2,
    ELEMENT_ACTIVECAPTION,
    ELEMENT_ACTIVESYSBUT1,
    ELEMENT_ACTIVESYSBUT2,
    ELEMENT_MENUNORMAL,
    ELEMENT_MENUSELECTED,
    ELEMENT_MENUDISABLED,
    ELEMENT_WINDOW,
    ELEMENT_MSGBOX,
    ELEMENT_MSGBOXCAPTION,
    ELEMENT_MSGBOXSYSBUT,
    ELEMENT_SCROLLBAR,
    ELEMENT_SCROLLUP,
    ELEMENT_SCROLLDOWN,
    ELEMENT_BUTTON,
    ELEMENT_SMCAPTION,
    ELEMENT_ICON,
    ELEMENT_ICONHORZSPACING,
    ELEMENT_ICONVERTSPACING,
    ELEMENT_INFO
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.c if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY	0x0001
#define CPI_PALETTEOK	0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

#define WM_RECREATEBITMAP (WM_USER)
extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

void FAR PASCAL LookPrev_Recalc(HWND hwnd);
void FAR PASCAL LookPrev_Repaint(HWND hwnd);

void FAR PASCAL Look_SelectElement(HWND hDlg, int iElement, DWORD dwFlag);

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);

DWORD FAR PASCAL DarkenColor(DWORD rgb, int n);
DWORD FAR PASCAL BrightenColor(DWORD rgb, int n);

DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale);


#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\install2.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    install2.cpp

Abstract:

    This file implements the display class installer.

Environment:

    WIN32 User Mode

--*/


#include <initguid.h>

#include "precomp.h" 
#pragma hdrstop

#include <devguid.h>

//
// Defines
//

#define INSETUP         1
#define INSETUP_UPGRADE 2

#define SZ_UPGRADE_DESCRIPTION TEXT("_RealDescription")
#define SZ_UPGRADE_MFG         TEXT("_RealMfg")

#define SZ_DEFAULT_DESCRIPTION TEXT("Video Display Adapter")
#define SZ_DEFAULT_MFG         TEXT("Microsoft")

#define SZ_LEGACY_UPGRADE      TEXT("_LegacyUpgradeDevice")

#define SZ_ROOT_LEGACY         TEXT("ROOT\\LEGACY_")
#define SZ_ROOT                TEXT("ROOT\\")

#define SZ_BINARY_LEN 32

#define ByteCountOf(x)  ((x) * sizeof(TCHAR))


//
// Data types
//

typedef struct _DEVDATA {
    SP_DEVINFO_DATA did;
    TCHAR szBinary[SZ_BINARY_LEN];
    TCHAR szService[SZ_BINARY_LEN];
} DEVDATA, *PDEVDATA;


//
// Forward declarations
//

BOOL CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ); 

DWORD 
DeskGetSetupFlags(
    VOID
    );

BOOL
DeskIsLegacyDevNodeByPath(
    const PTCHAR szRegPath
    );

BOOL
DeskIsLegacyDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDid
    );
 
BOOL
DeskIsRootDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDid
    );

BOOL
DeskGetDevNodePath(
    IN PSP_DEVINFO_DATA pDid,
    IN OUT PTCHAR szPath,
    IN LONG len
    );

VOID
DeskSetServiceStartType(
    LPTSTR ServiceName,
    DWORD dwStartType
    );

DWORD
DeskInstallService(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN LPTSTR pServiceName
    );

DWORD
DeskInstallServiceExtensions(
    IN HWND hwnd,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA DriverInfoData,
    IN PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,
    IN LPTSTR pServiceName
    );

VOID
DeskMarkUpNewDevNode(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

VOID
DeskNukeDevNode(
    LPTSTR szService,
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    );

PTCHAR 
DeskFindMatchingId(
    PTCHAR DeviceId,    
    PTCHAR IdList
    );

UINT
DeskDisableLegacyDeviceNodes(
    VOID 
    );

VOID
DeskDisableServices(
    );

DWORD
DeskPerformDatabaseUpgrade(
    HINF hInf,
    PINFCONTEXT pInfContext,
    BOOL bUpgrade,
    PTCHAR szDriverListSection,
    BOOL* pbForceDeleteAppletExt
    );

DWORD 
DeskCheckDatabase(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    BOOL* pbDeleteAppletExt
    );

VOID
DeskGetUpgradeDeviceStrings(
    PTCHAR Description,
    PTCHAR MfgName,
    PTCHAR ProviderName
    );

DWORD
OnAllowInstall(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

DWORD
OnSelectBestCompatDrv(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

DWORD
OnSelectDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    );

DWORD
OnInstallDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    );

BOOL
DeskGetVideoDeviceKey(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPTSTR pServiceName,
    IN DWORD DeviceX,
    OUT HKEY* phkDevice
    );

BOOL
DeskIsServiceDisableable(
    PTCHAR szService
    );

VOID
DeskDeleteAppletExtensions(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    );

VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    );

VOID
DeskAEMove(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    HKEY hkMoveFrom,
    PAPPEXT pAppExtBefore,
    PAPPEXT pAppExtAfter
    );


//
// Display class installer
//

DWORD
DisplayClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )

/*++

Routine Description:

  This routine acts as the class installer for Display devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    pDeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    BOOL bHandled = TRUE;
    TCHAR szDevNode[LINE_LEN];

    DeskOpenLog();

    switch(InstallFunction) {

    case DIF_SELECTDEVICE : 

        retVal = OnSelectDevice(hDevInfo, pDeviceInfoData);
        break;

    case DIF_SELECTBESTCOMPATDRV :

        retVal = OnSelectBestCompatDrv(hDevInfo, pDeviceInfoData);
        break;

    case DIF_ALLOW_INSTALL :

        retVal = OnAllowInstall(hDevInfo, pDeviceInfoData);
        break;

    case DIF_INSTALLDEVICE :
        
        retVal = OnInstallDevice(hDevInfo, pDeviceInfoData);
        break;

    default:

        bHandled = FALSE;
        break;
    }

    if (bHandled && 
        (pDeviceInfoData != NULL) &&
        (DeskGetDevNodePath(pDeviceInfoData, szDevNode, LINE_LEN-1)))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_125, 
                     retVal, 
                     InstallFunction,
                     szDevNode);
    }
    else
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_057, 
                     retVal, 
                     InstallFunction);
    }

    DeskCloseLog();

    //
    // If we did not exit from the routine by handling the call, 
    // tell the setup code to handle everything the default way.
    //

    return retVal;
}

/*
void StrClearHighBits(LPTSTR pszString, DWORD cchSize)
{
    // This string can not have any high bits set
}
*/

// Monitor class installer
DWORD
MonitorClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )

/*++

Routine Description:

  This routine acts as the class installer for Display devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    pDeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    return ERROR_DI_DO_DEFAULT;
}


//
// Handler functions
//

DWORD
OnAllowInstall(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    DWORD cbOutputSize;
    HINF hInf = INVALID_HANDLE_VALUE;
    TCHAR ActualInfSection[LINE_LEN];
    INFCONTEXT InfContext;
    ULONG DevStatus = 0, DevProblem = 0;
    CONFIGRET Result;
    DWORD dwRet = ERROR_DI_DO_DEFAULT;
    
    ASSERT (pDeviceInfoData != NULL);

    //
    // Do not allow install if the device is to be removed.
    //
    
    Result = CM_Get_DevNode_Status(&DevStatus,
                                   &DevProblem,
                                   pDeviceInfoData->DevInst,
                                   0);

    if ((Result == CR_SUCCESS) &&
        ((DevStatus & DN_WILL_BE_REMOVED) != 0)) {
        
        //
        // Message Box?
        //

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_099);
        dwRet = ERROR_DI_DONT_INSTALL;
        goto Fallout;
    }

    //
    // Check for a Win95 Driver
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(hDevInfo,
                                  pDeviceInfoData,
                                  &DriverInfoData))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetSelectedDriver"),
                     GetLastError());
        goto Fallout;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!(SetupDiGetDriverInfoDetail(hDevInfo,
                                     pDeviceInfoData,
                                     &DriverInfoData,
                                     &DriverInfoDetailData,
                                     DriverInfoDetailData.cbSize,
                                     &cbOutputSize)) &&
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetDriverInfoDetail"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the
    // AddService/DelService entries in its install service install section.
    //

    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("OnAllowInstall: SetupOpenInfFile"));
        goto Fallout;
    }

    //
    // Now find the actual (potentially OS/platform-specific) install section name.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          ActualInfSection,
                                          ARRAYSIZE(ActualInfSection),
                                          NULL,
                                          NULL))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetActualSectionToInstall"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Append a ".Services" to get the service install section name.
    //

    StringCchCat(ActualInfSection, ARRAYSIZE(ActualInfSection), TEXT(".Services"));

    //
    // See if the section exists.
    //

    if (!SetupFindFirstLine(hInf,
                            ActualInfSection,
                            NULL,
                            &InfContext))
    {
        //
        // Message Box?
        //

        DeskLogError(LogSevError, 
                     IDS_SETUPLOG_MSG_041, 
                     DriverInfoDetailData.InfFileName);
        dwRet = ERROR_NON_WINDOWS_NT_DRIVER;
    }

Fallout:

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return dwRet;
}

VOID
DeskModifyDriverRank(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    //
    // Regardless of whether a driver is properly signed or not
    // we don't want any W2K drivers to be choosen by default.  We have
    // simply found to many w2k drivers that don't work well on
    // windows XP.  So instead lets treat all drivers signed or not
    // as unsigned if they were released before we started signing
    // windows xp drivers.  [We have to do this because some w2k
    // drivers were incorrectly signed as winxp (5.x) drivers]
    //

    ULONG i=0;
    SP_DRVINFO_DATA_V2 DrvInfoData;
    SP_DRVINSTALL_PARAMS DrvInstallParams;
    SYSTEMTIME SystemTime;

    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA_V2);

    while (SetupDiEnumDriverInfo(hDevInfo,
           pDeviceInfoData,
           SPDIT_COMPATDRIVER,
           i++,
           &DrvInfoData)) {

        if (FileTimeToSystemTime(&DrvInfoData.DriverDate, &SystemTime)) {

            if (((SystemTime.wYear < 2001) ||
                 ((SystemTime.wYear == 2001) && (SystemTime.wMonth < 6)))) {

                //
                // If this was created before Jun. 2001 then we want to make it a
                // worse match than our in the box driver.  We'll do this by
                // treating it as unsigned.
                //

                ZeroMemory(&DrvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
                DrvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);

                if (SetupDiGetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstallParams)) {

                    DrvInstallParams.Rank |= DRIVER_UNTRUSTED_RANK;

                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstallParams);
                }
            }
        }
    }
}

DWORD
OnSelectBestCompatDrv(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_DEVINSTALL_PARAMS DevInstParam;
    SP_DRVINFO_DATA DrvInfoData;
    PTCHAR szDesc = NULL, szMfg = NULL;
    HKEY hKey;
    DWORD dwFailed;
    BOOL bDummy = FALSE;
    DWORD dwLegacyUpgrade = 1;
    DWORD dwRet = ERROR_DI_DO_DEFAULT; 

    DeskModifyDriverRank(hDevInfo, pDeviceInfoData);

    if (DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {

        //
        // Always allow root devices in select
        //

        goto Fallout;
    }

    //
    // Check the database to see if this is an approved driver.
    // We need the test only during an upgrade.
    //

    if (((DeskGetSetupFlags() & INSETUP_UPGRADE) == 0) ||
        (DeskCheckDatabase(hDevInfo, 
                           pDeviceInfoData,
                           &bDummy) == ERROR_SUCCESS)) {

        //
        // It is, no other work is necessary
        //
        
        goto Fallout;
    }

    //
    // This particular vid card is not allowed to run with drivers out 
    // of the box.  Note this event in the reg and save off other values.
    // Also, install a fake device onto the devnode so that the user doesn't 
    // get PnP popus upon first (real) boot
    //
    
    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_046);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey) == ERROR_SUCCESS) {

        // 
        // Save off the fact that upgrade was not allowed (used in migrated 
        // display settings in the display OC
        // 

        dwFailed = 1;
        RegSetValueEx(hKey, 
                      SZ_UPGRADE_FAILED_ALLOW_INSTALL,
                      0,
                      REG_DWORD, 
                      (PBYTE) &dwFailed,
                      sizeof(DWORD));

        RegCloseKey(hKey);
    }

    //
    // Grab the description of the device so we can give it to the devnode
    // after a succesfull install of the fake devnode
    //

    ZeroMemory(&DrvInfoData, sizeof(DrvInfoData));
    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if (SetupDiEnumDriverInfo(hDevInfo,
                              pDeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              0,
                              &DrvInfoData)) {

        if (lstrlen(DrvInfoData.Description)) {
            szDesc = DrvInfoData.Description;
        }
        
        if (lstrlen(DrvInfoData.MfgName)) {
            szMfg = DrvInfoData.MfgName;
        }
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_047);
    }

    if (!szDesc) {
        szDesc = SZ_DEFAULT_DESCRIPTION;
    }

    if (!szMfg) {
        szMfg = SZ_DEFAULT_MFG;
    }

    //
    // Save the description of the device under the device registry key
    //

    if ((hKey = SetupDiCreateDevRegKey(hDevInfo,
                                       pDeviceInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DEV,
                                       NULL,
                                       NULL)) != INVALID_HANDLE_VALUE) {

        RegSetValueEx(hKey,
                      SZ_UPGRADE_DESCRIPTION,
                      0,
                      REG_SZ,
                      (PBYTE) szDesc, 
                      ByteCountOf(lstrlen(szDesc) + 1));

        RegSetValueEx(hKey,
                      SZ_UPGRADE_MFG,
                      0,
                      REG_SZ,
                      (PBYTE) szMfg, 
                      ByteCountOf(lstrlen(szMfg) + 1));

        RegSetValueEx(hKey,
                      SZ_LEGACY_UPGRADE,
                      0,
                      REG_DWORD,
                      (PBYTE)&dwLegacyUpgrade, 
                      sizeof(DWORD));

        RegCloseKey(hKey);
    
    } else {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_048);
    }

    //
    // Make sure there isn't already a class driver list built for this 
    // device information element
    //

    if (!SetupDiDestroyDriverInfoList(hDevInfo, pDeviceInfoData, SPDIT_CLASSDRIVER)) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("OnSelectBestCompatDrv: SetupDiDestroyDriverInfoList"));
    }

    //
    // Build a class driver list off of display.inf.
    //

    DevInstParam.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DevInstParam)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiGetDeviceInstallParams"),
                     GetLastError());
        goto Fallout;
    }

    DevInstParam.Flags |= DI_ENUMSINGLEINF;
    StringCchCopy(DevInstParam.DriverPath, ARRAYSIZE(DevInstParam.DriverPath), TEXT("display.inf"));
    
    if (!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DevInstParam)) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiSetDeviceInstallParams"),
                     GetLastError());
        goto Fallout;
    }

    if (!SetupDiBuildDriverInfoList(hDevInfo, pDeviceInfoData, SPDIT_CLASSDRIVER)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiBuildDriverInfoList"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Now select the fake node.
    // All strings here match the inf fake device entry section.  
    // If the INF is modified in any way WRT to these strings, 
    // these to be changed as well
    //

    ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DrvInfoData.DriverType = SPDIT_CLASSDRIVER;
    
    DeskGetUpgradeDeviceStrings(DrvInfoData.Description,
                                DrvInfoData.MfgName,
                                DrvInfoData.ProviderName);

    if (!SetupDiSetSelectedDriver(hDevInfo, pDeviceInfoData, &DrvInfoData)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiSetSelectedDriver"),
                     GetLastError());
        goto Fallout;
    }

    dwRet = NO_ERROR;

Fallout:

    return dwRet;
}


DWORD
OnSelectDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )
{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    DWORD index = 0, reqSize = 0, curSize = 0;
    PSP_DRVINFO_DETAIL_DATA pDrvInfoDetailData = NULL;
    SP_DRVINFO_DATA DrvInfoData;
    SP_DRVINSTALL_PARAMS DrvInstallParams;

    //
    // Build the list of drivers
    //

    if (!SetupDiBuildDriverInfoList(hDevInfo, 
                                    pDeviceInfoData, 
                                    SPDIT_CLASSDRIVER)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectDevice: SetupDiBuildDriverInfoList"),
                     GetLastError());
        goto Fallout;
    }

    ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while (SetupDiEnumDriverInfo(hDevInfo,
                                 pDeviceInfoData,
                                 SPDIT_CLASSDRIVER,
                                 index,
                                 &DrvInfoData)) {

        //
        // Get the required size
        //

        reqSize = 0;
        SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDeviceInfoData,
                                   &DrvInfoData,
                                   NULL,
                                   0,
                                   &reqSize);
        
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("OnSelectDevice: SetupDiGetDriverInfoDetail"),
                         GetLastError());
            goto Fallout;
        }

        //
        // Allocate memory, if needed
        //

        if ((reqSize > curSize) || (pDrvInfoDetailData == NULL)) {
        
            curSize = reqSize;
    
            if (pDrvInfoDetailData != NULL) {
                LocalFree(pDrvInfoDetailData);
            }
    
            pDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA)LocalAlloc(LPTR, curSize);
    
            if (pDrvInfoDetailData == NULL) {
    
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_127,
                             TEXT("OnSelectDevice: LocalAlloc"));
                goto Fallout; 
            }
        
        } else {

            ZeroMemory(pDrvInfoDetailData, reqSize);
        }

        //
        // Get the driver detail info
        //

        pDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDeviceInfoData,
                                        &DrvInfoData,
                                        pDrvInfoDetailData,
                                        reqSize,
                                        NULL)) {
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("OnSelectDevice: SetupDiGetDriverInfoDetail"),
                         GetLastError());
            goto Fallout;
        }
            
        if (lstrcmpi(pDrvInfoDetailData->HardwareID, 
                     TEXT("LEGACY_UPGRADE_ID")) == 0) {

            //
            // Mark the legacy upgrade drv. info as "bad" so that it is 
            // not shown when the user is prompted to select the driver
            //
            
            ZeroMemory(&DrvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
            DrvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
            
            if (SetupDiGetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DrvInfoData,
                                              &DrvInstallParams)) {
                
                DrvInstallParams.Flags |=  DNF_BAD_DRIVER;
                
                SetupDiSetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DrvInfoData,
                                              &DrvInstallParams);
            }
        }

        //
        // Get the next driver info
        //

        ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
        DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

        ++index;
    }

Fallout:
    
    if (pDrvInfoDetailData) {
        LocalFree(pDrvInfoDetailData);
    }

    return retVal;
}


DWORD
OnInstallDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    )
{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    DWORD dwLegacyUpgrade, dwSize;
    DISPLAY_DEVICE displayDevice;
    TCHAR szBuffer[LINE_LEN];
    PTCHAR szHardwareIds = NULL;
    BOOL bDisableLegacyDevices = TRUE;
    ULONG len = 0;
    HKEY hkDevKey;

    //
    // Disable legacy devices if pDeviceInfoData is not:
    //     - a root device or
    //     - legacy upgrade device
    //

    if (DeskIsRootDevNodeByDevInfo(pDeviceInfoData)) {
    
        //
        // Root device
        //

        bDisableLegacyDevices = FALSE;
    
    } else {
    
        //
        // Is this the legacy upgrade device?
        //

        hkDevKey = SetupDiOpenDevRegKey(hDevInfo,
                                        pDeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DEV,
                                        KEY_ALL_ACCESS);

        if (hkDevKey != INVALID_HANDLE_VALUE) {
        
            dwSize = sizeof(DWORD);
            if (RegQueryValueEx(hkDevKey,
                                 SZ_LEGACY_UPGRADE,
                                 0,
                                 NULL,
                                 (PBYTE)&dwLegacyUpgrade,
                                 &dwSize) == ERROR_SUCCESS) {
                 
                if (dwLegacyUpgrade == 1) {

                    //
                    // Legacy upgrade device
                    //
    
                    bDisableLegacyDevices = FALSE;
                }

                RegDeleteValue(hkDevKey, SZ_LEGACY_UPGRADE);
            }

            RegCloseKey(hkDevKey);
        }
    }

    if (bDisableLegacyDevices) {

        if ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0) {
        
            //
            // Delete legacy applet extensions
            //

            DeskDeleteAppletExtensions(hDevInfo, pDeviceInfoData);
        }
        
        //
        // Disable legacy devices
        //

        DeskDisableLegacyDeviceNodes();
    }

    retVal = DeskInstallService(hDevInfo,
                                pDeviceInfoData,
                                szBuffer);

    if ((retVal == ERROR_NO_DRIVER_SELECTED) &&
        (DeskGetSetupFlags() & INSETUP_UPGRADE) &&
        DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {
        
        //
        // If this is a legacy device and no driver is selected,
        // let the default handler install a NULL driver.
        //
        
        retVal = ERROR_DI_DO_DEFAULT;
    }

    //
    // Calling EnumDisplayDevices will rescan the devices, and if a
    // new device is detected, we will disable and reenable the main
    // device. This reset of the display device will clear up any 
    // mess caused by installing a new driver
    //

    displayDevice.cb = sizeof(DISPLAY_DEVICE);
    EnumDisplayDevices(NULL, 0, &displayDevice, 0);

    return retVal;
}


//
// Logging function
//

BOOL CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ) 
/*++

Outputs a message to the setup log.  Prepends "desk.cpl  " to the strings and 
appends the correct newline chars (\r\n)

--*/
{
    int cch;
    TCHAR ach[1024+40];    // Largest path plus extra
    TCHAR szMsg[1024];     // MsgId
    va_list vArgs;

    static int setupState = 0;

    if (setupState == 0) {

        if (DeskGetSetupFlags() & (INSETUP | INSETUP_UPGRADE)) {
            
            setupState = 1;
        
        } else {
            
            setupState = 2;
        }
    }

    if (setupState == 1) {
        
        *szMsg = 0;
        if (LoadString(hInstance,
                       MsgId,
                       szMsg,
                       ARRAYSIZE(szMsg))) {

            *ach = 0;
            LoadString(hInstance,
                       IDS_SETUPLOG_MSG_000,
                       ach,
                       ARRAYSIZE(ach));
                       
            cch = lstrlen(ach);
            va_start(vArgs, MsgId);
            StringCchVPrintf(&ach[cch], ARRAYSIZE(ach) - cch, szMsg, vArgs);
            StringCchCat(ach, ARRAYSIZE(ach), TEXT("\r\n"));
            va_end(vArgs);
    
            return SetupLogError(ach, Severity);
        
        } else {
            
            return FALSE;
        }
    
    } else {

        va_start(vArgs, MsgId);
        va_end(vArgs);
        
        return TRUE;
    }
}


//
// Service Controller stuff
//

VOID
DeskSetServiceStartType(
    LPTSTR ServiceName,
    DWORD dwStartType
    )
{
    SC_HANDLE SCMHandle;
    SC_HANDLE ServiceHandle;
    ULONG Attempts;
    SC_LOCK SCLock = NULL;
    ULONG ServiceConfigSize = 0;
    LPQUERY_SERVICE_CONFIG ServiceConfig;

    //
    // Open the service controller
    // Open the service
    // Change the service.
    //

    if (SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))
    {
        if (ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))
        {
            QueryServiceConfig(ServiceHandle,
                               NULL,
                               0,
                               &ServiceConfigSize);

            ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

            if (ServiceConfig = (LPQUERY_SERVICE_CONFIG)
                                 LocalAlloc(LPTR, ServiceConfigSize))
            {
                if (QueryServiceConfig(ServiceHandle,
                                       ServiceConfig,
                                       ServiceConfigSize,
                                       &ServiceConfigSize))
                {
                    //
                    // Attempt to acquite the database lock.
                    //

                    for (Attempts = 20;
                         ((SCLock = LockServiceDatabase(SCMHandle)) == NULL) && Attempts;
                         Attempts--)
                    {
                        //
                        // Lock SC database locked
                        // 

                        Sleep(500);
                    }

                    //
                    // Change the service to demand start
                    //

                    if (!ChangeServiceConfig(ServiceHandle,
                                             SERVICE_NO_CHANGE,
                                             dwStartType,
                                             SERVICE_NO_CHANGE,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL))
                    {
                        DeskLogError(LogSevInformation, 
                                     IDS_SETUPLOG_MSG_126,
                                     TEXT("DeskSetServiceStartType: ChangeServiceConfig"),
                                     GetLastError());
                    }

                    if (SCLock)
                    {
                        UnlockServiceDatabase(SCLock);
                    }
                
                } else {
                
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_126,
                                 TEXT("DeskSetServiceStartType: QueryServiceConfig"),
                                 GetLastError());
                }

                LocalFree(ServiceConfig);
            
            } else {
            
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_127,
                             TEXT("DeskSetServiceStartType: LocalAlloc"));
            }

            CloseServiceHandle(ServiceHandle);
        
        } else {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("DeskSetServiceStartType: OpenService"),
                         GetLastError());
        }

        CloseServiceHandle(SCMHandle);
    
    } else {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskSetServiceStartType: OpenSCManager"),
                     GetLastError());

    }
}


//
// Service Installation
//


DWORD
DeskInstallServiceExtensions(
    IN HWND hwnd,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA DriverInfoData,
    IN PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,
    IN LPTSTR pServiceName
    )
{
    DWORD retVal = NO_ERROR;
    HINF InfFileHandle;
    INFCONTEXT tmpContext;
    TCHAR szSoftwareSection[LINE_LEN];
    INT maxmem;
    INT numDev;
#ifndef _WIN64
    SP_DEVINSTALL_PARAMS   DeviceInstallParams;
#endif
    TCHAR keyName[LINE_LEN];
    DWORD disposition;
    HKEY hkey;

    //
    // Open the inf so we can run the sections in the inf, more or less manually.
    //

    InfFileHandle = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                                     NULL,
                                     INF_STYLE_WIN4,
                                     NULL);

    if (InfFileHandle == INVALID_HANDLE_VALUE)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("DeskInstallServiceExtensions: SetupOpenInfFile"));

        return ERROR_INVALID_PARAMETER;
    }


    //
    // Get any interesting configuration data for the inf file.
    //

    maxmem = 8;
    numDev = 1;

    StringCchPrintf(szSoftwareSection,
             ARRAYSIZE(szSoftwareSection),
             TEXT("%ws.GeneralConfigData"),
             DriverInfoDetailData->SectionName);

    if (SetupFindFirstLine(InfFileHandle,
                           szSoftwareSection,
                           TEXT("MaximumNumberOfDevices"),
                           &tmpContext))
    {
        SetupGetIntField(&tmpContext,
                         1,
                         &numDev);
    }

    if (SetupFindFirstLine(InfFileHandle,
                           szSoftwareSection,
                           TEXT("MaximumDeviceMemoryConfiguration"),
                           &tmpContext))
    {
        SetupGetIntField(&tmpContext,
                         1,
                         &maxmem);
    }

    //
    // Create the <Service> key.
    //

    StringCchPrintf(keyName,
             ARRAYSIZE(keyName),
             TEXT("System\\CurrentControlSet\\Services\\%ws"),
             pServiceName);

    RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                   keyName,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE,
                   NULL,
                   &hkey,
                   &disposition);

#ifndef _WIN64

    //
    // Increase the number of system PTEs if we have cards that will need
    // more than 10 MB of PTE mapping space.  This only needs to be done for
    // 32-bit NT as virtual address space is limited.  On 64-bit NT there is
    // always enough PTE mapping address space so don't do anything as you're
    // likely to get it wrong.
    //

    if ((maxmem = maxmem * numDev) > 10)
    {
        //
        // On x86, 1K PTEs support 4 MB.
        // Then add 50% for other devices this type of machine may have.
        // NOTE - in the future, we may want to be smarter and try
        // to merge with whatever someone else put in there.
        //

        maxmem = maxmem * 0x400 * 3/2 + 0x3000;

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkey,
                           &disposition) == ERROR_SUCCESS)
        {
            //
            // Check if we already set maxmem in the registry.
            //

            DWORD data;
            DWORD cb = sizeof(data);

            if ((RegQueryValueEx(hkey,
                                 TEXT("SystemPages"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)(&data),
                                 &cb) != ERROR_SUCCESS) ||
                 (data < (DWORD) maxmem))
            {
                //
                // Set the new value
                //

                RegSetValueEx(hkey,
                              TEXT("SystemPages"),
                              0,
                              REG_DWORD,
                              (LPBYTE) &maxmem,
                              sizeof(DWORD));

                //
                // Tell the system we must reboot before running this driver
                // in case the system has less than 128M.
                //

                MEMORYSTATUSEX MemStatus;
                SYSTEM_INFO SystemInfo;

                GetSystemInfo(&SystemInfo);
                MemStatus.dwLength = sizeof(MemStatus);

                if ((SystemInfo.dwPageSize == 0) ||
                    (!GlobalMemoryStatusEx(&MemStatus)) ||
                    ((MemStatus.ullTotalPhys  / SystemInfo.dwPageSize) <= 0x7F00))
                {
                    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
                    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    
                    if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams)) {
    
                        DeviceInstallParams.Flags |= DI_NEEDREBOOT;
    
                        if (!SetupDiSetDeviceInstallParams(hDevInfo,
                                                           pDeviceInfoData,
                                                           &DeviceInstallParams)) {
                            
                            DeskLogError(LogSevInformation, 
                                         IDS_SETUPLOG_MSG_126,
                                         TEXT("DeskInstallServiceExtensions: SetupDiSetDeviceInstallParams"),
                                         GetLastError());
                        }
    
                    } else {
    
                        DeskLogError(LogSevInformation, 
                                     IDS_SETUPLOG_MSG_126,
                                     TEXT("DeskInstallServiceExtensions: SetupDiGetDeviceInstallParams"),
                                     GetLastError());
                    }
                }
            }

            RegCloseKey(hkey);
        }
    }
#endif

    //
    // We may have to do this for multiple adapters at this point.
    // So loop throught the number of devices, which has 1 as the default value.
    // For dual view, videoprt.sys will create [GUID]\000X entries as needed 
    // and will copy all the entries from the "Settings" key to [GUID]\000X.
    //

    DWORD dwSoftwareSettings = 1;
    DWORD dwDeviceX = 0;

    do {

        if (dwSoftwareSettings == 1)
        {
            //
            // Install everything under the old video device key:
            //     HKLM\System\CCS\Services\[SrvName]\DeviceX
            //

            numDev--;
            
            if (numDev == 0) 
                dwSoftwareSettings++;

            //
            // For all drivers, install the information under DeviceX
            // We do this for legacy purposes since many drivers rely on
            // information written to this key.
            //

            StringCchPrintf(keyName,
                     ARRAYSIZE(keyName),
                     TEXT("System\\CurrentControlSet\\Services\\%ws\\Device%d"),
                     pServiceName, numDev);

            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               keyName,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hkey,
                               &disposition) != ERROR_SUCCESS) {
                hkey = (HKEY) INVALID_HANDLE_VALUE;
            }
        }
        else if (dwSoftwareSettings == 2) 
        {
            //
            // Install everything under the new video device key:
            //     HKLM\System\CCS\Control\Video\[GUID]\000X
            //

            if (DeskGetVideoDeviceKey(hDevInfo,
                                      pDeviceInfoData,
                                      pServiceName,
                                      dwDeviceX,
                                      &hkey)) 
            {
                dwDeviceX++;
            }
            else
            {
                hkey = (HKEY) INVALID_HANDLE_VALUE;
                dwSoftwareSettings++;
            }
        }
        else if (dwSoftwareSettings == 3)
        {

            dwSoftwareSettings++;

            //
            // Install everything under the driver (aka software) key:
            //     HKLM\System\CCS\Control\Class\[Display class]\000X\Settings
            //

            hkey = (HKEY) INVALID_HANDLE_VALUE;

            HKEY hKeyDriver = SetupDiOpenDevRegKey(hDevInfo,
                                                  pDeviceInfoData,
                                                  DICS_FLAG_GLOBAL,
                                                  0,
                                                  DIREG_DRV,
                                                  KEY_ALL_ACCESS);

            if (hKeyDriver != INVALID_HANDLE_VALUE) {

                //
                // Delete the old settings and applet extensions before 
                // installing the new driver
                //

                SHDeleteKey(hKeyDriver, TEXT("Settings"));
                SHDeleteKey(hKeyDriver, TEXT("Display"));
                
                //
                // Create/open the settings key
                //

                if (RegCreateKeyEx(hKeyDriver,
                                   TEXT("Settings"),
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkey,
                                   NULL) != ERROR_SUCCESS) {

                    hkey = (HKEY)INVALID_HANDLE_VALUE;
                }

                RegCloseKey(hKeyDriver);
            }
        } 

        if (hkey != INVALID_HANDLE_VALUE)
        {
            //
            // Delete the CapabilityOverride key.
            //

            RegDeleteValue(hkey,
                           TEXT("CapabilityOverride"));

            StringCchPrintf(szSoftwareSection,
                     ARRAYSIZE(szSoftwareSection),
                     TEXT("%ws.SoftwareSettings"),
                     DriverInfoDetailData->SectionName);

            if (!SetupInstallFromInfSection(hwnd,
                                            InfFileHandle,
                                            szSoftwareSection,
                                            SPINST_REGISTRY,
                                            hkey,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL))
            {
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_126,
                             TEXT("DeskInstallServiceExtensions: SetupInstallFromInfSection"),
                             GetLastError());

                RegCloseKey(hkey);
                return ERROR_INVALID_PARAMETER;
            }

            //
            // Write the description of the device 
            //

            RegSetValueEx(hkey,
                          TEXT("Device Description"),
                          0,
                          REG_SZ,
                          (LPBYTE) DriverInfoDetailData->DrvDescription,
                          ByteCountOf(lstrlen(DriverInfoDetailData->DrvDescription) + 1));

            //
            // If this is a server sku, then lets default to all accelerations
            // being disabled.
            //

            OSVERSIONINFOEX osvi;

            ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

            if (GetVersionEx((OSVERSIONINFO *) &osvi)) {

                if (osvi.wProductType == VER_NT_SERVER) {

                    //
                    // Check to see if the registry value for
                    // Accleration.Level already exists.
                    //

                    ULONG Status;

                    Status = RegQueryValueEx(hkey,
                                             TEXT("Acceleration.Level"),
                                             0,
                                             NULL,
                                             NULL,
                                             NULL);

                    if (Status == ERROR_FILE_NOT_FOUND) {

                        //
                        // the key doesn't exist already, so lets
                        // create it.  If it was already in existance,
                        // we'll just leave the current setting.
                        //

                        DWORD AccelLevel = 4;

                        //
                        // Set acceleration level to "minimal".
                        //

                        RegSetValueEx(hkey,
                                      TEXT("Acceleration.Level"),
                                      0,
                                      REG_DWORD,
                                      (PBYTE)&AccelLevel,
                                      sizeof(DWORD));
                    }
                }
            }

            RegCloseKey(hkey);
        }

    } while (dwSoftwareSettings <= 3);

    //
    // Optionally run the OpenGl section in the inf.
    // Ignore any errors at this point since this is an optional entry.
    //

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers"),
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE,
                       NULL,
                       &hkey,
                       &disposition) == ERROR_SUCCESS)
    {
        StringCchPrintf(szSoftwareSection,
                 ARRAYSIZE(szSoftwareSection),
                 TEXT("%ws.OpenGLSoftwareSettings"),
                 DriverInfoDetailData->SectionName);

        SetupInstallFromInfSection(hwnd,
                                   InfFileHandle,
                                   szSoftwareSection,
                                   SPINST_REGISTRY,
                                   hkey,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);

        RegCloseKey(hkey);
    }

    SetupCloseInfFile(InfFileHandle);

    return retVal;
}


DWORD
DeskInstallService(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN LPTSTR pServiceName
    )
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    DWORD cbOutputSize;
    HINF hInf = INVALID_HANDLE_VALUE;
    TCHAR ActualInfSection[LINE_LEN];
    INFCONTEXT infContext;
    DWORD status = NO_ERROR;
    PAPPEXT pAppExtDisplayBefore = NULL, pAppExtDisplayAfter = NULL;
    PAPPEXT pAppExtDeviceBefore = NULL, pAppExtDeviceAfter = NULL;
    HKEY hkDisplay = 0, hkDevice = 0;

    //
    // Get the params so we can get the window handle.
    //

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    SetupDiGetDeviceInstallParams(hDevInfo,
                                  pDeviceInfoData,
                                  &DeviceInstallParams);

    //
    // Retrieve information about the driver node selected for this device.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(hDevInfo,
                                  pDeviceInfoData,
                                  &DriverInfoData)) {

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetSelectedDriver"),
                     status);

        goto Fallout;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if (!(SetupDiGetDriverInfoDetail(hDevInfo,
                                     pDeviceInfoData,
                                     &DriverInfoData,
                                     &DriverInfoDetailData,
                                     DriverInfoDetailData.cbSize,
                                     &cbOutputSize)) &&
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        
        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetDriverInfoDetail"),
                     status);
        goto Fallout;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the
    // AddService/DelService entries in its install service install section.
    //

    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        
        //
        // For some reason we couldn't open the INF--this should never happen.
        //

        status = ERROR_INVALID_HANDLE;
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("DeskInstallService: SetupOpenInfFile"));
        goto Fallout;
    }

    //
    // Now find the actual (potentially OS/platform-specific) install section name.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          ActualInfSection,
                                          sizeof(ActualInfSection) / sizeof(TCHAR),
                                          NULL,
                                          NULL)) {

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetActualSectionToInstall"),
                     status);
        goto Fallout;
    }
    
    //
    // Append a ".Services" to get the service install section name.
    //

    StringCchCat(ActualInfSection, ARRAYSIZE(ActualInfSection), TEXT(".Services"));

    //
    // Now run the service modification entries in this section...
    //

    if (!SetupInstallServicesFromInfSection(hInf,
                                            ActualInfSection,
                                            0))
    {
        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupInstallServicesFromInfSection"),
                     status);
        goto Fallout;
    }

    //
    // Get the service Name if needed (detection)
    //

    if (SetupFindFirstLine(hInf,
                           ActualInfSection,
                           TEXT("AddService"),
                           &infContext))
    {
        SetupGetStringField(&infContext,
                            1,
                            pServiceName,
                            LINE_LEN,
                            NULL);
    }

    //
    // Get a snapshot of the applet extensions installed under generic 
    // Device and Display keys
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                     0,
                     KEY_ALL_ACCESS,
                     &hkDisplay) == ERROR_SUCCESS) {

        DeskAESnapshot(hkDisplay, &pAppExtDisplayBefore);
    
    } else {

        hkDisplay = 0;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DEVICE_SHEX_PROPSHEET,
                     0,
                     KEY_ALL_ACCESS,
                     &hkDevice) == ERROR_SUCCESS) {

        DeskAESnapshot(hkDevice, &pAppExtDeviceBefore);
    
    } else {

        hkDevice = 0;
    }
    
    //
    // Now that the basic install has been performed (without starting the
    // device), write the extra data to the registry.
    //

    status = DeskInstallServiceExtensions(DeviceInstallParams.hwndParent,
                                          hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInfoDetailData,
                                          pServiceName);

    if (status != NO_ERROR)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: DeskInstallServiceExtensions"),
                     status);

        goto Fallout;
    }

    //
    // Do the full device install
    // If some of the flags (like paged pool) needed to be changed,
    // let's ask for a reboot right now.
    // Otherwise, we can actually try to start the device at this point.
    //

    if (!SetupDiInstallDevice(hDevInfo, pDeviceInfoData))
    {
        //
        // Remove the device !??
        //

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiInstallDevice"),
                     status);
        goto Fallout;
    }
        
    //
    // Get a snapshot of the applet extensions after the device was installed
    // Move the new added extensions under the driver key
    //

    if (hkDisplay != 0) {

        DeskAESnapshot(hkDisplay, &pAppExtDisplayAfter);

        DeskAEMove(hDevInfo,
                   pDeviceInfoData,
                   hkDisplay,
                   pAppExtDisplayBefore,
                   pAppExtDisplayAfter);

        DeskAECleanup(pAppExtDisplayBefore);
        DeskAECleanup(pAppExtDisplayAfter);
    }

    if (hkDevice != 0) {

        DeskAESnapshot(hkDevice, &pAppExtDeviceAfter);

        DeskAEMove(hDevInfo,
                   pDeviceInfoData,
                   hkDevice,
                   pAppExtDeviceBefore,
                   pAppExtDeviceAfter);
        
        DeskAECleanup(pAppExtDeviceBefore);
        DeskAECleanup(pAppExtDeviceAfter);
    }

    //
    // For a PnP Device which will never do detection, we want to mark
    // the device as DemandStart.
    //

    DeskSetServiceStartType(pServiceName, SERVICE_DEMAND_START);

    //
    // Make sure the device description and mfg are the original values
    // and not the marked up ones we might have made during select bext
    // compat drv
    //

    DeskMarkUpNewDevNode(hDevInfo, pDeviceInfoData);

    status = NO_ERROR;

Fallout:
    
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if (hkDisplay != 0) {
        RegCloseKey(hkDisplay);
    }

    if (hkDevice != 0) {
        RegCloseKey(hkDevice);
    }
    
    return status;
}


VOID
DeskMarkUpNewDevNode(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    HKEY hKey;
    PTCHAR szProperty;
    DWORD dwSize;

    //
    // Make sure the device desc is "good". 
    //
    
    if (DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {
        
        //
        // Don't do this to legacy devnode.
        //

        return;
    }
        
    //
    // Open the device registry key.
    // The real manufacturer and description were stored here
    // by the handler of DIF_SELECTBESTCOMPATDRV
    //

    hKey = SetupDiCreateDevRegKey(hDevInfo,
                                  pDeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  NULL,
                                  NULL);

    if (hKey == INVALID_HANDLE_VALUE) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskMarkUpNewDevNode: SetupDiCreateDevRegKey"),
                     GetLastError());
        return;
    }

    //
    // Set Description
    //

    dwSize = 0;
    if (RegQueryValueEx(hKey,
                        SZ_UPGRADE_DESCRIPTION,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {

        goto Fallout;
    }

    ASSERT(dwSize != 0);
    
    dwSize *= sizeof(TCHAR);
    szProperty = (PTCHAR) LocalAlloc(LPTR, dwSize);

    if ((szProperty != NULL) &&  
        (RegQueryValueEx(hKey,
                         SZ_UPGRADE_DESCRIPTION,
                         0,
                         NULL,
                         (PBYTE) szProperty,
                         &dwSize) == ERROR_SUCCESS))
    {
        SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         pDeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         (PBYTE) szProperty,
                                         ByteCountOf(lstrlen(szProperty)+1));

        RegDeleteValue(hKey, SZ_UPGRADE_DESCRIPTION);

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_004, 
                     szProperty);
    }

    LocalFree(szProperty);
    szProperty = NULL;

    //
    // Set Manufacturer
    //

    dwSize = 0;
    if (RegQueryValueEx(hKey,
                        SZ_UPGRADE_MFG,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {

        goto Fallout;
    }

    ASSERT(dwSize != 0);
    
    dwSize *= sizeof(TCHAR);
    szProperty = (PTCHAR) LocalAlloc(LPTR, dwSize);
    
    if ((szProperty != NULL) &&  
        (RegQueryValueEx(hKey,
                         SZ_UPGRADE_MFG,
                         0,
                         NULL,
                         (PBYTE) szProperty,
                         &dwSize) == ERROR_SUCCESS))
    {
        SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         pDeviceInfoData,
                                         SPDRP_MFG,
                                         (PBYTE) szProperty,
                                         ByteCountOf(lstrlen(szProperty)+1));

        RegDeleteValue(hKey, SZ_UPGRADE_MFG);

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_006, 
                     szProperty);
    }
    
    LocalFree(szProperty);
    szProperty = NULL;

Fallout:

    RegCloseKey(hKey);
}


//
// Helper functions
//

BOOL
DeskIsLegacyDevNodeByPath(
    const PTCHAR szRegPath
    )
{
    return (_tcsncicmp(SZ_ROOT_LEGACY, szRegPath, _tcslen(SZ_ROOT_LEGACY)) == 0);
}


BOOL
DeskIsLegacyDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDevInfoData
    )
{
    TCHAR szBuf[LINE_LEN];

    return (DeskGetDevNodePath(pDevInfoData, szBuf, LINE_LEN - 1) &&
            DeskIsLegacyDevNodeByPath(szBuf));
}
 

BOOL
DeskIsRootDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDevInfoData
    )
{
    TCHAR szBuf[LINE_LEN];
    
    return (DeskGetDevNodePath(pDevInfoData, szBuf, LINE_LEN - 1) &&
            (_tcsncicmp(SZ_ROOT, szBuf, _tcslen(SZ_ROOT)) == 0));
}


BOOL
DeskGetDevNodePath(
    PSP_DEVINFO_DATA pDid,
    PTCHAR szPath,
    LONG len
    )
{
    return (CR_SUCCESS == CM_Get_Device_ID(pDid->DevInst, szPath, len, 0));
}


VOID
DeskNukeDevNode(
    LPTSTR szService,
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_REMOVEDEVICE_PARAMS rdParams;
    TCHAR szPath[LINE_LEN];

    // Disable the service
    if (szService)
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_008, szService);
        DeskSetServiceStartType(szService, SERVICE_DISABLED);
    }
    else
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_009);
    }

    // Remove the devnode
    if (DeskGetDevNodePath(pDeviceInfoData, szPath, LINE_LEN))
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_010, szPath);
    }

    ZeroMemory(&rdParams, sizeof(SP_REMOVEDEVICE_PARAMS));
    rdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rdParams.Scope = DI_REMOVEDEVICE_GLOBAL;

    if (SetupDiSetClassInstallParams(hDevInfo,
                                     pDeviceInfoData,
                                     &rdParams.ClassInstallHeader,
                                     sizeof(SP_REMOVEDEVICE_PARAMS)))
    {
        if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, pDeviceInfoData))
        {
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_011, GetLastError());
        }
    }
    else
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_012, GetLastError());
    }
}


PTCHAR 
DeskFindMatchingId(
    PTCHAR DeviceId,    
    PTCHAR IdList // a multi sz
    )
{
    PTCHAR currentId;

    if (!IdList) {
        return NULL;
    }

    for (currentId = IdList; *currentId; ) {

        if (lstrcmpi(currentId, DeviceId) == 0) {

            //
            // We have a match
            //

            return currentId;
        
        } else {

            //
            // Get to the next string in the multi sz
            //

            while (*currentId) {
                currentId++;
            }

            //
            // Jump past the null
            //

            currentId++;
        }
    }

    return NULL;
}


UINT
DeskDisableLegacyDeviceNodes(
    VOID 
    )
{
    DWORD index = 0, dwSize;
    UINT count = 0;
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA did;
    TCHAR szRegProperty[256];
    PTCHAR szService;
    
    //
    // Let's find all the video drivers that are installed in the system
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskDisableLegacyDeviceNodes: SetupDiGetClassDevs"),
                     GetLastError());
        goto Fallout;
    }

    ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
    did.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(hDevInfo, index, &did))
    {
        // If we have a root legacy device, then don't install any new
        // devnode (until we get better at this).
        if (CR_SUCCESS == CM_Get_Device_ID(did.DevInst,
                                           szRegProperty,
                                           ARRAYSIZE(szRegProperty),
                                           0))
        {
            if (DeskIsLegacyDevNodeByPath(szRegProperty))
            {
                // We have a legacy DevNode, lets disable its service and 
                // remove its devnode 
                szService = NULL;
                
                dwSize = sizeof(szRegProperty);
                if (CM_Get_DevNode_Registry_Property(did.DevInst,
                                                     CM_DRP_SERVICE,
                                                     NULL,
                                                     szRegProperty,
                                                     &dwSize,
                                                     0) == CR_SUCCESS)
                {
                    // Make sure we don't disable vga or VgaSave
                    if (!DeskIsServiceDisableable(szRegProperty))
                    {
                        goto NextDevice;
                    }

                    szService = szRegProperty;
                }

                DeskNukeDevNode(szService, hDevInfo, &did);
                count++;
            }
        }
        
NextDevice:

        ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
        did.cbSize = sizeof(SP_DEVINFO_DATA);
        index++;
    }

    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_013, count, index);
    SetupDiDestroyDeviceInfoList(hDevInfo);
    
Fallout:

    if ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0) {
        DeskDisableServices();
    }

    return count;
}


VOID
DeskDisableServices(
    )
{
    HKEY hKey = 0;
    PTCHAR mszBuffer = NULL, szService = NULL;
    DWORD cbSize = 0;

    //
    // Retrieve the services we want to disable from the registry
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey) != ERROR_SUCCESS) {
        
        hKey = 0;
        goto Fallout;
    }

    //
    // Get the size
    //

    if (RegQueryValueEx(hKey,
                        SZ_SERVICES_TO_DISABLE,
                        0,
                        NULL,
                        NULL,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Allocate the memory
    //

    mszBuffer = (PTCHAR)LocalAlloc(LPTR, cbSize);
    
    if (mszBuffer == NULL) {
        goto Fallout;
    }

    //
    // Get the services
    //

    if (RegQueryValueEx(hKey,
                        SZ_SERVICES_TO_DISABLE,
                        0,
                        NULL,
                        (BYTE*)mszBuffer,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Scan through all the services
    //

    szService = mszBuffer;
    while (*szService != TEXT('\0')) {

        //
        // Make sure this service is not vga
        //

        if (DeskIsServiceDisableable(szService)) {

            //
            // Disable the service
            //

            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_008, szService);
            DeskSetServiceStartType(szService, SERVICE_DISABLED);
        } 

        //
        // Go to next service
        //

        while (*szService != TEXT('\0')) {
            szService++;
        }
        szService++;
    }

Fallout:

    if (mszBuffer != NULL) {
        LocalFree(mszBuffer);
    }

    if (hKey != 0) {

        //
        // Delete the SERVICES_TO_DISABLE value
        //

        RegDeleteValue(hKey, SZ_SERVICES_TO_DISABLE);

        //
        // Close the key
        //

        RegCloseKey(hKey);
    }
}
 


DWORD
DeskPerformDatabaseUpgrade(
    HINF hInf,
    PINFCONTEXT pInfContext,
    BOOL bUpgrade,
    PTCHAR szDriverListSection,
    BOOL* pbDeleteAppletExt
    )

/*--

Remarks:
    This function is called once the ID of the device in question matches an ID
    contained in the upgrade database. We then compare the state of the system 
    with what is contained in the database. The following algorithm is followed.
   
    If szDriverListSection is NULL or cannot be found, then bUpgrade is used
    If szDriverListSection is not NUL, then following table is used
    
    bUpgrade    match found in DL           return value
    TRUE        no                          upgrade
    TRUE        yes                         no upgrade
    FALSE       no                          no upgrade
    FALSE       yes                         upgrade
  
    essentially, a match in the DL negates bUpgrade 
    
++*/

{
    HKEY hKey;
    DWORD dwRet = ERROR_SUCCESS, dwSize;
    INFCONTEXT driverListContext;
    TCHAR szService[32], szProperty[128];
    TCHAR szRegPath[128];
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    PDEVDATA rgDevData = NULL;
    PSP_DEVINFO_DATA pDid;
    UINT iData, numData, maxData = 5, iEnum;
    BOOL foundMatch = FALSE;
    INT DeleteAppletExt = 0;

    UNREFERENCED_PARAMETER(pInfContext);

    // If no Driver list is given, life is quite simple: 
    // just disable all legacy drivers and succeed
    if (!szDriverListSection)
    {
        ASSERT (pbDeleteAppletExt == NULL);
        DeskLogError(LogSevInformation, (bUpgrade ? IDS_SETUPLOG_MSG_014 : IDS_SETUPLOG_MSG_015));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    // By default, do not disable applet extensions 
    ASSERT (pbDeleteAppletExt != NULL);
    *pbDeleteAppletExt = FALSE;

    // Find the specified section in the inf
    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_016, szDriverListSection);

    if (!SetupFindFirstLine(hInf,
                            szDriverListSection,
                            NULL,
                            &driverListContext))
    {
        // The section listed in the database doesn't exist!  
        // Behave as though it wasn't there
        DeskLogError(LogSevInformation, (bUpgrade ? IDS_SETUPLOG_MSG_017 
                                                  : IDS_SETUPLOG_MSG_018));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    // Get all the video devices in the system
    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        // If no display devices are found, treat this as the case where 
        // no match was made
        DeskLogError(LogSevInformation, 
                     (bUpgrade ? IDS_SETUPLOG_MSG_019 : IDS_SETUPLOG_MSG_020));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    rgDevData = (PDEVDATA) LocalAlloc(LPTR, maxData * sizeof(DEVDATA));
    
    if (!rgDevData) {
        
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    iEnum = numData = 0;
    
    do
    {
        pDid = &rgDevData[numData].did;

        pDid->cbSize = sizeof(SP_DEVINFO_DATA);
        if (!SetupDiEnumDeviceInfo(hDevInfo, ++iEnum, pDid))
        {
            break;
        }

        // If it isn't a legacy devnode, then ignore it
        if (CM_Get_Device_ID(pDid->DevInst, szProperty, ARRAYSIZE(szProperty), 0)
            == CR_SUCCESS && !DeskIsLegacyDevNodeByPath(szProperty))
        {
            continue;
        }
                                            
        // Initially grab the service name
        dwSize = SZ_BINARY_LEN;
        if (CM_Get_DevNode_Registry_Property(pDid->DevInst,
                                             CM_DRP_SERVICE,
                                             NULL,
                                             rgDevData[numData].szService,
                                             &dwSize,
                                             0) != CR_SUCCESS)
        {
            // couldn't get the service, ignore this device
            continue;
        }

        StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), TEXT("System\\CurrentControlSet\\Services\\%s"), rgDevData[numData].szService);

        // Try to grab the real binary name of the service
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szRegPath,
                         0,
                         KEY_READ,
                         &hKey) == ERROR_SUCCESS)
        {
            // Parse the device map and open the registry.
            dwSize = ARRAYSIZE(szProperty);
            if (RegQueryValueEx(hKey,
                                TEXT("ImagePath"),
                                NULL,
                                NULL,
                                (LPBYTE) szProperty,
                                &dwSize) == ERROR_SUCCESS)
            {
                // The is a binary, extract the name, which will be of the form
                // ...\driver.sys
                LPTSTR pszDriver, pszDriverEnd;

                pszDriver = szProperty;
                pszDriverEnd = szProperty + lstrlen(szProperty);

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('.')) {
                    pszDriverEnd--;
                }

                *pszDriverEnd = UNICODE_NULL;

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('\\')) {
                    pszDriverEnd--;
                }

                pszDriverEnd++;

                //
                // If pszDriver and pszDriverEnd are different, we now
                // have the driver name.
                //

                if (pszDriverEnd > pszDriver &&
                    lstrlen(pszDriverEnd) < SZ_BINARY_LEN) {
                    StringCchCopy(rgDevData[numData].szBinary, ARRAYSIZE(rgDevData[numData].szBinary), pszDriverEnd);
                }
            }
    
            RegCloseKey(hKey);
        
        } else {
            
            //
            // no service at all, consider it bogus
            //

            continue;
        }

        if (++numData == maxData) {

            DEVDATA *tmp;
            UINT oldMax = maxData;

            maxData <<= 1;

            //
            // Alloc twice as many, copy them over, zero out the new memory
            // and free the old list
            //

            tmp = (PDEVDATA) LocalAlloc(LPTR, maxData * sizeof(DEVDATA));
            memcpy(tmp, rgDevData, oldMax * sizeof(DEVDATA));
            ZeroMemory(tmp + oldMax, sizeof(DEVDATA) * oldMax);
            LocalFree(rgDevData);
            rgDevData = tmp;
        }
    
    } while (1);

    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_021, numData);

    //
    // Assume that no matches have been made
    //

    dwRet =  (bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL);
    
    if (numData != 0) {

        //
        // There are legacy devices to check against...
        //

        do {
            LPTSTR szValue;

            memset(szService, 0, sizeof(szService));
            dwSize = sizeof(szService) / sizeof(TCHAR);
            if ((SetupGetFieldCount(&driverListContext) < 1) ||
                !SetupGetStringField(&driverListContext, 
                                     1, 
                                     szService, 
                                     dwSize, 
                                     &dwSize)) {
                continue;
            }
    
            if (szService[0] == TEXT('\0')) {
                continue;
            }
    
            for (iData = 0; iData < numData; iData++) {

                if (rgDevData[iData].szBinary[0] != TEXT('\0')) {
                    
                    szValue = rgDevData[iData].szBinary;
                
                } else {
                    
                    szValue = rgDevData[iData].szService;
                }

                if (lstrcmpi(szService, szValue) == 0)
                {
                    DeskLogError(LogSevInformation, 
                                 (bUpgrade ? IDS_SETUPLOG_MSG_022 
                                           : IDS_SETUPLOG_MSG_023));

                    dwRet = (bUpgrade ? ERROR_DI_DONT_INSTALL : ERROR_SUCCESS);
                    foundMatch = TRUE;
                    
                    //
                    // In case we fail upgrade, do we want to disable applet 
                    // extensions?
                    //

                    if ((dwRet == ERROR_DI_DONT_INSTALL) &&
                        (SetupGetFieldCount(&driverListContext) >= 2) &&
                        SetupGetIntField(&driverListContext, 2,
                                         &DeleteAppletExt)) {

                        *pbDeleteAppletExt = 
                            (DeleteAppletExt != 0);
                    }

                    break;
                }
            }
        } while (SetupFindNextLine(&driverListContext, &driverListContext));
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
    LocalFree(rgDevData);

    if (!foundMatch)
    {
        DeskLogError(LogSevInformation, 
                     (bUpgrade ? IDS_SETUPLOG_MSG_024 : IDS_SETUPLOG_MSG_025),
                     szDriverListSection);
    }

    return dwRet;
}


DWORD 
DeskCheckDatabase(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    BOOL* pbDeleteAppletExt
    )
{
    DWORD dwRet = ERROR_SUCCESS, dwSize, dwValue;
    HINF hInf;
    HKEY hKeyUpdate;
    INFCONTEXT infContext;
    BOOL foundMatch = FALSE;
    TCHAR szDatabaseId[200];
    TCHAR szDriverListSection[100];
    PTCHAR szHardwareIds = NULL, szCompatIds = NULL;
    CONFIGRET cr;
    ULONG len;
    PTCHAR szMatchedId = NULL;
    int upgrade = FALSE;
    BOOL IsNTUpgrade = FALSE;
    TCHAR szDatabaseInf[] = TEXT("display.inf");
    TCHAR szDatabaseSection[] = TEXT("VideoUpgradeDatabase");

    ASSERT (pDeviceInfoData != NULL);
    ASSERT (pbDeleteAppletExt != NULL);
    ASSERT ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0);
    
    *pbDeleteAppletExt = FALSE;

    //
    // All of the following values were placed here by our winnt32 migration dll
    // Find out what version of windows we are upgrading from
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKeyUpdate) == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        if ((RegQueryValueEx(hKeyUpdate, 
                            SZ_UPGRADE_FROM_PLATFORM, NULL, NULL,
                            (PBYTE) 
                            &dwValue, 
                            &dwSize) == ERROR_SUCCESS) && 
            (dwValue == VER_PLATFORM_WIN32_NT)) {

            IsNTUpgrade = TRUE;
        }

        RegCloseKey(hKeyUpdate);
    }

    if (!IsNTUpgrade) {

        return ERROR_SUCCESS;
    }

    //
    // Get the hardware ID
    //

    len = 0;
    cr = CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                           CM_DRP_HARDWAREID,
                                           NULL,
                                           NULL,
                                           &len,
                                           0);

    if (cr == CR_BUFFER_SMALL) {

        szHardwareIds = (PTCHAR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (szHardwareIds) {

            CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                             CM_DRP_HARDWAREID,
                                             NULL,
                                             szHardwareIds,
                                             &len,
                                             0);

            if (DeskFindMatchingId(TEXT("LEGACY_UPGRADE_ID"), szHardwareIds)) {

                DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_031);
                LocalFree(szHardwareIds);
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Get the compatible ID
    //

    len = 0;
    cr = CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                          CM_DRP_COMPATIBLEIDS,
                                          NULL,
                                          NULL,
                                          &len,
                                          0);

    if (cr == CR_BUFFER_SMALL) {

        szCompatIds = (PTCHAR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (szCompatIds) {
            
            CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                             CM_DRP_COMPATIBLEIDS,
                                             NULL,
                                             szCompatIds,
                                             &len,
                                             0);
        }
    }

    if (!szHardwareIds && !szCompatIds)
    {
        // No IDs to look up!  Assume success.
        DeskLogError(LogSevWarning, IDS_SETUPLOG_MSG_032);
        return ERROR_SUCCESS;
    }

    hInf = SetupOpenInfFile(szDatabaseInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        // Couldn't open the inf. This shouldn't happen.  
        // Use default upgrade logic
        DeskLogError(LogSevWarning, IDS_SETUPLOG_MSG_033);
        return ERROR_SUCCESS;
    }

    if (!SetupFindFirstLine(hInf,
                            szDatabaseSection,
                            NULL,
                            &infContext))
    {
        // Couldn't find the section or there are no entries in it.  
        // Use default upgrade logic
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_034, szDatabaseSection);
    }
    else
    {
        do
        {
            dwSize = ARRAYSIZE(szDatabaseId);
            if (!SetupGetStringField(&infContext, 0, szDatabaseId, dwSize, &dwSize))
            {
                continue;
            }

            szMatchedId = DeskFindMatchingId(szDatabaseId, szHardwareIds);
            if (!szMatchedId)
            {
                szMatchedId = DeskFindMatchingId(szDatabaseId, szCompatIds);
            }

            if (szMatchedId)
            {
                DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_035, szMatchedId);

                // Do something here and then get out of the loop
                SetupGetIntField(&infContext, 1, &upgrade);

                if (SetupGetFieldCount(&infContext) >= 2)
                {
                    dwSize = ARRAYSIZE(szDriverListSection);
                    SetupGetStringField(&infContext, 2, szDriverListSection, dwSize, &dwSize);

                    dwRet = DeskPerformDatabaseUpgrade(hInf, 
                                                       &infContext, 
                                                       upgrade, 
                                                       szDriverListSection, 
                                                       pbDeleteAppletExt);
                }
                else
                {
                    dwRet = DeskPerformDatabaseUpgrade(hInf, 
                                                       &infContext, 
                                                       upgrade, 
                                                       NULL, 
                                                       NULL);
                }
    
                break;
            }
    
        } while (SetupFindNextLine(&infContext, &infContext));
    }

    if (szHardwareIds) {
        LocalFree(szHardwareIds);
    }
    if (szCompatIds) {
        LocalFree(szCompatIds);
    }

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if (dwRet == ERROR_SUCCESS)
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_039);
    }
    else {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_040);
    }

    return dwRet;
}


VOID
DeskGetUpgradeDeviceStrings(
    PTCHAR Description,
    PTCHAR MfgName,
    PTCHAR ProviderName
    )
{
    TCHAR szDisplay[] = TEXT("display.inf");
    TCHAR szDeviceStrings[] = TEXT("SystemUpgradeDeviceStrings");
    TCHAR szValue[LINE_LEN];
    HINF hInf;
    INFCONTEXT infContext;
    DWORD dwSize;

    hInf = SetupOpenInfFile(szDisplay, NULL, INF_STYLE_WIN4, NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        goto GetStringsError;
    }

    if (!SetupFindFirstLine(hInf, szDeviceStrings, NULL, &infContext)) 
        goto GetStringsError;

    do {
        dwSize = ARRAYSIZE(szValue);
        if (!SetupGetStringField(&infContext, 0, szValue, dwSize, &dwSize)) {
            continue;
        }

        dwSize = LINE_LEN;
        if (lstrcmp(szValue, TEXT("Mfg")) ==0) {
            SetupGetStringField(&infContext, 1, MfgName, dwSize, &dwSize);
        }
        else if (lstrcmp(szValue, TEXT("Provider")) == 0) {
            SetupGetStringField(&infContext, 1, ProviderName, dwSize, &dwSize);
        }
        else if (lstrcmp(szValue, TEXT("Description")) == 0) {
            SetupGetStringField(&infContext, 1, Description, dwSize, &dwSize);
        }
    } while (SetupFindNextLine(&infContext, &infContext));

    SetupCloseInfFile(hInf);
    return;

GetStringsError:

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    StringCchCopy(Description, ARRAYSIZE(Description), TEXT("Video Upgrade Device"));
    StringCchCopy(MfgName, ARRAYSIZE(MfgName), TEXT("(Standard display types)"));
    StringCchCopy(ProviderName, ARRAYSIZE(ProviderName), TEXT("Microsoft"));
}


DWORD
DeskGetSetupFlags(
    VOID
    )
{
    HKEY hkey;
    DWORD retval = 0;
    TCHAR data[256];
    DWORD cb;
    LPTSTR regstring;

    hkey = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("System\\Setup"),
                     0,
                     KEY_READ | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        
        cb = 256;

        if (RegQueryValueEx(hkey,
                            TEXT("SystemSetupInProgress"),
                            NULL,
                            NULL,
                            (LPBYTE)(data),
                            &cb) == ERROR_SUCCESS) {
            
            retval |= *((LPDWORD)(data)) ? INSETUP : 0;
            regstring = TEXT("System\\Video_Setup");
        
        } else {
            
            regstring = TEXT("System\\Video_NO_Setup");
        }

        cb = 256;

        if (RegQueryValueEx(hkey,
                            TEXT("UpgradeInProgress"),
                            NULL,
                            NULL,
                            (LPBYTE)(data),
                            &cb) == ERROR_SUCCESS) {
            
            retval |= *((LPDWORD)(data)) ? INSETUP_UPGRADE : 0;
            regstring = TEXT("System\\Video_Setup_Upgrade");
        
        } else {

            regstring = TEXT("System\\Video_Setup_Clean");
        }

        if (hkey) {
            RegCloseKey(hkey);
        }
    }

    return retval;
}


BOOL
DeskGetVideoDeviceKey(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPTSTR pServiceName,
    IN DWORD DeviceX,
    OUT HKEY* phkDevice
    )
{
    BOOL retVal = FALSE;
    HKEY hkPnP = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
    GUID DeviceKeyGUID;
    LPWSTR pwstrGUID= NULL;
    LPTSTR ptstrGUID= NULL;
    LPTSTR pBuffer = NULL;
    DWORD dwSize, len;

    //
    // Open the PnP key
    //

    hkPnP = SetupDiCreateDevRegKey(hDevInfo,
                                   pDeviceInfoData,
                                   DICS_FLAG_GLOBAL,
                                   0,
                                   DIREG_DEV,
                                   NULL,
                                   NULL);

    if (hkPnP == INVALID_HANDLE_VALUE) {

        //
        // Videoprt.sys handles the legacy device case.
        //

        goto Fallout;
    }

    //
    // Try to get the GUID from the PnP key
    //

    dwSize = 0;
    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        NULL,
                        &dwSize) == ERROR_SUCCESS) {
        
        //
        // The GUID is there so use it.
        //

        len = lstrlen(SZ_VIDEO_DEVICES);
        
        DWORD cbBuffer = dwSize + (len + 6) * sizeof(TCHAR);
        pBuffer = (LPTSTR)LocalAlloc(LPTR, cbBuffer);
        
        if (pBuffer == NULL)
        {
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("LocalAlloc"));
            goto Fallout;
        }
        
        StringCbCopy(pBuffer, cbBuffer, SZ_VIDEO_DEVICES);

        if (RegQueryValueEx(hkPnP,
                            SZ_GUID,
                            0,
                            NULL,
                            (PBYTE)(pBuffer + len),
                            &dwSize) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegQueryValueEx"));
    
            goto Fallout;
        }

        DWORD cchGUID = lstrlen(pBuffer);
        StringCbPrintf(pBuffer + cchGUID, 
                  cbBuffer - (cchGUID * sizeof(TCHAR)), 
                  TEXT("\\%04d"), 
                  DeviceX);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pBuffer,
                         0,
                         KEY_ALL_ACCESS,
                         phkDevice) != ERROR_SUCCESS) {

            if (DeviceX == 0) {
            
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_128,
                             TEXT("RegOpenKeyEx"));
            }
    
            goto Fallout;
        }

        retVal = TRUE;
    
    } else {

        if (DeviceX > 0) {

            //
            // For dual-view, the class installer handles only the primary view. 
            // Secondary views are handled by videoprt.sys
            //

            goto Fallout;
        }

        //
        // The GUID is not there so create a new one.
        //

        if (CoCreateGuid(&DeviceKeyGUID) != S_OK) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("CoCreateGuid"));
    
            goto Fallout;
        }
        
        if (StringFromIID(DeviceKeyGUID, &pwstrGUID) != S_OK) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("StringFromIID"));
    
            pwstrGUID = NULL;
            goto Fallout;
        }
    
        //
        // Convert the string if necessary
        //

#ifdef UNICODE
        ptstrGUID = pwstrGUID;
#else
        SIZE_T cch = wcslen(pwstrGUID) + 1;
        ptstrGUID = LocalAlloc(LPTR, cch);
        if (ptstrGUID == NULL) 
            goto Fallout;
        WideCharToMultiByte(CP_ACP, 0, pwstrGUID, -1, ptstrGUID, cch, NULL, NULL);
#endif

        //
        // Upcase the string
        //

        CharUpper(ptstrGUID);
        
        //
        // Allocate the memory
        //

        len = max((lstrlen(SZ_VIDEO_DEVICES) + 
                   lstrlen(ptstrGUID) + 
                   max(6, lstrlen(SZ_COMMON_SUBKEY) + 1)),
                  (lstrlen(SZ_SERVICES_PATH) +
                   lstrlen(pServiceName) +
                   lstrlen(SZ_COMMON_SUBKEY) + 1));

        
        pBuffer = (LPTSTR)LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (pBuffer == NULL) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("LocalAlloc"));
    
            goto Fallout;
        }

        //
        // Save the service name 
        //

        StringCchPrintf(pBuffer, len, TEXT("%s%s%s"), SZ_VIDEO_DEVICES, ptstrGUID, SZ_COMMON_SUBKEY);

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkCommonSubkey,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
            
            hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        if (RegSetValueEx(hkCommonSubkey,
                          SZ_SERVICE,
                          0,
                          REG_SZ,
                          (LPBYTE)pServiceName,
                          (lstrlen(pServiceName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
            goto Fallout;
        }
        
        RegCloseKey(hkCommonSubkey);
        hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;

        StringCchPrintf(pBuffer, len, TEXT("%s%s%s"), SZ_SERVICES_PATH, pServiceName, SZ_COMMON_SUBKEY);

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkCommonSubkey,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
            
            hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        if (RegSetValueEx(hkCommonSubkey,
                          SZ_SERVICE,
                          0,
                          REG_SZ,
                          (LPBYTE)pServiceName,
                          (lstrlen(pServiceName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
            goto Fallout;
        }
        
        //
        // Build the new registry key 
        //

        StringCchPrintf(pBuffer, len, TEXT("%s%s\\0000"), SZ_VIDEO_DEVICES, ptstrGUID);

        //
        // Create the key
        //

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           phkDevice,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
    
            goto Fallout;
        }

        //
        // Store the GUID under the PnP key
        //

        if (RegSetValueEx(hkPnP,
                          SZ_GUID,
                          0,
                          REG_SZ,
                          (LPBYTE)ptstrGUID,
                          (lstrlen(ptstrGUID) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
    
            RegCloseKey(*phkDevice);
            *phkDevice = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        retVal = TRUE;
    }

Fallout:

    //
    // Clean-up
    //

    if (hkCommonSubkey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkCommonSubkey);
    }

    if (pBuffer != NULL) {
        LocalFree(pBuffer);
    }

#ifndef UNICODE
    
    if (ptstrGUID != NULL) {
        LocalFree(ptstrGUID);
    }

#endif

    if (pwstrGUID != NULL) {
        CoTaskMemFree(pwstrGUID);
    }
    
    if (hkPnP != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkPnP);
    }

    return retVal;

} // DeskGetVideoDeviceKey


BOOL
DeskIsServiceDisableable(
    PTCHAR szService
    )
{
    return ((lstrcmp(szService, TEXT("vga")) != 0) &&
            (lstrcmp(szService, TEXT("VgaSave")) != 0));
}

VOID
DeskDeleteAppletExtensions(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    )
{
    PTCHAR mszBuffer = NULL;
    HKEY  hKeyUpdate;
    DWORD dwSize, dwPlatform = VER_PLATFORM_WIN32_NT, dwMajorVer = 5;
    BOOL bDeleteAppletExt = FALSE;
    DWORD cbSize = 0;

    //
    // Open the upgrade registry key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKeyUpdate) != ERROR_SUCCESS) {

        //
        // No big deal
        //

        return;
    }

    //
    // Retrieve the applet extensions we want to delete from the registry
    // Get the size first.
    //

    if (RegQueryValueEx(hKeyUpdate,
                        SZ_APPEXT_TO_DELETE,
                        0,
                        NULL,
                        NULL,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Allocate the memory
    //

    mszBuffer = (PTCHAR)LocalAlloc(LPTR, cbSize);
    
    if (mszBuffer == NULL) {
        goto Fallout;
    }

    //
    // Get the extensions
    //

    if ((RegQueryValueEx(hKeyUpdate,
                         SZ_APPEXT_TO_DELETE,
                         0,
                         NULL,
                         (BYTE*)mszBuffer,
                         &cbSize) != ERROR_SUCCESS) ||
        (*mszBuffer == TEXT('\0'))) {
        
        goto Fallout;
    }

    //
    // Read the OS version we are upgrading from from the registry
    //

    dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUpdate, 
                    SZ_UPGRADE_FROM_PLATFORM, 
                    NULL, 
                    NULL,
                    (PBYTE) &dwPlatform, &dwSize);

    dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUpdate, 
                    SZ_UPGRADE_FROM_MAJOR_VERSION, 
                    NULL, 
                    NULL,
                    (PBYTE) &dwMajorVer, &dwSize);

    //
    // Don't do anything for Win3x or Win9x 
    //

    if (dwPlatform != VER_PLATFORM_WIN32_NT) {
        goto Fallout;
    }


    if ((dwMajorVer < 5) &&
        (DeskCheckDatabase(hDevInfo, 
                           pDeviceInfoData,
                           &bDeleteAppletExt) != ERROR_SUCCESS) &&
        (!bDeleteAppletExt)) {

        goto Fallout;
    }

    DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                 mszBuffer);

Fallout:

    RegCloseKey(hKeyUpdate);

    if (mszBuffer != NULL) {
        LocalFree(mszBuffer);
    }
}


VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    )
{
    TCHAR szKeyName[MAX_PATH];
    HKEY  hkDeleteFrom, hkExt;
    DWORD cSubKeys = 0, cbSize = 0;
    TCHAR szDefaultValue[MAX_PATH];
    PTCHAR szValue;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     szDeleteFrom, 
                     0,
                     KEY_ALL_ACCESS,
                     &hkDeleteFrom) == ERROR_SUCCESS) {

        if (RegQueryInfoKey(hkDeleteFrom, 
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS) {
        
            while (cSubKeys--) {
        
                if (RegEnumKey(hkDeleteFrom, 
                               cSubKeys, 
                               szKeyName, 
                               ARRAYSIZE(szKeyName)) == ERROR_SUCCESS) {
        
                    int iComp = -1;
        
                    if (RegOpenKeyEx(hkDeleteFrom,
                                     szKeyName,
                                     0,
                                     KEY_READ,
                                     &hkExt) == ERROR_SUCCESS) {
        
                        cbSize = sizeof(szDefaultValue);
                        if ((RegQueryValueEx(hkExt,
                                             NULL,
                                             0,
                                             NULL,
                                             (PBYTE)szDefaultValue,
                                             &cbSize) == ERROR_SUCCESS) &&
                            (szDefaultValue[0] != TEXT('\0'))) {
        
                            szValue = mszExtensionsToRemove;
        
                            while (*szValue != TEXT('\0')) {
                            
                                iComp = lstrcmpi(szDefaultValue, szValue);
        
                                if (iComp <= 0) {
                                    break;
                                }
        
                                while (*szValue != TEXT('\0')) 
                                    szValue++;

                                szValue++;
                            }
                        }
        
                        RegCloseKey(hkExt);
                    }
        
                    if (iComp == 0) {
                    
                        if (SHDeleteKey(hkDeleteFrom, szKeyName) == ERROR_SUCCESS) {
                            
                            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_098, szKeyName);
                        
                        } else {
                            
                            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_097);
                        }
                    }
                }
            }
        }

        RegCloseKey(hkDeleteFrom);
    }
} 


VOID
DeskAEMove(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    HKEY hkMoveFrom,
    PAPPEXT pAppExtBefore,
    PAPPEXT pAppExtAfter
    )
{
    HKEY hkDrvKey = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkMoveTo = 0, hkMovedKey;
    PAPPEXT pAppExtMove = NULL;

    hkDrvKey = SetupDiOpenDevRegKey(hDevInfo,
                                    pDeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);

    if (hkDrvKey == INVALID_HANDLE_VALUE) {
        goto Fallout;
    }

    while (pAppExtAfter != NULL) {

        BOOL bMove = FALSE;
        pAppExtMove = pAppExtAfter;

        if (pAppExtBefore != NULL) {
        
            int iComp = lstrcmpi(pAppExtBefore->szDefaultValue, pAppExtAfter->szDefaultValue);
            
            if (iComp < 0) {
    
                pAppExtBefore = pAppExtBefore->pNext;
            
            } else if (iComp == 0) {
    
                pAppExtBefore = pAppExtBefore->pNext;
                pAppExtAfter = pAppExtAfter->pNext;
            
            } else {

                bMove = TRUE;
                pAppExtAfter = pAppExtAfter->pNext;
            }
        
        } else {
            
            bMove = TRUE;
            pAppExtAfter = pAppExtAfter->pNext;
        }

        if (bMove) {

            SHDeleteKey(hkMoveFrom, pAppExtMove->szKeyName);
    
            if (hkMoveTo == 0) {
            
                if (RegCreateKeyEx(hkDrvKey,
                                   TEXT("Display\\") STRREG_SHEX_PROPSHEET,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkMoveTo,
                                   NULL) != ERROR_SUCCESS) {
    
                    hkMoveTo = 0;
                    goto Fallout;
                }
            }

            if (RegCreateKeyEx(hkMoveTo,
                               pAppExtMove->szKeyName,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkMovedKey,
                               NULL) == ERROR_SUCCESS) {

                RegSetValueEx(hkMovedKey, 
                              NULL,
                              0,
                              REG_SZ, 
                              (PBYTE)(pAppExtMove->szDefaultValue),
                              (lstrlen(pAppExtMove->szDefaultValue) + 1) * sizeof(TCHAR));

                //
                // Make sure we check for duplicate applet extension when  
                // the advanced page is opened for the first time
                //

                DWORD CheckForDuplicates = 1;
                RegSetValueEx(hkDrvKey,
                              TEXT("DeskCheckForDuplicates"),
                              0,
                              REG_DWORD,
                              (LPBYTE)&CheckForDuplicates,
                              sizeof(DWORD));

                RegCloseKey(hkMovedKey);
            }
        }
    }

Fallout:
    
    if (hkMoveTo != 0) {
        RegCloseKey(hkMoveTo);
    }

    if (hkDrvKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrvKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETEXT       = cpl

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

DLLDEF          = $(O)\desk.def

INCLUDES=$(INCLUDES);..\;$(TERMSRV_INC_PATH);$(DS_INC_PATH);$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(0);$(O)

SOURCES         = ..\desk.rc      \
                  ..\backdlg.cpp  \
                  ..\debug.cpp    \
                  ..\desk.cpp     \
                  ..\deskcmmn.cpp \
                  ..\init.cpp     \
                  ..\install2.cpp \
                  ..\ocpage.cpp   \
                  ..\util.cpp

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(WINDOWS_LIB_PATH)\user32p.lib   \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SHELL_LIB_PATH)\shfusion.lib    \
                  $(SDK_LIB_PATH)\setupapi.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(SDK_LIB_PATH)\mpr.lib           \
                  $(SDK_LIB_PATH)\version.lib       \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib

DLLENTRY        = DllInitialize

DELAYLOAD=SETUPAPI.DLL;MPR.DLL
DLOAD_ERROR_HANDLER=KERNEL32.DLL

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
 
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\ocpage.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ocpage.cpp

Abstract:

    This file implements the display page setup.

Environment:

    WIN32 User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <devguid.h>


//
// Defines
//

#define DEFAULT_XRESOLUTION    640
#define DEFAULT_YRESOLUTION    480
#define DEFAULT_BPP            15
#define DEFAULT_VREFRESH       60
#define MIN_XRESOLUTION        800
#define MIN_YRESOLUTION        600


//
// Global Data
//

BOOL g_IsSetupInitComponentInitialized = FALSE;
SETUP_INIT_COMPONENT g_SetupInitComponent;


//
// Function prototypes
//

DWORD
HandleOcInitComponent(
    PSETUP_INIT_COMPONENT SetupInitComponent
    );

DWORD
HandleOcCompleteInstallation(
    VOID
    );

BOOL 
MigrateUnattendedSettings(
    HDEVINFO hDevInfo
    );

VOID
MigrateRegistrySettings(
    HDEVINFO hDevInfo
    );

VOID
MigrateRegistrySettingsBasedOnBusLocation(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount,
    DWORD BusNumber,
    DWORD Address
    );

VOID
MigrateRegistrySettingsLegacy(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey
    );

VOID
MigrateRegistrySettingsHelper(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount
    );

VOID
MigrateDeviceKeySettings(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hLogicalDeviceKey,
    DWORD Index
    );


//
// Implementation
//


extern "C" {

DWORD
DisplayOcSetupProc(
    IN LPCVOID ComponentId,
    IN LPCVOID SubcomponentId,
    IN UINT Function,
    IN UINT_PTR Param1,
    IN OUT PVOID Param2
    )
{
    switch (Function) {
    
    case OC_PREINITIALIZE:
        return OCFLAG_UNICODE;

    case OC_INIT_COMPONENT:
        return HandleOcInitComponent((PSETUP_INIT_COMPONENT)Param2);

    case OC_QUERY_STATE:
        return SubcompOn; // we are always installed

    case OC_COMPLETE_INSTALLATION:
        return HandleOcCompleteInstallation();

    default:
        break;
    }

    return ERROR_SUCCESS;
}

} // extern "C"


DWORD
HandleOcInitComponent(
    PSETUP_INIT_COMPONENT SetupInitComponent
    )
{
    DWORD retValue = ERROR_SUCCESS;

    if (OCMANAGER_VERSION <= SetupInitComponent->OCManagerVersion) {

        SetupInitComponent->ComponentVersion = OCMANAGER_VERSION;
        
        g_IsSetupInitComponentInitialized = TRUE;
        CopyMemory(
            &g_SetupInitComponent,
            (LPVOID)SetupInitComponent,
            sizeof(SETUP_INIT_COMPONENT));
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_100);

        retValue = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return retValue;
}


DWORD
HandleOcCompleteInstallation(
    VOID
    )
{
    BOOL bUnattended = FALSE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HKEY hKey;
    
    DeskOpenLog();
    
    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_101);
        goto Cleanup;
    }

    if ((g_SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) != 0) {
        
        //
        // Unattended settings
        //

        bUnattended = MigrateUnattendedSettings(hDevInfo);
    }

    if ((!bUnattended) && 
        ((g_SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) != 0)) {

        //
        // Registry settings
        //

        MigrateRegistrySettings(hDevInfo);
    }
    
Cleanup:

    RegDeleteKey(HKEY_LOCAL_MACHINE, SZ_DETECT_DISPLAY);
    RegDeleteKey(HKEY_LOCAL_MACHINE, SZ_NEW_DISPLAY);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     SZ_UPDATE_SETTINGS_PATH,
                     0,
                     KEY_WRITE,
                     &hKey) == ERROR_SUCCESS) {
    
        SHDeleteKey(hKey, SZ_UPDATE_SETTINGS_KEY);
        RegCloseKey(hKey);
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_102);
    }
    
    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    DeskCloseLog();
    
    return ERROR_SUCCESS;
}


BOOL
MigrateUnattendedSettings(
    HDEVINFO hDevInfo
    )
{
    INFCONTEXT context;
    HINF hInf;
    TCHAR szName[128];
    DWORD value;
    DWORD cFields = 0;
    DWORD BitsPerPel = 0, XResolution = 0, YResolution = 0, VRefresh = 0;
    DWORD UsePreferredMode = 0;
    DWORD AttachedToDesktop = 0;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    HKEY hInterfaceKey = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
    DWORD DevInfoIndex = 0;

    //
    // Get the handle to the answer file
    //

    hInf = g_SetupInitComponent.HelperRoutines.GetInfHandle(
        INFINDEX_UNATTENDED,
        g_SetupInitComponent.HelperRoutines.OcManagerContext);

    if ((hInf == NULL) || 
        (hInf == (HINF)INVALID_HANDLE_VALUE)) {
        
        return FALSE;
    }
    
    //
    // Read the settings from the answer file
    //

    if (SetupFindFirstLine(hInf, TEXT("Display"), NULL, &context)) {
        
        do {

            if (SetupGetStringField(&context,
                                    0,
                                    szName,
                                    ARRAYSIZE(szName),
                                    &value)) {
    
                if (lstrcmpi(szName, TEXT("BitsPerPel")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT)&value)) {

                        ++cFields;
                        BitsPerPel = value;
                    
                    } else {

                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_096,
                                     szName);
                    }
                
                } else if (lstrcmpi(szName, TEXT("Xresolution")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT)&value)) {

                        ++cFields;
                        XResolution = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_060);
                    }
                
                } else if (lstrcmpi(szName, TEXT("YResolution")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT) &value)) {

                        ++cFields;
                        YResolution = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_062,
                                     szName);
                    }
                
                } else if (lstrcmpi( szName, TEXT("VRefresh")) == 0) {
                    
                    if (SetupGetIntField(&context, 1, (PINT) &value)) {
                        
                        ++cFields;
                        VRefresh = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_064,
                                     szName);
                    }
                
                } else {

                    DeskLogError(LogSevInformation,
                                 IDS_SETUPLOG_MSG_065,
                                 szName);
                }
            }
    
        } while (SetupFindNextLine(&context, &context));

    }

    if (cFields == 0) {

        //
        // The answer file doesn't contain any display settings
        //

        goto Fallout;
    }

    //
    // "Normalize" the display settings
    //

    AttachedToDesktop = 1;

    if (BitsPerPel == 0) {

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_069,
                     DEFAULT_BPP);

        BitsPerPel = DEFAULT_BPP;
    }

    if ((XResolution == 0) || (YResolution == 0)) {

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_067,
                     DEFAULT_XRESOLUTION, 
                     DEFAULT_YRESOLUTION);

        XResolution = DEFAULT_XRESOLUTION;
        YResolution = DEFAULT_YRESOLUTION;
    }                                                  

    if (VRefresh == 0) {
        
        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_068,
                     DEFAULT_VREFRESH);

        VRefresh = DEFAULT_VREFRESH;
    }

    //
    // Apply the display settings to all video cards
    //

    DevInfoIndex = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    
    while (SetupDiEnumDeviceInfo(hDevInfo, DevInfoIndex, &DevInfoData)) {

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (!SetupDiCreateDeviceInterface(hDevInfo,
                                          &DevInfoData,
                                          &GUID_DISPLAY_ADAPTER_INTERFACE,
                                          NULL,  
                                          0,
                                          &InterfaceData)) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_103);
            goto NextDevice;
        }

        hInterfaceKey = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                           &InterfaceData, 
                                                           0,
                                                           KEY_SET_VALUE,
                                                           NULL,
                                                           NULL);

        if (hInterfaceKey == INVALID_HANDLE_VALUE) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_104);
            goto NextDevice;
        }

        if (RegCreateKeyEx(hInterfaceKey, 
                           TEXT("0"),
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hInterfaceLogicalDeviceKey,
                           NULL) != ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_105, 0);
            hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
            goto NextDevice;
        }

        //
        // Do not use the preferred mode for unattended installs
        //

        UsePreferredMode = 0;
        
        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_PREFERRED_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&UsePreferredMode, 
                      sizeof(UsePreferredMode));

        //
        // AttachedToDesktop
        //

        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_ATTACHED_TO_DESKTOP, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&AttachedToDesktop, 
                      sizeof(AttachedToDesktop));

        //
        // BitsPerPel
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_BITS_PER_PEL, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&BitsPerPel, 
                          sizeof(BitsPerPel)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_106, 
                         BitsPerPel);
        }

        //
        // XResolution
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_X_RESOLUTION, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&XResolution, 
                          sizeof(XResolution)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_107, 
                         XResolution);
        }

        //
        // dwYResolution
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_Y_RESOLUTION, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&YResolution, 
                          sizeof(YResolution)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_108, 
                         YResolution);
        }

        //
        // dwVRefresh
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_VREFRESH, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&VRefresh, 
                          sizeof(VRefresh)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_109, 
                         VRefresh);
        }

NextDevice:

        if (hInterfaceLogicalDeviceKey != INVALID_HANDLE_VALUE) {
        
            RegCloseKey(hInterfaceLogicalDeviceKey);
            hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
        }

        if (hInterfaceKey != INVALID_HANDLE_VALUE) {
        
            RegCloseKey(hInterfaceKey);
            hInterfaceKey = (HKEY)INVALID_HANDLE_VALUE;
        }

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        ++DevInfoIndex;
    }

Fallout:

    return (cFields != 0);
}


VOID
MigrateRegistrySettings(
    HDEVINFO hDevInfo
    )
{
    HKEY hKey = 0, hPhysicalDeviceKey = 0;
    DWORD PhysicalDevicesCount = 0, LogicalDevicesCount = 0;
    DWORD cb = 0, PhysicalDevice = 0, Failed = 0;
    TCHAR Buffer[20];
    BOOL IsLegacy;
    DWORD BusNumber = 0, Address = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_075);

        hKey = 0;
        goto Cleanup;
    }

    cb = sizeof(DWORD);
    if ((RegQueryValueEx(hKey,
                         SZ_UPGRADE_FAILED_ALLOW_INSTALL,
                         NULL,
                         NULL,
                         (LPBYTE)&Failed,
                         &cb) == ERROR_SUCCESS) &&
         (Failed != 0)) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_076);
        goto Cleanup;
    }

    cb = sizeof(PhysicalDevicesCount);
    if (RegQueryValueEx(hKey,        
                        SZ_VU_COUNT,
                        0,
                        NULL,
                        (PBYTE)&PhysicalDevicesCount,
                        &cb) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_110);
        goto Cleanup;
    }

    for(PhysicalDevice = 0; 
        PhysicalDevice < PhysicalDevicesCount; 
        PhysicalDevice++) {
        
        StringCchCopy(Buffer, ARRAYSIZE(Buffer), SZ_VU_PHYSICAL);
        size_t cchBuf = lstrlen(Buffer);
        StringCchPrintf(Buffer + cchBuf, ARRAYSIZE(Buffer) - cchBuf, TEXT("%d"), PhysicalDevice);

        if (RegOpenKeyEx(hKey, 
                         Buffer,
                         0,
                         KEY_READ,
                         &hPhysicalDeviceKey) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_111);
            hPhysicalDeviceKey = 0;
            goto NextPhysicalDevice;
        }

        //
        // Get the count of logical devices 
        //

        cb = sizeof(LogicalDevicesCount);
        if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_COUNT,
                            0,
                            NULL,
                            (PBYTE)&LogicalDevicesCount,
                            &cb) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_112);
            goto NextPhysicalDevice;
        }

        //
        // Get the bus number and address 
        //

        IsLegacy = TRUE;
        cb = sizeof(BusNumber);
        if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_BUS_NUMBER,
                            0,
                            NULL,
                            (PBYTE)&BusNumber,
                            &cb) == ERROR_SUCCESS) {

            cb = sizeof(Address);
            if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_ADDRESS,
                            0,
                            NULL,
                            (PBYTE)&Address,
                            &cb) == ERROR_SUCCESS) {
            
                IsLegacy = FALSE;
            }
        }

        if (!IsLegacy) {

            MigrateRegistrySettingsBasedOnBusLocation(hDevInfo,
                                                      hPhysicalDeviceKey, 
                                                      LogicalDevicesCount,
                                                      BusNumber,
                                                      Address);
        
        } else if ((PhysicalDevicesCount == 1) &&
                   (LogicalDevicesCount == 1)) {

            //
            // If legacy, we support migration of a single device.
            //

            MigrateRegistrySettingsLegacy(hDevInfo,
                                          hPhysicalDeviceKey);
        }

NextPhysicalDevice:

        if (hPhysicalDeviceKey != 0) {
        
            RegCloseKey(hPhysicalDeviceKey);
            hPhysicalDeviceKey = 0;
        }
    }

Cleanup:

    if (hKey != 0) {
        RegCloseKey(hKey);
    }

    return;
}


VOID
MigrateRegistrySettingsBasedOnBusLocation(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount,
    DWORD BusNumber,
    DWORD Address
    )
{
    SP_DEVINFO_DATA DevInfoData;
    DWORD CurrentBusNumber = 0, CurrentAddress = 0;
    DWORD DevInfoIndex = 0;
    BOOL bFound = FALSE;

    //
    // Let's find the device with the same bus number and address
    //

    DevInfoIndex = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    
    while (SetupDiEnumDeviceInfo(hDevInfo, DevInfoIndex, &DevInfoData)) {

        if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_BUSNUMBER,
                                             NULL,
                                             (PBYTE)&CurrentBusNumber,
                                             sizeof(CurrentBusNumber),
                                             NULL) && 
            
            (CurrentBusNumber == BusNumber) &&

            SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_ADDRESS,
                                             NULL,
                                             (PBYTE)&CurrentAddress,
                                             sizeof(CurrentAddress),
                                             NULL) &&

            (CurrentAddress == Address)) {
            
            //
            // We found the device with the same bus number and address
            // So ... migrate the settings 
            //
                        
            MigrateRegistrySettingsHelper(hDevInfo,
                                          &DevInfoData,
                                          hPhysicalDeviceKey,
                                          LogicalDevicesCount);
            
            //
            // We are done
            //

            bFound = TRUE;
            break;
        }

        //
        // Next device
        //

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        ++DevInfoIndex;
    }

    if (!bFound) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_113);
    }

    return;
}


VOID
MigrateRegistrySettingsLegacy(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey
    )
{
    SP_DEVINFO_DATA DevInfoData0, DevInfoData1;
    
    DevInfoData0.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiEnumDeviceInfo(hDevInfo, 0, &DevInfoData0)) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_115);
        return;
    }

    DevInfoData1.cbSize = sizeof(SP_DEVINFO_DATA);
    if (SetupDiEnumDeviceInfo(hDevInfo, 1, &DevInfoData1)) {
        
        //
        // There are at least 2 video devices in the system
        // We don't know which device to apply the settings to.
        // So, just ignore this case
        //
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_114);
        return;
    }

    MigrateRegistrySettingsHelper(hDevInfo,
                                  &DevInfoData0,
                                  hPhysicalDeviceKey,
                                  1); // there is only one logical device
}


VOID
MigrateRegistrySettingsHelper(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount
    )
{
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    HKEY hInterfaceKey = 0;
    HKEY hInterfaceLogicalDeviceKey = 0;
    HKEY hLogicalDeviceKey = 0;
    TCHAR Buffer[20];
    DWORD cb = 0, LogicalDevice = 0;
    DWORD UsePreferredMode = 0;
    DWORD AttachedToDesktop = 0;
    DWORD RelativeX = 0;
    DWORD RelativeY = 0;
    DWORD BitsPerPel = 0;
    DWORD XResolution = 0;
    DWORD YResolution = 0;
    DWORD VRefresh = 0;
    DWORD Flags = 0;

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    if (!SetupDiCreateDeviceInterface(hDevInfo,
                                      pDevInfoData,
                                      &GUID_DISPLAY_ADAPTER_INTERFACE,
                                      NULL,  
                                      0,
                                      &InterfaceData)) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_103);
        return;
    }

    hInterfaceKey = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                       &InterfaceData, 
                                                       0,
                                                       KEY_SET_VALUE,
                                                       NULL,
                                                       NULL);

    if (hInterfaceKey == INVALID_HANDLE_VALUE) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_104);
        return;
    }

    for (LogicalDevice = 0;
         LogicalDevice < LogicalDevicesCount;
         ++LogicalDevice) {

        StringCchCopy(Buffer, ARRAYSIZE(Buffer), SZ_VU_LOGICAL);
        size_t cchBuf = lstrlen(Buffer);
        StringCchPrintf(Buffer + cchBuf, ARRAYSIZE(Buffer) - cchBuf, TEXT("%d"), LogicalDevice);

        if (RegOpenKeyEx(hPhysicalDeviceKey, 
                        Buffer,
                        0,
                        KEY_READ,
                        &hLogicalDeviceKey) != ERROR_SUCCESS) {
            
            //
            // We can not go on with this physical device
            // The LogicalDevices order is important for DualView
            //
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_116);
            break;
        }

        StringCchPrintf(Buffer, ARRAYSIZE(Buffer), TEXT("%d"), LogicalDevice);
        if (RegCreateKeyEx(hInterfaceKey, 
                           Buffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hInterfaceLogicalDeviceKey,
                           NULL) != ERROR_SUCCESS) {

            //
            // We can not go on with this physical device
            // The LogicalDevices order is important for DualView
            //
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_105, LogicalDevice);
            RegCloseKey(hLogicalDeviceKey);
            break;
        }

        //
        // Use preferred mode?
        //

        cb = sizeof(XResolution);
        if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_X_RESOLUTION,
                            0,
                            NULL,
                            (PBYTE)&XResolution,
                            &cb) != ERROR_SUCCESS) {
    
            XResolution = DEFAULT_XRESOLUTION;
        }
    
        cb = sizeof(YResolution);
        if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_Y_RESOLUTION,
                            0,
                            NULL,
                            (PBYTE)&YResolution,
                            &cb) != ERROR_SUCCESS) {
    
            YResolution = DEFAULT_YRESOLUTION;
        }

        UsePreferredMode = ((XResolution < MIN_XRESOLUTION) || 
                            (YResolution < MIN_YRESOLUTION));
        
        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_PREFERRED_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&UsePreferredMode, 
                      sizeof(UsePreferredMode));

        if (UsePreferredMode) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_130);

        } else {

            //
            // AttachedToDesktop
            //
        
            cb = sizeof(AttachedToDesktop);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_ATTACHED_TO_DESKTOP,
                                0,
                                NULL,
                                (PBYTE)&AttachedToDesktop,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_ATTACHED_TO_DESKTOP, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&AttachedToDesktop, 
                                  sizeof(AttachedToDesktop)) == ERROR_SUCCESS) {
    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_117, 
                                 AttachedToDesktop);
                }
            }
    
            //
            // RelativeX
            //
        
            cb = sizeof(RelativeX);
            if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_RELATIVE_X,
                            0,
                            NULL,
                            (PBYTE)&RelativeX,
                            &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_RELATIVE_X, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&RelativeX, 
                                  sizeof(RelativeX)) == ERROR_SUCCESS) {
    
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_118, 
                             RelativeX);
                }
    
            }
        
            //
            // RelativeY
            //
        
            cb = sizeof(RelativeY);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_RELATIVE_Y,
                                0,
                                NULL,
                                (PBYTE)&RelativeY,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_RELATIVE_Y, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&RelativeY, 
                                  sizeof(RelativeY)) == ERROR_SUCCESS) {
                
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_119, 
                                 RelativeY);
                }
            }
    
            //
            // BitsPerPel
            //
        
            cb = sizeof(BitsPerPel);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_BITS_PER_PEL,
                                0,
                                NULL,
                                (PBYTE)&BitsPerPel,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_BITS_PER_PEL, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&BitsPerPel, 
                                  sizeof(BitsPerPel)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_120, 
                                 BitsPerPel);
                }
            }
        
            //
            // XResolution
            //
        
            if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                              SZ_VU_X_RESOLUTION, 
                              0, 
                              REG_DWORD, 
                              (PBYTE)&XResolution, 
                              sizeof(XResolution)) == ERROR_SUCCESS) {
                
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_121, 
                             XResolution);
            }
        
            //
            // dwYResolution
            //
        
            if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                              SZ_VU_Y_RESOLUTION, 
                              0, 
                              REG_DWORD, 
                              (PBYTE)&YResolution, 
                              sizeof(YResolution)) == ERROR_SUCCESS) {
                
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_122, 
                             YResolution);
            }
        
            //
            // dwVRefresh
            //
        
            cb = sizeof(VRefresh);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_VREFRESH,
                                0,
                                NULL,
                                (PBYTE)&VRefresh,
                                &cb) == ERROR_SUCCESS) {
            
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_VREFRESH, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&VRefresh, 
                                  sizeof(VRefresh)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_123, 
                                 VRefresh);
                }
            }
        
            //
            // Flags
            //
        
            cb = sizeof(Flags);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_FLAGS,
                                0,
                                NULL,
                                (PBYTE)&Flags,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_FLAGS, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&Flags, 
                                  sizeof(Flags)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_124, 
                                 Flags);
                }
            }
        }
    
        //
        // Migrate the hardware acceleration and the pruning mode
        //

        MigrateDeviceKeySettings(hDevInfo,
                                 pDevInfoData,
                                 hLogicalDeviceKey,
                                 LogicalDevice);

        RegCloseKey(hLogicalDeviceKey);
        RegCloseKey(hInterfaceLogicalDeviceKey);
    }

    RegCloseKey(hInterfaceKey);
}


VOID
MigrateDeviceKeySettings(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hLogicalDeviceKey,
    DWORD Index
    )
{
    HKEY hkPnP = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkDevice = (HKEY)INVALID_HANDLE_VALUE;
    LPTSTR pBuffer = NULL;
    DWORD dwSize, len, cb;
    DWORD HwAcceleration, PruningMode;

    //
    // Open the PnP key
    //

    hkPnP = SetupDiOpenDevRegKey(hDevInfo,
                                 pDevInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DEV,
                                 KEY_READ);

    if (hkPnP == INVALID_HANDLE_VALUE) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("SetupDiOpenDevRegKey"));

        goto Fallout;
    }

    //
    // Try to get the GUID from the PnP key
    //

    dwSize = 0;
    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegQueryValueEx"));

        goto Fallout;
    }

    len = lstrlen(SZ_VIDEO_DEVICES);
    
    DWORD cbBuf = dwSize + (len + 6) * sizeof(TCHAR);
    pBuffer = (LPTSTR)LocalAlloc(LPTR, cbBuf);
    
    if (pBuffer == NULL) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("LocalAlloc"));

        goto Fallout;
    }
    
    StringCbCopy(pBuffer, cbBuf, SZ_VIDEO_DEVICES);

    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        (PBYTE)(pBuffer + len),
                        &dwSize) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegQueryValueEx"));

        goto Fallout;
    }

    DWORD cchGUID = lstrlen(pBuffer);
    StringCbPrintf(pBuffer + cchGUID, cbBuf - (cchGUID * sizeof(TCHAR)), L"\\%04d", Index);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     pBuffer,
                     0,
                     KEY_WRITE,
                     &hkDevice) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegOpenKeyEx"));

        hkDevice = (HKEY)INVALID_HANDLE_VALUE;
        goto Fallout;
    }

    //
    // Hardware acceleration
    //

    cb = sizeof(HwAcceleration);
    if (RegQueryValueEx(hLogicalDeviceKey,
                        SZ_HW_ACCELERATION,
                        0,
                        NULL,
                        (PBYTE)&HwAcceleration,
                        &cb) == ERROR_SUCCESS) {

        RegSetValueEx(hkDevice, 
                      SZ_HW_ACCELERATION, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&HwAcceleration, 
                      sizeof(HwAcceleration));
    }

    //
    // Pruning mode
    //

    cb = sizeof(PruningMode);
    if (RegQueryValueEx(hLogicalDeviceKey,
                        SZ_PRUNNING_MODE,
                        0,
                        NULL,
                        (PBYTE)&PruningMode,
                        &cb) == ERROR_SUCCESS) {

        RegSetValueEx(hkDevice, 
                      SZ_PRUNNING_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&PruningMode, 
                      sizeof(PruningMode));
    }

Fallout:

    if (hkPnP != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkPnP);
    }

    if (pBuffer != NULL) {
        LocalFree(pBuffer);
    }
    
    if (hkDevice != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDevice);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 5/30/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag);
BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid);
HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\deskcmmn.cpp ===
#include "deskperf.h"

#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 5/30/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "util.h"

BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid)
{
    BOOL fIsEqual = FALSE;

    if (punk)
    {
        CLSID clsidPageID;
        HRESULT hr = IUnknown_GetClassID(punk, &clsidPageID);

        if (SUCCEEDED(hr) && IsEqualCLSID(clsidPageID, clsid))
        {
            fIsEqual = TRUE;
        }
    }

    return fIsEqual;
}


HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ppunkFound)
    {
        IEnumUnknown * pEnum;

        *ppunkFound = NULL;
        hr = punk->QueryInterface(IID_PPV_ARG(IEnumUnknown, &pEnum));
        if (SUCCEEDED(hr))
        {
            IUnknown * punkToTry;
            ULONG ulFetched;

            while (SUCCEEDED(pEnum->Next(1, &punkToTry, &ulFetched)) &&
                (1 == ulFetched))
            {
                if (IUnknown_CompareCLSID(punkToTry, clsid))
                {
                    *ppunkFound = punkToTry;
                    break;
                }

                punkToTry->Release();
            }

            pEnum->Release();
        }
    }

    return hr;
}

HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\desknt5\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <help.h>
#include <scrnsave.h>

#include <shlobj.h>
#include <cpl.h>
#include <shsemip.h>
#include <shellp.h>

#include <commdlg.h>
#include <commctrl.h>
#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <cfgmgr32.h>
#include <newexe.h>
#include <winuser.h>
#include <winuserp.h>
#include <wingdi.h>
#include <ccstock.h>
#include <objsafe.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>

#include <shsemip.h>
#include <shpriv.h>

#include <ocmanage.h>

#include <debug.h>

#include "deskid.h"
#include "desk.h"
#include "deskdbg.h"
#include "look.h"
#include "util.h"
#include "..\common\deskcplext.h"
#include "..\common\deskcmmn.h"
#include "shfusion.h"
#include <tchar.h>

#include <strsafe.h>


// With this feature on, we demote the advanced appearances
// options into an "Advanced" subdialog.
#define FEATURE_DEMOTE_ADVANCED_APPEAROPTIONS



#define CH_HTML_ESCAPE             L'%'


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\resource.h ===
// Static control

#ifndef IDC_STATIC
#define IDC_STATIC               (-1)
#endif

// Icon

#define IDI_MONITOR              100

// Property sheet

#define PROP_SHEET_DLG           200
#define IDC_ACCELERATION_SLIDER  201
#define IDC_ACCELERATION_TEXT    202
#define IDC_TROUBLE_SHOOTER      203
#define IDC_DESCRIPTION          204
#define IDC_ENABLE_USWC          205

// dialog box

#define DLG_ASKDYNACDS           250
#define IDC_NODYNA               251
#define IDC_YESDYNA              252
#define IDC_SHUTUP               253

// Strings

#define IDS_PAGE_TITLE             1
#define IDS_LEVEL0               300
#define IDS_LEVEL1               301
#define IDS_LEVEL2               302 
#define IDS_LEVEL3               303
#define IDS_LEVEL4               304
#define IDS_LEVEL5               305
#define IDS_WC_CAPTION           310
#define IDS_WC_MESSAGE           311
#define IDS_ERR_CAPTION          312
#define IDS_ERR_MESSAGE          313

// Help

#define IDH_NOHELP               ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION     4175
#define IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_WRITE_COMBINING  4176
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\propsext.cpp ===
#include "deskperf.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"

PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst)
{
    PROPSHEETPAGE* ppsPage = LocalAlloc(LPTR, sizeof(PROPSHEETPAGE));
    if (ppsPage)
    {
        ppsPage->dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        ppsPage->hInstance = hinst;
        ppsPage->dwFlags = PSP_DEFAULT;
    }

    return ppsPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\deskperf.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>
#include <htmlhelp.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>

#include <initguid.h>
#include <help.h>
#include <commctrl.h>

#include <winuser.h>
#include <winuserp.h>

#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "..\..\common\deskcmmn.h"

#include "resource.h"

#define STRSAFE_LIB
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\aliases.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 ***************************************************************************/

#ifdef UNIX_FEATURE_ALIAS

#undef UNICODE

#include "inetcplp.h"
#include "shalias.h"

#include "mluisupp.h"

STDAPI RefreshGlobalAliasList();

#define  GETALIASLIST(hDlg)     ((LPALIASINFO )GetWindowLong(hDlg, DWL_USER))->aliasList
#define  GETALIASDELLIST(hDlg)  ((LPALIASINFO )GetWindowLong(hDlg, DWL_USER))->aliasDelList

BOOL CALLBACK AlEditDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID WINAPI InitAliasListStyle(HWND hwndLV, DWORD dwView);

static TCHAR g_szAliasKey[]     = TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\Alias");

// InitListViewImageLists - creates image lists for a list view. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
BOOL WINAPI InitAliasListImageLists(HWND hwndLV)     
{ 
    HICON hiconItem;        // icon for list view items 
    HIMAGELIST himlLarge;   // image list for icon view 
    HIMAGELIST himlSmall;   // image list for other views  

    // Create the full-sized and small icon image lists. 
    himlLarge = ImageList_Create(GetSystemMetrics(SM_CXICON), 
        GetSystemMetrics(SM_CYICON), TRUE, 1, 1); 
    himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
        GetSystemMetrics(SM_CYSMICON), TRUE, 1, 1);  
    
    // Add an icon to each image list. 
    // note that IDI_WALLET has to live in inetcplc.rc because
    // it's used by a localizable dialog, hence the MLGetHinst()
    hiconItem = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_WALLET));
    ImageList_AddIcon(himlLarge, hiconItem); 
    ImageList_AddIcon(himlSmall, hiconItem);     
    DeleteObject(hiconItem);  
    
    // Assign the image lists to the list view control. 
    ListView_SetImageList(hwndLV, himlLarge, LVSIL_NORMAL); 
    ListView_SetImageList(hwndLV, himlSmall, LVSIL_SMALL);     

    return TRUE;     
} 

    
// InitListViewItems - adds items and subitems to a list view. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
// pfData - text file containing list view items with columns 
//          separated by semicolons. 
BOOL WINAPI InitAliasListItems(HWND hwndLV, HDPA aliasList)     
{ 
    PSTR pszEnd;
    int iItem;
    int iSubItem;
    LVITEM lvi;  
    
    // Initialize LVITEM members that are common to all items. 
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE; 
    lvi.state = 0;     lvi.stateMask = 0; 
    lvi.pszText = LPSTR_TEXTCALLBACK;   // app. maintains text 
    lvi.iImage = 0;                     // image list index  
    
    int aliasCount = DPA_GetPtrCount( aliasList );

    for (int i = 0; i< aliasCount; i++)
    { 
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, i );

        // Initialize item-specific LVITEM members.         
        lvi.iItem = i; 
        lvi.iSubItem = 0;
        lvi.lParam = (LPARAM) NULL;    // item data  
        // Add the item.       
        ListView_InsertItem(hwndLV, &lvi);  

        // Initialize item-specific LVITEM members.         
        ListView_SetItemText(hwndLV, i, 0, (TCHAR*)GetAliasName(ptr));  
        ListView_SetItemText(hwndLV, i, 1, (TCHAR*)GetAliasUrl(ptr));  
    }      
    
    return TRUE;
}  


// InitListViewColumns - adds columns to a list view control. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
BOOL WINAPI InitAliasListColumns(HWND hwndLV)     
{ 
    TCHAR g_achTemp[256];         // temporary buffer     
    LVCOLUMN lvc; 
    int iCol;      
    
    // Initialize the LVCOLUMN structure. 
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvc.fmt = LVCFMT_LEFT;     
    lvc.pszText = g_achTemp;  
    
    // Add the columns.     
    for (iCol = 0; iCol < ALIASLIST_COLUMNS; iCol++) 
    { 
        lvc.iSubItem = iCol; 
        lvc.cx = 100 + (iCol*150);     
        MLLoadString(IDS_FIRSTCOLUMN + iCol, 
                g_achTemp, sizeof(g_achTemp)); 
        if (ListView_InsertColumn(hwndLV, iCol, &lvc) == -1) 
            return FALSE;     
    } 

    return TRUE;
}

// SetView - sets a list view's window style to change the view. 
// hwndLV - handle to the list view control. 
// dwView - value specifying a view style.      
VOID WINAPI InitAliasListStyle(HWND hwndLV, DWORD dwView)     
{ 
    // Get the current window style. 
    DWORD dwStyle = ListView_GetExtendedListViewStyle(hwndLV);  

    ListView_SetExtendedListViewStyle( hwndLV, (dwStyle|dwView) );
    // SetWindowLong(hwndLV, GWL_EXSTYLE, (dwStyle | dwView)); 
} 

// AliasDel - deletes alias from active list and moves it to the
//            del list to be delete later. 
// hDlg - handle of the propertysheet dialog.
BOOL WINAPI AliasDel( HWND hDlg )
{
    int index = 0, iItem = 0;
    HWND lb           = GetDlgItem( hDlg, IDC_ALIAS_LIST );
    HDPA aliasList    = GETALIASLIST(hDlg);
    HDPA aliasDelList = GETALIASDELLIST(hDlg);
    BOOL fAsked       = FALSE;
    BOOL fChanged     = FALSE;
    int  count        = ListView_GetItemCount(lb);

    // Get the selection from the Listview and remove it from the
    // active alias list, add it to the aliaslist to be deleted.
    while( (iItem = ListView_GetNextItem( lb, -1, LVNI_SELECTED ) ) != -1 )
    {
        TCHAR str[MAX_URL_STRING]; *str = TEXT('\0');

        if( !fAsked )
        {
            TCHAR question[MAX_PATH];

            wsprintf( question, "Are you Sure you want to delete the selected items?");
            if( MessageBox( GetParent(hDlg), question, TEXT("Delete Alias"), MB_YESNO ) != IDYES )
                return FALSE;

            fAsked = TRUE;
        }

        // if( !ListView_GetCheckState(lb, iItem) ) continue;

        ListView_GetItemText(lb, iItem, 0, str, MAX_URL_STRING );
        if(*str)
        {
            if( (index = FindAliasIndex(aliasList, str) ) != -1 )
            {
                 CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, index );
                 if( ptr )
                 {
                    CAlias *pAlias = (CAlias *)DPA_DeletePtr( aliasList, index );

                    // Add to List of deleted entries
                    DPA_InsertPtr( aliasDelList, 0x7FFF, pAlias );
                    ListView_DeleteItem(lb, iItem);
                    fChanged = TRUE;
                    LocalFree( str );
                } 
            }
        }
    }

    if( fChanged )
    {
        InitAliasDialog( hDlg, NULL, FALSE ); 
        PropSheet_Changed(GetParent(hDlg),hDlg);
    }

    return TRUE;
}


// AliasEdit - Called in response to the Edit button pressed.
// hDlg - Handle to the property sheet 
BOOL WINAPI AliasEdit( HWND hDlg )
{
    CAlias * ptr = GetCurrentAlias( hDlg );
    HDPA aliasDelList = GETALIASDELLIST(hDlg);

    if( ptr )
    {
        CAlias *ptrOld = (CAlias *)CreateAlias( (LPTSTR)GetAliasName(ptr) );
        ALIASEDITINFO aliasEditInfo = { GETALIASLIST(hDlg), ptr, hDlg, EDIT_ALIAS };
        if(MLDialogBoxParamWrap( MLGetHinst(), MAKEINTRESOURCE(IDD_ALIAS_EDIT), hDlg, AlEditDlgProc, (LPARAM)&aliasEditInfo ) == 2 )
        {
            // Add old alias to del list if alias name changes.
            LPCTSTR aliasNew = GetAliasName(ptr);
            LPCTSTR aliasOld = GetAliasName(ptrOld);

            if( StrCmp( aliasNew, aliasOld) )
                DPA_InsertPtr( aliasDelList, 0x7FFF, ptrOld );
            else
                DestroyAlias( ptrOld );
            
            InitAliasDialog( hDlg, ptr, FALSE ); 
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
    }

    return TRUE;
}


// AliasEdit - Called in response to the Add button pressed.
// hDlg - Handle to the property sheet 
BOOL WINAPI AliasAdd( HWND hDlg)
{
    CAlias * ptr = (CAlias *)CreateAlias( TEXT("") );

    if ( ptr )
    {
        ALIASEDITINFO aliasEditInfo = { GETALIASLIST(hDlg), ptr, hDlg, ADD_ALIAS };
        if(MLDialogBoxParamWrap( MLGetHinst(), MAKEINTRESOURCE(IDD_ALIAS_EDIT), hDlg, AlEditDlgProc, (LPARAM)&aliasEditInfo ) == 2)
        {
            InitAliasDialog( hDlg, ptr, FALSE ); 
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        DestroyAlias(ptr);
    }

    return TRUE;
}

// GetCurrentAlias - returns currently selected alis from the listview
// Returns - Selected alias
// hDlg - handle to the property sheet.
CAlias * GetCurrentAlias( HWND hDlg )
{
    int index = 0, iItem = 0;
    HDPA aliasList = GETALIASLIST( hDlg );
    HWND lb   = GetDlgItem( hDlg, IDC_ALIAS_LIST );

    if( ListView_GetSelectedCount(lb) == 1  && 
      ( (iItem = ListView_GetNextItem( lb, -1, LVNI_SELECTED ) ) != -1 ) )
    {
        TCHAR str[MAX_URL_STRING]; *str = TEXT('\0');
        ListView_GetItemText(lb, iItem, 0, str, MAX_URL_STRING );
        if(*str)
        {
            if( (index = FindAliasIndex(aliasList, str) ) != -1 )
            {
                CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, index );
                return ptr;
            }
        }
    }
    return NULL;
}

// InitAliasDialog - Initalizes the aliases dialog 
// Returns - TRUE if succeeded/FALSE if failed.
// hDlg - handle to the property sheet.
// fFullInit - Init listview columns/styles/etc
BOOL FAR PASCAL InitAliasDialog(HWND hDlg, CAlias * current, BOOL fFullInit)
{
    HRESULT  hr = E_FAIL;
    HKEY     hKey;
    HWND     listBox = GetDlgItem( hDlg, IDC_ALIAS_LIST );
    TCHAR *  displayString;

    // Allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    LPALIASINFO pgti = (LPALIASINFO)GetWindowLong(hDlg, DWL_USER);
    pgti->fInternalChange = FALSE;

    SendMessage( listBox, LVM_DELETEALLITEMS, 0, 0L );

    // Initailize ListView
    if( fFullInit )
    {
        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, EM_LIMITTEXT, 255, 0 );
        SendDlgItemMessage( hDlg, IDC_URL_EDIT, EM_LIMITTEXT, MAX_URL_STRING-1, 0 );
        // InitAliasListStyle(listBox, LVS_EX_CHECKBOXES|LVS_EX_FULLROWSELECT );
        InitAliasListStyle(listBox, LVS_EX_FULLROWSELECT );
        InitAliasListImageLists(listBox);     
        InitAliasListColumns(listBox);     
    }

    InitAliasListItems(listBox, GETALIASLIST(hDlg));     
        
    return TRUE;
}

// AliasApply - This function is called in response to  pressing the apply/ok
//              button on the property sheet dialog.
void AliasApply(HWND hDlg)
{
    HDPA aliasDelList = GETALIASDELLIST(hDlg);
    HDPA aliasList    = GETALIASLIST(hDlg);

    ASSERT(aliasList);

    if( aliasDelList )
    {
        int count = DPA_GetPtrCount( aliasDelList );
        
        for(int i=count-1; i>=0; i--)
        {
            CAlias * pAlias = (CAlias *)DPA_DeletePtr( aliasDelList, i );
            if(pAlias) 
            {
                pAlias->Delete();
                DestroyAlias(pAlias);
            }
        }
    }

    // Save the currently changed aliases
    SaveAliases( aliasList );

    // Refresh Global Alias List.
    RefreshGlobalAliasList();
}

// AliasDlgProc - Alias PropertySheet dialog Proc
// Returns BOOL
// hDlg - Handle to the property sheet window
// wParam, lParam - Word/Long param
BOOL CALLBACK AliasDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // get our tab info structure
    LPALIASINFO pgti;

    if (uMsg == WM_INITDIALOG)
    {
        // Allocate memory for a structure which will hold all the info
        // gathered from this page
        //
        LPALIASINFO pgti = (LPALIASINFO)LocalAlloc(LPTR, sizeof(tagALIASINFO));
        if (!pgti)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        pgti->hDlg = hDlg;

        pgti->fInternalChange = FALSE;
        SetWindowLong(hDlg, DWL_USER, (LPARAM)pgti);
        
        if((pgti->aliasList = DPA_Create(4)) != (HDPA)NULL ) 
        {
            pgti->aliasDelList = DPA_Create(4);
            LoadAliases( pgti->aliasList );

            // Initailize dialog 
            if( InitAliasDialog(hDlg, NULL, TRUE) ) 
            {
                return TRUE;
            }
            else
            {
                TCHAR szTitle[MAX_PATH];
                MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));
                MessageBox( GetParent(hDlg), TEXT("Cannot read aliases from registry."), szTitle, MB_OK ); 
                return FALSE;
            }
        }
        else
            return FALSE;
    }
    else
        pgti = (LPALIASINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pgti)
        return FALSE;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case NM_DBLCLK:
                    if(lpnm->idFrom == IDC_ALIAS_LIST)
                          AliasEdit( pgti->hDlg ); 
                    break;
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    AliasApply(hDlg);
                    break;
            }
            break;
        }

        case WM_COMMAND:
            { 
                if(HIWORD(wParam) == BN_CLICKED)
                {
                     switch (LOWORD(wParam))
                     { 
                         case IDC_ALIAS_ADD:
                            AliasAdd( pgti->hDlg ); break;
                         case IDC_ALIAS_EDIT:
                             AliasEdit( pgti->hDlg ); break;
                         case IDC_ALIAS_DEL:
                            AliasDel( pgti->hDlg ); break;
                     }
                }
            }
            break;

        case WM_DESTROY:
            // Delete registry information
            if( pgti->aliasList )
            {
                FreeAliases(pgti->aliasList);
                DPA_Destroy(pgti->aliasList);
            }

            if( pgti->aliasDelList )
            {
                FreeAliases(pgti->aliasDelList);
                DPA_Destroy(pgti->aliasDelList);
            }

            if (pgti)
                LocalFree(pgti);

            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  // make sure we don't re-enter
            break;

    }
    return FALSE;
}


BOOL CALLBACK AlEditDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAlias * pAlias;
    LPALIASEDITINFO pAliasInfo;

    if (uMsg == WM_INITDIALOG)
    {
        TCHAR achTemp[256];
        pAliasInfo = (LPALIASEDITINFO)lParam;
        pAlias = pAliasInfo->alias;
        
        if( !lParam ) 
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, WM_SETTEXT, 0,  (LPARAM)GetAliasName(pAlias));
        SendDlgItemMessage( hDlg, IDC_URL_EDIT, WM_SETTEXT, 0,  (LPARAM)GetAliasUrl(pAlias));

        if( pAliasInfo->dwFlags & EDIT_ALIAS )
        {
            // EnableWindow( GetDlgItem(hDlg, IDC_ALIAS_EDIT ), FALSE );
            MLLoadString(IDS_TITLE_ALIASEDIT, 
                achTemp, sizeof(achTemp)); 
            SendMessage( hDlg, WM_SETTEXT, 0, (LPARAM)achTemp); 
        }
        else
        {
            MLLoadString(IDS_TITLE_ALIASADD, 
                achTemp, sizeof(achTemp)); 
            SendMessage( hDlg, WM_SETTEXT, 0, (LPARAM)achTemp); 
        }

        SetWindowLong(hDlg, DWL_USER, (LPARAM)pAliasInfo);
        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
    }
    else
        pAliasInfo = (LPALIASEDITINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pAlias)
        return FALSE;

    switch (uMsg)
    {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_ALIAS_EDIT:
                case IDC_URL_EDIT:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE) 
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                    }
                    break;
                case IDOK:
                {
                    if( pAliasInfo )
                    {
                        TCHAR alias[MAX_URL_STRING];
                        TCHAR szurl[MAX_URL_STRING];
                        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, WM_GETTEXT, MAX_URL_STRING, (LPARAM)alias );
                        SendDlgItemMessage( hDlg, IDC_URL_EDIT, WM_GETTEXT, MAX_URL_STRING, (LPARAM)szurl );

                        EatSpaces( alias );
                        
                        if( !*alias ) 
                        {
                            EndDialog( hDlg, 1 );
                            break;
                        }

                        if( pAliasInfo->dwFlags & ADD_ALIAS  && *alias)
                        {
                            if(AddAliasToList( pAliasInfo->aliasList, alias, szurl, hDlg ))
                                EndDialog( hDlg, 2);
                        }
                        else if( pAliasInfo->dwFlags & EDIT_ALIAS )
                        {
                            CAlias * ptr = pAliasInfo->alias;
                            if( StrCmp(GetAliasName(ptr), alias) )
                                if(FindAliasIndex( pAliasInfo->aliasList, alias ) != -1)
                                {
                                    MessageBox( hDlg, 
                                        TEXT("Alias with same name already exists"), 
                                        TEXT("Edit Alias"), 
                                        MB_OK|MB_ICONSTOP );
                                    break;
                                }
                            SetAliasInfo(ptr, alias, szurl);
                            EndDialog( hDlg, 2);
                        }
                        break;
                    }        
                    else
                        EndDialog( hDlg, 1 );
                    break;
                }
                case IDCANCEL:
                {
                    EndDialog( hDlg, 1 );
                }
            }
            break;

        case WM_DESTROY:
            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  
            break;

    }
    return FALSE;
}

#endif /* UNIX_FEATURE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\deskperf.cpp ===
//
// [Display Troubleshooter Control Panel Extenstion]
//
//
// - Aug.25.1998
//
//    Created by Hideyuki Nagase [hideyukn]
// 

#include    "deskperf.h"
#define DECL_CRTFREE
#include <crtfree.h>

//
// Defines
//

#define ACCELERATION_FULL  0
#define ACCELERATION_NONE  5

#define SLIDER_POS_TO_ACCEL_LEVEL(x) (ACCELERATION_NONE - (x))
#define ACCEL_LEVEL_TO_SLIDER_POS(x) (ACCELERATION_NONE - (x))

#define REGSTR_GRAPHICS_DRIVERS         TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers")
#define REGSTR_DISABLE_USWC             TEXT("DisableUSWC")
#define REGSTR_VAL_DYNASETTINGSCHANGE   TEXT("DynaSettingsChange")


//
// Guid for "Troubleshooter" shell extentions
//

GUID g_CLSID_CplExt = { 0xf92e8c40, 0x3d33, 0x11d2,
                        { 0xb1, 0xaa, 0x08, 0x00, 0x36, 0xa7, 0x5b, 0x03}
                      };

//
// Global variables
//

//
// Dos display device name
//

TCHAR gszWinDisplayDevice[MAX_PATH];

//
// NT display device name
//

TCHAR gszNtDisplayDevice[MAX_PATH];

//
// Registry path for current device
//

TCHAR gszRegistryPath[MAX_PATH];

//
// Current acceleration level.
//

DWORD AccelLevel = ACCELERATION_FULL;

//
// Last saved acceleration level.
//

DWORD AccelLevelInReg = ACCELERATION_FULL;

//
// Registry security.
//

BOOL  gbReadOnly = FALSE;

//
// Is DisableUSWC key present?.
//

BOOL gbDisableUSWC = FALSE;

//
// Context-sentitive help
//

static const DWORD sc_PerformanceHelpIds[] =
{
   IDI_MONITOR,             IDH_NOHELP,
   IDC_DESCRIPTION,         IDH_NOHELP,
   IDC_ACCELERATION_SLIDER, IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION,
   IDC_ACCELERATION_TEXT,   IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION,
   IDC_ENABLE_USWC,         IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_WRITE_COMBINING,
   0, 0
};

void UpdateGraphicsText(HWND hDlg, DWORD AccelPos)
{
    TCHAR MessageBuffer[200];

    LoadString(g_hInst, IDS_LEVEL0 + AccelPos, MessageBuffer, ARRAYSIZE(MessageBuffer));

    SetDlgItemText(hDlg, IDC_ACCELERATION_TEXT, (LPTSTR) MessageBuffer);
}

BOOL GetDeviceKey(LPCTSTR pszDisplay, LPTSTR pszDeviceKey, int cChars)
{
    DISPLAY_DEVICE DisplayDevice;
    BOOL fFound = FALSE;
    BOOL fSuccess = TRUE;
    int iEnum = 0;

    // Enumerate all the devices in the system.
    while(fSuccess && !fFound)
    {
        ZeroMemory(&DisplayDevice, sizeof(DisplayDevice));
        DisplayDevice.cb = sizeof(DisplayDevice);
        fSuccess = EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0);
        if(fSuccess)
        {
            if(0 == lstrcmp(&DisplayDevice.DeviceName[0], pszDisplay))
            {
                fSuccess = (lstrlen(DisplayDevice.DeviceKey) < cChars);
                ASSERT(fSuccess);
                if(fSuccess)
                {
                    StringCchCopy(pszDeviceKey, cChars, DisplayDevice.DeviceKey);
                    fFound = TRUE;
                }
            }
            ++iEnum;
        }
    }
    
    return fFound;
}


INT_PTR
CALLBACK
AskDynamicApply(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    int *pTemp;

    switch (msg)
    {
    case WM_INITDIALOG:
        if ((pTemp = (int *)lp) != NULL)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTemp);
            CheckDlgButton(hDlg, (*pTemp & DCDSF_DYNA)?
                           IDC_YESDYNA : IDC_NODYNA, BST_CHECKED);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDOK:
            if ((pTemp = (int *)GetWindowLongPtr(hDlg, DWLP_USER)) != NULL)
            {
                *pTemp = IsDlgButtonChecked(hDlg, IDC_YESDYNA)? DCDSF_DYNA : 0;

                if (!IsDlgButtonChecked(hDlg, IDC_SHUTUP))
                    *pTemp |= DCDSF_ASK;

                SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, *pTemp);
            }

            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMessage)
    {
    case WM_INITDIALOG:

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            BOOL bSuccess = FALSE;
            BOOL bDisableUSWCReadOnly = TRUE;

            //
            // LATER: Check we are on Terminal Server client or not.
            //

            BOOL bLocalConsole = TRUE;

            if (bLocalConsole)
            {
                //
                // Get the display device name from IDataObject.
                //

                FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE),
                                  (DVTARGETDEVICE FAR *) NULL,
                                  DVASPECT_CONTENT,
                                  -1,
                                  TYMED_HGLOBAL};

                STGMEDIUM stgm;

                HRESULT hres = g_lpdoTarget->GetData(&fmte, &stgm);

                if (SUCCEEDED(hres) && stgm.hGlobal)
                {
                    //
                    // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
                    //

                    PWSTR pDisplayDevice = (PWSTR) GlobalLock(stgm.hGlobal);

                    if (pDisplayDevice)
                    {
                        //
                        // Copy the data to local buffer.
                        //

                        StringCchCopy(gszWinDisplayDevice, ARRAYSIZE(gszWinDisplayDevice), pDisplayDevice);
                        bSuccess = TRUE;

                        GlobalUnlock(stgm.hGlobal);
                    }  
                }

                //
                // let's build registry path for its hardware profile.
                //

                if (bSuccess)
                {
                    TCHAR szServicePath[MAX_PATH];

                    bSuccess = FALSE;

                    if(GetDeviceKey(gszWinDisplayDevice, szServicePath, ARRAYSIZE(szServicePath)))
                    {
                        //
                        // Upcase all character.
                        //

                        TCHAR *psz = szServicePath;

                        while (*psz)
                        {
                            *psz = _totupper(*psz);
                            psz++;
                        }

                        //
                        // Find \SYSTEM from service path
                        //

                        psz = _tcsstr(szServicePath,TEXT("\\SYSTEM"));

                        //
                        // Skip '\'
                        //

                        psz++;

                        StringCchCopy(gszRegistryPath, ARRAYSIZE(gszRegistryPath), psz);

                        bSuccess = TRUE;
                    }
                }

                if (bSuccess)
                {
                    //
                    // Read current acceleration level from registry.
                    //

                    HKEY hKeyAccelLevel = NULL;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     gszRegistryPath,
                                     0,
                                     KEY_WRITE | KEY_READ,
                                     &hKeyAccelLevel) != ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         gszRegistryPath,
                                         0,
                                         KEY_READ,
                                         &hKeyAccelLevel) != ERROR_SUCCESS)
                        {
                            hKeyAccelLevel = NULL;
                        }
                        else
                        {
                            gbReadOnly = TRUE;
                        }
                    }

                    if (hKeyAccelLevel)
                    {
                        DWORD cb = sizeof(AccelLevel);
                        if (RegQueryValueEx(hKeyAccelLevel,
                                            SZ_HW_ACCELERATION,
                                            NULL,NULL,
                                            (LPBYTE) &AccelLevel,
                                            &cb) == ERROR_SUCCESS)
                        {
                            //
                            // Update last saved accel level.
                            //

                            AccelLevelInReg = AccelLevel;
                        }
                        else
                        {
                            //
                            // If there is no registry value, assume full acceleration.
                            //

                            AccelLevelInReg = AccelLevel = ACCELERATION_FULL;
                        }

                        RegCloseKey(hKeyAccelLevel);

                        bSuccess = TRUE;
                    }
                }
            
                //
                // Read current DisableUSWC status.
                //

                HKEY hKeyGraphicsDrivers = NULL;
                bDisableUSWCReadOnly = FALSE;
                
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_GRAPHICS_DRIVERS,
                                 0,
                                 KEY_WRITE | KEY_READ,
                                 &hKeyGraphicsDrivers) != ERROR_SUCCESS)
                {
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     REGSTR_GRAPHICS_DRIVERS,
                                     0,
                                     KEY_READ,
                                     &hKeyGraphicsDrivers) != ERROR_SUCCESS)
                    {
                        hKeyGraphicsDrivers = NULL;
                    }
                    else
                    {
                        bDisableUSWCReadOnly = TRUE;
                    }
                }

                if (NULL != hKeyGraphicsDrivers) 
                {
                    HKEY hKeyDisableUSWC = NULL;
                    gbDisableUSWC = 
                        (RegOpenKeyEx(hKeyGraphicsDrivers,
                                      REGSTR_DISABLE_USWC,
                                      0,
                                      KEY_READ,
                                      &hKeyDisableUSWC) == ERROR_SUCCESS);
                    
                    if (NULL != hKeyDisableUSWC)
                        RegCloseKey(hKeyDisableUSWC);

                    RegCloseKey(hKeyGraphicsDrivers);
                }
            }

            //
            // Setup slider.
            //

            HWND hSlider = GetDlgItem(hDlg, IDC_ACCELERATION_SLIDER);

            //
            // Slider range is between ACCEL_FULL and ACCEL_NONE.
            //

            SendMessage(hSlider, TBM_SETRANGE, (WPARAM)FALSE,
                        MAKELPARAM(ACCELERATION_FULL, ACCELERATION_NONE));

            //
            // Set currect slider position based on current accel level.
            //
 
            SendMessage(hSlider, TBM_SETPOS, (WPARAM)TRUE,
                        (LPARAM) ACCEL_LEVEL_TO_SLIDER_POS(AccelLevel));

            //
            // Update message based on current acceleration level.
            //

            UpdateGraphicsText(hDlg, AccelLevel);

            if (!bSuccess || gbReadOnly)
            {
                // 
                // Disable slider control
                //

                EnableWindow(hSlider, FALSE);
            }

            
            //
            // Setup DisableUSWC combobox
            //

            HWND hEnableUSWC = GetDlgItem(hDlg, IDC_ENABLE_USWC);
            if (NULL != hEnableUSWC)
            {
                CheckDlgButton(hDlg, IDC_ENABLE_USWC, !gbDisableUSWC);
                EnableWindow(hEnableUSWC, !bDisableUSWCReadOnly);
            }
        }

        break;

    case WM_HSCROLL:

        if (GetWindowLongPtr((HWND)lParam, GWLP_ID) == IDC_ACCELERATION_SLIDER)
        {
            //
            // Slider has been moved.
            //

            HWND hSlider = (HWND) lParam;

            //
            // Obtain currect slider position.
            //

            DWORD dwSliderPos = (DWORD) SendMessage(hSlider, TBM_GETPOS, 0, 0L);

            //
            // Convert slider position to accel level.
            //

            DWORD AccelNew = SLIDER_POS_TO_ACCEL_LEVEL(dwSliderPos); 

            //
            // If accleration level has been changed, update description, and
            // enable apply button.
            //

            if (AccelNew != AccelLevel)
            {
                AccelLevel = AccelNew;
                UpdateGraphicsText(hDlg, AccelNew);
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
        }

        break;

    case WM_COMMAND:
        
        if (IDC_ENABLE_USWC == GET_WM_COMMAND_ID(wParam, lParam))
        {
            BOOL bDisableUSWC = 
                (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_ENABLE_USWC));
            
            if (gbDisableUSWC != bDisableUSWC) 
            {
                //
                // Enable Apply button
                //

                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
        }
        break;

    case WM_NOTIFY:

        if (((NMHDR *)lParam)->code == PSN_APPLY)
        {
            TCHAR szCaption[128];
            TCHAR szMessage[256];
            BOOL bSuccess = TRUE;
            int val = 0;
            BOOL bCancel = FALSE;
            BOOL bAccelLevelDirty;
            BOOL bDisableUSWC;
            BOOL bUSWCDirty;

            bDisableUSWC = 
                (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_ENABLE_USWC));
            bUSWCDirty = (gbDisableUSWC != bDisableUSWC);
            bAccelLevelDirty = (AccelLevel != AccelLevelInReg);

            //
            // Popup dialogs to ask user to apply it dynamically or not.
            //

            if (bAccelLevelDirty)
            {
                val = GetDynaCDSPreference();

                if (val & DCDSF_ASK)
                {
                    if (!bUSWCDirty)
                    {
                        switch (DialogBoxParam(g_hInst, 
                                               MAKEINTRESOURCE(DLG_ASKDYNACDS),
                                               hDlg, 
                                               AskDynamicApply, 
                                               (LPARAM)&val))
                        {
                        case 0:         // user cancelled
                        case -1:        // dialog could not be displayed
                            bCancel = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        val = 0;
                    }
                }
            }

            if ((!(bUSWCDirty || bAccelLevelDirty)) || 
                bCancel)
            {
                //
                // Nothing to do
                //

                SetWindowLongPtr(hDlg, 
                                 DWLP_MSGRESULT, 
                                 ((!(bUSWCDirty || bAccelLevelDirty)) ? 
                                     PSNRET_NOERROR : 
                                     PSNRET_INVALID_NOCHANGEPAGE));

                break;
            }
            
            //
            // Acceleration Level 
            //

            if (AccelLevel != AccelLevelInReg)
            {
                //
                // AccelLevel has been changed. save it to registry.
                //

                HKEY hKeyAccelLevel;
                
                bSuccess = FALSE;
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 gszRegistryPath,
                                 0,
                                 KEY_WRITE,
                                 &hKeyAccelLevel) == ERROR_SUCCESS)
                {
                    if (RegSetValueEx(hKeyAccelLevel,
                                      SZ_HW_ACCELERATION,
                                      NULL, REG_DWORD,
                                      (LPBYTE) &AccelLevel,
                                      sizeof(AccelLevel)) == ERROR_SUCCESS)
                    {
                        bSuccess = TRUE;
                    }

                    RegCloseKey(hKeyAccelLevel);
                }

                if (bSuccess)
                {
                    //
                    // Update last saved data.
                    //

                    AccelLevelInReg = AccelLevel;

                    //
                    // Apply it dynamically?
                    //

                    if ((val & DCDSF_DYNA) == DCDSF_DYNA)
                    {
                        // Apply it dynamically.

                        ChangeDisplaySettings(NULL, CDS_RAWMODE);
                    }
                }
            }

            //
            // Disable USWC
            //

            if (bSuccess && bUSWCDirty) 
            {
                HKEY hKeyGraphicsDrivers = NULL;
                bSuccess = FALSE;
                
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_GRAPHICS_DRIVERS,
                                 0,
                                 KEY_WRITE,
                                 &hKeyGraphicsDrivers) == ERROR_SUCCESS)
                {
                    if (bDisableUSWC)
                    {
                        //
                        // Create the key
                        //
                          
                        HKEY hKeyDisableUSWC = NULL;
                        DWORD Disposition;
        
                        bSuccess = (RegCreateKeyEx(hKeyGraphicsDrivers,
                                                   REGSTR_DISABLE_USWC,
                                                   0,
                                                   NULL,
                                                   REG_OPTION_NON_VOLATILE,
                                                   KEY_READ,
                                                   NULL,
                                                   &hKeyDisableUSWC,
                                                   &Disposition) == ERROR_SUCCESS);
                        
                        if (bSuccess)
                            RegCloseKey(hKeyDisableUSWC);
        
                    }
                    else
                    {
                        //
                        // Delete the key
                        //
        
                        bSuccess = 
                            (RegDeleteKey(hKeyGraphicsDrivers, 
                                          REGSTR_DISABLE_USWC) == ERROR_SUCCESS);
                    }
                
                    if (bSuccess) 
                        gbDisableUSWC = bDisableUSWC;
                    
                    RegCloseKey(hKeyGraphicsDrivers);
                }


                if (bSuccess)
                {
                    //
                    // Notify the user it a reboot is needed
                    //
    
                    if ((LoadString(g_hInst, 
                                    IDS_WC_CAPTION, 
                                    szCaption, 
                                    ARRAYSIZE(szCaption)) != 0) &&
                        (LoadString(g_hInst, 
                                   IDS_WC_MESSAGE, 
                                   szMessage, 
                                   ARRAYSIZE(szMessage)) !=0))
                    {
                        MessageBox(hDlg,
                                   szMessage,
                                   szCaption,
                                   MB_OK | MB_ICONINFORMATION);
                    }
                }
            }

            if (bSuccess)
            {
                if (bUSWCDirty || (0 == val))
                    PropSheet_RestartWindows(GetParent(hDlg));
                
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            } 
            else
            {
                //
                // Notify the user that an unexpected error occured
                //

                if ((LoadString(g_hInst, 
                                IDS_ERR_CAPTION, 
                                szCaption, 
                                ARRAYSIZE(szCaption)) != 0) &&
                    (LoadString(g_hInst, 
                               IDS_ERR_MESSAGE, 
                               szMessage, 
                               ARRAYSIZE(szMessage)) !=0))
                {
                    MessageBox(hDlg,
                               szMessage,
                               szCaption,
                               MB_OK | MB_ICONERROR);
                }

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_PerformanceHelpIds);

        break;


    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_PerformanceHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\deskperf\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETNAME = deskperf
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll

COFFBASE   = desk

DLLDEF=$(O)\deskperf.def

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskperf.rc    \
          ..\deskperf.cpp   \
          ..\propsext.cpp   \
          ..\deskcmmn.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\strsafe.lib          \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SHELL_LIB_PATH)\shfusion.lib

UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain


 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\advanced.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

//
// ADVANCED.C - "Advanced" Property Sheet
//

// HISTORY:
//
// 6/22/96  t-gpease    created
// 5/27/97  t-ashlm     rewrote
//

#include "inetcplp.h"

#include <mluisupp.h>

//
// Private Calls and structures
//
TCHAR g_szUnderline[3][64];

// Reads a STRING and determines BOOL value: "yes" = TRUE | "no" = FALSE
BOOL RegGetBooleanString(HUSKEY huskey, LPTSTR RegValue, BOOL Value);

// Writes a STRING depending on the BOOL: TRUE = "yes" | FALSE = "no"
BOOL RegSetBooleanString(HUSKEY huskey, LPTSTR RegValue, BOOL Value);

// Reads a STRING of R,G,B values and returns a COLOREF.
COLORREF RegGetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value);

// Writes a STRING of R,G,B comma separated values.
COLORREF RegSetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value);

BOOL _AorW_GetFileNameFromBrowse(HWND hDlg,
                                 LPWSTR pszFilename,
                                 UINT cchFilename,
                                 LPCWSTR pszWorkingDir,
                                 LPCWSTR pszExt,
                                 LPCWSTR pszFilter,
                                 LPCWSTR pszTitle);

//
// Reg keys
//
#define REGSTR_PATH_ADVANCEDLIST REGSTR_PATH_IEXPLORER TEXT("\\AdvancedOptions")


typedef struct {
    HWND hDlg;              // handle of our dialog
    HWND hwndTree;          // handle to the treeview

    IRegTreeOptions *pTO;   // pointer to RegTreeOptions interface
    BOOL fChanged;
    BOOL fShowIEOnDesktop;
} ADVANCEDPAGE, *LPADVANCEDPAGE;


BOOL IsShowIEOnDesktopEnabled()
{
    HKEY hk;
    if (SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), TRUE, FALSE, &hk)))
    {
        DWORD dwValue = 0, cbSize = SIZEOF(dwValue);
        SHGetValueW(hk, NULL, TEXT("Attributes"), NULL, (BYTE *)&dwValue, &cbSize);
        RegCloseKey(hk);

        return (dwValue & SFGAO_NONENUMERATED) != SFGAO_NONENUMERATED;;
    }
    return TRUE;
}


#define IE_DESKTOP_NAMESPACE_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\Namespace\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}")

void ShowIEOnDesktop(BOOL fShow)
{
    switch (GetUIVersion())
    {
    case 3:
        //  win95 shell
        if (fShow)
        {
            TCHAR szTheInternet[MAX_PATH];

            int cch = MLLoadString(IDS_THE_INTERNET, szTheInternet, ARRAYSIZE(szTheInternet));
            SHSetValue(HKEY_LOCAL_MACHINE, IE_DESKTOP_NAMESPACE_KEY, NULL, REG_SZ, 
                       szTheInternet, (cch + 1) * sizeof(TCHAR));
        }
        else
        {
            SHDeleteKey(HKEY_LOCAL_MACHINE, IE_DESKTOP_NAMESPACE_KEY); 
        }
        break;

    case 4:
        //  IE4 integrated shell
        //  doesnt have peruser, so we need to just 
        //  delete it by marking it NONENUMERATED
        {
            HKEY hk;
            if (SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), FALSE, FALSE, &hk)))
            {
                DWORD dwValue = 0, cbSize = SIZEOF(dwValue);
                SHGetValue(hk, NULL, TEXT("Attributes"), NULL, (BYTE *)&dwValue, &cbSize);

                dwValue = (dwValue & ~SFGAO_NONENUMERATED) | (fShow ? 0 : SFGAO_NONENUMERATED);

                SHSetValueW(hk, NULL, TEXT("Attributes"), REG_DWORD, (BYTE *)&dwValue, SIZEOF(dwValue));
                RegCloseKey(hk);
            }
        }       
        break;

    default:
        //  do nothing since just changing the settings 
        //  in the right place sets up the PER-USER
        //  stuff correctly
        break;
    }
        
}

// AdvancedDlgInit()
//
// Initializes Advanced property sheet
//
// History:
//
// 6/13/96  t-gpease   created
// 5/27/96  t-ashlm    rewrote
//
BOOL AdvancedDlgInit(HWND hDlg)
{
    LPADVANCEDPAGE  pAdv;
    HTREEITEM htvi;
    HRESULT hr;

    pAdv = (LPADVANCEDPAGE)LocalAlloc(LPTR, sizeof(*pAdv));
    if (!pAdv)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    TraceMsg(TF_GENERAL, "\nInitializing Advanced Tab\n");

    pAdv->fShowIEOnDesktop = IsShowIEOnDesktopEnabled();

    InitCommonControls();

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pAdv);

    // save dialog handle
    pAdv->hDlg = hDlg;
    pAdv->hwndTree = GetDlgItem( pAdv->hDlg, IDC_ADVANCEDTREE );

    CoInitialize(0);
    hr = CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER,
                          IID_IRegTreeOptions, (LPVOID *)&(pAdv->pTO));


    if (SUCCEEDED(hr))
    {
#ifdef UNICODE  // InitTree takes Ansi string
        char szRegPath[REGSTR_MAX_VALUE_LENGTH];
        SHTCharToAnsi(REGSTR_PATH_ADVANCEDLIST, szRegPath, ARRAYSIZE(szRegPath));
        hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, szRegPath, NULL);
#else
        hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, REGSTR_PATH_ADVANCEDLIST, NULL);
#endif
    }

        // find the first root and make sure that it is visible
    htvi = TreeView_GetRoot( pAdv->hwndTree );
    TreeView_EnsureVisible( pAdv->hwndTree, htvi );

    if (g_restrict.fAdvanced)
    {
        EnableDlgItem(hDlg, IDC_RESTORE_DEFAULT, FALSE);
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

#define REGKEY_DECLINED_IOD   TEXT("Software\\Microsoft\\Active Setup\\Declined Install On Demand IEv5.PP2")
#define REGKEY_DECLINED_COMPONENTS     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Declined Components IE5.pp2")
//
// AdvancedDlgOnCommand
//
// Handles Advanced property sheet window commands
//
// History:
// 6/13/96  t-gpease   created
// 5/27/97  t-ashlm    rewrote
//
void AdvancedDlgOnCommand(LPADVANCEDPAGE pAdv, UINT id, UINT nCmd)
{
    switch (id)
    {
        case IDC_RESTORE_DEFAULT:
            if (nCmd == BN_CLICKED)
            {
                // forget all Install On Demands that the user requested we
                // never ask again
                // Warning : if you ever have subkeys - these will fail on NT
                RegDeleteKey(HKEY_CURRENT_USER, REGKEY_DECLINED_IOD);
                // forget all code downloads that user said No to
                RegDeleteKey(HKEY_CURRENT_USER, REGKEY_DECLINED_COMPONENTS);

                pAdv->pTO->WalkTree(WALK_TREE_RESTORE);
                pAdv->fChanged = TRUE;
                ENABLEAPPLY(pAdv->hDlg);
            }
            break;
    }
}

//
// AdvancedDlgOnNotify()
//
// Handles Advanced property sheets WM_NOTIFY messages
//
// History:
//
// 6/13/96  t-gpease   created
//
void AdvancedDlgOnNotify(LPADVANCEDPAGE pAdv, LPNMHDR psn)
{
    SetWindowLongPtr( pAdv->hDlg, DWLP_MSGRESULT, (LONG_PTR)0); // handled

    switch (psn->code) {
        case TVN_KEYDOWN:
        {
            TV_KEYDOWN *pnm = (TV_KEYDOWN*)psn;
            if (pnm->wVKey == VK_SPACE)
            {
                if (!g_restrict.fAdvanced)
                {
                    pAdv->pTO->ToggleItem((HTREEITEM)SendMessage(pAdv->hwndTree, TVM_GETNEXTITEM, TVGN_CARET, NULL));
                    ENABLEAPPLY(pAdv->hDlg);
                    pAdv->fChanged = TRUE;

                    // Return TRUE so that the treeview swallows the space key.  Otherwise
                    // it tries to search for an element starting with a space and beeps.
                    SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, TRUE);
                }
            }
            break;
        }

        case NM_CLICK:
        case NM_DBLCLK:
        {   // is this click in our tree?
            if ( psn->idFrom == IDC_ADVANCEDTREE )
            {   // yes...
                TV_HITTESTINFO ht;

                GetCursorPos( &ht.pt );                         // get where we were hit
                ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

                // retrieve the item hit
                if (!g_restrict.fAdvanced)
                {
                    pAdv->pTO->ToggleItem(TreeView_HitTest( pAdv->hwndTree, &ht));
                    ENABLEAPPLY(pAdv->hDlg);
                    pAdv->fChanged = TRUE;
                }
            }
        }
        break;

        case PSN_QUERYCANCEL:
        case PSN_KILLACTIVE:
        case PSN_RESET:
            SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_APPLY:
        {
            if (pAdv->fChanged)
            {
                pAdv->pTO->WalkTree( WALK_TREE_SAVE );

                //  Now see if the user changed the "Show Internet Explorer on the Desktop"
                //  setting.
                if (pAdv->fShowIEOnDesktop != IsShowIEOnDesktopEnabled())
                {
                    pAdv->fShowIEOnDesktop = !pAdv->fShowIEOnDesktop;
                    
                    //  They did, so now see if it's integrated shell or not.
                    ShowIEOnDesktop(pAdv->fShowIEOnDesktop);

                    //  Now refresh the desktop
                    SHITEMID mkid = {0};
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST | SHCNF_FLUSHNOWAIT, &mkid, NULL);
                }

                InternetSetOption( NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
                UpdateAllWindows();
                pAdv->fChanged = FALSE;
            }
        }
        break;

    }
}

//
// AdvancedDlgProc
//
// SubDialogs:
//    Temporary Internet Files (cache)
//
// History:
//
// 6/12/96    t-gpease    created
// 5/27/97    t-ashlm     rewrote
//
INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADVANCEDPAGE pAdv;

    if (uMsg == WM_INITDIALOG)
        return AdvancedDlgInit(hDlg);
    else
         pAdv = (LPADVANCEDPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pAdv)
        return FALSE;

    switch (uMsg)
    {

        case WM_NOTIFY:
            AdvancedDlgOnNotify(pAdv, (LPNMHDR)lParam);
            return TRUE;
            break;

        case WM_COMMAND:
            AdvancedDlgOnCommand(pAdv, LOWORD(wParam), HIWORD(wParam));
            return TRUE;
            break;

        case WM_HELP:                   // F1
        {
            LPHELPINFO lphelpinfo;
            lphelpinfo = (LPHELPINFO)lParam;

            if (lphelpinfo->iCtrlId != IDC_ADVANCEDTREE)
            {
                ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                             HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);

            }
            else
            {
                    HTREEITEM hItem;
                //Is this help invoked throught F1 key
                if (GetAsyncKeyState(VK_F1) < 0)
                {
                    // Yes. WE need to give help for the currently selected item
                    hItem = TreeView_GetSelection(pAdv->hwndTree);
                }
                else
                {
                    //No, We need to give help for the item at the cursor position
                    TV_HITTESTINFO ht;
                    ht.pt =((LPHELPINFO)lParam)->MousePos;
                    ScreenToClient(pAdv->hwndTree, &ht.pt); // Translate it to our window
                    hItem = TreeView_HitTest(pAdv->hwndTree, &ht);
                }

                if (FAILED(pAdv->pTO->ShowHelp(hItem, HELP_WM_HELP)))
                {
                    ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
                }
            }
            break;
        }

        case WM_CONTEXTMENU:        // right mouse click
        {
            TV_HITTESTINFO ht;

            GetCursorPos( &ht.pt );                         // get where we were hit
            ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

            // retrieve the item hit
            if (FAILED(pAdv->pTO->ShowHelp(TreeView_HitTest( pAdv->hwndTree, &ht),HELP_CONTEXTMENU)))
            {
                ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break;
        }
        case WM_DESTROY:
            // destroying this deliberately flushes its update (see WM_DESTROY in the UpdateWndProc);
#ifndef UNIX
            // Should only be destroyed in Process Detach.
            if (g_hwndUpdate)
                DestroyWindow(g_hwndUpdate);
#endif

            // free the tree
            if (pAdv->pTO)
            {
                pAdv->pTO->WalkTree( WALK_TREE_DELETE );
                pAdv->pTO->Release();
                pAdv->pTO=NULL;
            }

            // free local memory
            ASSERT(pAdv);
            LocalFree(pAdv);

            // make sure we don't re-enter
            SetWindowLongPtr( hDlg, DWLP_USER, (LONG)NULL );
            CoUninitialize();
            break;

    } // switch

    return FALSE; // not handled

} // AdvancedDlgProc


//////////////////////////////////////////////
//
// Buttons on bottom
//
////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCOLORSINFO {
    HWND     hDlg;
    BOOL     fUseWindowsDefaults;
    COLORREF colorWindowText;
    COLORREF colorWindowBackground;
    COLORREF colorLinkViewed;
    COLORREF colorLinkNotViewed;
    COLORREF colorLinkHover;
    BOOL     fUseHoverColor;
} COLORSINFO, *LPCOLORSINFO;

VOID Color_DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis, COLORREF the_color )
{
    SIZE thin   = { GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER) };
    RECT rc     = lpdis->rcItem;
    HDC hdc     = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) && !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    // Draw any caption
    TCHAR szCaption[80];
    int cxButton = 23*(rc.bottom - rc.top)/12;

    if (GetWindowText(lpdis->hwndItem, szCaption, ARRAYSIZE(szCaption)))
    {
        COLORREF crText;

        RECT rcText = rc;
        rcText.right -= cxButton;

        int nOldMode = SetBkMode(hdc, TRANSPARENT);

        if (lpdis->itemState & ODS_DISABLED)
        {
            // Draw disabled text using the embossed look
            crText = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
            RECT rcOffset = rcText;
            OffsetRect(&rcOffset, 1, 1);
            DrawText(hdc, szCaption, -1, &rcOffset, DT_VCENTER|DT_SINGLELINE);
            SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        }
        else
        {
            crText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }
        DrawText(hdc, szCaption, -1, &rcText, DT_VCENTER|DT_SINGLELINE);
        SetTextColor(hdc, crText);
        SetBkMode(hdc, nOldMode);
    }
    
    // Draw the button portion
    rc.left = rc.right - cxButton;

    if (lpdis->itemState & ODS_SELECTED)
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        OffsetRect(&rc, 1, 1);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }

    // color sample
    if ( !(lpdis->itemState & ODS_DISABLED) )
    {
        HBRUSH hBrush;

        InflateRect(&rc, -2 * thin.cx, -2 * thin.cy);
        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_BTNTEXT));
        InflateRect(&rc, -thin.cx, -thin.cy);

        hBrush = CreateSolidBrush( the_color );
        FillRect(hdc, &rc, hBrush);
        DeleteObject(hBrush);
    }
}

COLORREF g_CustomColors[16] = { 0 };

// ChooseColorW is yet implemented in comdlg32.dll
BOOL UseColorPicker( HWND hWnd,  COLORREF *the_color, int extra_flags )
{
    // Make a local copy of the custom colors so they are not saved if the 
    // color picker dialog is cancelled
    COLORREF customColors[16];
    memcpy(customColors, g_CustomColors, sizeof(customColors));

    CHOOSECOLORA cc;

    cc.lStructSize      = sizeof(cc);
    cc.hwndOwner        = hWnd;
    cc.hInstance        = NULL;
    cc.rgbResult        = (DWORD) *the_color;
    cc.lpCustColors     = customColors;
    cc.Flags            = CC_RGBINIT | extra_flags;
    cc.lCustData        = (DWORD) NULL;
    cc.lpfnHook         = NULL;
    cc.lpTemplateName   = NULL;

    if (ChooseColorA(&cc))
    {
        *the_color = cc.rgbResult;
        memcpy(g_CustomColors, customColors, sizeof(g_CustomColors));

        InvalidateRect( hWnd, NULL, FALSE );
        return TRUE;
    }
    TraceMsg(TF_GENERAL, "\nChooseColor() return 0\n");

    return FALSE;
}


VOID AppearanceDimFields( HWND hDlg )
{
    // reverse the function of the check.... if CHECKED turn off the color
    // selectors.
    BOOL setting = !IsDlgButtonChecked( hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX ) && !g_restrict.fColors;

    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_HOVER),
                 IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX) && !g_restrict.fLinks);
}

BOOL General_DrawItem(HWND hDlg, WPARAM wParam, LPARAM lParam, LPCOLORSINFO pci)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_GENERAL_APPEARANCE_COLOR_TEXT:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorWindowText);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorWindowBackground);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_LINKS:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkNotViewed);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkViewed);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_HOVER:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkHover);
            return TRUE;
    }
    return FALSE;
}


INT_PTR CALLBACK ColorsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCOLORSINFO pci = (LPCOLORSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            DWORD cb = sizeof(DWORD);
            HUSKEY huskey;

            pci = (LPCOLORSINFO)LocalAlloc(LPTR, sizeof(COLORSINFO));
            if (!pci)
            {
                EndDialog(hDlg, IDCANCEL);
                return FALSE;
            }

            // tell dialog where to get info
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pci);

            // save the handle to the page
            pci->hDlg = hDlg;

            // set default values
            pci->fUseWindowsDefaults       = TRUE;
            pci->colorWindowText           = RGB(0,0,0);
            pci->colorWindowBackground     = RGB(192,192,192);
            pci->colorLinkViewed           = RGB(0, 128, 128);
            pci->colorLinkNotViewed        = RGB(0, 0, 255);
            pci->colorLinkHover            = RGB(255, 0, 0);
            pci->fUseHoverColor            = TRUE;

            if (SHRegOpenUSKey(REGSTR_PATH_IEXPLORER,
                               KEY_READ|KEY_WRITE,    // samDesired
                               NULL,    // hUSKeyRelative
                               &huskey,
                               FALSE) == ERROR_SUCCESS)
            {
                HUSKEY huskeySub;

                if (SHRegOpenUSKey(REGSTR_KEY_MAIN,
                                   KEY_READ|KEY_WRITE,
                                   huskey,
                                   &huskeySub,
                                   FALSE) == ERROR_SUCCESS)
                {
                    pci->fUseWindowsDefaults       = RegGetBooleanString(huskeySub,
                        REGSTR_VAL_USEDLGCOLORS, pci->fUseWindowsDefaults);

                    SHRegCloseUSKey(huskeySub);
                }

                if (SHRegOpenUSKey(REGSTR_KEY_IE_SETTINGS,
                                   KEY_READ|KEY_WRITE,
                                   huskey,
                                   &huskeySub,
                                   FALSE) == ERROR_SUCCESS)
                {
                    pci->colorWindowText           = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_TEXTCOLOR, pci->colorWindowText);

                    pci->colorWindowBackground     = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_BACKGROUNDCOLOR, pci->colorWindowBackground);

                    pci->colorLinkViewed           = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLORVISITED, pci->colorLinkViewed);

                    pci->colorLinkNotViewed        = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLOR, pci->colorLinkNotViewed);

                    pci->colorLinkHover            = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLORHOVER, pci->colorLinkHover);

                    pci->fUseHoverColor            = RegGetBooleanString(huskeySub,
                        REGSTR_VAL_USEHOVERCOLOR, pci->fUseHoverColor);

                    SHRegCloseUSKey(huskeySub);
                }
                SHRegCloseUSKey(huskey);
            }

            cb = sizeof(g_CustomColors);
            SHRegGetUSValue(REGSTR_PATH_IE_SETTINGS, REGSTR_VAL_IE_CUSTOMCOLORS, NULL, (LPBYTE)&g_CustomColors,
                            &cb, FALSE, NULL, NULL);

            //
            // select appropriate dropdown item here for underline links
            //

            CheckDlgButton(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX, pci->fUseWindowsDefaults);
            CheckDlgButton(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX, pci->fUseHoverColor);

            AppearanceDimFields(hDlg);

            if (g_restrict.fLinks)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_LINKS), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX), FALSE);
            }

            if (g_restrict.fColors)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX), FALSE);
            }

            return TRUE;
        }

        case WM_DRAWITEM:
            return General_DrawItem(hDlg, wParam, lParam, pci);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    HUSKEY huskey;
                    if (SHRegOpenUSKey(REGSTR_PATH_IEXPLORER,
                                       KEY_WRITE,    // samDesired
                                       NULL,    // hUSKeyRelative
                                       &huskey,
                                       FALSE) == ERROR_SUCCESS)
                    {
                        HUSKEY huskeySub;

                        if (SHRegOpenUSKey(REGSTR_KEY_MAIN,
                                           KEY_WRITE,
                                           huskey,
                                           &huskeySub,
                                           FALSE) == ERROR_SUCCESS)
                        {
                            pci->fUseWindowsDefaults = RegSetBooleanString(huskeySub,
                                REGSTR_VAL_USEDLGCOLORS, pci->fUseWindowsDefaults);

                            SHRegCloseUSKey(huskeySub);
                        }

                        if (SHRegOpenUSKey(REGSTR_KEY_IE_SETTINGS,
                                           KEY_WRITE,
                                           huskey,
                                           &huskeySub,
                                           FALSE) == ERROR_SUCCESS)
                        {
                            pci->colorWindowText           = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_TEXTCOLOR, pci->colorWindowText);

                            pci->colorWindowBackground     = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_BACKGROUNDCOLOR, pci->colorWindowBackground);

                            pci->colorLinkViewed           = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLORVISITED, pci->colorLinkViewed);

                            pci->colorLinkNotViewed        = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLOR, pci->colorLinkNotViewed);

                            pci->colorLinkHover            = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLORHOVER, pci->colorLinkHover);

                            pci->fUseHoverColor            = RegSetBooleanString(huskeySub,
                                REGSTR_VAL_USEHOVERCOLOR, pci->fUseHoverColor);

                            SHRegCloseUSKey(huskeySub);
                        }
                        SHRegCloseUSKey(huskey);
                    }


                    // custom colors
                    SHRegSetUSValue(REGSTR_PATH_IE_SETTINGS, REGSTR_VAL_IE_CUSTOMCOLORS, REGSTR_VAL_IE_CUSTOMCOLORS_TYPE, (LPBYTE)&g_CustomColors,
                                    sizeof(g_CustomColors), SHREGSET_FORCE_HKCU);

                    // refresh the browser
                    UpdateAllWindows();

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        pci->fUseWindowsDefaults =
                            IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX);
                        AppearanceDimFields(hDlg);
                    }
                    break;


                case IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        pci->fUseHoverColor =
                            IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX);
                        AppearanceDimFields(hDlg);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_TEXT:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorWindowText, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorWindowBackground, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_LINKS:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkNotViewed, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkViewed, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_HOVER:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkHover, CC_SOLIDCOLOR);
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pci);
            if (pci)
            {
                LocalFree(pci);
            }

            break;
    }
    return FALSE;
}

typedef struct tagACCESSIBILITYINFO
{
    HWND hDlg;
    BOOL fMyColors;
    BOOL fMyFontStyle;
    BOOL fMyFontSize;
    BOOL fMyStyleSheet;
    TCHAR szStyleSheetPath[MAX_PATH];
} ACCESSIBILITYINFO, *LPACCESSIBILITYINFO;

INT_PTR CALLBACK AccessibilityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPACCESSIBILITYINFO pai = (LPACCESSIBILITYINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HKEY hkey;
            DWORD cb;

            pai = (LPACCESSIBILITYINFO)LocalAlloc(LPTR, sizeof(ACCESSIBILITYINFO));
            if (!pai)
            {
                EndDialog(hDlg, IDCANCEL);
                return FALSE;
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pai);
            pai->hDlg = hDlg;

            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               TEXT("Software\\Microsoft\\Internet Explorer\\Settings"),
                               0, NULL, 0,
                               KEY_READ,
                               NULL,
                               &hkey,
                               NULL) == ERROR_SUCCESS)
            {

                cb = sizeof(pai->fMyColors);
                RegQueryValueEx(hkey, TEXT("Always Use My Colors"), NULL, NULL, (LPBYTE)&(pai->fMyColors), &cb);

                cb = sizeof(pai->fMyFontStyle);
                RegQueryValueEx(hkey, TEXT("Always Use My Font Face"), NULL, NULL, (LPBYTE)&(pai->fMyFontStyle),&cb);

                cb = sizeof(pai->fMyFontSize);
                RegQueryValueEx(hkey, TEXT("Always Use My Font Size"), NULL, NULL, (LPBYTE)&(pai->fMyFontSize),&cb);

                RegCloseKey(hkey);

            }
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                             TEXT("Software\\Microsoft\\Internet Explorer\\Styles"),
                             0, NULL, 0,
                             KEY_READ,
                             NULL,
                             &hkey,
                             NULL) == ERROR_SUCCESS)
            {
                cb = sizeof(pai->fMyStyleSheet);
                RegQueryValueEx(hkey, TEXT("Use My Stylesheet"), NULL, NULL, (LPBYTE)&(pai->fMyStyleSheet),&cb);

                cb = sizeof(pai->szStyleSheetPath);
                RegQueryValueEx(hkey, TEXT("User Stylesheet"), NULL, NULL, (LPBYTE)&(pai->szStyleSheetPath), &cb);
                RegCloseKey(hkey);
            }

            CheckDlgButton(hDlg, IDC_CHECK_COLOR, pai->fMyColors);
            CheckDlgButton(hDlg, IDC_CHECK_FONT_STYLE, pai->fMyFontStyle);
            CheckDlgButton(hDlg, IDC_CHECK_FONT_SIZE, pai->fMyFontSize);
            CheckDlgButton(hDlg, IDC_CHECK_USE_MY_STYLESHEET, pai->fMyStyleSheet);
            SetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, pai->szStyleSheetPath);
            SHAutoComplete(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), SHACF_DEFAULT);

            if (!pai->fMyStyleSheet || g_restrict.fAccessibility)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STYLESHEET), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STYLESHEET_BROWSE), FALSE);
            }

            if (g_restrict.fAccessibility)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_COLOR), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FONT_STYLE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FONT_SIZE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_USE_MY_STYLESHEET), FALSE);
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    HKEY hkey;

                    GetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, pai->szStyleSheetPath, sizeof(pai->szStyleSheetPath));
                    if (!PathFileExists(pai->szStyleSheetPath) && IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET))
                    {
                        MLShellMessageBox(hDlg, MAKEINTRESOURCEW(IDS_FILENOTFOUND), NULL, MB_ICONHAND|MB_OK);
                        break;
                    }

                    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Settings"),0, KEY_WRITE, &hkey) == ERROR_SUCCESS)
                    {
                        DWORD cb;

                        cb = sizeof(pai->fMyColors);
                        pai->fMyColors = IsDlgButtonChecked(hDlg, IDC_CHECK_COLOR);
                        RegSetValueEx(hkey, TEXT("Always Use My Colors"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyColors), cb);

                        cb = sizeof(pai->fMyFontStyle);
                        pai->fMyFontStyle = IsDlgButtonChecked(hDlg, IDC_CHECK_FONT_STYLE);
                        RegSetValueEx(hkey, TEXT("Always Use My Font Face"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyFontStyle), cb);

                        cb = sizeof(pai->fMyFontSize);
                        pai->fMyFontSize = IsDlgButtonChecked(hDlg, IDC_CHECK_FONT_SIZE);
                        RegSetValueEx(hkey, TEXT("Always Use My Font Size"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyFontSize),cb);

                        RegCloseKey(hkey);
                    }

                    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Styles"), 0, KEY_WRITE, &hkey) == ERROR_SUCCESS)
                    {
                        DWORD cb;

#ifndef UNIX
                        cb = sizeof(pai->szStyleSheetPath);
#else
                        // We don't know if this is exactly what we need to do, so we ifdef it.
                        cb = (_tcslen(pai->szStyleSheetPath) + 1) * sizeof(TCHAR);
#endif
                        RegSetValueEx(hkey, TEXT("User Stylesheet"), NULL, REG_SZ, (LPBYTE)&(pai->szStyleSheetPath),cb);

                        cb = sizeof(pai->fMyStyleSheet);
                        pai->fMyStyleSheet = IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET);
                        RegSetValueEx(hkey, TEXT("Use My Stylesheet"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyStyleSheet),cb);

                        RegCloseKey(hkey);
                    }

                    UpdateAllWindows();     // refresh the browser

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_CHECK_USE_MY_STYLESHEET:
                {
                    DWORD fChecked;

                    fChecked = IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET);
                    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STYLESHEET), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_STYLESHEET_BROWSE), fChecked);
                    EnableWindow(GetDlgItem(hDlg,IDOK), IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET) ? (GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET)) ? TRUE:FALSE) : TRUE);
                    break;
                }

                case IDC_EDIT_STYLESHEET:
                    switch(HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            EnableWindow(GetDlgItem(hDlg,IDOK), IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET) ? (GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET)) ? TRUE:FALSE) : TRUE);
                            break;
                    }
                    break;


                case IDC_STYLESHEET_BROWSE:
                {
                    TCHAR szFilenameBrowse[MAX_PATH];
                    int ret;
                    TCHAR szExt[MAX_PATH];
                    TCHAR szFilter[MAX_PATH];

                    szFilenameBrowse[0] = 0;
                    // why is IDS_STYLESHEET_EXT in shdoclc.rc?
                    MLLoadString(IDS_STYLESHEET_EXT, szExt, ARRAYSIZE(szExt));
                    int cchFilter = MLLoadShellLangString(IDS_STYLESHEET_FILTER, szFilter, ARRAYSIZE(szFilter)-1);

                    // Make sure we have a double null termination on the filter
                    szFilter[cchFilter + 1] = 0;

                    ret = _AorW_GetFileNameFromBrowse(hDlg, szFilenameBrowse, ARRAYSIZE(szFilenameBrowse), NULL, szExt,
                        szFilter, NULL);

                    if (ret > 0)
                    {
                        SetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, szFilenameBrowse);
                    }
                    break;
                }

                default:
                    return FALSE;
            }
            return TRUE;
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pai);
            if (pai)
            {
                LocalFree(pai);
            }
            break;
    }
    return FALSE;
}


#define TEMP_SMALL_BUF_SZ  256
inline BOOL IsNotResource(LPCWSTR pszItem)
{
    return (HIWORD(pszItem) != 0);
}

BOOL WINAPI _AorW_GetFileNameFromBrowse
(
    HWND hwnd,
    LPWSTR pszFilePath,     // IN OUT
    UINT cchFilePath,
    LPCWSTR pszWorkingDir,  //IN OPTIONAL
    LPCWSTR pszDefExt,      //IN OPTIONAL
    LPCWSTR pszFilters,     //IN OPTIONAL
    LPCWSTR pszTitle        //IN OPTIONAL
)
{
    BOOL bResult;

#ifndef UNIX
    // Determine which version of NT or Windows we're running on
    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    BOOL fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);

    if (fRunningOnNT)
    {
#endif
        bResult = GetFileNameFromBrowse(hwnd,
                                    pszFilePath,
                                    cchFilePath,
                                    pszWorkingDir,
                                    pszDefExt,
                                    pszFilters,
                                    pszTitle);
#ifndef UNIX
    }
    else
    {
        // Thunk to ansi
        CHAR szFilters[TEMP_SMALL_BUF_SZ*2];
        CHAR szPath[MAX_PATH];
        CHAR szDir[MAX_PATH];
        CHAR szExt[TEMP_SMALL_BUF_SZ];
        CHAR szTitle[TEMP_SMALL_BUF_SZ];
 
        // Always move pszFilePath stuff to szPath buffer. Should never be a resourceid.
        SHUnicodeToAnsi(pszFilePath, szPath, ARRAYSIZE(szPath));

        if (IsNotResource(pszWorkingDir)) 
        {
            SHUnicodeToAnsi(pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCWSTR)szDir;
        }
        if (IsNotResource(pszDefExt))
        {
            SHUnicodeToAnsi(pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCWSTR)szExt;
        }
        if (IsNotResource(pszFilters))
        {
            int nIndex = 1;

            // Find the double terminator
            while (pszFilters[nIndex] || pszFilters[nIndex-1])
                nIndex++;

            // nIndex+1 looks like bunk unless it goes past the terminator
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, szFilters, ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCWSTR)szFilters;
        }
        if (IsNotResource(pszTitle))
        {
            SHUnicodeToAnsi(pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCWSTR)szTitle;
        }

        bResult = GetFileNameFromBrowse(hwnd, (LPWSTR)szPath, ARRAYSIZE(szPath), pszWorkingDir, pszDefExt, pszFilters, pszTitle);

        SHAnsiToUnicode(szPath, pszFilePath, cchFilePath);
    }
#endif

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_
EXTERN_C PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\cachecpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************
//
//      CACHECPL.H - header file for cachecpl
//
//      HISTORY:
//      
//      4/6/98      v-sriran         Moved some definitions from cachecpl.cpp
//                                   to this file, so that it can be easier
//                                   to make unix specific changes to cachecpl.
//

#ifndef _CACHECPL_H_
#define _CACHECPL_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// private structures for cachecpl
//
typedef struct {
    // hold our dialog handle
    HWND hDlg;

    // hold dialog item handles
    HWND hwndTrack;

    // data
    TCHAR szHistoryLocation[MAX_PATH+1];
    INT  iHistoryNumPlaces;
    UINT uiCacheQuota;
    UINT uiDiskSpaceTotal;
    WORD iCachePercent;
    TCHAR szCacheLocation[MAX_PATH+1];
    TCHAR szNewCacheLocation[MAX_PATH+1];
    INT  iCacheUpdFrequency;
    INT  iHistoryExpireDays;

    // something changed
    BOOL bChanged;
    BOOL bChangedLocation;

} TEMPDLG, *LPTEMPDLG;

#define CONTENT 0

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _CACHECPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//              registry access, etc.
//

//  HISTORY:
//  
//  12/07/94    jeremys        Borrowed from WNET common library
//

#include "inetcplp.h"
#define DECL_CRTFREE
#include <crtfree.h>

BOOL BUFFER::Alloc( UINT cbBuffer )
{
    _lpBuffer = (LPTSTR)::GlobalAlloc(GPTR,cbBuffer);
    if (_lpBuffer != NULL) {
        _cb = cbBuffer;
        return TRUE;
    }
    return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
    LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
        GMEM_MOVEABLE | GMEM_ZEROINIT);
    if (lpNew == NULL)
        return FALSE;

    _lpBuffer = (LPTSTR)lpNew;
    _cb = cbNew;
    return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
    _lpBuffer( NULL )
{
    if (cbInitial)
        Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
    if (_lpBuffer != NULL) {
        GlobalFree((HGLOBAL) _lpBuffer);
        _lpBuffer = NULL;
    }
}

BOOL BUFFER::Resize( UINT cbNew )
{
    BOOL fSuccess;

    if (QuerySize() == 0)
        fSuccess = Alloc( cbNew );
    else {
        fSuccess = Realloc( cbNew );
    }
    if (fSuccess)
        _cb = cbNew;
    return fSuccess;
}

RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey, REGSAM regsam)
{
    _error = RegCreateKeyEx(hkey, pszSubKey, 0, NULL, 0, regsam, NULL, &_hkey, NULL);
    if (_error) {
        bhkeyValid = FALSE;
    }
    else {
        bhkeyValid = TRUE;
    }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
                    (LPBYTE)string, (lstrlen(string)+1)*sizeof(TCHAR));
    }
    return _error;
}

long RegEntry::SetValue(const TCHAR *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
                    (LPBYTE)&dwNumber, sizeof(dwNumber));
    }
    return _error;
}

long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (bhkeyValid) {
        _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
    }
    return _error;
}


TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length)
{
    DWORD     dwType;   
    
    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
                    &length);
    }
    if (_error) {
        *string = '\0';
         return NULL;
    }

    return string;
}

long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
     DWORD     dwType;  
     long    dwNumber = 0L;
     DWORD    dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                    &dwSize);
    }
    if (_error)
        dwNumber = dwDefault;
    
    return dwNumber;
}

long RegEntry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY    _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKeyEx ( _hkey,
                                pszSubKeyName,
                                0,
                                KEY_READ|KEY_WRITE,
                                &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

    return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
        _error = RegFlushKey(_hkey);
    }
    return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new TCHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAccessibleWrapper implementation
//
//////////////////////////////////////////////////////////////////////////////



CAccessibleWrapper::CAccessibleWrapper( IAccessible * pAcc )
    : m_ref( 1 ),
      m_pAcc( pAcc ),
      m_pEnumVar( NULL ),
      m_pOleWin( NULL )
{
    m_pAcc->AddRef();
}

CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
    if( m_pEnumVar )
        m_pEnumVar->Release();
    if( m_pOleWin )
        m_pOleWin->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr;
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else if( riid == IID_IEnumVARIANT )
    {
        // Get the IEnumVariant from the object we are sub-classing so we can delegate
        // calls.
        if( ! m_pEnumVar )
        {
            hr = m_pAcc->QueryInterface( IID_IEnumVARIANT, (void **) & m_pEnumVar );
            if( FAILED( hr ) )
            {
                m_pEnumVar = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if( ! m_pEnumVar )
                return E_NOINTERFACE;
        }

        *ppv = (IEnumVARIANT *) this;
    }
    else if( riid == IID_IOleWindow )
    {
        // Get the IOleWindow from the object we are sub-classing so we can delegate
        // calls.
        if( ! m_pOleWin )
        {
            hr = m_pAcc->QueryInterface( IID_IOleWindow, (void **) & m_pOleWin );
            if( FAILED( hr ) )
            {
                m_pOleWin = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if( ! m_pOleWin )
                return E_NOINTERFACE;
        }

        *ppv = (IOleWindow*) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return ++m_ref;
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ULONG ulRet = --m_ref;

    if( ulRet == 0 )
        delete this;

    return ulRet;
}


// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}


// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    return m_pAcc->get_accName(varChild, pszName);
}



STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    return m_pAcc->get_accValue(varChild, pszValue);
}


STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    return m_pAcc->get_accDescription(varChild, pszDescription);
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}


// IEnumVARIANT
// - pass all through m_pEnumVar

STDMETHODIMP  CAccessibleWrapper::Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched)
{
    return m_pEnumVar->Next(celt, rgvar, pceltFetched);
}


STDMETHODIMP  CAccessibleWrapper::Skip(ULONG celt)
{
    return m_pEnumVar->Skip(celt);
}


STDMETHODIMP  CAccessibleWrapper::Reset()
{
    return m_pEnumVar->Reset();
}


STDMETHODIMP  CAccessibleWrapper::Clone(IEnumVARIANT ** ppenum)
{
    return m_pEnumVar->Clone(ppenum);
}

// IOleWindow
// - pass all through m_pOleWin

STDMETHODIMP  CAccessibleWrapper::GetWindow(HWND* phwnd)
{
    return m_pOleWin->GetWindow(phwnd);
}


STDMETHODIMP  CAccessibleWrapper::ContextSensitiveHelp(BOOL fEnterMode)
{
    return m_pOleWin->ContextSensitiveHelp(fEnterMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\connectn.cpp ===
///////////////////////////////////////////////////////////////////////
//                   Microsoft Windows                               //
//             Copyright(c) Microsoft Corp., 1995                    //
///////////////////////////////////////////////////////////////////////
//
// CONNECTN.C - "Connection" Property Sheet
//
// HISTORY:
//
// 6/22/96  t-gpease    moved to this file
//

#include "inetcplp.h"
#include <inetcpl.h>
#include <rasdlg.h>

#include <mluisupp.h>

HINSTANCE   hInstRNADll = NULL;
DWORD       dwRNARefCount = 0;
BOOL        g_fWin95 = TRUE;
BOOL        g_fMillennium = FALSE;
BOOL        g_fWin2K = FALSE;

static const TCHAR g_szSensPath[]            = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");

// clsids used to jit in features
static const CLSID clsidFeatureICW = {      // {5A8D6EE0-3E18-11D0-821E-444553540000}
    0x5A8D6EE0, 0x3E18, 0x11D0, {0x82, 0x1E, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

static const CLSID clsidFeatureMobile = {   // {3af36230-a269-11d1-b5bf-0000f8051515}
    0x3af36230, 0xa269, 0x11d1, {0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15}};

// RNA api function names
static const CHAR szRasEditPhonebookEntryA[]   = "RasEditPhonebookEntryA";
static const CHAR szRasEditPhonebookEntryW[]   = "RasEditPhonebookEntryW";
static const CHAR szRasEnumEntriesA[]          = "RasEnumEntriesA";
static const CHAR szRasEnumEntriesW[]          = "RasEnumEntriesW";
static const CHAR szRasDeleteEntryA[]          = "RasDeleteEntryA";
static const CHAR szRasDeleteEntryW[]          = "RasDeleteEntryW";
static const CHAR szRasGetEntryDialParamsA[]   = "RasGetEntryDialParamsA";
static const CHAR szRasGetEntryDialParamsW[]   = "RasGetEntryDialParamsW";
static const CHAR szRasSetEntryDialParamsA[]   = "RasSetEntryDialParamsA";
static const CHAR szRasSetEntryDialParamsW[]   = "RasSetEntryDialParamsW";
static const CHAR szRasCreatePhonebookEntryA[] = "RasCreatePhonebookEntryA";
static const CHAR szRasGetEntryPropertiesW[]   = "RasGetEntryPropertiesW";
static const CHAR szRnaActivateEngine[]        = "RnaActivateEngine";
static const CHAR szRnaDeactivateEngine[]      = "RnaDeactivateEngine";
static const CHAR szRnaDeleteEntry[]           = "RnaDeleteConnEntry";

RASEDITPHONEBOOKENTRYA   lpRasEditPhonebookEntryA   = NULL;
RASEDITPHONEBOOKENTRYW   lpRasEditPhonebookEntryW   = NULL;
RASENUMENTRIESA          lpRasEnumEntriesA          = NULL;
RASENUMENTRIESW          lpRasEnumEntriesW          = NULL;
RASDELETEENTRYA          lpRasDeleteEntryA          = NULL;
RASDELETEENTRYW          lpRasDeleteEntryW          = NULL;
RASGETENTRYDIALPARAMSA   lpRasGetEntryDialParamsA   = NULL;
RASGETENTRYDIALPARAMSW   lpRasGetEntryDialParamsW   = NULL;
RASSETENTRYDIALPARAMSA   lpRasSetEntryDialParamsA   = NULL;
RASSETENTRYDIALPARAMSW   lpRasSetEntryDialParamsW   = NULL;
RASCREATEPHONEBOOKENTRYA lpRasCreatePhonebookEntryA = NULL;
RASGETENTRYPROPERTIESW   lpRasGetEntryPropertiesW   = NULL;
RNAACTIVATEENGINE        lpRnaActivateEngine        = NULL;
RNADEACTIVATEENGINE      lpRnaDeactivateEngine      = NULL;
RNADELETEENTRY           lpRnaDeleteEntry           = NULL;

#define NUM_RNAAPI_PROCS        15
APIFCN RasApiList[NUM_RNAAPI_PROCS] = {
    { (PVOID *) &lpRasEditPhonebookEntryA,   szRasEditPhonebookEntryA},
    { (PVOID *) &lpRasEditPhonebookEntryW,   szRasEditPhonebookEntryW},
    { (PVOID *) &lpRasEnumEntriesA,          szRasEnumEntriesA},
    { (PVOID *) &lpRasEnumEntriesW,          szRasEnumEntriesW},
    { (PVOID *) &lpRasGetEntryDialParamsA,   szRasGetEntryDialParamsA},
    { (PVOID *) &lpRasGetEntryDialParamsW,   szRasGetEntryDialParamsW},
    { (PVOID *) &lpRasSetEntryDialParamsA,   szRasSetEntryDialParamsA},
    { (PVOID *) &lpRasSetEntryDialParamsW,   szRasSetEntryDialParamsW},
    { (PVOID *) &lpRasDeleteEntryA,          szRasDeleteEntryA},
    { (PVOID *) &lpRasDeleteEntryW,          szRasDeleteEntryW},
    { (PVOID *) &lpRasCreatePhonebookEntryA, szRasCreatePhonebookEntryA},
    { (PVOID *) &lpRasGetEntryPropertiesW,   szRasGetEntryPropertiesW},
    { (PVOID *) &lpRnaActivateEngine,        szRnaActivateEngine},
    { (PVOID *) &lpRnaDeactivateEngine,      szRnaDeactivateEngine},
    { (PVOID *) &lpRnaDeleteEntry,           szRnaDeleteEntry}
};


//
// Connection dialog needs info
//
typedef struct _conninfo {

    HTREEITEM   hDefault;
    TCHAR       szEntryName[RAS_MaxEntryName+1];

} CONNINFO, *PCONNINFO;

//
// dial dialog needs some info asssociated with its window
//
typedef struct _dialinfo {

    PROXYINFO   proxy;              // manual proxy info
    BOOL        fClickedAutodetect; // did the user actually click autodetect?
    LPTSTR      pszConnectoid;
#ifdef UNIX
    TCHAR       szEntryName[RAS_MaxEntryName+1];
#endif

} DIALINFO, *PDIALINFO;

//
// Private Functions
//

BOOL ConnectionDlgInit(HWND hDlg, PCONNINFO pConn);
BOOL ConnectionDlgOK(HWND hDlg, PCONNINFO pConn);
VOID EnableConnectionControls(HWND hDlg, PCONNINFO pConn, BOOL fSetText);
BOOL LoadRNADll(VOID);
VOID UnloadRNADll(VOID);
DWORD PopulateRasEntries(HWND hDlg, PCONNINFO pConn);
BOOL MakeNewConnectoid(HWND hDlg, PCONNINFO pConn);
BOOL EditConnectoid(HWND hDlg);
VOID FixAutodialSettings(HWND hDlg, PCONNINFO pConn);

INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AdvDialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AdvAutocnfgDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

// Handy stuff for looking at proxy exceptions (from proxysup.cpp)
BOOL RemoveLocalFromExceptionList(IN LPTSTR lpszExceptionList);

extern const TCHAR cszLocalString[];

// defines for tree view image list
#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define CONN_BITMAPS    2
#define IMAGE_LAN       0
#define IMAGE_MODEM     1

void GetConnKey(LPTSTR pszConn, LPTSTR pszBuffer, int iBuffLen)
{
    if(NULL == pszConn || 0 == *pszConn) {
        // use lan reg location
        StrCpyN(pszBuffer, REGSTR_PATH_INTERNET_LAN_SETTINGS, iBuffLen);
    } else {
        // use connectoid reg location
        wnsprintf(pszBuffer, iBuffLen, TEXT("%s\\Profile\\%s"), REGSTR_PATH_REMOTEACCESS, pszConn);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// JitFeature - decide if a feature is present, not present but
//              jitable, or not present and not jitable.  Actually JIT it
//              in if requested
//
/////////////////////////////////////////////////////////////////////////////
#define JIT_PRESENT         0           // Installed
#define JIT_AVAILABLE       1           // Can be JIT'ed
#define JIT_NOT_AVAILABLE   2           // You're in trouble - can't be JIT'ed

DWORD JitFeature(HWND hwnd, REFCLSID clsidFeature, BOOL fCheckOnly)
{
    HRESULT     hr  = REGDB_E_CLASSNOTREG;
    uCLSSPEC    classpec;
    DWORD       dwFlags = 0;

    // figure out struct and flags
    classpec.tyspec = TYSPEC_CLSID;
    classpec.tagged_union.clsid = clsidFeature;

    if(fCheckOnly)
        dwFlags = FIEF_FLAG_PEEK;

    //
    // since we only come to install of JIT features
    // only via a UI code path in inetcpl, we want to
    // simply ignore any previous UI action
    //
    dwFlags |= FIEF_FLAG_FORCE_JITUI;
    // call jit code
    hr = FaultInIEFeature(hwnd, &classpec, NULL, dwFlags);

    if(S_OK == hr) {
        // feature present
        return JIT_PRESENT;
    }

    if(S_FALSE == hr || E_ACCESSDENIED == hr) {
        // jit doesn't know about this feature.  Assume it's present.
        return JIT_PRESENT;
    }

    if(HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) {
        // user didn't want it - may try again sometime, however
        return JIT_AVAILABLE;
    }

    if(fCheckOnly) {
        if(HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED) == hr) {
            // not present but can get it
            return JIT_AVAILABLE;
        }
    }

    //
    // Actually tried to get it but didn't - return not available
    //
    return JIT_NOT_AVAILABLE;
}


/////////////////////////////////////////////////////////////////////////////
//
// RasEnumHelp
//
// Abstract grusome details of getting a correct enumeration of entries 
// from RAS.  Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

class RasEnumHelp
{
private:
    
    //
    // Win2k version of RASENTRYNAMEW struct
    //
    #define W2KRASENTRYNAMEW struct tagW2KRASENTRYNAMEW
    W2KRASENTRYNAMEW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        DWORD dwFlags;
        WCHAR szPhonebookPath[MAX_PATH + 1];
    };
    #define LPW2KRASENTRYNAMEW W2KRASENTRYNAMEW*

    //
    // Possible ways we got info from RAS
    //
    typedef enum {
        ENUM_MULTIBYTE,             // Win9x
        ENUM_UNICODE,               // NT4
        ENUM_WIN2K                  // Win2K
    } ENUM_TYPE;

    //
    // How we got the info
    //
    ENUM_TYPE       _EnumType;     

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASENTRYNAMEA * _preList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    WCHAR           _szCurrentEntryW[RAS_MaxEntryName + 1];


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD   GetError();
    DWORD   GetEntryCount();
    LPWSTR  GetEntryW(DWORD dwEntry);
};



RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;
    OSVERSIONINFO   ver;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    // figure out which kind of enumeration we're doing - start with multibyte
    _EnumType = ENUM_MULTIBYTE;
    dwStructSize = sizeof(RASENTRYNAMEA);

    ver.dwOSVersionInfoSize = sizeof(ver);
    if(GetVersionEx(&ver))
    {
        if(VER_PLATFORM_WIN32_NT == ver.dwPlatformId)
        {
            _EnumType = ENUM_UNICODE;
            dwStructSize = sizeof(RASENTRYNAMEW);

            if(ver.dwMajorVersion >= 5)
            {
                _EnumType = ENUM_WIN2K;
                dwStructSize = sizeof(W2KRASENTRYNAMEW);
            }
        }
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)GlobalAlloc(LMEM_FIXED, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                if(lpRasEnumEntriesA)
                {
                    _dwLastError = lpRasEnumEntriesA(
                                    NULL,
                                    NULL,
                                    (LPRASENTRYNAMEA)_preList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
            else
            {
                if(lpRasEnumEntriesW)
                {
                    _dwLastError = lpRasEnumEntriesW(
                                    NULL,
                                    NULL,
                                    (LPRASENTRYNAMEW)_preList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
       
            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                GlobalFree(_preList);
                _preList = (LPRASENTRYNAMEA)GlobalAlloc(LMEM_FIXED, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        GlobalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        GlobalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(
    DWORD dwEntryNum
    )
{
    LPWSTR  pwszName = NULL;

    if(dwEntryNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        MultiByteToWideChar(CP_ACP, 0, _preList[dwEntryNum].szEntryName,
            -1, _szCurrentEntryW, RAS_MaxEntryName + 1);
        pwszName = _szCurrentEntryW;
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        pwszName = lpTemp[dwEntryNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        pwszName = lpTemp[dwEntryNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           MakeNewConnectoid
//
//        SYNOPSIS:       Launches RNA new connectoid wizard; selects newly
//                                created connectoid (if any) in combo box
//
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFRED)(LPTSTR, LPTSTR, LPRASENTRYDLG);

BOOL MakeNewConnectoid(HWND hDlg, PCONNINFO pConn)
{
    BOOL fRet = FALSE, fDone = FALSE;
    DWORD dwRes = 0;

    ASSERT(lpRasCreatePhonebookEntryA);

    if(FALSE == g_fWin95) {
        // on NT, use RasEntryDlg so we know who we created and can edit
        // proxy info for that connectoid
        HMODULE hRasDlg = LoadLibrary(TEXT("rasdlg.dll"));
        if(hRasDlg) {
#ifdef UNICODE
            PFRED pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgW");
#else
            PFRED pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgA");
#endif
            if(pfred) {
                RASENTRYDLG info;

                memset(&info, 0, sizeof(RASENTRYDLG));
                info.dwSize = sizeof(RASENTRYDLG);
                info.hwndOwner = hDlg;
                info.dwFlags = RASEDFLAG_NewEntry;

                dwRes = (pfred)(NULL, NULL, &info);
                if(dwRes) {
                    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP), hDlg,
                        DialupDlgProc, (LPARAM)info.szEntry);
                    dwRes = ERROR_SUCCESS;

                    // save name as default
                    lstrcpyn(pConn->szEntryName, info.szEntry, RAS_MaxEntryName);
                } else {
                    dwRes = info.dwError;
                }
                fDone = TRUE;
            }

            FreeLibrary(hRasDlg);
        }
    }

    if(FALSE == fDone) {
        // on win95, show the ui to make new entry
        if(lpRasCreatePhonebookEntryA)
        {
            dwRes = (lpRasCreatePhonebookEntryA)(hDlg,NULL);
        }

        // if we're on millennium, refresh default
        if(g_fMillennium)
        {
            FixAutodialSettings(hDlg, pConn);
        }
    }

    if(ERROR_SUCCESS == dwRes) {
        // make sure dial default is turned on.  If this is NT, default entry
        // is set above to new entry.
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP_NEVER))
        {
            CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP);
        }
        PopulateRasEntries(hDlg, pConn);
        EnableConnectionControls(hDlg, pConn, FALSE);
        fRet = TRUE;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////
//
//        NAME:           PopulateRasEntries
//
//        ENTRY:          hwndDlg - dlg box window handle
//
//        SYNOPSIS:       Fills specified combo box with list of existing RNA
//                                connectoids
//
///////////////////////////////////////////////////////////////////////////

#define DEF_ENTRY_BUF_SIZE      8192

DWORD PopulateRasEntries(HWND hDlg, PCONNINFO pConn)
{
    HWND hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    DWORD i;
    DWORD dwBufSize = 16 * sizeof(RASENTRYNAMEA);
    DWORD dwEntries = 0;
    TVITEM tvi;
    TVINSERTSTRUCT tvins;
    HTREEITEM hFirst = NULL;

    ASSERT(hwndTree);

    // init tvi and tvins
    tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvi.lParam = 0;
    tvins.hInsertAfter = (HTREEITEM)TVI_SORT;
    tvins.hParent = TVI_ROOT;

    // clear list
    TreeView_DeleteAllItems(hwndTree);

    // any old htree is now bogus - we'll get a new one
    pConn->hDefault = NULL;

    // enumerate
    RasEnumHelp reh;

    if(ERROR_SUCCESS == reh.GetError())
    {
        TCHAR szTemp[RAS_MaxEntryName + 64];
        BOOL fDefault, fFoundDefault = FALSE;
        LPTSTR pszEntryName;

        // insert connectoid names from buffer into combo box
        for(i=0; i<reh.GetEntryCount(); i++)
        {
            pszEntryName = reh.GetEntryW(i);
            fDefault = FALSE;

            // if there's only one entry, force it to be the default
            if(1 == dwEntries)
            {
                StrCpyN(pConn->szEntryName, pszEntryName, RAS_MaxEntryName);
            }

            if(*pConn->szEntryName && 0 == StrCmp(pszEntryName, pConn->szEntryName)) {
                // this is the default entry - stick it in the default
                // text control and append (Default) to it
                SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), pConn->szEntryName);
                StrCpyN(szTemp, pszEntryName, RAS_MaxEntryName);
                MLLoadString(IDS_DEFAULT_TEXT, szTemp + lstrlen(szTemp), 64);
                tvi.pszText = szTemp;
                fDefault = TRUE;
                fFoundDefault = TRUE;
            } else {
                tvi.pszText = pszEntryName;
            }
            tvi.iImage = IMAGE_MODEM;
            tvi.iSelectedImage = IMAGE_MODEM;
            tvi.lParam = i;
            tvins.item = tvi;
            HTREEITEM hItem = TreeView_InsertItem(hwndTree, &tvins);
            if(NULL == hFirst)
                hFirst = hItem;
            if(fDefault)
                pConn->hDefault = hItem;
        }

        // if we didn't match our default with a connectoid, kill it
        if(FALSE == fFoundDefault)
        {
            *pConn->szEntryName = 0;
            MLLoadString(IDS_NONE, szTemp, 64);
            SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), szTemp);
        }
    }

    // select default or first entry if there is one
    if(pConn->hDefault)
    {
        TreeView_Select(hwndTree, pConn->hDefault, TVGN_CARET);
    }
    else if(hFirst)
    {
        TreeView_Select(hwndTree, hFirst, TVGN_CARET);
    }

    return reh.GetEntryCount();
}

void PopulateProxyControls(HWND hDlg, LPPROXYINFO pInfo, BOOL fSetText)
{
    BOOL fManual = FALSE, fScript = FALSE, fDisable, fTemp;

    // decide if everything is disabled
    fDisable = IsDlgButtonChecked(hDlg, IDC_DONT_USE_CONNECTION);

    //
    // disable proxy enable check box if proxy restricted
    //
    fTemp = fDisable || g_restrict.fProxy;
    EnableDlgItem(hDlg, IDC_MANUAL, !fTemp);
    if(FALSE == g_restrict.fProxy)
    {
        fManual = !fDisable && pInfo->fEnable;
    }

    //
    // Disable autoconfig if restricted
    //
    fScript = !fDisable && IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);

    fTemp = fDisable || g_restrict.fAutoConfig;
    EnableDlgItem(hDlg, IDC_CONFIGSCRIPT, !fTemp);
    EnableDlgItem(hDlg, IDC_AUTODISCOVER, !fTemp);
    if(fTemp)
    {
        fScript = FALSE;
    }

    // enable config script controls
    EnableDlgItem(hDlg, IDC_CONFIG_ADDR, fScript);
    EnableDlgItem(hDlg, IDC_CONFIGADDR_TX, fScript);
    EnableDlgItem(hDlg, IDC_AUTOCNFG_ADVANCED, fScript);

    // Button is always on and omit local addresses is available if proxy is checked
    EnableDlgItem(hDlg, IDC_PROXY_ADVANCED, fManual);
    EnableDlgItem(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES, fManual);

    // Enable dial controls as necessary
    EnableDlgItem(hDlg, IDC_USER, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_PASSWORD, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_DOMAIN, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_USER, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_PASSWORD, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_DOMAIN, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_RAS_SETTINGS, !fDisable);
    EnableDlgItem(hDlg, IDC_DIAL_ADVANCED, !fDisable && !pInfo->fCustomHandler);

    // settings changed in here are enabled/disabled based on the actual proxy settings
    if(StrChr(pInfo->szProxy, TEXT('=')))
    {
        // different servers for each - disable fields on this dialog
        fManual = FALSE;
        if (fSetText)
        {
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), TEXT(""));
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
        }
    }
    else if (fSetText)
    {
        TCHAR       *pszColon, *pszColon2;
        //Is there a : in the proxy string ?
        pszColon = StrChr(pInfo->szProxy, TEXT(':'));
        if(pszColon)
        {
            //Yes, Find if we have another ':'
            pszColon2 = StrChr(pszColon + 1, TEXT(':'));
            if(pszColon2)
            {
                //Yes, so we have strig like http://itgproxy:80
                pszColon = pszColon2;
                SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                *pszColon = 0;
            }
            else
            {
                //No, We dont have a second ':'

                int ilength =  (int) (pszColon - pInfo->szProxy);
                //Are there atleast two characters  left beyond the first ':'
                if (lstrlen(pInfo->szProxy) - ilength >= 2 )
                {
                    //Yes, Are Those characters equal //
                    if((pInfo->szProxy[++ilength] == TEXT('/')) &&
                        (pInfo->szProxy[++ilength] == TEXT('/')))
                    {
                        //Yes then we have string like http://itgproxy
                        //make the whole thing as the server and make port fiel empty
                       SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
                    }
                    else
                    {
                        //No, so we have string like itgproxy:80.
                        SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                        *pszColon = 0;
                    }
                }
                else
                {
                  //No We dont have atleast two character so lets parse this as server and port
                  // Assuming this strign to be something like itgproxy:8
                  SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                  *pszColon = 0;
                }

            }
        }
        else
        {
            //No we dont have a : so treat the string as just the proxy server.
            //Case itgproxy
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
        }
        SetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), pInfo->szProxy);
    }


    EnableDlgItem(hDlg, IDC_ADDRESS_TEXT,   fManual);
    EnableDlgItem(hDlg, IDC_PORT_TEXT,      fManual);
    EnableDlgItem(hDlg, IDC_PROXY_ADDR,     fManual);
    EnableDlgItem(hDlg, IDC_PROXY_PORT,     fManual);
}

void GetProxyInfo(HWND hDlg, PDIALINFO pDI)
{
    pDI->proxy.fEnable = IsDlgButtonChecked(hDlg, IDC_MANUAL);

    if(NULL == StrChr(pDI->proxy.szProxy, TEXT('=')))
    {
        //
        // not per-protocol, so read edit boxes
        //
        TCHAR szProxy[MAX_URL_STRING];
        TCHAR szPort[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];

        GetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), szProxy, ARRAYSIZE(szProxy) );
        GetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), szPort, ARRAYSIZE(szPort) );

        // if we got a proxy and a port, combine in to one string
        if(*szProxy && *szPort)
            wnsprintf(pDI->proxy.szProxy, ARRAYSIZE(pDI->proxy.szProxy), TEXT("%s:%s"), szProxy, szPort);
        else
            StrCpyN(pDI->proxy.szProxy, szProxy, ARRAYSIZE(pDI->proxy.szProxy));
    }

    //
    // fix manual settings override
    //
    pDI->proxy.fOverrideLocal = IsDlgButtonChecked(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES);

    if(pDI->proxy.fOverrideLocal) {
        RemoveLocalFromExceptionList(pDI->proxy.szOverride);
        if(*pDI->proxy.szOverride)
            wnsprintf(pDI->proxy.szOverride, ARRAYSIZE(pDI->proxy.szOverride), TEXT("%s;%s"), pDI->proxy.szOverride, cszLocalString);
        else
            StrCpyN(pDI->proxy.szOverride, cszLocalString, ARRAYSIZE(pDI->proxy.szOverride));
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       DeleteRasEntry
//
//        SYNOPSIS:   Delete a connectoid
//
//////////////////////////////////////////////////////////////////////
void DeleteRasEntry(LPTSTR pszEntry)
{
    // Use RasDeleteEntryW if possible
    if(lpRasDeleteEntryW)
    {
        (lpRasDeleteEntryW)(NULL, pszEntry);
    }
    else
    {
        CHAR szEntryA[MAX_PATH];
        SHUnicodeToAnsi(pszEntry, szEntryA, ARRAYSIZE(szEntryA));

        // Use RasDeleteEntryA if possible
        if(lpRasDeleteEntryA)
        {
            (lpRasDeleteEntryA)(NULL, szEntryA);
        }
        else
        {
            // no RasDeleteEntry - must by Win95 gold machine.  Use RNA. Ick.
            if( lpRnaActivateEngine &&
                lpRnaDeleteEntry &&
                lpRnaDeactivateEngine &&
                ERROR_SUCCESS == (lpRnaActivateEngine)())
            {
                (lpRnaDeleteEntry)(szEntryA);
                (lpRnaDeactivateEngine)();
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ChangeDefault
//
//        SYNOPSIS:   Change default connectoid to currently selected one
//
//////////////////////////////////////////////////////////////////////
void ChangeDefault(HWND hDlg, PCONNINFO pConn)
{
    TVITEM tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    HTREEITEM hCur;

    memset(&tvi, 0, sizeof(TVITEM));

    // find current selection - if there isn't one, bail
    hCur = TreeView_GetSelection(hwndTree);
    if(NULL == hCur)
        return;

    // remove (default) from current default
    if(pConn->hDefault) {
        tvi.mask = TVIF_HANDLE | TVIF_TEXT;
        tvi.hItem = pConn->hDefault;
        tvi.pszText = pConn->szEntryName;
        tvi.cchTextMax = RAS_MaxEntryName;
        TreeView_SetItem(hwndTree, &tvi);
    }

    // get text for current item
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = hCur;
    tvi.pszText = pConn->szEntryName;
    tvi.cchTextMax = RAS_MaxEntryName;
    TreeView_GetItem(hwndTree, &tvi);

    // fill in default text field
    SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), pConn->szEntryName);

    // add (default) to current selection
    TCHAR szTemp[RAS_MaxEntryName + 64];

    StrCpyN(szTemp, pConn->szEntryName, RAS_MaxEntryName);
    MLLoadString(IDS_DEFAULT_TEXT, szTemp + lstrlen(szTemp), 64);

    // stick it back in the tree
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = hCur;
    tvi.pszText = szTemp;
    tvi.cchTextMax = RAS_MaxEntryName;
    TreeView_SetItem(hwndTree, &tvi);

    // save htree
    pConn->hDefault = hCur;
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ShowConnProps
//
//        SYNOPSIS:   Show properties for selected connection
//
//////////////////////////////////////////////////////////////////////

HTREEITEM GetCurSel(PCONNINFO pConn, HWND hDlg, LPTSTR pszBuffer, int iLen, BOOL *pfChecked)
{
    HWND    hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    TVITEM  tvi;

    tvi.hItem = TreeView_GetSelection(hwndTree);

    if(tvi.hItem) {
        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE;
        tvi.stateMask = TVIS_STATEIMAGEMASK;

        // get test if needed
        if(pszBuffer) {
            tvi.mask |= TVIF_TEXT;
            tvi.pszText = pszBuffer;
            tvi.cchTextMax = iLen;
        }
        TreeView_GetItem(hwndTree, &tvi);

        if(pfChecked)
            *pfChecked = (BOOL)(tvi.state >> 12) - 1;
    }

    // if this is the default connectiod, return name without (default) part
    if(pszBuffer && tvi.hItem == pConn->hDefault) {
        StrCpyN(pszBuffer, pConn->szEntryName, iLen);
    }

    return tvi.hItem;
}

void ShowConnProps(HWND hDlg, PCONNINFO pConn, BOOL fLan)
{
    HTREEITEM   hItem = NULL;
    TCHAR       szEntryName[RAS_MaxEntryName+1];
    BOOL        fChecked = FALSE;

    // if not lan, apply current selections
    if(g_fMillennium && !fLan)
    {
        ConnectionDlgOK(hDlg, pConn);
    }

    // default to lan
    *szEntryName = 0;

    // find item of interest
    if(FALSE == fLan)
        hItem = GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, &fChecked);

    if(hItem || fLan) {
        // show settings
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP), hDlg,
            DialupDlgProc, (LPARAM)szEntryName);
    }

    // if not lan, some settings may have been changed by RAS UI -- refresh
    if(g_fMillennium && !fLan )
    {
        FixAutodialSettings(hDlg, pConn);
    }
}

BOOL GetConnSharingDll(LPTSTR pszPath)
{
    DWORD cb = SIZEOF(TCHAR) * MAX_PATH;
    return SHGetValue(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                TEXT("SharingDLL"), NULL, pszPath, &cb) == ERROR_SUCCESS;
}

BOOL IsConnSharingAvail()
{
    TCHAR szPath[MAX_PATH];
    return GetConnSharingDll(szPath);
}

typedef HRESULT (WINAPI *PFNCONNECTIONSHARING)(HWND hwnd, DWORD dwFlags);

void ShowConnSharing(HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    if (GetConnSharingDll(szPath))
    {
        HMODULE hmod = LoadLibrary(szPath);
        if (hmod)
        {
            PFNCONNECTIONSHARING pfn = (PFNCONNECTIONSHARING)GetProcAddress(hmod, "InternetConnectionSharing");
            if (pfn)
                pfn(hDlg, 0);
            FreeLibrary(hmod);
        }
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ConnectionDlgProc
//
//        SYNOPSIS:   Connection property sheet dialog proc.
//
//////////////////////////////////////////////////////////////////////


INT_PTR CALLBACK ConnectionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    PCONNINFO pConn = (PCONNINFO)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    if (NULL == pConn && uMsg != WM_INITDIALOG)
    {
        return FALSE;
    }

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // build and save conninfo struct
            pConn = new CONNINFO;
            if(NULL == pConn)
                return FALSE;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pConn);
            memset(pConn, 0, sizeof(CONNINFO));

            return ConnectionDlgInit(hDlg, pConn);

        case WM_DESTROY:
        {
            UnloadRNADll();

            // Free the image list used by the connection list
            HWND hwndConnList = GetDlgItem(hDlg, IDC_CONN_LIST);
            HIMAGELIST himl = TreeView_SetImageList(hwndConnList, NULL, TVSIL_NORMAL);
            if (himl)
            {
                ImageList_Destroy(himl);
            }

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)NULL);
            delete pConn;
            return TRUE;
        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *pkey = (TV_KEYDOWN*)lpnm;
                    if(pkey->wVKey == VK_SPACE)
                    {
                        ENABLEAPPLY(hDlg);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // eat the key
                        return TRUE;
                    }
                    break;
                }

                case NM_CLICK:
                case NM_DBLCLK:
                {   // is this click in our tree?
                    if(lpnm->idFrom == IDC_CONN_LIST)
                    {   
                        HWND            hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
                        TV_HITTESTINFO  ht;
                        HTREEITEM       hItem;

                        GetCursorPos(&ht.pt);
                        ScreenToClient(hwndTree, &ht.pt);
                        hItem = TreeView_HitTest(hwndTree, &ht);
                        if(hItem)
                        {
                            TreeView_SelectItem(hwndTree, hItem);

                            // If it's a double click, show settings
                            if(NM_DBLCLK == lpnm->code)
                            {
                                PostMessage(hDlg, WM_COMMAND, IDC_MODEM_SETTINGS, 0);
                            }
                        }
                    }
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    break;
                }

                case TVN_SELCHANGEDA:
                case TVN_SELCHANGEDW:
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    break;

                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                {
                    BOOL fRet = ConnectionDlgOK(hDlg, pConn);
                    SetPropSheetResult(hDlg,!fRet);
                    return !fRet;
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
            switch  (LOWORD(wParam))
            {
                case IDC_LAN_SETTINGS:
                    ShowConnProps(hDlg, pConn, TRUE);
                    break;

                case IDC_CON_SHARING:
                    ShowConnSharing(hDlg);
                    break;

                case IDC_DIALUP_ADD:
                    MakeNewConnectoid(hDlg, pConn);
                    break;

                case IDC_DIALUP_REMOVE:
                {
                    TCHAR   szEntryName[RAS_MaxEntryName+1];

                    if (GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, NULL) &&
                        *szEntryName) {
                        if(IDOK == MsgBox(hDlg, IDS_DELETECONNECTOID, MB_ICONWARNING, MB_OKCANCEL)) {
                            DeleteRasEntry(szEntryName);
                            PopulateRasEntries(hDlg, pConn);

                            // fix controls
                            EnableConnectionControls(hDlg, pConn, FALSE);
                        }
                    }
                    break;
                }


                case IDC_DIALUP:
                case IDC_DIALUP_ON_NONET:
                case IDC_DIALUP_NEVER:

                    // fix radio buttons
                    CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, LOWORD(wParam));

                    // enable/disable other controls appropriately
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_ENABLE_SECURITY:
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_SET_DEFAULT:
                    ChangeDefault(hDlg, pConn);
                    if(GetFocus() == GetDlgItem(hDlg, IDC_SET_DEFAULT))
                    {
                        // focus is currently on the button and it's about to be disabled
                        SetFocus(GetDlgItem(hDlg, IDC_CONN_LIST));
                    }
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_MODEM_SETTINGS:
                    ShowConnProps(hDlg, pConn, FALSE);
                    break;

                case IDC_CONNECTION_WIZARD:
                    TCHAR       szICWReg[MAX_PATH];
                    TCHAR       szICWPath[MAX_PATH + 1];
                    DWORD       cbSize = MAX_PATH, dwType;

                    if (IsOS(OS_WHISTLERORGREATER))
                    {
                        // This is the invocation path for the New Connection Wizard in Whistler
                        StrCpy(szICWPath, TEXT("rundll32.exe netshell.dll,StartNCW"));
                    }
                    else
                    {
                        // Try and get ICW from IOD.  If it fails, try to run
                        // ICW anyway.  We may luck out and get an old one.
                        DWORD dwRes = JitFeature(hDlg, clsidFeatureICW, FALSE);

                        // find path of ICW
                        MLLoadString(IDS_ICW_NAME, szICWPath, MAX_PATH);
                        wnsprintf(szICWReg, ARRAYSIZE(szICWReg), TEXT("%s\\%s"), REGSTR_PATH_APPPATHS, szICWPath);

                        // read app paths key
                        if(ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, szICWReg, NULL, &dwType, szICWPath, &cbSize))
                            break;
                    }

                    // run connection wizard
                    STARTUPINFO si;
                    PROCESS_INFORMATION pi;
                    memset(&si, 0, sizeof(si));
                    si.cb = sizeof(si);

                    if(CreateProcess(NULL, szICWPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
                    {
                        // successfully ran ICW - get rid of this dialog
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                    }
                    break;
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*******************************************************************

NAME:           ConnectionDlgOK

SYNOPSIS:       OK button handler for connection prop page

********************************************************************/

// prototype for IsNetworkAlive()
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

BOOL ConnectionDlgOK(HWND hDlg, PCONNINFO pConn)
{
    DWORD   dwAutodial;

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
    if(ERROR_SUCCESS == re.GetError()) {

        // autodial
        dwAutodial = AUTODIAL_MODE_NEVER;
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP))
        {
            dwAutodial = AUTODIAL_MODE_ALWAYS;
        }
        else if(IsDlgButtonChecked(hDlg, IDC_DIALUP_ON_NONET))
        {
            dwAutodial = AUTODIAL_MODE_NO_NETWORK_PRESENT;

            DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, FALSE);
            if(JIT_PRESENT != dwRes) {
                // user doesn't want MOP, change to dial always.
                dwAutodial = AUTODIAL_MODE_ALWAYS;
            }
            else
            {
                // Call IsNetworkAlive.  This will start sens service
                // and next instance of wininet will use it.
                HINSTANCE hSens;
                ISNETWORKALIVE pfnIsNetworkAlive;
                DWORD dwFlags;

                hSens = LoadLibrary(TEXT("sensapi.dll"));
                if(hSens)
                {
                    pfnIsNetworkAlive = (ISNETWORKALIVE)GetProcAddress(hSens, "IsNetworkAlive");
                    if(pfnIsNetworkAlive)
                    {
                        // Call it.  Don't really care about the result.
                        pfnIsNetworkAlive(&dwFlags);
                    }
                    FreeLibrary(hSens);
                }
            }
        }

        // save autodial mode
        InternetSetOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwAutodial, sizeof(dwAutodial));

        // save default connectoid
        if(*pConn->szEntryName)
        {
            InternetSetOption(NULL, INTERNET_OPTION_AUTODIAL_CONNECTION, pConn->szEntryName, lstrlen(pConn->szEntryName));
        }
    }

    // save security check state on win95
    if(g_fWin95)
    {
        DWORD dwValue = 0;
        if(IsDlgButtonChecked(hDlg, IDC_ENABLE_SECURITY))
        {
            dwValue = 1;
        }
        re.SetValue(REGSTR_VAL_ENABLESECURITYCHECK, dwValue);
    }

    //
    // Have wininet refresh it's connection settings
    //
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    UpdateAllWindows();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           EnableConnectionControls
//
//        SYNOPSIS:       Enables controls appropriately depending on what
//                                checkboxes are checked.
//
/////////////////////////////////////////////////////////////////////////////

VOID EnableConnectionControls(HWND hDlg, PCONNINFO pConn, BOOL fSetText)
{
    TCHAR   szEntryName[RAS_MaxEntryName + 1];
    BOOL    fList = FALSE, fDial = FALSE, fAutodial = FALSE;
    BOOL    fAdd = FALSE, fSettings = FALSE, fLan = TRUE, fSetDefault = TRUE;
    BOOL    fDialDefault = FALSE, fNT4SP3;
    HTREEITEM   hItem;
    int     iCount;

    fNT4SP3 = IsNTSPx(FALSE, 4, 3);

    if(fNT4SP3)
    {
        // no sens stuff on NT4SP3, so make sure on no net isn't picked
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP_ON_NONET))
        {
            CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP);
        }
    }

    //
    // Check out how much stuff is in the tree view and what's selected
    //
    iCount = TreeView_GetCount(GetDlgItem(hDlg, IDC_CONN_LIST));
    hItem = GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, NULL);

    if(dwRNARefCount) {
        // Ras is loaded so enable list control
        fList = TRUE;

        // if anything is selected, turn on settings button
        if(hItem)
        {
            fSettings = TRUE;
            if(hItem == pConn->hDefault)
            {
                fSetDefault = FALSE;
            }
        }

        // Ensure ras is loaded
        if(iCount > 0)
            fDial = TRUE;
    }

    // check to see if dial default is checked
    if(fDial)
        fDialDefault = !IsDlgButtonChecked(hDlg, IDC_DIALUP_NEVER);

    if(fList && lpRasCreatePhonebookEntryA)
        fAdd = TRUE;

    // if dialing restriction is present, make sure user can't do nothing.
    if(g_restrict.fDialing)
        fAdd = fList = fDial = fDialDefault = fAutodial = fSettings = fLan = fSetDefault = FALSE;

    // enable list controls
    EnableDlgItem(hDlg, IDC_CONN_LIST,       fList);
    EnableDlgItem(hDlg, IDC_DIALUP_ADD,      fAdd);
    EnableDlgItem(hDlg, IDC_DIALUP_REMOVE,   fSettings);
    EnableDlgItem(hDlg, IDC_MODEM_SETTINGS,  fSettings);

    // enable lan controls
    EnableDlgItem(hDlg, IDC_LAN_SETTINGS,    fLan);

    // enable default controls
    EnableDlgItem(hDlg, IDC_DIALUP_NEVER,    fDial);
    EnableDlgItem(hDlg, IDC_DIALUP_ON_NONET, fDial && !fNT4SP3);
    EnableDlgItem(hDlg, IDC_DIALUP,          fDial);
    EnableDlgItem(hDlg, IDC_DIAL_DEF_TXT,    fDialDefault);
    EnableDlgItem(hDlg, IDC_DIAL_DEF_ISP,    fDialDefault);
    EnableDlgItem(hDlg, IDC_ENABLE_SECURITY, fDialDefault);
    EnableDlgItem(hDlg, IDC_SET_DEFAULT,     fDialDefault && fSetDefault);

    // if autodialing is disabled (no connectoids) make sure it's not checked
    if(FALSE == fDial)
        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP_NEVER);

    //
    // Fix connection wizard
    //
    if (g_restrict.fConnectionWizard)
    {
        EnableDlgItem(hDlg, IDC_CONNECTION_WIZARD, FALSE);
    }
}

VOID FixAutodialSettings(HWND hDlg, PCONNINFO pConn)
{
    // Find default connectoid
    DWORD dwSize = RAS_MaxEntryName + 1;
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_AUTODIAL_CONNECTION, pConn->szEntryName, &dwSize))
    {
        *pConn->szEntryName = 0;
    }

    // populate connectoids, will do the right thing with the default read above
    PopulateRasEntries(hDlg, pConn);

    // fix autodial radio buttons
    int iSel;
    DWORD dwAutodial;

    dwSize = sizeof(DWORD);
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwAutodial, &dwSize))
    {
        dwAutodial = AUTODIAL_MODE_NEVER;
    }

    switch(dwAutodial)
    {
    case AUTODIAL_MODE_ALWAYS:
        iSel = IDC_DIALUP;
        break;
    case AUTODIAL_MODE_NO_NETWORK_PRESENT:
        iSel = IDC_DIALUP_ON_NONET;
        break;
    default :
        iSel = IDC_DIALUP_NEVER;
        break;
    } /* switch */
    CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, iSel);

    // enable appropriate controls
    EnableConnectionControls(hDlg, pConn, TRUE);
}


BOOL ConnectionDlgInit(HWND hDlg, PCONNINFO pConn)
{
    BOOL        fProxy = FALSE;
    BOOL        fDial = FALSE;
    HIMAGELIST  himl;
    HICON       hIcon;

    // Get platform - we need this as there's no security check on NT.
    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) 
    {
        g_fWin95 = FALSE;

        if(osvi.dwMajorVersion > 4)
        {
            g_fWin2K = TRUE;
        }
    }
    else
    {
        if(osvi.dwMinorVersion >= 90)
        {
            g_fMillennium = TRUE;
        }
    }

    // load ras (success checked later - see dwRNARefCount in EnableConnectionControls
    LoadRNADll();

    // create image list for tree view
    himl = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_COLOR | ILC_MASK, CONN_BITMAPS, 4 );
    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_LAN));
    ImageList_AddIcon(himl, hIcon);
    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_PHONE));
    ImageList_AddIcon(himl, hIcon);

    TreeView_SetImageList(GetDlgItem(hDlg, IDC_CONN_LIST), himl, TVSIL_NORMAL);

    // populate and configure autodial settings
    FixAutodialSettings(hDlg, pConn);

    // fix security check
    if(g_fWin95)
    {
        RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
        if (re.GetError() == ERROR_SUCCESS)
        {
            if(re.GetNumber(REGSTR_VAL_ENABLESECURITYCHECK,0))
            {
                CheckDlgButton(hDlg, IDC_ENABLE_SECURITY, TRUE);
            }
        }
    }
    else
    {
        // no security check on NT so hide check box
        ShowWindow(GetDlgItem(hDlg, IDC_ENABLE_SECURITY), SW_HIDE);
    }

    if (!IsConnSharingAvail())
        ShowWindow(GetDlgItem(hDlg, IDC_CON_SHARING), SW_HIDE);

    // disable wizard button if for some reason ICW cannot be JITed in
    DWORD dwRes = JitFeature(hDlg, clsidFeatureICW, TRUE);
    if(JIT_NOT_AVAILABLE == dwRes) {
        // can never get ICW so grey button
        EnableWindow(GetDlgItem(hDlg, IDC_CONNECTION_WIZARD), FALSE);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//
//        NAME:           LoadRNADll
//
//        SYNOPSIS:       Loads RNA dll if not already loaded and obtains pointers
//                        for function addresses.
//
//        NOTES:          Maintains a reference count so we know when to unload
//
///////////////////////////////////////////////////////////////////////////

BOOL LoadRNADll(VOID)
{
    // increase reference count
    dwRNARefCount++;

    if (hInstRNADll)
    {
        // already loaded, nothing to do
        return TRUE;
    }

    // Ask wininet if Ras is installed.  Always make this call even if ras
    // dll doesn't load since it also forces wininet to migrate proxy
    // settings if necessary.
    DWORD dwFlags;
    InternetGetConnectedStateExA(&dwFlags, NULL, 0, 0);
    if(0 == (dwFlags & INTERNET_RAS_INSTALLED)) {
        // not installed - none of the functions will work so bail
        dwRNARefCount--;
        return FALSE;
    }

    // get the file name from resource
    TCHAR szDllFilename[SMALL_BUF_LEN+1];
    if (!MLLoadString(IDS_RNADLL_FILENAME,szDllFilename,ARRAYSIZE(szDllFilename))) {
        dwRNARefCount--;
        return FALSE;
    }

    // load the DLL
    hInstRNADll = LoadLibrary(szDllFilename);
    if (!hInstRNADll) {
        dwRNARefCount--;
        return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    UINT nIndex;
    for (nIndex = 0;nIndex < NUM_RNAAPI_PROCS;nIndex++)
    {
        if (!(*RasApiList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hInstRNADll,
            RasApiList[nIndex].pszName)))
        {
            // no longer fatal - no RasDeleteEntry on Win95 gold.
            TraceMsg(TF_GENERAL, "Unable to get address of function %s", RasApiList[nIndex].pszName);

//          UnloadRNADll();
//          return FALSE;
        }
    }

    if(g_fWin95)
    {
        // make sure we don't use any W versions that may be around on Win9x.
        // They'll almost certainly be stubs.
        lpRasEditPhonebookEntryW   = NULL;
        lpRasEnumEntriesW          = NULL;
        lpRasDeleteEntryW          = NULL;
        lpRasGetEntryDialParamsW   = NULL;
        lpRasSetEntryDialParamsW   = NULL;
        lpRasGetEntryPropertiesW   = NULL;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           UnloadRNADll
//
//        SYNOPSIS:       Decrements RNA dll reference count and unloads it if
//                        zero
//
/////////////////////////////////////////////////////////////////////////////

VOID UnloadRNADll(VOID)
{
    // decrease reference count
    if (dwRNARefCount)
        dwRNARefCount --;

    // unload DLL if reference count hits zero
    if (!dwRNARefCount && hInstRNADll)
    {

        // set function pointers to NULL
        UINT nIndex;
        for (nIndex = 0;nIndex < NUM_RNAAPI_PROCS;nIndex++)
            *RasApiList[nIndex].ppFcnPtr = NULL;

        // free the library
        FreeLibrary(hInstRNADll);
        hInstRNADll = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                           Dialup Dialog ie modem settings
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define W2KRASENTRYW struct tagW2KRASENTRYW
W2KRASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    WCHAR       szScript[ MAX_PATH ];
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    DWORD       dwIdleDisconnectSeconds;
    DWORD       dwType;
    DWORD       dwEncryptionType;
    DWORD       dwCustomAuthKey;
    GUID        guidId;
    WCHAR       szCustomDialDll[MAX_PATH];
    DWORD       dwVpnStrategy;
};


BOOL GetConnectoidInfo(HWND hDlg, LPTSTR pszEntryName)
{
    BOOL    fPassword = FALSE;

    if(g_fWin2K && lpRasGetEntryPropertiesW)
    {
        W2KRASENTRYW    re[2];
        DWORD           dwSize;

        // get props for this connectoid and see if it has a custom dial dll
        re[0].dwSize = sizeof(W2KRASENTRYW);
        dwSize = sizeof(re);
        if(ERROR_SUCCESS == (lpRasGetEntryPropertiesW)(NULL, pszEntryName,
                    (LPRASENTRYW)re, &dwSize, NULL, NULL))
        {
            if(0 != re[0].szCustomDialDll[0])
            {
                // Win2K handler exists - flag that we need to grey out
                // credential fields
                return TRUE;
            }
        }
    }
    else
    {
        // on down level platforms, check registry for cdh
        TCHAR   szTemp[MAX_PATH];

        GetConnKey(pszEntryName, szTemp, MAX_PATH);
        RegEntry re(szTemp, HKEY_CURRENT_USER);
        if(ERROR_SUCCESS == re.GetError())
        {
            if(re.GetString(REGSTR_VAL_AUTODIALDLLNAME, szTemp, MAX_PATH) && *szTemp)
            {
                // CDH exists - flag that we need to grey credentials
                return TRUE;
            }
        }
    }

    if(lpRasGetEntryDialParamsW)
    {
        RASDIALPARAMSW params;
        WCHAR  *pszUser = L"", *pszPassword = L"", *pszDomain = L"";

        memset(&params, 0, sizeof(params));
        params.dwSize = sizeof(params);

        StrCpyN(params.szEntryName, pszEntryName, RAS_MaxEntryName);
        if(ERROR_SUCCESS == (lpRasGetEntryDialParamsW)(NULL, (LPRASDIALPARAMSW)&params, &fPassword))
        {
            pszUser = params.szUserName;
            if(' ' != params.szDomain[0] || IsNTSPx(TRUE, 4, 6))  // NT4SP6 or greater?
                pszDomain = params.szDomain;
            if(fPassword)
                pszPassword = params.szPassword;
        }

        SetWindowText(GetDlgItem(hDlg, IDC_USER), pszUser);
        SetWindowText(GetDlgItem(hDlg, IDC_DOMAIN), pszDomain);
        SetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), pszPassword);
    }
    else if(lpRasGetEntryDialParamsA)
    {
        RASDIALPARAMSA  params;
        CHAR            *pszUser = "", *pszPassword = "", *pszDomain = "";

        memset(&params, 0, sizeof(params));
        params.dwSize = sizeof(params);
        SHUnicodeToAnsi(pszEntryName, params.szEntryName, ARRAYSIZE(params.szEntryName));

        if(ERROR_SUCCESS == (lpRasGetEntryDialParamsA)(NULL, &params, &fPassword))
        {
            pszUser = params.szUserName;
            if(' ' != params.szDomain[0] || IsNTSPx(TRUE, 4, 6))  // NT4SP6 or greater?
                pszDomain = params.szDomain;
            if(fPassword)
                pszPassword = params.szPassword;
        }

        SetWindowTextA(GetDlgItem(hDlg, IDC_USER), pszUser);
        SetWindowTextA(GetDlgItem(hDlg, IDC_DOMAIN), pszDomain);
        SetWindowTextA(GetDlgItem(hDlg, IDC_PASSWORD), pszPassword);
    }

    return FALSE;
}

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif // WS_EX_LAYOUTRTL

///////////////////////////////////////////////////////////////////
//
// NAME:       FixDialogForLan
//
// SYNOPSIS:   Remove dialing section of dialog box
//
///////////////////////////////////////////////////////////////////
void FixDialogForLan(HWND hDlg)
{
    RECT rectParent, rectDial, rectNet, rectCur;
    POINT pt;
    int i;

    static int iHideIDs[] = {
        IDC_GRP_DIAL, IDC_RAS_SETTINGS, IDC_TX_USER, IDC_USER, IDC_TX_PASSWORD,
        IDC_PASSWORD, IDC_TX_DOMAIN, IDC_DOMAIN, IDC_DIAL_ADVANCED,
        IDC_DONT_USE_CONNECTION
      };
#define NUM_HIDE (sizeof(iHideIDs) / sizeof(int))

    static int iMoveIDs[] = {
        IDCANCEL, IDOK
      };
#define NUM_MOVE (sizeof(iMoveIDs) / sizeof(int))

    // hide relevant windows
    for(i=0; i<NUM_HIDE; i++) {
        ShowWindow(GetDlgItem(hDlg, iHideIDs[i]), SW_HIDE);
    }

    // move relevant windows (yuck)
    GetWindowRect(hDlg, &rectParent);
    GetWindowRect(GetDlgItem(hDlg, IDC_GRP_DIAL), &rectDial);
    GetWindowRect(GetDlgItem(hDlg, IDC_GRP_PROXY), &rectNet);

    for(i=0; i<NUM_MOVE; i++) {
        GetWindowRect(GetDlgItem(hDlg, iMoveIDs[i]), &rectCur);
        pt.x = (GetWindowLong(hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? rectCur.right : rectCur.left;
        pt.y = rectCur.top;
        ScreenToClient(hDlg, &pt);
        MoveWindow(GetDlgItem(hDlg, iMoveIDs[i]), pt.x,
            pt.y - (rectDial.bottom - rectNet.bottom),
            rectCur.right - rectCur.left,
            rectCur.bottom - rectCur.top,
            TRUE);
    }

    // adjust dialog box size
    MoveWindow(hDlg, rectParent.left, rectParent.top,
        rectParent.right - rectParent.left,
        rectParent.bottom - rectParent.top - (rectDial.bottom - rectNet.bottom),
        TRUE);
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgInit
//
// SYNOPSIS:   Does initalization for dialup dialog
//
////////////////////////////////////////////////////////////////////

BOOL DialupDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    PDIALINFO pDI;
    TCHAR   szTemp[MAX_PATH], szSettings[64];
    DWORD   dwIEAK = 0, cb;

    // set up dailinfo struct
    pDI = new DIALINFO;
    if(NULL == pDI)
        return FALSE;
    memset(pDI, 0, sizeof(DIALINFO));  // new already zero init?
#ifndef UNIX
    pDI->pszConnectoid = pszConnectoid;
#else
    // Can't pass lparam from PSheet because we put dialup dialog directly
    // on the tab.
    pszConnectoid = TEXT("");
    pDI->pszConnectoid = pDI->szEntryName;

#endif
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pDI);

    // Fix window title
    if(0 == *(pDI->pszConnectoid)) {
        if (MLLoadString(IDS_LAN_SETTINGSPROXY, szTemp, MAX_PATH))
        {
            SetDlgItemText(hDlg, IDC_MANUAL, szTemp);
        }
        MLLoadString(IDS_LAN_SETTINGS, szTemp, MAX_PATH);
    } else {
        MLLoadString(IDS_SETTINGS, szSettings, 64);
        wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s %s"), pDI->pszConnectoid, szSettings);
    }
    SetWindowText(hDlg, szTemp);

#ifndef UNIX
    // Different stuff if we're editing a connectoid vs. lan settings
    if(NULL == pszConnectoid || 0 == *pszConnectoid) {
        // remove dialing goo from dialog
        FixDialogForLan(hDlg);
    } else {
        // fill in username/password/domain
        pDI->proxy.fCustomHandler = GetConnectoidInfo(hDlg, pszConnectoid);
    }
#endif

    // hide advanced button for autoconfig info if IEAK restriction is not set

    cb = sizeof(dwIEAK);
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INETCPL_RESTRICTIONS, REGSTR_VAL_INETCPL_IEAK,
        NULL, (LPVOID)&dwIEAK, &cb) != ERROR_SUCCESS) || !dwIEAK)
        ShowWindow(GetDlgItem(hDlg, IDC_AUTOCNFG_ADVANCED), SW_HIDE);

    // hide advanced button on millennium
    if(g_fMillennium)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_DIAL_ADVANCED), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_DIAL_ADVANCED), FALSE);
    }

    //
    // Read proxy and autoconfig settings for this connection
    //
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 4;
    list.pOptions = new INTERNET_PER_CONN_OPTION[4];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    //
    // move options to pDI struct
    //
    pDI->proxy.fEnable = (list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY);
    if(list.pOptions[1].Value.pszValue)
    {
        StrCpyN(pDI->proxy.szProxy, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
        GlobalFree(list.pOptions[1].Value.pszValue);
        list.pOptions[1].Value.pszValue = NULL;
    }
    if(list.pOptions[2].Value.pszValue)
    {
        StrCpyN(pDI->proxy.szOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
        GlobalFree(list.pOptions[2].Value.pszValue);
        list.pOptions[2].Value.pszValue = NULL;
    }

    //
    // fill in dialog fields
    //

    // proxy enable
    if(pDI->proxy.fEnable)
    {
        CheckDlgButton(hDlg, IDC_MANUAL, TRUE);
    }

    // autoconfig enable and url
    if(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL)
    {
        CheckDlgButton(hDlg, IDC_CONFIGSCRIPT, TRUE);
    }
    if(list.pOptions[3].Value.pszValue)
    {
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR), list.pOptions[3].Value.pszValue);
        GlobalFree(list.pOptions[3].Value.pszValue);
        list.pOptions[3].Value.pszValue = NULL;
    }

    // autodiscovery enable
    if(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT)
    {
        CheckDlgButton(hDlg, IDC_AUTODISCOVER, TRUE);
    }

    // all done with options list
    delete [] list.pOptions;

    // check enable and override and parse out server and port
    pDI->proxy.fOverrideLocal = RemoveLocalFromExceptionList(pDI->proxy.szOverride);
    CheckDlgButton(hDlg, IDC_PROXY_ENABLE, pDI->proxy.fEnable);
    CheckDlgButton(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES, pDI->proxy.fOverrideLocal);
    PopulateProxyControls(hDlg, &pDI->proxy, TRUE);

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgOk
//
// SYNOPSIS:   Apply settings for dial up dialog box
//
////////////////////////////////////////////////////////////////////

BOOL DialupDlgOk(HWND hDlg, PDIALINFO pDI)
{
    DWORD   dwValue = 0;

    //
    // Save proxy settings
    //
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD   dwBufSize = sizeof(list);
    DWORD   dwOptions = 2;              // always save FLAGS & DISCOVERY_FLAGS
    TCHAR   szAutoConfig[MAX_URL_STRING];
    
    list.pszConnection = (pDI->pszConnectoid && *pDI->pszConnectoid) ? pDI->pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions = new INTERNET_PER_CONN_OPTION[5];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    //
    // Query autodiscover flags - we just need to set one bit in there
    //
    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    //
    // save off all other options
    //
    list.pOptions[1].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].Value.dwValue = PROXY_TYPE_DIRECT;

    //
    // save proxy settings
    //
    GetProxyInfo(hDlg, pDI);

    if(pDI->proxy.fEnable)
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_PROXY;
    }

    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].Value.pszValue = pDI->proxy.szProxy;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].Value.pszValue = pDI->proxy.szOverride;

    dwOptions += 2;

    //
    // save autodetect
    //
    if(IsDlgButtonChecked(hDlg, IDC_AUTODISCOVER))
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
        if(pDI->fClickedAutodetect)
        {
            list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;
        }
    }
    else
    {
        list.pOptions[0].Value.dwValue &= ~AUTO_PROXY_FLAG_DETECTION_RUN;
    }

    //
    // save autoconfig
    //
    if(IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT) &&
       GetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR), szAutoConfig, MAX_URL_STRING))
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
        list.pOptions[dwOptions].Value.pszValue = szAutoConfig;
        list.pOptions[dwOptions].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
        dwOptions++;
    }

    // update wininet
    list.dwOptionCount = dwOptions;
    InternetSetOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize);

    // tell wininet that the proxy info has changed
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    // all done with options list
    delete [] list.pOptions;

    // all done if we're editing lan settings
    if(NULL == pDI->pszConnectoid || 0 == *pDI->pszConnectoid)
        return TRUE;

    // no credentials to store if we have a w2k custom handler
    if(pDI->proxy.fCustomHandler)
    {
        return TRUE;
    }

    //
    // save connectoid information - use wide version if possible
    //
    BOOL            fDeletePassword = FALSE;

    if(lpRasSetEntryDialParamsW)
    {
        RASDIALPARAMSW  params;

        memset(&params, 0, sizeof(RASDIALPARAMSW));
        params.dwSize = sizeof(RASDIALPARAMSW);
        StrCpyN(params.szEntryName, pDI->pszConnectoid, RAS_MaxEntryName+1);
        GetWindowText(GetDlgItem(hDlg, IDC_USER), params.szUserName, UNLEN);
        GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), params.szPassword, PWLEN);
        if(0 == params.szPassword[0])
            fDeletePassword = TRUE;
        GetWindowText(GetDlgItem(hDlg, IDC_DOMAIN), params.szDomain, DNLEN);
        if(0 == params.szDomain[0] && !IsNTSPx(TRUE, 4, 6)) {    // NT4SP6 or greater?
            // user wants empty domain
            params.szDomain[0] = TEXT(' ');
        }
        (lpRasSetEntryDialParamsW)(NULL, &params, fDeletePassword);

    }
    else if(lpRasSetEntryDialParamsA)
    {
        RASDIALPARAMSA  params;

        memset(&params, 0, sizeof(RASDIALPARAMSA));
        params.dwSize = sizeof(RASDIALPARAMSA);
        SHUnicodeToAnsi(pDI->pszConnectoid, params.szEntryName, ARRAYSIZE(params.szEntryName));
        GetWindowTextA(GetDlgItem(hDlg, IDC_USER), params.szUserName, UNLEN);
        GetWindowTextA(GetDlgItem(hDlg, IDC_PASSWORD), params.szPassword, PWLEN);
        if(0 == params.szPassword[0])
            fDeletePassword = TRUE;
        GetWindowTextA(GetDlgItem(hDlg, IDC_DOMAIN), params.szDomain, DNLEN);
        if(0 == params.szDomain[0] && !IsNTSPx(TRUE, 4, 6)) {      // NT4SP6 or greater?
            // user wants empty domain
            params.szDomain[0] = TEXT(' ');
        }
        (lpRasSetEntryDialParamsA)(NULL, &params, fDeletePassword);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgProc
//
// SYNOPSIS:   Dialog proc for dial up dialog
//
////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    PDIALINFO pDI = (PDIALINFO)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            ASSERT(lParam);
            DialupDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_DESTROY:
            delete pDI;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_AUTODISCOVER:
                pDI->fClickedAutodetect = TRUE;
                break;
            case IDC_AUTOCNFG_ADVANCED:
                if(GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                    break;
                // show advanced dialog box
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOCNFG_SETTINGS), hDlg,
                    AdvAutocnfgDlgProc, (LPARAM) pDI->pszConnectoid);
                break;

            case IDC_PROXY_ADVANCED:
                if(GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                    break;

                GetProxyInfo(hDlg, pDI);

                // remove local so it doesn't show up in advanced dialog
                RemoveLocalFromExceptionList(pDI->proxy.szOverride);

                // show advanced dialog box
                if (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_PROXY_SETTINGS), hDlg,
                                ProxyDlgProc, (LPARAM) &pDI->proxy) == IDOK)
                {
                    if(FALSE == pDI->proxy.fEnable)
                    {
                        // user disabled proxy in advanced dialog
                        CheckDlgButton(hDlg, IDC_MANUAL, FALSE);
                    }
                    PopulateProxyControls(hDlg, &pDI->proxy, TRUE);
                }
                break;

            case IDC_RAS_SETTINGS:
                if (g_fWin95) //jeffsi
                {
                    if(lpRasEditPhonebookEntryW)
                    {
                        (lpRasEditPhonebookEntryW)(hDlg, NULL, pDI->pszConnectoid);
                    }
                    else if(lpRasEditPhonebookEntryA)
                    {
                        CHAR  szConnectoid[MAX_PATH];
                        SHUnicodeToAnsi(pDI->pszConnectoid, szConnectoid, ARRAYSIZE(szConnectoid));
                        (lpRasEditPhonebookEntryA)(hDlg, NULL, szConnectoid);
                    }  
                }
                else
                {
                    PFRED pfred = NULL;
                    HMODULE hRasDlg = LoadLibrary(TEXT("rasdlg.dll"));
                    RASENTRYDLG info;

                    if (!hRasDlg)
                    {
                        break;
                    }
#ifdef UNICODE
                    pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgW");
#else
                    pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgA");
#endif
                    if (!pfred)
                    {
                        FreeLibrary(hRasDlg);
                        break;
                    }

                    memset(&info, 0, sizeof(RASENTRYDLG));
                    info.dwSize = sizeof(RASENTRYDLG);
                    info.hwndOwner = hDlg;

#ifdef UNICODE
                    (pfred)(NULL, pDI->pszConnectoid, &info);
#else
                    CHAR szConnectoid[MAX_PATH];
                    SHUnicodeToAnsi(pDI->pszConnectoid, szConnectoid, ARRAYSIZE(szConnectoid));
                    (pfred)(NULL, szConnectoid, &info);
#endif

                    FreeLibrary(hRasDlg);
                }
                break;
                
            case IDC_DIAL_ADVANCED:
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP_ADVANCED), hDlg,
                    AdvDialupDlgProc, (LPARAM) pDI->pszConnectoid);
                break;

            case IDC_MANUAL:
                if(IsDlgButtonChecked(hDlg, IDC_MANUAL))
                {
                    pDI->proxy.fEnable = TRUE;
                    SetFocus(GetDlgItem(hDlg, IDC_PROXY_ADDR));
                    SendMessage(GetDlgItem(hDlg, IDC_PROXY_ADDR), EM_SETSEL, 0, -1);
                }
                else
                {
                    pDI->proxy.fEnable = FALSE;
                }
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
#ifdef UNIX
                ENABLEAPPLY(hDlg);
#endif
                break;

            case IDC_CONFIGSCRIPT:
                if(IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT))
                {
                    // set focus to config script url
                    SetFocus(GetDlgItem(hDlg, IDC_CONFIG_ADDR));
                    SendMessage(GetDlgItem(hDlg, IDC_CONFIG_ADDR), EM_SETSEL, 0, -1);
                }
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
#ifdef UNIX
                ENABLEAPPLY(hDlg);
#endif
                break;


#ifdef UNIX
            case IDC_AUTODISCOVER:
            case IDC_PROXY_OMIT_LOCAL_ADDRESSES:
                ENABLEAPPLY(hDlg);
                break;
            case IDC_PROXY_PORT:
            case IDC_PROXY_ADDR:
            case IDC_CONFIG_ADDR:
                switch (HIWORD(wParam))
                {
                    case EN_CHANGE:
                        ENABLEAPPLY(hDlg);
                        break;
                }
                break;
#endif
            case IDC_DONT_USE_CONNECTION:
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
                break;

            case IDOK:
                if(FALSE == DialupDlgOk(hDlg, pDI))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
#ifdef UNIX
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
            if(FALSE == DialupDlgOk(hDlg, pDI))
                // something is wrong... don't exit yet
                break;
                // fall through
                }
        }
    }
#endif
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Advanced dial-up settings dialog
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// NAME:       AdvDialupDlgProc
//
// SYNOPSIS:   Dialog proc for dial up dialog
//
////////////////////////////////////////////////////////////////////

void EnableAdvDialControls(HWND hDlg)
{
    BOOL fIdle      = IsDlgButtonChecked(hDlg, IDC_ENABLE_AUTODISCONNECT);

    // on if we have idle disconnect...
    EnableDlgItem(hDlg, IDC_IDLE_TIMEOUT, fIdle);
    EnableDlgItem(hDlg, IDC_IDLE_SPIN, fIdle);
}

BOOL AdvDialupDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    TCHAR szTemp[MAX_PATH];
    DWORD dwRedialAttempts, dwRedialInterval, dwAutodisconnectTime;
    BOOL fExit, fDisconnect;

    // save connectoid name
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pszConnectoid);

    // figure out our registry key
    GetConnKey(pszConnectoid, szTemp, MAX_PATH);

    // open connectoid or lan settings
    RegEntry reCon(szTemp, HKEY_CURRENT_USER);
    if(ERROR_SUCCESS != reCon.GetError())
        return FALSE;

    //
    // Read autodial / redial stuff
    //
    // We get this stuff from the connectoid if possible.  We assume it's all
    // saved to the connectoid together so if EnableAutodial is present there,
    // read everything from there else read everything from the IE4 settings.
    //
    dwRedialInterval = reCon.GetNumber(REGSTR_VAL_REDIALINTERVAL, DEF_REDIAL_WAIT);
    dwRedialAttempts = reCon.GetNumber(REGSTR_VAL_REDIALATTEMPTS, DEF_REDIAL_TRIES);

    // autodisconnect
    fDisconnect = (BOOL)reCon.GetNumber(REGSTR_VAL_ENABLEAUTODIALDISCONNECT, 0);
    dwAutodisconnectTime = reCon.GetNumber(REGSTR_VAL_DISCONNECTIDLETIME, DEF_AUTODISCONNECT_TIME);
    fExit = (BOOL)reCon.GetNumber(REGSTR_VAL_ENABLEEXITDISCONNECT, 0);

    //
    // Check if the mobile pack is installed and if it is not - then do not have it checked
    //
    DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, TRUE);
    if(JIT_PRESENT != dwRes)
    {
        fDisconnect = FALSE;
        fExit = FALSE;
        // check to see if offline pack is installed and disable the disconnect
        // options if user has bailed on it
        if(JIT_NOT_AVAILABLE == dwRes) {
            // can't get offline pack so disable options
            CheckDlgButton(hDlg, IDC_ENABLE_AUTODISCONNECT, FALSE);
            CheckDlgButton(hDlg, IDC_EXIT_DISCONNECT, FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLE_AUTODISCONNECT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_TX_AUTODISCONNECT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EXIT_DISCONNECT), FALSE);
        }
    }

    //
    // Populate controls
    //
    CheckDlgButton(hDlg, IDC_ENABLE_AUTODISCONNECT, fDisconnect);
    CheckDlgButton(hDlg, IDC_EXIT_DISCONNECT, fExit);

    SendDlgItemMessage(hDlg, IDC_IDLE_SPIN, UDM_SETPOS, 0, dwAutodisconnectTime);
    SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN,UDM_SETPOS, 0, dwRedialAttempts);
    SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN,UDM_SETPOS, 0, dwRedialInterval);

    //
    // Set control limits
    //
    Edit_LimitText(GetDlgItem(hDlg,IDC_IDLE_TIMEOUT), 2);    // limit edit ctrl to 2 chars
    Edit_LimitText(GetDlgItem(hDlg,IDC_IDLE_SPIN), 2);
    Edit_LimitText(GetDlgItem(hDlg,IDC_CONNECT_SPIN), 2);

    // set spin control min/max
    SendDlgItemMessage(hDlg,IDC_IDLE_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_AUTODISCONNECT_TIME,MIN_AUTODISCONNECT_TIME));
    SendDlgItemMessage(hDlg,IDC_CONNECT_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_REDIAL_TRIES,MIN_REDIAL_TRIES));
    SendDlgItemMessage(hDlg,IDC_INTERVAL_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_REDIAL_WAIT,MIN_REDIAL_WAIT));

    // enable controls
    EnableAdvDialControls(hDlg);

    return TRUE;
}

BOOL AdvDialupDlgOk(HWND hDlg, LPTSTR pszConnectoid)
{
    TCHAR szTemp[MAX_PATH];

    GetConnKey(pszConnectoid, szTemp, MAX_PATH);

    // open connectoid or lan settings
    RegEntry reCon(szTemp, HKEY_CURRENT_USER);
    if(ERROR_SUCCESS != reCon.GetError())
        return FALSE;

    // Save autodisconnect values
    BOOL fExit = IsDlgButtonChecked(hDlg,IDC_EXIT_DISCONNECT);
    BOOL fDisconnect = IsDlgButtonChecked(hDlg,IDC_ENABLE_AUTODISCONNECT);

    if(fExit || fDisconnect) {
        // make sure offline pack is installed or this feature won't work.
        DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, FALSE);
        if(JIT_PRESENT != dwRes) {
            // user doesn't want to download it so turn off autodisconnect
            fExit = FALSE;
            fDisconnect = FALSE;
        }
    }

    reCon.SetValue(REGSTR_VAL_ENABLEAUTODIALDISCONNECT, (DWORD)fDisconnect);
    reCon.SetValue(REGSTR_VAL_ENABLEEXITDISCONNECT, (DWORD)fExit);

    if(fDisconnect)
    {
        // get autodisconnect time from edit control
        // Sundown: coercion to 32b since values are range checked
        DWORD dwAutoDisconnectTime = (DWORD) SendDlgItemMessage(hDlg, IDC_IDLE_SPIN,
                                                                UDM_GETPOS,0,0);

        if(HIWORD(dwAutoDisconnectTime)) {
            MsgBox(hDlg, IDS_INVALID_AUTODISCONNECT_TIME, 0, MB_OK);

            // decide if it's too big or too small and fix it appropriately
            if(GetDlgItemInt(hDlg, IDC_IDLE_TIMEOUT, NULL, FALSE) < MIN_AUTODISCONNECT_TIME)
                dwAutoDisconnectTime = MIN_AUTODISCONNECT_TIME;
            else
                dwAutoDisconnectTime = MAX_AUTODISCONNECT_TIME;
            SendDlgItemMessage(hDlg, IDC_IDLE_SPIN, UDM_SETPOS, 0, dwAutoDisconnectTime);
            SetFocus(GetDlgItem(hDlg, IDC_IDLE_TIMEOUT));
            return FALSE;
        }

        // save it to registry
        reCon.SetValue(REGSTR_VAL_DISCONNECTIDLETIME, dwAutoDisconnectTime);

        // also save this value to MSN autodisconnect value, to
        // avoid confusion.  At some point in the future we'll
        // combine our UI...
        RegEntry reMSN(REGSTR_PATH_MOSDISCONNECT,HKEY_CURRENT_USER);
        if (reMSN.GetError() == ERROR_SUCCESS)
        {
            reMSN.SetValue(REGSTR_VAL_MOSDISCONNECT,dwAutoDisconnectTime);
        }
    }

    // save redial info
    DWORD_PTR dwRedialTry = SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN, UDM_GETPOS, 0, 0);
    DWORD_PTR dwRedialWait = SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN, UDM_GETPOS, 0, 0);

    if(HIWORD(dwRedialTry)) {
        MsgBox(hDlg, IDS_INVALID_REDIAL_ATTEMPTS, 0, MB_OK);
        if(GetDlgItemInt(hDlg, IDC_CONNECT, NULL, FALSE) < MIN_REDIAL_TRIES)
            dwRedialTry = MIN_REDIAL_TRIES;
        else
            dwRedialTry = MAX_REDIAL_TRIES;
        SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN, UDM_SETPOS, 0, dwRedialTry);
        SetFocus(GetDlgItem(hDlg, IDC_CONNECT));
        return FALSE;
    }

    if(HIWORD(dwRedialWait)) {
        MsgBox(hDlg, IDS_INVALID_REDIAL_WAIT, 0, MB_OK);
        if(GetDlgItemInt(hDlg, IDC_INTERVAL, NULL, FALSE) < MIN_REDIAL_WAIT)
            dwRedialWait = MIN_REDIAL_WAIT;
        else
            dwRedialWait = MAX_REDIAL_WAIT;
        SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN, UDM_SETPOS, 0, dwRedialWait);
        SetFocus(GetDlgItem(hDlg, IDC_INTERVAL));
        return FALSE;
    }

    reCon.SetValue(REGSTR_VAL_REDIALATTEMPTS, (DWORD) dwRedialTry);
    reCon.SetValue(REGSTR_VAL_REDIALINTERVAL, (DWORD) dwRedialWait);

    return TRUE;
}

INT_PTR CALLBACK AdvDialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LPTSTR pszConn = (LPTSTR) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            ASSERT(lParam);
            AdvDialupDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_ENABLE_AUTODISCONNECT:
                EnableAdvDialControls(hDlg);
                break;

            case IDOK:
                if(FALSE == AdvDialupDlgOk(hDlg, pszConn))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Advanced autoconfig settings dialog (only used by IEAK)
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL AdvAutocnfgDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);

    // save connectoid name
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pszConnectoid);

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 3;
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    // autoproxy url (js)
    if(list.pOptions[0].Value.pszValue)
    {
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIGJS_ADDR), list.pOptions[0].Value.pszValue);
    }

    
    // autoconfig timer interval
    if(list.pOptions[1].Value.dwValue)
    {
        TCHAR szTimerInterval[16];

        wsprintf(szTimerInterval, TEXT("%d"), list.pOptions[1].Value.dwValue);
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIGTIMER), szTimerInterval);
    }

    // autoconfig optimization
    CheckDlgButton(hDlg, IDC_CONFIGOPTIMIZE, 
        (list.pOptions[2].Value.dwValue & AUTO_PROXY_FLAG_CACHE_INIT_RUN ) ? BST_CHECKED : BST_UNCHECKED);

    // all done with options list
    if (list.pOptions[0].Value.pszValue)
    {
        GlobalFree(list.pOptions[0].Value.pszValue);
    }
    delete [] list.pOptions;

    return TRUE;
}

BOOL AdvAutocnfgDlgOk(HWND hDlg, LPTSTR pszConnectoid)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD   dwBufSize = sizeof(list);
    TCHAR    szAutoconfig[MAX_URL_STRING];
    TCHAR   szTimerInterval[16];

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
    //
    // Query autodiscover flags - we just need to set one bit in there
    //
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    // save autoconfiguration optimization field

    if (IsDlgButtonChecked(hDlg, IDC_CONFIGOPTIMIZE) == BST_CHECKED)
        list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_CACHE_INIT_RUN ;
    else
        list.pOptions[0].Value.dwValue &= ~AUTO_PROXY_FLAG_CACHE_INIT_RUN ;

    //
    // save autoproxy url
    //
    list.pOptions[1].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    GetWindowText(GetDlgItem(hDlg, IDC_CONFIGJS_ADDR), szAutoconfig, sizeof(szAutoconfig));
    list.pOptions[1].Value.pszValue = szAutoconfig;

    //
    // save autoconfig timer
    //
    list.pOptions[2].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[2].Value.dwValue = 0;
        
    if(GetWindowText(GetDlgItem(hDlg, IDC_CONFIGTIMER), szTimerInterval, sizeof(szTimerInterval)))
        list.pOptions[2].Value.dwValue = StrToInt(szTimerInterval);
    
    // update wininet
    list.dwOptionCount = 3;
    InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize);

    // tell wininet that the proxy info has changed
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    delete [] list.pOptions;

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       AdvAutocnfgProc
//
// SYNOPSIS:   Dialog proc for autoconfig dialog
//
////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvAutocnfgDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LPTSTR pszConn = (LPTSTR) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            AdvAutocnfgDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDOK:
                if(FALSE == AdvAutocnfgDlgOk(hDlg, pszConn))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\cachecpl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

File Name:

     cachecpl.c

Module :

    inetcpl.cpl

Abstract:

    This file contains code to set cache config information from the internet
    control panel

Author:

    Shishir Pardikar

6/22/96 t-gpease    moved entire dailog to this file from "dialdlg.c"

Environment:

    User Mode - Win32

Revision History:

--*/

#include "inetcplp.h"
#include "cachecpl.h"

#include <mluisupp.h>
#include <winnls.h>

#ifdef unix
#define DIR_SEPARATOR_CHAR TEXT('/')
#else
#define DIR_SEPARATOR_CHAR TEXT('\\')
#endif /* unix */

#define CONSTANT_MEGABYTE   (1024*1024)

INT_PTR CALLBACK 
EmptyCacheDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK 
EmptyCacheCookiesDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam);

#ifdef UNICODE
/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfo(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, 
PDWORDLONG pdlTotal)
{
    CHAR  szGDFSEXA[MAX_PATH];
    SHUnicodeToAnsi(pszPath, szGDFSEXA, ARRAYSIZE(szGDFSEXA));
    return GetDiskInfoA(szGDFSEXA, pdwClusterSize, pdlAvail, pdlTotal);
}
#else
#define GetDiskInfo     GetDiskInfoA
#endif

/* DispMessage
    A quick and easy way to display messages for the cachecpl
*/

INT DispMessage(HWND hWnd, UINT Msg, UINT Title, UINT Type)
{
    TCHAR szTitle[80];
    TCHAR szMessage[1024];
    
    // something went wrong with the registry
    // notify user
    MLLoadShellLangString(Msg, szMessage, ARRAYSIZE(szMessage));
    MLLoadShellLangString(Title, szTitle, ARRAYSIZE(szTitle));

    return MessageBox(hWnd, szMessage, szTitle, Type);
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

#undef SHGetFolderPath
#ifdef UNICODE
#define SHGETFOLDERPATH_STR "SHGetFolderPathW"
#else
#define SHGETFOLDERPATH_STR "SHGetFolderPathA"
#endif

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
{
    HMODULE hmodSHFolder = LoadLibrary(TEXT("shfolder.dll"));
    HRESULT hr = E_FAIL;
    
    if (hmodSHFolder) 
    {
        PFNSHGETFOLDERPATH pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hmodSHFolder, SHGETFOLDERPATH_STR);
        if (pfn)
        {
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
        }
        FreeLibrary(hmodSHFolder);
    }
    return hr;
}


// Cache maximum/minimum in MB
#define CACHE_SIZE_CAP 32000
#define CACHE_SIZE_MIN 1


DWORD UpdateCacheQuotaInfo(LPTEMPDLG pTmp, BOOL fUpdate)
{
    // The following probably needs to be fixed.
    DWORDLONG cKBLimit = pTmp->uiDiskSpaceTotal, cKBSpare = pTmp->uiCacheQuota;

    if (cKBLimit==0)
    {
        return GetLastError();
    }

    // What's happening in the following sequence:
    // We want to ensure that the cache size is
    // 1.   less than the drive's size (if larger, then reduce to 75% of drive's space
    // 2.   less than 32 GB

    // And adjust percentage accordingly.
    
    if (fUpdate)
    {
        ASSERT(pTmp->iCachePercent<=100);
        if (pTmp->iCachePercent==0)
        {
            cKBSpare = CACHE_SIZE_MIN;
        }
        else
        {
            cKBSpare = (cKBLimit * pTmp->iCachePercent)/ 100;
        }
        if (cKBSpare > cKBLimit)
        {
            pTmp->iCachePercent = 75;
            cKBSpare = (cKBLimit * pTmp->iCachePercent) / 100;
        }
        pTmp->uiCacheQuota = (DWORD)cKBSpare;
        SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
    }

    if (cKBSpare > CACHE_SIZE_CAP)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = CACHE_SIZE_CAP;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    }
    else if (cKBSpare < CACHE_SIZE_MIN)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = CACHE_SIZE_MIN;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    } 
    else if (cKBSpare > cKBLimit)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = (DWORD)cKBLimit;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    }

    if (!fUpdate)
    {
        pTmp->iCachePercent = (WORD)((cKBSpare * 100 + (cKBLimit/2))/cKBLimit);
        if (pTmp->iCachePercent>100)
        {
            pTmp->iCachePercent = 100;
        }
        SendMessage( pTmp->hwndTrack, TBM_SETPOS, TRUE, pTmp->iCachePercent );
    }
    return ERROR_SUCCESS;
}

VOID AdjustCacheRange(LPTEMPDLG pTmp)
{
    UINT uiMax = 10;
    DWORDLONG dlTotal = 0;

    if (GetDiskInfo(pTmp->bChangedLocation ? pTmp->szNewCacheLocation : pTmp->szCacheLocation, NULL, NULL, &dlTotal))
    {
        dlTotal 