         }

            cwcActual = UTF8ToWideChar ( (char *) abDBCSInput,
                                          nSavedSplitBytes,
                                          _awcTranslatedBuffer,
                                          TRANSLATED_CHAR_BUFFER_LENGTH );
                        Win4Assert (cwcActual != 0);

            fDBCSSplitChar = FALSE;
                }
                else
        if ( fDBCSSplitChar )
        {
            //
            // Convert the lead byte (abDCSInput[0]) and the trail byte (first
            // byte in newly mapped buffer) to Unicode
            //
            Win4Assert( IsDBCSLeadByteEx( _ulCodePage, abDBCSInput[0] ) );

            abDBCSInput[1] = * (BYTE *) _mmStreamBuf.Get();

            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             (char *) abDBCSInput,
                                             2,
                                             _awcTranslatedBuffer,
                                             TRANSLATED_CHAR_BUFFER_LENGTH );
            if ( cwcActual == 0 )
            {
                //
                // Input buffer is 2 bytes, and output buffer is 2k, hence there
                // should be ample space
                //
                Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );

                throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
            }

            cChIn = 1;
            fDBCSSplitChar = FALSE;
        }
        else
        {
            ULONG cChUnread = _mmStreamBuf.Size() - _bytesReadFromMMBuffer;

            //
            // Since, the wide chars are precomposed, assume 1:1 translation mapping
            //
            cChIn = TRANSLATED_CHAR_BUFFER_LENGTH;
            if ( cChIn > cChUnread )
            {
                //
                // Not enough chars in input
                //
                cChIn = cChUnread;
            }

            cwcActual = 0;
            BYTE *pInBuf = (BYTE *) _mmStreamBuf.Get() + _bytesReadFromMMBuffer;
            do
            {
                if ( _fSimpleConversion )
                {
                                        // Simple conversion is used for the HTML "pre scan"
                                        // for meta tags, it just casts bytes to WCHAR's.

                    for ( unsigned i=0; i<cChIn; i++ )
                        _awcTranslatedBuffer[i] = pInBuf[i];

                    cwcActual = cChIn;
                }
                else if ( _ulCodePage == CP_UTF8 )
                                {
                                        Win4Assert( cChIn >= 1 );

                                        // If the last byte(s) represent a partial UTF-8
                                        // character, don't convert them.
                                        //
                                        cChIn -= UTF8CountExtraBytes ( (char *)pInBuf, cChIn );

                                        cwcActual = UTF8ToWideChar (
                                                (char *) _mmStreamBuf.Get() + _bytesReadFromMMBuffer,
                                                cChIn,
                                                _awcTranslatedBuffer,
                                                TRANSLATED_CHAR_BUFFER_LENGTH );
                                }
                                else
                {
                    //
                    // If last char is a DBCS lead byte, then don't convert the last char
                    //
                    if ( _fDBCSCodePage
                         && IsLastCharDBCSLeadByte( pInBuf, cChIn ) )
                    {
                        Win4Assert( cChIn > 1 );
                        cChIn--;
                    }

                    cwcActual = MultiByteToWideChar( _ulCodePage,
                                                     0,
                                                     (char *) _mmStreamBuf.Get() + _bytesReadFromMMBuffer,
                                                     cChIn,
                                                     _awcTranslatedBuffer,
                                                     TRANSLATED_CHAR_BUFFER_LENGTH );
                }

                if ( cwcActual == 0 )
                {
                    if ( _ulCodePage == CP_UTF8 && cChIn >= 2 )
                    {
                        cChIn /= 2;
                    }
                    else
                    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER && cChIn >= 2 )
                        cChIn /= 2;
                    else
                    {
                        // too chatty
                        //Win4Assert( !"CMemoryMappedInputStream::Either unknown codepage or cannot translate single char" );

                        throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
                    }
                }
            } while( cwcActual == 0 );
        }

        Win4Assert( _bytesReadFromMMBuffer + cChIn <= _mmStreamBuf.Size() );
        Win4Assert( cwcActual <= TRANSLATED_CHAR_BUFFER_LENGTH );

        _bytesReadFromMMBuffer += cChIn;
        _charsReadFromTranslatedBuffer = 0;
        _cwcTranslatedBuffer = cwcActual;
    }

    return _awcTranslatedBuffer[_charsReadFromTranslatedBuffer++];
}




//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::UnGetChar
//
//  Synopsis:   Pushes(logically) a character back into the input stream
//
//  Arguments:  [wch] -- Char to be pushed back
//
//--------------------------------------------------------------------------

void CMemoryMappedInputStream::UnGetChar( WCHAR wch )
{
    //
    // We can unget only one char at a time
    //
    Win4Assert( !_fUnGotChar );

    _fUnGotChar = TRUE;
    _wch = wch;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::Eof
//
//  Synopsis:   Is this the end of input file ?
//
//--------------------------------------------------------------------------

BOOL CMemoryMappedInputStream::Eof()
{
    if ( _fUnGotChar )
        return FALSE;

    if ( _charsReadFromTranslatedBuffer < _cwcTranslatedBuffer )
        return FALSE;

    if ( _bytesReadFromMMBuffer == _mmStreamBuf.Size() )
        return _mmStreamBuf.Eof();
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::IsLastCharDBCSLeadByte
//
//  Synopsis:   Check if last byte in buffer is a DBCS lead byte
//
//  Arguments:  [pbIn]    --  Input buffer
//              [cChIn]   --  Buffer length
//
//--------------------------------------------------------------------------

BOOL CMemoryMappedInputStream::IsLastCharDBCSLeadByte( BYTE *pbIn,
                                                       ULONG cChIn )
{
    Win4Assert( IsDBCSCodePage( _ulCodePage ) );

    for ( ULONG cCh=0; cCh<cChIn; cCh++ )
        if ( IsDBCSLeadByteEx( _ulCodePage, pbIn[cCh] ) )
            cCh++;

    //
    // If last char is DBCS lead byte, then cCh == cChIn + 1, else cCh == cChIin
    //
    return cCh != cChIn;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::IsDBCSCodePage
//
//  Synopsis:   Check if the codepage is a DBCS code page
//
//  Arguments:  [codePage]    --  Code page to check
//
//--------------------------------------------------------------------------

BOOL CMemoryMappedInputStream::IsDBCSCodePage( ULONG ulCodePage )
{
    CPINFO cpInfo;

        if ( ulCodePage == CP_UTF8 )
                return FALSE;

    BOOL fSuccess = GetCPInfo( ulCodePage, &cpInfo );

    if ( fSuccess )
    {
        if ( cpInfo.LeadByte[0] != 0 && cpInfo.LeadByte[1] != 0 )
            return TRUE;
        else
            return FALSE;
    }
    else
    {
          htmlDebugOut(( DEB_ERROR,
                         "IsDBCSCodePage failed, 0x%x\n",
                         GetLastError() ));
          return FALSE;
    }
}



//+-------------------------------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::SkipTwoByteUnicodeMarker
//
//  Synopsis:   Skip the two byte Unicode marker in the input.
//
//  Returns:    void
//
//  Throw:      no
//
//  Arguments:  none
//
//  Unclear Assumptions:
//      This assumes the stream is positioned at the very beginning when this
//      method is called. It also assumes HTML_FILTER_CHUNK_SIZE >= 2. Obviously,
//      HTML_FILTER_CHUNK_SIZE should be greater than 2 for efficiency considerations.
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CMemoryMappedInputStream::SkipTwoByteUnicodeMarker()
{
    Win4Assert(HTML_FILTER_CHUNK_SIZE >= 2 && "What going on here? Alien mind control??");
    Win4Assert(0 ==_bytesReadFromMMBuffer && "Why SkipTwoByteUnicodeMarker if we are not at "
        "the beginning??");

    _bytesReadFromMMBuffer += 2;
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::InitAsUnicode
//
//  Synopsis:   Initialize the stream as an Unicode stream.
//
//  Returns:    void
//
//  Throw:      CException(FILTER_E_ACCESS) when access to the stream failed.
//              Note:   Personally, I would like an error code that is more informative.
//                      To make that happen requires more changes. More changes means more
//                      development time, which the current schedule does not have. Plus,
//                      more changes means bugs are more likely to be introduced.
//
//  Arguments:
//  [BOOL fBigEndian]   - [in]  Indicate if Unicode is Big endian byte order.
//
//  Unclear Assumptions:
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CMemoryMappedInputStream::InitAsUnicode(BOOL fBigEndian)
{
    _ulCodePage = CP_UNICODE;
    _fDBCSCodePage = FALSE;
    m_fBigEndianUnicode = fBigEndian;

    InternalInitNoCodePage();
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::InternalInitNoCodePage
//
//  Synopsis:   Initialize the memory mapped stream w/o setting the code page.
//
//  Returns:    void
//
//  Throw:      CException(FILTER_E_ACCESS) when access to the stream failed.
//              Note:   Personally, I would like an error code that is more informative.
//                      To make that happen requires more changes. More changes means more
//                      development time, which the current schedule does not have. Plus,
//                      more changes means bugs are more likely to be introduced.
//
//  Arguments:  none
//
//  Unclear Assumptions:
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CMemoryMappedInputStream::InternalInitNoCodePage()
{
    _bytesReadFromMMBuffer = 0;
    _charsReadFromTranslatedBuffer = 0;
    _cwcTranslatedBuffer = 0;
    _fSimpleConversion = FALSE;
    _fUnGotChar = FALSE;
    _wch = 0;

    if(_mmStream.Ok())
    {
        _mmStreamBuf.Rewind();
        _mmStreamBuf.Init(&_mmStream);

        if(!_mmStream.isEmpty())
        {
            _mmStreamBuf.Map(HTML_FILTER_CHUNK_SIZE);
        }
    }
    else if(_mmIStream.Ok())
    {
        _mmStreamBuf.Rewind();
        _mmStreamBuf.Init(&_mmIStream);

        if(!_mmIStream.isEmpty())
        {
            _mmStreamBuf.Map(HTML_FILTER_CHUNK_SIZE);
        }
    }
    else
    {
        htmlDebugOut((DEB_ERROR, "Throwing FILTER_E_ACCESS in CMemoryMappedInputStream::InternalInitNoCodePage "
            "because _mmStream.Ok() is false"));
        throw(CException(FILTER_E_ACCESS));
    }
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CMemoryMappedInputStream::GetNextByte
//
//  Synopsis:   Get the next byte from the input stream. Map in more data as necessary.
//
//  Returns:    TRUE if there is a byte to read.
//              FALSE otherwise.
//
//  Throw:      CException(HRESULT_FROM_WIN32(GetLastError()))
//
//  Arguments:
//  [BYTE &rbValue] - [out] The byte read. Nothing will be written if return value is FALSE
//
//  Unclear Assumptions:
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
BOOL CMemoryMappedInputStream::GetNextByte(BYTE &rbValue)
{
    //
    //  The reason for "<=" is because of the assumption of SkipTwoByteUnicodeMarker.
    //  In case of the assumption being false, we don't want to read beyond the
    //  mapped buffer.
    //
    Win4Assert(_mmStreamBuf.Size() >= _bytesReadFromMMBuffer && "Assumption in "
        "SkipTwoByteUnicodeMarker() has been violated");
    if(_mmStreamBuf.Size() <= _bytesReadFromMMBuffer)
    {
        if(_mmStreamBuf.Eof())
        {
            _bytesReadFromMMBuffer = _mmStreamBuf.Size();
            return FALSE;
        }
        else
        {
            _mmStreamBuf.Map(HTML_FILTER_CHUNK_SIZE);
            _bytesReadFromMMBuffer = 0;
        }
    }

    BYTE *pbByteToRead = (BYTE *)_mmStreamBuf.Get();
    Win4Assert(pbByteToRead && "Nothing to read??");
    if(!pbByteToRead)
    {
        htmlDebugOut((DEB_ERROR, "CMemoryMappedInputStream::GetNextByte(): _mmStreamBuf.Get() returned 0. "
            "Returning FALSE to indicate no next byte."));
        return FALSE;
    }

    pbByteToRead += _bytesReadFromMMBuffer;
    rbValue = *pbByteToRead;
    ++_bytesReadFromMMBuffer;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\htmlfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       htmlfilt.cxx
//
//  Contents:   Html filter
//
//  Classes:    CHtmlIFilter
//
//  History:    25-Apr-97       BobP            1. Replaced "element bag" with
//                                                 _tagHandler fixed array lookup.
//                                              2. (Temporarily) removed _pAttributes
//                                                 and lobotomized IsStopToken().
//                                              3. Added statistical language +
//                                                 charset detection; rewrote
//                                                 DetectCodePage()
//                                                                              
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


#define INITSSGUIDS
#include <pkmguid.hxx>

DECLARE_INFOLEVEL(html)

const GUID guidStoragePropset = PSGUID_STORAGE;

const WCHAR * WCSTRING_LANG = L"lang";
const WCHAR * WCSTRING_NEUTRAL = L"neutral";
const WCHAR * WCSTRING_HREF = L"href";
const WCHAR * WCSTRING_LINK = L"link";

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::CHtmlIFilter
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CHtmlIFilter::CHtmlIFilter()
    : _pHtmlElement(0),
      _fNonHtmlFile(FALSE),
      _fFilterContent(FALSE),
      _fFilterProperties(FALSE),
      _cAttributes(0),
      _pAttributes(0),
      _pwszFileName(0),
      _ulChunkID(0),
      //_locale(GetSystemDefaultLCID()),
      _fReturnDeferredNow(FALSE),
      _fCodePageReturned(FALSE),
      _fMetaRobotsReturned(FALSE),
      _pMetaRobotsValue(NULL),
      _pLanguageProperty(NULL)
{
    _pScanner = new CHtmlScanner (*this, _serialStream);

    //
    // Setup various Html elements
        //
        // TagEntries[] drives *parsing* and indicates a handler type
        // (HtmlTokenType) for each HTML tag.
        //
        // _tagHandler binds the HtmlTokenType to an instance of a
        // CHtmlElement-derived class that provides dynamic state and
        // type-specific code to *filter* the tag.  All the ...Tag handler
        // objects are derived from CHtmlElement.
        //
        // Tags that are handled by the HTML scanner and generate no output
        // may not require an entry in _tagHandler.
        //
        // I haven't figured out why multiple object instances are required
        // for e.g. Heading1, Heading2, or for that matter why multiple tokens
        // are required for them in the first place.
        //
        _tagHandler.Add (AnchorToken, new CAnchorTag( *this, _serialStream ));
        _tagHandler.Add (AspToken, new CAspTag( *this, _serialStream ));
        _tagHandler.Add (CodePageToken, new CCodePageTag( *this, _serialStream ));
        _tagHandler.Add (MetaRobotsToken, new CMetaRobotsTag( *this, _serialStream ));
        _tagHandler.Add (CommentToken, new CParamTag( *this, _serialStream ));
        _tagHandler.Add (DeferToken, new CDeferTag( *this, _serialStream ));
        _tagHandler.Add (Heading1Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (Heading2Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (Heading3Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (Heading4Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (Heading5Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (Heading6Token, new CPropertyTag( *this, _serialStream ));
        _tagHandler.Add (HeadToken, new CHeadTag( *this, _serialStream ));
        _tagHandler.Add (IgnoreToken, new CIgnoreTag( *this, _serialStream ));
        _tagHandler.Add (InputToken, new CInputTag( *this, _serialStream ));
        _tagHandler.Add (MetaToken, new CMetaTag( *this, _serialStream ));
        _tagHandler.Add (ParamToken, new CParamTag( *this, _serialStream ));
        _tagHandler.Add (ScriptToken, new CScriptTag( *this, _serialStream ));
        _tagHandler.Add (StartOfFileToken, new CStartOfFileElement(*this, _serialStream));
        _tagHandler.Add (StyleToken, new CStyleTag( *this, _serialStream ));
        _tagHandler.Add (TextToken, new CTextElement( *this, _serialStream ));
        _tagHandler.Add (TitleToken, new CTitleTag( *this, _serialStream ));
        _tagHandler.Add (SpanToken, new CLangTag( *this, _serialStream ));
        _tagHandler.Add (ParagraphToken, new CLangTag( *this, _serialStream ));
        _tagHandler.Add (AbbrToken, new CLangTag( *this, _serialStream ));
        _tagHandler.Add (EmToken, new CLangTag( *this, _serialStream ));
        _tagHandler.Add (BodyToken, new CLangTag( *this, _serialStream ));

        // The order of the following tokens is important. In ~CTagHandler()
        // the instance of CHtmlElement is deleted only once if it is in consecutive
        // entries. The enum definition for the tokens needs to be consecutive.
        CHtmlElement *p = new CXMLTag( *this, _serialStream );
        _tagHandler.Add (HTMLToken, p);
        _tagHandler.Add (XMLToken, p);
        _tagHandler.Add (XMLNamespaceToken, p);
        _tagHandler.Add (DocPropToken, p);
        _tagHandler.Add (CustDocPropToken, p);
        _tagHandler.Add (XMLSubjectToken, p);
        _tagHandler.Add (XMLAuthorToken, p);
        _tagHandler.Add (XMLKeywordsToken, p);
        _tagHandler.Add (XMLDescriptionToken, p);
        _tagHandler.Add (XMLLastAuthorToken, p);
        _tagHandler.Add (XMLRevisionToken, p);
        _tagHandler.Add (XMLCreatedToken, p);
        _tagHandler.Add (XMLLastSavedToken, p);
        _tagHandler.Add (XMLTotalTimeToken, p);
        _tagHandler.Add (XMLPagesToken, p);
        _tagHandler.Add (XMLWordsToken, p);
        _tagHandler.Add (XMLCharactersToken, p);
        _tagHandler.Add (XMLTemplateToken, p);
        _tagHandler.Add (XMLLastPrintedToken, p);
        _tagHandler.Add (XMLCategoryToken, p);
        _tagHandler.Add (XMLManagerToken, p);
        _tagHandler.Add (XMLCompanyToken, p);
        _tagHandler.Add (XMLLinesToken, p);
        _tagHandler.Add (XMLParagraphsToken, p);
        _tagHandler.Add (XMLPresentationFormatToken, p);
        _tagHandler.Add (XMLBytesToken, p);
        _tagHandler.Add (XMLSlidesToken, p);
        _tagHandler.Add (XMLNotesToken, p);
        _tagHandler.Add (XMLHiddenSlidesToken, p);
        _tagHandler.Add (XMLMultimediaClipsToken, p);
        _tagHandler.Add (XMLShortHand, p);
        _tagHandler.Add (XMLIgnoreContentToken, p);

        _tagHandler.Add (XMLOfficeChildLink, p);


    //
    // Set the start state to StartOfFile mode
    //
    _pHtmlElement = _tagHandler.Get( StartOfFileToken );

}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::~CHtmlIFilter
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CHtmlIFilter::~CHtmlIFilter()
{
    delete[] _pAttributes;
    delete[] _pwszFileName;

    delete _pScanner;

    if (_pLanguageProperty != NULL)
    {
        FreeVariant (_pLanguageProperty);
        _pLanguageProperty = NULL;
    }

    if (_pMetaRobotsValue != NULL)
    {
        FreeVariant (_pMetaRobotsValue);
        _pMetaRobotsValue = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::BindRegion
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- the region of text to be mapped to a moniker
//              [riid]    -- Interface id
//              [ppunk]   -- the interface
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::BindRegion( FILTERREGION origPos,
                                                  REFIID riid,
                                                  void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_HtmlIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::IsDirty()
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//                              All this does is remember the filename; nothing actually
//                              happens until Init() is called.
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Load( LPCWSTR psszFileName, DWORD dwMode )
{
    if ( 0 == psszFileName )
        return E_INVALIDARG;

    if ( _pwszFileName != 0 )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    _xStream.Free();

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    SCODE sc = S_OK;
    try
    {
        unsigned cLen = wcslen( psszFileName ) + 1;
        _pwszFileName = new WCHAR[cLen];
        wcscpy( _pwszFileName, psszFileName );

        _fNonHtmlFile = IsNonHtmlFile();
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR, "Exception 0x%x caught in CHtmlIFilter::Load", e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Save( LPCWSTR pszFileName, BOOL fRemember )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::SaveCompleted( LPCWSTR pszFileName )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetCurFile( LPWSTR * ppwszFileName )
{
    if ( _pwszFileName == 0 )
        return E_FAIL;

    unsigned cLen = wcslen( _pwszFileName ) + 1;
    *ppwszFileName = (WCHAR *)CoTaskMemAlloc( cLen*sizeof(WCHAR) );

    SCODE sc = S_OK;
    if ( *ppwszFileName )
        wcscpy( *ppwszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::Load, public
//
//  Synopsis:   Loads the IStream
//
//  Arguments:  [pStm] -- The stream to load
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Load( IStream * pStm )
{
    if ( 0 == pStm )
        return E_INVALIDARG;

    // Clear out any old state

    if ( 0 != _pwszFileName )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    _xStream.Free();
    _xStream.Set( pStm );
    _xStream->AddRef();

    return S_OK;
} //Load

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::Init
//
//  Synopsis:   Initializes instance of Html filter
//
//                              Called for each file to filter.
//                              At present time, for each file, CHtmlIFilter::Load() is first
//                              called to set the filename to filter, then Init() is called.
//
//                              The actual file open is buried in DetectCodePage().
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array pAttributes
//              [pAttributes] -- array of attributes
//              [pFlags]      -- Set to 0 version 1
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * pAttributes,
                                            ULONG * pFlags )
{
    SCODE sc = S_OK;

    *pFlags = 0;  // There are no OLE docfile properties for .htm files.

    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {

        _stkLangTags.Reset();
        _tagHandler.Reset();

#ifndef DONT_COMBINE_META_TAGS
        _deferredValues.Reset();
#endif
        _fReturnDeferredNow = FALSE;
        _fCodePageReturned = FALSE;
        if (_pLanguageProperty != NULL)
        {
            FreeVariant (_pLanguageProperty);
            _pLanguageProperty = NULL;
        }

        _fMetaRobotsReturned = FALSE;
        if (_pMetaRobotsValue != NULL)
        {
            FreeVariant (_pMetaRobotsValue);
            _pMetaRobotsValue = NULL;
        }

        _fFilterContent = FALSE;
        _fFilterProperties = FALSE;

        if ( _cAttributes > 0 )
        {
            delete[] _pAttributes;
            _pAttributes = 0;
            _cAttributes = 0;
        }

        if ( cAttributes > 0 )
        {
            //
            // Filter properties specified in pAttributes
                        // take precedence over grfFlags
            //
            _pAttributes = new(eThrow) CFullPropSpec[cAttributes];
            _cAttributes = cAttributes;

            CFullPropSpec *pAttrib = (CFullPropSpec *) pAttributes;

            if ( pAttrib == 0 )
                return E_FAIL;

            for (unsigned i=0; i<cAttributes; i++)
            {
                if ( pAttrib[i].IsPropertyPropid()
                     && pAttrib[i].GetPropertyPropid() == PID_STG_CONTENTS
                     && pAttrib[i].GetPropSet() == guidStoragePropset )
                {
                    _fFilterContent = TRUE;
                }

                _pAttributes[i] = pAttrib[i];
            }
        }
        else
        {
            //
            // Default is to filter contents only, no properties
            //
                        _fFilterContent = TRUE;

                        if ( grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES )
                        {
                                //
                                // Also filter all pseudo-properties including
                                // all meta tags, link anchors, script text etc.
                                //
                                _fFilterProperties = TRUE;
                        }
        }

                // Select the initial null element handler for start of file

                _pHtmlElement = _tagHandler.Get( StartOfFileToken );
        _ulChunkID = 0;

        //
        // Find the codepage of HTML file and initialize serial stream
        //

        SetDefaultLangInfo( DetectCodePage() );
    }
    catch( CException& e)
    {
        htmlDebugOut(( DEB_ERROR,
                       "Exception 0x%x caught in CHtmlIFilter::Init\n",
                       e.GetErrorCode() ));
        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::ChangeState
//
//  Synopsis:   Change the current Html element and hence the parsing algorithm
//
//  Arguments:  [pHtmlElemNewState]  -- New Html element to change to
//
//--------------------------------------------------------------------------

void CHtmlIFilter::ChangeState( CHtmlElement *pHtmlElemNewState )
{
    _pHtmlElement = pHtmlElemNewState;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::QueryElement
//
//  Synopsis:   Return HtmlElement corresponding to given token type
//
//  Arguments:  [eTokenType]  -- token type
//
//--------------------------------------------------------------------------

CHtmlElement *CHtmlIFilter::QueryHtmlElement( HtmlTokenType eTokType )
{
    return _tagHandler.Get( eTokType );
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetNextChunkId
//
//  Synopsis:   Return a brand new chunk id
//
//--------------------------------------------------------------------------

ULONG CHtmlIFilter::GetNextChunkId()
{
    Win4Assert( _ulChunkID != ULONG_MAX );

    return ++_ulChunkID;
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//                              Wrapper which dispatches to GetChunk for the current tag.
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetChunk( STAT_CHUNK * pStat )
{
    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_END_OF_CHUNKS;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _HtmlChunkPreFilter.GetChunk(_pHtmlElement, pStat);
                // sc = _pHtmlElement->GetChunk(pStat);
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetChunk\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    09-27-1999  KitmanH     return E_INVALIDARG if the buffer is
//                                      NULL or the length is zero.
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput )
{
    if ( 0 == awcOutput || 0 == pcwcOutput || *pcwcOutput <= 0 )
        return E_INVALIDARG;

    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_NO_TEXT;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _HtmlChunkPreFilter.GetText(_pHtmlElement, pcwcOutput, awcOutput);
                // sc = _pHtmlElement->GetText(pcwcOutput, awcOutput);
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetText\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CHtmlIFilter::GetValue( VARIANT ** ppPropValue )
{
    //
    // IE workaround, don't filter non-Html files such as .gif
    //
    if ( _fNonHtmlFile )
        return FILTER_E_NO_VALUES;

    SCODE sc = S_OK;

    _se_translator_function tf = _set_se_translator( SystemExceptionTranslator );

    try
    {
        sc = _HtmlChunkPreFilter.GetValue(_pHtmlElement, ppPropValue);
                // sc = _pHtmlElement->GetValue(ppPropValue);
    }
    catch( CException& e )
    {
        htmlDebugOut(( DEB_ERROR,
                       "Caught exception 0x%x in CHtmlIFilter::GetValue\n",
                       e.GetErrorCode() ));

        sc = GetOleError( e );
    }

    _set_se_translator( tf );

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::IsStopToken
//
//  Synopsis:   Check if given token is a token that should stop further
//              scanning and be processed.  This just returns a flag
//                              from the PTagEntry.  The requirement is that tags having
//                              any special syntax must be stop tags whether they are
//                              filtered or not, to ensure that the parse is correct
//                              either way.  Other tags are stop tags only if they are
//                              filtered.
//
//  Arguments:  [token]  -- Given token
//
//--------------------------------------------------------------------------

BOOL CHtmlIFilter::IsStopToken( CToken& token )
{
        // The following must always be stop tokens to correctly parse the HTML.

        switch (token.GetTokenType())
        {
        case IgnoreToken:       // Must be a stop to actually ignore spanned text
        case CommentToken:      // ... to correctly find the "-->"
        case AspToken:          // ... to find the "%>"
        case EofToken:          // Must always be handled
        case HeadToken:
        case ScriptToken:       // script element body is not HTML syntax
        case StyleToken:        // style element body is not HTML syntax
        case MetaToken:         // Must be a stop since meta tags must be parsed
                                                // in order to test against the attributes list.
        case HTMLToken:                         // Stop in order to recognize Office 9 XML namespace
        case XMLNamespaceToken:         // Stop in order to recognize Office 9 XML namespace
        case DocPropToken:                      // Stop to set state in XML tag handler
        case CustDocPropToken:          // Stop to set state in XML tag handler
        case XMLShortHand:                      // Stop to extract custom property name
        case XMLIgnoreContentToken:     // Stop to eat text
        case ParagraphToken:            // Stop to set the lang info
        case SpanToken:                 // Stop to set the lang info
        case AbbrToken:                 // Stop to set the lang info
        case EmToken:                   // Stop to set the lang info
        case BodyToken:                   // Stop to set the lang info
        case XMLToken:                  // Stop in order to recognize Office namespace
            return TRUE;
        }

        PTagEntry pT = token.GetTagEntry();

        if (pT && pT->IsStopToken() )
        {
                // If filtering all attributes, the tag entry determines if it's a
                // stop token.

                if ( _fFilterProperties )
                        return TRUE;

                // It's a stop token if it is specifically requested
                // in the attributes list, no matter what the token type.

                for ( unsigned i=0; i<_cAttributes; i++ )
                        if ( pT->IsMatchProperty (_pAttributes[i]) )
                                return TRUE;
        }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::IsLangInfoToken
//
//  Synopsis:   Check if Given token is lang information related token
//
//  Arguments:  [token]  -- Given token
//
//  Returns:    TRUE if token is lang info related, FALSE otherwise
//
//  History:    23-Dec-1999     KitmanH     Created
//
//--------------------------------------------------------------------------

BOOL CHtmlIFilter::IsLangInfoToken( CToken& token )
{
    switch (token.GetTokenType())
    {
    case ParagraphToken:
    case SpanToken:
    case AbbrToken:
    case EmToken:
    case BodyToken:
        return TRUE;
    default:
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlIFilter::IsNonHtmlFile
//
//  Synopsis:   Check if file being filtered has an extension such as .gif,
//              which means that the file is not an Html file
//
//--------------------------------------------------------------------------

BOOL CHtmlIFilter::IsNonHtmlFile()
{
    WCHAR *pwszExtension;

        if (_pwszFileName == NULL || _pwszFileName[0] == 0)
                return TRUE;

    for (int i=wcslen(_pwszFileName)-1; i>=0; i-- )
    {
        if ( _pwszFileName[i] == L'.' )
        {
            pwszExtension = &_pwszFileName[i+1];
            break;
        }
    }

    //
    // No extension, then assume it's an html file
    //
    if ( i < 0 )
        return FALSE;

    switch( pwszExtension[0] )
    {
    case L'a':
    case L'A':
        if ( _wcsicmp( pwszExtension, L"aif" ) == 0
             || _wcsicmp( pwszExtension, L"aifc" ) == 0
             || _wcsicmp( pwszExtension, L"aiff" ) == 0
             || _wcsicmp( pwszExtension, L"art" ) == 0
             || _wcsicmp( pwszExtension, L"au" ) == 0 )
        {
            return TRUE;
        }

        break;

    case L'g':
    case L'G':
        if ( _wcsicmp( pwszExtension, L"gif" ) == 0 )
            return TRUE;

        break;

    case L'j':
    case L'J':
        if ( _wcsicmp( pwszExtension, L"jfif" ) == 0
             || _wcsicmp( pwszExtension, L"jpe" ) == 0
             || _wcsicmp( pwszExtension, L"jpeg" ) == 0
             || _wcsicmp( pwszExtension, L"jpg" ) == 0 )
        {
            return TRUE;
        }

        break;

    case L's':
    case L'S':
        if ( _wcsicmp( pwszExtension, L"snd" ) == 0 )
            return TRUE;

        break;

    case L'x':
    case L'X':
        if ( _wcsicmp( pwszExtension, L"xbm" ) == 0 )
            return TRUE;

        break;

    default:
        return FALSE;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::DetectCodePage, private
//
//  Synopsis:   Get the code page from the HTML file and
//              initialize the serial stream
//              This also does the actual file open on _serialStream for the
//              rest of the filter.
//
//  Returns:    the locale detected
//
//  History:    10-Jan-2000     KitmanH     Added this note
//
//--------------------------------------------------------------------------

LCID CHtmlIFilter::DetectCodePage()
{
    _ulCodePage = 0;
    LCID locale = LOCALE_NEUTRAL;

    //
    // Steps for detecting the code page of an HTML file :
    //
    //   0. Do full auto detection to get code page and language(s)
    //   1. Look for charset and/or locale in meta tags, and override
    //              auto-detected values if present.
    //   2. If charset/code page is still not known, use code page for the
    //      server's default locale.
    //

    if ( 0 != _pwszFileName )
        _serialStream.Init( _pwszFileName );
    else
        _serialStream.Init( _xStream.GetPointer() );

    _serialStream.CheckForUnicodeStream();

    BOOL fUnicode = _serialStream.InitAsUnicodeIfUnicode();

    _codePageRecognizer.Init( *this, _serialStream );

        // Detect by scanning for tags.
        // Constructing the object scans the stream.

    if ( _codePageRecognizer.FNoIndex() )
    {
        _fNonHtmlFile = TRUE;           // NOTE: noindex is presently not detected
        return locale;
    }


        // If the doc contains an explicit locale-identifying tag, use it
        // instead of the detected language.  Note that it's used only for
        // setting the chunk locale, and does not cancel using the statistical
        // result for the searchable language tags.

    if ( _codePageRecognizer.FLocaleFound() )
        locale = _codePageRecognizer.GetLocale();

    //
    //  For Unicode, there no point in looking for the charset tag.
    //  Even if there is one, it doesn't make too much sense to use
    //  it because we already know the file is native Unicode.
    //
    if(_serialStream.InitAsUnicodeIfUnicode())
    {
        //
        //  Why am I calling InitAsUnicodeIfUnicode if I have already called
        //  InitAsUnicodeIfUnicode above?
        //  The CodePageRecognizer reads the stream to find the locale
        //  (even though it is called the CodePageRecognizer). Because
        //  of the read done, it is necessary to call some form of
        //  Init method, just like at the end of this DetectCodePage
        //  method.
        //

        if(!IsValidLocale(locale, LCID_SUPPORTED))
        {
            locale = GetSystemDefaultLCID();
        }

        return locale;
    }


        // If the doc has an explicit charset tag, use it instead of the
        // detected code page.

    if ( _codePageRecognizer.FCodePageFound() )
        _ulCodePage = _codePageRecognizer.GetCodePage();

    if ( JIS_CODEPAGE == _ulCodePage )
        _ulCodePage = CODE_JPN_JIS;
    else if ( EUC_CODEPAGE == _ulCodePage )
        _ulCodePage = CODE_JPN_EUC;

        // If the charset is known but not the locale, try to get a default
        // locale from the charset.

    if ( _ulCodePage != 0 &&
         ( locale == LOCALE_NEUTRAL || !IsValidLocale( locale, LCID_SUPPORTED )) )
    {
        switch ( _ulCodePage )
        {

        case SHIFT_JIS_CODEPAGE:
        case CODE_JPN_EUC:
        case CODE_JPN_JIS:
            locale = MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        case 949:
        case 51949:
        case 1361:
            locale = MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        case 936:
        case 950:
            locale = MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        case 20866:
        case 1251:
        case 28595:
            locale = MAKELCID(MAKELANGID(LANG_RUSSIAN, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        case 1253:
            locale = MAKELCID(MAKELANGID(LANG_GREEK, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        case 1255:
            locale = MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT),
                              SORT_DEFAULT);
            break;

        default:
            break;
        }

        if ( locale != LOCALE_NEUTRAL && !IsValidLocale( locale, LCID_SUPPORTED ) )
            locale = GetSystemDefaultLCID();
    }


    // If the locale is not installed, filter the doc
    // anyway, using the system defaults.

    if ( (locale == LOCALE_NEUTRAL && !_codePageRecognizer.FLocaleFound()) ||
                ( locale != LOCALE_NEUTRAL && !IsValidLocale( locale, LCID_SUPPORTED )) )
    {
        locale = GetSystemDefaultLCID();
    }

    // If the code page is still not known, use the default code page
    // for the locale.

    if ( _ulCodePage == 0 )
    {
        _ulCodePage = LocaleToCodepage( locale );
    }

    if ( ( _ulCodePage == CODE_JPN_JIS || _ulCodePage == CODE_JPN_EUC ) )
    {
        //
        // Code page is known, but requires explicit preconversion
        //
        IMultiLanguage2 *pMultiLanguage2 = 0;
        if(S_OK == _codePageRecognizer.GetIMultiLanguage2(&pMultiLanguage2) &&
            IsValidCodePage(SHIFT_JIS_CODEPAGE))
        {
            Win4Assert(pMultiLanguage2);
            XInterface<IMultiLanguage2> xMultiLanguage2;
            xMultiLanguage2.Set(pMultiLanguage2);
            pMultiLanguage2 = 0;
            if(CODE_JPN_JIS == _ulCodePage)
            {
                ConvertJISToSJISUsingMLang(xMultiLanguage2.GetPointer());
            }
            else if(CODE_JPN_EUC == _ulCodePage)
            {
                ConvertEUCToSJISUsingMLang(xMultiLanguage2.GetPointer());
            }
            _ulCodePage = SHIFT_JIS_CODEPAGE;
            return locale;
        }
        else
        {
            htmlDebugOut(( DEB_ERROR, "Cannot apply conversion to S-JIS\n" ));

            // In lieu of conversion, refuse to index it
            _fNonHtmlFile = TRUE;
            return locale;
        }
    }

    //
    //  From RichardS
    //  There was a bug in Internet Explorer 4.0 (actually MLANG.DLL in IE 4.0)
    //  where 1252 and 1254 encoded content was tagged incorrectly as iso-8859-1
    //  and iso-8859-9 respectively.  There were also bugs in earlier versions of
    //  Office and other applications that do the same.  For example, the Netscape
    //  Communicator 4.7 will tag 1252 encoded content as iso-8859-1.  To work
    //  around these problems the codepage conversion code in the 5.0 and later
    //  versions of MLANG unconditionally treats all requests to convert from
    //  28591 and 28599 to Unicode as if they were requests to convert from 1252
    //  and 1254 respectively.  For code points in the 0x00 to 0x7F and 0xA0 to 0xFF
    //  range there is no difference.  For code points in the 0x80 to 0x9F range
    //  these get converted as if they were the characters in the Windows encodings
    //  instead of being invalid as they are in the ISO encodings.
    //
    if(28591 == _ulCodePage)
    {
        _ulCodePage = 1252;
    }
    else if(28599 == _ulCodePage && IsValidCodePage(1254))
    {
        //
        //  It is possible to install the NLS file for 28599 and
        //  not install the one for 1254.
        //
        _ulCodePage = 1254;
    }

    // If the code page is not installed, try some substitutions,
    // and ultimately ignore the document.

    if ( IsValidCodePage( _ulCodePage ) == FALSE )
    {
        if ( 20127 == _ulCodePage )
            _ulCodePage = 1252;
    }

    if ( CP_UTF8 != _ulCodePage &&
            FALSE == IsValidCodePage( _ulCodePage ) )
    {

        // work here: figure out how to write gather log
        htmlDebugOut(( DEB_ERROR, "not filtering doc because its code page is not installed\n" ));
        _fNonHtmlFile = TRUE;
        return locale;
    }

    _serialStream.Init( _ulCodePage );

    return locale;
}

//+-------------------------------------------------------------------------------------------------
//
//  Function:   CHtmlIFilter::ConvertEUCToSJISUsingMLang
//
//  Synopsis:   Convert EUC to SJIS using MLang
//
//  Returns:    N/A
//
//  Throw:      No
//
//  Arguments:
//  [IMultiLanguage2 *ppMultiLanguage2] - [in]  The interface pointer.
//
//  History:    08/23/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CHtmlIFilter::ConvertEUCToSJISUsingMLang(IMultiLanguage2 *pMultiLanguage2)
{
    InternalConvertToSJISUsingMLang(EUC_CODEPAGE, pMultiLanguage2);
}

//+-------------------------------------------------------------------------------------------------
//
//  Function:   CHtmlIFilter::ConvertJISToSJISUsingMLang
//
//  Synopsis:   Convert JIS to SJIS using MLang
//
//  Returns:    N/A
//
//  Throw:      No
//
//  Arguments:
//  [IMultiLanguage2 *ppMultiLanguage2] - [in]  The interface pointer.
//
//  History:    08/23/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CHtmlIFilter::ConvertJISToSJISUsingMLang(IMultiLanguage2 *pMultiLanguage2)
{
    InternalConvertToSJISUsingMLang(JIS_CODEPAGE, pMultiLanguage2);
}

//+-------------------------------------------------------------------------------------------------
//
//  Function:   CHtmlIFilter::InternalConvertToSJISUsingMLang
//
//  Synopsis:   Convert EUC/JIS to SJIS using MLang. Like ConvertToSJIS, but uses MLang instead.
//
//  Returns:    N/A
//
//  Throw:      No
//
//  Arguments:
//  [ULONG ulCodePage]                  - [in]  The code page, 50220 for JIS, 51932 for EUC.
//  [IMultiLanguage2 *ppMultiLanguage2] - [in]  The interface pointer.
//
//  History:    08/23/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CHtmlIFilter::InternalConvertToSJISUsingMLang(
    ULONG ulCodePage,
    IMultiLanguage2 *pMultiLanguage2)
{
    Win4Assert(JIS_CODEPAGE == ulCodePage || EUC_CODEPAGE == ulCodePage);

    //
    // Assume a max file size of 2^32 (Query cannot handle files more than a few MB,
    //                                 and the conversion function below takes ints only)
    //
    UINT uiSizeIn = _serialStream.GetFileSize();

    //
    // Memory map entire file
    //
    _serialStream.MapAll();

    //
    // Create a temporary memory-mapped file to hold the converted S-JIS chars
    //
    _serialStream.CreateTempFileMapping( uiSizeIn );

    BYTE *pInBuf = (BYTE *) _serialStream.GetBuffer();
    BYTE *pOutBuf = (BYTE *) _serialStream.GetTempFileBuffer();

    DWORD dwMode = 0;
    UINT uiSizeOut = uiSizeIn;
    HRESULT hr = pMultiLanguage2->ConvertString(&dwMode,
                                                ulCodePage,
                                                SHIFT_JIS_CODEPAGE,
                                                pInBuf,
                                                &uiSizeIn,
                                                pOutBuf,
                                                &uiSizeOut);
    if(S_OK != hr)
    {
        htmlDebugOut((DEB_ERROR, "Conversion to S-JIS returned failed\n"));
        throw(CException(E_FAIL));
    }

    _serialStream.SetTempFileSize((ULONG)uiSizeOut);
    _serialStream.Rewind();
    _serialStream.UnmapTempFile();

    //
    // Make serial stream read from temporary S-JIS file
    //
    _serialStream.InitWithTempFile();
}


//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetLCIDFromString, public
//
//  Synopsis:   translate the input string into locale
//
//  Returns:    locale
//
//  History:    11-Jan-2000     KitmanH     Created
//
//--------------------------------------------------------------------------

LCID CHtmlIFilter::GetLCIDFromString( WCHAR *wcsLocale )
{
    return _codePageRecognizer.GetLCIDFromString( wcsLocale );
}

//+-------------------------------------------------------------------------
//
//  Member:     CLangTagStack::SetDefaultLangInfo, public
//
//  Synopsis:   sets the default locale
//
//  Arguments:  [locale] -- locale
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CLangTagStack::SetDefaultLangInfo( LCID locale )
{
    Win4Assert( 0 == _stkLangTags.Count() );
    _defaultLocale = locale;
}

//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetCurrentLocale, public
//
//  Synopsis:   Get the current locale from the lang info stack
//
//  Returns:    The current locale
//
//  History:    11-Jan-2000     KitmanH     Created
//
//--------------------------------------------------------------------------

LCID CHtmlIFilter::GetCurrentLocale()
{
    return _stkLangTags.GetCurrentLocale();
}

//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::GetDefaultLocale, public
//
//  Synopsis:   Get the default locale from the lang info stack
//
//  Returns:    The default locale
//
//  History:    12-Jan-2000     KitmanH     Created
//
//--------------------------------------------------------------------------

LCID CHtmlIFilter::GetDefaultLocale()
{
    return _stkLangTags.GetDefaultLocale();
}

//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::SetDefaultLangInfo, public
//
//  Synopsis:   sets the default locale
//
//  Arguments:  [locale] -- locale
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CHtmlIFilter::SetDefaultLangInfo( LCID locale )
{
    _stkLangTags.SetDefaultLangInfo( locale );
}

//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::PushLangTag, public
//
//  Synopsis:   Push the lang tag onto the stack
//
//  Arguments:  [eTokenType] -- Token type
//              [fLangAttr]  -- Is there a lang attribute in this Tag
//              [locale]     -- Locale
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CHtmlIFilter::PushLangTag( HtmlTokenType eTokenType,
                                BOOL fLangAttr,
                                LCID locale )
{
    _stkLangTags.Push( eTokenType, fLangAttr, locale );
}

//+-------------------------------------------------------------------------
//
//  Member:     CHtmlIFilter::PopLangTag, public
//
//  Synopsis:   Pops the lang tag of the type eTokenType off the stack.
//
//  Arguments:  [eTokenType] -- Token type
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CHtmlIFilter::PopLangTag( HtmlTokenType eTokenType )
{
    _stkLangTags.Pop( eTokenType );
}


//+-------------------------------------------------------------------------
//
//  Member:     CLangTagStack::GetCurrentLocale, public
//
//  Synopsis:   Gets the current locale from the lang info stack
//
//  Returns:    The current locale
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

LCID CLangTagStack::GetCurrentLocale()
{
    unsigned uCount = _stkLangTags.Count();

    if ( -1 == _iCurrentLang || 0 == uCount )
        return _defaultLocale;

    Win4Assert( _iCurrentLang < (int)uCount );
    Win4Assert( _stkLangTags.Get(_iCurrentLang)->fLangAttr );
    Win4Assert( !_stkLangTags.Get(_iCurrentLang)->fTagPopped );

    return _stkLangTags.Get(_iCurrentLang)->locale;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLangTagStack::Push, public
//
//  Synopsis:   Pushes the lang tag on to the stack.
//
//  Arguments:  [eTokenType] -- Token type
//              [fLangAttr]  -- Is the lang attribute specified
//              [locale]     -- locale
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CLangTagStack::Push( HtmlTokenType eTokenType, BOOL fLangAttr, LCID locale )
{
    SLangTag * pLangTag = new(eThrow) SLangTag;
    pLangTag->eTokenType = eTokenType;
    pLangTag->fTagPopped = FALSE;
    pLangTag->fLangAttr = fLangAttr;
    pLangTag->locale = locale;

    XPtr<SLangTag> xTag( pLangTag );

    _stkLangTags.Push( pLangTag );

    xTag.Acquire();

    if ( fLangAttr )
    {
        _iCurrentLang = _stkLangTags.Count() - 1;
        htmlDebugOut(( DEB_ITRACE, "Push::_iCurrentLang is now %d\n", _iCurrentLang ));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CLangTagStack::Pop, public
//
//  Synopsis:   Pops the lang tag of the token type off the stack.
//              If the tag of the specified is not on top of the stack,
//              mark the stack element fpoped
//
//  Arguments:  [eTokenType] -- Token type
//
//  History:    25-Apr-2001     KitmanH     Created
//
//--------------------------------------------------------------------------

void CLangTagStack::Pop( HtmlTokenType eTokenType )
{
    if ( _stkLangTags.Count() < 1 )
        return;

    Win4Assert( !_stkLangTags.GetLast()->fTagPopped );

    unsigned uPoppedPos = 0;         // The position of the element popped
    SLangTag * pTopTag = _stkLangTags.GetLast();
    if ( eTokenType == pTopTag->eTokenType )
    {
        _stkLangTags.DeleteTop();
        uPoppedPos = _stkLangTags.Count();
        htmlDebugOut(( DEB_ITRACE, "Pop::Pop top element\n" ));
    }
    else
    {
        for ( int i=_stkLangTags.Count() - 1; i >= 0; i-- )
        {
            SLangTag * pLangTag = _stkLangTags.GetPointer(i);

            if ( eTokenType == pLangTag->eTokenType )
            {
                if ( !pLangTag->fTagPopped )
                {
                    // mark the tag popped
                    htmlDebugOut(( DEB_ITRACE, "Pop::Marking %dth stack element popped\n", i ));
                    pLangTag->fTagPopped = TRUE;
                    uPoppedPos = i;
                    break;
                }
            }
        }
    }

    // clean out the poped elements that are still at top of the stack
    while ( _stkLangTags.Count() > 0 && _stkLangTags.GetLast()->fTagPopped )
    {
        htmlDebugOut(( DEB_ITRACE, "Pop::Clean up on the top of the stack\n" ));
        _stkLangTags.DeleteTop();
    }

    // Did we just pop the current lang?
    if ( _iCurrentLang == uPoppedPos )
    {
        // current lang was popped, need to find new _iCurrentLang
        htmlDebugOut(( DEB_ITRACE, "Pop::Default Lang was poped from top\n" ));
        unsigned uCount = _stkLangTags.Count();
        unsigned uCount2 = uPoppedPos > uCount ? uCount : uPoppedPos;

        htmlDebugOut(( DEB_ITRACE, "Pop::Start finding new current lang from %d\n", uCount2 ));
        while ( uCount2 > 0 )
        {
            uCount2--;
            SLangTag * pTag = _stkLangTags.Get( uCount2 );
            if ( pTag->fLangAttr && !pTag->fTagPopped )
            {
                _iCurrentLang = uCount2;
                htmlDebugOut(( DEB_ITRACE, "Pop::Now _iCurrentLang is %d\n", _iCurrentLang ));
                return;
            }
        }

        if ( 0 == uCount2 )
            _iCurrentLang = -1;

        htmlDebugOut(( DEB_ITRACE, "Pop::Now _iCurrentLang is %d\n", _iCurrentLang ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\htmlelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       htmlelem.cxx
//
//  Contents:   Base class for Html element
//
//  Classes:    CHtmlElement
//
//  History:    25-Apr-97       BobP            Rewrote SwitchToNextHtmlElement() to
//                                              sequence through tag entry chain
//                                              and loop on InitStatChunk == FALSE;
//                                              added SwitchToSavedElement().
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::CHtmlElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]     -- Reference to IFilter
//              [mmSerialStream]  -- Reference to input stream
//
//--------------------------------------------------------------------------

CHtmlElement::CHtmlElement( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : _htmlIFilter(htmlIFilter),
      _serialStream(serialStream),
          _scanner(htmlIFilter.GetScanner())
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::Reset
//
//  Synopsis:   Re-initializer
//
//--------------------------------------------------------------------------

void
CHtmlElement::Reset( )
{
        _Token = CToken();
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat.
//
//                              This is the default implementation for tags for which all
//                              filter output is returned in a single chunk emitted at the
//                              time the start-tag is processed.  So, the next GetChunk()
//                              call is for the next input element, which it reads and
//                              switches the main state machine to.
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = SwitchToNextHtmlElement( pStat );

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetText
//
//  Synopsis:   Default implementation for handlers that don't return
//                              CHUNK_TEXT.
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    return FILTER_E_NO_TEXT;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetValue
//
//  Synopsis:   Default implementation for for handlers that don't return
//                              CHUNK_VALUE.
//
//  Arguments:  [ppPropValue]  -- Value returned here
//
//--------------------------------------------------------------------------
SCODE CHtmlElement::GetValue( VARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::InitFilterRegion
//
//  Synopsis:   Initializes the filter region of a chunk to default value
//
//  Arguments:  [idChunkSource]  -- Id of source chunk
//              [cwcStartSource] -- Offset of source text in chunk
//              [cwcLenSource]   -- Length of source text in chunk
//
//--------------------------------------------------------------------------

void CHtmlElement::InitFilterRegion( ULONG& idChunkSource,
                                     ULONG& cwcStartSource,
                                     ULONG& cwcLenSource )
{
    idChunkSource = 0;
    cwcStartSource = 0;
    cwcLenSource = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SwitchToNextHtmlElement
//
//  Synopsis:   Switch to the next parsing algorithm for the current tag;
//                              read from input to get the next tag as necessary.
//
//                              If the next document element is plain text, the "token" is
//                              TextToken, and it's essential that no functions be called
//                              that depend on actually being inside an HTML tag.
//
//                              This is the main state-machine dispatch, that sets
//                              pHtmlElement to the handler for the token type of
//                              the next tag or body text, whichever is found.
//
//  Arguments:  [pStat] -- chunk information returned here
//
// 
// Notes:
// 
// This is called by GetChunk() from every tag handler for EVERY element HTML
// type, AFTER a tag name has been read but before further input is read, to 
// dispatch to the appropriate parsing / filtering handler for that tag.
// 
// The handler(s) in question then read further input as required, possibly
// reading far beyond the current tag when the semantics of the initial tag
// require that, e.g. <noframe>.
//
// The main state machine state is _pHtmlElement, which points to a 
// CHtmlElement-derived object that provides implementations of
// GetChunk(), GetText() and GetValue() specific to that tag type.
// 
// The tag entry handler chain supports a single tag invoking multiple
// handlers, each one of which potentially returns a chunk.  It does not
// directly support a SINGLE handler returning MULTIPLE chunks for a
// single tag.  To do that, the tag handler must implement its own state
// machine e.g. CMetaTag, CPropertyTag, to sequence through the multiple
// GetChunk() calls.
// 
// This also returns deferred meta tags as one chunk per unique name= 
// parameter.  The tags are returned after </head> is read, or at EOF if
// no </head> is found.  Note that any tags that would ordinarily be deferred,
// if found after </head>, are returned immediately instead of being deferred
// until EOF.
// 
//--------------------------------------------------------------------------

SCODE CHtmlElement::SwitchToNextHtmlElement( STAT_CHUNK *pStat )
{
        SCODE sc;

        // Read and parse input until the InitStatChunk() for a given tag and
        // handler indicates there is data to return.

        do {
                // Before reading more input, check if more handlers need to be called
                // to potentially return more chunks for the tag already in the
                // scanner's buffer.  Additional handlers are indicated by the chain
                // at GetTagEntry()->GetNext().

                if (GetTagEntry() && GetTagEntry()->GetNext() != NULL)
                {
                        // Switch the current _Token to use the next handler, if there is
                        // one, in its PTagEntry chain for the tag alread in the
                        // scanner's buffer.

                        SetTagEntry (GetTagEntry()->GetNext());

                        SetTokenType (GetTagEntry()->GetTokenType());
                }
                else if ( _htmlIFilter.GetCodePageReturnedYet() == FALSE &&
                                  _htmlIFilter.FFilterProperties() == TRUE )
                {
                        // Return the code page chunk only if all properties are filtered

                        _htmlIFilter.SetCodePageReturnedYet(TRUE);
                        SetTagEntry (NULL);
                        SetTokenType (CodePageToken);
                }
                else if ( _htmlIFilter.GetMetaRobotsValue() != NULL &&
                                  _htmlIFilter.GetMetaRobotsReturnedYet() == FALSE )
                {
                        // Return the robots tag only if all properties are filtered
                        // or if this property is specifically requested

                        _htmlIFilter.SetMetaRobotsReturnedYet(TRUE);
                        SetTagEntry (NULL);
                        SetTokenType (MetaRobotsToken);
                }
                else if ( _htmlIFilter.ReturnDeferredValuesNow() && 
                                  _htmlIFilter.AnyDeferredValues() )
                {
                        // To return any deferred meta tags, switch to the "defer" handler

                        SetTagEntry (NULL);
                        SetTokenType (DeferToken);
                } 
                else 
                {
                        // Otherwise, read the next input element and fill in the current
                        // element's token with its info (token type, IsStart, tag entry)
                        // and set its PTagEntry to the first handler in the chain.

                        _scanner.SkipCharsUntilNextRelevantToken( GetToken() );
                }

        } while (ProcessElement (pStat, &sc) == FALSE );

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::ProcessElement
//
//  Synopsis:   Common code for SwitchToNextHtmlElement, SwitchToSavedElement.
//
//                              The scanner has called ScanTagName() for this tag
//                              and _Token has been set with its HtmlTokenType and PTagEntry.
//
//  Arguments:  [pStat] -- chunk information returned here
//              [psc] -- return the SCODE here, 
//
//  Return value:  TRUE if the element produces output which needs to be
//                 returned, in which case *psc is set to the SCODE to return.
//                                 FALSE indicates the element produces no output, and further
//                                 input must be read prior to returning from GetChunk.
// 
//+-------------------------------------------------------------------------
BOOL CHtmlElement::ProcessElement( STAT_CHUNK *pStat, SCODE *psc )
{
        CHtmlElement *pHtmlElemNext;

        if ( GetTokenType() == EofToken )
        {
                // If EOF is found before </head>, return deferred values first.

                if ( _htmlIFilter.AnyDeferredValues() )
                {
                        SetTagEntry (NULL);
                        SetTokenType (DeferToken);
                }
                else
                {
                        *psc = FILTER_E_END_OF_CHUNKS;
                        return TRUE;
                }
        }

        // Get the CHtmlElement-derived handler object for this token type

        pHtmlElemNext = _htmlIFilter.QueryHtmlElement( GetTokenType() );
        Win4Assert( pHtmlElemNext );

        // Save a  *Copy*  of token in the next handler object
    CToken & token = GetToken();    
        pHtmlElemNext->SetToken ( token );

    if ( _htmlIFilter.IsLangInfoToken( token ) )
    {
        // no chunk is emitted for this type of token
        CLangTag * pLangTag = (CLangTag *)pHtmlElemNext; 
        pLangTag->PushLangTag();
        return FALSE;
    }

        // Do whatever processing is needed to set up the STAT_CHUNK for the
        // first chunk GetChunk() will return for this tag.


        if (pHtmlElemNext->InitStatChunk( pStat ) == TRUE)
        {
                // There is data to return for this element.
                // Set the "state machine" to dispatch client calls to that handler
                // object until the machine switches on to the next input element.

                _htmlIFilter.ChangeState( pHtmlElemNext );
                
                *psc = S_OK;
                return TRUE;
        }

        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SwitchToSavedElement
//
//  Synopsis:   Switch to the next parsing algorithm for a tag that the
//                              scanner has read, but was not processed by that GetChunk()
//                              call.  
//
//                              The scanner has already called ScanTagName() for this tag
//                              and _Token has been set with its HtmlTokenType and
//                              PTagEntry, but the state machine has not yet switched to it.
//
//                              If ProcessElement finds data to return, we're done, return it.
// 
//                              Otherwise, fall through to SwitchToNextHtmlElement() to
//                              read and dispatch as usual until some handler returns data.
// 
//  Arguments:  [pStat] -- chunk information returned here
// 
//+-------------------------------------------------------------------------

SCODE CHtmlElement::SwitchToSavedElement( STAT_CHUNK *pStat )
{
        SCODE sc;

        if ( ProcessElement (pStat, &sc) == TRUE)
                return sc;

        return SwitchToNextHtmlElement (pStat);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SkipRemainingTextAndGotoNextChunk
//
//  Synopsis:   Move to the next chunk
//
//                              This exists to handle the case where the external caller
//                              calls GetChunk() BEFORE GetText() or GetValue() has returned
//                              all the text that needs to be read from the input and/or is
//                              already bufferred.  It's not part of the normal path
//                              when filtering content and the caller calls GetText()
//                              until it returns FILTER_S_LAST_TEXT.
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::SkipRemainingTextAndGotoNextChunk( STAT_CHUNK *pStat )
{
    ULONG ulBufSize  = TEMP_BUFFER_SIZE;

    //
    // Loop until text in current chunk has been exhausted
    //
    SCODE sc = GetText( &ulBufSize, _aTempBuffer );
    while ( SUCCEEDED(sc) && FILTER_S_LAST_TEXT != sc )
    {
        sc = GetText( &ulBufSize, _aTempBuffer );
    }

    sc = GetChunk( pStat );

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlElement::SkipRemainingValueAndGotoNextChunk
//
//  Synopsis:   Move to the next chunk
//
//              This exists to handle the case where the external caller
//              calls GetChunk() BEFORE GetValue() has returned
//              all the text that needs to be read from the input.  
//              It's not part of the normal path when filtering content 
//              and the caller calls GetValue() until it returns 
//              FILTER_S_LAST_VALUES.
//
//  Arguments:  [pStat] -- chunk information returned here
//
//  History:    10-14-1999  KitmanH     Created
//
//  Note:       The calls to CoTaskMemFree depends on what type of values
//              are returned in all the GetValue methods.
//
//--------------------------------------------------------------------------

SCODE CHtmlElement::SkipRemainingValueAndGotoNextChunk( STAT_CHUNK *pStat )
{
    //
    // Calling GetValue here results into calls a pair of calls to 
    // CoTaskMemAlloc and CoTaskMemFree. Calling this function instead 
    // of calling GetValue directly does not save time nor memory.  
    // This function should avoid calling GetValue or set a flag for 
    // GetValue to not allocation any memory for pPropValue
    //

    PROPVARIANT * pPropValue = 0;
    SCODE sc = GetValue( &pPropValue );
     
    if( SUCCEEDED(sc) && pPropValue )
    {
        if ( VT_LPWSTR == pPropValue->vt ) 
            CoTaskMemFree( pPropValue->pwszVal );

        CoTaskMemFree( pPropValue );
    }

    sc = GetChunk( pStat );

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTagHandler::Reset
//
//  Synopsis:   Reset each registered tag handler
//
//                              Defined here to put it in the scope of CHtmlElement
//
//+-------------------------------------------------------------------------

void
CTagHandler::Reset (void) 
{
        for (ULONG i = 0; i < HtmlTokenCount; i++) {
                if ( Get(i) )
                        Get(i) -> Reset();
        }
}

//+-------------------------------------------------------------------------
//
//  Method:     CTagHandler::~CTagHandler
//
//  Synopsis:   Reset each registered tag handler
//
//                              Defined here to put it in the scope of CHtmlElement
//
//+-------------------------------------------------------------------------

CTagHandler::~CTagHandler (void)
{
        // Delete tag handlers
        // This assumes if the same instance of the tag handler is used
        // for multiple tags, it is in consecutive entries
        CHtmlElement *p = 0;
        for (ULONG i = 0; i < HtmlTokenCount; i++)
        {
                if ( Get(i) != p )
                {
                        delete (p=Get(i));
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\htmlscan.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       htmlscan.cxx
//
//  Contents:   Scanner for html files
//
//  Classes:    CHtmlScanner
//
//  History:    25-Apr-97       BobP            Created state machines for parsing
//                                              parameters and comments; rewrote 
//                                              ScanTagName, ScanTagBuffer, ReadTag, 
//                                              ReadComment to recognize all correct
//                                              HTML syntax; added tag name hash
//                                              table lookup.
//                                                                              
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::CHtmlScanner
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Reference to Html filter
//              [serialStream]   -- Reference to input stream to scan
//
//--------------------------------------------------------------------------

CHtmlScanner::CHtmlScanner( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : _htmlIFilter(htmlIFilter),
      _serialStream(serialStream),
      _uLenTagBuf(TAG_BUFFER_SIZE),
      _cTagCharsRead(0),
          _fTagIsAlreadyRead(FALSE)
{
    _pwcTagBuf = new WCHAR[ TAG_BUFFER_SIZE ];
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::~CHtmlScanner
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CHtmlScanner::~CHtmlScanner()
{
    delete[] _pwcTagBuf;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::Peek_ParseAsTag
//
//  Synopsis:   Read ahead to determine how to parse '<'
//
//                              On entry, only the '<' has been read.
//
//                              If '<' or '</' is followed by a lexically valid tag name,
//                              it must be parsed as a tag even if the name is unknown.
//                              If not followed by a valid tag name, then it must be parse
//                              as contents text.  Read ahead to determine which case
//                              applies, and then call UnGetChar with whatever char(s)
//                              were read to restore the input stream to the same state
//                              as on entry.
//
//                              If EOF is read, return FALSE.
//
//  Returns:    TRUE if what follows should be parse as a tag.
//
//--------------------------------------------------------------------------
BOOL
CHtmlScanner::Peek_ParseAsTag ()
{
        BOOL fSlashRead = FALSE;

        if ( _serialStream.Eof() )
                return FALSE;

        WCHAR wch = _serialStream.GetChar();
        if ( wch == L'/' )
        {
                if ( _serialStream.Eof() )
                {
                        _serialStream.UnGetChar (wch);
                        return FALSE;
                }

                fSlashRead = TRUE;
                wch = _serialStream.GetChar();
        }

        _serialStream.UnGetChar( wch );
        if (fSlashRead)
                _serialStream.UnGetChar( L'/' );

        return wch == L'!' || wch == L'%' || wch == L'?' || iswalpha(wch);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetBlockOfChars
//
//  Synopsis:   Returns a block of chars up to the size requested by user. 
//
//                              If an HTML tag is found before that number of chars are read,
//                              then read the tag up to and including its NAME and initialize
//                              token with the tag's type and handler info.   On return, 
//                              the scanner has read the tag NAME but not its parameters
//                              or the '>'.
//
//                              If the requested number of chars are found before an HTML tag,
//                              return those chars; the token arg is NOT INITIALIZED or
//                              otherwise modified.  If cCharsNeeded == cCharsScanned, the
//                              token has NOT been initialized, its contents are undefined and
//                              the caller must not reference it.
//
//                              Specifically, the scanner state upon return is either that it
//                              is in the middle of non-tag body text, or has read a tag name
//                              but has not yet read the tag parameters or closing '>'.  
//                              (Once it reads the '<' it also reads the full tag name,
//                              independent of cCharsNeeded.)
//
//  Arguments:  [cCharsNeeded]   -- Maximum # chars to scan
//              [awcBuffer]      -- Buffer to fill with scanned chars
//              [cCharsScanned]  -- # chars actually scanned
//              [token]          -- Token found (if any)
//
//--------------------------------------------------------------------------

void CHtmlScanner::GetBlockOfChars( ULONG cCharsNeeded,
                                    WCHAR *awcBuffer,
                                    ULONG& cCharsScanned,
                                    CToken& token )
{
    Win4Assert( 0 != awcBuffer );
        
    cCharsScanned = 0;

    while ( cCharsNeeded > 0 )
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
                        break;
        }

                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( &awcBuffer[cCharsScanned], cCharsNeeded, L"<" );

        WCHAR wch = _serialStream.GetChar();
        if ( wch == L'<' && Peek_ParseAsTag() )
                {
            //
            // Html tag encountered
                        // Scan the tag and set token's type and tag entry for it
            //
                        ScanTagName( token );
                        break;
                }
                else
                {
                        awcBuffer[cCharsScanned++] = wch;
                        cCharsNeeded--;
        }
    }
        
        if (cCharsScanned)
                FixPrivateChars (awcBuffer, cCharsScanned);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::Peek_ParseAsEndScriptTag
//
//  Synopsis:   Read ahead to determine how to parse '<' inside a script
//
//                              On entry, only the '<' has been read.
//
//                              Return TRUE if the '<' is followed by a lexically valid
//                              end-script tag.  Read ahead to determine which case
//                              applies, and then call UnGetChar with whatever char(s)
//                              were read to restore the input stream to the same state
//                              as on entry.
//
//                              If EOF is read, return FALSE.
//
//                              It takes an argument to indicate whether it is looking for script tag or style tag.
//                              This function is called to find both the end tags.
//
//  Returns:    TRUE if what follows should be parse as the end-script tag.
//
//--------------------------------------------------------------------------
BOOL
CHtmlScanner::Peek_ParseAsEndScriptTag( BOOL fStyle )
{
        if ( _serialStream.Eof() )
                return FALSE;

        WCHAR wch = _serialStream.GetChar();
        if ( wch != L'/' || _serialStream.Eof() )
        {
                _serialStream.UnGetChar (wch);
                return FALSE;
        }

        //      -2 because we have to unget '/' and potentially '>'
        const unsigned kCharsToGetForName = MAX_UNGOT_CHARS - 2;
        WCHAR wszEndTagName[kCharsToGetForName + 1];
        int cCharsRead = 0;
        wch = _serialStream.GetChar();

        while(!_serialStream.Eof() 
                && wch != L'>' &&
                cCharsRead < kCharsToGetForName)
        {
                wszEndTagName[cCharsRead++] = wch;
                wch = _serialStream.GetChar();
                if(wch == L'>') _serialStream.UnGetChar(L'>');
        }
        wszEndTagName[cCharsRead] = L'\0';

        BOOL fEndScriptTag = FALSE;
        SmallString csEndTagName(wszEndTagName);
        csEndTagName.TrimRight();
        csEndTagName.TrimLeft();
        if((csEndTagName == L"script" && !fStyle) || (csEndTagName == L"style" && fStyle))
        {
                fEndScriptTag = TRUE;
        }

        while(cCharsRead > 0)
        {
                _serialStream.UnGetChar(wszEndTagName[--cCharsRead]);
        }
        _serialStream.UnGetChar( L'/' );

        return fEndScriptTag;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetBlockOfScriptChars
//
//  Synopsis:   Returns a block of chars up to the size requested by user,
//                              while reading between <script> and </script> tags.
//
//                              If a lexically valid end-tag is found before the requested
//                              number of chars are read, then 
//                              read the end-tag up to and including its NAME and initialize
//                              token with the tag's type and handler info.   On return, 
//                              the scanner has read the tag NAME but not its parameters
//                              or the '>'.
//
//                              See GetBlockOfChars().
//
//  Arguments:  same as GetBlockOfChars()
//
//--------------------------------------------------------------------------

void CHtmlScanner::GetBlockOfScriptChars( ULONG cCharsNeeded,
                                    WCHAR *awcBuffer,
                                    ULONG& cCharsScanned,
                                    CToken& token )
{
    cCharsScanned = 0;

    while ( cCharsNeeded > 0 )
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
                        break;
        }

                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( &awcBuffer[cCharsScanned], cCharsNeeded, L"<" );

        WCHAR wch = _serialStream.GetChar();

        // Peek_ParseAsEndScriptTag is used to find both script and style therefore we pass
        //an argument 0 to indicate that it is looking for end script tag

        if ( wch == L'<' && Peek_ParseAsEndScriptTag( FALSE ) )
                {
            //
            // End-script tag encountered
                        // Scan the tag and set token's type and tag entry for it
            //
                        ScanTagName( token );
                        break;
                }
                else
                {
                        awcBuffer[cCharsScanned++] = wch;
                        cCharsNeeded--;
        }
    }
        
        if (cCharsScanned)
                FixPrivateChars (awcBuffer, cCharsScanned);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::SkipCharsUntilNextRelevantToken
//
//  Synopsis:   Skips characters in input until EOF or an interesting token
//              is found. The list of properties that were asked to be filtered
//              as part of the IFilter::Init call determines whether a token is
//              interesting or not.
//
//                              If vanilla content text is found, switch to TextToken
//                              and return.
//
//                              Note that body text is an "interesting" token when content
//                              is being filtered, this really "skips" anything only when
//                              content is not being filtered.
//
//                              The token type indicates the return value -- TextToken
//                              if the next input is body text, or some other Token ID
//                              if the next input is a tag.
//
//  Arguments:  [fFilterContents]     -- Are contents filtered ?
//              [fFilterProperties]   -- Are properties filtered ?
//              [cAttributes]          -- Count of properties
//              [pAttributes]         -- List of properties to be filtered
//
//--------------------------------------------------------------------------

void CHtmlScanner::SkipCharsUntilNextRelevantToken( CToken& token )
{
        token.SetTokenType (GenericToken);
        token.SetTagEntry (NULL);

    //
    // Loop until we find a stop token or end of file
    //
    for (;;)
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
            return;
        }

                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( buf, BUFLEN, L"<" );

        WCHAR wch = _serialStream.GetChar();
        if ( wch == L'<' && Peek_ParseAsTag() )
        {
                        // Html tag encountered
                        // Scan the tag and set token's type and tag entry for it

                        ScanTagName( token );

                        // Stop the scan if a token was found and the table indicates
                        // it needs to be processed.

                        if ( token.GetTokenType() == EofToken
                                 || _htmlIFilter.IsStopToken( token ) )
                        {
                                return;
                        }
            else
            {
                //
                // Uninteresting tag, hence skip tag
                //
                EatTag();
            }
                }
                else
                {
                        //
                        // Vanilla text
                        //
                        if ( _htmlIFilter.FFilterContent() )
                        {
                                _serialStream.UnGetChar( wch );
                                token.SetTokenType( TextToken );
                                return;
                        }
                        else
                                EatText();
                }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::SkipCharsUntilEndScriptToken
//
//  Synopsis:   Skips characters in input until EOF or a lexically valid
//                              potential end-script token is found.
//
//                              The token type indicates the return value.  
//                              See SkipCharsUntilNextRelevantToken().
//
//  Arguments:
//
//--------------------------------------------------------------------------

void CHtmlScanner::SkipCharsUntilEndScriptToken( CToken& token )
{
        token.SetTokenType (GenericToken);
        token.SetTagEntry (NULL);

    //
    // Loop until we find a lexically valid end-script token or end of file
    //
    for (;;)
    {
        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
            return;
        }

                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( buf, BUFLEN, L"<" );

        WCHAR wch = _serialStream.GetChar();

        // Peek_ParseAsEndScriptTag is used to find both script and style therefore we pass an argument 0 to indicate
        // that it is looking for end script tag

        if ( wch == L'<' && Peek_ParseAsEndScriptTag( FALSE ) )
        {
                        // End-script tag encountered
                        // Scan the tag and set token's type and tag entry for it

                        ScanTagName( token );

                        // Stop the scan if a token was found and the table indicates
                        // it needs to be processed.

                        if ( token.GetTokenType() == EofToken
                                 || _htmlIFilter.IsStopToken( token ) )
                        {
                                return;
                        }
            else
            {
                //
                // Uninteresting tag, hence skip tag
                //
                EatTag();
            }
                }
                else
                {
                        EatText();
                }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ScanTagName
//
//  Synopsis:   Scans a Html tag name from input
//
//                              The '<' has already been read.  Read the rest of the
//                              tag name up to but not including a delimiter, or '>' 
//                              if the tag has no parameters.
//
//                              Stop reading at MAX_TAG_LENGTH if the delimiter or '>' have
//                              not been encountered.
//
//  Arguments:  [token]  -- Token info returned here
//
//--------------------------------------------------------------------------

void CHtmlScanner::ScanTagName( CToken& token )
{
        _fTagIsAlreadyRead = FALSE;             // rest of tag hasn't been read

        token.SetTokenType( GenericToken );
        token.SetTagEntry( NULL );

        EatBlanks();

    if ( _serialStream.Eof() )
    {
        token.SetTokenType( EofToken );
                _eTokType = EofToken;
        return;
    }
    WCHAR wch = _serialStream.GetChar();

    token.SetStartTokenFlag( TRUE );
    if ( wch == L'/' )
    {
        //
        // This is an end tag
        //
        token.SetStartTokenFlag( FALSE );
        EatBlanks();

        if ( _serialStream.Eof() )
        {
            token.SetTokenType( EofToken );
                        _eTokType = EofToken;
            return;
        }
        wch = _serialStream.GetChar();
    }

    unsigned uLenTag = 0;


    //
    // Scan the tag name into szTagName. We scan MAX_TAG_LENGTH
    // characters only, because anything longer is most probably
    // a bogus tag.
    //
    while ( !iswspace(wch)
            && wch != L'>'
            && uLenTag <= MAX_TAG_LENGTH )
    {
        _awcTagName[uLenTag++] = wch;

        if ( uLenTag == 1 && _awcTagName[0] == L'%' )
        {
            //
            // Asp tag, so no need to read further
            //
            break;
        }

                if ( uLenTag == 3 && 
                         token.IsStartToken() &&
                         _awcTagName[0] == L'!' && 
                         _awcTagName[1] == L'-' && 
                         _awcTagName[2] == L'-' )
                {
                        // 
                        // Comment is a special case, since it is not
                        // necessarily delimited by whitespace.
                        //
                        break;
                }

        if ( _serialStream.Eof() )
            break;
        wch = _serialStream.GetChar();
    }

        // Special case for office 9 comment
        // <!--[if gte mso 9]>
        if ( uLenTag == 3 && 
                 token.IsStartToken() &&
                 _awcTagName[0] == L'!' && 
                 _awcTagName[1] == L'-' && 
                 _awcTagName[2] == L'-' &&
                 !_serialStream.Eof())
        {
                WCHAR rgwcBuf[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                int i = 0;
                while(i < 15)
                {
                        rgwcBuf[i++] = wch = _serialStream.GetChar();
                        if(_serialStream.Eof())
                        {
                                break;
                        }
                }
                if(_serialStream.Eof() ||
                   _wcsnicmp(L"[if gte mso 9]>", rgwcBuf, 15))
                {
                        // Didn't get the whole tag before eof
                        // Or it's not the special case
                        while(i > 0)
                        {
                                _serialStream.UnGetChar(rgwcBuf[--i]);
                        }
                        wch = L'-';
                }
                else
                {
                        // Assert the bounds _awcTagName[MAX_TAG_LENGTH+1], 
                        Win4Assert( sizeof(_awcTagName) >= (17 * sizeof(WCHAR)) );
                        // Special case
                        // rgwcBuf = L"[if gte mso 9]>"
                        memcpy(_awcTagName + 3, rgwcBuf, 14 * sizeof(WCHAR));
                        uLenTag += 14;
                }
        }


    _awcTagName[uLenTag] = 0;

    if ( wch == L'>' || uLenTag == MAX_TAG_LENGTH )
    {
        //
        // Push char back into input stream because a subsequent GetChar()
        // will be expecting to see the char in the input
        //
        _serialStream.UnGetChar( wch );
    }

        // Fill in token with the tag table definition for _awcTagName.

    TagNameToToken( _awcTagName, token );

        _eTokType = token.GetTokenType();
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ReadTag
// 
//  Synopsis:   Reads the rest of the current HTML tag from the input stream
//                              up to and including the closing '>'.
//
//                              If fReadIntoBuffer is TRUE, read the tag text up to but NOT
//                              including the '>' into the scanner's internal tag buffer.
//                              If FALSE, read the same input but discard it.
//
//                              This fully parses a tag for the sole purpose of determining
//                              where it ends and hence how much to read.  ScanTagBuffer()
//                              is used to extract data from the tag after.
//
//  Arguments:  [fReadIntoBuffer]  -- read into buffer
//
// The following must be correctly handled:
//              <tag paramname=value ...>
//              <tag paramname="val'ue 1" ...>
//              <tag paramname='val"ue 2' ...>
//              <tag paramname = value ...>
//              <tag param1name param2name = value ...>
//
// Robustly handle badly-formed tags.  Follow IE's model:
// 1. Ignore quotes that appear where not expected.
// 2. For values that begin with a proper quote but are missing the 
//    closing quote, read indefinitely until a matching quote is found.
//        This may eat several lines of text, but it will get back in sync at 
//        the next quote because that quote's matching quote will appear in an
//        invalid position and thus NOT mistakenly begin another quote.
//
// Note:  The PRIVATE_USE_MAPPING chars are left in place for now, since
// the buffer assembled here is read-parsed as each parameter is extracted.
// Each call to ScanTagBuffer must be followed by a call to FixPrivateChars
// to undo the mapping.
//
//--------------------------------------------------------------------------

// Parsing states for tag parameter names and values.
//
// Possible state transitions:
//        esIdle to esName
//        esName to esSpaceAfterName or esEquals 
//        esSpaceAfterName to esName or esEquals
//        esEquals to xxxValue
//        xxxValue to esIdle

enum esParamState { 
        esIdle,                                 // reading whitespace prior to name
        esName,                                 // reading parameter name up to '='
        esPrefix,                               // Not used in ReadTag(), but used in
                                                        // ScanTagBufferEx()
        esSpaceAfterName,               // reading whitespace after param name
        esEquals,                               // just read '=' and expecting value next
        esSingleQuotedValue,    // inside a single-quoted parameter value
        esDoubleQuotedValue,    // inside double-quoted value
        esUnquotedValue                 // inside an unquoted parameter value
};

void CHtmlScanner::ReadTag( BOOL fReadIntoBuffer )
{
    WCHAR wch;

        // Allow this to be called multiple times for a given tag
        // 
        if (_fTagIsAlreadyRead == TRUE)
                return;
        _fTagIsAlreadyRead = TRUE;

        // Erase buffer either way
        _cTagCharsRead = 0;


        // Special handling for tags with non-standard closing syntax

        switch ( _eTokType )
        {

        case CommentToken:
                ReadComment ( fReadIntoBuffer );        // read to "-->" instead of ">"
                return;

        case AspToken:                                                  // read to "%>"
                EatAspCode();                                           // WORK HERE: add fReadIntoBuffer
                return;
        }

        esParamState estate = esIdle;

    while ( _serialStream.Eof() == FALSE )
        {
                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( buf, BUFLEN, L">" );
                // since the resulting block will always be entirely consumed

                wch = _serialStream.GetChar();
                
                switch (estate) {

                case esIdle:
                        if (wch == L'>')
                                return;
                        if ( !iswspace(wch) )
                                estate = esName;                // wch is 1st char of a param name
                        break;

                case esName:
                        if (wch == L'>')
                                return;
                        if (wch == L'=')
                                estate = esEquals;
                        break;

                case esEquals:
                        switch (wch) {
                        case L'>':
                                return;
                        case L' ':
                        case L'\t':
                                break;
                        case L'\'':
                                estate = esSingleQuotedValue;
                                break;
                        case L'"':
                                estate = esDoubleQuotedValue;
                                break;
                        default:
                                estate = esUnquotedValue;
                                break;
                        }
                        break;

                case esSingleQuotedValue:
                        if (wch == L'\'')
                                estate = esIdle;
                        break;

                case esDoubleQuotedValue:
                        if (wch == L'"')
                                estate = esIdle;
                        break;

                case esUnquotedValue:
                        if (wch == L'>')
                                return;
                        if (iswspace(wch))
                                estate = esIdle;
                        break;
                }

                if ( fReadIntoBuffer )
                {
                        if ( _cTagCharsRead >= _uLenTagBuf )
                                GrowTagBuffer();
                        Win4Assert( _cTagCharsRead < _uLenTagBuf );

                        _pwcTagBuf[_cTagCharsRead++] = wch;
                }
    }
        
        // Found EOF before end of tag; buffer contains whatever was read
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ScanTagBuffer
//
//  Synopsis:   Scans the internal tag buffer for a given parameter name,
//              and returns the corresponding value string.  
//                              The tag buffer contains all the text up to, not incl, the ">".
//
//                              The buffer contents and file position are not modified,
//                              i.e. this may be called multiple times to read different
//                              parameters from any position in the buffer.
//
//                              CHANGE NOTE:  this previously matched a raw substring; to 
//                              match parameters the caller passed in literally 'tagname="'.
//                              To correctly handle whitespace, unquoted and single-quoted
//                              values, the caller now passes just name e.g. 'tagname'.
//
//  Arguments:  [awcName]  [in]   -- Pattern to match  (null terminated)
//              [pwcValue]  [out] -- Start position of value returned here
//              [uLenValue] [out] -- Length of value field
//
//--------------------------------------------------------------------------

void CHtmlScanner::ScanTagBuffer( WCHAR const * awcName,
                                  WCHAR * & pwcValue,
                                  unsigned& uLenValue )
{
        ReadTagIntoBuffer();                    // read, if not already

    unsigned uLenName = wcslen( awcName );

        // Run the state machine over the tag parameters again, and this time
        // test awcName against each parsed parameter name.

        // The data to parse is _pwcTagBuf[ 0 ... _cTagCharsRead-1 ]

        esParamState estate = esIdle;

        LPWSTR pParamName = NULL;
        unsigned uParamNameLen = 0;
        BOOL fIsNameMatch = FALSE;

        for (LPWSTR pTagData = _pwcTagBuf; pTagData < &_pwcTagBuf[_cTagCharsRead]; pTagData++)
        {
                WCHAR wch = *pTagData;

                switch (estate) {

                case esIdle:
                        if ( !iswspace(wch) )
                        {
                                pParamName = pTagData;          // 1st char of param name
                                uParamNameLen = 0;
                                estate = esName;
                        }
                        break;

                case esName:
                        if (wch == L'=')
                        {
                                if ( uLenName == uParamNameLen &&
                                         !_wcsnicmp( awcName, pParamName, uLenName ))
                                {
                                        fIsNameMatch = TRUE;    // matched the param name; set 
                                }                                                       // flag to return the next value
                                estate = esEquals;
                        }
                        else if ( !iswspace(wch) )              // remember last non-ws name char
                                uParamNameLen = (unsigned) ( (pTagData - pParamName) + 1 );
                        else
                                estate = esSpaceAfterName;
                        break;
                        
                case esSpaceAfterName:
                        // If the whitespace is followed by '=' then just ignore the WS
                        // i.e. treat as name=val.
                        // If the whitespace is followed by any other char then reset
                        // the name -- the space delimits a valueless attribute
                        // i.e. name1 name2=val so reset pParamName to name2
                        if (wch == L'=')
                        {
                                if ( uLenName == uParamNameLen &&
                                         !_wcsnicmp( awcName, pParamName, uLenName ))
                                {
                                        fIsNameMatch = TRUE;    // matched the param name; set 
                                }                                                       // flag to return the next value
                                estate = esEquals;
                        }
                        else if ( !iswspace(wch) )
                        {
                                pParamName = pTagData;          // 1st char of param name
                                uParamNameLen = 0;
                                estate = esName;
                        }
                        break;

                case esEquals:
                        switch (wch) {
                        case L' ':
                        case L'\t':
                                break;
                        case L'\'':
                                pwcValue = pTagData + 1;
                                estate = esSingleQuotedValue;
                                break;
                        case L'"':
                                pwcValue = pTagData + 1;
                                estate = esDoubleQuotedValue;
                                break;
                        default:
                                pwcValue = pTagData;
                                estate = esUnquotedValue;
                                break;
                        }
                        break;

                case esSingleQuotedValue:
                        if (wch == L'\'')
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;

                case esDoubleQuotedValue:
                        if (wch == L'"')
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;

                case esUnquotedValue:
                        if (iswspace(wch))
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;
                }
        }

        // Handle end state

        switch (estate) {

        case esUnquotedValue:   // end of tag terminates an unquoted value
                if (fIsNameMatch)
                {
                        uLenValue = (unsigned) ( pTagData - pwcValue );
                        return;
                }
                break;

        default:                                // no other relevant end state
                break;
        }

        // Parameter name and/or value are not present

        pwcValue = 0;   
        uLenValue = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ScanTagBufferEx
//
//  Synopsis:   Same as ScanTagBuffer, extended to handle Office 9 namespace
//                              definition.
//
//  Arguments:  [awcName]  [in]   -- Pattern to match  (null terminated)
//              [pwcValue]  [out] -- Start position of value returned here
//              [uLenValue] [out] -- Length of value field
//              [pwcPrefix]  [out] -- Start position of prefix returned here
//              [uLenPrefix] [out] -- Length of prefix field
//                              [iPos]           [in] -- Tag parameter to match
//
//--------------------------------------------------------------------------

void CHtmlScanner::ScanTagBufferEx(WCHAR *awcName,
                                                                   WCHAR * & pwcValue,
                                                                   unsigned& uLenValue,
                                                                   WCHAR * & pwcPrefix,
                                                                   unsigned& uLenPrefix,
                                                                   int iPos)
{
        ReadTagIntoBuffer();                    // read, if not already

    unsigned uLenName = wcslen( awcName );

        // Run the state machine over the tag parameters again, and this time
        // test awcName against each parsed parameter name.

        // The data to parse is _pwcTagBuf[ 0 ... _cTagCharsRead-1 ]

        esParamState estate = esIdle;

        LPWSTR pParamName = NULL;
        unsigned uParamNameLen = 0;
        BOOL fIsNameMatch = FALSE;
        int iMatch = 0;

        for (LPWSTR pTagData = _pwcTagBuf; pTagData < &_pwcTagBuf[_cTagCharsRead]; pTagData++)
        {
                WCHAR wch = *pTagData;

                switch (estate) {

                case esIdle:
                        if ( !iswspace(wch) )
                        {
                                pParamName = pTagData;          // 1st char of param name
                                uParamNameLen = 0;
                                estate = esName;
                        }
                        break;

                case esName:
                        if (wch == L':')
                        {
                                if ( uLenName == uParamNameLen &&
                                         !_wcsnicmp( awcName, pParamName, uLenName ))
                                {
                                        if(iMatch++ == iPos)
                                        {
                                                fIsNameMatch = TRUE;    // matched the param name; set 
                                                                                                // flag to return the next value
                                        }
                                }
                                pwcPrefix = pTagData + 1;
                                uLenPrefix = 0;
                                estate = esPrefix;
                        }
                        else if (wch == L'=')
                        {
                                if ( uLenName == uParamNameLen &&
                                         !_wcsnicmp( awcName, pParamName, uLenName ))
                                {
                                        if(iMatch++ == iPos)
                                        {
                                                fIsNameMatch = TRUE;    // matched the param name; set 
                                                                                                // flag to return the next value
                                        }
                                }
                                estate = esEquals;
                        }
                        else if ( !iswspace(wch) )              // remember last non-ws name char
                                uParamNameLen = (unsigned) ( (pTagData - pParamName) + 1 );
                        else
                                estate = esSpaceAfterName;
                        break;

                case esPrefix:
                        if (wch == L'=')
                        {
                                estate = esEquals;
                        }
                        else if (!iswspace(wch))
                        {
                                ++uLenPrefix;
                        }
                        else
                        {
                                estate = esSpaceAfterName;
                        }
                        break;
                        
                case esSpaceAfterName:
                        // If the whitespace is followed by '=' then just ignore the WS
                        // i.e. treat as name=val.
                        // If the whitespace is followed by any other char then reset
                        // the name -- the space delimits a valueless attribute
                        // i.e. name1 name2=val so reset pParamName to name2
                        if (wch == L'=')
                        {
                                if ( uLenName == uParamNameLen &&
                                         !_wcsnicmp( awcName, pParamName, uLenName ))
                                {
                                        if(iMatch++ == iPos)
                                        {
                                                fIsNameMatch = TRUE;    // matched the param name; set 
                                        }                                                       // flag to return the next value
                                }
                                estate = esEquals;
                        }
                        else if ( !iswspace(wch) )
                        {
                                pParamName = pTagData;          // 1st char of param name
                                uParamNameLen = 0;
                                estate = esName;
                        }
                        break;

                case esEquals:
                        switch (wch) {
                        case L' ':
                        case L'\t':
                                break;
                        case L'\'':
                                pwcValue = pTagData + 1;
                                estate = esSingleQuotedValue;
                                break;
                        case L'"':
                                pwcValue = pTagData + 1;
                                estate = esDoubleQuotedValue;
                                break;
                        default:
                                pwcValue = pTagData;
                                estate = esUnquotedValue;
                                break;
                        }
                        break;

                case esSingleQuotedValue:
                        if (wch == L'\'')
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;

                case esDoubleQuotedValue:
                        if (wch == L'"')
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;

                case esUnquotedValue:
                        if (iswspace(wch))
                        {
                                if (fIsNameMatch)
                                {
                                        uLenValue = (unsigned) ( pTagData - pwcValue );
                                        return;
                                }
                                estate = esIdle;
                        }
                        break;
                }
        }

        // Handle end state

        switch (estate) {

        case esUnquotedValue:   // end of tag terminates an unquoted value
                if (fIsNameMatch)
                {
                        uLenValue = (unsigned) ( pTagData - pwcValue );
                        return;
                }
                break;

        default:                                // no other relevant end state
                break;
        }

        // Parameter name and/or value are not present

        pwcValue = 0;   
        uLenValue = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetTagBuffer
//
//  Synopsis:   Return the entire raw contents of the tag buffer, i.e.
//                              all the text from after the tag name up to but not including
//                              the ">".   The buffer contents and position are
//                              not modified.
//
//  Arguments:  [pwcValue]  -- Start position of value returned here
//              [uLenValue  -- Length of value field
//
//--------------------------------------------------------------------------
void
CHtmlScanner::GetTagBuffer( WCHAR * & pwcValue, unsigned& uLenValue )
{
        pwcValue = _pwcTagBuf;
        uLenValue = _cTagCharsRead;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatText
//
//  Synopsis:   Skips characters in input until a '<', ie a tag is encountered
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatText()
{
    if ( _serialStream.Eof() )
        return;

        // WORK HERE:  optimize by calling GetCharsUpTo( buf, BUFLEN, L"<" );

    WCHAR wch = _serialStream.GetChar();
    while ( wch != L'<' && !_serialStream.Eof() )
        wch = _serialStream.GetChar();

    if ( wch == L'<' )
        _serialStream.UnGetChar( wch );
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatBlanks
//
//  Synopsis:   Skips generic white space characters in input
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatBlanks()
{
    if ( _serialStream.Eof() )
        return;

    WCHAR wch = _serialStream.GetChar();
    while ( iswspace(wch) && !_serialStream.Eof() )
        wch = _serialStream.GetChar();

    if ( !iswspace(wch) )
        _serialStream.UnGetChar( wch );
}



//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::ReadComment
//
//  Synopsis:   Read and/or skip over comment.
//
//                              Comment is special since it is closed by '-->' not by '>'.
//
//  Arguments:  [fRead]  -- If TRUE, read into buffer, otherwise just skip
//
//--------------------------------------------------------------------------

void CHtmlScanner::ReadComment(BOOL fReadIntoBuffer)
{
        enum esCommentState {
                esIdle,                                 // not inside a potential end-comment
                es1stMinus,                             // read the 1st '-'
                es2ndMinus                              // read the 2nd or subsequent '-'
        };

        // Erase buffer either way
        _cTagCharsRead = 0;

        esCommentState eState = esIdle;

        // Read until '-->' or EOF

        while ( !_serialStream.Eof() )
    {
                // WORK HERE:  optimize by calling 
                //       GetCharsUpTo( buf, BUFLEN, L">" );
                // since the resulting block will always be entirely consumed

        WCHAR wch = _serialStream.GetChar();

                switch (eState) {
                        
                case esIdle:
                        if (wch == L'-')
                                eState = es1stMinus;
                        break;
                        
                case es1stMinus:
                        if (wch == L'-')
                                eState = es2ndMinus;
                        else
                                eState = esIdle;
                        break;
                        
                case es2ndMinus:
                        if (wch == L'>')
                        {
                                // found end-comment

                                if ( fReadIntoBuffer )
                                {
                                        _cTagCharsRead -= 2;            // don't remember the '--'
                                        FixPrivateChars (_pwcTagBuf, _cTagCharsRead);
                                }
                                return;
                        }
                        else if (wch != L'-')
                                eState = esIdle;
                        break;
                }

                if ( fReadIntoBuffer )
                {
                        if ( _cTagCharsRead >= _uLenTagBuf )
                                GrowTagBuffer();
                        Win4Assert( _cTagCharsRead < _uLenTagBuf );

                        _pwcTagBuf[_cTagCharsRead++] = wch;
                }
    }

        // Found EOF before end of comment

        FixPrivateChars (_pwcTagBuf, _cTagCharsRead);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::EatAspCode
//
//  Synopsis:   Skips over Denali code
//
//                              ASP tags are special since they are closed by '%>' not '>'.
//
//--------------------------------------------------------------------------

void CHtmlScanner::EatAspCode()
{
    //
    // Exit for loop when %> is found or it is Eof
    //
    for (;;)
    {
        if ( _serialStream.Eof() )
            return;

                // WORK HERE:  optimize by calling GetCharsUpTo( buf, BUFLEN, L"%" );

        WCHAR wch = _serialStream.GetChar();
        while ( wch != L'%' && !_serialStream.Eof() )
            wch = _serialStream.GetChar();

        BOOL fPercentChar = TRUE;
        while ( fPercentChar )
        {
            if ( _serialStream.Eof() )
                return;

            wch = _serialStream.GetChar();
            if ( wch == L'>' )
            {
                //
                // Found %> , hence we are done
                //
                return;
            }

            if ( wch != L'%' )
            {
                //
                // Need to start searching for the '%' char,
                // otherwise we should we should search for '>' char
                //
                fPercentChar = FALSE;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::TagNameIsOffice9Property
//
//  Synopsis:   Determines if a tag name if an office 9 property tag name
//
//  Arguments:  [awcTagName]  -- Tag name
//              [token]       -- Token information returned here
//
//--------------------------------------------------------------------------

bool CHtmlScanner::TagNameIsOffice9Property( WCHAR *awcTagName )
{
        if(!_csOffice9PropPrefix.IsEmpty() && !_wcsnicmp(awcTagName, _csOffice9PropPrefix.GetBuffer(), _csOffice9PropPrefix.GetLength()))
        {
                return true;
        }
        else
        {
                return false;
        }
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::TagNameToToken
//
//  Synopsis:   Maps a tag name to token information
//
//  Arguments:  [awcTagName]  -- Tag name to map
//              [token]       -- Token information returned here
//
// Notes:
// 
// The tag hash table has exactly one entry per unique tag name.  Chained
// entries in the hash table result from hash collisions of different names,
// NOT from multiple tag definition table entries for one tag name.
//
// The tag definition table may have multiple entries per unique name, in
// which case the CTagEntry's are chained together external to the hash table,
// and the caller of this code is responsible for sequencing through them.
// Lookup() only returns a pointer to the head of the chain.
// 
//--------------------------------------------------------------------------

void CHtmlScanner::TagNameToToken( WCHAR *awcTagName, CToken& token )
{
        // Find awcTagName in the dispatch table and fill in token from the table.
        // The TagEntry is set to the head of the handler chain.

        PTagEntry pTE;
        
        if ( TagHashTable.Lookup (awcTagName, wcslen(awcTagName), pTE) == TRUE)
        {
                token.SetTokenType( pTE->GetTokenType()  );
                token.SetTagEntry( pTE );
        }
        else if( TagNameIsOffice9Property(awcTagName) )
        {
                unsigned cwcPrefix = _csOffice9PropPrefix.GetLength();
                if( TagHashTable.Lookup (awcTagName + cwcPrefix, wcslen(awcTagName) - cwcPrefix, pTE) == TRUE )
                {
                        token.SetTokenType( pTE->GetTokenType()  );
                        token.SetTagEntry( pTE );
                }
                else
                {
                        // Custom Office 9 properties
                        token.SetTokenType( XMLShortHand );
                        token.SetTagEntry( NULL );
                        token.SetTokenName( awcTagName + cwcPrefix + 1);
                }
        }
        else if( IgnoreTagContent(awcTagName) )
        {
                token.SetTokenType( XMLIgnoreContentToken );
                token.SetTagEntry( NULL );
        }
        else
        {
                token.SetTokenType( GenericToken );             // any unrecognized tag
                token.SetTagEntry( NULL );
        }
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GrowTagBuffer
//
//  Synopsis:   Grow internal tag buffer to twice its current size
//
//--------------------------------------------------------------------------

void CHtmlScanner::GrowTagBuffer()
{
    WCHAR *pwcNewTagBuf = new WCHAR[2 * _uLenTagBuf];
    RtlCopyMemory( pwcNewTagBuf,
                   _pwcTagBuf,
                   _uLenTagBuf * sizeof(WCHAR) );

    delete[] _pwcTagBuf;
    _uLenTagBuf *= 2;
    _pwcTagBuf = pwcNewTagBuf;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetStylesheetEmbeddedURL
//
//  Synopsis:   Scan stylesheet body text for an embedded URL of the 
//                              form  url( URL ).  If found, copy to sURL, leave the parse
//                              point following the ")" and return TRUE.  Else leave
//                              the parse point following the </style> or at EOF and
//                              return FALSE.  This always eats the end tag. This
//                              function is called by GetScripEmbedded URL, therefore we
//                              pass an argument to indicate whether is checking for StyleSheet
//                              or Script.
//
// Invariants:  Can return false only if it has either scanned off the
//                              entire end-tag, or has read EOF.
//                              Return true indicates it has not read the end tag.
//
// Quoting from CSS1:
//
// The format of a URL value is 'url(' followed by optional white space
// followed by an optional single quote (') or double quote (")
// character followed by the URL itself (as defined in [11]) followed by
// an optional single quote (') or double quote (") character followed
// by optional whitespace followed by ')'. Quote characters that are not
// part of the URL itself must be balanced. 
//
// Parentheses, commas, whitespace characters, single quotes (') and
// double quotes (") appearing in a URL must be escaped with a
// backslash: '\(', '\)', '\,'. 
//
//--------------------------------------------------------------------------
BOOL
CHtmlScanner::GetStylesheetEmbeddedURL( URLString &sURL, BOOL fStyle )
{
        enum ScanState { 
                sIdle, sMatch1, sMatch2, sMatch3, sStartURL, sReadingURL, sEscape
        };

        ScanState eState = sIdle;

        sURL.Empty();

        // NOTE:  sURL throws when the length exceeds a fixed limit, but
        // the code is supposed to prevent it from exceeding.  An exception
        // indicates some other bug.

        while ( !_serialStream.Eof() )
        {
                WCHAR wch = _serialStream.GetChar();

                // '</' ends both the URL and the entire element no matter where
                // it appears.  Eat the rest of the end tag.

                if ( wch == L'<' &&
                         Peek_ParseAsEndScriptTag( fStyle ) )
                {
                        // End-script tag encountered.  Even if there is data to return,
                        // the syntax must be bad so discard it.
                        sURL.Empty();

                        // Go through the motions of parsing a tag to get the parse
                        // point to just past the ">"
                        CToken token;
                        ScanTagName( token );
                        EatTag ();
                        return FALSE;
                }

                switch (eState)
                {
                case sIdle:
                        // look for the 1st char of the URL marker url(
                        if (wch == L'u' || wch == L'U')
                                eState = sMatch1;
                        break;

                case sMatch1:
                        if (wch == L'r' || wch == L'R')
                                eState = sMatch2;
                        else
                                eState = sIdle;
                        break;

                case sMatch2:
                        if (wch == L'l' || wch == L'L')
                                eState = sMatch3;
                        else
                                eState = sIdle;
                        break;

                case sMatch3:
                        if ( wch == L'(' )
                                eState = sStartURL;
                        else
                                eState = sIdle;
                        break;

                case sStartURL:
                        // found "url(", now scan off possible whitespace & quoting
                        // until a valid start-of-URL char is found

                        if ( wch == L'\'' || wch == L'"' )
                        {
                                eState = sReadingURL;
                        }
                        else if ( wch == L'\\' )
                                eState = sEscape;
                        else if ( !iswspace (wch))
                        {
                                eState = sReadingURL;
                                sURL += wch;            // 1st char -- no need to check length
                        }
                        break;

                case sReadingURL:
                        // accumulate into sURL until an end char appears
                        if ( wch == L'\'' || wch == L'"' || iswspace (wch) )
                                break;
                        else if ( wch == L'\\' )
                                eState = sEscape;
                        else if ( wch == ')')
                        {
                                // If an actual URL was found, return it
                                if ( sURL.GetLength() != 0)
                                        return TRUE;

                                // Otherwise, reset and start looking again
                                sURL.Empty();
                                eState = sIdle;
                        }
                        else if (sURL.GetLength() + 2 < sURL.GetMaxLen())
                                sURL += wch;            // just discard overlength
                        break;

                case sEscape:
                        // a \ has excaped this char
                        eState = sReadingURL;
                        if (sURL.GetLength() + 2 < sURL.GetMaxLen())
                                sURL += wch;
                        break;
                }
        }

        // returns via this path only when EOF is read, not when end tag is read
        
        sURL.Empty();
        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHtmlScanner::GetScriptEmbeddedURL
//
//  Synopsis:   Scan script body text for an embedded URL of the 
//                              form "http:...".  If found, copy to sURL, leave the parse
//                              point following the last URL char and return TRUE.  Else leave
//                              the parse point following the </script> or at EOF and
//                              return FALSE.  This always eats the end tag.
//
//                              Recognize protocols http:, https:, ftp:
//
//                              The URL may contain or end with the following chars:
//                                      0-9 
//                                      A-Z
//                                      @#$%^&*_=+\|`~/
//                                      0x7F-0xFF
//
//                              The URL may contain the following but these are stripped
//                              from the end if none of the preceding set end the URL.
//                                      !()-[]{};:'".,<>?
//                                      0-0x1F
//
//--------------------------------------------------------------------------
BOOL
CHtmlScanner::GetScriptEmbeddedURL( URLString &sURL )
{
        // WORK HERE -- implement as needed

        // 0 as second argument in GetStylesheetEmbeddedURL indicates that
        // it is called to look for ScriptEmbeddedURL

        return GetStylesheetEmbeddedURL( sURL, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   EatTagAndInvalidTag
//
//  Synopsis:   Eats a regular or invalid tag. This is fix for pkmraid 15377
//
//  History:    4-06-2000   KitmanH   Created
//
//----------------------------------------------------------------------------

void CHtmlScanner::EatTagAndInvalidTag()
{ 
    if ( !_serialStream.Eof() )
    {
        WCHAR wch = _serialStream.GetChar();
        _serialStream.UnGetChar( wch );
        if ( L'<' == wch )
            _fTagIsAlreadyRead = FALSE; 
    }

    EatTag();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\irdebug.h ===
//                                                                      -*- c++ -*-
// irdebug.H
//              debugging helper functions
//

#ifndef _irdebug_H_
#define _irdebug_H_

#include <dbgconst.h>

#ifdef DBG          /* build environment */
#undef DBG
#endif

#ifndef DEBUG
#undef DBGOUT  // don't do DBGOUT if not DEBUG
#endif

//-----------------------------------------------------------------------------
// ASSERT()      macro for asserting....
//               doesn't matter how many times it is included, but it needs
//               to get included for semcls.h to compile.
//
// VERIFY()      like ASSERT, but it is executed in non-debug builds as well.
//
//-----------------------------------------------------------------------------

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _ASSERTE
#undef _ASSERTE
#endif

#ifdef VERIFY
#undef VERIFY
#endif


#ifdef DEBUG 

void AssertProc( LPCTSTR, LPCTSTR, unsigned int );
void NLAssertProc( const TCHAR* expr, const TCHAR *file, unsigned int iLine );

#define ASSERT(t)       (void) ((t) ? 0 : AssertProc(TEXT(#t),TEXT(__FILE__),__LINE__))
#define _ASSERT(t)      (void) ((t) ? 0 : AssertProc(NULL,TEXT(__FILE__),__LINE__))
#define _ASSERTE(t)     (void) ((t) ? 0 : AssertProc(TEXT(#t),TEXT(__FILE__),__LINE__))

#define VERIFY(t)       (void) ((t) ? 0 : AssertProc(TEXT(#t),TEXT(__FILE__),__LINE__))
#define _VERIFY(t)      (void) ((t) ? 0 : AssertProc(TEXT(#t),TEXT(__FILE__),__LINE__))

#else // ! DEBUG

#define ASSERT(t)       ((void)0)
#define _ASSERT(t)      ((void)0)
#define _ASSERTE(t)     ((void)0)
#define VERIFY(t)               t
#define _VERIFY(t)              t

#endif // DEBUG

//-----------------------------------------------------------------------------
// DBG()  macro to do printfs to the debugger output window
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// printf - style debug output
//-----------------------------------------------------------------------------

#ifdef DBGOUT

void DebugOut( LPCTSTR pstrFormatStr, ... );
void DebugOutTagged( TCHAR chTag, LPCTSTR pstrFormatStr, ... );
void InitDebug( LPCTSTR pcstrDebugKey );

#define DBG(x)          ::DebugOut x
#define DBGT(x)         ::DebugOutTagged x
#define DBGO(x)         x

#else  // no DBGOUT

#define DBG(x)                  0
#define DBGT(x)                 0
#define DBGO(x)                 0
#define InitDebug(c)    0

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\makefile.inc ===
filtreg.hxx: ..\h\filtreg.hxx
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\irerror.h ===
/*
** irerror.h
**
** Copyright (C) 1996 Microsoft Corp.
**      All rights reserved.
**
** Global definitions for error and success HRESULTS used in the IR system.
**
** History:
**      03/30/96        AlanPe          Created - merged collator, commgr and
**                                      datasource errors into one file.
**      04/11/96        BenHolz         Added asp, sso, and query errors
**      05/14/96        BenHolz         Added admin errors
**      07/15/96        KenjiO          Resource error strings
*/

#ifndef _irerror_h_
#define _irerror_h_

/*
** we will use FACILITY_ITF for all of our HRESULTS
**
** we also define an 8-bit source field and an 8-bit ID field for the errors
**
*/

/* macro to extract the error source from the error code */
#define ERROR_SOURCE(hr)        ((hr)&0xff00)

#define BEGIN_IR_ERRORS()       typedef enum {
#define MAKE_IR_ERROR(err,sev,src,val,str) err = MAKE_HRESULT(sev,FACILITY_ITF,(src)|(val)),
#define END_IR_ERRORS()         } IRERROR;

#include "errorlst.rc"

#undef BEGIN_IR_ERRORS
#undef MAKE_IR_ERROR
#undef END_IR_ERRORS

#define MV_E_INTERNALBASE   2000        /* MediaView error table bases */
#define MV_E_GRAMMARBASE    3000

/*****************************************************************************
** function prototypes
*****************************************************************************/

/* get a descriptive error string for the given HRESULT */

HRESULT MVtoIRError (WORD wMVError);    /* convert MediaView errors to IR HRESULTS */

#include "resdll.h"
#include "lmstr.hxx"

#define ERROR_MESSAGE(hr)   ((LPCTSTR)CErrorString(hr, TRUE))
#define ERROR_CODE(hr)  ((LPCTSTR)CErrorString(hr, FALSE))

#define ErrorMessage(hr)    ERROR_MESSAGE(hr)
#define ErrorName(hr)       ERROR_CODE(hr)

#define ERROR_STRING_SIZE       256

class CErrorString : public CLMString
{
    public:

    CErrorString(HRESULT hr, BOOL fErrorMessage);
    ~CErrorString() {}

    virtual void GrowString(unsigned)
    {
        throw CException(HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));
    }

    virtual void CleanString(unsigned)
    {
    }

        static void FreeLibraries()
        {
                m_reslibError.Free();
                m_reslibWininet.Free();
                m_reslibCI.Free();
        }


    private:

    TCHAR m_chData[ERROR_STRING_SIZE + 1];

    static CResourceLibrary m_reslibError;
    static CResourceLibrary m_reslibWininet;
    static CResourceLibrary m_reslibCI;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\main.cxx ===
//+---------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1996 - 2002.
//
// File:        main.cxx
//
// Contents:    DLL entry point for htmlfilt.dll
//
//  History:    25-Apr-97       BobP    Changed SFilterEntry to "nlhtml.dll"
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define _DECL_DLLMAIN 1
#include <process.h>

#include <osv.hxx>

#undef VARIANT
#include <filtreg.hxx>

//
// global function to find OS platform
//
#define UNINITIALIZED -1
int g_nOSWinNT = UNINITIALIZED;


//+-------------------------------------------------------------------------
//
//  Function:   InitOSVersion
//
//  Synopsis:   Determine OS version
//
//--------------------------------------------------------------------------

void InitOSVersion()
{
    if ( g_nOSWinNT == UNINITIALIZED )
    {
        OSVERSIONINFOA OSVersionInfo;
        OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );

        if ( GetVersionExA( &OSVersionInfo ) )
        {
            g_nOSWinNT = OSVersionInfo.dwPlatformId;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  -- Module handle
//              [dwReason]   -- Reason for call
//              [lpReserved] -- Unused
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason, void * lpReserved )
{
    BOOL fOK = TRUE;

    CExceptionTranslator xlate;

    try
    {
        if ( DLL_PROCESS_ATTACH == dwReason )
        {
            #if DBG == 1 
                InitTracerTags();
            #endif
    
            DisableThreadLibraryCalls( (HINSTANCE) hInstance );
    
            InitOSVersion();
    
            TagHashTable.Init();
        }
        else if ( DLL_PROCESS_DETACH == dwReason )
        {
            #if DBG == 1 
                DeleteTracerTags();
                ShutdownTracer();
            #endif  
        }
    }
    catch( CException & e )
    {
        fOK = FALSE;
    }

    return fOK;
} //DllMain


// Register classes
// 1. HKLM\SOFTWARE\Classes\.htm w/ default value "htmlfile"
// 2. HKLM\SOFTWARE\Classes\htmlfile\CLSID w/ value GUID 253369...

SClassEntry aHTMLClasses[] =
{
    { L".odc",  L"odcfile",       L"",      L"{25336920-03F9-11cf-8FD0-00AA00686F13}", L"ODC file" },
    { L".hhc",  L"hhcfile",       L"",      L"{7f73b8f6-c19c-11d0-aa66-00c04fc2eddc}", L"HHC file" },
    { L".htm",  L"htmlfile",      L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },  // htmlfile guid
    { L".html", L"htmlfile",      L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htx",  L"htmlfile",      L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".stm",  L"htmlfile",      L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htw",  L"htmlfile",      L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".asp",  L"asp_auto_file", L"", L"{bd70c020-2d24-11d0-9110-00004c752752}", L"ASP auto file" },
    { L".aspx", L"aspxfile",      L"", L"{ffb10349-5267-4c96-8ad7-01b52a2de434}", L"Active Server Page Plus" },
    { L".ascx", L"ascxfile",      L"", L"{ea25106f-12f5-4460-a10a-19e48fff1da5}", L"ASP.NET User Controls" },
    { L".css",  L"cssfile",       L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".hta",  L"htafile",       L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
    { L".htt",  L"httfile",       L"",     L"{25336920-03f9-11cf-8fd0-00aa00686f13}", L"HTML file" },
};


// Register persistent handler
//  1. HKLM\SOFTWARE\Classes\{EEC9...} w/ value "HTML File Persistent handler"
//  2. ...\PersistentAddinsRegistered\{IID_IFilter} w/ value {E0CA....}

SHandlerEntry const HTMLHandler =
{
    L"{eec97550-47a9-11cf-b952-00aa0051fe20}",          // html persistent handler
    L"HTML File persistent handler",
    L"{e0ca5340-4534-11cf-b952-00aa0051fe20}"           // html filter DLL
};

// NOTE:  Filter DLL GUID must match GUID defined at top of htmliflt.cxx

// Register filter DLL
//  Software\Classes\CLSID\{guid}\InprocServer32
// w/ default value "nlhtml.dll"

SFilterEntry const HTMLFilter =
{
    L"{e0ca5340-4534-11cf-b952-00aa0051fe20}",          // html filter DLL
    L"HTML filter",
    L"nlhtml.dll",                      // must match TARGETNAME in sources
    L"Both"
};

DEFINE_REGISTERFILTER( HTML, HTMLHandler, HTMLFilter, aHTMLClasses )

STDAPI DllRegisterServer(void)
{
    HMODULE hMod = GetModuleHandleW(HTMLFilter.pwszDLL);
    if(hMod == NULL) return HRESULT_FROM_WIN32(GetLastError());

    NameString csHHCDesc;
    NameString csHTMLDesc;
    NameString csASPDesc;
    NameString csASPXDesc;
    NameString csASCXDesc;

    csHHCDesc.Load((HINSTANCE)hMod, 1);
    csHTMLDesc.Load((HINSTANCE)hMod, 2);
    csASPDesc.Load((HINSTANCE)hMod, 3);
    csASPXDesc.Load((HINSTANCE)hMod, 4);
    csASCXDesc.Load((HINSTANCE)hMod, 5);

    //
    //  Override static strings
    //
    aHTMLClasses[0].pwszDescription = aHTMLClasses[0].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //odc

    aHTMLClasses[1].pwszDescription = aHTMLClasses[1].pwszClassIdDescription = csHHCDesc.GetBuffer();  //hhc

    aHTMLClasses[2].pwszDescription = aHTMLClasses[2].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //htm
    aHTMLClasses[3].pwszDescription = aHTMLClasses[3].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //html
    aHTMLClasses[4].pwszDescription = aHTMLClasses[4].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //htx
    aHTMLClasses[5].pwszDescription = aHTMLClasses[5].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //stm
    aHTMLClasses[6].pwszDescription = aHTMLClasses[6].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //htw

    aHTMLClasses[7].pwszDescription = aHTMLClasses[7].pwszClassIdDescription = csASPDesc.GetBuffer();  //asp
    aHTMLClasses[8].pwszDescription = aHTMLClasses[8].pwszClassIdDescription = csASPXDesc.GetBuffer(); //aspx
    aHTMLClasses[9].pwszDescription = aHTMLClasses[9].pwszClassIdDescription = csASCXDesc.GetBuffer(); //ascx

    aHTMLClasses[10].pwszDescription = aHTMLClasses[10].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //css
    aHTMLClasses[11].pwszDescription = aHTMLClasses[11].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //hta
    aHTMLClasses[12].pwszDescription = aHTMLClasses[12].pwszClassIdDescription = csHTMLDesc.GetBuffer(); //htt

    return HTMLRegisterServer();
}

STDAPI DllUnregisterServer(void)
{
    return HTMLUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\langtag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999 - 2001.
//
//  File:       langtag.cxx
//
//  Contents:   Handler for tags where lang attribute is allowed
//              in the start-tag
//
//  History:    05-Dec-1999     KitmanH     Created
//
//  Notes:
// 
//  This is the generic handler for tags which have simple parameter
//  values which do not have end tags All the filter chunk data comes from the
//  parameters of the start tag and is returned immediately upon parsing
//  the start tag, so a single CHtmlElement-derived object may be used
//  to filter all such tags defined in the tag table.
// 
//  This can be used for tags that DO have end tags, so long as the body text
//  between the start tag and end tag is filtered as ordinary Content, and
//  the end tag is ignored.  To do otherwise would require a separate
//  object instance for each such tag.
// 
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern const WCHAR * WCSTRING_LANG;
extern const WCHAR * WCSTRING_NEUTRAL;

//+-------------------------------------------------------------------------
//
//  Method:     CLangTag::CLangTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CLangTag::CLangTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CLangTag::GetLangInfo, private
//
//  Synopsis:   Retrieves the lang info
//
//  Arguments:  [pLocale] -- output pointer to the locale ID
//
//  Returns:    FALSE if the tag is not a start tag   
//
//  History:    16-Dec-1999 KitmanH     Created
//
//--------------------------------------------------------------------------

BOOL CLangTag::GetLangInfo( LCID * pLocale )
{
    Win4Assert( IsStartToken() ); 

    *pLocale = _htmlIFilter.GetCurrentLocale();
 
    PTagEntry pTE = GetTagEntry();

    _scanner.ReadTagIntoBuffer();

    // look for lang
    Win4Assert( NULL != pTE->GetParamName() && 
                !_wcsicmp ( pTE->GetParamName(), WCSTRING_LANG ) );

    //
    // Read value from the parameter specified by the tag table entry.
    // No distinction is made between having a null value for the param
    // vs. not containing the param= at all.
    //
    WCHAR * pwcsLocale;
    unsigned cwcLocale = 0;

    _scanner.ScanTagBuffer( pTE->GetParamName(),
                            pwcsLocale,
                            cwcLocale );

    if(cwcLocale >= MAX_LOCALE_LEN)
    {
        cwcLocale = MAX_LOCALE_LEN - 1;
    }
    WCHAR wcsLocale[MAX_LOCALE_LEN];
    RtlCopyMemory( wcsLocale, pwcsLocale, cwcLocale * sizeof(WCHAR) );

    if ( 0 == cwcLocale )
        return FALSE;

    wcsLocale[cwcLocale] = L'\0';

    if( 0 == _wcsicmp( wcsLocale, WCSTRING_NEUTRAL ) )
        *pLocale = LOCALE_NEUTRAL;
    else
    {
        *pLocale = _htmlIFilter.GetLCIDFromString( wcsLocale );
        if ( 0 == *pLocale )
        {
            // If not found, look for just the base part e.g.
            // "en" instead of "en-us".
                
            LPWSTR pw = wcschr ( wcsLocale , L'-');
            if ( NULL != pw && pw != wcsLocale )
            {
                *pw = 0;
                *pLocale = _htmlIFilter.GetLCIDFromString( wcsLocale );
            }
        }
    }
    
    return TRUE;

}


//+-------------------------------------------------------------------------
//
//  Method:     CLangTag::PushLangTag
//
//  Synopsis:   This funtion 
//              looks for the lang attribute (lang=). If lang attriubte exist, 
//              it will be pushed onto the LangInfoStack
//
//  History:    16-Dec-1999     KitmanH     Created
//
//--------------------------------------------------------------------------

void CLangTag::PushLangTag()
{
    LCID locale = LOCALE_NEUTRAL;
    BOOL fLangAttr = FALSE; 

    if ( !IsStartToken() )
    {
        _htmlIFilter.PopLangTag( GetTokenType() );
        _scanner.EatTag();
    }
    else
    {
        if ( GetLangInfo( &locale ) )
        {
            fLangAttr = TRUE;
            if ( ( LOCALE_NEUTRAL != locale ) &&
                 ( !IsValidLocale( locale, LCID_SUPPORTED ) ) )
                locale = _htmlIFilter.GetDefaultLocale(); 
        }
        
        _htmlIFilter.PushLangTag( GetTokenType(), fLangAttr, locale );
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CLangTag::InitStatChunk
//
//  Synopsis:   This function does not really initialize the stat chunk. It's 
//              here just for compilational purpose
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//  Returns:    always return FALSE, because no chunk is returned
//
//  History:    20-Dec-1999     KitmanH     Created
//
//--------------------------------------------------------------------------

BOOL CLangTag::InitStatChunk( STAT_CHUNK *pStat )
{
    _scanner.EatTag();
    Win4Assert( !"CLangTag::InitStatChunk() call unexpected" );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\islist.h ===
//---------------------------------------------------------------
//  File:               ISList.h
//        
//      Synopsis:       Header for the pointer based 
//                              single linked list of COM objects
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Author:    Dmitriy Meyerzon
//----------------------------------------------------------------

#ifndef __ISLIST_H
#define __ISLIST_H

#include "semcls.h" 
#include "slnklist.h"
#include "tpagepool.h"
#include "lmstr.hxx"

//
// class CUnkSingleLink
//
// indirects a pointer to T
//
class CUnkSingleLink: public CSingleLink,
    public TPagedMemPooled<CUnkSingleLink>
{
        public:

        CUnkSingleLink() {}
        ~CUnkSingleLink() {}    //do not destroy value

        HRESULT GetValue(IUnknown** ppValue) 
        { 
                m_pValue->AddRef(); 
                *ppValue = m_pValue;
                return S_OK;
        }
        
        void SetValue(IUnknown* pValue) 
        { 
                m_pValue = pValue; 
        }

        private:
        TComPointer<IUnknown> m_pValue;
};

//
// class CUnkSList - a list of CUnkSingleLink elements
//
//
class CUnkSList: protected CLnkList
{
        public:

        CUnkSList() : CLnkList() {};
        ~CUnkSList() { RemoveAll(); }

        CLnkList::GetEntries;
        CLnkList::IsEmpty;

        HRESULT GetFirst(IUnknown** ppUnk) const { return GetLinkValue(CLnkList::GetFirst(), ppUnk); }

        HRESULT GetLast(IUnknown** ppUnk) const { return GetLinkValue(CLnkList::GetLast(), ppUnk); }

        HRESULT Append(IUnknown* pValue) 
        { 
                CUnkSingleLink *pLink = CreateLink(pValue);
                CLnkList::Append(pLink);
                return pLink ? S_OK : E_OUTOFMEMORY;
        }

        HRESULT Prepend(IUnknown*pValue) 
        { 
                CUnkSingleLink *pLink = CreateLink(pValue);
                CLnkList::Prepend(pLink);
                return pLink ? S_OK : E_OUTOFMEMORY;
        }

        HRESULT RemoveFirst(IUnknown** ppUnk);
        HRESULT RemoveLast(IUnknown** ppUnk);

        HRESULT GetAt(UINT i, IUnknown**ppUnk) const { return GetLinkValue(CLnkList::GetAt(i), ppUnk); }

        HRESULT InsertAt(IUnknown* pValue, UINT i) 
        { 
                CUnkSingleLink *pLink = CreateLink(pValue);
                CLnkList::InsertAt(pLink, i);
                return pLink ? S_OK : E_OUTOFMEMORY;
        }

        HRESULT Contains(IUnknown*pUnk) const;

        HRESULT Remove(IUnknown* ppUnk);
        HRESULT RemoveAt(UINT i, IUnknown** ppUnk);
        void RemoveAll();

        
        private:
        CUnkSList(CUnkSList &rList);

        protected:
        
        CUnkSingleLink *CreateLink(IUnknown*pValue);
        void DestroyLink(CUnkSingleLink *pLink);

        static HRESULT GetLinkValue(const CSingleLink *pSLink, IUnknown** ppUnk);

        friend class CUnkSListIter;     
};

//
// the iterator
//
class CUnkSListIter
{
        public:
        CUnkSListIter(CUnkSList& rList): 
                m_LnkList(&rList), m_Position((CUnkSingleLink *)&rList.m_Begin), m_Prior(NULL) 
                {}
        CUnkSListIter(): m_LnkList(NULL), m_Position(NULL), m_Prior(NULL) {}
        ~CUnkSListIter() {}

        CUnkSListIter(CUnkSListIter &other) { *this = other; }

        void operator =(const CUnkSListIter &other)
        {
                m_LnkList = other.m_LnkList;
                m_Position = other.m_Position;
                m_Prior = other.m_Prior;
        }

        BOOL operator++();

        CUnkSList*       GetList() const { return m_LnkList; }

        HRESULT GetCurrentValue(IUnknown** ppUnk) const 
        { 
                return CUnkSList::GetLinkValue(m_Prior ? m_Position : NULL, ppUnk); 
        }

        HRESULT GetPriorValue(IUnknown **ppUnk) const
        {
                return CUnkSList::GetLinkValue(
                        m_Prior && m_Prior != &m_LnkList->m_Begin ? m_Prior : NULL, ppUnk);
        }

        void  Reset() { if(m_LnkList) { m_Position = (CUnkSingleLink *)&m_LnkList->m_Begin; m_Prior = NULL;} }
        HRESULT Remove(IUnknown**ppUnk)
        { 
                HRESULT hr = S_FALSE;

                if(m_LnkList && m_Prior && m_Position)
                {
                        CUnkSingleLink *pLink = (CUnkSingleLink *)m_LnkList->RemoveAfter(m_Prior);
                        if(pLink)
                        {
                                hr =  pLink->GetValue(ppUnk);
                                m_LnkList->DestroyLink(pLink);
                        }
                        m_Position = (CUnkSingleLink *)m_Prior->m_plNext;
                        if(m_Position == (CUnkSingleLink *)&m_LnkList->m_End) m_Position = NULL;
                }

                return hr;
        }

        HRESULT Move(BOOL fUp, IUnknown **ppUnkReplaced);

        HRESULT Insert(IUnknown *pUnk)
        {
                if(m_LnkList == NULL) return E_UNEXPECTED;

                CUnkSingleLink *pNewLink = m_LnkList->CreateLink(pUnk);
                if(pNewLink == NULL) return E_OUTOFMEMORY;

                m_LnkList->InsertAfter(m_Prior ? m_Prior : m_Position,
                                                                        pNewLink);

                if(m_Prior == NULL) m_Prior = (CUnkSingleLink *)&m_LnkList->m_Begin;

                m_Position = (CUnkSingleLink *)m_Prior->m_plNext;

                return S_OK;
        }

        protected:

        CUnkSList*       m_LnkList;                     // The list over which we are iterating
        CUnkSingleLink* m_Position;             // Iter position
        CUnkSingleLink* m_Prior;

        friend class CUnkHMapUnkter;
};

//
// class CInterfaceSList - a list of CUnkSingleLink elements
//
//
template <class I>  class CInterfaceSList: public CUnkSList
{
        public:

        CInterfaceSList() : CUnkSList() {}
        ~CInterfaceSList() { }

        HRESULT GetFirst(I** ppI) const { return CUnkSList::GetFirst((IUnknown **)ppI); }

        HRESULT GetLast(I** ppI) const { return CUnkSList::GetLast((IUnknown **)ppI); }

        HRESULT Append(I* pI) { return CUnkSList::Append((IUnknown *)pI); }
        HRESULT Prepend(I* pI) { return CUnkSList::Prepend((IUnknown *)pI); }
        HRESULT RemoveFirst(I** ppI) { return CUnkSList::RemoveFirst((IUnknown **)ppI); }
        HRESULT RemoveLast(I** ppI) { return CUnkSList::RemoveLast((IUnknown **)ppI); }

        HRESULT GetAt(UINT i, I**ppI) const { return CUnkSList::GetAt(i, (IUnknown **)ppI); }

        HRESULT InsertAt(I* pI, UINT i) { return CUnkSList::InsertAt((IUnknown *)pI, i); }

        HRESULT Contains(I*pI) const { return CUnkSList::Contains((IUnknown *)pI); }

        HRESULT Remove(I* pI) { return CUnkSList::Remove((IUnknown *)pI); }
        HRESULT RemoveAt(UINT i, I** ppI) { return CUnkSList::RemoveAt(i, (IUnknown **)ppI); }
        
        private:
        CInterfaceSList(CInterfaceSList &rList);
};

//
// the iterator
//
template <class I>  class CInterfaceSListIter: public CUnkSListIter
{
        public:
        CInterfaceSListIter(CInterfaceSList<I>& rList): 
                CUnkSListIter(rList) {}
        CInterfaceSListIter() {}
        ~CInterfaceSListIter() {}

        CInterfaceSListIter(CInterfaceSListIter<I> &other) { CUnkSListIter::operator=(other); }

        void operator =(const CInterfaceSListIter<I> &other)
        {
                CUnkSListIter::operator=(other);
        }

        BOOL operator++() { return CUnkSListIter::operator++(); }

        CInterfaceSList<I>*      GetList() const 
        { 
                return (CInterfaceSList<I> *)CUnkSListIter::GetList(); 
        }

        HRESULT GetCurrentValue(I** ppI) const 
        { 
                return CUnkSListIter::GetCurrentValue((IUnknown **)ppI);
        }

        HRESULT Remove(I**ppI)
        { 
                return CUnkSListIter::Remove((IUnknown **)ppI);
        }

        HRESULT Move(BOOL fUp, I**ppI)
        {
                return CUnkSListIter::Move(fUp, (IUnknown **)ppI);
        }

        HRESULT Insert(I *pI) 
        { 
                return CUnkSListIter::Insert((IUnknown *)pI); 
        }
};

template <class T, class I> class CNamedISList: public CInterfaceSList<I>
{
        public:

        CNamedISList() : CInterfaceSList<I>() {}
        ~CNamedISList() { }

        HRESULT Lookup(CLMSubStr *psName, T**ppT)
        {
                if(ppT == NULL) return E_POINTER;

                CInterfaceSListIter<I> next(*this);
                while(++next)
                {
                        TComPointer<I> pI;
                        next.GetCurrentValue(&pI);

                        if(((T*)(I*)pI)->GetName() == *psName)
                        {
                                pI->AddRef();
                                *ppT = (T*)(I*)pI;
                                return S_OK;
                        }
                }

                return S_FALSE;
        }

        HRESULT RemoveFirst(T**ppT)
        {
                if(ppT == NULL) return E_POINTER;
                TComPointer<I> pI;
                HRESULT hr = CInterfaceSList<I>::RemoveFirst(&pI);
                if(hr != S_OK) return hr;
                pI->AddRef();
                *ppT = (T*)(I*)pI;
                return S_OK;
        }

        private:
        CNamedISList(const CNamedISList<T,I> &);
};

template <class T, class I> class CNamedListIter: public CInterfaceSListIter<I>
{
        public:

        CNamedListIter(CNamedISList<T,I>& rList): 
                CInterfaceSListIter<I>(rList) {}
        CNamedListIter() {}
        ~CNamedListIter() {}

        CNamedListIter(CNamedListIter<T,I> &other) 
        {
                CInterfaceSListIter<I>::operator=(other); 
        }

        void operator =(const CInterfaceSListIter<I> &other)
        {
                CUnkSListIter::operator=(other);
        }
        

        HRESULT GetCurrentValue(T** ppT) const 
        { 
        I* pI;
                HRESULT hr = CInterfaceSListIter<I>::GetCurrentValue(&pI);
        if (hr == S_OK) 
            *ppT = (T*) pI;

        return hr;
            
        }

        HRESULT Remove(T** ppT)
        {
        I* pI;
                HRESULT hr = CInterfaceSListIter<I>::Remove(&pI);
        if (hr == S_OK) 
            *ppT = (T*) pI;

        return hr;
        }

        HRESULT Move(BOOL fUp, T**ppT)
        {
        I* pI;
                HRESULT hr = CInterfaceSListIter<I>::Move(fUp, &pI);
        if (hr == S_OK) 
            *ppT = (T*) pI;

        return hr;
        }
};

//
// class TUnkSList - a list of TUnkSingleLink elements
//
//

template <class T>
class TUnkSListIter;

template <class T>
class TUnkSList: public CUnkSList
{
        public:

        TUnkSList() : CUnkSList() {}
        ~TUnkSList() {}

        HRESULT GetFirst(T** ppT) const 
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::GetFirst(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT GetLast(T** ppT) const 
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::GetLast(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT Append(T* pValue) 
        { 
                return CUnkSList::Append((IUnknown *)pValue);
        }

        HRESULT Prepend(T* pValue) 
        { 
                return CUnkSList::Prepend((IUnknown *)pValue);
        }

        HRESULT RemoveFirst(T** ppT)
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::RemoveFirst(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT RemoveLast(T** ppT)
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::RemoveLast(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT GetAt(UINT i, T**ppT) const 
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::GetAt(i, &pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT InsertAt(T* pValue, UINT i) 
        { 
                return CUnkSList::InsertAt((IUnknown *)pValue, i);
        }

        HRESULT Contains(T*pT) const 
        { 
                return CUnkSList::Contains((IUnknown *)pT);
        }

        HRESULT Remove(T* pT) { return CUnkSList::Remove((IUnknown *)pT); }
        HRESULT RemoveAt(UINT i, T** ppT)
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSList::RemoveAt(i, &pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        friend class TUnkSListIter<T>;  
};

//
// the iterator
//

template <class T>
class TUnkSListIter: public CUnkSListIter
{
        public:
        TUnkSListIter(TUnkSList<T>& rList):  CUnkSListIter((CUnkSList &)rList) {}
        TUnkSListIter(): CUnkSListIter() {}
        ~TUnkSListIter() {}

        TUnkSListIter(TUnkSListIter &other) { *this = other; }

        void operator =(const TUnkSListIter<T> &other)
        {
                CUnkSListIter::operator =((const CUnkSListIter &)other);
        }

        BOOL operator++() { return CUnkSListIter::operator ++(); }

        TUnkSList<T>*    GetList() const 
        { 
                return (TUnkSList<T> *)CUnkSListIter::GetList(); 
        }

        HRESULT GetCurrentValue(T** ppT) const 
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSListIter::GetCurrentValue(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT GetPriorValue(T **ppT) const
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSListIter::GetPriorValue(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT Remove(T**ppT)
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSListIter::Remove(&pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }


        HRESULT Move(BOOL fUp, T **ppT)
        { 
                IUnknown *pUnk;
                HRESULT hr = CUnkSListIter::Move(fUp, &pUnk);
                if(hr == S_OK) *ppT = (T*)pUnk;
                return hr;
        }

        HRESULT Insert(T *pT)
        {
                return CUnkSListIter::Insert((IUnknown *)pT);
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\lmstr.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       lmstr.h
//
//  Contents:   Lean and Mean string header
//
//  Classes:    CLMString and TLMString
//
//  Functions:
//
//  History:    4-23-96   Krishna Nareddi   Created
//                              4-24/96   Dmitriy Meyerzon  added CLMString class
//              9-06-97   micahk            add/fix some WC/MB support
//              18-Nov-99 KLam              Win64 warning fixes
//
//----------------------------------------------------------------------------

#include "pch.cxx"

//
// class CLMString construction
//

CLMString::CLMString(unsigned uMaxLen, LPTSTR pchData, TCHAR ch, unsigned nRepeat):
        m_uMaxLen(uMaxLen), m_pchData(pchData)
{
    unsigned i;
    if(nRepeat + 1 > uMaxLen) GrowInConstructor(nRepeat + 1);

    for(i=0;i<nRepeat;i++)
    {
        *(pchData++) = ch;
    }
    *pchData = 0;
    m_uLen = nRepeat;
}

#ifdef _UNICODE
CLMString::CLMString(unsigned uMaxLen, LPTSTR pchData, LPCSTR lpsz):
        m_uMaxLen(uMaxLen), m_pchData(pchData)
{
    AssignInConstructor(lpsz);
}
#else
CLMString::CLMString(unsigned uMaxLen, LPTSTR pchData, LPCWSTR lpsz):
        m_uMaxLen(uMaxLen), m_pchData(pchData)
{
    unsigned uLen;

    if(lpsz == NULL) throw CNLBaseException(E_POINTER);

    uLen = (unsigned)lstrlenW(lpsz);
    if (2 * uLen + 1 > m_uMaxLen)
    {
        GrowInConstructor(2 * uLen + 1);
    }

    m_uLen = WideCharToMultiByteSZ(lpsz, uLen, m_pchData, 2*uLen + 1);
}
#endif // _UNICODE

void CLMString::GrowInConstructor(unsigned uLen)
{
    m_pchData = new TCHAR[ uLen ];
    m_uMaxLen = uLen;
}

int CLMString::Assign(LPCTSTR lpsz, unsigned uStart, unsigned uLen)
{
        if(lpsz == NULL) throw CNLBaseException(E_INVALIDARG);
        if (uLen == LMSTR_ENTIRE_STRING)
        {
            uLen = lstrlen(lpsz);
        }

        if (uStart + uLen + 1 > m_uMaxLen)
        {
            GrowString(uStart + uLen + 1);
        }
        else if (uStart == 0)
        {
            CleanString(uStart + uLen + 1);
        }

        Assert(uStart + uLen + 1 <= m_uMaxLen);

        CopyMemory(&m_pchData[uStart], lpsz, uLen*sizeof(TCHAR));
        m_uLen = uStart+uLen;
        m_pchData[m_uLen] = 0;
        return m_uLen;
}

#ifdef _UNICODE
int CLMString::Assign(LPCSTR lpsz, unsigned uStart, unsigned uLen)
{
        if(lpsz == NULL) throw CNLBaseException(E_INVALIDARG);
        if (uLen == LMSTR_ENTIRE_STRING)
        {
        uLen = lstrlenA(lpsz);
        }

        if (uStart + uLen + 1 > m_uMaxLen)
        {
                GrowString(uStart + uLen + 1);
        }
        else if (uStart == 0)
        {
                CleanString(uStart + uLen + 1);
        }

        Assert(uStart + uLen + 1 <= m_uMaxLen);

    m_uLen = uStart;
    m_uLen += MultiByteToWideCharSZ(lpsz, uLen, &m_pchData[uStart], uLen + 1);
        return m_uLen;
}
#else
int CLMString::Assign(LPCWSTR lpsz, unsigned uStart, unsigned uLen)
{
        if(lpsz == NULL) throw CNLBaseException(E_INVALIDARG);
        if (uLen == LMSTR_ENTIRE_STRING)
        {
            uLen = (unsigned)lstrlenW(lpsz);
        }

        if (uStart + 2*uLen + 1 > m_uMaxLen)
        {
                GrowString(uStart + 2*uLen + 1);
        }
        else if (uStart == 0)
        {
                CleanString(uStart + 2*uLen + 1);
        }

        Assert(uStart + 2*uLen + 1 <= m_uMaxLen);

    m_uLen = uStart;
    m_uLen += WideCharToMultiByteSZ(lpsz, uLen, &m_pchData[uStart], 2*uLen + 1);
        return m_uLen;
}
#endif // _UNICODE

int CLMString::AssignInConstructor(LPCTSTR lpsz, unsigned uLen)
{
        if(lpsz == NULL) throw CNLBaseException(E_INVALIDARG);
        if (uLen == LMSTR_ENTIRE_STRING)
        {
                uLen = lstrlen(lpsz);
        }

        if (uLen + 1 > m_uMaxLen)
        {
                GrowInConstructor(uLen + 1);
        }

        CopyMemory(m_pchData, lpsz, uLen*sizeof(TCHAR));
        m_uLen = uLen;
        m_pchData[m_uLen] = 0;
        return m_uLen;
}

#ifdef UNICODE
int CLMString::AssignInConstructor(LPCSTR psz)
//+-----------------------------------------------
//
//      Function:       CLMString::AssignInConstructor
//
//      Synopsis:       Assigns in constructor a multibyte string into UNICODE
//
//      Arguments:
//      [LPCSTR psz]    - multibyte string
//
//      History:        7/20/2000       dmitriym        Created
//
//+-----------------------------------------------
{
        unsigned uLen;

        if(psz == NULL) throw CNLBaseException(E_POINTER);

        uLen = lstrlenA(psz);
        if (uLen + 1 > m_uMaxLen)
                        GrowInConstructor(uLen + 1);

    m_uLen = MultiByteToWideCharSZ(psz, uLen, m_pchData, uLen + 1);

    return m_uLen;
}
#endif

void CLMString::TrimRight()
{
        // find beginning of trailing spaces by starting at beginning (DBCS aware)
        LPTSTR lpsz = m_pchData;
        LPTSTR lpszLast = NULL;
        while (*lpsz != 0)
        {
                if (_istspace(*lpsz))
                {
                        if (lpszLast == NULL)
                                lpszLast = lpsz;
                }
                else
                        lpszLast = NULL;
                lpsz = _tcsinc(lpsz);
        }

        if (lpszLast != NULL)
        {
                // truncate at trailing space start
                *lpszLast = 0;
        Assert ( ULONG_MAX >= (ULONG_PTR)(lpszLast - m_pchData) );
                m_uLen = (unsigned)(ULONG_PTR)(lpszLast - m_pchData);
        }
}

void CLMString::TrimLeft()
{
        // find first non-space character
        LPCTSTR lpsz = m_pchData;
        while (_istspace(*lpsz))
                lpsz = _tcsinc(lpsz);

        // fix up data and length
    Assert ( ULONG_MAX >= (ULONG_PTR)(lpsz - m_pchData) );
        m_uLen -= (unsigned)(ULONG_PTR)(lpsz - m_pchData);
        CopyMemory(m_pchData, lpsz, (m_uLen+1)*sizeof(TCHAR));
}

void CLMString::ReplaceAll(TCHAR cWhat, TCHAR cWith, unsigned uStart)
{
        int whatIndex = Find(cWhat, uStart);
        while(whatIndex != -1)
        {
                m_pchData[(unsigned)whatIndex] = TCHAR(cWith);
                whatIndex = Find(cWhat, whatIndex+1);
        }
}


void CLMString::CleanStringHelper (unsigned uLenWanted,  unsigned uOrgSize, LPCTSTR pchOrgData)
{
        //NOTE: this does not copy memory so it should only be used when
        //              you want to over-write the current string, as in the case of an assign
        //              to a zero offset
        if (uLenWanted < uOrgSize)
        {
                DeleteBuf (pchOrgData);
                m_pchData = (LPTSTR)pchOrgData;
                m_uMaxLen = uOrgSize;
        }
}


void CLMString::GrowStringHelper (unsigned uLenWanted,  unsigned uMaxGrowOnce, unsigned uMaxEver,
                                                                 LPCTSTR pchOrgData)
{
        if (uLenWanted <= m_uMaxLen)
        {
                return; //we're already there.
        }

        if (uLenWanted > uMaxEver) throw CNLBaseException(HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));

        TCHAR * pchNewData;
        unsigned nNewLen;
        unsigned uGrowBy;

        uGrowBy = min(m_uMaxLen, uMaxGrowOnce);
        Assert(uGrowBy > 0);
        nNewLen = (uLenWanted%uGrowBy == 0) ? uLenWanted :
                                        (uLenWanted/uGrowBy + 1)*uGrowBy;

        //any of the above permutations should always cause us to allocate
        //at least as much as was requested.
        Assert(nNewLen >= uLenWanted);

        pchNewData = new TCHAR[ nNewLen ];
        CopyMemory( pchNewData, m_pchData, (m_uLen + 1)*sizeof(TCHAR) );
        if ( m_pchData != pchOrgData )
        {
            delete [] m_pchData;
        }
        m_pchData = pchNewData;
        m_uMaxLen = nNewLen;

}

HRESULT CLMString::Export(TCHAR wszBuffer[], DWORD dwSize, DWORD *pdwLength) const
//+-----------------------------------------------
//
//      Function:       CLMString::Export
//
//      Synopsis:       Copies the string into the buffer
//
//      Arguments:
//      [TCHAR wszBuffer[]]     -
//      [DWORD dwSize]  -
//      [DWORD *pdwLength]      -
//
//      History:        1/28/99 dmitriym        Created
//
//+-----------------------------------------------
{
        if(dwSize < GetLength()+1)
        {
                if(pdwLength)
                {
                        *pdwLength = GetLength() + 1;
                }

        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        if(pdwLength)
        {
                *pdwLength = GetLength();
        }

        CopyMemory(wszBuffer, m_pchData, (GetLength()+1)*sizeof(TCHAR));

        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\mmbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.
//
//  File:       mmstrm.cxx
//
//  Contents:   Memory Mapped Buffer, Safe ptr to stream
//
//  Classes:    CMmStreamBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


CMmStreamBuf::~CMmStreamBuf()
{
    if (_buf && _pStream )
        _pStream->Unmap(*this);
}

SMmStream::~SMmStream()
{
    delete _pStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\memthrow.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       memthrow.h
//
//  Contents:   operator new that throws when memory allocation fails.
//
//  History:    4-13-97   srikants   Created
//
//  Notes:      To use this operator new, for say allocating a byte array use
//
//              BYTE * p = new(eThrow) BYTE[100];
//
//----------------------------------------------------------------------------

#pragma once

#include <eh.h>

// define _T macro
#include <tchar.h>

#pragma warning(4:4535)         // set_se_translator used w/o /EHa

#ifndef TRANSLATE_EXCEPTIONS
#define TRANSLATE_EXCEPTIONS   _se_translator_function __tf = _set_se_translator( SystemExceptionTranslator );
#define UNTRANSLATE_EXCEPTIONS _set_se_translator( __tf );
#endif

void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept );
class CExceptionTranslator
{
    public:
    CExceptionTranslator()
    {
        m__tf = _set_se_translator( SystemExceptionTranslator );
    }

    ~CExceptionTranslator()
    {
        _set_se_translator( m__tf );
    }

    private:
    _se_translator_function m__tf;
};

#define EXCEPTION_TRANSLATOR    CExceptionTranslator translator

enum ENewThrowType { eThrow };

//+---------------------------------------------------------------------------
//
//  Function:   new
//
//  Synopsis:   A memory allocator that throws a CException when it
//              cannot allocate memory.
//
//  History:    4-13-97   srikants   Created
//
//----------------------------------------------------------------------------

inline void * __cdecl operator new (  size_t size, ENewThrowType eType )
{
    void * p = (void *) new BYTE [size];
    if ( 0 == p )
        throw CException(E_OUTOFMEMORY);

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\mmistrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mmistrm.hxx
//
//  Contents:   Memory Mapped IStream
//
//  Classes:    CMmIStream
//
//  History:    11-Feb-97 KyleP     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmistrm.hxx>

#define THROW throw

unsigned const cbMaxMappable = 1024 * 1024;

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::CMMIStream, public
//
//  Synopsis:   Constructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::CMmIStream()
        : _pStream( 0 ),
          _pBuf( 0 )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::~CMMIStream, public
//
//  Synopsis:   Destructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::~CMmIStream()
{
    Close();
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Open, public
//
//  Synopsis:   Opens a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Open( IStream * pStream )
{
    Win4Assert( 0 == _pStream );
    Win4Assert( 0 == _pBuf );

    _pStream = pStream;
    _pStream->AddRef();

    //
    // Get stream stats.
    //

    SCODE sc = pStream->Stat( &_statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Close, public
//
//  Synopsis:   Close a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Close()
{
    if ( 0 != _pStream )
        _pStream->Release();

    delete [] _pBuf;

    _pStream = 0;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::MapAll, public
//
//  Synopsis:   Map all of a stream
//
//  Arguments:  [sbuf] -- Stream buffer to fill in
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::MapAll( CMmStreamBuf& sbuf )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( 0 != SizeHigh() )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ) ) );

    Map( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Map, public
//
//  Synopsis:   Map part of a stream
//
//  Arguments:  [sbuf]         -- Stream buffer to fill in
//              [cb]           -- Size to map
//              [offLow]       -- Offset in stream
//              [offHigh]      -- Offset in stream
//              [fMapForWrite] -- TRUE --> Writeable (invalid option here)
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Map ( CMmStreamBuf& sbuf,
                       ULONG cb,
                       ULONG offLow,
                       ULONG offHigh,
                       BOOL  fMapForWrite )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( cb > cbMaxMappable )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ) ) );

    //
    // Now, allocate the memory.
    //

    Win4Assert( 0 == _pBuf );
    _pBuf = new BYTE [ cb ];

    //
    // Then seek and read.
    //

    LARGE_INTEGER off = { offLow, offHigh };

    SCODE sc = _pStream->Seek( off,
                               STREAM_SEEK_SET,     // From beginning of file
                               0 );                 // Don't return new seek pointer

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    ULONG cbRead = 0;

    sc = _pStream->Read( _pBuf, cb, &cbRead );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    if ( cb > cbRead )
    {
        THROW( CException( E_FAIL ) );
    }

    //
    // Finally, set up the buffer.
    //

    sbuf.SetBuf( _pBuf );
    sbuf.SetSize ( cbRead );
    sbuf.SetStream ( this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Unmap, public
//
//  Synopsis:   Unmap stream
//
//  Arguments:  [sbuf]         -- Stream buffer to unmap
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Unmap ( CMmStreamBuf& sbuf )
{
    Win4Assert( sbuf.Get() == _pBuf );

    sbuf.SetBuf( 0 );
    sbuf.SetSize( 0 );

    delete [] _pBuf;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Flush, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::Flush ( CMmStreamBuf& sbuf, ULONG cb )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::FlushMetaData, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::FlushMetaData( BOOL fThrowOnFailure )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\mmscbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1996, Microsoft Corporation.
//
//  File:       mmscbuf.cxx
//
//  Contents:   Memory Mapped Stream buffer for consecutive buffer mapping
//
//  Classes:    CMmStreamConsecBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CMmStreamConsecBuf::CMmStreamConsecBuf()
    : _pMmStream(0)
{
    LARGE_INTEGER liOffset = { 0, 0 };
    _liOffset = liOffset;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CMmStreamConsecBuf::~CMmStreamConsecBuf()
{
    if ( _pMmStream && Get() != 0 )
        _pMmStream->Unmap( *this );
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Map, public
//
//  Synopsis:   Map next consecutive part of file
//
//  Arguments:  [cb] -- size of the mapped area
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Map( ULONG cb )
{
    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    LARGE_INTEGER liNewOffset;
    LARGE_INTEGER liStreamSize={_pMmStream->SizeLow(), _pMmStream->SizeHigh()};

     liNewOffset.QuadPart = cb + _liOffset.QuadPart;

    if ( liNewOffset.QuadPart > liStreamSize.QuadPart )
    {
        cb = (ULONG)(liStreamSize.QuadPart - _liOffset.QuadPart);
        liNewOffset = liStreamSize;
    }

    _pMmStream->Map( *this,
                     cb,
                     _liOffset.LowPart,
                     _liOffset.HighPart );

    _liOffset = liNewOffset;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::MapAll
//
//  Synopsis:   Map entire file
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::MapAll()
{
    Win4Assert( _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    _pMmStream->MapAll( *this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Init, public
//
//  Synopsis:   Initizializes CMmStreamConsecBuf
//
//  Arguments:  [pMmStream] -- pointer to the CMmStream from which to fill
//                             the buffer
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Init( PMmStream * pMmStream )
{
    _pMmStream = pMmStream;
    LARGE_INTEGER liOffset = { 0, 0 };
    _liOffset = liOffset;
    SetSize(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Rewind, public
//
//  Synopsis:   Rewind file to beginning.
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Rewind()
{
    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    _liOffset.LowPart = 0;
    _liOffset.HighPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Eof, public
//
//  Synopsis:   Returns whether end of file has been hit
//
//  Returns:    FALSE if there is still more file to be mapped.  TRUE
//              otherwise.
//
//--------------------------------------------------------------------------

BOOL CMmStreamConsecBuf::Eof()
{
    Win4Assert( 0 != _pMmStream );
    return( ( (ULONG) _liOffset.HighPart == _pMmStream->SizeHigh() ) &&
            ( _liOffset.LowPart == _pMmStream->SizeLow() ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\mmstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1996  Microsoft Corp.
//
//  File:       mmstrm.cxx
//
//  Contents:   Memory Mapped Stream using win32 API
//
//  Classes:    CMmStream, CMmStreamBuf
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::CMmStream
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------
CMmStream::CMmStream()
    : _hFile(INVALID_HANDLE_VALUE),
      _hMap(0),
      _hTempFileMap(0),
      _pTempFileBuf(0),
      _sizeLowTempFile(0),
      _fWrite(FALSE),
      _sizeHigh(0),
      _sizeLow(0)
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::~CMmStream
//
//  Synopsis:   destructor
//
//
//--------------------------------------------------------------------------
CMmStream::~CMmStream()
{
    if( _hMap )
        CloseHandle(_hMap);

    if ( _hFile != INVALID_HANDLE_VALUE )
        CloseHandle ( _hFile );

    if ( _pTempFileBuf != 0 )
        UnmapViewOfFile( _pTempFileBuf );

    if ( _hTempFileMap )
        CloseHandle( _hTempFileMap );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsCreateExisting
//
//  Synopsis:   Tests if the error was a result of trying to create a
//              file that already exists.
//
//  Arguments:  [Error]      --  Error returned by the system.
//              [modeAccess] --  access mode specified to CreateFile.
//              [modeCreate] --  create mode specified to CreateFile.
//
//  Returns:    TRUE if the failure is because of trying to create a "New"
//              file with the same name as the one already existing.
//              FALSE otherwise.
//
//----------------------------------------------------------------------------

BOOL IsCreateExisting( ULONG Error, ULONG modeAccess, ULONG modeCreate )
{
    if ( (Error == ERROR_ALREADY_EXISTS || Error == ERROR_FILE_EXISTS) &&
         (modeAccess & GENERIC_WRITE) &&
         (modeCreate & CREATE_NEW) )
    {
       return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Open, public
//
//  Synopsis:   Open stream
//
//  Arguments:  [path] - file path
//              [modeAccess] -- access mode
//              [modeShare] -- sharing mode
//              [modeCreate] -- create mode
//
//--------------------------------------------------------------------------

void CMmStream::Open(
    const WCHAR* wcsPath,
    ULONG modeAccess,
    ULONG modeShare,
    ULONG modeCreate,
    ULONG modeAttribute)
{
    _fWrite = FALSE;

    _hFile = CreateFile( wcsPath,
                            modeAccess,
                            modeShare,
                            0, // security
                            modeCreate,
                            modeAttribute,
                            0 ); // template

    if ( !Ok() )
    {
        //
        // If applicable, delete a zomby and re-create it.
        //
        if ( IsCreateExisting( GetLastError(), modeAccess, modeCreate ) )
        {
            htmlDebugOut(( DEB_ERROR, "CreateNew on %ws - already exists\n",
                         wcsPath ));
            modeCreate &= ~CREATE_NEW;   // Turn off the Create new flag
            modeCreate |= CREATE_ALWAYS; // Enable the CREATE_ALWAYS flag.

            _hFile = CreateFile( wcsPath,
                                    modeAccess,
                                    modeShare,
                                    0,          // security
                                    modeCreate,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0 );        // template
        }
    }

    if ( Ok() )
    {
        _sizeLow = GetFileSize ( _hFile, &_sizeHigh );

        if (_sizeLow == 0xffffffff && GetLastError() != NO_ERROR)
        {
            Close();
            htmlDebugOut (( DEB_ERROR, "Open stream %ws failed\n", wcsPath ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

        if ( modeAccess & GENERIC_WRITE )
        {
            _fWrite = TRUE;
            CommonPageRound(_sizeLow, _sizeHigh);

            if (_sizeLow == 0 && _sizeHigh == 0)
            {
                if ( SetFilePointer ( _hFile,
                                      COMMON_PAGE_SIZE,
                                      0,
                                      FILE_BEGIN ) == 0xFFFFFFFF  &&
                     GetLastError() != NO_ERROR )
                {
                    Close();
                    htmlDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetFilePointer returned %d\n",
                                 GetLastError() ));
                    throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
                }

                if ( !SetEndOfFile( _hFile ) )
                {
                    Close();
                    htmlDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetEndOfFile returned %d\n",
                                 GetLastError() ));
                    throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
                }
                _sizeLow = COMMON_PAGE_SIZE;
            }
        }

        if ( _sizeLow != 0 || _sizeHigh != 0 )
        {
            _hMap = CreateFileMapping( _hFile,
                                        0, // security
                                        _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                        _sizeHigh,
                                        _sizeLow,
                                        0 ); // name

            if (_hMap == NULL)
            {
                Close();
                htmlDebugOut (( DEB_ERROR, "File mapping failed\n" ));
                throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
            }
        }
    }
    else
    {
        htmlDebugOut (( DEB_ITRACE, "Open failed on MM Stream; GetLastError()=0x%x\n",
                      GetLastError() ));
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::InitWithTempFile
//
//  Synopsis:   Closes all handles, and initializes with temporary memory
//              mapped file
//
//--------------------------------------------------------------------------

void CMmStream::InitWithTempFile()
{
    if(_hMap )
    {
        if ( !CloseHandle(_hMap))
        {
            htmlDebugOut (( DEB_ERROR, "Closing file mapping _hMap failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hMap = 0;
    }

    if ( _hFile != INVALID_HANDLE_VALUE )
    {
        if ( !CloseHandle ( _hFile ))
        {

            htmlDebugOut (( DEB_ERROR, "Closing _hFile handle failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hFile = INVALID_HANDLE_VALUE;
    }

    if ( _pTempFileBuf != 0 )
    {
        if ( !UnmapViewOfFile( _pTempFileBuf ) )
        {
            htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile _pTempFileBuf returned %d\n", GetLastError() ));
            throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
        }

        _pTempFileBuf = 0;
    }

    _hMap = _hTempFileMap;
    _hTempFileMap = 0;
    _sizeLow = _sizeLowTempFile;

    Win4Assert( _sizeHigh == 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Close, public
//
//  Synopsis:   Closes all handles
//
//--------------------------------------------------------------------------

void CMmStream::Close()
{
    if(_hMap )
    {
        if ( !CloseHandle(_hMap))
        {
            htmlDebugOut (( DEB_ERROR, "Closing file mapping _hMap failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hMap = 0;
    }

    if ( _hFile != INVALID_HANDLE_VALUE )
    {
        if ( !CloseHandle ( _hFile ))
        {

            htmlDebugOut (( DEB_ERROR, "Closing _hFile handle failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hFile = INVALID_HANDLE_VALUE;
    }

    if ( _pTempFileBuf != 0 )
    {
        if ( !UnmapViewOfFile( _pTempFileBuf ) )
        {
            htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile _pTempFileBuf returned %d\n", GetLastError() ));
            throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
        }

        _pTempFileBuf = 0;
    }

    if ( _hTempFileMap )
    {
        if ( !CloseHandle ( _hTempFileMap ))
        {
            htmlDebugOut (( DEB_ERROR, "Closing _hTempFileMap handle failed\n" ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }
        _hTempFileMap = INVALID_HANDLE_VALUE;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::SetSize, public
//
//  Synopsis:   Increase the size of the (writable) file
//
//  Arguments:  [storage] -- storage (not used)
//              [newSizeLow]  -- Low 32 bits of filesize
//              [newSizeHigh] -- High 32 bits of filesize
//
//--------------------------------------------------------------------------

void CMmStream::SetSize ( PStorage& storage,
    ULONG newSizeLow, ULONG newSizeHigh )
{
    if (_hMap != 0)
        CloseHandle(_hMap);

    LARGE_INTEGER sizeOld = { _sizeLow, _sizeHigh };
    LARGE_INTEGER sizeNew = { newSizeLow, newSizeHigh };

    if (sizeNew.QuadPart < sizeOld.QuadPart)
    {
        if ( SetFilePointer ( _hFile,
                              newSizeLow,
                              (long *)&newSizeHigh,  
                              FILE_BEGIN ) == 0xFFFFFFFF  &&
             GetLastError() != NO_ERROR )
        {
            htmlDebugOut(( DEB_ERROR,
                         "CMmStream::Close -- SetFilePointer returned %d\n",
                         GetLastError() ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

        if ( !SetEndOfFile( _hFile ) )
        {
            htmlDebugOut(( DEB_ERROR,
                         "CMmStream::Close -- SetEndOfFile returned %d\n",
                         GetLastError() ));
            throw ( CException(HRESULT_FROM_WIN32(GetLastError())));
        }

    }

    _hMap = CreateFileMapping( _hFile,
                                0, // security
                                PAGE_READWRITE,
                                newSizeHigh,
                                newSizeLow,
                                0 ); // name

    if (_hMap == 0)
        throw ( CException(HRESULT_FROM_WIN32(GetLastError())));

    _sizeLow = newSizeLow;
    _sizeHigh = newSizeHigh;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::MapAll, public
//
//  Synopsis:   Create file mapping
//
//--------------------------------------------------------------------------
void CMmStream::MapAll ( CMmStreamBuf& sbuf )
{
    Win4Assert ( SizeHigh() == 0 );
    Map ( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Map, private
//
//  Synopsis:   Create file mapping
//
//  Arguments:  [cb] -- size of the mapped area
//              [offLow] -- low part of file offset
//              [offHigh] -- high part of file offset
//
//--------------------------------------------------------------------------

void CMmStream::Map ( CMmStreamBuf& sbuf,
                      ULONG cb, ULONG offLow, ULONG offHigh,
                      BOOL
                    )
{
    Win4Assert ( _hMap != 0 );

    if ( !_fWrite )
    {
        //
        // Adjust size to be min( cb, sizeoffile - off )
        //

        LARGE_INTEGER size = { _sizeLow, _sizeHigh };
        LARGE_INTEGER off  = { offLow, offHigh };
        LARGE_INTEGER licb = { cb, 0 };
        LARGE_INTEGER diff;

        diff.QuadPart = size.QuadPart - off.QuadPart;

        if ( diff.QuadPart < licb.QuadPart )
        {
            cb = diff.LowPart;
            htmlDebugOut(( DEB_ITRACE,
                         "CMmStream::Map -- reducing map to 0x%x bytes\n",
                         cb ));
        }
    }

    void* buf = MapViewOfFile (
            _hMap,
            _fWrite? FILE_MAP_WRITE: FILE_MAP_READ,
            offHigh,
            offLow,
            cb );

    if ( 0 == buf )
    {
        htmlDebugOut(( DEB_ERROR,
                     "CMmStream::Map -- MapViewOfFile returned %d\n",
                     GetLastError() ));
        throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
    }

    sbuf.SetBuf( buf );
    sbuf.SetSize ( cb );
    sbuf.SetStream ( this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Unmap, public
//
//  Synopsis:   Unmap the view of file
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------
void CMmStream::Unmap( CMmStreamBuf& sbuf )
{
     if ( !UnmapViewOfFile(sbuf.Get()) )
     {
         htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile returned %d\n",
                      GetLastError() ));
         throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
     }

     sbuf.SetBuf ( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Flush, public
//
//  Synopsis:   Flush the view back to disk
//
//--------------------------------------------------------------------------

void CMmStream::Flush( CMmStreamBuf& sbuf, ULONG cb )
{
    FlushViewOfFile ( sbuf.Get(), cb );
}



//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::GetFileSize
//
//  Synopsis:   Returns file size
//
//--------------------------------------------------------------------------

ULONG CMmStream::GetSize()
{
    Win4Assert( _sizeHigh == 0 );

    return _sizeLow;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::GetTempFileBuffer
//
//  Synopsis:   Returns view of temporary memory mapped file
//
//--------------------------------------------------------------------------

void *CMmStream::GetTempFileBuffer()
{
    Win4Assert( _pTempFileBuf != 0 );

    return _pTempFileBuf;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::SetTempFileSize
//
//  Synopsis:   Sets file size of temporary memory mapped file
//
//  Arguments:  [ulSize]  -- File size
//
//--------------------------------------------------------------------------

void CMmStream::SetTempFileSize( ULONG ulSize )
{
    //
    // No need to use SetFilePointer and SetEndOfFile, because this is
    // just a temporary file
    //

    Win4Assert( _sizeHigh == 0 );

    _sizeLowTempFile = ulSize;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::CreateTempFileMapping
//
//  Synopsis:   Creates a temporary memory mapped file with size _sizeLow
//
//--------------------------------------------------------------------------

void CMmStream::CreateTempFileMapping( ULONG cbLow )
{
    Win4Assert( _sizeHigh == 0 );

    _hTempFileMap = CreateFileMapping( INVALID_HANDLE_VALUE,
                                    0, // security
                                    PAGE_READWRITE,
                                    0,
                                    cbLow,
                                    0 ); // name

    if (_hTempFileMap == NULL)
    {
        htmlDebugOut (( DEB_ERROR, "File mapping of temporary file failed\n" ));
        throw ( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
    }

    _pTempFileBuf = MapViewOfFile( _hTempFileMap,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0 );
    if ( _pTempFileBuf == 0 )
    {
        htmlDebugOut (( DEB_ERROR, "Mapping view of temporary file failed\n" ));
        throw ( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::UnmapTempFile
//
//  Synopsis:   Unmaps view of temporary file
//
//--------------------------------------------------------------------------

void CMmStream::UnmapTempFile()
{
    if ( !UnmapViewOfFile( _pTempFileBuf ) )
    {
        htmlDebugOut(( DEB_ERROR, "UnmapViewOfFile of _pTempFileBuf returned %d\n", GetLastError() ));
        throw( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
    }

    _pTempFileBuf = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\metatag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       metatag.cxx
//
//  Contents:   Parsing algorithm for meta tag in Html
//
//  Classes:    CMetaTag
//
//  History:    25-Apr-97       BobP            Added meta refresh=, url=,
//                                                                              rewrote parameter parsing
// 
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pkmguid.hxx>

// static void RemoveTypeSpec (LPWSTR pwcName);

//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::CMetaTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CMetaTag::CMetaTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _pwcValueBuf(0),
      _cValueChars(0),
      _eState(FilteringValue),
      m_fShouldStripSurroundingSingleQuotes(FALSE)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//                              (Non-deferred values only)
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CMetaTag::GetValue( VARIANT **ppPropValue )
{
    switch ( _eState )
    {
    case FilteringValue:
    {
        PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
        if ( pPropVar == 0 )
            return E_OUTOFMEMORY;

        pPropVar->vt = VT_LPWSTR;
        pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( ( _cValueChars + 1 ) * sizeof( WCHAR ) );
        if ( pPropVar->pwszVal == 0 )
        {
            CoTaskMemFree( (void *) pPropVar );
            return E_OUTOFMEMORY;
        }

        PWSTR pVal = _pwcValueBuf;
        ULONG cwch = _cValueChars;

        if(cwch && m_fShouldStripSurroundingSingleQuotes)
        {
            if(L'\'' == _pwcValueBuf[_cValueChars - 1])
            {
                --cwch;
            }
            if(L'\'' == _pwcValueBuf[0])
            {
                --cwch;
                ++pVal;
            }
        }

        RtlCopyMemory( pPropVar->pwszVal, pVal, cwch * sizeof(WCHAR) );
        pPropVar->pwszVal[cwch] = 0;

        *ppPropValue = pPropVar;
        FixPrivateChars (pPropVar->pwszVal, _cValueChars);

        _eState = NoMoreValue;
        return S_OK;
    }

    case NoMoreValue:

        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"CMetaTag::GetValue, unknown state" );
        return E_FAIL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CMetaTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//                              This handler deals only with 
//                                      <meta name="xx" content="yy">  
//                              and
//                                      <meta http-equiv="xx" content="yy">
//                              Other <meta> forms are ignored.
//
//                              The default FULLPROPSPEC is PROPSET_MetaInfo with "xx" as
//                              the PRSPEC_LPWSTR and "yy" as the filtered value.
//
//                              For certain values of "xx", the FULLPROPSPEC is replaced
//                              with Office standard properties.
//
//                              Sets _pwcValueBuf, _cValueChars to point to the value
//                              text in the chunk's local buffer, which is then copied
//                              to alloc'd VT_LPWSTR's in GetValue()
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CMetaTag::InitStatChunk( STAT_CHUNK *pStat )
{
    m_fShouldStripSurroundingSingleQuotes = FALSE;

    PTagEntry pTE = GetTagEntry();

    WCHAR *pwcName;
    unsigned cwcName;

    pStat->idChunk = 0;
    pStat->flags = CHUNK_VALUE;
    pStat->locale = _htmlIFilter.GetCurrentLocale();
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

        _cValueChars = 0;
        _eState = NoMoreValue;

    //
    // Read the name or http-equiv parameter, whichever appears first
    //
    _scanner.ReadTagIntoBuffer();

    _scanner.ScanTagBuffer( L"name", pwcName, cwcName );
    if ( cwcName == 0 )
    {
        _scanner.ScanTagBuffer( L"http-equiv", pwcName, cwcName );
    }

        // If it isn't a <meta name= content=> or <meta http-equiv= content=>
        // then ignore the tag.

    if ( cwcName == 0 )
                return FALSE;

        _scanner.ScanTagBuffer( L"content", _pwcValueBuf, _cValueChars);

        if (pTE->HasPropset() == FALSE || 
            IsStartToken() == FALSE)
        {
            return FALSE;
        }


        // Form the default PRSPEC_LPWSTR from the name= or http-equiv= param.

        if ( cwcName > MAX_PROPSPEC_STRING_LENGTH )
                cwcName = MAX_PROPSPEC_STRING_LENGTH;

        RtlCopyMemory( _awszPropSpec, pwcName, cwcName * sizeof(WCHAR) );
        _awszPropSpec[cwcName] = 0;

        // RemoveTypeSpec (_awszPropSpec);

        _wcsupr( _awszPropSpec );

        pTE->GetFullPropSpec (pStat->attribute);
        pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
        pStat->attribute.psProperty.lpwstr = _awszPropSpec;

    _eState = FilteringValue;

        // Defer all potentially result-returnable meta tags to be buffered
        // up into VT_LPWSTR|VT_VECTOR chunks as needed.

        BOOL fDefer = TRUE;

        //
        // Map a few special properties to the office property set/propid
        // and other property sets/propids
        // 
        switch ( _awszPropSpec[0] )
        {
        case L'A':
                if ( wcscmp( _awszPropSpec, L"AUTHOR" ) == 0 )
                {
                        pStat->attribute.guidPropSet = FMTID_SummaryInformation;
                        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                        pStat->attribute.psProperty.propid = PIDSI_AUTHOR;
                }

                break;

        case L'C':
                if ( wcscmp( _awszPropSpec, L"CONTENT-TYPE" ) == 0 )
                {
                        fDefer = FALSE;
                }
                break;

        case L'D':
                if ( wcscmp( _awszPropSpec, L"DESCRIPTION" ) == 0 )
                {
                        fDefer = FALSE;
                }
                break;

        case L'K':
                if ( wcscmp( _awszPropSpec, L"KEYWORDS" ) == 0 )
                {
                        pStat->attribute.guidPropSet = FMTID_SummaryInformation;
                        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                        pStat->attribute.psProperty.propid = PIDSI_KEYWORDS;
                }

                break;

        case L'M':
                if ( wcscmp( _awszPropSpec, L"MS.CATEGORY" ) == 0 )
                {
                        pStat->attribute.guidPropSet = FMTID_DocSummaryInformation;
                        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                        pStat->attribute.psProperty.propid = PID_CATEGORY;
                }

                break;

        case L'P':
                if ( wcscmp( _awszPropSpec, L"PRAGMA" ) == 0 || 
                         wcscmp( _awszPropSpec, L"PICS-LABEL" ) == 0 )
                {
                        fDefer = FALSE;
                }
                break;

        case L'R':
                if ( wcscmp( _awszPropSpec, L"REFRESH" ) == 0 )
                {
                        // Special case: if the content= param contains "URL=" e.g.
                        //    <meta http-equiv="refresh" content="5; url=http://foobar"> 
                        // then filter this as a link.
                        
                        LPWSTR pw;
                        if ((pw = wcsnistr (_pwcValueBuf, L"url=", _cValueChars)) != NULL)
                        {
                            //
                            //  For <meta http-equiv="refresh" content="10:url='frameset_home.html'">
                            //  The surrounding quotes of the url= value should be stripped.
                            //
                            m_fShouldStripSurroundingSingleQuotes = TRUE;

                                _cValueChars -= (unsigned) ( (pw - _pwcValueBuf) + 4 );
                                _pwcValueBuf = pw + 4;

                                pStat->attribute.guidPropSet = CLSID_LinkInfo;
                                pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
                                pStat->attribute.psProperty.lpwstr = L"META.URL";
// WORK HERE, can't just change the type to CHUNK_VALUE,
// because there's no mechanism to return CHUNK_TEXT.
//                              pStat->flags = CHUNK_TEXT;
                        }

                        fDefer = FALSE;
                }
                else if ( wcscmp( _awszPropSpec, L"ROBOTS" ) == 0 )
                {
                        // Ignore robots here, it was processed in the pre-scan
                        return FALSE;
                }

                break;

        case L'S':
                if ( wcscmp( _awszPropSpec, L"SUBJECT" ) == 0 )
                {
                        pStat->attribute.guidPropSet = FMTID_SummaryInformation;
                        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                        pStat->attribute.psProperty.propid = PIDSI_SUBJECT;
                }

                break;

        case L'U':
                if ( wcscmp( _awszPropSpec, L"URL" ) == 0 )
                {
                        pStat->attribute.guidPropSet = CLSID_LinkInfo;
                        pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
                        pStat->attribute.psProperty.lpwstr = L"META.URL";
//                      pStat->flags = CHUNK_TEXT;

                        fDefer = FALSE;
                }
                break;

        default:
                break;
        }

        if (_cValueChars == 0)
                return FALSE;

        // Filter this tag only if we are filtering all index properties,
        // or if this property has been specifically requested.

        if ( _htmlIFilter.FFilterProperties() == FALSE &&
                 _htmlIFilter.IsMatchProperty (pStat->attribute) == FALSE)
        {
                return FALSE;
        }

#ifndef DONT_COMBINE_META_TAGS
        if ( fDefer == TRUE && _htmlIFilter.ReturnDeferredValuesNow() == FALSE )
        {
                // Defer a value only if previously-deferred values have not already
                // been returned.

                _htmlIFilter.DeferValue (pStat->attribute, _pwcValueBuf,_cValueChars);
                return FALSE;
        }
#endif

        pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->idChunkSource = pStat->idChunk;

        return TRUE;
}

#if 0

#include <hash.hxx>

class CTagTypeTable : public CCaseInsensHashTable<char>
{
public:
    CTagTypeTable();
};

CTagTypeTable::CTagTypeTable()
{
        // -arity specifiers, indicated by value 0
    Add (L"single", 0);
    Add (L"multiple", 0);

        // type specifiers, indicated by value 1
    Add (L"_category", 1);
    Add (L"_date", 1);
    Add (L"_email", 1);
    Add (L"_int", 1);
    Add (L"_string", 1);
    Add (L"VT_I4", 1);
    Add (L"VT_UI4", 1);
    Add (L"VT_DATE", 1);
    Add (L"VT_LPWSTR", 1);
}

static CTagTypeTable _TagTypeTable;

static void
RemoveTypeSpec (LPWSTR pwszName)
//
// Given pwszName, remove the -arity and type specifiers if present.
// Modify null-terminated string pwszName in place.
{
        LPWSTR pwc;

        if ((pwc = wcsrchr (pwszName, L'.')) != NULL)
        {
                char nType;

                // Remove either an -arity or type specifier, if present.

                if ( _TagTypeTable.Lookup( &pwc[1], wcslen(&pwc[1]), nType) )
                {
                        *pwc = 0;

                        // If an -arity specifier was removed, 
                        // remove a remaining type specifier if present.

                        if ( (pwc = wcsrchr (pwszName, L'.')) != NULL)
                        {
                                if ( _TagTypeTable.Lookup( &pwc[1], wcslen(&pwc[1]), nType) &&
                                         nType == 1 )
                                {
                                        *pwc = 0;
                                }
                        }
                }
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\nounkslist.h ===
//---------------------------------------------------------------
//  File:		NoUnkSList.h
//        
//	Synopsis:	Header for the pointer based 
//				single linked list of ATL COM objects with more than
//				one interface
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Author:    Dmitriy Meyerzon
//----------------------------------------------------------------

#ifndef __NOUNKSLIST_H
#define __NOUNKSLIST_H

#include "semcls.h" 
#include "slnklist.h"
#include "tpagepool.h"

//
// class TNoUnkSingleLink
//
// indirects a pointer to T
//
template <class T>
class TNoUnkSingleLink: public CSingleLink,
    public TPagedMemPooled<TNoUnkSingleLink<T> >
{
	public:

	TNoUnkSingleLink() {}
	~TNoUnkSingleLink() {}	//do not destroy value

	HRESULT GetValue(T** ppValue) 
	{ 
		if(m_pValue == NULL) return S_FALSE;
		m_pValue->GetUnknown()->AddRef(); 
		*ppValue = m_pValue;
		return S_OK;
	}
	
	void SetValue(T* pValue) 
	{ 
		m_pValue = pValue; 
	}

	private:
	TComNoUnkPointer<T> m_pValue;
};

//
// class TNoUnkSList - a list of TNoUnkSingleLink elements
//
//
template <class T> class TNoUnkSListIter;

template <class T>
class TNoUnkSList: protected CLnkList
{
	public:

	TNoUnkSList() : CLnkList() {};
	~TNoUnkSList() { RemoveAll(); }

	CLnkList::GetEntries;
	CLnkList::IsEmpty;

	HRESULT GetFirst(T** ppT) const { return GetLinkValue(CLnkList::GetFirst(), ppT); }

	HRESULT GetLast(T** ppT) const { return GetLinkValue(CLnkList::GetLast(), ppT); }

	HRESULT Append(T* pValue) 
	{ 
		TNoUnkSingleLink<T> *pLink = CreateLink(pValue);
		CLnkList::Append(pLink);
		return pLink ? S_OK : E_OUTOFMEMORY;
	}

	HRESULT Prepend(T*pValue) 
	{ 
		TNoUnkSingleLink<T> *pLink = CreateLink(pValue);
		CLnkList::Prepend(pLink);
		return pLink ? S_OK : E_OUTOFMEMORY;
	}

	HRESULT RemoveFirst(T** ppT);
	HRESULT RemoveLast(T** ppT);

	HRESULT GetAt(UINT i, T**ppT) const { return GetLinkValue(CLnkList::GetAt(i), ppT); }

	HRESULT InsertAt(T* pValue, UINT i) 
	{ 
		TNoUnkSingleLink<T> *pLink = CreateLink(pValue);
		CLnkList::InsertAt(pLink, i);
		return pLink ? S_OK : E_OUTOFMEMORY;
	}

	HRESULT Contains(T*pT) const;

	HRESULT Remove(T* ppT);
	HRESULT RemoveAt(UINT i, T** ppT);
	void RemoveAll();

	
	private:
	TNoUnkSList(const TNoUnkSList<T> &rList);

	protected:
	
	TNoUnkSingleLink<T> *CreateLink(T*pValue);
	void DestroyLink(TNoUnkSingleLink<T> *pLink);

	static HRESULT GetLinkValue(const CSingleLink *pSLink, T** ppT);

	friend class TNoUnkSListIter<T>;
};

//
// the iterator
//
template <class T>
class TNoUnkSListIter
{
	public:
	TNoUnkSListIter(TNoUnkSList<T>& rList): 
		m_LnkList(&rList), m_Position((TNoUnkSingleLink<T> *)&rList.m_Begin), m_Prior(NULL) 
		{}
	TNoUnkSListIter(): m_LnkList(NULL), m_Position(NULL), m_Prior(NULL) {}
	~TNoUnkSListIter() {}

	TNoUnkSListIter(TNoUnkSListIter<T> &other) { *this = other; }

	void operator =(const TNoUnkSListIter<T> &other)
	{
		m_LnkList = other.m_LnkList;
		m_Position = other.m_Position;
		m_Prior = other.m_Prior;
	}

	BOOL operator++();

	TNoUnkSList<T>*	 GetList() const { return m_LnkList; }

	HRESULT GetCurrentValue(T** ppT) const 
	{ 
		return TNoUnkSList<T>::GetLinkValue(m_Prior ? m_Position : NULL, ppT); 
	}

	HRESULT GetPriorValue(T **ppT) const
	{
		return TNoUnkSList<T>::GetLinkValue(
			m_Prior && m_Prior != &m_LnkList->m_Begin ? m_Prior : NULL, ppT);
	}

	void  Reset() { if(m_LnkList) { m_Position = (TNoUnkSingleLink<T> *)&m_LnkList->m_Begin; m_Prior = NULL;} }
	HRESULT Remove(T**ppT)
	{ 
		HRESULT hr = S_FALSE;

		if(m_LnkList && m_Prior && m_Position)
		{
			TNoUnkSingleLink<T> *pLink = (TNoUnkSingleLink<T> *)m_LnkList->RemoveAfter(m_Prior);
			if(pLink)
			{
				hr =  pLink->GetValue(ppT);
				m_LnkList->DestroyLink(pLink);
			}
			m_Position = (TNoUnkSingleLink<T> *)m_Prior->m_plNext;
			if(m_Position == (TNoUnkSingleLink<T> *)&m_LnkList->m_End) m_Position = NULL;
		}

		return hr;
	}

	HRESULT Move(BOOL fUp, T **ppTReplaced);

	HRESULT Insert(T *pT)
	{
		if(m_LnkList == NULL) return E_UNEXPECTED;

		TNoUnkSingleLink<T> *pNewLink = m_LnkList->CreateLink(pT);
		if(pNewLink == NULL) return E_OUTOFMEMORY;

		m_LnkList->InsertAfter(m_Prior ? m_Prior : m_Position,
									pNewLink);

		if(m_Prior == NULL) m_Prior = (TNoUnkSingleLink<T> *)&m_LnkList->m_Begin;

		m_Position = (TNoUnkSingleLink<T> *)m_Prior->m_plNext;

		return S_OK;
	}

	protected:

	TNoUnkSList<T>*	 m_LnkList;			// The list over which we are iterating
	TNoUnkSingleLink<T>* m_Position;		// Iter position
	TNoUnkSingleLink<T>* m_Prior;
};

template <class T>
HRESULT TNoUnkSList<T>::Contains(T *pT) const
//uses class K::operator == to test the containment criteria
{
	TNoUnkSListIter<T> next(*(TNoUnkSList<T> *)this);

	while(++next)
	{
		TComNoUnkPointer<T> pCur;
		if(next.GetCurrentValue(&pCur) != S_OK) break;

		if(pCur == pT) return S_OK;
	}

	return S_FALSE;
}

template <class T>
HRESULT TNoUnkSList<T>::Remove(T*pT)
//uses class K::operator == to test 
{
	TNoUnkSListIter<T> next(*this);

	while(++next)
	{
		TComNoUnkPointer<T> pCur;
		if(next.GetCurrentValue(&pCur) != S_OK) break;

		if(pCur == pT) 
		{
			pCur = NULL;
			next.Remove(&pCur);
			return S_OK;
		}
	}

	return S_FALSE;
}

template <class T>
HRESULT TNoUnkSList<T>::RemoveFirst(T** ppT)
{
	TNoUnkSingleLink<T> *pLink = (TNoUnkSingleLink<T> *)CLnkList::RemoveFirst();
	HRESULT hr = GetLinkValue(pLink, ppT);

	if(hr == S_OK)
	{
		ASSERT(pLink && *ppT);
		DestroyLink(pLink);
	}

	return hr;
}

template <class T>
HRESULT TNoUnkSList<T>::RemoveLast(T** ppT)
{
	TNoUnkSingleLink<T> *pLink = (TNoUnkSingleLink<T> *)CLnkList::RemoveLast();
	HRESULT hr = GetLinkValue(pLink, ppT);

	if(hr == S_OK)
	{
		ASSERT(pLink && *ppT);
		DestroyLink(pLink);
	}

	return hr;
}

template <class T>
HRESULT TNoUnkSList<T>::RemoveAt(UINT i, T**ppT)
{
	TNoUnkSingleLink<T> *pLink = (TNoUnkSingleLink<T> *)CLnkList::RemoveAt(i);
	HRESULT hr = GetLinkValue(pLink, ppT);

	if(hr == S_OK)
	{
		ASSERT(pLink && *ppT);
		DestroyLink(pLink);
	}

	return hr;
}

template <class T>
void TNoUnkSList<T>::RemoveAll()
{
	TNoUnkSingleLink<T> *pLink;
	while(pLink = (TNoUnkSingleLink<T> *)CLnkList::RemoveFirst())
	{
		DestroyLink(pLink);
	}
}

template <class T>
TNoUnkSingleLink<T> *TNoUnkSList<T>::CreateLink(T*pValue)
{
	TNoUnkSingleLink<T> *pLink = new TNoUnkSingleLink<T>;
	ASSERT(pLink);

	pLink->SetValue(pValue);

	return pLink;
}

template <class T>
void TNoUnkSList<T>::DestroyLink(TNoUnkSingleLink<T> *pLink)
{
    delete pLink;
}

template <class T>
HRESULT TNoUnkSList<T>::GetLinkValue(const CSingleLink *pSLink, T**ppT)
{
	if(pSLink == NULL) return S_FALSE;
	return ((TNoUnkSingleLink<T> *)pSLink)->GetValue(ppT);
}

//
// class TNoUnkSListIter<T>
//

template <class T>
BOOL TNoUnkSListIter<T>::operator++()
{
	if(!m_LnkList) return FALSE;
	if(m_Position)
	{
		m_Prior = m_Position;
		m_Position = (TNoUnkSingleLink<T> *)m_Position->m_plNext;
		if(m_Position == (TNoUnkSingleLink<T> *)&m_LnkList->m_End) m_Position = NULL;
	}

	return m_Position ? TRUE : FALSE;
}

template <class T>
HRESULT TNoUnkSListIter<T>::Move(BOOL fUp, T **ppUnkReplaced)
{
	if(ppUnkReplaced == NULL) return E_POINTER;

	HRESULT hr = E_UNEXPECTED;
	if(m_LnkList && m_Prior && m_Position)
	{
		CSingleLink *Left;

		if(fUp)
		{
			Left = m_LnkList->GetPrior(m_Prior);
		}
		else
		{
			Left = m_Prior;
		}

		if(Left == NULL) return E_FAIL;

		CSingleLink *Middle = m_LnkList->RemoveAfter(Left);
		CSingleLink *Right = m_LnkList->GetNext(Left);
		m_LnkList->InsertAfter(Right, Middle);

		m_Prior = (TNoUnkSingleLink<T> *)Left;
		m_Position = (TNoUnkSingleLink<T> *)Right;

		CSingleLink *Replaced;
		if(fUp)
		{
			Replaced = Middle;
		}
		else
		{
			Replaced = Right;
		}

		hr = m_LnkList->GetLinkValue(Replaced, ppUnkReplaced);
	}

	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\resource.h ===
#ifndef __RESOURCE_H__
#define __RESOURCE_H__

//
//	String ID's
//
#define IDS_HHC_DESC    1
#define IDS_HTML_DESC   2
#define IDS_ASP_DESC    3
#define IDS_ASPX_DESC   4
#define IDS_ASCX_DESC   5

#endif // __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\paramtag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       paramtag.cxx
//
//  Contents:   Generic handler for tags in which all filtered output
//				comes from the parameters of the start-tag.
//
//				Includes subclass for CInputTag.
// 
//  History:    25-Apr-97	BobP		Created
//
//  Notes:
// 
// This is the generic handler for tags which have simple parameter
// values and either do not have end tags or require no state to track 
// matching start/end tags.  All the filter chunk data comes from the
// parameters of the start tag and is returned immediately upon parsing
// the start tag, so a single CHtmlElement-derived object may be used
// to filter all such tags defined in the tag table.
// 
// This can be used for tags that DO have end tags, so long as the body text
// between the start tag and end tag is filtered as ordinary Content, and
// the end tag is ignored.  To do otherwise would require a separate
// object instance for each such tag.
// 
// The tag definition table may define more than one entry for the same
// unique tag name.  All entries that the tag satisfies will produce output.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern const WCHAR * WCSTRING_LINK;
extern const WCHAR * WCSTRING_HREF;

//+-------------------------------------------------------------------------
//
//  Method:     CParamTag::CParamTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CParamTag::CParamTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _pwcValueBuf(0),
      _cValueChars(0),
      _cValueCharsFiltered(0)
{
}


void
CParamTag::Reset (void)
{
	_cValueChars = 0;
	_cValueCharsFiltered = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CParamTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CParamTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    ULONG cCharsRemaining = _cValueChars - _cValueCharsFiltered;

    if ( cCharsRemaining == 0 )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

	// copy text from the value buffer set from e.g. fooparam="value"

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       *pcwcOutput * sizeof(WCHAR) );
        _cValueCharsFiltered += *pcwcOutput;

		FixPrivateChars (awcBuffer, *pcwcOutput);

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcBuffer,
                       _pwcValueBuf + _cValueCharsFiltered,
                       cCharsRemaining * sizeof(WCHAR) );
        _cValueCharsFiltered += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

		FixPrivateChars (awcBuffer, cCharsRemaining);

        return FILTER_S_LAST_TEXT;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CParamTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK with the text filtered from
//				the tag parameters per the tag table entry.
//
//				If there is no data to return, returns FALSE to tell the
//				main state machine to move on without returning a chunk.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//  Returns:    TRUE if a chunk is emitted, FLASE otherwise
//
//  History:    14-Jan-2000    KitmanH    HREF chunks are emitted with 
//                                        LOCALE_NEUTRAL
//
//--------------------------------------------------------------------------

BOOL CParamTag::InitStatChunk( STAT_CHUNK *pStat )
{
	PTagEntry pTE = GetTagEntry();

	// End tags are always ignored; no state is preserved to associate
	// with matching start tags anyway.

	if ( IsStartToken() == FALSE || 
		 pTE->HasPropset() == FALSE ||
		 ( GetTokenType() == CommentToken && _htmlIFilter.FFilterProperties() == FALSE) )
	{
        _scanner.EatTag();
		return FALSE;
	}

    _scanner.ReadTagIntoBuffer();

	pTE->GetFullPropSpec (pStat->attribute);

    pStat->flags = CHUNK_TEXT;
    pStat->breakType = CHUNK_EOS;
    pStat->locale = _htmlIFilter.GetCurrentLocale();

    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

	// Initially no text to return

	_pwcValueBuf = NULL;
	_cValueChars = 0;
    _cValueCharsFiltered = 0;

	if (pTE->GetParamName() != NULL)
	{
		// First, look for the special case for 
		//	<link rel=stylesheet href=URL>
		// which for ACM, the Gatherer must treat as a different crawl depth.
		// If this form is recognized, change the PID to distinguish it
		// from any other <link href=URL> tag.

		if ( !_wcsicmp ( pTE->GetTagName(), WCSTRING_LINK ) &&
			 !_wcsicmp ( pTE->GetParamName(), WCSTRING_HREF ) )
		{
			_scanner.ScanTagBuffer( L"rel", _pwcValueBuf, _cValueChars );

			if ( _cValueChars == 10 && 
				 !_wcsnicmp(_pwcValueBuf, L"stylesheet", 10) )
			{
				pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
				pStat->attribute.psProperty.lpwstr = L"LINK.STYLESHEET";
			}
			else if(_cValueChars == 9)
			{
				if(!_wcsnicmp(_pwcValueBuf, L"Main-File", 9))
				{
					pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
					pStat->attribute.psProperty.lpwstr = L"LINK.ISOFFICECHILD";
				}
				else if(!_wcsnicmp(_pwcValueBuf, L"File-List", 9))
				{
					pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
					pStat->attribute.psProperty.lpwstr = L"LINK.OFFICECHILDLIST";
				}
			}
		}

		//
		// Read value from the parameter specified by the tag table entry.
		// No distinction is made between having a null value for the param
		// vs. not containing the param= at all.
		//
		_scanner.ScanTagBuffer(pTE->GetParamName(),_pwcValueBuf,_cValueChars);

        if ( NULL != pTE->GetParamName() && !_wcsicmp ( pTE->GetParamName(), WCSTRING_HREF ) )
            pStat->locale = LOCALE_NEUTRAL;
	}
	else
	{
		// 
		// No parameter in the tag entry; return the entire raw tag contents.
		// 
		_scanner.GetTagBuffer(  _pwcValueBuf, _cValueChars );
	}

	if ( _cValueChars == 0)
		return FALSE;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->idChunkSource = pStat->idChunk;

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CInputTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK for an <input ...> tag
//
//				This is the same as a "parameter" tag except for 
//				special casing the parameter detection.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CInputTag::InitStatChunk( STAT_CHUNK *pStat )
{
	PTagEntry pTE = GetTagEntry();

	// End tags are always ignored; no state is preserved to associate
	// with matching start tags anyway.

	if ( IsStartToken() == FALSE || pTE->HasPropset() == FALSE )
	{
        _scanner.EatTag();
		return FALSE;
	}

    _scanner.ReadTagIntoBuffer();

	pTE->GetFullPropSpec (pStat->attribute);

    pStat->flags = CHUNK_TEXT;
    pStat->breakType = CHUNK_EOS;
    pStat->locale = _htmlIFilter.GetCurrentLocale();

    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

	_pwcValueBuf = NULL;
	_cValueChars = 0;
    _cValueCharsFiltered = 0;

    //
    // Check input type
    //
    WCHAR *pwcType;
    unsigned cwcType;
    _scanner.ScanTagBuffer( L"type", pwcType, cwcType );

    if ( cwcType == 6           // 6 == wcslen( L"hidden" )
         && _wcsnicmp( pwcType, L"hidden", 6 ) == 0 )
    {
        //
        // Input is hidden, so don't output value field
        //
        return FALSE;
    }

    //
    // Read the value field to return
    //
    _scanner.ScanTagBuffer( L"value", _pwcValueBuf, _cValueChars );

	if ( _cValueChars == 0)
		return FALSE;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->idChunkSource = pStat->idChunk;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\propspec.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       propspec.cxx
//
//  Contents:   C++ wrappers for FULLPROPSPEC
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Default constructor
//
//  Effects:    Defines property with null guid and propid 0
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec()
{
    memset( &_guidPropSet, 0, sizeof( _guidPropSet ) );
    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Construct propid based propspec
//
//  Arguments:  [guidPropSet]  -- Property set
//              [pidProperty] -- Property
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( GUID const & guidPropSet, PROPID pidProperty )
        : _guidPropSet( guidPropSet )
{
    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Construct name based propspec
//
//  Arguments:  [guidPropSet] -- Property set
//              [wcsProperty] -- Property
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( GUID const & guidPropSet,
                              WCHAR const * wcsProperty )
        : _guidPropSet( guidPropSet )
{
    _psProperty.ulKind = PRSPEC_PROPID;
    SetProperty( wcsProperty );
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source property spec
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( CFullPropSpec const & src )
        : _guidPropSet( src._guidPropSet )
{
    _psProperty.ulKind = src._psProperty.ulKind;

    if ( _psProperty.ulKind == PRSPEC_LPWSTR )
    {
        if ( src._psProperty.lpwstr )
        {
            _psProperty.ulKind = PRSPEC_PROPID;
            SetProperty( src._psProperty.lpwstr );
        }
        else
            _psProperty.lpwstr = 0;

    }
    else
    {
        _psProperty.propid = src._psProperty.propid;
    }
}

inline void * operator new( size_t size, void * p )
{
    return( p );
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::operator=, public
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [Property] -- Source property
//
//--------------------------------------------------------------------------

CFullPropSpec & CFullPropSpec::operator=( CFullPropSpec const & Property )
{
    //
    // Clean up.
    //

    CFullPropSpec::~CFullPropSpec();

    new (this) CFullPropSpec( Property );

    return *this;
}


CFullPropSpec::~CFullPropSpec()
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
                _psProperty.lpwstr = 0;
    }
}


void CFullPropSpec::SetProperty( PROPID pidProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

BOOL CFullPropSpec::SetProperty( WCHAR const * wcsProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_LPWSTR;

    int len = (wcslen( wcsProperty ) + 1) * sizeof( WCHAR );

    _psProperty.lpwstr = (WCHAR *)CoTaskMemAlloc( len );

    if ( 0 != _psProperty.lpwstr )
    {
        memcpy( _psProperty.lpwstr,
                wcsProperty,
                len );
        return( TRUE );
    }
    else
    {
        _psProperty.lpwstr = 0;
        return( FALSE );
    }
}

int CFullPropSpec::operator==( CFullPropSpec const & prop ) const
{
    if ( memcmp( &prop._guidPropSet,
                 &_guidPropSet,
                 sizeof( _guidPropSet ) ) != 0 ||
         prop._psProperty.ulKind != _psProperty.ulKind )
    {
        return( 0 );
    }

    switch( _psProperty.ulKind )
    {
    case PRSPEC_LPWSTR:
        {
            const WCHAR *pwsz1 = GetPropertyName();
            const WCHAR *pwsz2 = prop.GetPropertyName();

            if (pwsz1 != NULL && pwsz2 != NULL)
                return (_wcsicmp(pwsz1, pwsz2) == 0);
        
            return ((pwsz1 == NULL) && (pwsz2 == NULL));
        }

        break;

    case PRSPEC_PROPID:
        return( GetPropertyPropid() == prop.GetPropertyPropid() );
        break;

    default:
        return( 0 );
        break;
    }
}

int CFullPropSpec::operator!=( CFullPropSpec const & prop ) const
{
    if (*this == prop)
        return( 0 );
    else
        return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\resdll.h ===
//                                                                      -*- c++ -*-
// resdll.h
//

#ifndef __RESDLL_H
#define __RESDLL_H

class CResourceLibrary
{
public:

    CResourceLibrary(LPCTSTR ptstrDll);
    ~CResourceLibrary();

    HINSTANCE GetDLL() const { return m_hDll; }
    void Free() {if (m_hDll) ::FreeLibrary(m_hDll); m_hDll = NULL;}

private:

    HINSTANCE           m_hDll;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\proptag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//  File:       proptag.cxx
//
//  Contents:   Generic parsing algorithm for "property" tags, such as title 
//				and headings.   Text between the <tag> and </tag> is 
//				filtered as PID_STG_CONTENTS, and any and all OTHER 
//				intervening tags are IGNORED.
//
//				"Property" tags are normally emittted in duplicate:
//					1. CLSID_Storage/PID_STG_CONTENTS, as TEXT chunks
//					2. FULLPROPSPEC per table entry, as TEXT chunks
//
//				CTitleTag, which derives from CPropertyTag, also emits
//				a 3rd copy:
//					3. FULLPROPSPEC per table entry, as VALUE chunks
//
//				If filtering properties only but not content, then only
//				outputs 2 and 3 are generated.
//
//  Classes:    CPropertyTag
//
//  History:    09/22/1999 KitmanH      Made changes to the parsing algorithm, so 
//                                      that properties are only emited once as
//                                      "FULLPROPSPEC per table entry, as VALUE 
//                                      chunks"
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::CPropertyTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]  -- Reference to Html filter
//              [serialStream] -- Reference to input stream
//
//--------------------------------------------------------------------------

CPropertyTag::CPropertyTag( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _eState(NoMoreValueProperty),
      _cPropChars(0),
      _fSavedElement(FALSE)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//
// State machine notes:
// 
// The state machine's sole purpose is to sequence through generating
// multiple copies of the output as described in the top-of-file comment.
//
// Remember that the GetChunk() that makes the first call to InitStatChunk()
// for a property tag is called in the previous machine state.
// The FIRST call to GetChunk() in THIS context does not occur until GetText()
// returns FILTER_E_NO_MORE_TEXT.
//
// The initial state on processing the start-tag in InitStatChunk() is
// FilteringContent when filtering both properties and content, 
// or FilteringPropertyButContentNotFiltered when filtering only properties.
// GetText() will then be called to return content chunks until the end
// tag is found.
// 
// State transitions:
//	Init filtering content and properties => FilteringContent
//	Init filtering properties only => FilteringPropertyButContentNotFiltered
//	FilteringContent => NoMoreContent
//	NoMoreContent => FilteringProperty
//	FilteringProperty => NoMoreProperty
//	FilteringPropertyButContentNotFiltered => NoMoreProperty
//	NoMoreProperty => done
//
//  History:    09/22/1999 KitmanH      state machine changed to start from
//                                      FilteringValueProperty => NoMoreValuePropery
//                                      NoMoreValueProperty => done
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::GetChunk( STAT_CHUNK * pStat )
{
    switch ( _eState )
    {
    case FilteringValueProperty:
    { 
        // This exists only to handle the case where the external caller
        // calls GetChunk() BEFORE GetValue() has returned all the text that 
        // needs to be read from the input and/or is already bufferred.  It's 
        // not part of the normal path.

        return SkipRemainingValueAndGotoNextChunk( pStat ); 
    }

    case NoMoreValueProperty:
    {
        if (_fSavedElement)
        {
            // The parse stopped early because a tag was found that needs to
            // be filtered as something other than part of a property.
            // Filter that tag.

            SetToken (_NextToken);
            return SwitchToSavedElement( pStat );
        }

        // Skip over the end-property tag and move on to the next element.
            
        _scanner.EatTag();
        return SwitchToNextHtmlElement( pStat );
    }

    default:
        Win4Assert( !"Unknown _eState in CPropertyTag::GetChunk" );
        htmlDebugOut(( DEB_ERROR, "CPropertyTag::GetChunk, unkown property tag state: %d\n", _eState ));
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    09-27-1999  KitmanH     return FILTER_E_NO_TEXT
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    switch ( _eState )
    {
    case FilteringValueProperty:
    case NoMoreValueProperty:
    {
        return FILTER_E_NO_TEXT;
    }

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CPropertyTag::GetText, unknown value of _eState: %d\n",
                       _eState ));
        return S_OK;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::ReadProperty, private
//
//  Synopsis:   Read Property into buffer
//
//  History:    09/22/1999 KitmanH      Created
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::ReadProperty()
{
    switch (_eState)
    {
    case FilteringValueProperty:
    {
        WCHAR awcBuffer[PROPERTY_BUFFER_SIZE]; 

        // Read, store and emit input until the matching end-tag is found;
        // collect the body text but DISCARD all other tags.

        ULONG cCharsReadInBuffer = 0;
        while ( FilteringValueProperty == _eState )
        {
            ULONG cCharsScanned;
            ULONG cCharsNeeded = PROPERTY_BUFFER_SIZE - cCharsReadInBuffer;
            CToken token;
            _scanner.GetBlockOfChars( cCharsNeeded,
                                      awcBuffer + cCharsReadInBuffer,
                                      cCharsScanned,
                                      token );

            cCharsReadInBuffer += cCharsScanned;
            if ( cCharsScanned == cCharsNeeded )
            {
                //
                // did not stop in the middle of a tag. Property is partialy read.
                //
                if ( cCharsScanned > 0 )
                {
                    _xPropBuf.Copy( awcBuffer, PROPERTY_BUFFER_SIZE, _cPropChars );
                    _cPropChars += PROPERTY_BUFFER_SIZE;
                    cCharsReadInBuffer = 0;
                }
                continue;
            }

            // The parse stopped before cCharsNeeded because a tag was found.
            // Stop when the matching end tag for this property is found,
            // or when a tag is found that deserves filtering precedence
            // over a property tag.

            HtmlTokenType eTokType = token.GetTokenType();
            if ( eTokType == EofToken || 
                 ( eTokType == GetTokenType() && !token.IsStartToken()) )
            {
                //
                // End of file or end property tag
                //
                _eState = NoMoreValueProperty;
                break;
            }
            else if ( eTokType == AnchorToken ||
                      eTokType == ParamToken ||
                      eTokType == Heading1Token ||
                      eTokType == Heading2Token ||
                      eTokType == Heading3Token ||
                      eTokType == Heading4Token ||
                      eTokType == Heading5Token ||
                      eTokType == Heading6Token )
            {
                // If a tag is found that it's more important to filter, stop
                // now and return for this prop only the text found so far.
                // 

                // Save the partly-read token so it can be filtered next
                _fSavedElement = TRUE;
                _NextToken = token;
                _eState = NoMoreValueProperty;
                break;
            }
            else
            {
                //
                // Uninteresting tag, so skip over tag and continue processing
                //
				_scanner.EatTag();
            }
        }

        _eState = NoMoreValueProperty;
        
        if ( cCharsReadInBuffer > 0 )
        {
            _xPropBuf.Copy( awcBuffer, cCharsReadInBuffer, _cPropChars );
            _cPropChars += cCharsReadInBuffer;
        }

        _xPropBuf.Copy( L"\0", 1, _cPropChars );
        _cPropChars++;

        return S_OK;
    }  
    case NoMoreValueProperty:
    {
        return FILTER_E_NO_MORE_VALUES;
    }
    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CPropertyTag::ReadProperty, unknown value of _eState: %d\n",
                       _eState ));
        return E_FAIL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK as part of a GetChunk call
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//  History:    09-27-1999  KitmanH     Only emit property as a value chunk
//
//--------------------------------------------------------------------------

BOOL CPropertyTag::InitStatChunk( STAT_CHUNK *pStat )
{
    _fSavedElement = FALSE;

    //
    // Skip over the rest of start-tag
    //
    _scanner.EatTag();

	// Ignore a stray end tag -- the end-tag that matches this start-tag
	// will be seen by GetText(), NOT here.

	if (IsStartToken() == FALSE)
		return FALSE;

    pStat->flags = CHUNK_VALUE;
    pStat->breakType = CHUNK_EOS;
    pStat->locale = _htmlIFilter.GetCurrentLocale();
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;
    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->idChunkSource = pStat->idChunk;

    if ( !GetTagEntry()->HasPropset() )
        return FALSE;

    GetTagEntry()->GetFullPropSpec (pStat->attribute);

    _eState = FilteringValueProperty;

	return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPropertyTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//  History:    10-07-1999  KitmanH     Created
//
//--------------------------------------------------------------------------

SCODE CPropertyTag::GetValue( VARIANT **ppPropValue )
{
    switch (_eState)
    {
    case FilteringValueProperty:
    {
        SCODE sc = ReadProperty();
        if ( SUCCEEDED(sc) )
        {
            PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
            if ( pPropVar == 0 )
                return E_OUTOFMEMORY;

            pPropVar->vt = VT_LPWSTR;
            int cb = ( _cPropChars ) * sizeof( WCHAR );
            pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( cb );

            if ( pPropVar->pwszVal == 0 )
            {
                CoTaskMemFree( (void *) pPropVar );
                return E_OUTOFMEMORY;
            }

            RtlCopyMemory( pPropVar->pwszVal, _xPropBuf.Get(), cb );

            *ppPropValue = pPropVar;

            // reset buffer
            _cPropChars = 0;

            _eState = NoMoreValueProperty;
            return FILTER_S_LAST_VALUES;
        }
        else
            return sc;
    }

    case NoMoreValueProperty:
        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CTitleTag::GetValue, unknown value of _eState: %d\n",
                       _eState ));
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\prefilter.cxx ===
//+-----------------------------------------------
//
//  Microsoft (R) Search
//  Copyright (C) Microsoft Corporation, 1998-1999.
//
//  File:		PreFilter.cxx
//
//  Content:    Class to "pre-filters" HTML chunks
//              before passing out the chunks through
//              IFilter
//
//  Classes:	CHTMLChunkPreFilter
//
//  History:	06/14/99	mcheng		Created
//
//+-----------------------------------------------

#include <pch.cxx>

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::CHTMLChunkPreFilter
//
//	Synopsis:	Constructor
//
//	Returns:
//
//	Arguments:
//
//	History:	06/14/99	mcheng		Created
//
//+-----------------------------------------------
CHTMLChunkPreFilter::CHTMLChunkPreFilter() :
	m_eState(eStateLookingForAllSpaceChunk),
	m_eTextState(eStateLookForAllSpaceText),
	m_scChunkAfterAllSpaceChunk(E_UNEXPECTED)
{
	ZeroMemory(&m_StatChunkCurrent, sizeof(m_StatChunkCurrent));
	ZeroMemory(&m_StatChunkNext, sizeof(m_StatChunkNext));
}

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::~CHTMLChunkPreFilter
//
//	Synopsis:	Destructor
//
//	Returns:
//
//	Arguments:
//
//	History:	06/14/99	mcheng		Created
//
//+-----------------------------------------------
CHTMLChunkPreFilter::~CHTMLChunkPreFilter()
{
	//	There is no clean up necessary
}

//+-----------------------------------------------
//
//  Function:   CHTMLChunkPreFilter::GetChunk
//
//  Synopsis:   Get the next chunk
//
//  Returns:    SCODE
//
//  Arguments:  [CHtmlElement *pHtmlElement]    -   The processing element
//              [STAT_CHUNK *pStat]             -   The chunk
//
//  History:    06/14/99    mcheng      Created
//
//+-----------------------------------------------

SCODE CHTMLChunkPreFilter::GetChunk( CHtmlElement *pHtmlElement,
									 STAT_CHUNK *pStat )
{
	SCODE sc = S_OK;

	switch(m_eState)
	{
	case eStateLookingForAllSpaceChunk:

		//
		//	Save the STAT_CHUNK for the potential all white space
		//	chunk. It will be used to compare with the STAT_CHUNK
		//	of the following chunk to determine if the all white
		//	space chunk can be ignored. The condition that allows
		//	the all white space chunk to be ignored is that the
		//	following chunk has the same FULLPROPSPEC.
		//
		sc = pHtmlElement->GetChunk(&m_StatChunkCurrent);
		*pStat = m_StatChunkCurrent;
		break;

	case eStateFoundAllSpaceChunk:

		//
		//	In order to determine if the all space
		//	chunk is to be ignored or not, GetText()
		//	has already called pHtmlElement->GetChunk().
		//	Therefore, the saved chunk is emitted here.
		//
		sc = m_scChunkAfterAllSpaceChunk;
		*pStat = m_StatChunkNext;

		m_StatChunkCurrent = m_StatChunkNext;
        m_eState = eStateLookingForAllSpaceChunk;
        m_eTextState = eStateLookForAllSpaceText;
		break;

	default:

		Assert(!"Unexpect state in CHTMLChunkPreFilter::GetChunk()");
		break;
	}

	return sc;
}

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::GetText
//
//	Synopsis:	Get the text of the chunk
//
//	Returns:	SCODE
//
//	Arguments:
//	[CHtmlElement *pHtmlElement]    -   The processing element
//	[ULONG *pcwcOutput]             -   Number of WCHAR in buffer
//	[WCHAR *awcBuffer]              -   The text buffer
//
//	History:	06/14/99	mcheng		Created
//
//+-----------------------------------------------
SCODE CHTMLChunkPreFilter::GetText(CHtmlElement *pHtmlElement,
								   ULONG *pcwcOutput,
								   WCHAR *awcBuffer)
{
    Win4Assert( 0 != pcwcOutput );
    Win4Assert( *pcwcOutput > 0 );
    Win4Assert( 0 != awcBuffer );
	
    switch(m_eTextState) 
    {
    case eStateLookForAllSpaceText:

        return LookForAllSpaceText(pHtmlElement, pcwcOutput, awcBuffer);

    case eStateNoText:

        m_eTextState = eStateLookForAllSpaceText;
        return FILTER_E_NO_MORE_TEXT;

    case eStatePassThrough:

    {
        SCODE sc = pHtmlElement->GetText(pcwcOutput, awcBuffer);
        if(sc == FILTER_E_NO_MORE_TEXT) m_eTextState = eStateLookForAllSpaceText;
        return sc;
    }

    default:

        Assert(!"Unexpect state in CHTMLChunkPreFilter::GetText()");
        return E_UNEXPECTED; 
    }

}

//+-------------------------------------------------------------------------------
//
//  Function:   CHTMLChunkPreFilter::GetValue
//
//  Synopsis:   Get the value of the chunk
//
//  Returns:    SCODE
//
//  Arguments:  [CHtmlElement *pHtmlElement]	-	The processing element
//	            [VARIANT **ppPropValue]			-	The value
//
//  History:    06/14/99	mcheng		Created
//              10/12/1999  kitmanh     Reset the m_eTextState here
//  
//  Note: CPropertyTag used to emit a CHUNK_TEXT as the first chunk. Thus, a
//        call to GetText was always expected. The call to GetText results 
//        into a state change of the state machine into eStateLookForAllSpaceText. 
//        A change was made to the CPropertyTag state machine in 09/1999 so
//        that CPropertyTag only emits CHUNK_VALUE. Therefore, GetText is not
//        expected to be called. This results in a buffer change without the 
//        coresponding state change in the text scanning state machine. The fix 
//        made on 10/12/1999 is for this case.
//
//+-------------------------------------------------------------------------------

SCODE CHTMLChunkPreFilter::GetValue(CHtmlElement *pHtmlElement,
									VARIANT **ppPropValue)
{
	m_eState = eStateLookingForAllSpaceChunk;
	m_eTextState = eStateLookForAllSpaceText;
	return pHtmlElement->GetValue(ppPropValue);
}

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::LookForAllSpaceText
//
//	Synopsis:	Look for all space text
//
//	Returns:	SCODE
//
//	Arguments:
//	[CHtmlElement *pHtmlElement]	-	The processing element
//	[ULONG *pcwcOutput]				-	Number of WCHAR in buffer
//	[WCHAR *awcBuffer]				-	The text buffer
//
//	History:	06/18/99	mcheng		Created
//
//+-----------------------------------------------
SCODE CHTMLChunkPreFilter::LookForAllSpaceText(CHtmlElement *pHtmlElement,
											   ULONG *pcwcOutput,
											   WCHAR *awcBuffer)

{
	Win4Assert( 0 != pcwcOutput );
	Win4Assert( *pcwcOutput > 0 );
	Win4Assert( 0 != awcBuffer );
	
	ULONG cwcBuffer = *pcwcOutput;
	SCODE sc = pHtmlElement->GetText(pcwcOutput, awcBuffer);

	if(FAILED(sc))
	{
		m_eState = eStateLookingForAllSpaceChunk;
		m_eTextState = eStateLookForAllSpaceText;
		return sc;
	}

	//
	//	Determine if the current text chunk is
	//	consisted of all white space. If it is,
	//	look at the next chunk to determine if
	//	this all white space chunk should be
	//	ignored or not.
	//
	BOOL fAllSpace = IsAllWhiteSpace(awcBuffer, *pcwcOutput);

	//
	//	Look at the rest of the text (if there is any) to
	//	see if it is also all white space.
	//
	while(fAllSpace)
	{
		//
		//	The plus 1 is used to reserve a character for
		//	white space in case the rest of the text turns
		//	out not be consisted of all white space.
		//
		*pcwcOutput = cwcBuffer - 1;
		sc = pHtmlElement->GetText(pcwcOutput, awcBuffer + 1);
		if(SUCCEEDED(sc))
		{
			fAllSpace = IsAllWhiteSpace(awcBuffer + 1, *pcwcOutput);
			if(!fAllSpace)
			{
				//
				//	Prepend a space character which is sufficient
				//	to represent all the white spaces that are
				//	ignored.
				//
				awcBuffer[0] = L' ';
				++(*pcwcOutput);
			}
		}
		else
		{
			break;
		}
	}

	//	Unexpected failure
	if(FAILED(sc) && sc != FILTER_E_NO_MORE_TEXT) return sc;

	if(fAllSpace)
	{
		m_eState = eStateFoundAllSpaceChunk;

		do
		{
			m_scChunkAfterAllSpaceChunk = pHtmlElement->GetChunk(&m_StatChunkNext);
		}
		while(m_scChunkAfterAllSpaceChunk == FILTER_E_EMBEDDING_UNAVAILABLE ||
			m_scChunkAfterAllSpaceChunk == FILTER_E_LINK_UNAVAILABLE);

		//
		//	Look at the next chunk to determine if this
		//	all white space chunk can be ignored
		//
		if(SUCCEEDED(m_scChunkAfterAllSpaceChunk))
		{
			if(CanIgnoreAllWhiteSpaceChunk(m_StatChunkCurrent, m_StatChunkNext))
			{
				sc = FILTER_E_NO_MORE_TEXT;

				if(m_StatChunkNext.breakType == CHUNK_NO_BREAK &&
					m_StatChunkCurrent.breakType != CHUNK_NO_BREAK)
				{
					m_StatChunkNext.breakType = m_StatChunkCurrent.breakType;
				}

			}
			else
			{
				//
				//	A single white space is sufficient to
				//	represent an all white space chunk
				//
				*pcwcOutput = 1;
				awcBuffer[0] = L' ';
				m_eTextState = eStateNoText;
			}
		}
	}
	else
	{
		if(sc == FILTER_E_NO_MORE_TEXT) sc = S_OK;

		Assert(SUCCEEDED(sc));

		m_eState = eStateLookingForAllSpaceChunk;
		m_eTextState = eStatePassThrough;
	}

	return sc;
}

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::IsAllWhiteSpace
//
//	Synopsis:	Determine if the text buffer consists
//				of all white space characters.
//
//	Returns:	BOOL
//
//	Arguments:
//	[WCHAR *awcBuffer]	-	The text buffer
//	[ULONG cwcBuffer]	-	The number of characters
//
//	History:	06/15/99	mcheng		Created
//
//+-----------------------------------------------
BOOL CHTMLChunkPreFilter::IsAllWhiteSpace(WCHAR *awcBuffer, ULONG cwcBuffer)
{
	for(ULONG ulIndex = 0; ulIndex < cwcBuffer; ++ulIndex)
	{
		//
		//	According to documentation, iswspace is locale
		//	independent, therefore it can be used to
		//	determine if the text chunk is consisted of
		//	all white space in Unicode.
		//
		if(!iswspace(awcBuffer[ulIndex]))
		{
			return FALSE;
		}
	}

	return TRUE;
}

//+-----------------------------------------------
//
//	Function:	CHTMLChunkPreFilter::CanIgnoreAllWhiteSpaceChunk
//
//	Synopsis:	Determine if the current all white space chunk
//				can be ignored or not based on what the next
//				chunk is.
//
//	Returns:	BOOL
//
//	Arguments:
//	[const STAT_CHUNK &rStatChunkCurrent]	-	The current chunk
//	[const STAT_CHUNK &rStatChunkNext]		-	The next chunk
//
//	History:	06/15/99	mcheng		Created
//
//+-----------------------------------------------
BOOL CHTMLChunkPreFilter::CanIgnoreAllWhiteSpaceChunk(const STAT_CHUNK &rStatChunkCurrent,
													  const STAT_CHUNK &rStatChunkNext)
{
	BOOL fIgnoreAllSpaceChunk = FALSE;

	if(rStatChunkNext.flags == CHUNK_TEXT &&
		rStatChunkNext.locale == rStatChunkCurrent.locale &&
		rStatChunkNext.attribute.guidPropSet == rStatChunkCurrent.attribute.guidPropSet &&
		rStatChunkNext.attribute.psProperty.ulKind == rStatChunkCurrent.attribute.psProperty.ulKind &&
		(rStatChunkNext.breakType != CHUNK_NO_BREAK || rStatChunkCurrent.breakType != CHUNK_NO_BREAK))
	{
		if(rStatChunkCurrent.attribute.psProperty.ulKind == PRSPEC_LPWSTR)
		{
			if(_wcsicmp(rStatChunkNext.attribute.psProperty.lpwstr, rStatChunkCurrent.attribute.psProperty.lpwstr) == 0)
			{
				fIgnoreAllSpaceChunk = TRUE;
			}
		}
		else
		{
			if(rStatChunkNext.attribute.psProperty.propid == rStatChunkCurrent.attribute.psProperty.propid)
			{
				fIgnoreAllSpaceChunk = TRUE;
			}
		}
	}

	return fIgnoreAllSpaceChunk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       pch.cxx
//
//  Contents:   Pre-compiled header
//
//--------------------------------------------------------------------------

#define         cdostrNS_Office         L"urn:schemas.microsoft.com:office:office:"

#include <windows.h>
#include <lmcons.h>
#include <tchar.h>
#include <eh.h>


// Define UTILDLLDECL so we will neither import nor export the utility
// functions and classes
#define UTILDLLDECL


#include <sstream.hxx>
#include <filter.h>
#include <global.hxx>
#include <strcnv.h>
#include <irdebug.h>
#include <lmstr.hxx>
#include <namestr.hxx>
#include <filterr.h>

// ATL includes
#include <atlbase.h>
extern CComModule & _Module;
#include "statreg.h"
#include <atlcom.h>
#include "atlext.h"

#define VARIANT PROPVARIANT

#include "specchar.hxx"
#include <htmlscan.hxx>
#include <memthrow.h>
#include <syncrdwr.h>
#include <semcls.h>
#include <misc.hxx>
#include <sifmt.h>
#include <mlang.h>
#include <anchor.hxx>
#include <titletag.hxx>
#include <textelem.hxx>
#include <stgprop.h>
#include <htmlelem.hxx>
#include <start.hxx>
#include <htmlfilt.hxx>
#include <scriptag.hxx>
#include <osv.hxx>
#include <proptag.hxx>
#include <propspec.hxx>
#include <paramtag.hxx>
#include <mmstrm.hxx>
#include "mmscbuf.hxx"
#include <pmmstrm.hxx>
#include <metatag.hxx>
#include <codepage.hxx>
#include <ignortag.hxx>
#include <limits.h>
#include <xmltag.hxx>
#include <deferred.hxx>
#include <defertag.hxx>
#include "prefilter.hxx"
#include <langtag.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\serstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.
//
//  File:       serstrm.cxx
//
//  Contents:   Serial stream
//
//  Classes:    CSerialStream
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
// aControlCodeMap is the mapping for chars in the control code region (0x80 to 0x9f)
// as mapped by the web browser
//

static const WCHAR aControlCodeMap[] = { 0x20,     // space
                                   0x20,     // space
                                   0x2c,     // comma
                                   0x192,    // script f
                                   0x201e,   // low double comma
                                   0x2026,   // horizontal ellipsis
                                   0x2020,   // dagger
                                   0x2021,   // double dagger
                                   0x5e,     // circumflex
                                   0x2030,   // per mille
                                   0x160,    // S haeck
                                   0x2039,   // left guillemet
                                   0x152,    // OE
                                   0x20,     // space
                                   0x20,     // space
                                   0x20,     // space
                                   0x20,     // space
                                   0x2018,   // single turned comma
                                   0x2019,   // single turned comma
                                   0x201c,   // double turned comma
                                   0x201d,   // double turned comma
                                   0x2022,   // bullet
                                   0x2014,   // em dash
                                   0x2015,   // quotation dash
                                   0x2dc,    // tilde
                                   0x2122,   // trademark
                                   0x161,    // s haeck
                                   0x203a,   // right guillemet
                                   0x153,    // oe
                                   0x20,     // space
                                   0x20,     // space
                                   0x178     // y diaresis
                                 };


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::CSerialStream
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CSerialStream::CSerialStream()
    : _cUnGotChars(0),
      _cCharsReadAhead(0),
      _pCurChar(_awcReadAheadBuf),
      m_eUnicodeByteOrder(eNonUnicode)
{
        for (unsigned i = 0; i < MAX_UNGOT_CHARS; i++)
                _wch[i] = 0;
}



//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Init
//
//  Synopsis:   Initialize the memory mapped stream
//
//  Arguments:  [pwszFileName] -- File to be mapped
//
//--------------------------------------------------------------------------

void CSerialStream::Init( WCHAR *pwszFileName )
{
    InternalInit();

    _mmInputStream.Init( pwszFileName );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Init
//
//  Synopsis:   Initialize the memory mapped stream
//
//  Arguments:  [pStream]  -- Input stream
//
//--------------------------------------------------------------------------

void CSerialStream::Init( IStream * pStream )
{
    InternalInit();

    _mmInputStream.Init( pStream );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Init
//
//  Synopsis:   Initialize the memory mapped stream
//
//  Arguments:  [ulCodePage] -- Codepage to use for converting to Unicode
//
//--------------------------------------------------------------------------

void CSerialStream::Init( ULONG ulCodePage )
{
    InternalInit();

    _mmInputStream.Init( ulCodePage );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::InitWithTempFile
//
//  Synopsis:   Initialize the memory mapped stream using the temporary
//              memory-mapped file for S-JIS chars
//
//--------------------------------------------------------------------------

void CSerialStream::InitWithTempFile()
{
    InternalInit();

    _mmInputStream.InitWithTempFile();
}




//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::GetChar
//
//  Synopsis:   Read the next Unicode character from the input file, accounting
//              for special chars, chars push backs and read ahead
//
//  Returns:    Next Unicode char
//
//--------------------------------------------------------------------------

WCHAR CSerialStream::GetChar()
{
    //
    // Was a char pushed back into input ?
    //
    if ( _cUnGotChars > 0 )
    {
        return _wch[--_cUnGotChars];
    }

    //
    // Are there any chars in our read-ahead buffer ?
    //
    WCHAR wch;
    if ( _pCurChar < _awcReadAheadBuf + _cCharsReadAhead )
    {
        wch = *_pCurChar;
        _pCurChar++;

        return wch;
    }

    if ( _mmInputStream.Eof() )
        return WEOF;

    //
    // Read from input stream
    //
    wch = _mmInputStream.GetChar();
    if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces
        wch = L' ';

    if ( wch == L'&' )
    {
        //
        // Read in the special char until ';' or '&', or EOF, or until _awcReadAhead buffer is full
        //
        _awcReadAheadBuf[0] = wch;
        for ( unsigned i=1; i<MAX_SPECIAL_CHAR_LENGTH; i++)
        {
            if ( _mmInputStream.Eof() )
                        {
                                // fix egrecious infinite loop bug when EOF follows '&'
                                if (i == 1)
                                        return L'&';    // EOF follows '&', return '&'

                                i--;                            // interpret '&' to EOF as an entity
                                break;
                        }

            wch = _mmInputStream.GetChar();
            if ( wch == 0xa || wch == 0xd )         // Replace newlines with spaces
                wch = L' ';

            _awcReadAheadBuf[i] = wch;
            if ( wch == L';' || wch == L'&' )
                break;
        }

        if ( wch == L';' || _mmInputStream.Eof() )
        {
            if ( _awcReadAheadBuf[1] == L'#' && IsUnicodeNumber( &_awcReadAheadBuf[2], i-2, wch ) )
            {
                //
                // Return converted Unicode number, e.g. for &#160, return 160
                //
                return wch;
            }
            else if ( LookupSpecialChar( &_awcReadAheadBuf[1], i-1, wch ) )
            {
                //
                // Corresponding Unicode char found
                //
                return wch;
            }
            else
            {
                _cCharsReadAhead = i+1;
                _pCurChar = &_awcReadAheadBuf[1];

                return L'&';
            }
        }
        else if ( wch == L'&' )
        {
            //
            // For example, &acu&aacute; . So keep &acu in the read ahead buffer,
            // but push the second '&' back into the input stream, so that &aacute;
            // can be recognized as a special char during a subsequent call to GetChar()
            //
            _mmInputStream.UnGetChar( L'&' );
            _cCharsReadAhead = i;
            _pCurChar = &_awcReadAheadBuf[1];

            return L'&';
        }
        else
        {
            _cCharsReadAhead = i;
            _pCurChar = &_awcReadAheadBuf[1];

            return L'&';
        }
    }
    else
        return wch;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::UnGetChar
//
//  Synopsis:   Pushes(logically) a character back into the input stream
//
//  Arguments:  [wch]  -- Char to be pushed back
//
//--------------------------------------------------------------------------

void CSerialStream::UnGetChar( WCHAR wch )
{
    //
    // We can unget only up to MAX_UNGOT_CHARS chars at a time
    //
    Win4Assert( _cUnGotChars < MAX_UNGOT_CHARS );

        if (_cUnGotChars < MAX_UNGOT_CHARS)
                _wch[_cUnGotChars++] = wch;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::Eof
//
//  Synopsis:   Is this the end of input file ?
//
//--------------------------------------------------------------------------

BOOL CSerialStream::Eof()
{
    if ( _cUnGotChars > 0 )
        return FALSE;

    if ( _pCurChar < _awcReadAheadBuf + _cCharsReadAhead )
        return FALSE;

    return _mmInputStream.Eof();
}




//+-------------------------------------------------------------------------
//
//  Method:     CSerialStream::IsUnicodeNumber
//
//  Synopsis:   Is the special char a Unicode number ?
//
//  Arguments:  [pwcInputBuf] -- input buffer
//              [uLen]        -- Length of input (not \0 terminated)
//              [wch]         -- Unicode char returned here
//
//  Returns:    True if we've managed to convert to a Unicode number
//
//--------------------------------------------------------------------------

BOOL CSerialStream::IsUnicodeNumber( WCHAR *pwcInputBuf,
                                     unsigned uLen,
                                     WCHAR& wch )
{
    wch = 0;
    for ( unsigned i=0; i<uLen; i++ )
    {
        //
        // Check that the result will be less than max Unicode value, namely 0xffff
        //
        if ( iswdigit( pwcInputBuf[i] )
             && wch < (0xffff - (pwcInputBuf[i]-L'0'))/10 )
        {
            wch = 10 * wch + pwcInputBuf[i] - L'0';
        }
        else
            return FALSE;
    }

    if ( wch >= 0x80 && wch <= 0x9f )
    {
        //
        // Chars in the control code region are mapped by the browser to valid chars
        //

        wch = aControlCodeMap[wch-0x80];
    }

    return ( wch > 0 );
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CSerialStream::CheckForUnicodeStream
//
//  Synopsis:   Peek in the stream to determine if the first 2 bytes is (0xFF 0xFE) or (0xFE 0xFF)
//              If they are, these 2 bytes will be read and the next read will begin after these
//              marker. If the first 2 bytes are not marker for Unicode HTML files, no actually
//              read will be done to the stream and the next read will begin at the beginning.
//
//  Returns:    void
//
//  Throw:      no
//
//  Arguments:  none
//
//  Unclear Assumptions:
//      Unicode HTML files are assumed to begin with the following 2 bytes.
//      0xFF 0xFE for little endian
//      0xFE 0xFF for big endian
//      m_eUnicodeByteOrder is initialized with eNonUnicode.
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CSerialStream::CheckForUnicodeStream()
{
    BYTE *pbStream = (BYTE *)GetBuffer();

    if(pbStream && GetFileSize() >= 2)
    {
        if((0xFF == *pbStream) && (0xFE == *(pbStream + 1)))
        {
            m_eUnicodeByteOrder = eLittleEndian;
        }
        else if((0xFE == *pbStream) && (0xFF == *(pbStream + 1)))
        {
            m_eUnicodeByteOrder = eBigEndian;
        }
        
        if((eLittleEndian == m_eUnicodeByteOrder) ||
            (eBigEndian == m_eUnicodeByteOrder))
        {
            _mmInputStream.SkipTwoByteUnicodeMarker();
        }
    }
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CSerialStream::InitAsUnicodeIfUnicode()
//
//  Synopsis:   See if the stream is Unicode or not.
//
//  Returns:    TRUE if the stream is Unicode.
//              FALSE otherwise.
//
//  Throw:      no
//
//  Arguments:  none
//
//  Unclear Assumptions: none
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
BOOL CSerialStream::InitAsUnicodeIfUnicode()
{
    if((eLittleEndian == m_eUnicodeByteOrder) ||
        (eBigEndian == m_eUnicodeByteOrder))
    {
        InitAsUnicode();
        return TRUE;
    }

    return FALSE;
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CSerialStream::InitAsUnicode
//
//  Synopsis:   Initialize the stream as an Unicode stream.
//
//  Returns:    void
//
//  Throw:      no
//
//  Arguments:  none
//
//  Unclear Assumptions:
//      To be consistent and minimize confusion, this method has a side effect just
//      like other Init methods of this class. Personally, I would like to avoid side
//      effect as a general rule. But in this case, consistency with the existing code
//      is more important. The side effect is that the stream would be rewind upon
//      completion of the Init methods. The unique part about the InitAsUnicode method
//      is that it requires skipping the 2-byte Unicode marker.
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CSerialStream::InitAsUnicode()
{
    Win4Assert(((eLittleEndian == m_eUnicodeByteOrder) || (eBigEndian == m_eUnicodeByteOrder))
                && "Why InitAsUncode() is it is *not* Unicode??");

    InternalInit();

    if(eLittleEndian == m_eUnicodeByteOrder)
    {
        _mmInputStream.InitAsUnicode(FALSE);
    }
    else if(eBigEndian == m_eUnicodeByteOrder)
    {
        _mmInputStream.InitAsUnicode(TRUE);
    }

    _mmInputStream.SkipTwoByteUnicodeMarker();
}




//+-------------------------------------------------------------------------------------------------
//
//  Method:     CSerialStream::InternalInit
//
//  Synopsis:   Initialize member variables.
//
//  Returns:    void
//
//  Throw:      no
//
//  Arguments:  none
//
//  Unclear Assumptions:
//      Called by other Init methods.
//
//  History:    10/10/00    mcheng      Created
//
//+-------------------------------------------------------------------------------------------------
void CSerialStream::InternalInit()
{
    ZeroMemory(_wch, sizeof(_wch));
    _cUnGotChars = 0;
    _cCharsReadAhead = 0;
    _pCurChar = _awcReadAheadBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\semcls.h ===
//                                                                                                                              -*- c++ -*-
// 
//  Microsoft Network
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       semcls.H
//
//  Contents:   in-line declarations for correct C++ use of critical sections
//                              and CSyncReadWrite
//
//  Classes:    
//
//  Functions:
//
//  History:    03-04-96   Dmitriy Meyerzon   Created
//                          06-16-97   Alan Pearson       Added CSafeArrayAccessData
//                              06-18-97   Alan Pearson       Added CComInit    
//

#ifndef __SEMCLS_H
#define __SEMCLS_H

#pragma warning( disable : 4284 )

//#include <irdebug.h>
#include "syncrdwr.h"
#include "memthrow.h"


//
// class CComInit
//
//              unwindable class to intialize com
//

class CComInit
{
        
public:
        
        CComInit()
        {
                ::CoInitializeEx( NULL, COINIT_MULTITHREADED );
        }

        ~CComInit()
        {
                ::CoUninitialize();
        }
};


class CCriticalResource
{
public:
        CCriticalResource(CRITICAL_SECTION &rSection): rCriticalSection(rSection)
        {
                EnterCriticalSection(&rCriticalSection);
        }

        ~CCriticalResource() { LeaveCriticalSection(&rCriticalSection); }

private:
        CRITICAL_SECTION &rCriticalSection;
};

class CNonExclusive
{
public:
        CNonExclusive(CSyncReadWrite &rSyncRdwr): rSyncReadWrite(rSyncRdwr)
        {
                rSyncReadWrite.BeginRead();
        }

        ~CNonExclusive() { rSyncReadWrite.EndRead(); }

private:
        CSyncReadWrite &rSyncReadWrite;
};

class CExclusive
{
public:
        CExclusive(CSyncReadWrite &rSyncRdwr): rSyncReadWrite(rSyncRdwr)
        {
                rSyncReadWrite.BeginWrite();
        }

        ~CExclusive() { rSyncReadWrite.EndWrite(); }

private:
        CSyncReadWrite &rSyncReadWrite;
};

class SafeHandle
{
public:
        SafeHandle(): m_h(NULL) {}
        ~SafeHandle() 
        { 
                if(m_h) CloseHandle(m_h); 
        }

        operator HANDLE() const { return m_h; }

        int operator ==(HANDLE h) const { return m_h == h; }
        int operator != (HANDLE h) const { return m_h != h; }
        SafeHandle &operator =(HANDLE h) { m_h = h; return *this; }
        HANDLE *operator &() { return &m_h; }

private:
        HANDLE m_h;
};

class SafeFileHandle
{
public:
        SafeFileHandle(): m_h(INVALID_HANDLE_VALUE) {}
        ~SafeFileHandle() 
        { 
                if(m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); 
        }

        operator HANDLE() const { return m_h; }

        int operator ==(HANDLE h) const { return m_h == h; }
        int operator != (HANDLE h) const { return m_h != h; }
        SafeFileHandle &operator =(HANDLE h) { m_h = h; return *this; }
        HANDLE *operator &() { return &m_h; }

private:
        HANDLE m_h;
};


class RegistryKey
{
        
public:
        
        RegistryKey(): m_h(NULL) {}
        ~RegistryKey() 
        { 
                if(m_h) RegCloseKey(m_h); 
        }

        int operator ==(HKEY h) const { return m_h == h; }
        int operator != (HKEY h) const { return m_h != h; }
        
        RegistryKey &operator =(HKEY h) { m_h = h; return *this; }
        RegistryKey &operator =(RegistryKey& k) { m_h = k.m_h; return *this; }
        
        operator HKEY() const { return m_h; }
        PHKEY operator &() { return &m_h; }

private:
        
        HKEY m_h;
};


class CriticalSection
{
public:
        CriticalSection() { InitializeCriticalSection(&m_cs); }
        ~CriticalSection() { DeleteCriticalSection(&m_cs); }

        operator LPCRITICAL_SECTION () { return &m_cs; }
        operator CRITICAL_SECTION &() { return m_cs; }

        void Enter() { EnterCriticalSection(&m_cs); }
        void Leave() { LeaveCriticalSection(&m_cs); }
        
private:
        CRITICAL_SECTION m_cs;

        CriticalSection(const CriticalSection &);
};


class CVariant
{
        
public:

        CVariant() : m_pvar(0) {}
        CVariant( VARIANT* pvar ) : m_pvar(pvar) {}
        
        virtual ~CVariant()
        {
                if( m_pvar != 0 )
                        VariantClear(m_pvar);
                m_pvar = 0;
        }

        operator VARIANT*()     { return m_pvar; }
        VARIANT* operator -> () { return m_pvar; }
        
        CVariant& operator = ( VARIANT* pvar )
        {
                m_pvar = pvar;
                return *this;
        }

private:

        VARIANT*                        m_pvar;
        
};


//-----------------------------------------------------------------------------
// class CSafeArrayAccess
//
// Author:              alanpe
//
// Purpose:             unwindable class that does SafeArrayAccessData and
//                              SafeArrayUnaccessData
//
// History:             06-16-97                Created                 alanpe
//
//-----------------------------------------------------------------------------

class CSafeArrayAccessData
{
private:
        SAFEARRAY&      m_rsa;
        BOOL            m_fAccessed;
        
public:
        CSafeArrayAccessData( SAFEARRAY& rsa ) :
                m_rsa(rsa),
                m_fAccessed(FALSE)
        {
        }

        ~CSafeArrayAccessData()
        {
                if( m_fAccessed )
                        UnaccessData();
        }
                
        HRESULT AccessData( void** ppvData )
        {
                HRESULT hr = SafeArrayAccessData( &m_rsa, ppvData );
                if( SUCCEEDED(hr) )
                        m_fAccessed = TRUE;
                return hr;
        }

        HRESULT UnaccessData( void )
        {
                return SafeArrayUnaccessData( &m_rsa );
        }
};



//-----------------------------------------------------------------------------
//
// class CSafeArray
//
//              smart wrapper around OLE automation safe array
//
//-----------------------------------------------------------------------------

class CSafeArray
{
private:

        SAFEARRAY*      m_psa;

public:

        CSafeArray() : m_psa(0) {}
        CSafeArray( SAFEARRAY *psa ) : m_psa(psa) {}

        ~CSafeArray()
        {
                Destroy();
        }
        
        operator SAFEARRAY*()
        {
                return m_psa;
        }
        
        CSafeArray& operator = ( SAFEARRAY* psa )
        {
                Set(psa);
                return *this;
        }

        void Destroy()
        {
                if( m_psa )
                        SafeArrayDestroy( m_psa );
                m_psa = 0;
        }
        
        SAFEARRAY* Get()
        {
                return m_psa;
        }
        
        void Set( SAFEARRAY* psa )
        {
                if( m_psa )
                        Destroy();
                m_psa = psa;
        }

        SAFEARRAY* Acquire( void )
        {
                SAFEARRAY* psa = m_psa;
                m_psa = 0;
                return psa;
        }
};

template <class T> class TPointer
{
public:
        TPointer(): m_pT(NULL) {}
        TPointer(T* pT): m_pT(pT) {}
        ~TPointer() { if(m_pT) delete m_pT; }

        operator T*() { return m_pT; }
        operator const T*() const { return m_pT; }
        
        T* operator ->() { return m_pT; }

        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        BOOL operator != (T* pT) const
        {
                return m_pT != pT;
        }


        void operator =(T*pT) { m_pT = pT; }
        T** operator &() { return &m_pT; }

        BOOL IsNull() const { return 0 == m_pT; }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }
        
private:
        T* m_pT;
};


template <class T> class TArray
{
public:
        TArray(): m_pT(NULL) {}
        TArray(T* pT): m_pT(pT) {}
        ~TArray() { if(m_pT) delete[] m_pT; }

         __forceinline operator T*() { return m_pT; }
         __forceinline operator const T*() const { return m_pT; }

        T& operator[](int n) { return m_pT[n]; }
        const T& operator[](int n) const { return m_pT[n]; }
        
        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        BOOL operator != (T* pT) const
        {
                return m_pT != pT;
        }

        void operator =(T*pT) { m_pT = pT; }
        T** operator &() { return &m_pT; }

        BOOL IsNull() const { return 0 == m_pT; }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }
        
private:
        T* m_pT;
};


template <class T> class TGlobalPointer
{
public:
        TGlobalPointer(): m_pT(NULL) {}
        TGlobalPointer(T* pT): m_pT(pT) {}
        virtual ~TGlobalPointer() { if(m_pT) GlobalFree(m_pT); }

        operator T*() { return m_pT; }
        T* operator ->() { return m_pT; }

        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }
        
        void operator =(T*pT) { m_pT = pT; }
        T** operator &() { return &m_pT; }

private:
        T* m_pT;
};

template <class T> class TTaskMemPointer
{
public:
        TTaskMemPointer(): m_pT(NULL) {}
        TTaskMemPointer(T* pT): m_pT(pT) {}
        virtual ~TTaskMemPointer() { if(m_pT) CoTaskMemFree(m_pT); }

        operator T*() { return m_pT; }
        T* operator ->() { return m_pT; }

        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        BOOL operator != (T* pT) const
        {
                return m_pT != pT;
        }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }

        void operator =(T*pT) { m_pT = pT; }
        T** operator &() { return &m_pT; }

private:
        T* m_pT;
};

template <class T, int N> class TPointerArray
{
public:
        TPointerArray()
        {
                int i;
                for(i=0;i<N;i++)
                {
                        m_T[i] = NULL;
                }
        }

        ~TPointerArray()
        {
                int i;
                for(i=0;i<N;i++)
                {
                        if(m_T[i]) 
                        {
                                delete m_T[i];
                        }
                }
        }

        T* &operator [](int i) 
        { 
                static T *pDummy = NULL;
                if(i >= N) return pDummy;

                return m_T[i]; 
        }
        const T* operator[](int i) const 
        { 
                if(i >= N) return NULL;
                return m_T[i]; 
        }

private:
        T* m_T[N];
};

template <class T> class TComPointer
{
public:
        TComPointer(): m_pT(NULL) {}
        TComPointer(T* pT);
        TComPointer(const TComPointer<T>& rT);
        ~TComPointer();

        operator T*() { return m_pT; }
        T& operator*() { return *m_pT; }

        // Removed ASSERT from operator&. Needed for search\collator\cmdcreator.cpp
        T** operator&() { return &m_pT; }
        T* operator->() { return m_pT; }
        T* operator=(T* pT);
        void operator=(const TComPointer &rT);

        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        BOOL operator != (T* pT) const
        {
                return m_pT != pT;
        }

        BOOL IsNull() const { return 0 == m_pT; }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }

private:
            
        T* m_pT;
};

template <class T> inline
TComPointer<T>::TComPointer(T* pT) : m_pT(pT)
{
        if(m_pT) m_pT->AddRef();
}

template <class T> inline
TComPointer<T>::TComPointer(const TComPointer<T>& rT) : m_pT(rT.m_pT)
{
        if(m_pT) m_pT->AddRef();
}

template <class T> inline
TComPointer<T>::~TComPointer() 
{ 
        if (m_pT) m_pT->Release(); 
}

template <class T> inline
T* TComPointer<T>::operator =(T*pT)
{
        // Do not make this function ASSERT that m_pt==0 instead of Releasing the
        // current pointer.  search\collator\cmdcreator.cpp depends on the current
        // behaviour.
        if(pT) pT->AddRef();
        if(m_pT) m_pT->Release();
        m_pT=pT;
        return m_pT;
}

template <class T> inline
void TComPointer<T>::operator =(const TComPointer<T> &rT)
{
        *this = (T *)(TComPointer<T> &)rT;
}

template <class T> class TComNoUnkPointer
{
public:
        TComNoUnkPointer(): m_pT(NULL) {}
        TComNoUnkPointer(T* pT);
        TComNoUnkPointer(const TComNoUnkPointer<T>& rT);
        ~TComNoUnkPointer();

        operator T*() { return m_pT; }
        T& operator*() { return *m_pT; }

        // Added an assertion that the pointer is null based on the 
        //  assumption that you're about to write over it
        T** operator&() { return &m_pT; }
        T* operator->() { return m_pT; }
        T* operator=(T* pT);
        void operator=(const TComNoUnkPointer &rT);

        BOOL operator == (T* pT) const
        {
                return m_pT == pT;
        }

        BOOL operator != (T* pT) const
        {
                return m_pT != pT;
        }

        T * Acquire()
        {
                T * pTemp = m_pT;
                m_pT = 0;
                return pTemp;
        }


private:
        T* m_pT;
};

template <class T> inline 
TComNoUnkPointer<T>::TComNoUnkPointer(T* pT) : m_pT(pT)
{
        if(m_pT) m_pT->GetUnknown()->AddRef();
}

template <class T> inline 
TComNoUnkPointer<T>::TComNoUnkPointer(const TComNoUnkPointer<T>& rT) : m_pT(rT.m_pT)
{
        if(m_pT) m_pT->GetUnknown()->AddRef();
}

template <class T> inline 
TComNoUnkPointer<T>::~TComNoUnkPointer()
{
        if (m_pT) m_pT->GetUnknown()->Release();
}

template <class T> inline 
T* TComNoUnkPointer<T>::operator =(T*pT)
{
        if(pT) pT->GetUnknown()->AddRef();
        if(m_pT) m_pT->GetUnknown()->Release();
        m_pT=pT;
        return m_pT;
}

template <class T> inline
void TComNoUnkPointer<T>::operator =(const TComNoUnkPointer<T> &rT)
{
        *this = (T *)(TComNoUnkPointer<T> &)rT;
}

class CCoImpersonateClient
{
        public:
        CCoImpersonateClient()
        {
                m_hr = CoImpersonateClient();
        }

        ~CCoImpersonateClient()
        {
                CoRevertToSelf();
        }

        HRESULT GetImpersonationStatus() const { return m_hr; }

        private:
        HRESULT m_hr;
};

class CSmartImpersonator
{
public:
        CSmartImpersonator(HANDLE hPreviousToken) : m_hPreviousToken(hPreviousToken) {}

        ~CSmartImpersonator()
        {
                RevertToPrevious();
        }

        void ImpersonateLoggedOnUser(HANDLE hToken)
        {
                if(::ImpersonateLoggedOnUser(hToken) == FALSE)
                {
                        throw CException();
                }
        }

        void ImpersonateSelf()
        {
                if(::RevertToSelf() == FALSE)
                {
                        throw CException();
                }
        }

        void RevertToPrevious()
        {
                if(m_hPreviousToken != NULL)
                {
                        if(::ImpersonateLoggedOnUser(m_hPreviousToken) == FALSE)
                        {
                                throw CException();
                        }
                }
                else
                {
                        if(::RevertToSelf() == FALSE)
                        {
                                throw CException();
                        }
                }
        }

private:
        HANDLE m_hPreviousToken;
};

class CBlob
{
public:
        CBlob() 
        {
                m_Blob.pBlobData = NULL;
                m_Blob.cbSize = 0;
        }
        CBlob(const BLOB &Blob)
        {
                *this = Blob;
        }

        CBlob(const CBlob& rBlob)
        {
                *this = rBlob.m_Blob;
        }

        ~CBlob()
        {
                Free();
        }

        BLOB* operator&() { return &m_Blob; }
        
        void operator=(const BLOB& Blob)
        {
                Free();

                if(Blob.cbSize)
                {
                        m_Blob.pBlobData = (BYTE *)CoTaskMemAlloc(Blob.cbSize);
                        if(m_Blob.pBlobData == NULL)
                        {
                                throw CException(E_OUTOFMEMORY);
                        }

                        CopyMemory(m_Blob.pBlobData, Blob.pBlobData, Blob.cbSize);
                        m_Blob.cbSize = Blob.cbSize;
                }
        }

        void operator=(const CBlob &rBlob)
        {
                *this = rBlob.m_Blob;
        }

private:
        void Free()
        {
                if(m_Blob.cbSize)
                {
                        ASSERT(m_Blob.pBlobData);
                        CoTaskMemFree(m_Blob.pBlobData);
                        m_Blob.pBlobData = NULL;
                        m_Blob.cbSize = 0;
                }
        }
            
        BLOB m_Blob;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\specchar.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 2002 - 2002 Microsoft Corporation.
//
//  File:       specchar.cxx
//
//  Contents:   Table that maps special characters to Unicode
//
//  Classes:    CSpecialCharTable
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

struct SStringCharEntry
{
    WCHAR const * pwcString;
    WCHAR         wcChar;
};

const SStringCharEntry g_aCharMap[] =
{
    { L"AElig",   0xC6 },
    { L"AMP",     0x26 },
    { L"Aacute",  0xC1 },
    { L"Abreve",  0x102 },
    { L"Acirc",   0xC2 },
    { L"Agrave",  0xC0 },
    { L"Alpha",   913 },
    { L"Amacr",   0x100 },
    { L"Aogon",   0x104 },
    { L"Aring",   0xC5 },
    { L"Atilde",  0xC3 },
    { L"Auml",    0xC4 },
    { L"Beta",    914 },
    { L"COPY",    0xA9 },
    { L"Cacute",  0x106 },
    { L"Ccaron",  0x10C },
    { L"Ccedil",  0xC7 },
    { L"Ccirc",   0x108 },
    { L"Cdot",    0x10A },
    { L"Chi",     935 },
    { L"Dagger",  8225 },
    { L"Dcaron",  0x10E },
    { L"Delta",   916 },
    { L"Dstrok",  0x110 },
    { L"ENG",     0x14A },
    { L"ETH",     0xD0 },
    { L"Eacute",  0xC9 },
    { L"Ebreve",  0x114 },
    { L"Ecaron",  0x11A },
    { L"Ecirc",   0xCA },
    { L"Edot",    0x116 },
    { L"Egrave",  0xC8 },
    { L"Emacr",   0x112 },
    { L"Eogon",   0x118 },
    { L"Epsilon", 917 },
    { L"Eta",     919 },
    { L"Euml",    0xCB },
    { L"GT",      PRIVATE_USE_MAPPING_FOR_GT },
    { L"Gamma",   915 },
    { L"Gbreve",  0x11E },
    { L"Gcedil",  0x122 },
    { L"Gcirc",   0x11C },
    { L"Gdot",    0x120 },
    { L"Iacute",  0xCD },
    { L"Icirc",   0xCE },
    { L"Idot",    0x130 },
    { L"Igrave",  0xCC },
    { L"Imacr",   0x12A },
    { L"Iogon",   0x12E },
    { L"Iota",    921 },
    { L"Itilde",  0x128 },
    { L"Iuml",    0xCF },
    { L"Kappa",   922 },
    { L"Kcedil",  0x136 },
    { L"LT",      PRIVATE_USE_MAPPING_FOR_LT },
    { L"Lacute",  0x139 },
    { L"Lambda",  923 },
    { L"Lcaron",  0x13D },
    { L"Lcedil",  0x13B },
    { L"Lstrok",  0x141 },
    { L"Mu",      924 },
    { L"Nacute",  0x143 },
    { L"Ncaron",  0x147 },
    { L"Ncedil",  0x145 },
    { L"Ntilde",  0xD1 },
    { L"Nu",      925 },
    { L"OElig",   0x152 },
    { L"Oacute",  0xD3 },
    { L"Ocirc",   0xD4 },
    { L"Odblac",  0x150 },
    { L"Ograve",  0xD2 },
    { L"Omacr",   0x14C },
    { L"Omega",   937 },
    { L"Omicron", 927 },
    { L"Oslash",  0xD8 },
    { L"Otilde",  0xD5 },
    { L"Ouml",    0xD6 },
    { L"Phi",     934 },
    { L"Pi",      928 },
    { L"Prime",   8243 },
    { L"Psi",     936 },
    { L"QUOT",    PRIVATE_USE_MAPPING_FOR_QUOT },
    { L"REG",     0xAE },
    { L"Racute",  0x154 },
    { L"Rcaron",  0x158 },
    { L"Rho",     929 },
    { L"Sacute",  0x15A },
    { L"Scaron",  0x160 },
    { L"Scedil",  0x15E },
    { L"Sigma",   931 },
    { L"THORN",   0xDE },
    { L"TRADE",   8482 },
    { L"Tau",     932 },
    { L"Tcaron",  0x164 },
    { L"Tcedil",  0x162 },
    { L"Theta",   920 },
    { L"Tstrok",  0x166 },
    { L"Uacute",  0xDA },
    { L"Ucirc",   0xDB },
    { L"Udblac",  0x170 },
    { L"Ugrave",  0xD9 },
    { L"Umacr",   0x16A },
    { L"Uogon",   0x172 },
    { L"Upsilon", 933 },
    { L"Uring",   0x16E },
    { L"Utilde",  0x168 },
    { L"Uuml",    0xDC },
    { L"Xi",      926 },
    { L"Yacute",  0xDD },
    { L"Yuml",    0x178 },
    { L"Zacute",  0x179 },
    { L"Zcaron",  0x17D },
    { L"Zdot",    0x17B },
    { L"Zeta",    918 },
    { L"aacute",  0xE1 },
    { L"aafs",    8301 },
    { L"abreve",  0x103 },
    { L"acirc",   0xE2 },
    { L"acute",   0xB4 },
    { L"aelig",   0xE6 },
    { L"agrave",  0xE0 },
    { L"alefsym", 8501 },
    { L"alpha",   945 },
    { L"amacr",   0x101 },
    { L"amp",     0x26 },
    { L"and",     8743 },
    { L"ang",     8736 },
    { L"aogon",   0x105 },
    { L"apos",    0x27 },
    { L"aring",   0xE5 },
    { L"ass",     8299 },
    { L"asymp",   8776 },
    { L"atilde",  0xE3 },
    { L"auml",    0xE4 },
    { L"bdquo",   8222 },
    { L"beta",    946 },
    { L"breve",   0x2D8 },
    { L"brvbar",  0xA6 },
    { L"bull",    8226 },
    { L"cacute",  0x107 },
    { L"cap",     8745 },
    { L"caron",   0x2C7 },
    { L"ccaron",  0x10D },
    { L"ccedil",  0xE7 },
    { L"ccirc",   0x109 },
    { L"cdot",    0x10B },
    { L"cedil",   0xB8 },
    { L"cent",    0xA2 },
    { L"chi",     967 },
    { L"circ",    710 },
    { L"clubs",   9827 },
    { L"colon",   0x3A },
    { L"comma",   0x2C },
    { L"cong",    8773 },
    { L"copy",    0xA9 },
    { L"crarr",   8629 },
    { L"cup",     8746 },
    { L"curren",  0xA4 },
    { L"dArr",    8659 },
    { L"dagger",  8224 },
    { L"darr",    8595 },
    { L"dblacc",  0x2DD },
    { L"dcaron",  0x10F },
    { L"deg",     0xB0 },
    { L"delta",   948 },
    { L"diams",   9830 },
    { L"divide",  0xF7 },
    { L"dot",     0x2D9 },
    { L"dstrok",  0x111 },
    { L"eacute",  0xE9 },
    { L"ebreve",  0x115 },
    { L"ecaron",  0x11B },
    { L"ecirc",   0xEA },
    { L"edot",    0x117 },
    { L"egrave",  0xE8 },
    { L"emacr",   0x113 },
    { L"empty",   8709 },
    { L"emsp",    8195 },
    { L"eng",     0x14B },
    { L"ensp",    8194 },
    { L"eogon",   0x119 },
    { L"epsilon", 949 },
    { L"equals",  0x3D },
    { L"equiv",   8801 },
    { L"eta",     951 },
    { L"eth",     0xF0 },
    { L"euml",    0xEB },
    { L"euro",    8364 },
    { L"excl",    0x21 },
    { L"exist",   8707 },
    { L"fnof",    402 },
    { L"forall",  8704 },
    { L"frac12",  0xBD },
    { L"frac14",  0xBC },
    { L"frac34",  0xBE },
    { L"frasl",   8260 },
    { L"gamma",   947 },
    { L"gbreve",  0x11F },
    { L"gcedil",  0x123 },
    { L"gcirc",   0x11D },
    { L"gdot",    0x121 },
    { L"ge",      8805 },
    { L"grave",   0x60 },
    { L"gt",      PRIVATE_USE_MAPPING_FOR_GT },
    { L"hArr",    8660 },
    { L"harr",    8596 },
    { L"hearts",  9829 },
    { L"hellip",  8230 },
    { L"iacute",  0xED },
    { L"iafs",    8300 },
    { L"icirc",   0xEE },
    { L"iexcl",   0xA1 },
    { L"igrave",  0xEC },
    { L"imacr",   0x12B },
    { L"image",   8465 },
    { L"infin",   8734 },
    { L"inodot",  0x131 },
    { L"int",     8747 },
    { L"iogon",   0x12F },
    { L"iota",    953 },
    { L"iquest",  0xBF },
    { L"isin",    8712 },
    { L"iss",     8298 },
    { L"itilde",  0x129 },
    { L"iuml",    0xEF },
    { L"kappa",   954 },
    { L"kcedil",  0x137 },
    { L"kra",     0x138 },
    { L"lArr",    8656 },
    { L"lacute",  0x13A },
    { L"lambda",  955 },
    { L"lang",    9001 },
    { L"laquo",   0xAB },
    { L"larr",    8592 },
    { L"lcaron",  0x13E },
    { L"lcedil",  0x13C },
    { L"lceil",   8968 },
    { L"ldquo",   8220 },
    { L"le",      8804 },
    { L"lfloor",  8970 },
    { L"lowast",  8727 },
    { L"lowbar",  0x5F },
    { L"loz",     9674 },
    { L"lre",     8234 },
    { L"lrm",     8206 },
    { L"lro",     8237 },
    { L"lsaquo",  8249 },
    { L"lsqb",    0x5B },
    { L"lsquo",   8216 },
    { L"lstrok",  0x142 },
    { L"lt",      PRIVATE_USE_MAPPING_FOR_LT },
    { L"macr",    0xAF },
    { L"mdash",   8212 },
    { L"micro",   0xB5 },
    { L"middot",  0xB7 },
    { L"minus",   8722 },
    { L"mu",      956 },
    { L"nabla",   8711 },
    { L"nacute",  0x144 },
    { L"nads",    8302 },
    { L"nbsp",    0xA0 },
    { L"ncaron",  0x148 },
    { L"ncedil",  0x146 },
    { L"ndash",   8211 },
    { L"ne",      8800 },
    { L"ni",      8715 },
    { L"nods",    8303 },
    { L"not",     0xAC },
    { L"notin",   8713 },
    { L"nsub",    8836 },
    { L"ntilde",  0xF1 },
    { L"nu",      957 },
    { L"oacute",  0xF3 },
    { L"ocirc",   0xF4 },
    { L"odblac",  0x151 },
    { L"oelig",   0x153 },
    { L"ogon",    0x2DB },
    { L"ograve",  0xF2 },
    { L"oline",   8254 },
    { L"omacr",   0x14D },
    { L"omega",   969 },
    { L"omicron", 959 },
    { L"oplus",   8853 },
    { L"or",      8744 },
    { L"ordf",    0xAA },
    { L"ordm",    0xBA },
    { L"oslash",  0xF8 },
    { L"otilde",  0xF5 },
    { L"otimes",  8855 },
    { L"ouml",    0xF6 },
    { L"para",    0xB6 },
    { L"part",    8706 },
    { L"pdf",     8236 },
    { L"period",  0x2E },
    { L"permil",  8240 },
    { L"perp",    8869 },
    { L"phi",     966 },
    { L"pi",      960 },
    { L"piv",     982 },
    { L"plus",    0x2B },
    { L"plusmn",  0xB1 },
    { L"pound",   0xA3 },
    { L"prime",   8242 },
    { L"prod",    8719 },
    { L"prop",    8733 },
    { L"psi",     968 },
    { L"quest",   0x3F },
    { L"quot",    PRIVATE_USE_MAPPING_FOR_QUOT },
    { L"rArr",    8658 },
    { L"racute",  0x155 },
    { L"radic",   8730 },
    { L"rang",    9002 },
    { L"raquo",   0xBB },
    { L"rarr",    8594 },
    { L"rcaron",  0x159 },
    { L"rceil",   8969 },
    { L"rdquo",   8221 },
    { L"real",    8476 },
    { L"reg",     0xAE },
    { L"rfloor",  8971 },
    { L"rho",     961 },
    { L"rle",     8235 },
    { L"rlm",     8207 },
    { L"rlo",     8238 },
    { L"rsaquo",  8250 },
    { L"rsqb",    0x5D },
    { L"rsquo",   8217 },
    { L"sacute",  0x15B },
    { L"sbquo",   8218 },
    { L"scaron",  0x161 },
    { L"scedil",  0x15F },
    { L"sdot",    8901 },
    { L"sect",    0xA7 },
    { L"semi",    0x3B },
    { L"shy",     0xAD },
    { L"sigma",   963 },
    { L"sigmaf",  962 },
    { L"sim",     8764 },
    { L"spades",  9824 },
    { L"sub",     8834 },
    { L"sube",    8838 },
    { L"sum",     8721 },
    { L"sup",     8835 },
    { L"sup1",    0xB9 },
    { L"sup2",    0xB2 },
    { L"sup3",    0xB3 },
    { L"supe",    8839 },
    { L"supl",    0xB9 },
    { L"szlig",   0xDF },
    { L"tau",     964 },
    { L"tcaron",  0x165 },
    { L"tcedil",  0x163 },
    { L"there4",  8756 },
    { L"theta",   952 },
    { L"thetasym",977 },
    { L"thinsp",  8201 },
    { L"thorn",   0xFE },
    { L"tilde",   0x2DC },
    { L"times",   0xD7 },
    { L"trade",   8482 },
    { L"tstrok",  0x167 },
    { L"uArr",    8657 },
    { L"uacute",  0xFA },
    { L"uarr",    8593 },
    { L"ucirc",   0xFB },
    { L"udblac",  0x171 },
    { L"ugrave",  0xF9 },
    { L"umacr",   0x16B },
    { L"uml",     0xA8 },
    { L"uogon",   0x173 },
    { L"upsih",   978 },
    { L"upsilon", 965 },
    { L"uring",   0x16F },
    { L"utilde",  0x169 },
    { L"uuml",    0xFC },
    { L"weierp",  8472 },
    { L"xi",      958 },
    { L"yacute",  0xFD },
    { L"yen",     0xA5 },
    { L"yuml",    0xFF },
    { L"zacute",  0x17A },
    { L"zcaron",  0x17E },
    { L"zdot",    0x17C },
    { L"zeta",    950 },
    { L"zwj",     8205 },
    { L"zwnj",    8204 },
    { L"zwsp",    8203 },
};

#define ArraySize(x) ( sizeof( x ) / sizeof( x[0] ) )

const ULONG g_cCharMap = ArraySize( g_aCharMap );

int __cdecl StringCharEntryCompare(
    WCHAR const *            pwcKey,
    SStringCharEntry const * pEntry )
{
    return wcscmp( pwcKey, pEntry->pwcString );
} //StringCharEntryCompare

BOOL LookupSpecialChar( WCHAR const * pwcTag, ULONG cwcTag, WCHAR & wc )
{
    WCHAR awc[ 50 ];

    if ( cwcTag >= ArraySize( awc ) )
        return FALSE;

    memcpy( awc, pwcTag, cwcTag * sizeof WCHAR );
    awc[ cwcTag ] = 0;

    SStringCharEntry * pEntry = (SStringCharEntry *)
                                bsearch( awc,
                                         g_aCharMap,
                                         g_cCharMap,
                                         sizeof SStringCharEntry,
                                         (int (__cdecl *)(const void *, const void *) )
                                             StringCharEntryCompare );

    if ( 0 != pEntry )
    {
        wc = pEntry->wcChar;
        return TRUE;
    }

    return FALSE;
} //LookupSpecialChar
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\start.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.
//
//  File:       start.cxx
//
//  Contents:   Parsing algorithm at the beginning of an Html file
//
//  Classes:    CStartOfFileElement
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::CStartOfFileElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CStartOfFileElement::CStartOfFileElement( CHtmlIFilter& htmlIFilter,
                                          CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CStartOfFileElement::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    //
    // CStartOfFile is used to set up the first chunk correctly, and the first
    // chunk cannot be of type CStartOfFile
    //
    Win4Assert( !"CStartOfFileElement::GetText() call unexpected" );

    return E_FAIL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CStartOfFileElement::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CStartOfFileElement::InitStatChunk( STAT_CHUNK *pStat )
{
    Win4Assert( !"CStartOfFileElement::InitStatChunk() call unexpected" );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\slnklist.h ===
//---------------------------------------------------------------
//  File:		CLnkList.h
//        
//	Synopsis:	Header for the single linked list
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Author:    Dmitriy Meyerzon
//----------------------------------------------------------------

#ifndef  __CLNKLIST_H
#define  __CLNKLIST_H

class CSingleLink
{
	public:

	CSingleLink(): m_plNext(NULL) {}
	~CSingleLink() {}

	CSingleLink* GetNext() { return m_plNext; }
	CSingleLink* m_plNext;
};


class CLnkList
{
	public:

	CLnkList();
	~CLnkList() {}

	DWORD		 GetEntries() const { return m_uItems; }
	CSingleLink* GetFirst() const	{ return IsEmpty() ? NULL: m_Begin.m_plNext; }
	BOOL		 IsEmpty() const { return m_uItems == 0; }
	CSingleLink* GetLast() const { return IsEmpty() ? NULL : m_Last; }

	void		 Append(CSingleLink* pLink)	{ InsertAfter(m_Last, pLink); }
	void		 Prepend(CSingleLink* pLink)	{ InsertAfter(&m_Begin, pLink); }
	CSingleLink* operator [](UINT i) const { return GetAt(i); }
	CSingleLink* RemoveFirst()	{ return IsEmpty() ? NULL : RemoveAfter(&m_Begin); }
	CSingleLink* RemoveLast()	{ return Remove(GetLast()); }

	CSingleLink* GetAt(UINT i) const;
	BOOL		 InsertAt(CSingleLink* pLink, UINT i);
	BOOL		 Contains(const CSingleLink *pLink) const;
	CSingleLink* GetNext(const CSingleLink *pLink) const; //do not use this to iterate the list
															//instead use the iterator

	CSingleLink* Remove(CSingleLink *pLink) { return RemoveAfter(GetPrior(pLink)); }
	CSingleLink* RemoveAt(UINT i);
	void RemoveAll();

	protected:

	void		 InsertAfter(CSingleLink* pExistingLink, CSingleLink* pNewLink);
	CSingleLink* RemoveAfter(CSingleLink* pLink);
	CSingleLink* GetPrior(const CSingleLink *pLink);

	CSingleLink	 m_Begin;		
	CSingleLink	 m_End;		
	CSingleLink* m_Last;		
	DWORD		 m_uItems;
	
	friend class CLnkListIterator;	
};

// the iterator
class CLnkListIterator
{
	public:
	CLnkListIterator(CLnkList& rList): 
		m_LnkList(&rList), m_Position(&rList.m_Begin), m_Prior(NULL) 
		{}
	CLnkListIterator() : m_LnkList(NULL), m_Position(NULL), m_Prior(NULL)
		{}
	~CLnkListIterator() {}

	CLnkListIterator(CLnkListIterator &other) { *this = other; }

	void operator =(const CLnkListIterator &other)
	{
		m_LnkList = other.m_LnkList;
		m_Position = other.m_Position;
		m_Prior = other.m_Prior;
	}

	CSingleLink* operator++();		// get next element

	CLnkList*	 GetList() const	{ return m_LnkList; }
	CSingleLink* GetCurrent() const { return m_Position; }
	void		 Reset() { if(m_LnkList) { m_Position = &m_LnkList->m_Begin; m_Prior = NULL;} }
	CSingleLink* Remove() 
	{ 
		CSingleLink *pRemoved = NULL;
		
		if(m_LnkList && m_Prior && m_Position)
		{
			pRemoved = m_LnkList->RemoveAfter(m_Prior);
			m_Position = m_Prior->GetNext();
			if(m_Position == &m_LnkList->m_End) m_Position = NULL;
		}

		return pRemoved;
	}

	protected:

	CLnkList*	 m_LnkList;			// The list over which we are iterating
	CSingleLink* m_Position;		// Iterator position
	CSingleLink* m_Prior;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\strcnv.cxx ===
//+-----------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       strcnv.cxx
//
//  Contents:   CLMString conversion helpers (these use the current system locale)
//
//  Classes:    none
//
//  Functions:  WideCharToMultiByteSZ
//              MultiByteToWideCharSZ
//
//  History:    ???        benholz        Created
//              09-Sep-97  micahk         Replace code
//
//------------------------------------------------------------------------------
#include "pch.cxx"

//+----------------------------------------------------------------------------
//
//      Function:       WideCharToMultiByteSZ
//
//      Synopsis:       Converts a wide char string to null terminated multibyte string.
//
//      Returns:        number of bytes written to result buffer (excluding terminator)
//              if error, returns 0 - call GetLastError()
//
//      Arguments:  [awcWide]  - [in]  pointer to wide char input buffer (to convert)
//              [cchWide]  - [in]  number ot characters to convert (excluding null
//                                 terminator)
//              [szMulti]  - [out] pointer to target multibyte buffer
//              [cbMulti]  - [in]  number of bytes in target buffer
//
//  Notes:      This function converts with the same semantics as the underlying
//              conversion function, but also null-terminates the output string
//              or returns an appropriate error if it can't.  No assumption is 
//              made about whether or not the wide-char input string is null 
//              terminated or not.
//
//      History:        9/ 6/97 micahk      Create/replace old code
//+----------------------------------------------------------------------------
int WideCharToMultiByteSZ(LPCWSTR awcWide,  int cchWide, 
                          LPSTR   szMulti,  int cbMulti)
{
    int cbConvert;

    // Try the conversion.  WideCharToMultiByte internally handles parameter
    // validation and calls SetLastError as appropriate.
    cbConvert = ::WideCharToMultiByte(CP_ACP, 0, awcWide, cchWide,
        szMulti, cbMulti, NULL, NULL);

    //
    // Attempt to null-terminate the output string.  If they pass 0 bytes for
    // output buffer, then assume that they just want the required buffer size.
    //
    if (0 != cbMulti)
    {
        Assert (NULL != szMulti);

        if (cbConvert < cbMulti)
        {
            // Successful null-terminate
            // This also null terminates the string with length 0 if there
            // was an error in the underlying function
            szMulti[cbConvert] = NULL;
        }
        else
        {
            // Adding the null terminator would overflow the output buffer, so 
            // return an error.
            cbConvert = 0;
            
            // Null terminate anyways
            szMulti[cbMulti-1] = NULL;

            SetLastError (ERROR_INSUFFICIENT_BUFFER);
        }
    }
    return cbConvert;
}

//+----------------------------------------------------------------------------
//
//      Function:       MultiByteToWideCharSZ
//
//      Synopsis:       Converts a multibyte string string to null terminated wide char.
//
//      Returns:        number of characters converted
//              if error, returns 0 - call GetLastError()
//
//      Arguments:  [awcMulti] - [in]  pointer to multibyte input buffer (to convert)
//              [cbMulti]  - [in]  number of bytes to convert (excluding null
//                                 terminator)
//              [szWide]   - [out] pointer to target wide char buffer
//              [cchWide]  - [in]  number of characters in target buffer
//              
//  Notes:      This function converts with the same semantics as the underlying
//              conversion function, but also null-terminates the output string
//              or returns an appropriate error if it can't.  No assumption is 
//              made about whether or not the multibyte input string is null 
//              terminated or not.
//
//      History:        9/ 6/97 micahk      Create/replace old code
//+----------------------------------------------------------------------------
int MultiByteToWideCharSZ(LPCSTR  awcMulti, int cbMulti, 
                          LPWSTR  szWide,   int cchWide)
{
    int cchConvert;

    // Try the conversion.  MultiByteToWideChar internally handles parameter
    // validation and calls SetLastError as appropriate.
    cchConvert = ::MultiByteToWideChar(CP_ACP, 0, awcMulti, cbMulti,
        szWide, cchWide);

    //
    // Attempt to null-terminate the output string.  If they pass 0 bytes for
    // output buffer, then assume that they just want the required buffer size.
    //
    if (0 != cchWide)
    {
        Assert (NULL != szWide);

        if (cchConvert < cchWide)
        {
            // Successful null-terminate
            // This also null terminates the string with length 0 if there
            // was an error in the underlying function
            szWide[cchConvert] = NULL;
        }
        else
        {
            // Adding the null terminator would overflow the output buffer, so 
            // return an error.
            cchConvert = 0;
            
            // Null terminate anyways
            szWide[cchWide-1] = NULL;

            SetLastError (ERROR_INSUFFICIENT_BUFFER);
        }
    }
    return cchConvert;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\strcnv.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       strcnv.h
//
//  Contents:   CLMString conversion helpers (these use the current system locale)
//
//  Classes:    none.
//
//  Functions:  WideCharToMultiByteSZ
//              MultiByteToWideCharSZ
//
//  History:    09-Sep-97  micahk        Created
//
//------------------------------------------------------------------------------

#ifndef __STRCNV_H__
#define __STRCNV_H__

int WideCharToMultiByteSZ(LPCWSTR awcWide,  int cchWide, 
                          LPSTR   szMulti,  int cbMulti);

int MultiByteToWideCharSZ(LPCSTR  awcMulti, int cbMulti, 
                          LPWSTR  szWide,   int cchWide);

#endif // __STRCNV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\syncrdwr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       syncrdwr.h
//
//  Contents:   Contains various syncronization classes
//
//  Classes:    CSyncReadWrite      - reader-write problem solution
//              CSafeFlag           - Thread-safe flag implementation
//
//  Functions:
//
//  History:    11-23-94   SSanu   Created
//
//----------------------------------------------------------------------------

#ifndef _SYNCRDWR_H__
#define _SYNCRDWR_H__

class CSyncReadWrite
{
public:
    void BeginRead();
    void EndRead();
    void BeginWrite();
    void EndWrite();

    LONG GetNumReaders();

    CSyncReadWrite(BOOL fEnsureWrite);
    ~CSyncReadWrite();

private:
//    CRITICAL_SECTION m_csWrite;
	CRITICAL_SECTION m_csRead;
    HANDLE m_hSemWrite;
    HANDLE m_hEventAllowReads;
    LONG   m_lNumReaders;
};

class CSafeFlag
{
public:
    CSafeFlag(BOOL fInitState = 0)
    {
        //make it a manual reset event
        m_event = CreateEvent(0, 1, fInitState, 0);
    }

    ~CSafeFlag()
    {
        CloseHandle (m_event);
    }

    void Set()
    {
        SetEvent(m_event);
    }

    void Reset()
    {
        ResetEvent(m_event);
    }

    BOOL Test()
    {
        return (WAIT_TIMEOUT == WaitForSingleObject (m_event, 0) ? FALSE : TRUE);
    }
private:
    HANDLE m_event;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\tagtbl.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       tagtbl.hxx
//
//  Contents:   Table-driven tag parsing, dispatch and filtering
//
//  History:    25-Apr-97       BobP            Created.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pkmguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CTagEntry::CTagEntry
//
//  Synopsis:   Initialize a tag table entry.  (Compile time!)
//
//                              Compute the PRSPEC_LPWSTR string as required.
//                              Compute the "stop token" flag.
//
//  Arguments:  [pwszTag]     Tag string to recognized (required)
//              [eTokenType]  Identifies handler to dispatch to (required)
//              [pwszParam]   Optional parameter string to match e.g. name=
//              [pwszParam2]  Optional 2nd parameter for handler
//              [pPropset]    Propset for primary FULLPROPSPEC
//              [ulPropid]    If PRSPEC_PROPID, PID for primary FULLPROPSPEC
//              [ulKind]      PRSPEC type indicator
//                              [dt]              Data type
//
//--------------------------------------------------------------------------

CTagEntry::CTagEntry (LPWSTR pwszTag, 
                HtmlTokenType eTokenType,
                LPWSTR pwszParam, 
                LPWSTR pwszParam2, 
                const GUID * pPropset,
                PROPID ulPropId,
                ULONG ulKind,
                TagDataType dt)
: _pwszTag(pwszTag), 
  _eTokenType(eTokenType),
  _pwszParam(pwszParam), 
  _pwszParam2(pwszParam2), 
  _pPropset(pPropset),
  _ulPropId(ulPropId),
  _ulKind(ulKind),
  _pwszPropStr(NULL),
  _pNext(NULL),
  _TagDataType(dt)
{
        // Compute the default PRSPEC_LPWSTR ("TAG.PARAM")

        if ( _ulKind == PRSPEC_LPWSTR )
        {
                int len = wcslen(pwszTag) + 1;
                if (pwszParam != NULL)
                        len += wcslen(pwszParam) + 1;

                Win4Assert( len <= MAX_WCHAR_PROP_STR );

                _pwszPropStr = _awcPropStr;
                wcscpy (_pwszPropStr, pwszTag);

                // If no pwszParam, the tag name alone forms the PRSPEC_LPWSTR ("TAG")

                if (pwszParam != NULL)
                {
                        wcscat (_pwszPropStr, L".");
                        wcscat (_pwszPropStr, pwszParam);
                }
                _wcsupr (_pwszPropStr);
        }

        // Compute stop-token status

        switch (_eTokenType)
        {
        // These must be "stop" tokens because parsing them correctly requires
        // dispatching to a custom scanner loop.
        // 
        case IgnoreToken:               // Must be a stop to actually ignore spanned text
        case CommentToken:              // ... to correctly find the "-->"
        case AspToken:                  // ... to find the "%>"
        case EofToken:                  // Must always be handled
        case HeadToken:
        case ScriptToken:               // script element body is not HTML syntax
        case StyleToken:                // style element body is not HTML syntax
        case HTMLToken:                 // Stop in order to recognize Office 9 XML namespace
        case XMLNamespaceToken: // Stop in order to recognize Office 9 XML namespace
        case XMLOfficeChildLink:
                _fIsStopToken = TRUE;
                break;

        // These can't have handlers and are presumed to have normal syntax

        case GenericToken:              // Normal syntax assumed for any unrecognized tag 
        case BreakToken:                //
                _fIsStopToken = FALSE;
                break;

        // For all filterable tags, it depends on whether or not output is wanted.

        default:
                _fIsStopToken = (pPropset != NULL);
                break;
        }
}

CTagEntry::~CTagEntry (void)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CTagHashTable::Init
//
//  Synopsis:   Fill the tag name to tag entry hash table.
//
//                              Called from DLL per-process init.
//
//                              Given multiple entries for the same tag, chain them together
//                              through PTagEntry->_pNext, NOT through the hash table.
//
//--------------------------------------------------------------------------

void
CTagHashTable::Init (void)
{
        PTagEntry pTE;

        for (pTE = TagEntries; pTE->GetTagName() != NULL; pTE++) {

                // Query hash tbl for entry matching pTE->pwszTag

                PTagEntry pExist;

                if ( Lookup (pTE->GetTagName(), wcslen(pTE->GetTagName()), pExist) )
                {
                        // Table already has an entry for this unique tag name, so link
                        // this entry into the entry already in the table.
                        
                        pExist->AddLink (pTE);
                }
                else
                {
                        // New entry; add to hash table.

                        Add (pTE->GetTagName(), pTE);
                }
        }
}

//+-------------------------------------------------------------------------
//
// Define the table of tags and parameters to parse.
// In alphabetical order for convenience.
//
// There is one specific order dependence:  If two handlers are defined
// for the same tag name, and one filters the tag paramters while the other
// discards it by calling EatTag(), the one that filters it MUST be defined
// before the latter or the tag parameters will be unavailable to it.
//
// The following tag handlers have hardwired FULLPROPSPECS instead of
// or in addition the table entries:
//              <meta name= content=>: has many special cases, see the code
//              <h1>..<h6> and <title>: also emits Storage/PID_STG_CONTENTS chunks
//              <script>: the PRSPEC_LPWSTR is computed
//
// Body text in general is hardwired to Storage/PID_STG_CONTENTS in the code,
// particularly in the handlers that emit multiple copies of text.
//
// Note that a Propset entry is required for all tokens that are filtered,
// even if the handler ignores the Propset in the table, because that
// indicates to the scanner that a tag is a "stop" token.
//
// WORK HERE:  load dynamically
//
//--------------------------------------------------------------------------

#define TAG(str, tok) \
        CTagEntry( L##str, tok)
#define TAGPID(str, tok, propset, pid) \
        CTagEntry( L##str, tok, NULL, NULL, propset, pid, PRSPEC_PROPID)
#define TAGPIDT(str, tok, propset, pid, type) \
        CTagEntry( L##str, tok, NULL, NULL, propset, pid, PRSPEC_PROPID, type)
#define TAGSTR(str, tok, propset) \
        CTagEntry( L##str, tok, NULL, NULL, propset, 0, PRSPEC_LPWSTR)
#define TAGSTRT(str, tok, propset, type) \
        CTagEntry( L##str, tok, NULL, NULL, propset, 0, PRSPEC_LPWSTR, type)
#define PARAMSTR(str, tok, param, propset) \
        CTagEntry( L##str, tok, L##param, NULL, propset, 0, PRSPEC_LPWSTR)
#define PARAM2STR(str, tok, param, param2, propset) \
        CTagEntry( L##str, tok, L##param, L##param2, propset, 0, PRSPEC_LPWSTR)
#define PARAMPID(str, tok, param, propset, pid) \
        CTagEntry( L##str, tok, L##param, NULL, propset, pid, PRSPEC_PROPID)
#define TAGLANG( str, tok ) \
    CTagEntry( L##str, tok, L##"lang" )

CTagEntry TagEntries[] =
{
        TAG( "%", AspToken ),
//      TAGSTR( "%", AspToken, &CLSID_LinkInfo ),       // extracting URLs, later
        TAGPID( "!--", CommentToken, &CLSID_NetLibraryInfo, PID_COMMENT ),
        PARAMSTR( "a", AnchorToken, "href", &CLSID_LinkInfo ),
    TAGLANG( "abbr", AbbrToken ),
        TAG( "address", BreakToken ),
        PARAMSTR( "applet", ParamToken, "code", &CLSID_LinkInfo ),
        PARAMSTR( "applet", ParamToken, "codebase", &CLSID_LinkInfo),
        PARAMSTR( "area", ParamToken, "href", &CLSID_LinkInfo ),
        PARAMSTR( "base", ParamToken, "href", &CLSID_LinkInfo ),
        PARAMSTR( "bgsound", ParamToken, "src", &CLSID_LinkInfo ),
        TAG( "blockquote", BreakToken ),
        PARAMSTR( "body", ParamToken, "background", &CLSID_LinkInfo),
    TAGLANG( "body", BodyToken ),
        TAG( "br", BreakToken ),
        TAG( "dd", BreakToken ),
        TAG( "dl", BreakToken ),
        TAG( "dt", BreakToken ),
    TAGLANG( "em", EmToken ),
        PARAMSTR( "embed", ParamToken, "src", &CLSID_LinkInfo ),
        TAG( "form", BreakToken ),
        PARAMSTR( "frame", ParamToken, "src", &CLSID_LinkInfo ),
        TAG( "head", HeadToken ),       // used in codepage.cxx, not filtered
    // The heading guid constants are still kept in the common directory
    // in case we need the heading to be emmited as properties again
    // The heading tags are taken out to emulate the office filter behavior:
    // heading are not properties in Office and should be emitting as text
    // content versus properties
#if 0
        TAGPID( "h1", Heading1Token, &CLSID_HtmlInformation, PID_HEADING_1 ),
        TAGPID( "h2", Heading2Token, &CLSID_HtmlInformation, PID_HEADING_2 ),
        TAGPID( "h3", Heading3Token, &CLSID_HtmlInformation, PID_HEADING_3 ),
        TAGPID( "h4", Heading4Token, &CLSID_HtmlInformation, PID_HEADING_4 ),
        TAGPID( "h5", Heading5Token, &CLSID_HtmlInformation, PID_HEADING_5 ),
        TAGPID( "h6", Heading6Token, &CLSID_HtmlInformation, PID_HEADING_6 ),
#endif
        PARAMSTR( "img", ParamToken, "alt", &CLSID_HtmlInformation ),
        PARAMSTR( "img", ParamToken, "src", &CLSID_LinkInfo ),
        PARAMSTR( "img", ParamToken, "dynsrc", &CLSID_LinkInfo ),
        PARAMSTR( "img", ParamToken, "usemap", &CLSID_LinkInfo ),
        PARAMSTR( "iframe", ParamToken, "src", &CLSID_LinkInfo ),
        PARAMSTR( "input", ParamToken, "alt", &CLSID_HtmlInformation ),
        PARAMSTR( "input", ParamToken, "src", &CLSID_LinkInfo ),
        TAGPID( "input", InputToken, &guidStoragePropset, PID_STG_CONTENTS ),
        TAG( "li", BreakToken ),
        PARAMSTR( "link", ParamToken, "href", &CLSID_LinkInfo ),
        TAG( "math", BreakToken ),
        TAGSTR( "meta", MetaToken, &PROPSET_MetaInfo ),
        PARAMSTR( "meta", ParamToken, "url", &CLSID_LinkInfo ),
        TAG( "noframes", IgnoreToken ),
        TAG( "rt", IgnoreToken ),
        PARAMSTR( "object", ParamToken, "codebase", &CLSID_LinkInfo ),
        PARAMSTR( "object", ParamToken, "name", &CLSID_LinkInfo ),
        PARAMSTR( "object", ParamToken, "usemap", &CLSID_LinkInfo ),
        TAG( "ol", BreakToken ),
        PARAMSTR( "option", ParamToken, "value", &CLSID_HtmlInformation ),
    TAGLANG( "p", ParagraphToken ),
    //TAG( "p", BreakToken ),
        TAGSTR( "script", ScriptToken, &CLSID_LinkInfo ),
    TAGLANG( "span", SpanToken ),
        TAGSTR( "style", StyleToken, &CLSID_LinkInfo  ),
        PARAMSTR( "table", ParamToken, "background", &CLSID_LinkInfo ),
        PARAMSTR( "td", ParamToken, "background", &CLSID_LinkInfo ),
        PARAMSTR( "th", ParamToken, "background", &CLSID_LinkInfo ),
        TAGPID( "title", TitleToken, &FMTID_SummaryInformation, PIDSI_TITLE ),
        PARAMSTR( "tr", ParamToken, "background", &CLSID_LinkInfo ),
        TAG( "ul", BreakToken ),

        TAG( "!--[if gte mso 9]", XMLToken ),
        TAG( "!--[endif]--", XMLToken ),

        TAG( "html", HTMLToken ),
        TAG( "xml", XMLToken ),
        TAG( "xml:namespace", XMLNamespaceToken ),
        TAG( ":documentproperties", DocPropToken ),
        TAG( ":customdocumentproperties", CustDocPropToken ),

        TAGPID( ":subject", XMLSubjectToken, &FMTID_SummaryInformation, PIDSI_SUBJECT ),
        TAGPID( ":author", XMLAuthorToken, &FMTID_SummaryInformation, PIDSI_AUTHOR ),
        TAGPID( ":keywords", XMLKeywordsToken, &FMTID_SummaryInformation, PIDSI_KEYWORDS ),
        TAGPID( ":description", XMLDescriptionToken, &FMTID_SummaryInformation, PIDSI_COMMENTS ),
        TAGPID( ":lastauthor", XMLLastAuthorToken, &FMTID_SummaryInformation, PIDSI_LASTAUTHOR ),
        TAGPID( ":revision", XMLRevisionToken, &FMTID_SummaryInformation, PIDSI_REVNUMBER ),
        TAGPIDT( ":created", XMLCreatedToken, &FMTID_SummaryInformation, PIDSI_CREATE_DTM, DateTimeISO8601 ),
        TAGPIDT( ":lastsaved", XMLLastSavedToken, &FMTID_SummaryInformation, PIDSI_LASTSAVE_DTM, DateTimeISO8601 ),
        TAGPIDT( ":totaltime", XMLTotalTimeToken, &FMTID_SummaryInformation, PIDSI_EDITTIME, Minutes ),
        TAGPIDT( ":pages", XMLPagesToken, &FMTID_SummaryInformation, PIDSI_PAGECOUNT, Integer ),
        TAGPIDT( ":words", XMLWordsToken, &FMTID_SummaryInformation, PIDSI_WORDCOUNT, Integer ),
        TAGPIDT( ":characters", XMLCharactersToken, &FMTID_SummaryInformation, PIDSI_CHARCOUNT, Integer ),
        TAGPID( ":template", XMLTemplateToken, &FMTID_SummaryInformation, PIDSI_TEMPLATE ),
        TAGPIDT( ":lastprinted", XMLLastPrintedToken, &FMTID_SummaryInformation, PIDSI_LASTPRINTED, DateTimeISO8601 ),

        TAGPIDT( ":category", XMLCategoryToken, &FMTID_DocSummaryInformation, PID_CATEGORY, StringA ),
        TAGPIDT( ":manager", XMLManagerToken, &FMTID_DocSummaryInformation, PID_MANAGER, StringA ),
        TAGPIDT( ":company", XMLCompanyToken, &FMTID_DocSummaryInformation, PID_COMPANY, StringA ),
        TAGPIDT( ":lines", XMLLinesToken, &FMTID_DocSummaryInformation, PID_LINECOUNT, Integer ),
        TAGPIDT( ":paragraphs", XMLParagraphsToken, &FMTID_DocSummaryInformation, PID_PARACOUNT, Integer ),
        TAGPIDT( ":presentationformat", XMLPresentationFormatToken, &FMTID_DocSummaryInformation, PID_PRESENTATIONTARGET, StringA ),
        TAGPIDT( ":bytes", XMLBytesToken, &FMTID_DocSummaryInformation, PID_BYTECOUNT, Integer ),
        TAGPIDT( ":slides", XMLSlidesToken, &FMTID_DocSummaryInformation, PID_SLIDECOUNT, Integer ),
        TAGPIDT( ":notes", XMLNotesToken, &FMTID_DocSummaryInformation, PID_NOTECOUNT, Integer ),
        TAGPIDT( ":hiddenslides", XMLHiddenSlidesToken, &FMTID_DocSummaryInformation, PID_HIDDENCOUNT, Integer ),
        TAGPIDT( ":multimediaclips", XMLMultimediaClipsToken, &FMTID_DocSummaryInformation, PID_MMCLIPS, Integer ),

        TAGSTRT( ":file", XMLOfficeChildLink, &CLSID_LinkInfo, HRef),

        // terminates table
        CTagEntry()
};


CTagHashTable TagHashTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\textelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       textelem.cxx
//
//  Contents:   Parsing algorithm for vanilla text in Html
//
//  Classes:    CTextElement
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pkmguid.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::CTextElement
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CTextElement::CTextElement( CHtmlIFilter& htmlIFilter,
                            CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _fNoMoreText(TRUE),
      _idChunk(0),
      _cTextChars(0)
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

SCODE CTextElement::GetChunk( STAT_CHUNK * pStat )
{
    if ( _serialStream.Eof() )
        {
                // Give state machine the chance to return deferred meta tags

                return SwitchToNextHtmlElement( pStat );
        }

    if ( _fNoMoreText )
    {
        //
        // This is the GetChunk call after FILTER_E_NO_MORE_TEXT is returned.
                //
                // The scanner has already partly-read the next tag so attempt
                // to filter it before reading further input.
        //
                return SwitchToSavedElement( pStat );
    }
    else
    {
        //
        // GetChunk was called even though we had not returned
        // FILTER_E_NO_MORE_TEXT.
        //
        return SkipRemainingTextAndGotoNextChunk( pStat );
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::GetText
//
//  Synopsis:   Retrieves body text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CTextElement::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    Win4Assert( 0 != pcwcOutput );
    Win4Assert( *pcwcOutput > 0 );
    Win4Assert( 0 != awcBuffer );
        
    if ( _fNoMoreText || _serialStream.Eof() )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    ULONG cCharsRead = 0;  // count of chars read from input
    while ( cCharsRead < *pcwcOutput )
    {
        CToken token;
        ULONG cCharsScanned;
        ULONG cCharsNeeded = *pcwcOutput - cCharsRead;

                // scan a block up to cCharsNeeded or to the next token;
                // if the latter then fills in token.

        _scanner.GetBlockOfChars( cCharsNeeded,
                                  awcBuffer + cCharsRead,
                                  cCharsScanned,
                                  token );

        cCharsRead += cCharsScanned;
        if ( cCharsScanned == cCharsNeeded )
        {
            //
            // We've read the #chars requested by the user
                        // (and therefore did not stop in the middle of a tag)
            //
            break;
        }

        HtmlTokenType eTokType = token.GetTokenType();
        if ( eTokType == EofToken || _htmlIFilter.IsStopToken( token ) )
        {
            //
            // End of file, or we've hit an interesting token.
                        // Remember the token that we've halfway-parsed so the next 
                        // GetChunk() call can correctly pick up in the middle of it.
            //
            _fNoMoreText = TRUE;
                        SetToken (token);
            break;
        }
        else if ( BreakToken == eTokType || ParagraphToken == eTokType  )
        {
            //
            // Insert a newline char
            //
            Win4Assert( cCharsRead < *pcwcOutput );
            awcBuffer[cCharsRead++] = L'\n';
            _scanner.EatTag();
        }
        else
        {
            //
            // Skip over uninteresting tag and continue processing
            //
            _scanner.EatTag();
        }
    }

    *pcwcOutput = cCharsRead;

    _cTextChars += cCharsRead;

    if ( _fNoMoreText )
        return FILTER_S_LAST_TEXT;
    else
        return S_OK;
}





//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CTextElement::InitStatChunk( STAT_CHUNK *pStat )
{
    //
    // There is more text to be returned
    //
    _fNoMoreText = FALSE;

    pStat->idChunk = _htmlIFilter.GetNextChunkId();
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetCurrentLocale();
    pStat->attribute.guidPropSet = guidStoragePropset;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_EOS;
    pStat->idChunkSource = pStat->idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    _idChunk = pStat->idChunk;
    _cTextChars = 0;

        return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextElement::InitFilterRegion
//
//  Synopsis:   Initializes the filter region corresponding to this chunk
//
//  Arguments:  [idChunkSource]  -- Id of source chunk
//              [cwcStartSource] -- Offset of source text in chunk
//              [cwcLenSource]   -- Length of source text in chunk
//
//--------------------------------------------------------------------------

void CTextElement::InitFilterRegion( ULONG& idChunkSource,
                                     ULONG& cwcStartSource,
                                     ULONG& cwcLenSource )
{
    idChunkSource = _idChunk;
    cwcStartSource = 0;
    cwcLenSource = _cTextChars;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\tpagepool.h ===
//+-----------------------------------------------
//
//	Microsoft (R) Site Server Search
//	Copyright (C) Microsoft Corporation, 1996-1997.
//
//	File:	tsharedpool.h
//
//	Contents:	Shared Pool allows multiple objects with same size share the same pool
//				this is benefitial when the relative number of instances of each
//				class is small, but number of different classes with same Shared is large
//				this is true for small templated classes.
//
//	Classes:	
//
//	History:	11/17/97	dmitriym	Created
//
//+-----------------------------------------------

#ifndef __TSHAREDPOOL_H
#define __TSHAREDPOOL_H

#include "tslklist.h"
#include "semcls.h"
#include "cpool.h"

#ifndef NO_PAGE_POOLED_MEMORY

class CSharedPool: public CPool, public CSingleLink
{
	public:
	CSharedPool() {}
	~CSharedPool() {}
};

class CSharedPools
{
	public:
	CSharedPools() {}
	~CSharedPools()
	{
		CPool *pPool;
		while((pPool = m_Pools.RemoveFirst()) != NULL)
		{
			delete pPool;
		}
	}

	CSharedPool *GetSharedPool(size_t s)
	{
		s = (s + 7) & (~7);	//round up to 16 bytes

		CCriticalResource lock(m_PoolsAccess);

		CTLnkListIterator<CSharedPool> next(m_Pools);

		CSharedPool *pPool;
		while((pPool = ++next) != NULL)
		{
			if(pPool->GetInstanceSize() == s) break;
		}

		if(pPool) return pPool;

		pPool = new CSharedPool;
		if(pPool)
		{
			HRESULT hr = pPool->Init(s);
			if(FAILED(hr))
			{
				throw CException(hr);
			}

			m_Pools.Append(pPool);
		}

		return pPool;
	}

	void ReleaseMemory()
	{
		CCriticalResource lock(m_PoolsAccess);

		CTLnkListIterator<CSharedPool> next(m_Pools);

		CSharedPool *pPool;
		while((pPool = ++next) != NULL)
		{
			pPool->ReleaseMemory();
		}
	}

	static CSharedPools SharedPools;

	private:

	CriticalSection m_PoolsAccess;
	CTLnkList<CSharedPool> m_Pools;
};

//
// TMemPooled
//
// base class for all objects that want to use TPagedPool allocator
//

template <class T> class TPagedMemPooled
{
	protected:
	TPagedMemPooled() {}
	~TPagedMemPooled() {}

	public:
	void *operator new(size_t s) 
	{ 
		ASSERT(s == sizeof(T));

		return GetPool()->Alloc(); 
	}

	void operator delete(void *pInstance) 
	{ 
		GetPool()->Free(pInstance); 
	}

	protected:
	static CSharedPool *GetPool()
	{
		static CSharedPool *pPool;

		if(pPool) return pPool;

		//if two threads come here, the GetSharedPool will return the same pointer twice,
		//nothing bad should happen, we will remember it, and won't bother shared pools again
		pPool = CSharedPools::SharedPools.GetSharedPool(sizeof(T));

		return pPool;
	}
};

#else  // NO_PAGE_POOLED_MEMORY

//
// Define dummy classes instead of the real page pool classes.  Pooling can
//  be turned off so that the code works on win95 (a-bmk)
//
class CSharedPool {};
class CSharedPools {};
template <class T> class TPagedMemPooled {};

#endif  // NO_PAGE_POOLED_MEMORY


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\titletag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999 
//
//  File:       titletag.cxx
//
//  Contents:   Parsing algorithm for title tag in Html
//
//				Subclassed from CPropertyText, so as to emit a third copy
//				of the chunk text as a VALUE chunk, but otherwise as
//				per the tag table entry.  See comment in proptag.cxx.
//
//  Classes:    CTitleTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::CTitleTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]  -- Reference to Html filter
//              [serialStream] -- Reference to input stream
//
//--------------------------------------------------------------------------

CTitleTag::CTitleTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream )
    : CPropertyTag(htmlIFilter, serialStream)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CTitleTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//  History:    09-27-1999  KitmanH     Property value is filtered here, 
//                                      instead of relying on GetText
//
//--------------------------------------------------------------------------

SCODE CTitleTag::GetValue( VARIANT **ppPropValue )
{
    switch (_eState)
    {
    case FilteringValueProperty:
    {
        SCODE sc = CPropertyTag::ReadProperty();
        if ( SUCCEEDED(sc) )
        {
            PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
            if ( pPropVar == 0 )
                return E_OUTOFMEMORY;

            pPropVar->vt = VT_LPWSTR;
            int cb = ( _cPropChars ) * sizeof( WCHAR );
            pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( cb );

            if ( pPropVar->pwszVal == 0 )
            {
                CoTaskMemFree( (void *) pPropVar );
                return E_OUTOFMEMORY;
            }

            RtlCopyMemory( pPropVar->pwszVal, _xPropBuf.Get(), cb );

            *ppPropValue = pPropVar;

            // reset buffer
            _cPropChars = 0;

            _eState = NoMoreValueProperty;
            return FILTER_S_LAST_VALUES;
        }
        else
            return sc;
    }

    case NoMoreValueProperty:
        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CTitleTag::GetValue, unknown value of _eState: %d\n",
                       _eState ));
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\clidrun.h ===
#ifndef _CLIDRUN_INCLUDED_
#define _CLIDRUN_INCLUDED_

#include "dmfltinc.h"
#include "dmifstrm.hpp"

#define WHITE_SPACE_BUFFER_SIZE 2

class CWord8Stream;
class CWord6Stream;

class CLidRun
{
public:
	typedef ULONG FC;

    FC m_fcStart;
    FC m_fcEnd;
    WORD m_lid;

    CLidRun * m_pPrev;
    CLidRun * m_pNext;

    CLidRun(){};
    CLidRun(FC fcStart, FC fcEnd, WORD lid, CLidRun * pPrev, CLidRun * pNext)
    {
        m_fcStart = fcStart;
        m_fcEnd = fcEnd;
        m_lid = lid;
        m_pPrev = pPrev;
        m_pNext = pNext;
    };

    ~CLidRun()
    {
    };

    BOOL IsWhiteSpace(CWord6Stream * pWordStream);
    void Reduce(CWord6Stream * pWordStream);
    HRESULT Add(WORD lid, FC fcStart, FC fcEnd);
    void Reduce();
    BOOL EqualLid(WORD lid1, WORD lid2);
};

class CLidRun8
{
public:
	typedef ULONG FC;

    FC m_fcStart;
    FC m_fcEnd;
    WORD m_lid;
    WORD m_lidFE;
    WORD m_bUseFE;
	WORD m_lidBi;
	WORD m_bUseBi;

    CLidRun8 * m_pPrev;
    CLidRun8 * m_pNext;

    CLidRun8(){};
    CLidRun8(FC fcStart, FC fcEnd, WORD lid, WORD lidFE, WORD bUseFE, CLidRun8 * pPrev, CLidRun8 * pNext,
		WORD lidBi, WORD bUseBi)
    {
        m_fcStart = fcStart;
        m_fcEnd = fcEnd;
        
        m_lid = lid;
        m_lidFE = lidFE;
        m_bUseFE = bUseFE;

		m_lidBi = lidBi;
		m_bUseBi = bUseBi;
        
        m_pPrev = pPrev;
        m_pNext = pNext;
    };

    ~CLidRun8()
    {
    };

    BOOL EqualLid(WORD lid1, WORD lid2);
    BOOL Equal(CLidRun8 * pElem, BOOL fIgnoreBi = FALSE);
    BOOL IsWhiteSpace(CWord8Stream * pWordStream);
    void Reduce(CWord8Stream * pWordStream,  BOOL fIgnoreBi = FALSE);
	void TransformBi(void);
    HRESULT Add(WORD lid, WORD lidFE, WORD bUseFE, FC fcStart, FC fcEnd, WORD lidBi, WORD bUseBi);
};

void DeleteAll6(CLidRun * pElem);
void DeleteAll(CLidRun8 *);
BOOL FBidiLid(WORD lid);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\clidrun.cpp ===
#include "clidrun.h"
#include "dmiwd8st.hpp"
#include "dmiwd6st.hpp"

BOOL CLidRun::EqualLid(WORD lid1, WORD lid2)
{
    if( (lid1 == lid2) ||
        (lid1 == 0x400)||
        (lid2 == 0x400)||
        (lid1 == 0)||
        (lid2 == 0))
        return TRUE;
    else
        return FALSE;
}

BOOL CLidRun::IsWhiteSpace(CWord6Stream * pStr)
{
#if(1)
   char chBuff[WHITE_SPACE_BUFFER_SIZE];
   int nCnt = m_fcEnd - m_fcStart;

   if(nCnt <= WHITE_SPACE_BUFFER_SIZE)
   {
       HRESULT hr = pStr->SeekAndRead (m_fcStart, STREAM_SEEK_SET, chBuff, nCnt);
       if(hr)
           return FALSE;
       
       for(int i = 0; i < nCnt; i++)
       {
           if(!(chBuff[i] == 0x0 || chBuff[i] == 0x20 || chBuff[i] == 0xd))
               return FALSE;
       }
       return TRUE;
   }
   else
       return FALSE;
#else
   return FALSE;
#endif
}

void CLidRun::Reduce(CWord6Stream * pWordStream)
{
    CLidRun * pElem = this;
    while(pElem->m_pNext)
    {
        if(pElem->m_pNext->m_fcStart == pElem->m_fcEnd &&
           ((pElem->m_pNext->m_lid == pElem->m_lid) ||
           (pElem->m_pNext->m_lid == 0x400) ||
           (pElem->m_lid == 0x400) ||
           pElem->m_pNext->IsWhiteSpace(pWordStream)))
        {
            CLidRun * pTempNext = pElem->m_pNext->m_pNext;
            pElem->m_fcEnd = pElem->m_pNext->m_fcEnd;
            
            if(pElem->m_lid == 0x400)
                pElem->m_lid = pElem->m_pNext->m_lid;

            if(pElem->m_pNext->m_pNext)
                pElem->m_pNext->m_pNext->m_pPrev = pElem;

            pElem->m_pNext->m_pNext = 0;
            DeleteAll6(pElem->m_pNext);
            pElem->m_pNext = pTempNext;
        }
        else
        {
            pElem = pElem->m_pNext;
        }
    }
}

HRESULT CLidRun::Add(WORD lid, FC fcStart, FC fcEnd)
{
    HRESULT hr = S_OK;

    // all elements in the list are in accending order
    // find element containing fcStart
    CLidRun * pFirst = this;
    do
    {
        if(pFirst->m_fcStart <= fcStart && fcStart < pFirst->m_fcEnd)
            break;
        else
        {
            if(pFirst->m_pNext)
                pFirst = pFirst->m_pNext;
            else
            {
                // we are at the end of the table and
                // still didn't find a match - something wrong
                return E_FAIL;
            }
        }
    }while(pFirst->m_pNext);

    CLidRun * pLast = pFirst;

    // find element containing fcEnd
    do
    {
        if(pLast->m_fcStart <= fcEnd && fcEnd < pLast->m_fcEnd)
            break;
        else
        {
            if(pLast->m_pNext)
                pLast = pLast->m_pNext;
            else
            {
                // we are at the end of the table and
                // still didn't find a match - something wrong
                return E_FAIL;
            }
        }
    }while(pLast->m_pNext);

    if(pFirst != pLast)
    {
        // we have pFirst, pLast, delete anything in between, including pLast
    
        FC fcEndTemp = pLast->m_fcEnd;
        CLidRun * pTemp = pLast->m_pNext;
        WORD TempLid = pLast->m_lid;
    
        // this will stop destruction on the last one
        pLast->m_pNext = NULL;
    
        if(pFirst->m_pNext)
            DeleteAll6(pFirst->m_pNext);

        // replace pFirst with 3 (or less) elements:

        // pFirst->m_fcStart to fcStart with pFirst->m_lid
        // fcStart to fcEnd with lid
        // fcEnd to pFirst->m_fcEnd with TempLid

        if(pFirst->m_fcStart != fcStart)
        {
            pFirst->m_fcEnd = fcStart;
            pFirst->m_pNext = new CLidRun(pFirst->m_fcEnd, fcEnd, lid, pFirst, NULL);
			if(pFirst->m_pNext == NULL)
			{
				// Let's link pTemp with pFirst
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            pFirst = pFirst->m_pNext;
        }
        else
        {
            pFirst->m_fcEnd = fcEnd;
            pFirst->m_lid = lid;
        }

        if(pFirst->m_fcEnd != fcEndTemp)
        {
            pFirst->m_pNext = 
                new CLidRun(pFirst->m_fcEnd, fcEndTemp, TempLid, pFirst, pTemp);
			if(pFirst->m_pNext == NULL)
			{
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
        else
        {
            pFirst->m_pNext = pTemp;
            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
    }
    else
    {
       // new element goes in the middle of the existing one

       // check if previous element has the same properties, maybe we just 
       // can move its border, saves a lot of time and memory
       if(pFirst->m_pPrev)
       {
          if(pFirst->m_pPrev->m_fcEnd == fcStart && 
             EqualLid(pFirst->m_pPrev->m_lid, lid))
          {
             pFirst->m_pPrev->m_fcEnd = fcEnd;
             pFirst->m_fcStart = fcEnd;
             return S_OK;
          }
       }

       if(EqualLid(pFirst->m_lid, lid))
       {
          return S_OK;
       }
        
        FC fcEndTemp = pLast->m_fcEnd;
        CLidRun * pTemp = pLast->m_pNext;
        WORD TempLid = pLast->m_lid;

        if(pFirst->m_fcStart != fcStart)
        {
            pFirst->m_fcEnd = fcStart;
            pFirst->m_pNext = new CLidRun(pFirst->m_fcEnd, fcEnd, lid, pFirst, NULL);
			if(pFirst->m_pNext == NULL)
			{
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            pFirst = pFirst->m_pNext;
        }
        else
        {
            pFirst->m_fcEnd = fcEnd;
            pFirst->m_lid = lid;
        }

        if(pFirst->m_fcEnd != fcEndTemp)
        {
            pFirst->m_pNext = 
                new CLidRun(pFirst->m_fcEnd, fcEndTemp, TempLid, pFirst, pTemp);
			if(pFirst->m_pNext == NULL)
			{
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
        else
        {
            pFirst->m_pNext = pTemp;
            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
    }
    return hr;
}

void DeleteAll(CLidRun8 * pElem);

BOOL CLidRun8::EqualLid(WORD lid1, WORD lid2)
{
    if( (lid1 == lid2) ||
        (lid1 == 0x400)||
        (lid2 == 0x400)||
        (lid1 == 0)||
        (lid2 == 0))
        return TRUE;
    else
        return FALSE;
}

BOOL CLidRun8::Equal(CLidRun8 * pElem, BOOL fIgnoreBi)
{
    if(EqualLid(m_lid, pElem->m_lid) && 
        EqualLid(m_lidFE, pElem->m_lidFE) && m_bUseFE == pElem->m_bUseFE &&
		((EqualLid(m_lidBi, pElem->m_lidBi) && m_bUseBi == pElem->m_bUseBi) || fIgnoreBi))
        return TRUE;
    else
        return FALSE;
}

BOOL CLidRun8::IsWhiteSpace(CWord8Stream * pWordStream)
{
#if(1)
   char chBuff[WHITE_SPACE_BUFFER_SIZE];
   int nCnt = m_fcEnd - m_fcStart;

   if(nCnt <= WHITE_SPACE_BUFFER_SIZE)
   {
       HRESULT hr = pWordStream->SeekAndRead (m_fcStart, STREAM_SEEK_SET, chBuff, 
            nCnt, pWordStream->m_pStmMain);
       
       if(hr)
           return FALSE;
       
       for(int i = 0; i < nCnt; i++)
       {
           if(!(chBuff[i] == 0x0 || chBuff[i] == 0x20))
               return FALSE;
       }
       return TRUE;
   }
   else
       return FALSE;
#else
   return FALSE;
#endif
}

void CLidRun8::Reduce(CWord8Stream * pWordStream, BOOL fIgnoreBi)
{
    CLidRun8 * pElem = this;
    while(pElem->m_pNext)
    {
        if(pElem->m_pNext->m_fcStart == pElem->m_fcEnd && 
           (pElem->Equal(pElem->m_pNext, fIgnoreBi) || pElem->m_pNext->IsWhiteSpace(pWordStream)))
        {
            CLidRun8 * pTempNext = pElem->m_pNext->m_pNext;
            pElem->m_fcEnd = pElem->m_pNext->m_fcEnd;
            
            if(pElem->m_lid == 0x400)
                pElem->m_lid = pElem->m_pNext->m_lid;
            if(pElem->m_lidFE == 0x400)
                pElem->m_lidFE = pElem->m_pNext->m_lidFE;
			if (!fIgnoreBi && pElem->m_lidBi == 0)
				pElem->m_lidBi = pElem->m_pNext->m_lidBi;

            if(pElem->m_pNext->m_pNext)
                pElem->m_pNext->m_pNext->m_pPrev = pElem;

            pElem->m_pNext->m_pNext = 0;
            DeleteAll( pElem->m_pNext);
            pElem->m_pNext = pTempNext;
        }
        else
        {
            pElem = pElem->m_pNext;
        }
    }
}

void CLidRun8::TransformBi()
{
    CLidRun8 * pElem = this;
    while(pElem)
    {
        if (pElem->m_bUseBi && FBidiLid(pElem->m_lidBi))
		{
			if (!FBidiLid(pElem->m_lid))
				pElem->m_lid = pElem->m_lidBi;
			pElem->m_bUseFE = FALSE;
		}
		pElem = pElem->m_pNext;
    }
}

HRESULT CLidRun8::Add(WORD lid, WORD lidFE, WORD bUseFE, FC fcStart, FC fcEnd, WORD lidBi, WORD bUseBi)
{
    HRESULT hr = S_OK;

    // all elements in the list are in accending order
    // find element containing fcStart
    CLidRun8 * pFirst = this;
    do
    {
        if(pFirst->m_fcStart <= fcStart && fcStart < pFirst->m_fcEnd)
            break;
        else
        {
            if(pFirst->m_pNext)
                pFirst = pFirst->m_pNext;
            else
            {
                // we are at the end of the table and
                // still didn't find a match - something wrong
                return E_FAIL;
            }
        }
    }while(pFirst->m_pNext);

    CLidRun8 * pLast = pFirst;

    // find element containing fcEnd
    do
    {
        if(pLast->m_fcStart <= fcEnd && fcEnd < pLast->m_fcEnd)
            break;
        else
        {
            if(pLast->m_pNext)
                pLast = pLast->m_pNext;
            else
            {
                // we are at the end of the table and
                // still didn't find a match - something wrong
                return E_FAIL;
            }
        }
    }while(pLast->m_pNext);

    if(pFirst != pLast)
    {
        // we have pFirst, pLast, delete anything in between, including pLast
    
        FC fcEndTemp = pLast->m_fcEnd;
        CLidRun8 * pTemp = pLast->m_pNext;
        
        WORD TempLid = pLast->m_lid;
        WORD TempLidFE = pLast->m_lidFE;
        WORD TempUseFE = pLast->m_bUseFE;
		WORD TempLidBi = pLast->m_lidBi;
		WORD TempUseBi = pLast->m_bUseBi;
    
        // this will stop destruction on the last one
        pLast->m_pNext = NULL;
    
        if(pFirst->m_pNext)
            DeleteAll(pFirst->m_pNext);

        // replace pFirst with 3 (or less) elements:

        // pFirst->m_fcStart to fcStart with pFirst->m_lid
        // fcStart to fcEnd with lid
        // fcEnd to pFirst->m_fcEnd with TempLid

        if(!lid)
        {
            // Use existing lid
            lid = pFirst->m_lid;
        }
        if(!lidFE)
        {
            // Use existing lidFE
            lidFE = pFirst->m_lidFE;
        }
		if (!lidBi)
		{
			// Use existing lidBi
			lidBi = pFirst->m_lidBi;
		}

        if(pFirst->m_fcStart != fcStart)
        {
            pFirst->m_fcEnd = fcStart;
            pFirst->m_pNext = new CLidRun8(pFirst->m_fcEnd, fcEnd, lid, lidFE, bUseFE, pFirst, NULL, lidBi, bUseBi);
			if(pFirst->m_pNext == NULL)
			{
				// Let's link pTemp to pFirst
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            pFirst = pFirst->m_pNext;
        }
        else
        {
            pFirst->m_fcEnd = fcEnd;
            pFirst->m_lid = lid;
            pFirst->m_lidFE = lidFE;
            pFirst->m_bUseFE = bUseFE;
			pFirst->m_lidBi = lidBi;
			pFirst->m_bUseBi = bUseBi;
        }

        if(pFirst->m_fcEnd != fcEndTemp)
        {
            pFirst->m_pNext = 
                new CLidRun8(pFirst->m_fcEnd, fcEndTemp, TempLid, TempLidFE, TempUseFE, pFirst, pTemp,
								TempLidBi, TempUseBi);
			if(pFirst->m_pNext == NULL)
			{
				// Let's link pTemp to pFirst
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
        else
        {
            pFirst->m_pNext = pTemp;
            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
    }
    else
    {
       // new element goes in the middle of the existing one

		if (!lidBi)
		{
			// Use existing lidBi
			lidBi = pFirst->m_lidBi;
		}

       // check if previous element has the same properties, maybe we just 
       // can move its border, saves a lot of time and memory
       if(pFirst->m_pPrev)
       {
          if(pFirst->m_pPrev->m_fcEnd == fcStart && 
             EqualLid(pFirst->m_pPrev->m_lid, lid) && 
             EqualLid(pFirst->m_pPrev->m_lidFE, lidFE) && 
              (pFirst->m_pPrev->m_bUseFE == bUseFE ) &&
			 (lidBi == 0 || pFirst->m_pPrev->m_lidBi == lidBi) &&
			  (pFirst->m_pPrev->m_bUseBi == bUseBi))
          {
             pFirst->m_pPrev->m_fcEnd = fcEnd;
             pFirst->m_fcStart = fcEnd;
             return S_OK;
          }
       }

       // check if the new elment we are about to insert
       // has the same properties as the existing one

       if(EqualLid(pFirst->m_lid, lid) &&
          EqualLid(pFirst->m_lidFE, lidFE) && 
           (pFirst->m_bUseFE == bUseFE) &&
		  (lidBi == 0 || pFirst->m_lidBi == lidBi) &&
		   (pFirst->m_bUseBi == bUseBi))
       {
          return S_OK;
       }

        FC fcEndTemp = pLast->m_fcEnd;
        CLidRun8 * pTemp = pLast->m_pNext;
     
        WORD TempLid = pLast->m_lid;
        WORD TempLidFE = pLast->m_lidFE;
        WORD TempUseFE = pLast->m_bUseFE;
		WORD TempLidBi = pLast->m_lidBi;
		WORD TempUseBi = pLast->m_bUseBi;

        if(!lid)
        {
            // Use existing lid
            lid = pFirst->m_lid;
        }
        
        if(!lidFE)
        {
            // Use existing lidFE
            lidFE = pFirst->m_lidFE;
        }
		
        if(pFirst->m_fcStart != fcStart)
        {
            pFirst->m_fcEnd = fcStart;
            pFirst->m_pNext = new CLidRun8(pFirst->m_fcEnd, fcEnd, lid, lidFE, bUseFE, pFirst, NULL, lidBi, bUseBi);
			if(pFirst->m_pNext == NULL)
			{
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            pFirst = pFirst->m_pNext;
        }
        else
        {
            pFirst->m_fcEnd = fcEnd;
            pFirst->m_lid = lid;
            pFirst->m_lidFE = lidFE;
            pFirst->m_bUseFE = bUseFE;
			pFirst->m_lidBi = lidBi;
			pFirst->m_bUseBi = bUseBi;
        }

        if(pFirst->m_fcEnd != fcEndTemp)
        {
            pFirst->m_pNext = 
                new CLidRun8(pFirst->m_fcEnd, fcEndTemp, TempLid, TempLidFE, TempUseFE, pFirst, pTemp,
								TempLidBi, TempUseBi);
			if(pFirst->m_pNext == NULL)
			{
				pFirst->m_pNext = pTemp;
				return E_OUTOFMEMORY;
			}

            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
        else
        {
            pFirst->m_pNext = pTemp;
            if(pTemp)
                pTemp->m_pPrev = pFirst;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\xmltag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       XMLtag.cxx
//
//  Contents:   Parsing algorithm for XML tag in HTML
//
//              Subclassed from CPropertyText, so as to emit a third copy
//              of the chunk text as a VALUE chunk, but otherwise as
//              per the tag table entry.  See comment in proptag.cxx.
//
//  Classes:    CXMLTag
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pkmguid.hxx>
#include <malloc.h>

//+-------------------------------------------------------------------------
//
//  Method:     CXMLTag::CXMLTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]  -- Reference to Html filter
//              [serialStream] -- Reference to input stream
//
//--------------------------------------------------------------------------

CXMLTag::CXMLTag( CHtmlIFilter& htmlIFilter,
                      CSerialStream& serialStream )
    : CPropertyTag(htmlIFilter, serialStream),
          _fSeenOffice9DocPropNamespace(false),
          _fSeenOffice9CustDocPropNamespace(false),
          _PropState(NotInOffice9Prop),
          _TagDataType(String)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CXMLTag::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//  History:    09-27-1999  KitmanH     Property value is filtered here,
//                                      instead of relying on GetText
//
//--------------------------------------------------------------------------

SCODE CXMLTag::GetValue( VARIANT **ppPropValue )
{
    switch ( _eState )
    {
    case FilteringValueProperty:
    {
        SCODE sc = CPropertyTag::ReadProperty();

        if ( SUCCEEDED(sc) )
        {

            PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
            if ( pPropVar == 0 )
                return E_OUTOFMEMORY;

            int cb = 0;

            // Set to appropriate type and do type conversion
            TagDataType dt = GetTagEntry() ? GetTagEntry()->GetTagDataType() : _TagDataType;
            switch(dt)
            {
            case String:

                pPropVar->vt = VT_LPWSTR;
                cb = ( _cPropChars + 1 ) * sizeof( WCHAR );
                pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( cb );

                if ( pPropVar->pwszVal == 0 )
                {
                    CoTaskMemFree( (void *) pPropVar );
                    return E_OUTOFMEMORY;
                }

                RtlCopyMemory( pPropVar->pwszVal, _xPropBuf.Get(), cb - sizeof(WCHAR));
                pPropVar->pwszVal[_cPropChars] = L'\0';

                break;

            case StringA:
            {
                pPropVar->vt = VT_LPSTR;
                int cwcPropBuf = _cPropChars;
                int cch = ( cwcPropBuf + 1 ) * 3; // Allow space for expanding conversion
                pPropVar->pszVal = (CHAR *) CoTaskMemAlloc(cch);

                if ( pPropVar->pszVal == 0 )
                {
                    CoTaskMemFree( (void *) pPropVar );
                    return E_OUTOFMEMORY;
                }

                int cchMultiByte = 0;
                if(cwcPropBuf)
                {
                    if(!(cchMultiByte = WideCharToMultiByte(_htmlIFilter.GetCodePage(), 0, _xPropBuf.Get(), cwcPropBuf, pPropVar->pszVal, cch, 0, 0)))
                    {
                        CoTaskMemFree( (void *) pPropVar->pszVal );
                        CoTaskMemFree( (void *) pPropVar );
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                pPropVar->pszVal[cchMultiByte] = '\0';
            }

            break;

            case Boolean:

                pPropVar->vt = VT_BOOL;
                pPropVar->boolVal = _wtoi(_xPropBuf.Get()) ? VARIANT_TRUE : VARIANT_FALSE;

                break;

            case Number:

            {
                pPropVar->vt = VT_R8;
                VarR8FromStr(_xPropBuf.Get(), _htmlIFilter.GetCurrentLocale(), 0, &(pPropVar->dblVal));
            }

            break;

            case DateISO8601:

            {
                SYSTEMTIME st;
                GetSystemTime(&st);
                ParseDateISO8601ToSystemTime(_xPropBuf.Get(), &st);

                pPropVar->vt = VT_FILETIME;
                SystemTimeToFileTime(&st, &pPropVar->filetime);
            }

            break;

            case DateTimeISO8601:

            {
                SYSTEMTIME st;
                GetSystemTime(&st);
                ParseDateTimeISO8601ToSystemTime(_xPropBuf.Get(), &st);

                pPropVar->vt = VT_FILETIME;
                SystemTimeToFileTime(&st, &pPropVar->filetime);
            }

            break;

            case Integer:

            {
                pPropVar->vt = VT_I4;
                pPropVar->lVal = _wtol(_xPropBuf.Get());
            }

            break;

            case Minutes:

            {
                long l = _wtol(_xPropBuf.Get());
                LARGE_INTEGER li;
                li.QuadPart = l * 60 * 1000;
                pPropVar->vt = VT_FILETIME;
                pPropVar->filetime.dwLowDateTime = (DWORD)li.LowPart;
                pPropVar->filetime.dwHighDateTime = (DWORD)li.HighPart;
            }

            break;

            case HRef:

                pPropVar->vt = VT_LPWSTR;
                cb = ( _csHRef.GetLength() + 1 ) * sizeof( WCHAR );
                pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( cb );

                if ( pPropVar->pwszVal == 0 )
                {
                    CoTaskMemFree( (void *) pPropVar );
                    return E_OUTOFMEMORY;
                }

                RtlCopyMemory( pPropVar->pwszVal, _csHRef.GetBuffer(), cb );

                break;

            default:

                Win4Assert( !"Unknown data type" );
                htmlDebugOut(( DEB_ERROR,
                               "CXMLTag::GetValue, unknown data type: %d\n",
                               dt ));
                return E_FAIL;
            }

            *ppPropValue = pPropVar;

            _cPropChars = 0;
            _eState = NoMoreValueProperty;
            return FILTER_S_LAST_VALUES;

        }
        else
            return sc;
    }

    case NoMoreValueProperty:
        return FILTER_E_NO_MORE_VALUES;

    default:
        Win4Assert( !"Unknown value of _eState" );
        htmlDebugOut(( DEB_ERROR,
                       "CXMLTag::GetValue, unknown value of _eState: %d\n",
                       _eState ));
        return E_FAIL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CXMLTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK as part of a GetChunk call
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//  Returns:    TRUE if a chunk is emitted, FLASE otherwise
//
//  History:    09-27-1999  KitmanH     only emit as a value chunk
//              01-14-2000  KitmanH     HREF chunks are emitted with
//                                      LOCALE_NEUTRAL
//
//--------------------------------------------------------------------------

BOOL CXMLTag::InitStatChunk( STAT_CHUNK *pStat )
{
        BOOL fHasData = FALSE;
        SmallString csDataTypeTag;

        switch(GetTokenType())
        {
        case HTMLToken:
        case XMLToken:
        {
            // <html xmlns:[prefix]="..." ....>
            // Hard code Office 9 namespace recognition
            // No data to return

            _scanner.ReadTagIntoBuffer();
            if(IsStartToken() == FALSE)
            {
                return FALSE;
            }

            WCHAR *pwcNameSpace;
            unsigned cwcNameSpace;
            WCHAR *pwcPrefix;
            unsigned cwcPrefix;

            int iPos = 0;
            _scanner.ScanTagBufferEx(L"xmlns", pwcNameSpace, cwcNameSpace, pwcPrefix, cwcPrefix, iPos);
            while(pwcNameSpace)
            {
                // Set flags according to namespace
                if(cwcNameSpace && !_wcsnicmp(L"urn:schemas-microsoft-com:office:office", pwcNameSpace, cwcNameSpace))
                {
                    _fSeenOffice9DocPropNamespace = true;
                    _scanner.SetOffice9PropPrefix( pwcPrefix, cwcPrefix );
                }

                if(cwcNameSpace && !_wcsnicmp(L"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882", pwcNameSpace, cwcNameSpace))
                {
                    _fSeenOffice9CustDocPropNamespace= true;
                    memcpy(_csDataTypePrefix.GetBuffer(cwcPrefix + 1), pwcPrefix, cwcPrefix * sizeof(WCHAR));
                    _csDataTypePrefix.Truncate(cwcPrefix);
                }

                ++iPos;
                _scanner.ScanTagBufferEx(L"xmlns", pwcNameSpace, cwcNameSpace, pwcPrefix, cwcPrefix, iPos);
            }

            return FALSE;
        }

        case XMLNamespaceToken:

                {
                // XML namespace
                // Hard code Office 9 namespace recognition
                // No data to return

            _scanner.ReadTagIntoBuffer();
                if(IsStartToken() == FALSE)
                {
                        return FALSE;
                }

                WCHAR *pwcNameSpace;
                unsigned cwcNameSpace;
                WCHAR *pwcPrefix;
                unsigned cwcPrefix;

                // Scan for namespace ("ns=...")
            _scanner.ScanTagBuffer(L"ns", pwcNameSpace, cwcNameSpace);

                // Scan for prefix
                _scanner.ScanTagBuffer(L"prefix", pwcPrefix, cwcPrefix);

                // Set flags according to namespace
                if(cwcNameSpace && !_wcsnicmp(L"urn:schemas-microsoft-com:office:office", pwcNameSpace, cwcNameSpace))
                {
                        _fSeenOffice9DocPropNamespace = true;
                        _scanner.SetOffice9PropPrefix( pwcPrefix, cwcPrefix );
                }
                if(cwcNameSpace && !_wcsnicmp(L"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882", pwcNameSpace, cwcNameSpace))
                {
                        _fSeenOffice9CustDocPropNamespace= true;
                        memcpy(_csDataTypePrefix.GetBuffer(cwcPrefix + 1), pwcPrefix, cwcPrefix * sizeof(WCHAR));
                        _csDataTypePrefix.Truncate(cwcPrefix);
                }

                return FALSE;
                }

        case DocPropToken:

                // Start of Office 9 document properties
                // Set state for parsing Office 9 document properties

                if(_fSeenOffice9DocPropNamespace)
                {
                        _PropState = IsStartToken() ? AcceptOffice9Prop : NotInOffice9Prop;
                }
                else
                {
                        _PropState = IsStartToken() ? IgnoreOffice9Prop : NotInOffice9Prop;
                }

                _scanner.EatTag();
                return FALSE;

        case CustDocPropToken:

                // Start of Office 9 custom document properties
                // Set state for parsing Office 9 custom document properties

                if(_fSeenOffice9DocPropNamespace && _fSeenOffice9CustDocPropNamespace)
                {
                        _PropState = IsStartToken() ? AcceptCustOffice9Prop : NotInOffice9Prop;
                }
                else
                {
                        _PropState = IsStartToken() ? IgnoreCustOffice9Prop : NotInOffice9Prop;
                }

                _scanner.EatTag();
                return FALSE;

        case XMLShortHand:

                // Get custom property name and type

            _scanner.ReadTagIntoBuffer();
                _fSavedElement = FALSE;

                if(IsStartToken() == FALSE)
                {
                        return FALSE;
                }

                // Scan for data type ("dt:dt=...")
                WCHAR *pwcDataType;
                unsigned cwcDataType;
                csDataTypeTag = _csDataTypePrefix;
                csDataTypeTag += L":dt";
            _scanner.ScanTagBuffer(csDataTypeTag.GetBuffer(), pwcDataType, cwcDataType);

                SetTagDataType( pwcDataType, cwcDataType );

                pStat->flags = CHUNK_VALUE;
                pStat->breakType = CHUNK_EOS;
                pStat->locale = _htmlIFilter.GetCurrentLocale();
                pStat->cwcStartSource = 0;
                pStat->cwcLenSource = 0;
                pStat->idChunkSource = 0;

                SetCustOffice9PropStatChunk(pStat);

                pStat->idChunk = _htmlIFilter.GetNextChunkId();

                // Start the state machine such that no "content" is
                // emitted for properties
                _eState = FilteringValueProperty;

                if(_PropState != AcceptCustOffice9Prop)
                {
                        _scanner.EatText();
                }

                return (_PropState == AcceptCustOffice9Prop);

        case XMLOfficeChildLink:

                {
                _scanner.ReadTagIntoBuffer();

                _fSavedElement = FALSE;

                if(IsStartToken() == FALSE)
                {
                        return FALSE;
                }

                _scanner.UnGetEndTag();

                // Scan for href
                WCHAR *pwcHRef;
                unsigned cwcHRef;
                _scanner.ScanTagBuffer(L"href", pwcHRef, cwcHRef);
                memcpy(_csHRef.GetBuffer(cwcHRef + 1), pwcHRef, cwcHRef * sizeof(WCHAR));
                _csHRef.Truncate(cwcHRef);

                _TagDataType = HRef;

                pStat->flags = CHUNK_VALUE;
                pStat->breakType = CHUNK_EOS;
                pStat->locale = LOCALE_NEUTRAL;
                pStat->cwcStartSource = 0;
                pStat->cwcLenSource = 0;
                pStat->idChunkSource = 0;

                NameString csLinkType = L"LINK.OFFICECHILD";
                pStat->attribute.guidPropSet = CLSID_LinkInfo;
                pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
                pStat->attribute.psProperty.lpwstr = (WCHAR *)CoTaskMemAlloc((csLinkType.GetLength() + 1) * sizeof(WCHAR));
                if(pStat->attribute.psProperty.lpwstr)
                {
                        memcpy(pStat->attribute.psProperty.lpwstr, csLinkType.GetBuffer(), (csLinkType.GetLength() + 1) * sizeof(WCHAR));
                }
                else
                {
                        throw CException(E_OUTOFMEMORY);
                }

                pStat->idChunk = _htmlIFilter.GetNextChunkId();

                // Start the state machine such that no "content" is
                // emitted for properties
                _eState = FilteringValueProperty;

                if(!_fSeenOffice9DocPropNamespace)
                {
                        _scanner.EatText();
                }

                return (_fSeenOffice9DocPropNamespace);
                }


        case XMLIgnoreContentToken:

                _scanner.EatTag();

                if(IsStartToken())
                {
                        _scanner.EatText();
                }

                return FALSE;

        default:

                // Office 9 document properties
                BOOL f = CPropertyTag::InitStatChunk(pStat);
                // Start the state machine such that no "content" is
                // emitted for properties
                _eState = FilteringValueProperty;

                if(_PropState != AcceptOffice9Prop)
                {
                        _scanner.EatText();
                }

                return (_PropState == AcceptOffice9Prop) ? f : FALSE;
        }
}


void CXMLTag::SetTagDataType( WCHAR *pwcType, unsigned cwcType )
{
        // Treat unrecognized type as string
        _TagDataType = String;

        if(cwcType)
        {
                switch(pwcType[0])
                {
                case L'S':
                case L's':

                        if(!_wcsnicmp(L"string", pwcType, 6))
                        {
                                _TagDataType = StringA;
                        }

                        break;

                case L'B':
                case L'b':

                        if(!_wcsnicmp(L"boolean", pwcType, 7))
                        {
                                _TagDataType = Boolean;
                        }

                        break;

                case L'F':
                case L'f':

                        if(!_wcsnicmp(L"float", pwcType, 5))
                        {
                                _TagDataType = Number;
                        }

                        break;

                case L'D':
                case L'd':

                        if(!_wcsnicmp(L"date", pwcType, 4))
                        {
                                _TagDataType = DateTimeISO8601;
                        }

                        break;
                }
        }
}

bool CXMLTag::ParseDateISO8601ToSystemTime( WCHAR *pwszPropBuf, LPSYSTEMTIME pst )
{
        // Currently, only complete representation is supported
        // e.g. 19980214 or 1998-02-14

        WCHAR *pwszFirstHyphen = wcschr(pwszPropBuf, L'-');
        WCHAR *pwszLastHyphen = wcsrchr(pwszPropBuf, L'-');

        int i;
        if(!pwszFirstHyphen && !pwszLastHyphen)
        {
                // 19980214

                if(lstrlen(pwszPropBuf) != 8)
                {
                        return false;
                }
                for(i = 0; i < 8; ++i)
                {
                        if(!iswdigit(pwszPropBuf[i]))
                        {
                                return false;
                        }
                }

                WCHAR wchTemp;

                wchTemp = pwszPropBuf[4];
                pwszPropBuf[4] = L'\0';
                pst->wYear = (WORD)_wtoi(pwszPropBuf);
                pwszPropBuf[4] = wchTemp;

                wchTemp = pwszPropBuf[6];
                pwszPropBuf[6] = L'\0';
                pst->wMonth = (WORD)_wtoi(pwszPropBuf + 4);
                pwszPropBuf[6] = wchTemp;

                pst->wDay = (WORD)_wtoi(pwszPropBuf + 6);

                pst->wHour = 0;
                pst->wMinute = 0;
                pst->wSecond = 0;
                pst->wMilliseconds = 0;
        }
        else if(pwszFirstHyphen && pwszLastHyphen)
        {
                // 1998-02-14
                if(lstrlen(pwszPropBuf) != 10)
                {
                        return false;
                }
                for(i = 0; i < 10; ++i)
                {
                        if(((pwszPropBuf + i) != pwszFirstHyphen) &&
                           ((pwszPropBuf + i) != pwszLastHyphen) &&
                           !iswdigit(pwszPropBuf[i]))
                        {
                                return false;
                        }
                }
                if(wcschr(pwszFirstHyphen + 1, L'-') != pwszLastHyphen)
                {
                        return false;
                }
                if(((int)(pwszFirstHyphen - pwszPropBuf) != 4) ||
                   ((int)(pwszLastHyphen - pwszPropBuf) != 7))
                {
                        return false;
                }
                *pwszFirstHyphen = L'\0';
                *pwszLastHyphen = L'\0';

                pst->wYear = (WORD)_wtoi(pwszPropBuf);
                pst->wMonth = (WORD)_wtoi(pwszPropBuf + 5);
                pst->wDay = (WORD)_wtoi(pwszPropBuf + 8);

                pst->wHour = 0;
                pst->wMinute = 0;
                pst->wSecond = 0;
                pst->wMilliseconds = 0;

                *pwszFirstHyphen = L'-';
                *pwszLastHyphen = L'-';
        }

        return true;
}

bool CXMLTag::ParseDateTimeISO8601ToSystemTime( WCHAR *pwszPropBuf, LPSYSTEMTIME pst )
{
        // Currently, only complete representation is supported
        // e.g. 19980214T131030Z or 1998-02-14T13:10:30Z or
        //      19980214T13:10:30Z or 1988-02-14T131030Z

        WCHAR *pwszTime = wcschr(pwszPropBuf, L'T');

        if(!pwszTime)
        {
                return false;
        }

        *pwszTime = L'\0';
        if(!ParseDateISO8601ToSystemTime(pwszPropBuf, pst))
        {
                return false;
        }
        *pwszTime = L'T';
        ++pwszTime;

        WCHAR *pwszFirstColon = wcschr(pwszTime, L':');
        WCHAR *pwszLastColon = wcsrchr(pwszTime, L':');
        WCHAR *pwszZ = wcschr(pwszTime, L'Z');

        if(!pwszZ)
        {
                return false;
        }
        *pwszZ = L'\0';

        int i;
        if(!pwszFirstColon && !pwszLastColon)
        {
                // 131030

                if(lstrlen(pwszTime) != 6)
                {
                        return false;
                }
                for(i = 0; i < 6; ++i)
                {
                        if(!iswdigit(pwszTime[i]))
                        {
                                return false;
                        }
                }

                WCHAR wchTemp;

                wchTemp = pwszTime[2];
                pwszTime[2] = L'\0';
                pst->wHour = (WORD)_wtoi(pwszTime);
                pwszTime[2] = wchTemp;

                wchTemp = pwszTime[4];
                pwszTime[4] = L'\0';
                pst->wMinute = (WORD)_wtoi(pwszTime + 2);
                pwszTime[4] = wchTemp;

                pst->wSecond = (WORD)_wtoi(pwszTime + 4);

                pst->wMilliseconds = 0;
        }
        else if(pwszFirstColon && pwszLastColon)
        {
                // 13:10:30
                if(lstrlen(pwszTime) != 8)
                {
                        return false;
                }
                for(i = 0; i < 8; ++i)
                {
                        if(((pwszTime + i) != pwszFirstColon) &&
                           ((pwszTime + i) != pwszLastColon) &&
                           !iswdigit(pwszTime[i]))
                        {
                                return false;
                        }
                }
                if(wcschr(pwszFirstColon + 1, L':') != pwszLastColon)
                {
                        return false;
                }
                if(((int)(pwszFirstColon - pwszTime) != 2) ||
                   ((int)(pwszLastColon - pwszTime) != 5))
                {
                        return false;
                }
                *pwszFirstColon = L'\0';
                *pwszLastColon = L'\0';

                pst->wHour = (WORD)_wtoi(pwszTime);
                pst->wMinute = (WORD)_wtoi(pwszTime + 3);
                pst->wSecond = (WORD)_wtoi(pwszTime + 6);

                pst->wMilliseconds = 0;

                *pwszFirstColon = L':';
                *pwszLastColon = L':';
        }

        *pwszZ = L'Z';

        return true;
}

//+-----------------------------------------------
//
//      Function:       SetCustOffice9PropStatChunk
//
//      Synopsis:       Set STAT_CHUNK for custom Office properties
//
//      Returns:        void
//
//      Arguments:
//      [STAT_CHUNK *pStat]     - The STAT_CHUNK to set
//
//      History:        04/12/99        mcheng          Created
//
//+-----------------------------------------------
void CXMLTag::SetCustOffice9PropStatChunk( STAT_CHUNK *pStat )
{
        pStat->attribute.guidPropSet = FMTID_UserDefinedProperties;
        pStat->attribute.psProperty.ulKind = PRSPEC_LPWSTR;
        CreateCustomPropertyNameFromTagName(GetTagName(), &(pStat->attribute.psProperty.lpwstr));
}

//+-----------------------------------------------
//
//      Function:       CreateCustomPropertyNameFromTagName
//
//      Synopsis:       Create the custom property name from
//                              the tag name. The tag name is the
//                              escaped version of the custom property
//                              name.
//
//      Returns:        void
//
//      Arguments:
//      [const CLMString &rcsTagName]   - The tag name
//      [LPWSTR *ppwszPropName]                 - The custom property name
//
//      History:        04/12/99        mcheng          Created
//
//+-----------------------------------------------
void CXMLTag::CreateCustomPropertyNameFromTagName(const CLMString &rcsTagName, LPWSTR *ppwszPropName)
{
    enum EscapeSeqState
    {
        e1,             //      Looking for leading '_'
        e2,             //      Looking for 'x' or 'X'
        e3,             //      Looking for 1st digit
        e4,             //      Looking for 2nd digit
        e5,             //      Looking for 3rd digit
        e6,             //      Looking for 4th digit
        e7,             //      Looking for trailing '_'
    }
    eEscapeSeqState = e1;

    //
    //      Get the type of characters in the tag name
    //
    TArray< WORD > xawCharType;
    unsigned cwCharType = rcsTagName.GetLength();
    WORD *pwCharType;
    if ( cwCharType > 64 )
    {
        xawCharType = new WORD[ cwCharType ];
        pwCharType = (WORD*) xawCharType;
    }
    else
    {
        pwCharType = (WORD *) _alloca( cwCharType * sizeof(WORD) );
    }

    if ( GetOSVersion() == VER_PLATFORM_WIN32_NT )
    {
        BOOL fGetStringType = GetStringTypeW(CT_CTYPE1, rcsTagName, rcsTagName.GetLength(), pwCharType);
        if(!fGetStringType) throw CException(HRESULT_FROM_WIN32(GetLastError()));
    }
    else
    {
        //
        // All we care about is whether it's a hex digit.  We can do that on
        // our own, especially since on Win9x this just fails.
        // NOTE: This code assumes the code later only looks for C1_XDIGIT!
        //       If you change this assumption change this code!
        //

        WORD * pw = pwCharType;
        WCHAR const * pwc = rcsTagName;

        while ( 0 != *pwc )
        {
            WCHAR c = *pwc;

            if ( ( c <= '9' && c >= '0' ) ||
                 ( c <= 'f' && c >= 'a' ) ||
                 ( c <= 'F' && c >= 'A' ) )
                *pw = C1_XDIGIT;
            else
                *pw = 0;
            pwc++;
            pw++;
        }
    }

    SmallString csPropName;
    TinyString csPotentialMatch;
    WCHAR wcHighByteValue[2] = { L'\0', L'\0' };
    WCHAR wcLowByteValue[2] = { L'\0', L'\0' };
    for(unsigned u = 0; u < rcsTagName.GetLength(); ++u)
    {
        BOOL fMatched = FALSE;
        csPotentialMatch += rcsTagName[u];

        switch(eEscapeSeqState)
        {
        case e1:
            if(rcsTagName[u] == L'_')
            {
                eEscapeSeqState = e2;
                fMatched = TRUE;
            }
            break;

        case e2:
            if(rcsTagName[u] == L'x' || rcsTagName[u] == L'X')
            {
                eEscapeSeqState = e3;
                fMatched = TRUE;
            }
            break;

        case e3:
            if(pwCharType[u] & C1_XDIGIT)
            {
                wcHighByteValue[0] = rcsTagName[u];
                eEscapeSeqState = e4;
                fMatched = TRUE;
            }
            break;

        case e4:
            if(pwCharType[u] & C1_XDIGIT)
            {
                wcHighByteValue[1] = rcsTagName[u];
                eEscapeSeqState = e5;
                fMatched = TRUE;
            }
            break;

        case e5:
            if(pwCharType[u] & C1_XDIGIT)
            {
                wcLowByteValue[0] = rcsTagName[u];
                eEscapeSeqState = e6;
                fMatched = TRUE;
            }
            break;

        case e6:
            if(pwCharType[u] & C1_XDIGIT)
            {
                wcLowByteValue[1] = rcsTagName[u];
                eEscapeSeqState = e7;
                fMatched = TRUE;
            }
            break;

        case e7:
            if(rcsTagName[u] == L'_')
            {
                eEscapeSeqState = e1;
                fMatched = TRUE;
                BYTE bHigh = 0, bLow = 0;
                Convert2HexWCharToByte(wcHighByteValue, bHigh);
                Convert2HexWCharToByte(wcLowByteValue, bLow);
                WCHAR wch = ((bHigh << 8) | bLow);
                csPropName += wch;
                csPotentialMatch.Truncate(0);
            }
            break;

        default:
                throw CException(E_UNEXPECTED);
        }

        if(!fMatched)
        {
            if(rcsTagName[u] == L'_')
            {
                //
                //  If not looking for '_' but found it, it is a potential
                //  start of another escape sequence
                //
                csPropName += csPotentialMatch.Left(csPotentialMatch.GetLength() - 1);
                csPotentialMatch = L'_';
                eEscapeSeqState = e2;
            }
            else
            {
                csPropName += csPotentialMatch;
                csPotentialMatch.Truncate(0);
                eEscapeSeqState = e1;
            }
        }
    }
    if(eEscapeSeqState != e1)
    {
        csPropName += csPotentialMatch;
    }

    *ppwszPropName = (WCHAR *)CoTaskMemAlloc((csPropName.GetLength() + 1) * sizeof(WCHAR));
    if(*ppwszPropName)
    {
        memcpy(*ppwszPropName, csPropName.GetBuffer(), (csPropName.GetLength() + 1) * sizeof(WCHAR));
    }
    else
    {
        throw CException(E_OUTOFMEMORY);
    }
}

//+-----------------------------------------------
//
//      Function:       Convert2HexWCharToByte
//
//      Synopsis:       Convert a hex string (2 WCHAR's)
//                              to a byte
//
//      Returns:        void
//
//      Arguments:
//      [WCHAR *pwcHex] - The 2 hex WCHAR's
//      [BYTE &rb]              - The value in a BYTE
//
//      History:        04/15/99        mcheng          Created
//
//+-----------------------------------------------
void CXMLTag::Convert2HexWCharToByte(WCHAR *pwcHex, BYTE &rb)
{
    rb = ByteValueFromWChar(pwcHex[0]) * 16;
    rb += ByteValueFromWChar(pwcHex[1]);
}

//+-----------------------------------------------
//
//      Function:       ByteValueFromWChar
//
//      Synopsis:       Convert a hex digit (WCHAR) to a byte value
//
//      Returns:        BYTE
//
//      Arguments:
//      [WCHAR wch]     - The hex WCHAR
//
//      History:        04/15/99        mcheng          Created
//
//+-----------------------------------------------
BYTE CXMLTag::ByteValueFromWChar(WCHAR wch)
{
    switch(wch)
    {
    case L'0':                              return 0;
    case L'1':                              return 1;
    case L'2':                              return 2;
    case L'3':                              return 3;
    case L'4':                              return 4;
    case L'5':                              return 5;
    case L'6':                              return 6;
    case L'7':                              return 7;
    case L'8':                              return 8;
    case L'9':                              return 9;
    case L'A': case L'a':   return 10;
    case L'B': case L'b':   return 11;
    case L'C': case L'c':   return 12;
    case L'D': case L'd':   return 13;
    case L'E': case L'e':   return 14;
    case L'F': case L'f':   return 15;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\tslklist.h ===
//---------------------------------------------------------------
//  File:		tslklist.h
//        
//	Synopsis:	Implementation of the template based single linked list
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Author:    Dmitriy Meyerzon
//  History:    5-09-96   SSanu   Added TPtrLink
//
//----------------------------------------------------------------

#ifndef __TSLKLIST_H__
#define __TSLKLIST_H__

//list elements have to be derived from CSingleLink class
//this mean that they can not simultaneously participate in more than one list
//class T has to have a well defined int operator == (const T&)

#include "slnklist.h"

//disable 4786:
//identifier was truncated to '255' characters in the browser information
//who cares?
#pragma warning (disable : 4786)

template <class T> class CTLnkListIterator;

//list element class for a list of ptrs.
template <class T, unsigned fDeleteOnRelease> class TPtrLink : CSingleLink
{
	private:
		T * m_pElem;
	public:
    	void Set (T* pElem)
		{ if (fDeleteOnRelease && m_pElem)
				delete m_pElem;							
		  m_pElem = pElem;
		}
		T* Get() {return m_pElem;}
		TPtrLink(T* pElem = 0) : m_pElem(pElem) {};
		virtual ~TPtrLink() {Set(NULL);}
};

template <class T> class CTLnkList: private CLnkList
{
	public:

	CTLnkList() {}
	virtual ~CTLnkList() {}

	CLnkList::GetEntries;
	CLnkList::IsEmpty;

	T* GetFirst() const	{ return (T*)CLnkList::GetFirst(); }
	T* GetLast() const { return (T*)CLnkList::GetLast(); }

	void	Append(T* pLink)	{ CLnkList::Append((CSingleLink *)pLink); }
	void	Prepend(T* pLink)	{ CLnkList::Prepend((CSingleLink *)pLink); }
	T*		operator [](UINT i) const { return (T*)CLnkList::GetAt(i); }
	T*		RemoveFirst()	{ return (T*)CLnkList::RemoveFirst(); }
	T*		RemoveLast()	{ return (T*)CLnkList::RemoveLast(); }

	T*		GetAt(UINT i) const { return (T*)CLnkList::GetAt(i); }
	BOOL	InsertAt(T* pLink, UINT i) { return CLnkList::InsertAt((CSingleLink *)pLink, i); }

	BOOL	Contains(const T*pLink) const { return CLnkList::Contains((CSingleLink *)pLink); }
	BOOL	ContainsEqual(const T*pLink) const;

	T*		GetNext(const T*pLink) const { return (T*)CLnkList::GetNext((CSingleLink *)pLink); }

	T*		Remove(T* pLink) { return (T*)CLnkList::Remove((CSingleLink *)pLink); }
	T*		RemoveAt(UINT i) { return (T*)CLnkList::RemoveAt(i); }
	T*		RemoveEqual(const T*pLink);

	private:
	CTLnkList(const CTLnkList &);
	void operator =(const CTLnkList &);

	friend class CTLnkListIterator<T>;
};

template <class T> class CTLnkListIterator: private CLnkListIterator
{
	public:
	CTLnkListIterator(CTLnkList<T>& rList): 
		CLnkListIterator((CLnkList &)rList)
		{}
	CTLnkListIterator() : CLnkListIterator() {}
	~CTLnkListIterator() {}

	CLnkListIterator::operator =;

	T* operator++() { return (T*)CLnkListIterator::operator++(); }

	CTLnkList<T>*	 GetList() const	
		{ return (CTLnkList<T> *)CLnkListIterator::GetList(); }
	T* GetCurrent() const { return (T*)CLnkListIterator::GetCurrent(); }

	CLnkListIterator::Reset;
	T* Remove() { return (T*)CLnkListIterator::Remove(); }
};

template <class T> class CTLnkListContainer: public CTLnkList<T>
{
	public:

	CTLnkListContainer() {}
	~CTLnkListContainer()
	{
		T* pT;
		while((pT = RemoveFirst())!=NULL)
		{
			delete pT;
		}
	}

	private:
	CTLnkListContainer(const CTLnkListContainer<T> &);
	void operator =(const CTLnkListContainer<T> &);	
};

template <class T> BOOL CTLnkList<T>::ContainsEqual(const T*pLink) const
//uses class T::operator == to test the containment criteria
{
#ifdef DEBUG
	if(pLink==NULL) return FALSE;
#endif

	CTLnkListIterator<T> next((CTLnkList<T> &)*this);
	T* cur;

	while(cur = ++next)
	{
		if(*cur == *pLink) return TRUE;
	}

	return FALSE;
}

template <class T> T* CTLnkList<T>::RemoveEqual(const T*pLink)
//uses class T::operator == to test the containment criteria
{
#ifdef DEBUG
	if(pLink==NULL) return FALSE;
#endif

	CTLnkListIterator<T> next(*this);
	T* cur;

	while(cur = ++next)
	{
		if(*cur == *pLink) return next.Remove();
	}

	return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\convapi.h ===
/*----------------------------------------------------------------------------
        %%File: CONVAPI.H
        %%Unit: CORE
        %%Contact: smueller

        Conversions API definitions, for all platforms
----------------------------------------------------------------------------*/

#ifndef CONVAPI_H
#define CONVAPI_H

#ifdef WIN16
#include "crmgr.h"      // for PFN_CRMGR
#endif

#include "converr.h"


// percentage complete structure
typedef struct
        {
        short cbpcvt;                           // size of this structure
        short wVersion;                         // version # for determining size of struct
        short wPctWord;                         // current %-complete according to Word
        short wPctConvtr;                       // current %-complete according to the converter
        } PCVT;


// RegisterApp definitions
// NOTE: This RegisterApp stuff should stay in sync with filecvt.h and
//  filecvt.c in the Microsoft Word project!
#define fRegAppPctComp          0x00000001
#define fRegAppNoBinary         0x00000002
#define fRegAppPreview          0x00000004
#define fRegAppSupportNonOem    0x00000008      // supports non-oem filenames
#define fRegAppIndexing         0x00000010      // omit most rtf

// BYTE opcodes for struct below
#define RegAppOpcodeVer                         0x01    // for REGAPPRET
#define RegAppOpcodeDocfile                     0x02    // for REGAPPRET
#define RegAppOpcodeCharset             0x03    // for REGAPPRET
#define RegAppOpcodeReloadOnSave        0x04    // for REGAPPRET
#define RegAppOpcodePicPlacehold        0x05    // Word should send placeholder pics (with size info) for includepicture \d fields
#define RegAppOpcodeFavourUnicode       0x06    // Word should output unicode RTF whenever possible (esp. for dbcs); \uc0 is good
#define RegAppOpcodeNoClassifyChars     0x07    // Word should not break text runs by charset clasification

// RegisterApp return structure
typedef struct
        {
        short cbStruct;                 // Size of the REGAPPRET structure

        // Following are self-describing records.  Extensible at any time.

        // Does this converter understand docfiles and/or non-docfiles?
        char cbSizefDocfile;
        char opcodefDocfile;
        union
                {
                struct
                        {
                        short fDocfile : 1;
                        short fNonDocfile : 1;
                        short : 14;
                        };
                short grfType;
                };

        // Version of Word for which converter's Rtf is compliant
        char cbSizeVer;         // == sizeof(char)+sizeof(char)+sizeof(short)+sizeof(short)
        char opcodeVer;
        short verMajor;         // Major version of Word for which Rtf is compliant
        short verMinor;         // Minor version of Word for which Rtf is compliant
        
        // What character set do we want all filenames to be in.
        char cbSizeCharset;
        char opcodeCharset;
        char charset;
        char opcodesOptional[0];        // optional additional stuff
        } REGAPPRET;

#define RegAppOpcodeFilename    0x80    // for REGAPP
#define RegAppOpcodeInterimPath 0x81    // the path we're saving to is *not* the final location

typedef struct _REGAPP {        // REGister APP structure (client gives to us)
        short cbStruct;                 // Size of the REGAPP structure
        char rgbOpcodeData[];
        } REGAPP;

// Principal converter functions as declared in SDK
// Each of these should free all resources allocated!  In particular,
// be sure to free memory and close files.  Also unlock global handles
// exactly as often as they were locked.
#ifdef WIN16

void PASCAL GetIniEntry(HANDLE ghIniName, HANDLE ghIniExt);
HGLOBAL PASCAL RegisterApp(DWORD lFlags, VOID FAR *lpFuture);
FCE  PASCAL IsFormatCorrect(HANDLE ghszFile, HANDLE ghszDescrip);
FCE  PASCAL ForeignToRtf(HANDLE ghszFile, HANDLE ghBuff, HANDLE ghszDescrip, HANDLE ghszSubset, PFN_CRMGR lpfnOut);
FCE  PASCAL RtfToForeign(HANDLE ghszFile, HANDLE ghBuff, HANDLE ghszDescrip, PFN_CRMGR lpfnIn);

#elif defined(WIN32)

// no coroutine manager, but this typedef is appropriate for callbacks
typedef DWORD (PASCAL *PFN_CRMGR)();

LONG PASCAL InitConverter32(HANDLE hWnd, char *szModule);
void PASCAL UninitConverter(void);
void PASCAL GetReadNames(HANDLE haszClass, HANDLE haszDescrip, HANDLE haszExt);
void PASCAL GetWriteNames(HANDLE haszClass, HANDLE haszDescrip, HANDLE haszExt);
HGLOBAL PASCAL RegisterApp(DWORD lFlags, VOID FAR *lpFuture);
FCE  PASCAL IsFormatCorrect32(HANDLE ghszFile, HANDLE ghszClass);
// &&& VOID * -> IStorage * or LPSTORAGE
FCE  PASCAL ForeignToRtf32(HANDLE ghszFile, VOID *pstgForeign, HANDLE ghBuff, HANDLE ghszClass, HANDLE ghszSubset, PFN_CRMGR lpfnOut);
FCE  PASCAL RtfToForeign32(HANDLE ghszFile, VOID *pstgForeign, HANDLE ghBuff, HANDLE ghshClass, PFN_CRMGR lpfnIn);
LONG PASCAL CchFetchLpszError(LONG fce, char FAR *lpszError, LONG cch);
LONG PASCAL FRegisterConverter(HANDLE hkeyRoot);

#elif defined(MAC)

#include "convtype.h"

typedef struct _GFIB    // Graphics File Information Block.
        {
        SHORT   fh;                     // File handle to the open file.
        FC              fcSrc;          // FC where the WPG Data will reside.
        LONG    lcbSrc;         // Count of bytes for WPG Data.
        } GFIB;

typedef struct _PINFO
        {
        Rect    box;            // Dimensions of the binding rectangle for the picture.
        SHORT   inch;           // Units/Inch in which these dimensions are given.
        } PINFO;
typedef PINFO **HPINFO;

// grf's for wOleFlags
#define grfOleDocFile           0x0100
#define grfOleNonDocFile        0x0200
#define grfOleInited            0x0001

// function type of Rtf callback function
typedef SHORT (PASCAL * PFNRTFXFER)(SHORT, WORD);

#ifdef MAC68K
typedef struct _FIC
        {
        short icr;                                      /* Index to the converter routine */
        union
                {
                char **hstFileName;             /* File Name */
                long **hrgTyp;                  /* Types of files known to this converter */
                GFIB **hgfib;                   /* Graphics File Info Block */
                VOID *lpFuture;                 // for RegisterApp()
                } hun;
        short vRefNum;                          /* vRefNum for the file */
        short refNum;                           /* Path for file */
        union
                {
                long ftg;
                unsigned long lFlags;   /* for RegisterApp */
                };
        char **hszDescrip;                      /* Description of file */
        PFNRTFXFER pfn;                         /* Pointer into Word of function to
                                                                   call for more RTF or to convert RTF */
        union
                {                                                                  
                HANDLE hBuffer;                         /* Buffer through which RTF will be
                                                                           passed. */
                HANDLE hRegAppRet;                      /* handle to return RegAppRet structure,
                                                                           NULL if couldn't be allocated */
                };
        short wReturn;                          /* Code returned by converter */

        // Following are new to Mac Word 6.0
        SHORT  wVersion;
        HANDLE hszClass;
        HANDLE hszSubset;
        HPINFO hpinfo;                          /* Handle to PINFO Struct for Graphics */
        union
                {
                struct
                        {
                        CHAR fDocFile : 1;
                        CHAR fNonDocFile : 1;
                        CHAR : 6;
                        CHAR fOleInited : 1;
                        CHAR : 7;
                        };
                SHORT wOleFlags;
                };
        } FIC;
        
typedef FIC *PFIC;
typedef PFIC *HFIC;
#define cbFIC sizeof(FIC)
#define cbFicW5 offsetof(FIC, wVersion) /* size of a Word 5 FIC */

/* Constants for Switch routine */
#define icrInitConverter    0
#define icrIsFormatCorrect  1
#define icrGetReadTypes     2
#define icrGetWriteTypes    3
#define icrForeignToRtf     4
#define icrRtfToForeign     5
#define icrRegisterApp          6
#define icrConverterForeignToRTF        7

VOID _pascal CodeResourceEntry(LONG *plUsr, FIC **hfic);
#endif

#ifdef MACPPC
LONG InitConverter(LONG *plw);
VOID UninitConverter(void);
Handle RegisterApp(DWORD lFlags, VOID *lpFuture);
void GetReadNames(Handle hszClass, Handle hszDescrip, Handle hrgTyp);
void GetWriteNames(Handle hszClass, Handle hszDescrip, Handle hrgTyp);
LONG IsFormatCorrect(FSSpecPtr, Handle);
LONG ForeignToRtf(FSSpecPtr, void *, Handle, Handle, Handle, PFNRTFXFER);
LONG RtfToForeign(FSSpecPtr, void *, Handle, Handle, PFNRTFXFER);
#endif

#else
#error Unknown platform.
#endif

#endif // CONVAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\convtype.h ===
/*----------------------------------------------------------------------------
	%%File: CONVTYPE.H
	%%Unit: CORE
	%%Contact: smueller

	Global type and constant definitions for conversions code.
----------------------------------------------------------------------------*/

#ifndef CONVTYPE_H
#define CONVTYPE_H

//  STORAGE CLASSES
//  ---------------
#ifndef STATIC
#define STATIC static
#endif

#ifndef EXTERN
#define EXTERN extern
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#ifdef WIN
#define FAR __far
#else
#define FAR
#endif
#endif

#ifndef NEAR
#ifdef WIN
#define NEAR __near
#else
#define NEAR
#endif
#endif

// Use __HUGE rather than HUGE or _HUGE as Excel mathpack defines both as externs
#ifndef __HUGE
#ifdef WIN
#define __HUGE __huge
#else
#define __HUGE
#endif
#endif


//  CALLING CONVENTIONS
//  -------------------
#ifndef PASCAL
#define PASCAL __pascal
#endif

#ifndef CDECL
#define CDECL __cdecl
#endif

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#ifndef INLINE
#define INLINE __inline
#endif


#ifndef PREPROC
#ifdef COREDLL
#define CORE_API(type)  type FAR PASCAL
#else
#define CORE_API(type)  type
#endif // COREDLL
#endif // PREPROC


// define platform-independent function type templates
// LOCAL and GLOBAL have no calling convention; it's specified by compiler
// switches.  ENTRYPT and FARPROC must include calling convention

#if defined(MAC)
#if defined(MACPPC)
#undef PASCAL
#define PASCAL
//#define __export
#define pascal
#define _pascal
#define __pascal
#endif

#define EXPORT
#define LOADDS
#define LOCAL(type) STATIC type NEAR
#define GLOBAL(type) type
typedef int (PASCAL * FARPROC)();

#ifdef MACPPC
#define ENTRYPT(type) type CDECL
#else
#define ENTRYPT(type) type PASCAL
#endif // !MACPPC

#elif defined(WIN16)

// CRPFN is ONLY used with the win16 coroutine manager
#define CRPFN(type)     type PASCAL
#define EXPORT _export
#define LOADDS _loadds
#define ENTRYPT(type) type FAR PASCAL EXPORT
#define LOCAL(type) STATIC type NEAR
#define GLOBAL(type) type
typedef int (FAR PASCAL * FARPROC)();

#elif defined(WIN32)

//#define EXPORT __declspec(dllexport)
#define EXPORT
#define LOADDS
#define ENTRYPT(type) type PASCAL
#define LOCAL(type) STATIC type NEAR
#define GLOBAL(type) type
typedef int (WINAPI * FARPROC)();

#else
#error Unknown platform.
#endif


//  ABSOLUTE SIZE
//  -------------
#define SHORT_MAX	32767			// obsolete: use SHRT_MAX
#define SHORT_MIN	(-32767)		// obsolete: use SHRT_MIN - 1
#define WORD_MAX	65535			// obsolete: use USHRT_MAX


#ifndef VOID
#define VOID void
#endif // VOID

#undef CHAR
typedef char			CHAR;

#undef BYTE
#undef UCHAR
typedef unsigned char	BYTE, byte, UCHAR, uchar;

#undef SHORT
typedef short			SHORT;

#undef WORD
#undef USHORT
#undef XCHAR
#undef WCHAR
typedef unsigned short 	WORD, USHORT, ushort, XCHAR, xchar, WCHAR, wchar;

#undef LONG
typedef long 			LONG;

#undef DWORD
#undef ULONG
typedef unsigned long 	DWORD, ULONG, ulong;

#undef FLOAT
typedef float 			FLOAT;

#undef DOUBLE
typedef double 			DOUBLE;


//  VARIABLE SIZE
//  -------------
typedef int INT;
typedef unsigned int UINT, UNSIGNED, uint;
typedef int BOOL, bool;


//  CONVERSIONS SPECIFIC
//  --------------------
typedef long 		FC;

#define fcNil		(-1)
#define fc0			((FC)0)
#define fcMax		0x7FFFFFFF

typedef long 		CP;

#define cp0			((CP)0)

typedef short		ZA;
typedef ZA			XA;
typedef ZA			YA;
typedef ushort		UZA;
typedef UZA			UXA;
typedef UZA			UYA;

#define czaInch		1440
#define cxaInch		czaInch
#define cyaInch		czaInch
#define czaPoint	20
#define cxaPoint	czaPoint
#define cyaPoint	czaPoint
#define xaLast		(22 * cxaInch)
#define xaMin		(-xaLast)
#define xaMax		(xaLast + 1)
#define xaNil		(xaMin - 1)
#define czaRTFPageSizeFirst		(cxaInch / 10)	// .1"
#define czaRTFPageSizeLast		(cxaInch * 22)	// 22"

typedef long		LZA;
typedef LZA 		LXA;
typedef LZA			LYA;

#pragma pack(1)
typedef struct _FP16		// 16/16 bit fixed-point number
	{
	WORD wFraction;
	SHORT nInteger;
	} FP16;
#pragma pack()

#pragma pack(1)
typedef struct _RGBCOLOR	// generic color  REVIEW: rename type to CLR?
	{
	BYTE r;
	BYTE g;
	BYTE b;
	} RGBCOLOR;
#pragma pack()

#ifndef WW96		// REVIEW: not core types
typedef ushort 		PN;
#else
typedef ulong		PN;
typedef ushort		PN_W6;
#endif
 
#define ptNil		SHRT_MIN


//  WIN32 ON MAC/WIN16
//  ------------------

#ifdef MAC

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

// REVIEW: eliminate these
typedef char FAR *LPSTR;
typedef const char FAR *LPCSTR;
typedef unsigned short FAR *LPWSTR;
typedef const unsigned short FAR *LPCWSTR;
typedef WORD HWND;
typedef void FAR *LPVOID;
typedef char **HANDLE;          // REVIEW: make this void **
typedef void **HGLOBAL;

#endif


//  TYPE UTILITIES
//  --------------

#define cElements(ary)		(sizeof(ary) / sizeof(ary[0]))


// define main function types -- these are obsolete

#define LOCALVOID       LOCAL(VOID)

#define GLOBALVOID      GLOBAL(VOID)
#define GLOBALBOOL      GLOBAL(BOOL)
#define GLOBALINT       GLOBAL(INT)
#define GLOBALUNS       GLOBAL(UNSIGNED)


//  COMMON CONSTANTS
//  ----------------

#define fTrue	1
#define fFalse	0

#ifndef NULL
#define NULL	0
#endif

#define iNil	(-1)

#ifndef hgNil					// obsolete: you probably want hxNil
#define hgNil ((HGLOBAL)NULL)
#endif

#endif // CONVTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmflterr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:      FiltErr.mc
//
//  Contents:  Errors for Content Index Filter interface
//
//  History:   22-Sep-93 KyleP     Created
//
//  Notes:
//  .mc file is compiled by the MC tool to generate a .h file and
//  .rc (resource compiler script) file.
//
//--------------------------------------------------------------------------
#ifndef _DMFLTERR_H_
#define _DMFLTERR_H_
// **** START OF COPIED DATA ****
// The following information is copied from oleerror.mc.
// It should not be merged into oleerror.mc
// Define the status type.
// Define the severities
// Define the facilities
//
// FACILITY_RPC is for compatibilty with OLE2 and is not used
// in later versions of OLE

// **** END OF COPIED DATA ****
//
// Error definitions follow
//
// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x1700-0x17ff are reserved for FILTER
//
//
// IFilter error codes
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#ifndef FACILITY_WINDOWS
#define FACILITY_WINDOWS                 0x8
#endif

#ifndef FACILITY_WIN32
#define FACILITY_WIN32                   0x7
#endif

#ifndef FACILITY_STORAGE
#define FACILITY_STORAGE                 0x3
#endif

#ifndef FACILITY_RPC
#define FACILITY_RPC                     0x1
#endif

#ifndef FACILITY_NULL
#define FACILITY_NULL                    0x0
#endif

#ifndef FACILITY_ITF
#define FACILITY_ITF                     0x4
#endif

#ifndef FACILITY_DISPATCH
#define FACILITY_DISPATCH                0x2
#endif


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0

#ifndef STATUS_SEVERITY_COERROR         // Chicago headers define this
#define STATUS_SEVERITY_COERROR          0x2
#endif


//
// MessageId: FILTER_E_FF_END_OF_CHUNKS
//
// MessageText:
//
//  No more chunks of text available in object.
//
#define FILTER_E_FF_END_OF_CHUNKS           ((HRESULT)0x80041700L)

//
// MessageId: FILTER_E_FF_NO_MORE_TEXT
//
// MessageText:
//
//  No more text available in chunk.
//
#define FILTER_E_FF_NO_MORE_TEXT            ((HRESULT)0x80041701L)

//
// MessageId: FILTER_E_FF_NO_MORE_VALUES
//
// MessageText:
//
//  No more property values available in chunk.
//
#define FILTER_E_FF_NO_MORE_VALUES          ((HRESULT)0x80041702L)

//
// MessageId: FILTER_E_FF_ACCESS
//
// MessageText:
//
//  Unable to access object.
//
#define FILTER_E_FF_ACCESS                  ((HRESULT)0x80041703L)

//
// MessageId: FILTER_S_FF_MONIKER_CLIPPED
//
// MessageText:
//
//  Moniker doesn't cover entire region.
//
#define FILTER_S_FF_MONIKER_CLIPPED         ((HRESULT)0x00041704L)

//
// MessageId: FILTER_S_FF_NOT_USING_PROXY
//
// MessageText:
//
//  Notification that the filter process could not start.
//
#define FILTER_S_FF_NOT_USING_PROXY    ((HRESULT)0x80041716L)

//
// MessageId: FILTER_E_FF_NO_TEXT
//
// MessageText:
//
//  No text in current chunk.
//
#define FILTER_E_FF_NO_TEXT                 ((HRESULT)0x80041705L)

//
// MessageId: FILTER_E_FF_NO_VALUES
//
// MessageText:
//
//  No values in current chunk.
//
#define FILTER_E_FF_NO_VALUES               ((HRESULT)0x80041706L)

//
// MessageId: FILTER_S_FF_LAST_TEXT
//
// MessageText:
//
//  This is the last text in the current chunk.
//
#define FILTER_S_FF_LAST_TEXT               ((HRESULT)0x00041709L)

//
// MessageId: FILTER_S_FF_LAST_VALUES
//
// MessageText:
//
//  This is the last value in the current chunk.
//
#define FILTER_S_FF_LAST_VALUES             ((HRESULT)0x0004170AL)

//
// MessageId: FILTER_E_FF_PASSWORD
//
// MessageText:
//
//  The file can't be read since its password protected
//
#define FILTER_E_FF_PASSWORD             ((HRESULT)0x8004170BL)

//
// MessageId: FILTER_E_FF_INCORRECT_FORMAT
//
// MessageText:
//
//  Format of file is incorrect, corrupt, or otherwise impossible to filter
//

#define FILTER_E_FF_INCORRECT_FORMAT     ((HRESULT)0x8004170CL)

//
// MessageId: FILTER_E_FF_FILE_NOT_FOUND
//
// MessageText:
//
//  The file can't be found
//
#define FILTER_E_FF_FILE_NOT_FOUND       ((HRESULT)0x8004170DL)

//
// MessageId: FILTER_E_FF_PATH_NOT_FOUND
//
// MessageText:
//
//  The pathname to the file is not valid
//
#define FILTER_E_FF_PATH_NOT_FOUND       ((HRESULT)0x8004170EL)

//
// MessageId: FILTER_E_FF_OUT_OF_HANDLES
//
// MessageText:
//
//  The file handle resource is exhausted
//
#define FILTER_E_FF_NO_FILE_HANDLES      ((HRESULT)0x8004170FL)

//
// MessageId: FILTER_E_FF_IO_ERROR
//
// MessageText:
//
//  An I/O error occurred while reading the file
//
#define FILTER_E_FF_IO_ERROR             ((HRESULT)0x80041710L)

//
// MessageId: FILTER_E_FF_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_FF_TOO_BIG                 ((HRESULT)0x80041711L)

//
// MessageId: FILTER_E_FF_VERSION
//
// MessageText:
//
//  The file is in an unsupported version
//
#define FILTER_E_FF_VERSION              ((HRESULT)0x80041712L)

//
// MessageId: FILTER_E_FF_OLE_PROBLEM
//
// MessageText:
//
//  Some problem with OLE
//
#define FILTER_E_FF_OLE_PROBLEM          ((HRESULT)0x80041713L)

//
// MessageId: FILTER_E_FF_UNEXPECTED_ERROR
//
// MessageText:
//
//  An implementation problem has occurred
//
#define FILTER_E_FF_UNEXPECTED_ERROR     ((HRESULT)0x80041714L)

//
// MessageId: FILTER_E_FF_OUT_OF_MEMORY
//
// MessageText:
//
//  The memory resource is exhausted
//
#define FILTER_E_FF_OUT_OF_MEMORY        ((HRESULT)0x80041715L)

//
// MessageId: FILTER_E_FF_CODE_PAGE
//
// MessageText:
//
//  The file was written in a code page that the filter can't process
//
#define FILTER_E_FF_CODE_PAGE            ((HRESULT)0x80041716L)

//
// MessageId: FILTER_E_FF_END_OF_EMBEDDINGS
//
// MessageText:
//
//  There are no more embeddings in the file
//
#define FILTER_E_FF_END_OF_EMBEDDINGS    ((HRESULT)0x80041717L)

#endif // _DMFLTERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmfltinc.h ===
#ifndef DMFLTINC_H
#define DMFLTINC_H

#ifdef FILTER_LIB

#include <windows.h>

#define fFalse FALSE
#define fTrue TRUE
#define BF unsigned int
#define Assert(x)
#define AssertSz(f, x)
#define AssertSzA(f, x)
#define MsoMultiByteToWideChar MultiByteToWideChar
#define MsoWideCharToMultiByte WideCharToMultiByte

#define NoThrow()
#define AssertCanThrow()
#define ThrowMemoryException()	return NULL
#define AssureDtorCalled(x)
__inline void __cdecl MsoTraceSz(const CHAR*,...) {}

inline void * PvAllocCb(DWORD cb)
	{
	return GlobalAlloc(GMEM_FIXED, cb);
  	}
inline DWORD CbAllocatedPv(void * pv)
	{
	return (DWORD)GlobalSize((HGLOBAL)pv);
	}
inline void * PvReAllocPvCb(void * pv, DWORD cb)
	{
	return GlobalReAlloc((HGLOBAL)pv, cb, GMEM_MOVEABLE);
	}
inline void FreePv(void * pv)
	{
	GlobalFree(pv);
	}

#ifdef	DEBUG
#define	Debug(x)	x
#else
#define	Debug(x)	/* nothing */
#endif

inline int MsoGrszToGrwz(const CHAR* szFrom, WCHAR* wzTo)
{
	int cchRet = 0;

	Assert(szFrom);
	Assert(wzTo);

	do
		{
		int cchConv;
		int cch = strlen(szFrom);
		cchConv = MultiByteToWideChar(CP_ACP, 0, szFrom, cch, wzTo, cch);
		cchRet += cchConv;
		wzTo += cchConv;
		szFrom += cch;
		}
	while (*szFrom);

	*wzTo = 0;		// add extra null terminator.

	return cchRet;
}

class CGlobals
{
public:
	static LONG RegOpenKeyExW (
		HKEY hKey,
		LPCWSTR lpSubKey,
		DWORD ulOptions,
		REGSAM samDesired,
		PHKEY phkResult)
		{
		char szAnsiKey[256];
		if (lpSubKey)
			{
			WideCharToMultiByte(CP_ACP, 0, lpSubKey, -1, szAnsiKey, 255, NULL, NULL);
			return ::RegOpenKeyExA(hKey, szAnsiKey, ulOptions, samDesired, phkResult);
			}
		else
			return ::RegOpenKeyExA(hKey, NULL, ulOptions, samDesired, phkResult);
		}

};

extern CGlobals g_globals;
extern CGlobals * g_pglobals;



#else	// !FILTER_LIB

#include "dmstd.hpp"

#endif // FILTER_LIB

#endif // DMFLTINC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\converr.h ===
/*----------------------------------------------------------------------------
	%%File: CONVERR.H
	%%Unit: CORE
	%%Contact: smueller

	Conversions error return values.
----------------------------------------------------------------------------*/

#ifndef CONVERR_H
#define CONVERR_H


typedef SHORT FCE;

// File Conversion Errors
#define fceNoErr    		0		// success

#define fceOpenInFileErr	(-1)	// could not open input file
#define fceReadErr			(-2)	// error during read
#define fceOpenConvErr		(-3)	// error opening conversion file
#define fceWriteErr			(-4)	// error during write
#define fceInvalidFile		(-5)	// invalid data in conversion file
#define fceOpenExceptErr	(-6)	// error opening exception file
#define fceWriteExceptErr	(-7)	// error writing exception file
#define fceNoMemory			(-8)	// out of memory
#define fceInvalidDoc		(-9)	// invalid document
#define fceDiskFull			(-10)	// out of space on output
#define fceDocTooLarge		(-11)	// conversion document too large for target
#define fceOpenOutFileErr	(-12)	// could not open output file
#define fceUserCancel		(-13)	// conversion cancelled by user
#define fceWrongFileType	(-14)	// wrong file type for this converter  REVIEW: why not just use InvalidFile?
#define fceNoCoreDll		(-15)	// shared dll is not available
#define fceMultipleCoreDll	(-16)	// multiple core dll's not supported
#define fceBadCoreVersion	(-17)	// core/client version mismatch
#define fcePasswordProtected (-18)	// document is password encrypted

#define fceAbsStandardMax	19


#if defined(WIN16) || defined(MAC68K)
// These errors are too new; old platforms should never used them.
#undef  fceNoCoreDll
#undef  fceMultipleCoreDll
#undef  fceBadCoreVersion
#elif defined(WIN32)
// These errors are obsolete.  Map all usages to smaller, current set.
#undef  fceOpenConvErr
#define fceOpenConvErr		fceOpenInFileErr
#undef  fceOpenExceptErr
#define fceOpenExceptErr 	fceOpenInFileErr
#undef  fceWriteExceptErr
#define fceWriteExceptErr	fceWriteErr
#undef  fceInvalidDoc
#define fceInvalidDoc		fceInvalidFile
#undef  fceDiskFull
#define fceDiskFull			fceWriteErr
#undef  fceDocTooLarge
#define fceDocTooLarge		fceWriteErr
#endif


// any abs(FCE) >= 100 is considered "local" and will be given to the
// individual converter to interpret.
#define fceAbsLocalErrorMin	100

#endif // CONVERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiexcel.h ===
/*
** File: EXCEL.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define EXCEL_H

/* DEFINITIONS */

#ifndef EXCEL_ERROR_CODES_ONLY

#ifndef EXTEXT_H
#error  Include extext.h before excel.h
#endif

#ifndef EXTYPES_H
#error  Include extypes.h before excel.h
#endif

#ifdef FILTER
   #include "dmixlcfg.h"
#else
   #include "excelcfg.h"
#endif

#ifdef EXCEL_ENABLE_FUNCTION_INFO
   #include "exceltab.h"
#endif

/*
** ----------------------------------------------------------------------------
** Limits
** ----------------------------------------------------------------------------
*/
#define EXCEL_FIRST_COL     0
#define EXCEL_LAST_COL      255

#define EXCEL_FIRST_ROW     0
#define EXCEL_LAST_ROW      16383
#define EXCEL_V8_LAST_ROW   65535

#define EXCEL_MAX_ROWS      (EXCEL_LAST_ROW - EXCEL_FIRST_ROW + 1)
#define EXCEL_V8_MAX_ROWS   (EXCEL_V8_LAST_ROW - EXCEL_FIRST_ROW + 1)
#define EXCEL_MAX_COLS      (EXCEL_LAST_COL - EXCEL_FIRST_COL + 1)

#define EXCEL_MAX_NAME_LEN         255
#define EXCEL_MAX_TEXT_LEN         255
#define EXCEL_V8_MAX_TEXT_LEN      65535
#define EXCEL_MAX_WRITERNAME_LEN   32
#define EXCEL_MAX_SHEETNAME_LEN    255
//#define EXCEL_MAX_SHEETNAME_LEN    31
#define EXCEL_MAX_OBJECTNAME_LEN   255
#define EXCEL_MAX_PASSWORD_LEN     15

#define EXCEL_MAX_FORMULA_IMAGE    1024

#define EXCEL_WORKSHEET_EXTENSION  ".XLS"
#define EXCEL_MACROSHEET_EXTENSION ".XLM"
#define EXCEL_TEMPLATE_EXTENSION   ".XLT"
#define EXCEL_CHART_EXTENSION      ".XLC"

#define EXCEL_SHEETNAME_SEPARATOR  '!'

#define ONE_SHEET_PER_FILE(v) (((v)==versionExcel3) || ((v)==versionExcel4))

/*
** ----------------------------------------------------------------------------
** Formula tokens (base ptg's)
** ----------------------------------------------------------------------------
*/
typedef enum {
   /* 00 */ ptgUnused00,
   /* 01 */ ptgExp,
   /* 02 */ ptgTbl,
   /* 03 */ ptgAdd,
   /* 04 */ ptgSub,
   /* 05 */ ptgMul,
   /* 06 */ ptgDiv,
   /* 07 */ ptgPower,
   /* 08 */ ptgConcat,
   /* 09 */ ptgLT,
   /* 0a */ ptgLE,
   /* 0b */ ptgEQ,
   /* 0c */ ptgGE,
   /* 0d */ ptgGT,
   /* 0e */ ptgNE,
   /* 0f */ ptgIsect,
   /* 10 */ ptgUnion,
   /* 11 */ ptgRange,
   /* 12 */ ptgUplus,
   /* 13 */ ptgUminus,
   /* 14 */ ptgPercent,
   /* 15 */ ptgParen,
   /* 16 */ ptgMissArg,
   /* 17 */ ptgStr,
   /* 18 */ ptgV8Extended,
   /* 19 */ ptgAttr,
   /* 1a */ ptgSheet,
   /* 1b */ ptgEndSheet,
   /* 1c */ ptgErr,
   /* 1d */ ptgBool,
   /* 1e */ ptgInt,
   /* 1f */ ptgNum,
   /* 20 */ ptgArray,
   /* 21 */ ptgFunc,
   /* 22 */ ptgFuncVar,
   /* 23 */ ptgName,
   /* 24 */ ptgRef,
   /* 25 */ ptgArea,
   /* 26 */ ptgMemArea,
   /* 27 */ ptgMemErr,
   /* 28 */ ptgMemNoMem,
   /* 29 */ ptgMemFunc,
   /* 2a */ ptgRefErr,
   /* 2b */ ptgAreaErr,
   /* 2c */ ptgRefN,
   /* 2d */ ptgAreaN,
   /* 2e */ ptgMemAreaN,
   /* 2f */ ptgMemNoMemN,
   /* 30 */ ptgUnused30,
   /* 31 */ ptgUnused31,
   /* 32 */ ptgUnused32,
   /* 33 */ ptgUnused33,
   /* 34 */ ptgUnused34,
   /* 35 */ ptgUnused35,
   /* 36 */ ptgUnused36,
   /* 37 */ ptgUnused37,
   /* 38 */ ptgFuncCE,
   /* 39 */ ptgNameX,
   /* 3a */ ptgRef3D,
   /* 3b */ ptgArea3D,
   /* 3c */ ptgRefErr3D,
   /* 3d */ ptgAreaErr3D
} PTG;

#define PTG_LAST ptgAreaErr3D

// Excel version 8 extended PTGs
typedef enum {
   /* 00 */ ptgxUnused00,
   /* 01 */ ptgxElfLel,
   /* 02 */ ptgxElfRw,
   /* 03 */ ptgxElfCol,
   /* 04 */ ptgxElfRwN,
   /* 05 */ ptgxElfColN,
   /* 06 */ ptgxElfRwV,
   /* 07 */ ptgxElfColV,
   /* 08 */ ptgxElfRwNV,
   /* 09 */ ptgxElfColNV,
   /* 0a */ ptgxElfRadical,
   /* 0b */ ptgxElfRadicalS,
   /* 0c */ ptgxElfRwS,
   /* 0d */ ptgxElfColS,
   /* 0e */ ptgxElfRwSV,
   /* 0f */ ptgxElfColSV,
   /* 10 */ ptgxElfRadicalLel,
   /* 11 */ ptgxElfElf3dRadical,
   /* 12 */ ptgxElfElf3dRadicalLel,
   /* 13 */ ptgxElfElf3dRefNN,
   /* 14 */ ptgxElfElf3dRefNS,
   /* 15 */ ptgxElfElf3dRefSN,
   /* 16 */ ptgxElfElf3dRefSS,
   /* 17 */ ptgxElfElf3dRefLel,
   /* 18 */ ptgxElfUnused18,
   /* 19 */ ptgxElfUnused19,
   /* 1a */ ptgxElfUnused1a,
   /* 1b */ ptgxNoCalc,
   /* 1c */ ptgxNoDep,
   /* 1d */ ptgxSxName
} PTGX;

#define PTGX_LAST ptgSxName
/*
** ptgAttr options
*/
#define bitFAttrSemi    0x01
#define bitFAttrIf      0x02
#define bitFAttrChoose  0x04
#define bitFAttrGoto    0x08
#define bitFAttrSum     0x10
#define bitFAttrBaxcel  0x20

#define PTGBASE(ptg) (((ptg & 0x40) ? (ptg | 0x20) : ptg) & 0x3f)

/*
** ----------------------------------------------------------------------------
** Builtin names
** ----------------------------------------------------------------------------
*/
#define BUILTIN_NAME_CONSOLIDATE_AREA 0x00
#define BUILTIN_NAME_AUTO_OPEN        0x01
#define BUILTIN_NAME_AUTO_CLOSE       0x02
#define BUILTIN_NAME_EXTRACT          0x03
#define BUILTIN_NAME_DATABASE         0x04
#define BUILTIN_NAME_CRITERIA         0x05
#define BUILTIN_NAME_PRINT_AREA       0x06
#define BUILTIN_NAME_PRINT_TITLES     0x07
#define BUILTIN_NAME_RECORDER         0x08
#define BUILTIN_NAME_DATA_FORM        0x09
#define BUILTIN_NAME_AUTO_ACTIVATE    0x0a
#define BUILTIN_NAME_AUTO_DEACTIVATE  0x0b
#define BUILTIN_NAME_SHEET_TITLE      0x0c
#define BUILTIN_NAME_MAX              12


/*
** Names use by the summary addin
*/
#define SUMMARY_AUTHOR   "__DSAuthor"
#define SUMMARY_COMMENTS "__DSComments"
#define SUMMARY_CREATED  "__DSCreated"
#define SUMMARY_REVISION "__DSRevision"
#define SUMMARY_SUBJECT  "__DSSubject"
#define SUMMARY_TITLE    "__DSTitle"

/*
** Names that control the addin manager
*/
#define ADDIN_MGR_READONLY    "__ReadOnly"
#define ADDIN_MGR_DEMANDLOAD  "__DemandLoad"
#define ADDIN_MGR_LONGNAME    "__LongName"
#define ADDIN_MGR_COMMAND     "__Command"
#define ADDIN_MGR_MENU        "__Menu"
#define ADDIN_MGR_DEL_COMMAND "__DeleteCommand"

/*
** Paste function categories
*/
#ifdef EXCEL_ENABLE_FUNCTION_INFO
#define EXCEL_BUILTIN_NAME_CATEGORIES 14

extern const char __far *
       const ExcelNameCategories[EXCEL_BUILTIN_NAME_CATEGORIES];
#endif

/*
** ----------------------------------------------------------------------------
** Dialog Box item types
** ----------------------------------------------------------------------------
*/
typedef enum {
   /* 00 */ EDI_unused,
   /* 01 */ EDI_OKDefault,
   /* 02 */ EDI_Cancel,
   /* 03 */ EDI_OK,
   /* 04 */ EDI_CancelDefault,
   /* 05 */ EDI_Text,
   /* 06 */ EDI_TextEdit,
   /* 07 */ EDI_IntegerEdit,
   /* 08 */ EDI_NumberEdit,
   /* 09 */ EDI_FormulaEdit,
   /* 10 */ EDI_ReferenceEdit,
   /* 11 */ EDI_OptionButtonGroup,
   /* 12 */ EDI_OptionButton,
   /* 13 */ EDI_CheckBox,
   /* 14 */ EDI_GroupBox,
   /* 15 */ EDI_ListBox,
   /* 16 */ EDI_LinkedList,
   /* 17 */ EDI_Icon,
   /* 18 */ EDI_LinkedFileList,
   /* 19 */ EDI_LinkedDriveAndDirList,
   /* 20 */ EDI_DirectoryText,
   /* 21 */ EDI_DropDownListBox,
   /* 22 */ EDI_DropDownCombinationEditList,
   /* 23 */ EDI_PictureButton,
   /* 24 */ EDI_HelpButton
} ExcelDialogItem, EDI;

#define EDI_First EDI_OKDefault
#define EDI_Last  EDI_HelpButton

/*
** ----------------------------------------------------------------------------
** Initialization
** ----------------------------------------------------------------------------
*/
extern int ExcelInitialize (void * pGlobals);

extern int ExcelTerminate (void * pGlobals);

//
// Excel builtin names are stored as codes so that they can be localized
// before display.  These codes are defined above as BUILTIN_NAME_<xxx>.
// Users of the Excel module may provide an implementation of a function to
// perform this localization.
//
typedef void ExcelLocalizeBuiltinName
      (void * pGlobals, TCHAR __far *pBuiltinName, TCHAR __far *pLocalizedName);

extern int ExcelInstallNameLocalizer (ExcelLocalizeBuiltinName *pfnLocalizer);


/*
** ----------------------------------------------------------------------------
** File and Sheet open
**
** The openOptions low byte are the standard DOSOpenFile access options
** as defined in WINDOS.H.  The high byte are options defined in this
** module
** ----------------------------------------------------------------------------
*/
typedef byte __far *EXLHandle;

// Use OLE storage to read file
#define EXCEL_SHOULD_BE_DOCFILE     0x0100

// Needed to support direct cell reads
#define EXCEL_BUILD_CELL_INDEX      0x0200

// Scan into embedded BOF-EOF regions
#define EXCEL_ALLOW_EMBEDDED_SCAN   0x0400

// Load the file into memory
#define EXCEL_LOAD_FILE             0x0800

// Build an index to allow reading V8 strings directly from the file
#define EXCEL_BUILD_STRING_INDEX    0x1000

// Read supporting records so ExcelResolveNameToRange works with V8+ workbooks
#define EXCEL_SETUP_FOR_NAME_DECODE 0x2000


extern int ExcelOpenFile
      (void * pGlobals, TCHAR __far *pathname, char __far *password,
       int openOptions, long offset, EXLHandle __far *bookHandle);

extern int ExcelCloseFile (void * pGlobals, EXLHandle bookHandle, BOOL retryAvailable);


#ifdef EXCEL_ENABLE_STORAGE_OPEN
   extern int ExcelOpenStorage
         (void * pGlobals, LPSTORAGE pStorage,
          char __far *password, int options, EXLHandle __far *bookHandle);

   extern int ExcelCurrentStorage
         (EXLHandle bookHandle, LPSTORAGE __far *pStorage);
#endif


extern int ExcelOpenSheet
      (void * pGlobals, EXLHandle bookHandle, TCHAR __far *sheetName, int openOptions,
       EXLHandle __far *sheetHandle);

extern int ExcelCloseSheet (void * pGlobals, EXLHandle sheetHandle);


// Populated range of the sheet
extern int ExcelSheetRange
      (EXLHandle bookHandle, TCHAR __far *sheetName, EXA_RANGE __far *range);

/*
** Return the Ith Sheet from a workbook.  First sheet is i = 0.  Returns
** EX_errBIFFNoSuchSheet when no such sheet
*/
extern int ExcelIthSheet
      (EXLHandle bookHandle, int i, TCHAR __far *sheetName, int __far *iType);


/*
** File version of the current open file (versionExcel2, ...)
*/
extern int ExcelFileVersion (EXLHandle handle);

/*
** Table of byte counts following each ptg token - set for the file version
*/
extern const int __far *ExcelPTGSize (int version);
extern const int __far *ExcelExtPTGSize (int version);

/*
** Return the date and time of the file as recorded in the OS directory
*/
extern int ExcelFileDateTime
      (EXLHandle bookHandle,
       int __far *year, int __far *month, int __far *day,
       int __far *hour, int __far *minute, int __far *second);

/*
** For Excel V5-8 files read the summary info
*/
typedef struct {
   char __far *pTitle;
   char __far *pSubject;
   char __far *pAuthor;
   char __far *pKeywords;
   char __far *pComments;
} ExcelOLESummaryInfo;

extern int ExcelFileSummaryInfo
      (EXLHandle bookHandle, ExcelOLESummaryInfo __far *pInfo);

/*
** Return the height of a row in units of 1/20th of a point
*/
extern int ExcelSheetRowHeight
      (EXLHandle sheetHandle, int row, unsigned int __far *height);

extern char *ExcelTextGet (EXLHandle handle, TEXT t);
extern TEXT  ExcelTextPut (void * pGlobals, EXLHandle handle, char __far *s, int cbString);

/*
** ----------------------------------------------------------------------------
** Array constants
** ----------------------------------------------------------------------------
*/
#define tagISNUMBER 1
#define tagISSTRING 2
#define tagISBOOL   4
#define tagISERR    16

typedef struct {
   byte   tag;
   double value;
} ArrayItemNum;

typedef struct {
   byte   tag;
   TEXT   value;
} ArrayItemStr;

typedef struct {
   byte   tag;
   BOOL   value;
} ArrayItemBool;

typedef struct {
   byte   tag;
   int    value;
} ArrayItemErr;

typedef union {
   byte          tag;
   ArrayItemNum  AIN;
   ArrayItemStr  AIS;
   ArrayItemBool AIB;
   ArrayItemErr  AIE;
} ArrayItem, AITEM;

typedef struct ArrayConstant {
   struct ArrayConstant __far *next;
   int    colCount;
   int    rowCount;
   AITEM  values[1];            /* values[rowCount * colCount] */
} ArrayConstant;

typedef ArrayConstant __far *ACP;


/*
** ----------------------------------------------------------------------------
** Formulas
** ----------------------------------------------------------------------------
*/
#define FORMULA_DEFINED

#pragma pack(1)
typedef struct {
   int          cbPostfix;
   unsigned int options;
   int          ctArrayConstants;
   ACP          arrayConstants;
   byte __far   *postfix;
} FormulaParts, FORM;
#pragma pack()

typedef FormulaParts __far *FRMP;


/*
** ----------------------------------------------------------------------------
** Array and shared formulas
** ----------------------------------------------------------------------------
*/
#define typeSHARED         0x00
#define typeARRAY_ENTERED  0x01

typedef struct SharedFormulaNode {
   struct SharedFormulaNode __far *next;
   int        iType;
   EXA_RANGE  range;
   int        cbDefinition;
   int        cbExtra;
   byte       definition[1];
} SharedFormulaNode;

typedef SharedFormulaNode __far *SFN;

extern SFN ExcelSharedFormulaAccess (EXLHandle sheetHandle);

extern int ExcelSharedFormulaToFormula
      (EXLHandle sheetHandle, SFN sharedFormula, FORM __far *pFormula);


/*
** ----------------------------------------------------------------------------
** Direct cell read access
** ----------------------------------------------------------------------------
**
** Access the contents of the file and process cells by retrieving
** their value directly.
*/
#ifdef FILTER
#include "dmixll.h"
#else
#include "excell.h"
#endif

extern int ExcelReadCell
      (EXLHandle sheetHandle, EXA_CELL location, CV __far *pValue);

extern int ExcelReadIntCell
      (EXLHandle sheetHandle, EXA_CELL location, long __far *value);

extern int ExcelReadNumberCell
      (EXLHandle sheetHandle, EXA_CELL location, double __far *value);

extern int ExcelReadTextCell
      (EXLHandle sheetHandle, EXA_CELL location, TEXT __far *value);

extern int ExcelReadBooleanCell
      (EXLHandle sheetHandle, EXA_CELL location, int __far *value);

/*
** To see if the sheet contains any non-blank cells in a given column
** below a given row, the following function may be used.  All
** cells in the column location.col and location.row+1 to EXCEL_LAST_ROW are
** checked.
**
** If there are non-blank cells EXA_errSuccess is returned otherwise
** EX_wrnCellNotFound is returned.
*/
extern int ExcelNextNonBlankCellInColumn
      (EXLHandle sheetHandle,
       EXA_CELL fromLocation, EXA_CELL __far *nonBlankLocation);

/*
** Return the location of the upper left most cell (cell with
** lowest column and row) that is populated
*/
extern int ExcelUpperLeftMostCell
      (EXLHandle sheetHandle, EXA_CELL __far *cellLocation);

/*
** ----------------------------------------------------------------------------
** Callback functions
** ----------------------------------------------------------------------------
**
** This module provides a logical file reader for Excel files.  Only
** selected records are read from the file and passed via
** the function pointers to a receiving function.  Any record type
** that does not have a function defined for it, or if the function
** for this record type is null in the dispatch structure, is
** skipped.
**
** Several changes are made to the data from the records as they
** are read from the file.  These are:
**
** - Continue records are merged with the record data prior to
**   passing the data to one of the dispatched functions.
**
** - When an RK cell, INTEGER cell, or NUMBER cell is read
**   the appropriate function for the type of value is called.
**
** - The component parts of the data for a formula cell are
**   broken out.
**
** - The name stored in the EXTERNSHEET record is translated
**   to DOS standards
**
** If the record type function returns a status code not equal
** to EX_errSuccess, the scan is terminated and that status code
** is returned from ExcelScanFile / ExcelReadCell
**
**
** All functions that are passed a formula use it as follows:
**
** 1. If the receiving function needs to save the formula postfix
**    it must be copied to a local buffer prior to the function return
**    as it is deallocated internally in this module.
**
** 2. The memory allocated for the array constants is used as follows:
**
**    To save the array constant list:
**       - save the pointer to the list (pFormula->arrayConstants)
**       - set pFormula->arrayConstants to NULL.
**
**    Not to save the array constant list:
**       - do nothing.  Upon return the data allocated to the list
**         is deallocated.
*/

typedef int ExcelBOF (void * pGlobals, int version, int docType);
#define versionExcel2  2
#define versionExcel3  3
#define versionExcel4  4
#define versionExcel5  5
#define versionExcel8  8

#define docTypeGlobals 0x0005
#define docTypeVB      0x0006
#define docTypeXLS     0x0010
#define docTypeXLC     0x0020
#define docTypeXLM     0x0040
#define docTypeXLW     0x0100

/*
** V4 Workbook specific records
**
** The BundleHeader callback sheetType argument is only valid during a
** WorkbookScan
*/
typedef int ExcelWBBundleHeader
       (void * pGlobals, char __far *sheetName, int sheetType, long boundDocAtOffset);

typedef int ExcelWBBundleSheet (void * pGlobals, char __far *sheetName);

typedef int ExcelWBExternSheet (void * pGlobals, int sheetType, char __far *pathname);
#define sheetTypeXLS   0x00
#define sheetTypeXLM   0x01
#define sheetTypeXLC   0x02

#define excelStartupDir     0x01  // Pathname may contain these characters
#define excelAltStartupDir  0x02
#define excelLibraryDir     0x03


typedef int ExcelWorkbookBoundSheet
       (void * pGlobals, TCHAR __far *sheetName, byte sheetType, byte sheetState);

#define boundWorksheet   0x00
#define boundDialogsheet 0x00
#define boundXLM         0x01
#define boundChart       0x02
#define boundVBModule    0x06

#define stateVisible     0x00
#define stateHidden      0x01
#define stateVeryHidden  0x02


typedef int ExcelIsTemplate (void * pGlobals);

typedef int ExcelIsAddin (void * pGlobals);

typedef int ExcelIsInternationalSheet (void * pGlobals);


typedef int ExcelInterfaceChanges (void * pGlobals, byte ctAddMenu, byte ctDelMenu);

typedef int ExcelDeleteMenu
       (void * pGlobals, int icetabItem, int ctChildren, int use, char __far *item);

#define useACTION      1
#define usePLACEHOLDER 0

typedef int ExcelAddMenu
       (void * pGlobals, int icetabItem, int icetabBefore, int ctChildren, int use,
        char __far *item, char __far *before, char __far *macro,
        char __far *status, char __far *help);

typedef int ExcelAddToolbar (void * pGlobals, char __far *name);


typedef int ExcelWriterName (void * pGlobals, char __far *userName);

typedef int ExcelDocRoute
       (void * pGlobals, int ctRecipients, int iDeliveryType, EXA_GRBIT options,
        char __far *subject, char __far *message, char __far *bookTitle,
        char __far *originatorName);

#define routeDeliveryOneAtATime 0
#define routeDeliveryAllAtOnce  1

#define fRrouted       0x0001
#define fReturnOrig    0x0002
#define fTrackStatus   0x0004
#define fCustomType    0x0008
#define fSaveRouteInfo 0x0080

typedef int ExcelRecipientName (void * pGlobals, char __far *name);

typedef int ExcelDateSystem (void * pGlobals, int system);
#define dateSystem1900 0
#define dateSystem1904 1

typedef int ExcelCodePage (void * pGlobals, int codePage);

/*
** To convert a 1904 date read from the file add this value:
*/
#define EXCEL_DATE_1904_CORRECTION 1462


/*
** Decodes the following records
** - FILESHARING
** - OBJPROTECT
** - PASSWORD
** - PROTECT
** - SCENPROTECT
** - WINDOW_PROTECT
** - WRITEPROT
*/
typedef int ExcelProtection (void * pGlobals, int iType, BOOL enabled);
#define protectCELLS                0
#define protectWINDOWS              1
#define protectOBJECTS              2
#define protectRECOMMENED_READ_ONLY 3
#define protectWRITE_RESERVATION    4
#define protectPASSWORD             5
#define protectSCENARIOS            6

typedef int ExcelColInfo
       (void * pGlobals, unsigned int colFirst, unsigned int colLast, unsigned int width,
        EXA_GRBIT options);

#define fHidden          0x0001
#define maskOutlineLevel 0x0700
#define fCollapsed       0x1000

typedef int ExcelStandardWidth (void * pGlobals, unsigned int width);

typedef int ExcelDefColWidth (void * pGlobals, unsigned int width);

typedef int ExcelGCW (void * pGlobals, unsigned int cbBitArray, byte __far *pBitArray);

typedef int ExcelDefRowHeight (void * pGlobals, unsigned int height, EXA_GRBIT options);

typedef int ExcelFont
       (void * pGlobals, unsigned int height, EXA_GRBIT options, char __far *faceName);

#define fBold      0x0001
#define fItalic    0x0002
#define fUnderline 0x0004
#define fStrikeout 0x0008
#define fOutline   0x0010
#define fShadow    0x0020
#define fCondensed 0x0040
#define fExtended  0x0080

typedef int ExcelXF (void * pGlobals, int iFont, int iFormat, EXA_GRBIT options);
#define fCellLocked 0x0001
#define fCellHidden 0x0002
#define fStyle      0x0004

typedef int ExcelFormat (void * pGlobals, TCHAR __far *formatString, int indexCode);

typedef int ExcelReferenceMode (void * pGlobals, int refMode);
#define fRefR1C1 0
#define fRefA1   1

typedef int ExcelFNGroupCount (void * pGlobals, int ctBuiltinGroups);

typedef int ExcelFNGroupName (void * pGlobals, char __far *name);

typedef int ExcelExternCount (void * pGlobals, int docCount);

typedef int ExcelExternSheet (void * pGlobals, char __far *name, EXA_GRBIT flags);
#define fESheetDDE  0x01
#define fESheetSelf 0x02

typedef int ExcelExternName
       (void * pGlobals, char __far *name, EXA_GRBIT flags, FORM __far *nameDefinition);
#define fENameBuiltin    0x0001
#define fENameWantAdvise 0x0002
#define fENameWantPict   0x0004
#define fENameOle        0x0008
#define fENameOleLink    0x0010
#define fENameClipFormat 0x7fe0

typedef int ExcelRangeName
       (void * pGlobals, EXA_GRBIT flags, BYTE keyboardShortcut,
        TCHAR __far *nameSpelling, int iBoundSheet, FORM __far *nameDefinition);
#define fNameHidden  0x0001
#define fNameFunc    0x0002
#define fNameRun     0x0004
#define fNameProc    0x0008
#define fNameCalcExp 0x0010
#define fNameBuiltin 0x0020
#define fNameGrp     0x0fc0

#define EXCEL_GLOBAL_NAME 0   // global if iBoundSheet = 0

extern int ExcelResolveNameToRange
      (EXLHandle handle,
       FORM __far *nameDefinition, EXA_RANGE __far *range, int __far *iSheet);

typedef int ExcelDimensions
        (void * pGlobals, int firstRow, int lastRowPlus1, int firstColumn, int lastColumnPlus1);


typedef int ExcelBlankCell
       (void * pGlobals, EXA_CELL location, int ixfe);

typedef int ExcelTextCell
       (void * pGlobals, EXA_CELL location, int ixfe, TCHAR __far *text, int cbText);

typedef int ExcelBooleanCell
       (void * pGlobals, EXA_CELL location, int ixfe, int value);

typedef int ExcelNumberCell
       (void * pGlobals, EXA_CELL location, int ixfe, double value);

// errorType is one of cellError<xxx>
typedef int ExcelErrorCell
       (void * pGlobals, EXA_CELL location, int ixfe, int errorType);

typedef int ExcelFormulaCell
       (void * pGlobals, EXA_CELL location,
        int ixfe, EXA_GRBIT flags, FRMP definition, CV __far *pValue);

#define fAlwaysCalc    0x01
#define fCalcOnLoad    0x02
#define fArrayFormula  0x04

typedef int ExcelArrayFormulaCell
       (void * pGlobals, EXA_RANGE location, EXA_GRBIT flags, FRMP definition);

typedef int ExcelSharedFormulaCell
       (void * pGlobals, EXA_RANGE location, FRMP definition);

typedef int ExcelStringCell (void * pGlobals, TCHAR __far *pString);

typedef int ExcelCellNote
       (void * pGlobals, EXA_CELL location, TCHAR __far *text, int cbText, int soundNote);

typedef struct {
   EXA_RANGE    boundingRectangle;
   unsigned int upperLeftDeltaX;
   unsigned int upperLeftDeltaY;
   unsigned int lowerRightDeltaX;
   unsigned int lowerRightDeltaY;
} OBJPOS;

typedef struct {
   byte fillBackColor;
   byte fillForeColor;
   byte fillPattern;
   byte isFillAuto;
   byte lineColor;
   byte lineStyle;
   byte lineWeight;
   byte isLineAuto;
   byte hasShadow;
} PICTPROP;

typedef struct {
   OBJPOS   pos;
   PICTPROP picture;
   FORM     macroFormula;
   FORM     cellLinkFormula;
   FORM     inputRangeFormula;
   TCHAR    __far *pName;
   TCHAR    __far *pText;
   TCHAR    __far *v3MacroFormula;
} OBJINFO;

#define fFillAuto   0x01   // pictprop.isFillAuto
#define fLineAuto   0x01   // pictprop.isLineAuto
#define fPictShadow 0x02   // pictprop.hasShadow

typedef int ExcelObject (void * pGlobals, int iType, int id, OBJINFO __far *pInfo);

#define otGroup        0
#define otLine         1
#define otRectangle    2
#define otOval         3
#define otArc          4
#define otChart        5
#define otText         6
#define otButton       7
#define otPicture      8
#define otPolygon      9
#define otUnused       10
#define otCheckbox     11
#define otOptionButton 12
#define otEditBox      13
#define otLabel        14
#define otDialogFrame  15
#define otSpinner      16
#define otScrollBar    17
#define otListBox      18
#define otGroupBox     19
#define otDropDown     20
#define otUnknown      21

typedef int ExcelImageData
       (void * pGlobals, int iFormat, int iEnvironment, long cbData, byte __huge *pData,
        HGLOBAL hData);

#define fmtMetafile 0x02
#define fmtBitmap   0x09
#define fmtOLE      0x0e

#define envWindows  0x01
#define envMac      0x02

typedef int ExcelScenario
       (void * pGlobals, TCHAR __far *scenarioName, TCHAR __far *comments, TCHAR __far *userName,
        EXA_GRBIT options,
        int ctChangingCells, EXA_CELL __far *changingCells, char __far *values);

#define scenarioLocked 0x0001
#define scenarioHidden 0x0002

typedef int ExcelEOF (void * pGlobals);

typedef int ExcelEveryRecord
       (void * pGlobals, int recType, unsigned int cbRecord, long recPos, byte __far *pRec);

typedef int ExcelStringPool
       (void * pGlobals, int ctTotalStrings, int iString, unsigned int cbText, TCHAR __far *pText);

/*
** Limited Chart Support
*/
#ifdef EXCEL_ENABLE_CHART_BIFF

typedef int ExcelSeriesText (void * pGlobals, int id, TCHAR __far *value);

#endif

/*
** ----------------------------------------------------------------------------
** Callback structure
** ----------------------------------------------------------------------------
*/
#define EXCEL_CALLBACK_VERSION 10

typedef struct {
   int                        version;
   ExcelEveryRecord           *pfnEveryRecord;
   ExcelBOF                   *pfnBOF;
   ExcelWBBundleHeader        *pfnWBBundleHeader;
   ExcelWBBundleSheet         *pfnWBBundleSheet;
   ExcelWBExternSheet         *pfnWBExternSheet;
   ExcelWorkbookBoundSheet    *pfnWorkbookBoundSheet;
   ExcelIsTemplate            *pfnIsTemplate;
   ExcelIsAddin               *pfnIsAddin;
   ExcelIsInternationalSheet  *pfnIsInternationalSheet;
   ExcelInterfaceChanges      *pfnInterfaceChanges;
   ExcelDeleteMenu            *pfnDeleteMenu;
   ExcelAddMenu               *pfnAddMenu;
   ExcelAddToolbar            *pfnAddToolbar;
   ExcelDateSystem            *pfnDateSystem;
   ExcelCodePage              *pfnCodePage;
   ExcelProtection            *pfnProtection;
   ExcelColInfo               *pfnColInfo;
   ExcelStandardWidth         *pfnStandardWidth;
   ExcelDefColWidth           *pfnDefColWidth;
   ExcelDefRowHeight          *pfnDefRowHeight;
   ExcelGCW                   *pfnGCW;
   ExcelFont                  *pfnFont;
   ExcelFormat                *pfnFormat;
   ExcelXF                    *pfnXF;
   ExcelWriterName            *pfnWriterName;
   ExcelDocRoute              *pfnDocRoute;
   ExcelRecipientName         *pfnRecipientName;
   ExcelReferenceMode         *pfnReferenceMode;
   ExcelFNGroupCount          *pfnFNGroupCount;
   ExcelFNGroupName           *pfnFNGroupName;
   ExcelExternCount           *pfnExternCount;
   ExcelExternSheet           *pfnExternSheet;
   ExcelExternName            *pfnExternName;
   ExcelRangeName             *pfnName;
   ExcelDimensions            *pfnDimensions;
   ExcelTextCell              *pfnTextCell;
   ExcelNumberCell            *pfnNumberCell;
   ExcelBlankCell             *pfnBlankCell;
   ExcelErrorCell             *pfnErrorCell;
   ExcelBooleanCell           *pfnBooleanCell;
   ExcelFormulaCell           *pfnFormulaCell;
   ExcelArrayFormulaCell      *pfnArrayFormulaCell;
   ExcelSharedFormulaCell     *pfnSharedFormulaCell;
   ExcelStringCell            *pfnStringCell;
   ExcelCellNote              *pfnCellNote;
   ExcelObject                *pfnObject;
   ExcelImageData             *pfnImageData;
   ExcelScenario              *pfnScenario;
   ExcelStringPool            *pfnStringPool;
   ExcelEOF                   *pfnEOF;

   #ifdef EXCEL_ENABLE_CHART_BIFF
   ExcelSeriesText            *pfnSeriesText;
   #endif
} EXCELDEF;


extern int ExcelStopOnBlankCell
      (EXA_CELL location, int ixfe);

extern int ExcelStopOnTextCell
      (EXA_CELL location, int ixfe, TCHAR __far *text, int cbText);

extern int ExcelStopOnBooleanCell
      (EXA_CELL location, int ixfe, int value);

extern int ExcelStopOnNumberCell
      (EXA_CELL location, int ixfe, double value);

extern int ExcelStopOnErrorCell
      (EXA_CELL location, int ixfe, int errorType);

extern int ExcelStopOnFormulaCell
      (EXA_CELL location,
       int ixfe, EXA_GRBIT flags, FRMP definition, CV __far *pValue);

extern int ExcelStopOnArrayFormulaCell
      (EXA_RANGE location, EXA_GRBIT flags, FRMP definition);

extern int ExcelStopOnSharedFormulaCell
      (EXA_RANGE location, FRMP definition);


/*
** ----------------------------------------------------------------------------
** Scan using callbacks
** ----------------------------------------------------------------------------
**
** Access the contents of the file and process records via the
** dispatch table
*/
typedef unsigned long ExcelBookmark;

#define ExcelBookmarkStartOfFile   0
#define ExcelBookmarkStartOfPly    0
#define ExcelBookmarkNil           0xffffffff

extern int ExcelGetBookmark
      (EXLHandle handle, int iType, ExcelBookmark __far *bookmark);

#define START_OF_CURRENT_RECORD 0
#define START_OF_NEXT_RECORD    1

extern int ExcelScanFile
      (void * pGlobals, EXLHandle handle, const EXCELDEF __far *dispatch, ExcelBookmark bookmark);

/*
** Scan a V4 workbook file.  The only callbacks are made for the BUNDLEHEADER
** record.  If the callback for the BUNDLEHEADER record returns
** EXCEL_WBSCAN_INTO then we operate the same as ExcelScanFile
** for that bound document.  Upon reaching the EOF record for that
** bound document the scan quits.
*/
extern int ExcelScanWorkbook (void * pGlobals, EXLHandle bookHandle, EXCELDEF __far *dispatch);

#define EXCEL_WBSCAN_INTO 1


#ifdef EXCEL_ENABLE_WRITE
/*
** ----------------------------------------------------------------------------
** Write facilities
**
** From this point on, these functions may be used by applications
** that create and/or write to Excel files.  For read only apps these
** facilities can be made unavailable by not defining the constant
** EXCEL_ENABLE_WRITE
** ----------------------------------------------------------------------------
*/

//
// File and Sheet creation
//
extern int ExcelCreateFile
      (char __far *pathname, int version, int options, EXLHandle __far *bookHandle);

extern int ExcelAppendNewSheet (EXLHandle bookHandle, char __far *sheetName);

//
// Name creation and update
//
// localToSheet == EXCEL_GLOBAL_NAME or 1 based indexe to sheets
// refersToSheet == zero based index to sheets
//
extern int ExcelAddName
      (EXLHandle bookHandle, int localToSheet, char __far *pSpelling,
       EXA_RANGE refersToRange, int refersToSheet, EXA_GRBIT flags);

extern int ExcelUpdateName
      (EXLHandle bookHandle, int localToSheet, char __far *pSpelling,
       EXA_RANGE refersToNewRange, EXA_GRBIT optionsAnd, EXA_GRBIT optionsOr);


//
// Cell write
//

extern int ExcelWriteCellList
      (EXLHandle sheetHandle, int row, CVLP pCellList, int hint);

// Write hints
#define hintNONE   0
#define hintINSERT 1
#define hintUPDATE 2


//
// Cell notes
//
extern int ExcelAddNote
      (EXLHandle sheetHandle, EXA_CELL location, char __far *text);

extern int ExcelDeleteNote
      (EXLHandle sheetHandle, EXA_CELL location);


//
// XF records
//
extern int ExcelAddXFRecord
      (EXLHandle bookHandle, int iFont, int iFmt, int __far *iXFNew);


//
// Should be private
//
extern int ExcelWriteDimensions (EXLHandle sheetHandle, EXA_RANGE range);

#endif

/*
** ----------------------------------------------------------------------------
** Status return values from ExcelReadCell and ExcelScanFile
** ----------------------------------------------------------------------------
*/
#define EX_wrnScanStopped           1

//From: ExcelReadCell, ExcelNextNonBlankCellInColumn, ExcelUpperLeftMostCell
#define EX_wrnCellNotFound          2

//From: ExcelSheetRowHeight
#define EX_wrnRowNotFound           3

//From: ExcelReadNumberCell, ExcelReadTextCell, ExcelReadBooleanCell
#define EX_wrnCellWrongType         4
#define EX_wrnCellIsBlank           5
#define EX_wrnCellHasFormula        6

#define EX_wrnLAST EX_wrnCellHasFormula

#endif
/*
** ----------------------------------------------------------------------------
** Errors
** ----------------------------------------------------------------------------
*/
#define EX_errSuccess                    0
#define EX_errGeneralError              -1
#define EX_errOutOfMemory               -2

#define EX_errBIFFFileNotFound          -3
#define EX_errBIFFPathNotFound          -4
#define EX_errBIFFCreateFailed          -5
#define EX_errBIFFFileAccessDenied      -6
#define EX_errBIFFOutOfFileHandles      -7
#define EX_errBIFFIOError               -8
#define EX_errBIFFDiskFull              -9
#define EX_errBIFFCorrupted             -10
#define EX_errBIFFNoIndex               -11
#define EX_errBIFFPasswordProtected     -12
#define EX_errBIFFVersion               -13
#define EX_errBIFFCallbackVersion       -14
#define EX_errBIFFFormulaPostfixLength  -15
#define EX_errBIFFFormulaExtraLength    -16
#define EX_errBIFFFormulaUnknownToken   -17
#define EX_errBIFFUnknownArrayType      -18

#define EX_errOLEInitializeFailure      -19
#define EX_errOLENotCompoundFile        -20
#define EX_errOLEFailure                -21

#define EX_errBIFFNoSuchSheet           -22
#define EX_errNotAWorkbook              -23
#define EX_errChartOrVBSheet            -24
#define EX_errNoSummaryInfo             -25
#define EX_errSummaryInfoError          -26
#define EX_errRecordTooBig              -27
#define EX_errMemoryImageNotSupported   -28
#define EX_errDiskImageNotSupported     -29

#define EX_errLAST EX_errDiskImageNotSupported

#endif // !VIEWER
/* end EXCEL.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiexcel.c ===
/*
** File: EXCEL.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifdef FILTER
   #include "dmixlcfg.h"
#else
   #include "excelcfg.h"
#endif

#if (defined(EXCEL_ENABLE_STORAGE_OPEN) && !defined(INC_OLE2))
   #define INC_OLE2
#endif

#include <stdlib.h>
#include <string.h>
#include <windows.h>

#if (!defined(WIN32) && defined(EXCEL_ENABLE_STORAGE_OPEN))
   #include <ole2.h>
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmixltyp.h"
   #include "dmitext.h"
   #include "dmiexcel.h"
   #include "dmixlrec.h"
   #include "dmubfile.h"
   #include "dmixlp.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "extypes.h"
   #include "extext.h"
   #include "excel.h"
   #include "exrectyp.h"
   #include "bfile.h"
   #include "excelp.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */

extern void SetExcelRecordBuffer(void * pGlobals, byte __far * pBuff);


/* MODULE DATA, TYPES AND MACROS  */

/*
** ----------------------------------------------------------------------------
** Excel Formula Tokens
** ----------------------------------------------------------------------------
*/
static const int ExcelV3PTGSize[] = {
   /* 00: ptgUnused00  */ -1,
   /* 01: ptgExp       */ 4,
   /* 02: ptgTbl       */ 4,
   /* 03: ptgAdd       */ 0,
   /* 04: ptgSub       */ 0,
   /* 05: ptgMul       */ 0,
   /* 06: ptgDiv       */ 0,
   /* 07: ptgPower     */ 0,
   /* 08: ptgConcat    */ 0,
   /* 09: ptgLT        */ 0,
   /* 0a: ptgLE        */ 0,
   /* 0b: ptgEQ        */ 0,
   /* 0c: ptgGE        */ 0,
   /* 0d: ptgGT        */ 0,
   /* 0e: ptgNE        */ 0,
   /* 0f: ptgIsect     */ 0,
   /* 10: ptgUnion     */ 0,
   /* 11: ptgRange     */ 0,
   /* 12: ptgUplus     */ 0,
   /* 13: ptgUminus    */ 0,
   /* 14: ptgPercent   */ 0,
   /* 15: ptgParen     */ 0,
   /* 16: ptgMissArg   */ 0,
   /* 17: ptgStr       */ 0,
   /* 18: ptgUnused18  */ -1,
   /* 19: ptgAttr      */ 0,
   /* 1a: ptgSheet     */ 10,
   /* 1b: ptgEndSheet  */ 4,
   /* 1c: ptgErr       */ 1,
   /* 1d: ptgBool      */ 1,
   /* 1e: ptgInt       */ 2,
   /* 1f: ptgNum       */ 8,
   /* 20: ptgArray     */ 7,
   /* 21: ptgFunc      */ 1,
   /* 22: ptgFuncVar   */ 2,
   /* 23: ptgName      */ 10,
   /* 24: ptgRef       */ 3,
   /* 25: ptgArea      */ 6,
   /* 26: ptgMemArea   */ 6,
   /* 27: ptgMemErr    */ 6,
   /* 28: ptgMemNoMem  */ 6,
   /* 29: ptgMemFunc   */ 2,
   /* 2a: ptgRefErr    */ 3,
   /* 2b: ptgAreaErr   */ 6,
   /* 2c: ptgRefN      */ 3,
   /* 2d: ptgAreaN     */ 6,
   /* 2e: ptgMemAreaN  */ 2,
   /* 2f: ptgMemNoMemN */ 6,
   /* 30: ptgUnused30  */ -1,
   /* 31: ptgUnused31  */ -1,
   /* 32: ptgUnused32  */ -1,
   /* 33: ptgUnused33  */ -1,
   /* 34: ptgUnused34  */ -1,
   /* 35: ptgUnused35  */ -1,
   /* 36: ptgUnused36  */ -1,
   /* 37: ptgUnused37  */ -1,
   /* 38: ptgFuncCE    */ 2,
   /* 39: ptgUnused39  */ -1,
   /* 3a: ptgUnused3a  */ -1,
   /* 3b: ptgV5AreaN   */ -1
};

static const int ExcelV4PTGSize[] = {
   /* 00: ptgUnused00  */ -1,
   /* 01: ptgExp       */ 4,
   /* 02: ptgTbl       */ 4,
   /* 03: ptgAdd       */ 0,
   /* 04: ptgSub       */ 0,
   /* 05: ptgMul       */ 0,
   /* 06: ptgDiv       */ 0,
   /* 07: ptgPower     */ 0,
   /* 08: ptgConcat    */ 0,
   /* 09: ptgLT        */ 0,
   /* 0a: ptgLE        */ 0,
   /* 0b: ptgEQ        */ 0,
   /* 0c: ptgGE        */ 0,
   /* 0d: ptgGT        */ 0,
   /* 0e: ptgNE        */ 0,
   /* 0f: ptgIsect     */ 0,
   /* 10: ptgUnion     */ 0,
   /* 11: ptgRange     */ 0,
   /* 12: ptgUplus     */ 0,
   /* 13: ptgUminus    */ 0,
   /* 14: ptgPercent   */ 0,
   /* 15: ptgParen     */ 0,
   /* 16: ptgMissArg   */ 0,
   /* 17: ptgStr       */ 0,
   /* 18: ptgUnused18  */ -1,
   /* 19: ptgAttr      */ 0,
   /* 1a: ptgSheet     */ 10,
   /* 1b: ptgEndSheet  */ 4,
   /* 1c: ptgErr       */ 1,
   /* 1d: ptgBool      */ 1,
   /* 1e: ptgInt       */ 2,
   /* 1f: ptgNum       */ 8,
   /* 20: ptgArray     */ 7,
   /* 21: ptgFunc      */ 2,    // v4 changed
   /* 22: ptgFuncVar   */ 3,    // v4 changed
   /* 23: ptgName      */ 10,
   /* 24: ptgRef       */ 3,
   /* 25: ptgArea      */ 6,
   /* 26: ptgMemArea   */ 6,
   /* 27: ptgMemErr    */ 6,
   /* 28: ptgMemNoMem  */ 6,
   /* 29: ptgMemFunc   */ 2,
   /* 2a: ptgRefErr    */ 3,
   /* 2b: ptgAreaErr   */ 6,
   /* 2c: ptgRefN      */ 3,
   /* 2d: ptgAreaN     */ 6,
   /* 2e: ptgMemAreaN  */ 2,
   /* 2f: ptgMemNoMemN */ 6,
   /* 30: ptgUnused30  */ -1,
   /* 31: ptgUnused31  */ -1,
   /* 32: ptgUnused32  */ -1,
   /* 33: ptgUnused33  */ -1,
   /* 34: ptgUnused34  */ -1,
   /* 35: ptgUnused35  */ -1,
   /* 36: ptgUnused36  */ -1,
   /* 37: ptgUnused37  */ -1,
   /* 38: ptgFuncCE    */ 2,
   /* 39: ptgUnused39  */ -1,
   /* 3a: ptgUnused3a  */ -1,
   /* 3b: ptgV5AreaN   */ -1
};

static const int ExcelV5PTGSize[] = {
   /* 00: ptgUnused00  */ -1,
   /* 01: ptgExp       */ 4,
   /* 02: ptgTbl       */ 4,
   /* 03: ptgAdd       */ 0,
   /* 04: ptgSub       */ 0,
   /* 05: ptgMul       */ 0,
   /* 06: ptgDiv       */ 0,
   /* 07: ptgPower     */ 0,
   /* 08: ptgConcat    */ 0,
   /* 09: ptgLT        */ 0,
   /* 0a: ptgLE        */ 0,
   /* 0b: ptgEQ        */ 0,
   /* 0c: ptgGE        */ 0,
   /* 0d: ptgGT        */ 0,
   /* 0e: ptgNE        */ 0,
   /* 0f: ptgIsect     */ 0,
   /* 10: ptgUnion     */ 0,
   /* 11: ptgRange     */ 0,
   /* 12: ptgUplus     */ 0,
   /* 13: ptgUminus    */ 0,
   /* 14: ptgPercent   */ 0,
   /* 15: ptgParen     */ 0,
   /* 16: ptgMissArg   */ 0,
   /* 17: ptgStr       */ 0,
   /* 18: ptgUnused18  */ -1,
   /* 19: ptgAttr      */ 0,
   /* 1a: ptgSheet     */ 10,   // Not used
   /* 1b: ptgEndSheet  */ 4,    // Not used
   /* 1c: ptgErr       */ 1,
   /* 1d: ptgBool      */ 1,
   /* 1e: ptgInt       */ 2,
   /* 1f: ptgNum       */ 8,
   /* 20: ptgArray     */ 7,
   /* 21: ptgFunc      */ 2,
   /* 22: ptgFuncVar   */ 3,
   /* 23: ptgName      */ 14,   // v5 changed
   /* 24: ptgRef       */ 3,
   /* 25: ptgArea      */ 6,
   /* 26: ptgMemArea   */ 6,
   /* 27: ptgMemErr    */ 6,
   /* 28: ptgMemNoMem  */ 6,
   /* 29: ptgMemFunc   */ 2,
   /* 2a: ptgRefErr    */ 3,
   /* 2b: ptgAreaErr   */ 6,
   /* 2c: ptgRefN      */ 3,    // v5 changed
   /* 2d: ptgAreaN     */ 6,    // v5 changed
   /* 2e: ptgMemAreaN  */ 2,
   /* 2f: ptgMemNoMemN */ 6,
   /* 30: ptgUnused30  */ -1,
   /* 31: ptgUnused31  */ -1,
   /* 32: ptgUnused32  */ -1,
   /* 33: ptgUnused33  */ -1,
   /* 34: ptgUnused34  */ -1,
   /* 35: ptgUnused35  */ -1,
   /* 36: ptgUnused36  */ -1,
   /* 37: ptgUnused37  */ -1,
   /* 38: ptgFuncCE    */ 2,
   /* 39: ptgNameX     */ 24,   // v5 new
   /* 3a: ptgRef3d     */ 17,   // v5 new
   /* 3b: ptgArea3d    */ 20,   // v5 new
   /* 3c: ptgRefErr3d  */ 17,   // v5 new
   /* 3d: ptgAreaErr3d */ 20    // v5 new
};

static const int ExcelV8PTGSize[] = {
   /* 00: ptgUnused00  */ -1,
   /* 01: ptgExp       */ 4,
   /* 02: ptgTbl       */ 4,
   /* 03: ptgAdd       */ 0,
   /* 04: ptgSub       */ 0,
   /* 05: ptgMul       */ 0,
   /* 06: ptgDiv       */ 0,
   /* 07: ptgPower     */ 0,
   /* 08: ptgConcat    */ 0,
   /* 09: ptgLT        */ 0,
   /* 0a: ptgLE        */ 0,
   /* 0b: ptgEQ        */ 0,
   /* 0c: ptgGE        */ 0,
   /* 0d: ptgGT        */ 0,
   /* 0e: ptgNE        */ 0,
   /* 0f: ptgIsect     */ 0,
   /* 10: ptgUnion     */ 0,
   /* 11: ptgRange     */ 0,
   /* 12: ptgUplus     */ 0,
   /* 13: ptgUminus    */ 0,
   /* 14: ptgPercent   */ 0,
   /* 15: ptgParen     */ 0,
   /* 16: ptgMissArg   */ 0,
   /* 17: ptgStr       */ 0,
   /* 18: ptgV8Extended*/ 1,
   /* 19: ptgAttr      */ 0,
   /* 1a: ptgSheet     */ 10,   // Not used
   /* 1b: ptgEndSheet  */ 4,    // Not used
   /* 1c: ptgErr       */ 1,
   /* 1d: ptgBool      */ 1,
   /* 1e: ptgInt       */ 2,
   /* 1f: ptgNum       */ 8,
   /* 20: ptgArray     */ 7,
   /* 21: ptgFunc      */ 2,
   /* 22: ptgFuncVar   */ 3,
   /* 23: ptgName      */ 14,
   /* 24: ptgRef       */ 4,    // v8 changed
   /* 25: ptgArea      */ 8,    // v8 changed
   /* 26: ptgMemArea   */ 6,
   /* 27: ptgMemErr    */ 6,
   /* 28: ptgMemNoMem  */ 6,
   /* 29: ptgMemFunc   */ 2,
   /* 2a: ptgRefErr    */ 4,	// v8 changed (VK)
   /* 2b: ptgAreaErr   */ 6,
   /* 2c: ptgRefN      */ 4,    // v8 changed
   /* 2d: ptgAreaN     */ 8,    // v8 changed
   /* 2e: ptgMemAreaN  */ 2,
   /* 2f: ptgMemNoMemN */ 6,
   /* 30: ptgUnused30  */ -1,
   /* 31: ptgUnused31  */ -1,
   /* 32: ptgUnused32  */ -1,
   /* 33: ptgUnused33  */ -1,
   /* 34: ptgUnused34  */ -1,
   /* 35: ptgUnused35  */ -1,
   /* 36: ptgUnused36  */ -1,
   /* 37: ptgUnused37  */ -1,
   /* 38: ptgFuncCE    */ 2,
   /* 39: ptgNameX     */ 4,    // v8 changed
   /* 3a: ptgRef3d     */ 6,    // v8 changed
   /* 3b: ptgArea3d    */ 10,   // v8 changed
   /* 3c: ptgRefErr3d  */ 6,    // v8 changed
   /* 3d: ptgAreaErr3d */ 10    // v8 changed
};

static const int ExcelV8ExtPTGSize[] = {
   /* 00: ptgxUnused00           */ 4,
   /* 01: ptgxElfLel             */ 4,
   /* 02: ptgxElfRw              */ 4,
   /* 03: ptgxElfCol             */ 4,
   /* 04: ptgxElfRwN             */ 4,
   /* 05: ptgxElfColN            */ 4,
   /* 06: ptgxElfRwV             */ 4,
   /* 07: ptgxElfColV            */ 4,
   /* 08: ptgxElfRwNV            */ 4,
   /* 09: ptgxElfColNV           */ 4,
   /* 0a: ptgxElfRadical         */ 13,
   /* 0b: ptgxElfRadicalS        */ 13,
   /* 0c: ptgxElfRwS             */ 4,
   /* 0d: ptgxElfColS            */ 4,
   /* 0e: ptgxElfRwSV            */ 4,
   /* 0f: ptgxElfColSV           */ 4,
   /* 10: ptgxElfRadicalLel      */ 13,
   /* 11: ptgxElfElf3dRadical    */ 15,
   /* 12: ptgxElfElf3dRadicalLel */ 15,
   /* 13: ptgxElfElf3dRefNN      */ 15,
   /* 14: ptgxElfElf3dRefNS      */ 15,
   /* 15: ptgxElfElf3dRefSN      */ 15,
   /* 16: ptgxElfElf3dRefSS      */ 15,
   /* 17: ptgxElfElf3dRefLel     */ 15,
   /* 18: ptgxElfUnused18        */ -1,
   /* 19: ptgxElfUnused19        */ -1,
   /* 1a: ptgxElfUnused1a        */ -1,
   /* 1b: ptgxNoCalc             */ 1,
   /* 1c: ptgxNoDep              */ 1,
   /* 1d: ptgxSxName             */ 4
};

/*
** ----------------------------------------------------------------------------
** Builtin name categories
** ----------------------------------------------------------------------------
*/
#ifdef EXCEL_ENABLE_FUNCTION_INFO
public const char __far * const ExcelNameCategories[EXCEL_BUILTIN_NAME_CATEGORIES] =
      {"Financial",
       "Date & Time",
       "Math & Trig",
       "Statistical",
       "Lookup & Reference",
       "Database",
       "Text",
       "Logical",
       "Information",
       "Commands",
       "Customizing",
       "Macro Control",
       "DDE/External",
       ""
      };
#endif

/* IMPLEMENTATION */

#ifdef AQTDEBUG
public int ExcelNotExpectedFormat (void)
{
   return (EX_errBIFFCorrupted);
}
#endif

public int ExcelInitialize (void * pGlobals)
{
   /*
   ** Allocate a buffer to hold the Excel records
   */
   if (pExcelRecordBuffer == NULL) 
   {
      byte __far * pBuff;

      if ((pBuff = MemAllocate(pGlobals, MAX_EXCEL_REC_LEN)) == NULL)
      {
         return (EX_errOutOfMemory);
      }
      else
      {
         SetExcelRecordBuffer(pGlobals, pBuff);
      }
   }
   return (EX_errSuccess);
}

public int ExcelTerminate (void * pGlobals)
{
   if (pExcelRecordBuffer != NULL) 
   {
      MemFree (pGlobals, pExcelRecordBuffer);
      SetExcelRecordBuffer(pGlobals, NULL);
   }
   return (EX_errSuccess);
}

public char *ExcelTextGet (EXLHandle handle, TEXT t)
{
   WBP pWorkbook = (WBP)handle;

   // Works with workbook or worksheet

   return (TextStorageGet(pWorkbook->textStorage, t));
}

public TEXT ExcelTextPut (void * pGlobals, EXLHandle handle, char __far *s, int cbString)
{
   WBP pWorkbook = (WBP)handle;

   // Works with workbook or worksheet

   return (TextStoragePut(pGlobals, pWorkbook->textStorage, s, cbString));
}

static const int ErrorTranslateTable[] =
   {
   EX_errSuccess,              /* BF_errSuccess              */
   EX_errBIFFOutOfFileHandles, /* BF_errOutOfFileHandles     */
   EX_errBIFFFileAccessDenied, /* BF_errFileAccessDenied     */
   EX_errBIFFPathNotFound,     /* BF_errPathNotFound         */
   EX_errBIFFFileNotFound,     /* BF_errFileNotFound         */
   EX_errBIFFIOError,          /* BF_errIOError              */
   EX_errOutOfMemory,          /* BF_errOutOfMemory          */
   EX_errOLEInitializeFailure, /* BF_errOLEInitializeFailure */
   EX_errOLENotCompoundFile,   /* BF_errOLENotCompoundFile   */
   EX_errBIFFCorrupted,        /* BF_errOLEStreamNotFound    */
   EX_errGeneralError,         /* BF_errOLEStreamAlreadyOpen */
   EX_errBIFFCreateFailed,     /* BF_errCreateFailed         */
   EX_errBIFFDiskFull,         /* BF_errDiskFull             */
   EX_errGeneralError,         /* BF_errNoOpenStorage        */
   EX_errBIFFCorrupted         /* BF_errEndOfFile            */
   };

public int ExcelTranslateBFError (int rc)
{
   return (ErrorTranslateTable[abs(rc)]);
}

public const int __far *ExcelPTGSize (int version)
{
   if (version == versionExcel3)
      return (ExcelV3PTGSize);
   else if (version == versionExcel4)
      return (ExcelV4PTGSize);
   else if (version == versionExcel5)
      return (ExcelV5PTGSize);
   else
      return (ExcelV8PTGSize);
}

public const int __far *ExcelExtPTGSize (int version)
{
   return (ExcelV8ExtPTGSize);
}

public int ExcelConvertToOurErrorCode (int excelEncoding)
{
   int value;

   #define errorNULL   0x00
   #define errorDIV0   0x07
   #define errorVALUE  0x0F
   #define errorREF    0x17
   #define errorNAME   0x1D
   #define errorNUM    0x24
   #define errorNA     0x2A

   if      (excelEncoding == errorNULL)  value = cellErrorNULL;
   else if (excelEncoding == errorDIV0)  value = cellErrorDIV0;
   else if (excelEncoding == errorVALUE) value = cellErrorVALUE;
   else if (excelEncoding == errorREF)   value = cellErrorREF;
   else if (excelEncoding == errorNAME)  value = cellErrorNAME;
   else if (excelEncoding == errorNUM)   value = cellErrorNUM;
   else                                  value = cellErrorNA;

   return (value);
}

public int ExcelConvertFromOurErrorCode (int ourEncoding)
{
   int value;

   if      (ourEncoding == cellErrorNULL)  value = errorNULL;
   else if (ourEncoding == cellErrorDIV0)  value = errorDIV0;
   else if (ourEncoding == cellErrorVALUE) value = errorVALUE;
   else if (ourEncoding == cellErrorREF)   value = errorREF;
   else if (ourEncoding == cellErrorNAME)  value = errorNAME;
   else if (ourEncoding == cellErrorNUM)   value = errorNUM;
   else                                    value = errorNA;

   return (value);
}

#endif // !VIEWER

/* end EXCEL.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiexfmt.h ===
/*
** File: EXFORMAT.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**       Main interface to user custom formats
**
** Edit History:
**  01/01/91  kmh  Created.
*/


/* INCLUDE TESTS */
#define EXFORMAT_H


/* DEFINITIONS */

#ifdef __cplusplus
   extern "C" {
#endif

typedef byte __far *FMTHANDLE;

/*
** The maximum number of characters in a format string passed to
** FMTStoreFormat and the size of the buffer passed to FMTRetrieveFormat
*/
#define MAX_FORMAT_IMAGE 255

/*
** Initialize the custom format database
*/
extern int FMTInitialize (void * pGlobals);


/*
** Control panel settings.  Needed for parsing (to detect currency) and for
** formatting (decimal sep, thousand sep, ...)
*/
#define MAX_CURRENCY_SYMBOL_LEN 8
#define MAX_AMPM_STRING_LEN     8
#define DAYS_PER_WEEK           7
#define MONTHS_PER_YEAR         12
#define MAX_FORMAT_STRING_LEN   64

typedef struct {
   int          iCountry;
   char         numberDecimalSeparator;
   char         numberThousandSeparator;
   int          numberDigits;
   int          numbersHaveLeadingZeros;

   char         currencySymbol[MAX_CURRENCY_SYMBOL_LEN + 1];
   int          currencyPosFormat;
   int          currencyNegFormat;
   int          currencyDigits;
   char         currencyDecimalSeparator;
   char         currencyThousandSeparator;

   int          iTime;                               /* 0: 12hour  1: 24hour */
   int          iTLZero;                             /* 0: h  1: hh */
   int          iAMPMPos;                            /* 0: AMPM suffix  1: AMPM prefix */
   char         timeSeparator;
   char         dateSeparator;
   char         AMString[MAX_AMPM_STRING_LEN + 1];
   char         PMString[MAX_AMPM_STRING_LEN + 1];

   char         datePicture[MAX_FORMAT_STRING_LEN + 1];

   char  __far *shortDayName[DAYS_PER_WEEK];         /* sun .. sat */
   char  __far *fullDayName[DAYS_PER_WEEK];
   short        cbShortDayName[DAYS_PER_WEEK];
   short        cbFullDayName[DAYS_PER_WEEK];

   char  __far *shortMonthName[MONTHS_PER_YEAR];     /* jan .. dec */
   char  __far *fullMonthName[MONTHS_PER_YEAR];
   short        cbShortMonthName[MONTHS_PER_YEAR];
   short        cbFullMonthName[MONTHS_PER_YEAR];

   BOOL         monthAndDayNamesOnHeap;
} CP_INFO;

/*
** WIN32
**    When the FMTControlPanelGetSettings function is called the day and month
**    names are retrieved from Windows.
**
** WIN16
**    If the day and month name arrays are empty, the English names are stored
**    into the structure
*/
extern int FMTControlPanelGetSettings (void * pGlobals, CP_INFO __far *pIntlInfo);

extern int FMTControlPanelFreeSettings (void * pGlobals, CP_INFO __far *pIntlInfo);


/*
** Parse and add a new format to the database
**
** If the format is parsed sucessfully FMT_OK is returned,
** otherwise an error code is returned.
*/
extern int FMTStoreFormat
      (void * pGlobals, char __far *formatString, CP_INFO __far *pIntlInfo, FMTHANDLE __far *hFormat);


/*
** Remove a format string from the database
*/
extern int FMTDeleteFormat (void * pGlobals, FMTHANDLE hFormat);


/*
** Return a string composed of the quoted text in the format.
** Separate the various strings using the characters in pSep.
*/
extern int FMTRetrieveQuotedStrings
      (FMTHANDLE hFormat, char __far *pBuffer, char __far *pSep);

/*
** Return the type of a format for a given value type
*/
typedef enum {
   FMTGeneral,
   FMTDate,
   FMTTime,
   FMTDateTime,
   FMTNumeric,
   FMTCurrency,
   FMTText,
   FMTNone
   } FMTType;

typedef enum {
   FMTValuePos,
   FMTValueNeg,
   FMTValueZero,
   FMTValueText
   } FMTValueType;

extern FMTType FMTFormatType (FMTHANDLE hFormat, FMTValueType value);

/*
** Excel V5 does not store all the format strings for builtin formats.
** They are identified by a code number.  If the ifmt passed to FMTV5FormatType
** is not a builtin one, FMTNone is returned
*/
extern FMTType FMTV5FormatType (int ifmt);

#define EXCEL5_FIRST_BUILTIN_FORMAT  0
#define EXCEL5_LAST_BUILTIN_FORMAT   58
#define EXCEL5_BUILTIN_FORMAT_COUNT (EXCEL5_LAST_BUILTIN_FORMAT - EXCEL5_FIRST_BUILTIN_FORMAT + 1)
#define EXCEL5_FIRST_CUSTOM_FORMAT   164

/*
** Display a number according to a format
*/
extern int FMTDisplay (
           void __far *pValue,           /* Value to format               */
           BOOL       isIntValue,        /* type of value, long or double */
           CP_INFO    __far *pIntlInfo,  /* International support         */
           FMTHANDLE  hFormat,           /* compiled format string        */
           int        colWidth,          /* cell width in pixels          */
           char __far *pResult           /* converted string              */
           );

/*
** Possible error codes returned by the above functions
*/
#define FMT_errSuccess                  0
#define FMT_errOutOfMemory             -2

#define FMT_errDisplayFailed           -100    // FMTDisplay

#define FMT_errEmptyFormatString       -101    // FMTStoreFormat
#define FMT_errUnterminatedString      -102
#define FMT_errColumnFill              -103
#define FMT_errTooManySubFormats       -104
#define FMT_errInvalidNumericFormat    -105
#define FMT_errInvalidFormat           -106

#define FMT_errEOS                     -107    // Internal error

#ifdef __cplusplus
   }
#endif

/* end EXFORMAT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\html\source\scriptag.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       scripttag.cxx
//
//  Contents:   Parsing algorithm for script tag in Html
//
//  Classes:    CScriptTag
//
//  History:    12/20/97   bobp      Rewrote; filter embedded URLs as links,
//                                   instead of filtering raw body text.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop



//+-------------------------------------------------------------------------
//
//  Method:     CEmbeddedURLTag::CEmbeddedURLTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CEmbeddedURLTag::CEmbeddedURLTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream)
{
    _awszPropSpec[0] = 0;
}

void
CEmbeddedURLTag::Reset (void)
{
    _awszPropSpec[0] = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEmbeddedURLTag::ReturnChunk
//
//  Synopsis:   Check if the client wants this FULLPROPSPEC, and if so then
//                              alloc a ChunkID and set up the rest of the STAT_CHUNK
//                              to return it.
//
//  Arguments:  [pStat] -- chunk information returned here
//
//  Returns:    TRUE if returning data, else FALSE
//
//--------------------------------------------------------------------------
BOOL
CEmbeddedURLTag::ReturnChunk( STAT_CHUNK *pStat )
{
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetCurrentLocale();
    pStat->breakType = CHUNK_EOS;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

        _nCharsReturned = 0;

        // _sURL contains data to return, but does the client want this property?

        // Set up the FULLPROPSPEC

        PTagEntry pTE = GetTagEntry();
        pTE->GetFullPropSpec (pStat->attribute);

        // Does the client want this FULLPROPSPEC?

        if ( _sURL.GetLength() != 0 &&
                 (_htmlIFilter.FFilterProperties() ||
                  _htmlIFilter.IsMatchProperty (pStat->attribute)) )
        {
                // Yes, set up to return it
                // (Tells client to call GetText if they want it)

                pStat->idChunk = _htmlIFilter.GetNextChunkId();
                pStat->idChunkSource = pStat->idChunk;

                return TRUE;
        }

        _sURL.Empty();
        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEmbeddedURLTag::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//                              Find a URL and set up to return it.
//
//                              Result is one of:
//                              Found a URL:
//                                      - set up to return it
//                                      - parse point follows last char of URL
//                              Found element end tag:
//                                      - parse point follows ">" of the end tag
//                                      - switch to next element
//                              Found EOF:
//                                      - switch to next element
//
//  Arguments:  [pStat] -- chunk information returned here
//
//  Invariants: On entry, parse point is one of:
//                              - after ">" of the element start tag
//                              - after the last char of an embedded URL
//
//                              On return, parse point is one of:
//                              - after last char of embedded URL (returning S_OK)
//                              - after ">" of end tag  (returning SwitchToNextHtmlElement)
//
//--------------------------------------------------------------------------

SCODE CEmbeddedURLTag::GetChunk( STAT_CHUNK * pStat )
{
        // If there is data to return and the client wants it, set up state
        // to return it.  Otherwise, call through to the handler for the
        // next content element.

        if ( ExtractURL( pStat ) == TRUE )
                return S_OK;

        return SwitchToNextHtmlElement( pStat );
}


//+-------------------------------------------------------------------------
//
//  Method:     CEmbeddedURLTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//                              Return the data from _sURL.
//
//                              This does not affect the parse, and it does not matter
//                              whether or not the client actually calls GetText for
//                              a given chunk.
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CEmbeddedURLTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
        if ( _nCharsReturned < _sURL.GetLength() )
        {
                // There is data to return to the client
                
                ULONG nCopied = min(*pcwcOutput, _sURL.GetLength() - _nCharsReturned);

                RtlCopyMemory( awcBuffer, &((LPCTSTR)_sURL)[_nCharsReturned], 
                                nCopied * sizeof(WCHAR));
                _nCharsReturned += nCopied;
                *pcwcOutput = nCopied;

                FixPrivateChars ( awcBuffer, nCopied);

                if ( _nCharsReturned < _sURL.GetLength() )
                        return S_OK;
        else
            return FILTER_S_LAST_TEXT;
        }
        else
        return FILTER_E_NO_MORE_TEXT;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEmbeddedURLTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//                              Extract and set up to return a URL attribute.
//
//                              This version filters only the src=URL link attribute,
//                              not the body of the script element.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
// Invariants:  On entry, the parse point follows the start tag name,
//                              e.g. follows "<script".
//
//                              On return, the parse point is one of:
//                              - After ">" of the element start tag (returning S_OK)
//                              - After last char of an embedded URL (returning GetChunk)
//                              - After ">" of the element end tag (returning GetChunk)
//
//--------------------------------------------------------------------------

BOOL CEmbeddedURLTag::InitStatChunk( STAT_CHUNK *pStat )
{
        // Ignore a stray end tag

        if ( IsStartToken() == FALSE )
                return FALSE;

    //
        // Read the Src= attribute to filter the URL value as a link.
    //
    _scanner.ReadTagIntoBuffer();

    WCHAR *_pwcValueBuf = NULL;
    unsigned _cValueChars = 0;
        _scanner.ScanTagBuffer( L"src", _pwcValueBuf, _cValueChars );

        // Parse point now follows ">" of the start tag

        if ( _cValueChars != 0)
        {
                if ( _cValueChars > _sURL.GetMaxLen() - 1 )
                        _cValueChars = _sURL.GetMaxLen() - 1;

                _sURL.Assign (_pwcValueBuf, 0, _cValueChars);

                // If the client wants this property, set up to return it

                if ( ReturnChunk( pStat ) == TRUE)
                        return TRUE;
        }

        // No start tag attribute to return -- look for embedded URL in body

        return ExtractURL( pStat );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStyleTag::ExtractURL
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//                              Scan the stylesheet body text for an embedded URL.
//
//                              If found, copy it to _sURL, leave the parse point
//                              following the URL and return TRUE.
//
//                              If not, leave the parse point following the </style>
//                              tag and return FALSE.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------
BOOL
CStyleTag::ExtractURL ( STAT_CHUNK *pStat )
{
    // 1 as second argument in GetStylesheetEmbeddedURL indicates that
    // it is called to look for StyleEmbeddedURL and not for Script

    while (_scanner.GetStylesheetEmbeddedURL( _sURL, TRUE ) == TRUE)
    {
            if ( ReturnChunk( pStat ) == TRUE )
                    return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CScriptTag::ExtractURL
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//                              Scan the script body text for an embedded URL.
//
//                              If found, copy it to _sURL, leave the parse point
//                              following the URL and return TRUE.
//
//                              If not, leave the parse point following the </script>
//                              tag and return FALSE.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------
BOOL
CScriptTag::ExtractURL ( STAT_CHUNK *pStat )
{
        while (_scanner.GetScriptEmbeddedURL( _sURL ) == TRUE)
        {
                if ( ReturnChunk( pStat ) == TRUE )
                        return TRUE;
        }

        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAspTag::CAspTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CAspTag::CAspTag( CHtmlIFilter& htmlIFilter,
                    CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAspTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//                              Scan off and ignore a <% ... %> tag.
//                              The "<%" has already been read.
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CAspTag::InitStatChunk( STAT_CHUNK *pStat )
{
        _scanner.EatAspCode();

        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiextch.h ===
/* extchar.h - Extended character set support include file. */

// This include file contains definitions for generic data types used to
// support extended character set.
//
// XCHAR		- generic character
// LPXCHAR	- far pointer to generic character
// PXCHAR	- pointer to generic character

#ifndef EXTCHAR_H
#define EXTCHAR_H

/***************************************************************************/
/*																									*/
/*	  Extended character set support build-specific									*/
/*																									*/
/***************************************************************************/

#ifdef PCODE
#define const
#endif

#ifdef EXTCHAR

/*--- type declarations ---*/
typedef unsigned short XCHAR;
#define XCharLast  32766
#define XUCharLast 65535
#define cbXchar    2


/***************************************************************************/
/*																									*/
/*	  Normal build-specific																	*/
/*																									*/
/***************************************************************************/

#else // !EXTCHAR

/*--- type declarations ---*/
typedef unsigned char XCHAR;
#define XCharLast  127
#define XUCharLast 255
#define cbXchar    1

#endif // !EXTCHAR

/***************************************************************************/
/*																									*/
/*	  Common definitions/declarations													*/
/*																									*/
/***************************************************************************/

#ifdef MACORNT
typedef XCHAR *LPXCHAR;
typedef const XCHAR *LPCXCHAR;
#else
typedef XCHAR far *LPXCHAR;
typedef const XCHAR far *LPCXCHAR;
#endif
typedef XCHAR *PXCHAR;
typedef const XCHAR *PCXCHAR;

#ifdef PCODE
#undef const
#endif

// ###########################################################################
// ----- SCRIPT DEFINITIONS/DECLARATIONS -------------------------------------
// ###########################################################################

typedef int	SCPT;

#define	scptSystem 255
#define	scptCurrent 254

#define	scptWinAnsi		0
#define	scptMacRoman	1
#define	scptWinShiftJIS	2
#define	scptMacShiftJIS	3
#define	scptWinCyrillic	4
#define	scptWinGreek	5
#define	scptWinEEurop	6
#define	scptWinTurkish	7
#define	scptWinHebrew	8
#define	scptWinArabi	9
#define scptWinKorea	10
#define scptWinTaiwan	11
#define scptWinChina	12

#define fSpecialEncoding 1

#ifdef FAREAST

#ifdef JAPAN
#define scptStrMan	scptWinShiftJIS

#ifdef MAC
#define scptDefault scptMacShiftJIS
#else
#define scptDefault scptWinShiftJIS
#endif // MAC
#endif // JAPAN

#ifdef TAIWAN
#ifdef CHINA
#define scptDefault scptWinChina
#define scptStrMan	scptDefault
#else // !CHINA
#define scptDefault scptWinTaiwan
#define scptStrMan	scptDefault
#endif // !CHINA
#endif // TAIWAN

#ifdef KOREA
#define scptDefault scptWinKorea
#define scptStrMan	scptDefault
#endif // KOREA

#else

#ifdef MAC
#define scptDefault scptMacRoman
#else
#define scptDefault scptWinANSI
#endif //MAC
#define scptStrMan	scptDefault

#endif //FAREAST

// ###########################################################################
// ----- SCRIPT MANAGEMENT ONLY ENABLED FOR MAC JAPAN BUILD CURRENTLY --------
// ###########################################################################
#if defined (MAC) && defined (FAREAST) && defined (JAPAN)
__inline SCPT ScptFromGrf(int grf) { \
	SCPT scpt = (grf & 0xff00) >> 8; \
	return (scpt == scptSystem ? scptDefault : scpt); \
	};
#else
#define ScptFromGrf(grf)	scptDefault
#endif // defined (MAC) && defined (FAREAST) && defined (JAPAN)

#endif // EXTCHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtcp.c ===
/*
** File: FMTCP.C
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/94  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"
   #include "dmifmtcp.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
   #include "fmtcp.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

static const char __far * const CurrencyPosFormatPre[] =
       {"\"$\"", "", "\"$\" ", ""};
static const char __far * const CurrencyPosFormatPost[] =
       {"", "\"$\"", "", " \"$\""};

static const char __far * const CurrencyNegFormatPre[] =
       {"(\"$\"", "-\"$\"", "\"$\"-", "\"$\"", "(",  "-", "", "",
        "-", "-\"$\" ", "", "\"$\" ", "\"$\" -", "", "(\"$\" ", "("};

static const char __far * const CurrencyNegFormatPost[] =
       {")",  "", "", "-", "\"$\")", "\"$\"", "-\"$\"", "\"$\"-", " \"$\"",
        "", " \"$\"-", "-", "", "- \"$\"", ")", " \"$\")"};


/* IMPLEMENTATION */

public uns ControlPanelBuildFormats
      (CP_INFO __far *pIntlInfo, CP_FMTS __far *pStdFormats)
{
   char formatBody[MAX_FORMAT_STRING_LEN + 1];
   char temp[MAX_FORMAT_STRING_LEN + 1];
   char __far *pTemp;
   char __far *pResult;
   int  cbBody, i, cbCurrencySymbol;

   /*
   ** Build date and time formats
   */
   strcpy (pStdFormats->date, pIntlInfo->datePicture);

   pStdFormats->time[0] = EOS;

   if ((pIntlInfo->iTime == 0) && (pIntlInfo->iAMPMPos == 1))
      strcat (pStdFormats->time, "AM/PM ");

   temp[0] = pIntlInfo->timeSeparator;
   temp[1] = EOS;

   strcat (pStdFormats->time, (pIntlInfo->iTLZero == 0) ? "h" : "hh");
   strcat (pStdFormats->time, temp);
   strcat (pStdFormats->time, "mm");
   strcat (pStdFormats->time, temp);
   strcat (pStdFormats->time, "ss");

   if ((pIntlInfo->iTime == 0) && (pIntlInfo->iAMPMPos == 0))
      strcat (pStdFormats->time, " AM/PM");

   strcpy (pStdFormats->dateTime, pStdFormats->date);
   strcat (pStdFormats->dateTime, " ");
   strcat (pStdFormats->dateTime, pStdFormats->time);

   /*
   ** Build currency format
   */
   if (pIntlInfo->numbersHaveLeadingZeros) {
      if (pIntlInfo->currencyThousandSeparator != EOS)
         strcpy (formatBody, "#,##0");
      else
         strcpy (formatBody, "0");
   }
   else {
      if (pIntlInfo->currencyThousandSeparator != EOS)
         strcpy (formatBody, "#,###");
      else
         strcpy (formatBody, "#");
   }

   if (pIntlInfo->currencyDigits > 0) {
      cbBody = strlen(formatBody);
      formatBody[cbBody] = '.';

      for (i = 0; i < pIntlInfo->currencyDigits; i++)
         formatBody[cbBody + i + 1] = '0';

      formatBody[cbBody + pIntlInfo->currencyDigits + 1] = EOS;
   }

   temp[0] = EOS;

   if (pIntlInfo->currencySymbol[0] != EOS)
      strcat (temp, CurrencyPosFormatPre[pIntlInfo->currencyPosFormat]);

   strcat (temp, formatBody);

   if (pIntlInfo->currencySymbol[0] != EOS)
      strcat (temp, CurrencyPosFormatPost[pIntlInfo->currencyPosFormat]);

   strcat (temp, ";");

   if (pIntlInfo->currencySymbol[0] != EOS)
      strcat (temp, CurrencyNegFormatPre[pIntlInfo->currencyNegFormat]);

   strcat (temp, formatBody);

   if (pIntlInfo->currencySymbol[0] != EOS)
      strcat (temp, CurrencyNegFormatPost[pIntlInfo->currencyNegFormat]);

   if ((pIntlInfo->currencySymbol[0] != '$') || (pIntlInfo->currencySymbol[1] != EOS))
   {
      cbCurrencySymbol = strlen(pIntlInfo->currencySymbol);

      pTemp = temp;
      pResult = pStdFormats->currency;
      while (*pTemp != EOS) {
         if (*pTemp == '$') {
            strcpy (pResult, pIntlInfo->currencySymbol);
            pResult += cbCurrencySymbol;
         }
         else {
            *pResult++ = *pTemp;
         }
         pTemp++;
      }
      *pResult = EOS;
   }
   else {
      strcpy (pStdFormats->currency, temp);
   }

   /*
   ** Build numeric format
   */
   if (pIntlInfo->numbersHaveLeadingZeros) {
      if (pIntlInfo->numberThousandSeparator != EOS)
         strcpy (formatBody, "#,##0");
      else
         strcpy (formatBody, "0");
   }
   else {
      if (pIntlInfo->numberThousandSeparator != EOS)
         strcpy (formatBody, "#,###");
      else
         strcpy (formatBody, "#");
   }

   if (pIntlInfo->numberDigits > 0) {
      cbBody = strlen(formatBody);
      formatBody[cbBody] = '.';

      for (i = 0; i < pIntlInfo->numberDigits; i++)
         formatBody[cbBody + i + 1] = '0';

      formatBody[cbBody + pIntlInfo->numberDigits + 1] = EOS;
   }

   strcpy (pStdFormats->numericSmall, formatBody);
   strcpy (pStdFormats->numericBig, "0.00E+00");

   return (FMT_errSuccess);
}

#endif // !VIEWER

/* end FMTCP.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtcp.h ===
/*
** File: FMTCP.H
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes:
**       Build Excel compatable format strings from the control panel settings
**
** Edit History:
**  01/01/91  kmh  Created.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define FMTCP_H

#ifndef EXFORMAT_H
#error  Include exformat.h before fmtcp.h
#endif


/* DEFINITIONS */

/*
** Standard formats for currency, numbers, date, and times
*/
typedef struct {
   char    currency[MAX_FORMAT_STRING_LEN + 1];
   char    numericSmall[MAX_FORMAT_STRING_LEN + 1];
   char    numericBig[MAX_FORMAT_STRING_LEN + 1];
   char    dateTime[MAX_FORMAT_STRING_LEN + 1];
   char    date[MAX_FORMAT_STRING_LEN + 1];
   char    time[MAX_FORMAT_STRING_LEN + 1];
} CP_FMTS;

extern uns ControlPanelBuildFormats (CP_INFO __far *pIntlInfo, CP_FMTS __far *pStdFormats);

#endif // !VIEWER
/* end FMTCP.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtdb.c ===
/*
** File: EXFMTDB.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/94  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"
   #include "dmifmtdb.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
   #include "exfmtdb.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */

void SetCustomFormatDatabase(void * pGlobals, void *);
void * GetCustomFormatDatabase(void * pGlobals);

/* MODULE DATA, TYPES AND MACROS  */

//public FIP CustomFormatDatabase;


/* IMPLEMENTATION */


/* Initialize the custom format database */
public int FMTInitialize (void * pGlobals)
{
   SetCustomFormatDatabase(pGlobals, NULL); //CustomFormatDatabase = NULL;
   return (FMT_errSuccess);
}


/* Remove a format string from the database */
public int FMTDeleteFormat (void * pGlobals, FMTHANDLE hFormat)
{
   FIP  pFormat = (FIP)hFormat;
   FIP  pPrevious, pCurrent;
   NIP  subFormat;
   int  subIdx;

   // If hFormat is null, don't bother to go further.
	if (!pFormat)
	   return (FMT_errSuccess);

   for (subIdx = 0; subIdx < pFormat->subFormatCount; subIdx++)
   {
      if ((subFormat = pFormat->subFormat[subIdx]) != NULL) {
         #ifdef WIN32
         if ((subFormat->tag == tagDATE_TIME) && (((DTIP)subFormat)->pOSFormat != NULL))
            MemFree (pGlobals, ((DTIP)subFormat)->pOSFormat);
         #endif

         MemFree (pGlobals, subFormat);
      }
   }

   //pCurrent  = CustomFormatDatabase;
   pCurrent  = (FIP)GetCustomFormatDatabase(pGlobals);

   pPrevious = NULL;
   while (pCurrent != NULL) {
      if (pCurrent == pFormat)
         break;

      pPrevious = pCurrent;
      pCurrent = pCurrent->next;
   }

   if (pCurrent != NULL) {
      if (pPrevious == NULL)
      {
         //CustomFormatDatabase = pCurrent->next;
         SetCustomFormatDatabase(pGlobals, (void*)pCurrent->next);
      }
      else
         pPrevious->next = pCurrent->next;

      MemFree (pGlobals, pCurrent);
   }
   return (FMT_errSuccess);
}


/* Parse and add a new format to the database */
public int FMTStoreFormat
      (void * pGlobals, char __far *formatString, CP_INFO __far *pIntlInfo, FMTHANDLE __far *hFormat)
{
   int  result;
   FIP  pFormat;

   if ((pFormat = MemAllocate(pGlobals, sizeof(FormatInfo) + strlen(formatString))) == NULL)
      return (FMT_errOutOfMemory);

   strcpy (pFormat->formatString, formatString);

   if ((result = FMTParse(pGlobals, formatString, pIntlInfo, pFormat)) != FMT_errSuccess) {
      MemFree (pGlobals, pFormat);
      return (result);
   }

   pFormat->next = (FIP)GetCustomFormatDatabase(pGlobals);
   //CustomFormatDatabase = pFormat;
   SetCustomFormatDatabase(pGlobals, (void*)pFormat); 

   *hFormat = (FMTHANDLE)pFormat;
   return (FMT_errSuccess);
}


/* Return part of the printable representation of the format string */
public int FMTRetrieveQuotedStrings
      (FMTHANDLE hFormat, char __far *pBuffer, char __far *pSep)
{
   FIP pFormat = (FIP)hFormat;

   FMTUnParseQuotedParts (pBuffer, pSep, pFormat);
   return (FMT_errSuccess);
}

/*
** Return the type of a format for a given value type
*/
public FMTType FMTFormatType (FMTHANDLE hFormat, FMTValueType value)
{
   FIP  pFormat = (FIP)hFormat;
   NIP  subFormat;
   DTIP pDateFormat;
   int  subFormatToUse;

   if (pFormat == NULL)
      return (FMTNone);

   if (pFormat->subFormatCount == 1)
      subFormatToUse = 0;

   else if (pFormat->subFormatCount == 2)
      subFormatToUse = (value == FMTValueNeg) ? 1 : 0;

   else if (pFormat->subFormatCount == 3) {
      if (value == FMTValueZero)
         subFormatToUse = 2;
      else if (value == FMTValueNeg)
         subFormatToUse = 1;
      else
         subFormatToUse = 0;
   }

   else {
      if (value == FMTValueText)
         subFormatToUse = 3;
      else if (value == FMTValueZero)
         subFormatToUse = 2;
      else if (value == FMTValueNeg)
         subFormatToUse = 1;
      else
         subFormatToUse = 0;
   }

   if ((subFormat = pFormat->subFormat[subFormatToUse]) != NULL) {
      if (subFormat->tag == tagGENERAL)
         return (FMTGeneral);

      else if (subFormat->tag == tagTEXT)
         return (FMTText);

      else if (subFormat->tag == tagDATE_TIME) {
         pDateFormat = (DTIP)subFormat;

         if (((pDateFormat->formatNeeds & dtMASK_DATE) != 0) && ((pDateFormat->formatNeeds & dtMASK_TIME) == 0))
            return (FMTDate);
         else if (((pDateFormat->formatNeeds & dtMASK_DATE) == 0) && ((pDateFormat->formatNeeds & dtMASK_TIME) != 0))
            return (FMTTime);
         else
            return (FMTDateTime);
      }

      else {
         if (subFormat->currencyEnable)
            return (FMTCurrency);
         else
            return (FMTNumeric);
      }
   }

   return (FMTNone);
}

#endif // !VIEWER

/* end EXFMTDB.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtdo.c ===
/*
** File: EXFMTDO.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/91  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#include "float_pt.h"
#endif

#include <stdlib.h>
#include <string.h>
#include <stdio.h>    /* For sprintf */
#include <math.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"
   #include "dmifmtdb.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
   #include "exfmtdb.h"
#endif

#ifdef EXCEL
   #ifdef FILTER
      #include "dmixlcfg.h"
   #else
      #include "excelcfg.h"
   #endif
#endif

#ifdef LOTUS
   #include "lotuscfg.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

#define UPCASE(c) ((((c) >= 'a') && ((c) <= 'z')) ? ((char)((c) - 32)) : (c))
#define LCCASE(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((char)((c) + 32)) : (c))
#define ABS(x)    (((x) < 0) ? -(x) : (x))

#ifdef INSERT_FILL_MARKS
   #define FILL_MARK_CHAR  0x01
   static char FillMark[2] = {FILL_MARK_CHAR, EOS};
#endif


/* IMPLEMENTATION */

private void AppendNM
       (char __far * __far *dest, char __far * source, int __far *count)
{
   char __far *d;

   d = *dest;
   while (*source != EOS)
   {
      #ifdef DBCS
         if (IsDBCSLeadByte(*source))
         {
            if (*count == 1)
               break;
            *d++ = *source++;
            count--;
         }
      #endif
      if ((*count -= 1) < 0) break;
      *d++ = *source++;
   }
   *dest = d;
}

private void AppendUC
       (char __far * __far *dest, char __far * source, int __far *count)
{
   char __far *d;

   d = *dest;
   while (*source != EOS)
   {
      if ((*count -= 1) < 0) break;
      *d++ = UPCASE(*source);
      #ifdef DBCS
         //
         // note: cannot uppercase dbcs second bytes
         //
         if (IsDBCSLeadByte(*source))
         {
            if (*count == 1)
            {
               d--;
               break;
            }
            source++;
            *d++ = *source;
            count--;
         }
      #endif
      source++;
   }
   *dest = d;
}

private void AppendLC
       (char __far * __far *dest, char __far *source, int __far *count)
{
   char __far *d;

   d = *dest;
   while (*source != EOS)
   {
      if ((*count -= 1) < 0) break;
      *d++ = LCCASE(*source);
      #ifdef DBCS
         //
         // note: cannot lowercase dbcs second bytes
         //
         if (IsDBCSLeadByte(*source))
         {
            if (*count == 1)
            {
               d--;
               break;
            }
            source++;
            *d++ = *source;
            count--;
         }
      #endif
      source++;
   }
   *dest = d;
}

private void AppendNum (char __far * __far *dest, uns long x, int __far *count)
{
   char  temp[32];

   _ltoa (x, temp, 10);
   AppendLC(dest, temp, count);
}

private void AppendNum2 (char __far * __far *dest, uns x, int __far *count)
{
   char   temp[16];
   char __far *d;

   if (x < 10) {
      if ((*count -= 1) < 0) return;
      d = *dest;  *d++ = '0'; *dest = d;
   }

   _ltoa (x, temp, 10);
   AppendLC(dest, temp, count);
}

/*--------------------------------------------------------------------------*/

private BOOL FormatText (
             double     value,            /* Value to format          */
             FIP        pFormat,          /* compiled format string   */
             NIP        pSubFormat,       /* compiled format string   */
             CP_INFO    __far *pIntlInfo, /* International support    */
             char __far *pOutput          /* converted string         */
             )
{
   TIP   textInfo;
   uns   i;
   char  __far *source, __far *dest;
   int   count;
   int   offset, srcCount, pos;
   char  generalImage[32];

   textInfo = (TIP)pSubFormat;

   dest = pOutput;
   count = MAX_FORMAT_IMAGE;

   /*
   ** All tokens marked typeCOMMON in exfmtprs must be handled here
   */
   for (i = 0; i < textInfo->formatCodeCount; i++) {
      switch (textInfo->formatCodes[i].code)
      {
         case QUOTED_INSERT:
            offset = textInfo->formatCodes[i].info1 + 1;
            srcCount = textInfo->formatCodes[i].info2 - 2;
            source = &(pFormat->formatString[offset]);
            for (pos = 0; pos < srcCount; pos++) {
               #ifdef DBCS
                  if (IsDBCSLeadByte(*source)) {
                     if ((count -= 2) < 0) break;
                     *dest++ = *source++;
                     *dest++ = *source++;
                     pos++;
                  }
                  else {
                     if ((count -= 1) < 0) break;
                     *dest++ = *source++;
                  }
               #else
                  if ((count -= 1) < 0) break;
                  *dest++ = *source++;
               #endif
            }
            break;

         case ESC_CHAR_INSERT:
         case NO_ESC_CHAR_INSERT:
            #ifdef DBCS
               if (textInfo->formatCodes[i].info2 != 0) {
                  if ((count -= 2) < 0) break;
                  *dest++ = textInfo->formatCodes[i].info1;
                  *dest++ = textInfo->formatCodes[i].info2;
               }
               else {
                  if ((count -= 1) < 0) break;
                  *dest++ = textInfo->formatCodes[i].info1;
               }
            #else
               if ((count -= 1) < 0) break;
               *dest++ = textInfo->formatCodes[i].info1;
            #endif
            break;

         case COLUMN_FILL:
            #ifdef INSERT_FILL_MARKS
               AppendLC(&dest, FillMark, &count);
            #endif
            break;

         case COLOR_SET:
         case CONDITIONAL:
            break;

         case UNDERLINE:
            break;

         case AT_SIGN:
            strcpy (generalImage, "<General>");

            #ifdef ENABLE_PRINTF_FOR_GENERAL
               sprintf (generalImage, "%g", value);
            #endif
            AppendNM(&dest, generalImage, &count);
            break;

         case DIGIT0:
            AppendLC(&dest, "0", &count);
            break;

         case DIGIT_QM:
            AppendLC(&dest, "?", &count);
            break;

         case DECIMAL_SEPARATOR:
            AppendLC(&dest, ".", &count);
            break;

         default:
            ASSERTION(FALSE);
      }
      if (count < 0) break;
   }

   *dest = EOS;
   return ((count < 0) ? FALSE : TRUE);
}

/*--------------------------------------------------------------------------*/

/* RoundString -- Round a number (string) to a given # of fract. digits */
private int RoundString
           (char *image, int imageRightDP, int roundToDigits)
{
   char  *DPLoc, *p, *dest;
   char  checkDigit;

   ASSERTION (imageRightDP > roundToDigits);

   DPLoc = image;
   while ((*DPLoc != EOS) && (*DPLoc != '.'))
      DPLoc++;

   ASSERTION (*DPLoc == '.');

   p = DPLoc + roundToDigits + 1;
   checkDigit = *p;
   *p = EOS;

   if (checkDigit < '5')
      return(0);

   p--;
   while (p >= image) {
      if (*p != '.') {
         if (*p != '9') {
            *p += 1;  return(0);
         }
         *p = '0';
      }
      p--;
   }

   dest = image + strlen(image) + 1;
   while (dest > image)
      *dest-- = *(dest - 1);
   *image = '1';
   return (1);
}


/* RawFormat -- Convert the number to a string in it's most simple form */
private int RawFormat (char __far *rawImage, double value,
                       BOOL percentEnable, BOOL exponentEnable,
                       int digitsLeftDP, int digitsRightDP)
{
   char    __far *pResult;
   int     digits, sign;
   int     resultExp;

   #define MAX_ECVT_DIGITS  16    /* Max digits ecvt can render */

   if (percentEnable == TRUE)
      value *= 100.0;

   /* The first step in formatting a number is converting the number
   ** to a string with the needed number of digits for the pattern.
   ** However, we must be aware that the conversion facilities available
   ** can only render a number to MAX_ECVT_DIGITS significant digits.
   **
   ** Always attempt to render one more decimal place than needed
   ** to allow for rounding
   */
   digits = min(digitsLeftDP + digitsRightDP + 1, MAX_ECVT_DIGITS);

   pResult = _ecvt(value, digits, &resultExp, &sign);

   /* If the image has fewer significant digits displayed than are
   ** possible, re-convert the number getting more digits
   */
   if ((resultExp > digitsLeftDP) && (digits < MAX_ECVT_DIGITS)) {
      digits = min(resultExp + digitsRightDP, MAX_ECVT_DIGITS);

      pResult = _ecvt(value, digits, &resultExp, &sign);
   }

   strcpy (rawImage, pResult);
   return (resultExp);
}


/*: Format the raw image to a form ready for final processing */
private BOOL NumericFirstFormat
             (char *firstFormat,       /* Result image                   */
              int  strSizeC,           /* Max characters in firstFormat  */
              int  digitsLeftDP,       /* format digits left DP          */
              int  digitsRightDP,      /* format digits right DP         */
              char *rawImage,          /* raw formatted image            */
              int  imageLeftDP,        /* digits in raw image left of DP */
              int  *insertDigitCount,  /* # digits insert at first 9/0   */
              int  *imageRightDPalways /* # digits always in fraction    */
             )
{
   char  *dest, *source;
   int   imageLength;
   int   zeroCount, trailingZeroCount, i;
   int   imageRightDP;
   int   count = 0;

   //No DBCS implications in this function since all characters are '0'..'9' and '.'

   /*
   ** First, format the raw image to introduce the decimal point at
   ** the appropriate place.  This may require adding zeros to
   ** the whole part of the number if the exponent exceeds the number
   ** of digits in the raw format
   */
   dest = firstFormat;
   source = rawImage;
   imageRightDP = 0;

   if ((count += (ABS(imageLeftDP) + 1)) > strSizeC) return(FALSE);

   if (imageLeftDP >= 0) {
      for (i = 0; i < imageLeftDP; i++) {
         *dest++ = (char)((*source == EOS) ? '0' : *source++);
      }
      *dest++ = '.';
   }
   else {
      *dest++ = '.';
      for (i = 0; i < ABS(imageLeftDP); i++) {
         *dest++ = '0';
      }
      imageLeftDP = 0;
   }

   while (*source != EOS) {
      if ((count += 1) > strSizeC) return(FALSE);
      *dest++ = *source++;
      imageRightDP++;
   }
   *dest = EOS;

   /*
   ** If the number of digits to the right of the DP in the image
   ** is less than the number of digits in the format (right DP)
   ** add trailing zeros to the image to bring the number of
   ** digits in the image equal to the digits (right DP) in the format.
   **
   ** If the number of digits to the right of the DP in the image
   ** is greater than the number of digits in the format (right DP)
   ** round/truncate the image to (format.digitsRightDP) digits.
   **
   ** This results in the following assertion always being true:
   **    - In fractional part of the image the number of digits is
   **      always the same as the number of digits (rightDP) in the format
   */
   if (imageRightDP < digitsRightDP) {
      zeroCount = digitsRightDP - imageRightDP;
      if ((count += zeroCount) > strSizeC) return(FALSE);

      imageLength = strlen(firstFormat);
      dest = firstFormat + imageLength;

      for (i = 0; i < zeroCount; i++) {
         *dest++ = '0';
      }
      *dest++ = EOS;
   }
   else if (imageRightDP > digitsRightDP) {
      if (RoundString(firstFormat, imageRightDP, digitsRightDP) != 0)
         imageLeftDP++;
   }

   /*
   ** Next, modify the image as follows:
   **
   ** If the number of digits to the left of the DP in the
   ** image is less than the number of digits in the format (left DP)
   ** put leading zeros onto the image to bring the number
   ** of digits in the image equal to digits (left DP) in the format
   **
   ** If the number of digits to the left of the DP in the image
   ** is greater than the number of digits in the format (left DP)
   ** determine the count of those digits.  This will be inserted
   ** when the first '0' or '9' is found during the final format.
   **
   ** This results in the following assertion always being true:
   **    - We may have more or an equal number of digits in the
   **      image (left DP) than the format - never less
   */

   *insertDigitCount = 0;

   if (imageLeftDP < digitsLeftDP) {
      zeroCount = digitsLeftDP - imageLeftDP;
      if ((count += zeroCount) > strSizeC) return(FALSE);

      imageLength = strlen(firstFormat);
      dest = firstFormat + imageLength + zeroCount;
      source = firstFormat + imageLength;

      for (i = 0; i <= imageLength; i++) {
         *dest-- = *source--;
      }

      dest = firstFormat;
      for (i = 0; i < zeroCount; i++) {
         *dest++ = '0';
      }
   }
   else if (imageLeftDP > digitsLeftDP) {
      *insertDigitCount = imageLeftDP - digitsLeftDP;
   }

   /*
   ** Count the number of trailing zeros in the image.  This is necessary
   ** for the final format to determine the applicability of '9's in
   ** the format fraction.
   **
   ** The value "imageRightDPalways" is a count of the number of
   ** fractional digits that are always placed in the result image
   ** regardless of the pattern character being a '0' or '9'
   */
   trailingZeroCount = 0;
   source = firstFormat + strlen(firstFormat) - 1;
   while (*source != '.') {
      if (*source-- != '0') break;
      trailingZeroCount++;
   }
   *imageRightDPalways = digitsRightDP - trailingZeroCount;

   return (TRUE);
}


private BOOL IsFractionFormat (NIP pFormat)
{
   uns  i;

   for (i = 0; i < pFormat->formatCodeCount; i++) {
      if (pFormat->formatCodes[i].code == FRACTION)
         return (TRUE);
   }
   return (FALSE);
}


private BOOL FormatGeneral (
             double     value,            /* Value to format          */
             FIP        pFormat,          /* compiled format string   */
             NIP        pSubFormat,       /* compiled format string   */
             CP_INFO    __far *pIntlInfo, /* International support    */
             char __far *pOutput          /* converted string         */
             )
{
   strcpy (pOutput, "<General>");

   #ifdef ENABLE_PRINTF_FOR_GENERAL
      sprintf (pOutput, "%.11g", value);

      if (pIntlInfo->numberDecimalSeparator != '.') {
         while (*pOutput != EOS) {
            if (*pOutput == '.')
               *pOutput = pIntlInfo->numberDecimalSeparator;
            pOutput++;
         }
      }
   #endif

   return (TRUE);
}



private BOOL FormatNumber (
             double     value,            /* Value to format          */
             FIP        pFormat,          /* compiled format string   */
             NIP        pSubFormat,       /* compiled format string   */
             CP_INFO    __far *pIntlInfo, /* International support    */
             char __far *pOutput          /* converted string         */
             )
{
   NIP    numInfo;
   char   rawImage[32];
   char   firstFormat[MAX_FORMAT_IMAGE + 1], *expFormat;
   char   __far *fsource, __far *dest;
   char   __far *source;
   uns    i;
   int    j, ignore, x;
   int    resultExp, trueExp;
   char   ch;
   int    insertDigitCount, insertDigitCountExp;
   int    imageRightDPalways;
   int    mantissaCount;
   BOOL   seenNonZero = FALSE, inFraction, showMinus;
   byte   code;
   int    offset, count, pos, icount;
   char   comma, dp;
   BOOL   result;

   /*
   ** Currenctly the fraction formats are not implemented
   */
   if (IsFractionFormat(pSubFormat)) {
      return (FormatGeneral(value, pFormat, pSubFormat, pIntlInfo, pOutput));
   }

   numInfo = pSubFormat;

   /*
   ** Handle scale factors
   */
   if (numInfo->scaleCount > 0) {
      for (i = 0; i < numInfo->scaleCount; i++)
         value /= 1000.0;
   }

   /* If we are using the first subformat and the value is negative
   ** we are responsible for showing the '-' sign.  For all other
   ** subformats, if the user wanted the '-'it would have been included
   ** as a character insertion.
   */
   showMinus = FALSE;

   if ((pFormat->subFormat[0] == pSubFormat) && (value < 0))
      showMinus = TRUE;

   value = ABS(value);

   /*
   ** Perform the conversion from a number to a string
   */
   resultExp = RawFormat(rawImage, value,
                         numInfo->percentEnable,
                         numInfo->exponentEnable,
                         numInfo->digitsLeftDP, numInfo->digitsRightDP);

   /*
   ** For numbers to be displayed in exponential form adjust the
   ** exponent as returned from the raw converter to make a fixed
   ** point number with the correct number of digits in the mantissa
   ** as required by the format.  The true exponent is attached
   ** later
   */
   if (numInfo->exponentEnable == TRUE) {
      if (resultExp == 0) {
         trueExp = (value != 0) ? -numInfo->digitsLeftDP : 0;   /*## Was 0 */
         resultExp = numInfo->digitsLeftDP;
         seenNonZero = TRUE;
      }
      else if (resultExp < 0) {
         trueExp = -(((abs(resultExp) / numInfo->digitsLeftDP) + 1) * numInfo->digitsLeftDP);
         resultExp = numInfo->digitsLeftDP - (abs(resultExp) % numInfo->digitsLeftDP);
      }
      else {
         trueExp = ((resultExp - 1) / numInfo->digitsLeftDP) * numInfo->digitsLeftDP;
         resultExp = ((resultExp - 1) % numInfo->digitsLeftDP) + 1;
      }
   }

   result = NumericFirstFormat(firstFormat, sizeof(firstFormat)-1,
                               numInfo->digitsLeftDP, numInfo->digitsRightDP,
                               rawImage, resultExp, &insertDigitCount, &imageRightDPalways);

   if (result == FALSE) goto overflow;

   if (numInfo->commaEnable) {
      mantissaCount = 0;
      source = firstFormat;
      while ((*source != EOS) && (*source != '.')) {
         mantissaCount++;
         source++;
      }
      FMTInsertCommas (firstFormat, sizeof(firstFormat)-1, mantissaCount, FALSE);
   }

   /*
   ** Format the exponent.  All the same rules apply to the exponent
   ** as apply to the mantissa.
   */
   if (numInfo->exponentEnable == TRUE) {
      resultExp = RawFormat(rawImage, (double)(ABS(trueExp)),
                            FALSE, FALSE,
                            numInfo->digitsExponent, 0);

      x = strlen(firstFormat);
      expFormat = firstFormat + x + 1;
      x = sizeof(firstFormat) - x - 2;

      result = NumericFirstFormat(expFormat, x, numInfo->digitsExponent, 0,
                                  rawImage, resultExp, &insertDigitCountExp, &ignore);

      if (result == FALSE) goto overflow;
   }

   /*
   ** The final step removes a character from the image for each
   ** '0' or '9' token in the format.  What happens depends upon
   ** if we are formatting the mantissa or fraction
   **
   ** Mantissa:
   **   When we encounter the first '0' or '9' token we must
   **   append to the result any extra digits in the image that
   **   we don't have pattern digits for.  The count of these
   **   "extra" digits has been computed previously and is in the
   **   variable insertDigitCount.  This in ONLY done for
   **   the first '0' or '9' token.
   **
   **   - For each '0' token we append one image digit
   **   - For each '9' token and the image digit is not a '0'
   **     we append one image digit
   **   - For each '9' token and the image token is a '0' we append
   **     the '0' IF we have previously appended a non zero digit
   **     (the image could be prefixed with a number of zeros)
   **
   ** Fraction:
   **    For each '0' token append one image digit and decrement the
   **    number of "insertAlways" digits.
   **
   **    For each '9' token append one image digit IF we are still
   **    working on "insertAlways" digits.  If we append a digit
   **    decrement the number of "insertAlways" digits.
   **
   ** If EVERYTHING works as planned when we encounter the DP token
   ** the "next" character in the image is a DP!
   */
   source = firstFormat;
   dest = pOutput;
   inFraction = FALSE;

   if (pSubFormat->currencyEnable) {
      comma = pIntlInfo->currencyThousandSeparator;
      dp    = pIntlInfo->currencyDecimalSeparator;
   }
   else {
      comma = pIntlInfo->numberThousandSeparator;
      dp    = pIntlInfo->numberDecimalSeparator;
   }

   count = 0;

   #define APPEND(c) { if (count++ > MAX_FORMAT_IMAGE) goto overflow; *dest++ = (c); }

   for (i = 0; i < numInfo->formatCodeCount; i++)
   {
      code = numInfo->formatCodes[i].code;

      if ((insertDigitCount > 0) &&
          ((code == DIGIT0) || (code == DIGIT_NUM) || (code == DIGIT_QM) || (code == DECIMAL_SEPARATOR)))
      {
         if (showMinus) APPEND('-');
         for (j = 0; j < insertDigitCount; j++) {
            if ((ch = *source++) != '0') seenNonZero = TRUE;
            APPEND(ch);
            if (*source == ',')
               { APPEND(comma); source++; }
         }
         insertDigitCount = 0;
         showMinus = FALSE;
      }

      switch (code) {
         case DIGIT0:
            ASSERTION ((*source >= '0') && (*source <= '9'));
            if (showMinus) { APPEND('-'); showMinus = FALSE; }
            if (inFraction == TRUE) {
               APPEND(*source++);
               imageRightDPalways--;
            }
            else {
               if ((ch = *source++) != '0') seenNonZero = TRUE;
               APPEND(ch);
               if (*source == ',')
                  { APPEND(comma); source++; }
            }
            break;

         case DIGIT_NUM:
         case DIGIT_QM:
            ASSERTION ((*source >= '0') && (*source <= '9'));
            if (showMinus) { APPEND('-'); showMinus = FALSE; }
            if (inFraction == TRUE) {
               if (imageRightDPalways > 0) {
                  APPEND(*source++);
                  imageRightDPalways--;
               }
            }
            else {
               if ((ch = *source++) != '0') seenNonZero = TRUE;
               if (seenNonZero == TRUE) {
                  APPEND(ch);
                  if (*source == ',')
                     { APPEND(comma); source++; }
               }
               else {
                  if (*source == ',') source++;
               }
            }
            break;

         case DECIMAL_SEPARATOR:
            if (showMinus) { APPEND('-'); showMinus = FALSE; }
            ch = *source++;
            ASSERTION (ch == '.');
            inFraction = TRUE;
            APPEND(dp);
            break;

         case EXPONENT_NEG_UC:
            if (numInfo->exponentEnable) {
               APPEND('E');
               if (trueExp < 0) APPEND('-');
               goto exponentCommon;
            }
            break;

         case EXPONENT_NEG_LC:
            if (numInfo->exponentEnable) {
               APPEND('e');
               if (trueExp < 0) APPEND('-');
               goto exponentCommon;
            }
            break;

         case EXPONENT_POS_UC:
            if (numInfo->exponentEnable) {
               APPEND('E');
               APPEND((char)((trueExp < 0) ? '-' : '+'));
               goto exponentCommon;
            }
            break;

         case EXPONENT_POS_LC:
            if (numInfo->exponentEnable) {
               APPEND('e');
               APPEND((char)((trueExp < 0) ? '-' : '+'));
               goto exponentCommon;
            }
            break;

exponentCommon:
            source = expFormat;
            inFraction = FALSE;
            seenNonZero = FALSE;
            insertDigitCount = insertDigitCountExp;
            break;

         case PERCENT:
            APPEND('%');
            break;

         case FRACTION:
            APPEND('/');
            break;

         case QUOTED_INSERT:
            offset = numInfo->formatCodes[i].info1 + 1;
            icount = numInfo->formatCodes[i].info2 - 2;
            fsource = &(pFormat->formatString[offset]);
            for (pos = 0; pos < icount; pos++)
               APPEND(*fsource++);
            break;

         case ESC_CHAR_INSERT:
         case NO_ESC_CHAR_INSERT:
            APPEND(numInfo->formatCodes[i].info1);
            #ifdef DBCS
               if (numInfo->formatCodes[i].info2 != 0)
                  APPEND(numInfo->formatCodes[i].info2);
            #endif
            break;

         case COLUMN_FILL:
            #ifdef INSERT_FILL_MARKS
               APPEND(FILL_MARK_CHAR);
            #endif
            break;

         case COLOR_SET:
         case CONDITIONAL:
         case UNDERLINE:
         case SCALE:
         case TOK_UNDEFINED:
            break;

         default:
            ASSERTION (FALSE);
      }
   }

   *dest = EOS;
   return (TRUE);

overflow:
   return (FALSE);
}


/*--------------------------------------------------------------------------*/

#define daySUN  0
#define dayMON  1
#define dayTUE  2
#define dayWED  3
#define dayTHS  4
#define dayFRI  5
#define daySAT  6

static uns Days[7] = {daySAT, daySUN, dayMON, dayTUE, dayWED, dayTHS, dayFRI};

#pragma optimize("",off)
private uns DateExtract (
             double value,          /* serial date                       */
             WORD   needs,          /* convert into what parts           */
             uns  __far *day,       /* 1 .. 31                           */
             uns  __far *month,     /* 1=jan ... 12=dec                  */
             uns  __far *year,      /* 4 digit year                      */
             uns  __far *weekday,   /* As given by the above enumeration */
             uns  __far *hour,      /* 24 hour clock (0 .. 23)           */
             uns  __far *minute,    /* 0 .. 59                           */
             uns  __far *second)    /* 0 .. 59                           */
{
   long  date, time, temp;
   int   cent;

   #define HALF_SECOND  (1.0/172800.0)

   if ((needs & (dtDAY | dtMONTH | dtYEAR)) != 0)
   {
      date = (long)value;

      /*
      ** Day 0 is a Saturday
      */
      *weekday = Days[date % 7];

      if (date == 0) {
         /*
         ** Make value zero into 0-jan-1900 (Strange but true!)
         */
         *day = 0;
         *month = 1;
         *year = 1900;
      }
      else if (date == 60) {
         /*
         ** Make value 60 into 29-feb-1900 (Wrong but as Excel does it!)
         */
         *day = 29;
         *month = 2;
         *year = 1900;
      }
      else {
         if ((date >= 1) && (date < 60))
            date++;

         date += 109511L;
         cent = (int)((4 * date + 3) / 146097L);
         date += cent - cent / 4;
         *year = (int)((date * 4 + 3) / 1461);
         temp = date - (*year * 1461L) / 4;
         *month = (int)((temp * 10 + 5) / 306);
         *day = (int)(temp - (*month * 306L + 5) / 10 + 1);

         *month += 3;
         if (*month > 12) {
            *month -= 12;
            *year += 1;
         }
         *year += 1600;
      }
   }

   if ((needs & (dtHOUR | dtMINUTE | dtSECOND)) != 0)
   {
      value += (value > 0.0) ? HALF_SECOND : -HALF_SECOND;
      value = fabs(value);
      time  = (long)((value - floor(value)) * 86400.0);
      *hour = (uns)(time / 3600);
      time  = time % 3600;

      *minute = (uns)(time / 60);
      *second = (uns)(time % 60);
   }

   return (0);
}
#pragma optimize("",on)

private BOOL FormatDate (
             double     value,            /* Value to format          */
             FIP        pFormat,          /* compiled format string   */
             NIP        pSubFormat,       /* compiled format string   */
             CP_INFO    __far *pIntlInfo, /* International support    */
             char __far *pOutput          /* converted string         */
             )
{
   DTIP  dateInfo;
   uns   day=0, month=1, year=1900, weekday=daySAT;
   uns   hour=0, min=0, sec=0;
   uns long ctDays;
   uns   i;
   char  __far *source, __far *dest;
   char  ampmString[16];
   int   count;
   int   offset, srcCount, pos;

   double frac, time;
   char   temp[32];
   char   fracDisplay[16];
   int    resultExp, ignore, iFrac;

   dateInfo = (DTIP)pSubFormat;

   DateExtract (value, dateInfo->formatNeeds, &day, &month, &year, &weekday, &hour, &min, &sec);

   #ifdef WIN32
   if (dateInfo->pOSFormat != NULL) {
      SYSTEMTIME sysTime;
      int cchOutput;

      sysTime.wYear = (WORD) year;
      sysTime.wMonth = (WORD) month;
      sysTime.wDayOfWeek = (WORD) weekday;
      sysTime.wDay = (WORD) day;
      sysTime.wHour = (WORD) hour;
      sysTime.wMinute = (WORD) min;
      sysTime.wSecond = (WORD) sec;
      sysTime.wMilliseconds = 0;

      if ((dateInfo->formatNeeds & dtMASK_DATE) != 0)
         cchOutput = GetDateFormatA(LOCALE_USER_DEFAULT, 0, &sysTime, dateInfo->pOSFormat, pOutput, MAX_FORMAT_IMAGE);
      else
         cchOutput = GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &sysTime, dateInfo->pOSFormat, pOutput, MAX_FORMAT_IMAGE);

      if (cchOutput != 0) {
         *(pOutput + cchOutput) = EOS;
         return (TRUE);
      }
   }
   #endif

   dest = pOutput;
   count = MAX_FORMAT_IMAGE;

   for (i = 0; i < dateInfo->formatCodeCount; i++) {
      switch (dateInfo->formatCodes[i].code)
      {
         case DAY_NUMBER:
            AppendNum(&dest, day, &count);
            break;
         case DAY_NUMBER2:
            AppendNum2(&dest, day, &count);
            break;
         case WEEKDAY3:
            AppendNM(&dest, pIntlInfo->shortDayName[weekday], &count);
            break;
         case WEEKDAY:
            AppendNM(&dest, pIntlInfo->fullDayName[weekday], &count);
            break;
         case MONTH_NUMBER:
            AppendNum(&dest, month, &count);
            break;
         case MONTH_NUMBER2:
            AppendNum2(&dest, month, &count);
            break;
         case MONTH_NAME3:
            AppendNM(&dest, pIntlInfo->shortMonthName[month - 1], &count);
            break;
         case MONTH_NAME:
            AppendNM(&dest, pIntlInfo->fullMonthName[month - 1], &count);
            break;
         case MONTH_LETTER:
            temp[0] = pIntlInfo->fullMonthName[month - 1][0];
            temp[1] = EOS;
            #ifdef DBCS
               if (IsDBCSLeadByte(temp[0])) {
                  temp[1] = pIntlInfo->fullMonthName[month - 1][1];
                  temp[2] = EOS;
               }
            #endif
            AppendNM(&dest, temp, &count);
            break;
         case YEAR2:
            AppendNum2(&dest, year % 100, &count);
            break;
         case YEAR4:
            AppendNum(&dest, year, &count);
            break;
         case HOUR_12:
            if (hour == 0)
               AppendNum(&dest, 12, &count);
            else
               AppendNum(&dest, (hour > 12) ? hour - 12 : hour, &count);
            break;
         case HOUR_24:
            AppendNum(&dest, hour, &count);
            break;
         case HOUR2_12:
            if (hour == 0)
               AppendNum2(&dest, 12, &count);
            else
               AppendNum2(&dest, (hour > 12) ? hour - 12 : hour, &count);
            break;
         case HOUR2_24:
            AppendNum2(&dest, hour, &count);
            break;
         case MINUTE:
            AppendNum(&dest, min, &count);
            break;
         case MINUTE2:
            AppendNum2(&dest, min, &count);
            break;
         case SECOND:
            AppendNum(&dest, sec, &count);
            break;
         case SECOND2:
            AppendNum2(&dest, sec, &count);
            break;
         case AMPM_UC:
            if (hour >= 12)
               AppendNM(&dest, pIntlInfo->PMString, &count);
            else
               AppendNM(&dest, pIntlInfo->AMString, &count);
            break;
         case AMPM_LC:
            if (hour >= 12)
               AppendLC(&dest, pIntlInfo->PMString, &count);
            else
               AppendLC(&dest, pIntlInfo->AMString, &count);
            break;
         case AP_UC:
            if (hour >= 12)
               strcpy (ampmString, pIntlInfo->PMString);
            else
               strcpy (ampmString, pIntlInfo->AMString);

            ampmString[1] = EOS;
            AppendUC(&dest, ampmString, &count);
            break;
         case AP_LC:
            if (hour >= 12)
               strcpy (ampmString, pIntlInfo->PMString);
            else
               strcpy (ampmString, pIntlInfo->AMString);

            ampmString[1] = EOS;
            AppendLC(&dest, ampmString, &count);
            break;

         case QUOTED_INSERT:
            offset = dateInfo->formatCodes[i].info1 + 1;
            srcCount = dateInfo->formatCodes[i].info2 - 2;
            source = &(pFormat->formatString[offset]);
            for (pos = 0; pos < srcCount; pos++) {
               #ifdef DBCS
                  if (IsDBCSLeadByte(*source)) {
                     if ((count -= 2) < 0) break;
                     *dest++ = *source++;
                     *dest++ = *source++;
                     pos++;
                  }
                  else {
                     if ((count -= 1) < 0) break;
                     *dest++ = *source++;
                  }
               #else
                  if ((count -= 1) < 0) break;
                  *dest++ = *source++;
               #endif
            }
            break;

         case ESC_CHAR_INSERT:
         case NO_ESC_CHAR_INSERT:
            #ifdef DBCS
               if (dateInfo->formatCodes[i].info2 != 0) {
                  if ((count -= 2) < 0) break;
                  *dest++ = dateInfo->formatCodes[i].info1;
                  *dest++ = dateInfo->formatCodes[i].info2;
               }
               else {
                  if ((count -= 1) < 0) break;
                  if (dateInfo->formatCodes[i].info1 == '/')
                     *dest++ = pIntlInfo->dateSeparator;
                  else
                     *dest++ = dateInfo->formatCodes[i].info1;
               }
            #else
               if ((count -= 1) < 0) break;
               *dest++ = dateInfo->formatCodes[i].info1;
            #endif
            break;

         case COLUMN_FILL:
            #ifdef INSERT_FILL_MARKS
               AppendLC(&dest, FillMark, &count);
            #endif
            break;

         case COLOR_SET:
            break;

         case UNDERLINE:
            break;

         case HOUR_GT:
            ctDays = (uns long)value;
            AppendNum(&dest, (uns long)hour + (ctDays * 24), &count);
            break;

         case MINUTE_GT:
            ctDays = (uns long)value;
            AppendNum(&dest, (uns long)min + ((uns long)hour * 60) + (ctDays * 24 * 60), &count);
            break;

         case SECOND_GT:
            ctDays = (long)value;
            AppendNum(&dest, (uns long)sec + ((uns long)min * 60) + ((uns long)hour * 60 * 60) + (ctDays * 24 * 60 * 60), &count);
            break;

         case TIME_FRAC:
            time = fabs(value);
            time = time - floor(time);
            frac = (time - (((double)hour * 3600.0 + (double)min * 60.0 + (double)sec) / 86400.0)) * 86400.0;

            resultExp = RawFormat(temp, frac, FALSE, FALSE, 0, 3);
            NumericFirstFormat(fracDisplay, sizeof(fracDisplay)-1, 0, 3, temp, resultExp, &ignore, &ignore);

            temp[0] = '.';
            temp[1] = EOS;
            AppendLC(&dest, temp, &count);
            iFrac = 1;
            break;

         case TIME_FRAC_DIGIT:
            temp[0] = fracDisplay[iFrac++];
            temp[1] = EOS;
            AppendLC(&dest, temp, &count);
            break;

         default:
            ASSERTION(FALSE);
      }
      if (count < 0) break;
   }

   *dest = EOS;
   return ((count < 0) ? FALSE : TRUE);
}

/*--------------------------------------------------------------------------*/

public int FMTDisplay (
            void __far *pValue,           /* Value to format               */
            BOOL       isIntValue,        /* type of value, long or double */
            CP_INFO    __far *pIntlInfo,  /* International support         */
            FMTHANDLE  hFormat,           /* compiled format string        */
            int        colWidth,          /* cell width in pixels          */
            char __far *pResult           /* converted string              */
            )

{
   double value;
   FIP    pFormat = (FIP)hFormat;
   NIP    subFormat;
   int    subFormatToUse;
   BOOL   result;

   result = TRUE;

   if (isIntValue)
      value = (double)(*((long __far *)pValue));
   else
      value = *((double __far *)pValue);

   if (pFormat->subFormatCount == 1)
      subFormatToUse = 0;

   else if (pFormat->subFormatCount == 2)
      subFormatToUse = (value < 0) ? 1 : 0;

   else {
      if (value == 0)
         subFormatToUse = 2;
      else if (value < 0)
         subFormatToUse = 1;
      else
         subFormatToUse = 0;
   }

   if ((subFormat = pFormat->subFormat[subFormatToUse]) != NULL)
   {
      if (subFormat->tag == tagDATE_TIME)
         result = FormatDate(value, pFormat, subFormat, pIntlInfo, pResult);

      else if (subFormat->tag == tagNUMERIC)
         result = FormatNumber(value, pFormat, subFormat, pIntlInfo, pResult);

      else if (subFormat->tag == tagGENERAL)
         result = FormatGeneral(value, pFormat, subFormat, pIntlInfo, pResult);

      else
         result = FormatText(value, pFormat, subFormat, pIntlInfo, pResult);
   }

   if (result == FALSE) {
      *pResult = EOS;
      return (FMT_errDisplayFailed);
   }

#ifdef INSERT_FILL_MARKS
   /*
   ** Look for the fill marker and fill based upon column width
   */
#endif

   return (FMT_errSuccess);
}

#endif // !VIEWER

/* end EXFMTDO.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtdb.h ===
/*
** File: EXFMTDB.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/94  kmh  Created.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define EXFMTDB_H


/* DEFINITIONS */

#define ESCAPE_CHAR         0x5c       /* Backslash */
#define UNDERLINE_CHAR      '_'


/* Common format codes */

#define TOK_UNDEFINED           0x00
#define QUOTED_INSERT           0x01   // i1: Offset     i2: count
#define ESC_CHAR_INSERT         0x02   // i1: Char       i2: DBCS trail byte
#define NO_ESC_CHAR_INSERT      0x03   // i1: Char       i2: DBCS trail byte
#define COLUMN_FILL             0x04   // i1: fill char  i2: DBCS trail byte
#define COLOR_SET               0x05   // i1: Offset     i2: count
#define UNDERLINE               0x06   // i1: width char i2: DBCS trail byte
#define CONDITIONAL             0x07   // i1: Offset     i2: count


/* Date/Time format codes */

#define DAY_NUMBER              0x08   /* d     */
#define DAY_NUMBER2             0x09   /* dd    */
#define WEEKDAY3                0x0a   /* ddd   */
#define WEEKDAY                 0x0b   /* dddd  */
#define MONTH_NUMBER            0x0c   /* m     */
#define MONTH_NUMBER2           0x0d   /* mm    */
#define MONTH_NAME3             0x0e   /* mmm   */
#define MONTH_NAME              0x0f   /* mmmm  */
#define MONTH_LETTER            0x10   /* mmmmm */
#define YEAR2                   0x11   /* yy    */
#define YEAR4                   0x12   /* yyyy  */

#define HOUR_12                 0x13   /* h     */
#define HOUR_24                 0x14   /* h     */
#define HOUR2_12                0x15   /* hh    */
#define HOUR2_24                0x16   /* hh    */
#define MINUTE                  0x17   /* m     */
#define MINUTE2                 0x18   /* mm    */
#define SECOND                  0x19   /* s     */
#define SECOND2                 0x1a   /* ss    */
#define HOUR_GT                 0x1b   /* [h]   */
#define MINUTE_GT               0x1c   /* [m]   */
#define SECOND_GT               0x1d   /* [s]   */
#define AMPM_UC                 0x1e   /* AM/PM */
#define AMPM_LC                 0x1f   /* am/pm */
#define AP_UC                   0x20   /* A/P   */
#define AP_LC                   0x21   /* a/p   */
#define TIME_FRAC               0x22   /* .     */
#define TIME_FRAC_DIGIT         0x23   /* 0     */


/* Numeric format codes */

#define GENERAL                 0x24   /* General */
#define DIGIT0                  0x25   /* 0   */
#define DIGIT_NUM               0x26   /* #   */
#define DIGIT_QM                0x27   /* ?   */
#define DECIMAL_SEPARATOR       0x28   /* .   */
#define EXPONENT_NEG_UC         0x29   /* E-  */
#define EXPONENT_NEG_LC         0x2a   /* e-  */
#define EXPONENT_POS_UC         0x2b   /* E+  */
#define EXPONENT_POS_LC         0x2c   /* E-  */
#define PERCENT                 0x2d   /* %   */
#define FRACTION                0x2e   /* /   */
#define SCALE                   0x2f	/* ,   */

/* Text format codes */

#define AT_SIGN                 0x30   /* @   */


/* The following are not stored in the formatCodes array */

#define THOUSANDS_SEPARATOR     0x31
#define FORMAT_SEPARATOR        0x32
#define TOK_EOS                 0x33

typedef struct {
   byte  code;
   byte  info1;
   byte  info2;
} FormatCode, FC;

#define tagGENERAL     0
#define tagNUMERIC     1
#define tagDATE_TIME   2
#define tagTEXT        3

typedef struct {
   byte    tag;
   byte    fillChar;
   uns     formatCodeCount;
   FC      formatCodes[1];        /* Really as long as needed */
} GeneralInfo, GI;

typedef GeneralInfo __far *GIP;

typedef struct {
   byte    tag;
   byte    fillChar;
   uns     formatCodeCount;
   FC      formatCodes[1];        /* Really as long as needed */
} TextInfo, TI;

typedef TextInfo __far *TIP;

/*
** The formatNeeds field is a bit mask that provides an indication
** to what level of date extraction is nedded to construct the image
*/
#define dtDAY       0x01          /* Bits in formatNeeds bitset */
#define dtMONTH     0x02
#define dtYEAR      0x04
#define dtWEEKDAY   0x08
#define dtHOUR      0x10
#define dtMINUTE    0x20
#define dtSECOND    0x40

#define dtMASK_DATE (dtDAY | dtMONTH | dtYEAR | dtWEEKDAY)
#define dtMASK_TIME (dtHOUR | dtMINUTE | dtSECOND)

typedef struct {
   byte    tag;
   byte    fillChar;
   uns     formatCodeCount;
   byte    formatNeeds;
   #ifdef WIN32
      char    *pOSFormat;         // Formatted for use with GetDateFormat, GetTimeFormat
   #endif
   FC      formatCodes[1];        // Really as long as needed
} DateTimeInfo, DTI;

typedef DateTimeInfo __far *DTIP;

typedef struct {
   byte    tag;
   byte    fillChar;
   uns     formatCodeCount;
   byte    digitsLeftDP;
   byte    digitsRightDP;
   byte    digitsExponent;
   byte    scaleCount;
   BOOL    exponentEnable;
   BOOL    commaEnable;
   BOOL    percentEnable;
   BOOL    currencyEnable;
   FC      formatCodes[1];        /* Really as long as needed */
} NumInfo, NI;

typedef NumInfo __far *NIP;


#define MAX_SUB_FORMATS  4  /* [0]:(# > 0) [1]:(# < 0) [2]:(# == 0) [3]:(Text) */

typedef struct FormatInfo {
   struct  FormatInfo __far *next;
   int     subFormatCount;
   NIP     subFormat[MAX_SUB_FORMATS];   /* May be NIP / DTIP / TIP / GIP */
   char    formatString[1];              /* Really as long as needed */
} FormatInfo, FI;

typedef FormatInfo __far *FIP;


/*
** FMTPARSE.C
*/

/* Translate a format string to it's internal form */
extern int FMTParse (void * pGlobals, char __far *formatString, CP_INFO __far * pIntlInfo, FIP formatData);

/* Extract the quoted strings from the format */
extern int FMTUnParseQuotedParts (char __far *pBuffer, char __far *pSep, FIP formatData);

/* Insert commas in a string */
extern void FMTInsertCommas
      (char *numericString, uns strSizC, uns count, BOOL padToShow);

#endif // !VIEWER
/* end EXFMTDB.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtps.c ===
/*
** File: EXFMTPRS.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/91  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"
   #include "dmifmtdb.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
   #include "exfmtdb.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */

void SetOrDateFormatNeeds(void * pGlobals, byte);
void SetDateFormatNeeds(void * pGlobals, byte);
byte GetDateFormatNeeds(void * pGlobals);
void SetSeenAMPM(void * pGlobals, BOOL);
BOOL GetSeenAMPM(void * pGlobals);

/* MODULE DATA, TYPES AND MACROS  */

/* Globals used during format string parsing */

typedef struct {
   char __far *string;
   uns         last;
   uns         next;
   FIP         data;
} formatInfo, FINFO;

//static FINFO  Format;


/* Globals used during parsing of date-time formats */
//static BOOL   SeenAMPM;
//static byte   DateFormatNeeds;


#define CH_GET                 0x0000   /* GetChar flags */
#define CH_LOWERCASE           0x0001

#define EXACT_CASE             0x0000   /* PeekChar and PeekString flags */
#define ANY_CASE               0x0001


#define Advance(count) pFormat->next += count


#define FORMAT_ESCAPE_CHAR      0x5c      /* Backslash */
#define FILL_MARKER             '*'
#define QUOTE_CHAR              '"'
#define COLOR_MARKER_START      '['
#define COLOR_MARKER_END        ']'
#define FORMAT_SEPARATOR_CHAR   ';'
#define DP                      '.'
#define COMMA                   ','
#define GENERAL_NAME            "General"


#define typeCOMMON  0
#define typeGENERAL 1
#define typeDATE    2
#define typeNUMBER  3
#define typeTEXT    4

static const BOOL FmtTokenType[] =
      {
       typeCOMMON,   /* TOK_UNDEFINED       */
       typeCOMMON,   /* QUOTED_INSERT       */
       typeCOMMON,   /* ESC_CHAR_INSERT     */
       typeCOMMON,   /* NO_ESC_CHAR_INSERT  */
       typeCOMMON,   /* COLUMN_FILL         */
       typeCOMMON,   /* COLOR_SET           */
       typeCOMMON,   /* UNDERLINE           */
       typeCOMMON,   /* CONDITIONAL         */

       typeDATE,     /* DAY_NUMBER          */
       typeDATE,     /* DAY_NUMBER2         */
       typeDATE,     /* WEEKDAY3            */
       typeDATE,     /* WEEKDAY             */
       typeDATE,     /* MONTH_NUMBER        */
       typeDATE,     /* MONTH_NUMBER2       */
       typeDATE,     /* MONTH_NAME3         */
       typeDATE,     /* MONTH_NAME          */
       typeDATE,     /* MONTH_LETTER        */
       typeDATE,     /* YEAR2               */
       typeDATE,     /* YEAR4               */

       typeDATE,     /* HOUR_12             */
       typeDATE,     /* HOUR_24             */
       typeDATE,     /* HOUR2_12            */
       typeDATE,     /* HOUR2_24            */
       typeDATE,     /* MINUTE              */
       typeDATE,     /* MINUTE2             */
       typeDATE,     /* SECOND              */
       typeDATE,     /* SECOND2             */
       typeDATE,     /* HOUR_GT             */
       typeDATE,     /* MINUTE_GT           */
       typeDATE,     /* SECOND_GT           */
       typeDATE,     /* AMPM_UC             */
       typeDATE,     /* AMPM_LC             */
       typeDATE,     /* AP_UC               */
       typeDATE,     /* AP_LC               */
       typeDATE,     /* TIME_FRAC           */
       typeDATE,     /* TIME_FRAC_DIGIT     */

       typeGENERAL,  /* GENERAL             */
       typeCOMMON,   /* DIGIT0              */
       typeNUMBER,   /* DIGIT_NUM           */
       typeNUMBER,   /* DIGIT_QM            */
       typeCOMMON,   /* DECIMAL_SEPARATOR   */
       typeNUMBER,   /* EXPONENT_NEG_UC     */
       typeNUMBER,   /* EXPONENT_NEG_LC     */
       typeNUMBER,   /* EXPONENT_POS_UC     */
       typeNUMBER,   /* EXPONENT_POS_LC     */
       typeNUMBER,   /* PERCENT             */
       typeCOMMON,   /* FRACTION            */
       typeNUMBER,   /* SCALE               */

       typeTEXT,     /* AT_SIGN             */

       typeNUMBER,   /* THOUSANDS_SEPARATOR */
       typeCOMMON,   /* FORMAT_SEPARATOR    */
       typeCOMMON    /* TOK_EOS             */
      };

#define DIGIT_PLACEHOLDER(code) ((code == DIGIT0) || (code == DIGIT_NUM) || (code == DIGIT_QM))

static const char __far * const IntlCurrencySymbols[] =
      {
       "Esc.",   /* Portugal         */
       "SFr.",   /* Switzerland      */

       "Cr$",    /* Brazil           */
       "kr.",    /* Iceland          */
       "IR\xa3", /* Ireland          */
       "LEI",    /* Romania          */
       "SIT",    /* Slovinia         */
       "Pts",    /* Spain            */

       "BF",     /* Belgian Dutch    */
       "FB",     /* Belgian French   */
       "kr",     /* Denmark          */
       "mk",     /* Finland          */
       "DM",     /* Germany          */
       "Ft",     /* Hungary          */
       "L.",     /* Italy            */
       "N$",     /* Mexico           */
       "kr",     /* Norway           */
       "Sk",     /* Slovak Republic  */
       "kr",     /* Sweden           */
       "TL",     /* Turkey           */

       "$",      /* Australia        */
       "S",      /* Austria          */
       "$",      /* Canadian English */
       "$",      /* Canadian French  */
       "K",      /* Croatia          */
       "F",      /* France           */
       "F",      /* Netherlands      */
       "$",      /* New Zealand      */
       "\xa3",   /* United Kingdom   */
       "$",      /* United States    */
       ""
      };


/* IMPLEMENTATION */

/* InsertCommas -- Insert commas in a string */
public void FMTInsertCommas
      (char __far *numericString, uns strSizC, uns count, BOOL padToShow)
{
   char  temp[MAX_FORMAT_IMAGE + 1];
   char  __far *dest, __far *source, __far *stopAt;
   int   pad, i, bufferSize, inputLength;
   int   digitsBeforeComma, commaCount;

   #define PAD_CHAR '#'

   // No DBCS implications in this function since all data is known to be '0'..'9', '.', or '#'

   /* Parameters are:
   **
   **  numericString : String with numeric image without commas
   **
   **  strSizC       : Maximum number of characters in numericString
   **
   **  count         : Number of digits to left of DP
   **
   **  padToShow     : If TRUE and if count < 4 add '#'s to the left
   **                  of the DP.
   */

   if ((inputLength = strlen(numericString)) > sizeof(temp)-1)
      return;

   strcpy (temp, numericString);
   dest = numericString;

   bufferSize = min(strSizC, sizeof(temp)-1);

   /*
   ** Step 1. Reconstruct the input string padding as necessary (padToShow)
   */
   if (padToShow == TRUE) {
      if (count < 4)
         pad = 4 - count;
      else if ((count % 3) == 0)
         pad = 1;
      else
         pad = 0;

      /* The intent of this is to transform strings as:
      **
      **   Input            Output
      **   -----            ------
      **   9                9999           9,999
      **   99               9999           9,999
      **   999              9999           9,999
      **   9999             9999           9,999
      **   99999            99999         99,999
      **   999999           9999999    9,999,999
      **   9999999          9999999    9,999,999
      **   99999999         99999999  99,999,999
      */
      if (pad > 0) {
         count += pad;
         commaCount = (count - 1) / 3;
         if (inputLength + pad + commaCount > bufferSize)
            return;

         dest = temp + strlen(temp) + pad;
         stopAt = temp + pad;
         while (dest >= stopAt) {
            *dest = *(dest - pad);
            dest--;
         }
         for (i = 0; i < pad; i++)
            *(temp + i) = PAD_CHAR;
      }
   }

   commaCount = (count - 1) / 3;
   if (inputLength + commaCount > bufferSize)
      return;

   /*
   ** Step 2: Copy "count" numbers from the source to the dest inserting
   **         commas as needed.
   */
   dest = numericString;
   source = temp;

   if ((digitsBeforeComma = count % 3) == 0)
      digitsBeforeComma = 3;

   while (count != 0) {
      if (digitsBeforeComma == 0) {
         *dest++ = COMMA;
         digitsBeforeComma = 3;
      }
      *dest++ = *source++;
      digitsBeforeComma--;
      count--;
   }

   /*
   ** Step 3: Copy any remaining characters in the numeric string
   */
   while (*source != EOS)
      *dest++ = *source++;

   *dest = EOS;
}

/*---------------------------------------------------------------------------*/

/* GetChar -- Return the next character from the format string */
private char GetChar (FINFO * pFormat, uns flags)
{
   char  c;

   if (pFormat->next > pFormat->last)
      return (EOS);

   c = pFormat->string[pFormat->next++];

   if ((flags & CH_LOWERCASE) != 0)
      c = ((c >= 'A') && (c <= 'Z')) ? ((char)(c + 32)) : (c);

   return (c);
}

/* PeekChar -- See if next character in the format string is specific char */
private BOOL PeekChar (FINFO * pFormat, char c, uns flags)
{
   uns   save;
   char  testChar;

   // No DBCS implications in this function since char "c" is known to be SBCS

   save = pFormat->next;
   testChar = GetChar(pFormat, flags);
   pFormat->next = save;

   return ((testChar == c) ? TRUE : FALSE);
}

/* PeekString -- See if next chars in the format string is specific string */
private BOOL PeekString (FINFO * pFormat, char __far *s, uns flags)
{
   uns   save;
   char  testChar;
   BOOL  result = TRUE;
   uns   getFlags;

   // No DBCS implications in this function since all chars in "s" are known to be SBCS

   getFlags = ((flags & ANY_CASE) != 0) ? CH_LOWERCASE : CH_GET;

   save = pFormat->next;
   while (*s != EOS) {
      testChar = GetChar(pFormat, getFlags);
      if (testChar != *s) {
         result = FALSE;
         break;
      }
      s++;
   }

   pFormat->next = save;
   return (result);
}

/*--------------------------------------------------------------------------*/

#define IS_CONDITIONAL(c) ((c == '<') || (c == '>') || (c == '='))

/* GetCommonToken -- Parse a token common in date-time and number formats */
private int GetCommonToken (FINFO * pFormat, char tokStartChar, char __far *data)
{
   int   result = FMT_errInvalidFormat;
   char  cnext;
   char  __far *dest;

   if (tokStartChar == ESCAPE_CHAR) {
      if ((cnext = GetChar(pFormat, CH_GET)) == EOS)
         return (FMT_errUnterminatedString);

      result = ESC_CHAR_INSERT;
      data[0] = cnext;
      data[1] = 0;

      #ifdef DBCS
         if (IsDBCSLeadByte(cnext))
            data[1] = GetChar(pFormat, CH_GET);
      #endif
   }

   else if (tokStartChar == FILL_MARKER) {
      if ((cnext = GetChar(pFormat, CH_GET)) == EOS)
         return (FMT_errColumnFill);

      result = COLUMN_FILL;
      data[0] = cnext;
      data[1] = 0;

      #ifdef DBCS
         if (IsDBCSLeadByte(cnext))
            data[1] = GetChar(pFormat, CH_GET);
      #endif
   }

   else if (tokStartChar == UNDERLINE_CHAR) {
      if ((cnext = GetChar(pFormat, CH_GET)) == EOS)
         return (FMT_errUnterminatedString);

      result = UNDERLINE;
      data[0] = cnext;
      data[1] = 0;

      #ifdef DBCS
         if (IsDBCSLeadByte(cnext))
            data[1] = GetChar(pFormat, CH_GET);
      #endif
   }

   else if (tokStartChar == QUOTE_CHAR) {
      if ((cnext = GetChar(pFormat, CH_GET)) == EOS)
         return (FMT_errUnterminatedString);

      while (cnext != QUOTE_CHAR) {
         #ifdef DBCS
            if (IsDBCSLeadByte(cnext))
               GetChar(pFormat, CH_GET);
         #endif

         if ((cnext = GetChar(pFormat, CH_GET)) == EOS)
            return (FMT_errUnterminatedString);
      }
      result = QUOTED_INSERT;
   }

   else if (tokStartChar == COLOR_MARKER_START) {
      dest = data;
      data[0] = EOS;

      forever {
         if ((cnext = GetChar(pFormat, CH_LOWERCASE)) == EOS)
            return (FMT_errUnterminatedString);

         if (cnext == COLOR_MARKER_END)
            break;

         *dest++ = cnext;

         #ifdef DBCS
            if (IsDBCSLeadByte(cnext))
               *dest++ = GetChar(pFormat, CH_GET);
         #endif
      }
      *dest = EOS;

      result = COLOR_SET;

      /*
      ** Look for the special [h] [m] [s] markers
      */
      if (((data[0] == 'h') && (data[1] == EOS)) || ((data[0] == 'h') && (data[1] == 'h') && (data[2] == EOS)))
         result = HOUR_GT;
      else if (((data[0] == 'm') && (data[1] == EOS)) || ((data[0] == 'm') && (data[1] == 'm') && (data[2] == EOS)))
         result = MINUTE_GT;
      else if (((data[0] == 's') && (data[1] == EOS)) || ((data[0] == 's') && (data[1] == 's') && (data[2] == EOS)))
         result = SECOND_GT;
      else if (IS_CONDITIONAL(data[0]))
         result = CONDITIONAL;
   }
   return (result);
}


/* GetToken -- Return the next token from a sub-format */
private int GetToken (void * pGlobals, FINFO * pFormat, char __far *data)
{
   char  c;
   uns   result = TOK_UNDEFINED;

   if ((c = GetChar(pFormat, CH_GET)) == EOS)
      return (TOK_EOS);

   switch (c)
   {
      case FORMAT_SEPARATOR_CHAR:
         result = FORMAT_SEPARATOR;
         break;

      case 'G':
      case 'g':
         if (PeekString(pFormat, "eneral", ANY_CASE) == TRUE) {
            Advance(6);
            result = GENERAL;
         }
         else if (PeekString(pFormat, "gge", ANY_CASE) == TRUE) {
            Advance(3);
            result = YEAR4;
            //DateFormatNeeds |= dtYEAR;
            SetOrDateFormatNeeds(pGlobals, dtYEAR);
         }
         break;

      case '0':
         result = DIGIT0;
         break;

      case '#':
         result = DIGIT_NUM;
         break;

      case '?':
         result = DIGIT_QM;
         break;

      case '%':
         result = PERCENT;
         break;

      case COMMA:
         result = SCALE;
         break;

      case DP:
         result = DECIMAL_SEPARATOR;
         break;

      case '/':
         result = FRACTION;
         break;

      case 'E':
      case 'e':
         if (PeekChar(pFormat, '+', EXACT_CASE) == TRUE) {
            Advance(1);
            result = (c == 'e') ? EXPONENT_POS_LC : EXPONENT_POS_UC;
         }
         else if (PeekChar(pFormat, '-', EXACT_CASE) == TRUE) {
            Advance(1);
            result = (c == 'e') ? EXPONENT_NEG_LC : EXPONENT_NEG_UC;
         }
         break;

      case 'D':
      case 'd':
         if (PeekString(pFormat, "ddd", ANY_CASE) == TRUE) {
            Advance(3);
            result = WEEKDAY;
            //DateFormatNeeds |= dtWEEKDAY;
            SetOrDateFormatNeeds(pGlobals, dtWEEKDAY);
         }
         else if (PeekString(pFormat, "dd", ANY_CASE) == TRUE) {
            Advance(2);
            result = WEEKDAY3;
            //DateFormatNeeds |= dtWEEKDAY;
            SetOrDateFormatNeeds(pGlobals, dtWEEKDAY);
         }
         else if (PeekChar(pFormat, 'd', ANY_CASE) == TRUE) {
            Advance(1);
            result = DAY_NUMBER2;
            //DateFormatNeeds |= dtDAY;
            SetOrDateFormatNeeds(pGlobals, dtDAY);
         }
         else {
            result = DAY_NUMBER;
            //DateFormatNeeds |= dtDAY;
            SetOrDateFormatNeeds(pGlobals, dtDAY);
         }
         break;

      case 'M':
      case 'm':
         if (PeekString(pFormat, "mmmm", ANY_CASE) == TRUE) {
            Advance(4);
            result = MONTH_LETTER;
         }
         else if (PeekString(pFormat, "mmm", ANY_CASE) == TRUE) {
            Advance(3);
            result = MONTH_NAME;
         }
         else if (PeekString(pFormat, "mm", ANY_CASE) == TRUE) {
            Advance(2);
            result = MONTH_NAME3;
         }
         else if (PeekChar(pFormat, 'm', ANY_CASE) == TRUE) {
            Advance(1);
            result = MONTH_NUMBER2;
         }
         else {
            result = MONTH_NUMBER;
         }
         //DateFormatNeeds |= dtMONTH;
         SetOrDateFormatNeeds(pGlobals, dtMONTH);
         break;

      case 'Y':
      case 'y':
         if (PeekString(pFormat, "yyy", ANY_CASE) == TRUE) {
            Advance(3);
            result = YEAR4;
            //DateFormatNeeds |= dtYEAR;
            SetOrDateFormatNeeds(pGlobals, dtYEAR);
         }
         else if (PeekChar(pFormat, 'y', ANY_CASE) == TRUE) {
            Advance(1);
            result = YEAR2;
            //DateFormatNeeds |= dtYEAR;
            SetOrDateFormatNeeds(pGlobals, dtYEAR);
         }
         break;

      case 'H':
      case 'h':
         if (PeekChar(pFormat, 'h', ANY_CASE) == TRUE) {
            Advance(1);
            result = HOUR2_24;
         }
         else {
            result = HOUR_24;
         }
         //DateFormatNeeds |= dtHOUR;
         SetOrDateFormatNeeds(pGlobals, dtHOUR);
         break;

      case 'S':
      case 's':
         if (PeekChar(pFormat, 's', ANY_CASE) == TRUE) {
            Advance(1);
            result = SECOND2;
         }
         else {
            result = SECOND;
         }
         //DateFormatNeeds |= dtSECOND;
         SetOrDateFormatNeeds(pGlobals, dtSECOND);
         break;

      case 'A':
         if (PeekString(pFormat, "M/PM", EXACT_CASE) == TRUE) {
            Advance(4);
            result = AMPM_UC;
            //SeenAMPM = TRUE;
            SetSeenAMPM(pGlobals, TRUE);
            //DateFormatNeeds |= dtHOUR;
            SetOrDateFormatNeeds(pGlobals, dtHOUR);
         }
         else if (PeekString(pFormat, "/P", EXACT_CASE) == TRUE) {
            Advance(2);
            result = AP_UC;
            //SeenAMPM = TRUE;
            SetSeenAMPM(pGlobals, TRUE);
            //DateFormatNeeds |= dtHOUR;
            SetOrDateFormatNeeds(pGlobals, dtHOUR);
         }
         break;

      case 'a':
         if (PeekString(pFormat, "m/pm", EXACT_CASE) == TRUE) {
            Advance(4);
            result = AMPM_LC;
            //SeenAMPM = TRUE;
            SetSeenAMPM(pGlobals, TRUE);
            //DateFormatNeeds |= dtHOUR;
            SetOrDateFormatNeeds(pGlobals, dtHOUR);
         }
         else if (PeekString(pFormat, "/p", EXACT_CASE) == TRUE) {
            Advance(2);
            result = AP_LC;
            //SeenAMPM = TRUE;
            SetSeenAMPM(pGlobals, TRUE);
            //DateFormatNeeds |= dtHOUR;
            SetOrDateFormatNeeds(pGlobals, dtHOUR);
         }
         break;

      case '@':
         result = AT_SIGN;
         break;

      case ESCAPE_CHAR:
      case FILL_MARKER:
      case UNDERLINE_CHAR:
      case QUOTE_CHAR:
      case COLOR_MARKER_START:
         result = GetCommonToken(pFormat, c, data);

         if ((result == HOUR_GT) || (result == MINUTE_GT) || (result == SECOND_GT)) {
            //DateFormatNeeds |= (dtMONTH | dtDAY | dtYEAR | dtHOUR | dtMINUTE | dtSECOND);
            SetOrDateFormatNeeds(pGlobals, (dtMONTH | dtDAY | dtYEAR | dtHOUR | dtMINUTE | dtSECOND));
         }
         break;
   }

   if (result == TOK_UNDEFINED) {
      result = NO_ESC_CHAR_INSERT;
      data[0] = c;
      data[1] = 0;

      #ifdef DBCS
         if (IsDBCSLeadByte(c))
            data[1] = GetChar(pFormat, CH_GET);
      #endif
   }
   return (result);
}


/* CheckNumericFormat -- Check for impossible formats and setup control */
private int CheckNumericFormat (NIP p)
{
   uns   i;
   int   currentState, nextState;
   int   code, tokenType;

   static byte FSM[4][4] = {0, 1, 2, 9,
                            1, 1, 2, 3,
                            2, 2, 9, 3,
                            3, 3, 9, 9};

   #define statePRIOR_NUM   0      /* Possible states */
   #define stateLEFT_DP     1
   #define stateRIGHT_DP    2
   #define stateEXPONENT    3

   #define typeTEXTITEM     0
   #define type09           1
   #define typeDP           2
   #define typeEXP          3

   if (p == NULL)
      return (FMT_errSuccess);

   p->digitsLeftDP   = 0;
   p->digitsRightDP  = 0;
   p->digitsExponent = 0;
   p->exponentEnable = FALSE;

   if ((p->formatCodeCount == 1) && (p->formatCodes[0].code == GENERAL))
      return (FMT_errSuccess);

   /* The general format of a numeric format string is:
   **
   **        <non 0-9> <0-9> <dp> <0-9> <exponent> <0-9> <non 0-9>
   **
   ** Where "<non 0-9>" are quoted inserts, char inserts,
   ** column fill, and color tokens
   **
   ** We must check that this general pattern is not violated
   ** by misplaced tokens.  This is done by a simple state machine
   ** described by the following table:
   **
   **                        <<input token>>
   **    <<state>>      text    0-9    .      E
   **                 +------+------+------+------+
   **     0: prior #  |  0   |  1   |  2   |  X   |
   **                 +------+------+------+------+
   **     1: left DP  |  1   |  1   |  2   |  3   |
   **                 +------+------+------+------+
   **     2: right DP |  2   |  2   |  X   |  3   |
   **                 +------+------+------+------+
   **     3: exponent |  3   |  3   |  X   |  X   |
   **                 +------+------+------+------+
   **
   ** The cells containg an 'X' denote an invalid format
   **
   ** In addition to validating the parsing of numeric formats this function
   ** also accumulates necessary statistics about the format for rendering
   ** (digits left, digits right, etc.).
   */

   currentState = statePRIOR_NUM;

   for (i = 0; i < p->formatCodeCount; i++)
   {
      code = p->formatCodes[i].code;

      if ((code == PERCENT) || ((code >= QUOTED_INSERT) && (code <= CONDITIONAL)))
         tokenType = typeTEXTITEM;

      else if ((code == DIGIT0) || (code == DIGIT_NUM) || (code == DIGIT_QM))
         tokenType = type09;

      else if (code == DECIMAL_SEPARATOR)
         tokenType = typeDP;

      else if ((code >= EXPONENT_NEG_UC) && (code <= EXPONENT_POS_LC))
         tokenType = typeEXP;

      else if ((code == FRACTION) || (code == SCALE) || (code == TOK_UNDEFINED))
         continue;

      else
         return (FMT_errInvalidNumericFormat);


      nextState = FSM[currentState][tokenType];
      switch (nextState) {
         case 0:
            break;
         case 1:
            if (tokenType == type09)
               p->digitsLeftDP += 1;
            break;
         case 2:
            if (tokenType == type09)
               p->digitsRightDP += 1;
            break;
         case 3:
            if (tokenType == type09)
               p->digitsExponent += 1;
            break;
         case 4:
            break;
         case 9:
            return (FMT_errInvalidNumericFormat);
      }
      currentState = nextState;
   }

   /*
   ** Only enable the exponent if there are digits in the exponent
   */
   if (p->digitsExponent > 0)
      p->exponentEnable = TRUE;

   return (FMT_errSuccess);
}


private BOOL IsCurrencySymbol (char __far *pSource, CP_INFO __far *pIntlInfo)
{
   int  iSymbol;

   if (strncmp(pSource, pIntlInfo->currencySymbol, strlen(pIntlInfo->currencySymbol)) == 0)
      return (TRUE);

   iSymbol = 0;
   while (IntlCurrencySymbols[iSymbol][0] != EOS) {
      if (strncmp(pSource, IntlCurrencySymbols[iSymbol], strlen(IntlCurrencySymbols[iSymbol])) == 0)
         return (TRUE);
      iSymbol++;
   }
   return (FALSE);
}

/* ParseSubFormat -- Compile a numeric format */
private int ParseSubFormat (void * pGlobals, FINFO * pFormat, CP_INFO __far *pIntlInfo, NIP __far *parseResult)
{
   uns     rc;
   int     i, j, token, lastToken;
   int     storedTokenCount;
   int     tokenCount, ctTypes;
   int     percentCount, thousandsSeparatorCount, currencyCount, digit0Count;
   int     formatNext, tokIdx, offset;
   uns     nodeSize;
   uns     tokenCharStart;
   NIP     pResult;
   NIP     pNum;
   TIP     pText;
   GIP     pGeneral;
   DTIP    pDate;
   FC      __far *pParsedFormat;
   char    __far *pSource;
   char    tokenArgument[MAX_FORMAT_IMAGE + 1];
   int     tokenClass[5] = {0, 0, 0, 0, 0};

   *parseResult = NULL;

   tokenCount = 0;
   storedTokenCount = 0;

   percentCount = 0;
   currencyCount = 0;
   thousandsSeparatorCount = 0;
   digit0Count = 0;

   //SeenAMPM  = FALSE;
   SetSeenAMPM(pGlobals, FALSE);
   //DateFormatNeeds = 0;
   SetDateFormatNeeds(pGlobals, 0);

   /*
   ** Scan the format to see how big the compiled format will be
   */
   formatNext = pFormat->next;

   tokenCharStart = pFormat->next;
   if ((token = GetToken(pGlobals, pFormat, tokenArgument)) == TOK_EOS)
      return (FMT_errEOS);

   if (token < FMT_errSuccess)
      return (token);

   while ((token != TOK_EOS) && (token != FORMAT_SEPARATOR))
   {
      storedTokenCount++;
      switch (token) {
         case DIGIT0:
            digit0Count++;
            break;
         case PERCENT:
            percentCount++;
            break;
         case QUOTED_INSERT:
            offset = tokenCharStart + 1;
            pSource = pFormat->string + offset;
            if (IsCurrencySymbol(pSource, pIntlInfo) == TRUE)
               currencyCount++;
            break;
         case ESC_CHAR_INSERT:
         case NO_ESC_CHAR_INSERT:
            if (IsCurrencySymbol(tokenArgument, pIntlInfo) == TRUE)
               currencyCount++;
            break;
      }
      tokenCount++;
      tokenClass[FmtTokenType[token]] = 1;

      tokenCharStart = pFormat->next;
      if ((token = GetToken(pGlobals, pFormat, tokenArgument)) < FMT_errSuccess)
         return (token);
   }
   lastToken = token;

   /*
   ** Does the format make sense?
   */
   if (storedTokenCount == 0)
      return (FMT_errEmptyFormatString);

   ctTypes = tokenClass[typeGENERAL] + tokenClass[typeDATE] + tokenClass[typeNUMBER] + tokenClass[typeTEXT];
   if (ctTypes > 1)
      return (FMT_errInvalidFormat);

   if ((ctTypes == 0) && (digit0Count > 0))
      tokenClass[typeNUMBER] = 1;


   /*
   ** Allocate space to hold the compiled format and save the overall
   ** format info
   */
   if (tokenClass[typeDATE] == 1) {
      nodeSize = sizeof(DateTimeInfo) + (storedTokenCount * sizeof(FormatCode));
      if ((pDate = MemAllocate(pGlobals, nodeSize)) == NULL)
         return (FMT_errOutOfMemory);

      pDate->tag = tagDATE_TIME;
      pDate->formatCodeCount = storedTokenCount;
      //pDate->formatNeeds = DateFormatNeeds;
      pDate->formatNeeds = GetDateFormatNeeds(pGlobals);

      pParsedFormat = pDate->formatCodes;
      pResult = (NIP)pDate;
   }

   else if (tokenClass[typeNUMBER] == 1) {
      nodeSize = sizeof(NumInfo) + (storedTokenCount * sizeof(FormatCode));
      if ((pNum = MemAllocate(pGlobals, nodeSize)) == NULL)
         return (FMT_errOutOfMemory);

      pNum->tag = tagNUMERIC;
      pNum->formatCodeCount = storedTokenCount;
      pNum->commaEnable     = (thousandsSeparatorCount > 0);
      pNum->percentEnable   = (percentCount > 0);
      pNum->currencyEnable  = (currencyCount > 0);

      pParsedFormat = pNum->formatCodes;
      pResult = (NIP)pNum;
   }

   else if (tokenClass[typeGENERAL] == 1) {
      nodeSize = sizeof(GeneralInfo) + (storedTokenCount * sizeof(FormatCode));
      if ((pGeneral = MemAllocate(pGlobals, nodeSize)) == NULL)
         return (FMT_errOutOfMemory);

      pGeneral->tag = tagGENERAL;
      pGeneral->formatCodeCount = storedTokenCount;

      pParsedFormat = pGeneral->formatCodes;
      pResult = (NIP)pGeneral;
   }

   else {
      nodeSize = sizeof(TextInfo) + (storedTokenCount * sizeof(FormatCode));
      if ((pText = MemAllocate(pGlobals, nodeSize)) == NULL)
         return (FMT_errOutOfMemory);

      pText->tag = tagTEXT;
      pText->formatCodeCount = storedTokenCount;

      pParsedFormat = pText->formatCodes;
      pResult = (NIP)pText;
   }


   /*
   ** Re-parse the format and store the compiled tokens
   */
   pFormat->next = formatNext;
   tokIdx = 0;

   for (i = 0; i < tokenCount; i++)
   {
      tokenCharStart = pFormat->next;
      token = GetToken(pGlobals, pFormat, tokenArgument);

      if (token == THOUSANDS_SEPARATOR)
         ;
      else if ((token == QUOTED_INSERT) || (token == COLOR_SET) || (token == CONDITIONAL)) {
         pParsedFormat[tokIdx].code  = (byte)token;
         pParsedFormat[tokIdx].info1 = (byte)tokenCharStart;
         pParsedFormat[tokIdx].info2 = (byte)(pFormat->next - tokenCharStart);
         tokIdx++;
      }
      else if ((token == ESC_CHAR_INSERT) || (token == NO_ESC_CHAR_INSERT) ||
               (token == COLUMN_FILL) || (token == UNDERLINE)) {
         pParsedFormat[tokIdx].code  = (byte)token;
         pParsedFormat[tokIdx].info1 = (byte)tokenArgument[0];
         pParsedFormat[tokIdx].info2 = (byte)tokenArgument[1];
         tokIdx++;
      }
      else {
         pParsedFormat[tokIdx].code = (byte)token;
         tokIdx++;
      }
   }

   /*
   ** Pick up the format separator
   */
   if (lastToken == FORMAT_SEPARATOR)
      GetToken (pGlobals, pFormat, tokenArgument);


   /*
   ** Perform final checks and adjustments
   */
   if (pResult->tag == tagNUMERIC)
   {
      pNum->scaleCount = 0;
      for (i = 0; i < storedTokenCount; i++) {
         if (pParsedFormat[i].code == SCALE)
         {
            if (i == 0) {
               /* First token */
               pNum->scaleCount += 1;
            }
            else if (i == (storedTokenCount - 1)) {
               /* Last token */
               pNum->scaleCount += 1;
            }
            else {
               /* Middle token */
               if (DIGIT_PLACEHOLDER(pParsedFormat[i - 1].code) && DIGIT_PLACEHOLDER(pParsedFormat[i + 1].code)) {
                  pNum->commaEnable = TRUE;
                  pParsedFormat[i].code = TOK_UNDEFINED;
               }
               else {
                  pNum->scaleCount += 1;
               }
            }
         }
      }

      if ((rc = CheckNumericFormat(pResult)) != FMT_errSuccess)
         return (rc);
   }

   else if (pResult->tag == tagDATE_TIME) {
      /*
      ** The Excel manual states that the string "mm" is only treated as
      ** minutes if it follows "hh", otherwise it is treated as months.
      ** This is totall false - if it were true then "mm:ss" would not
      ** work.  Since its a standard format it must work.
      **
      ** Seems like as soon as you see "hh" or "ss" then all "mm"
      ** that follow are minutes.  In addition "mm" followed by "hh"
      ** "ss" (skipping character insertions) is also minutes.
      */
      for (i = 0; i < storedTokenCount; i++) {
         if ((pParsedFormat[i].code == MONTH_NUMBER) || (pParsedFormat[i].code == MONTH_NUMBER2))
         {
            for (j = i + 1; j < storedTokenCount; j++) {
               switch (pParsedFormat[j].code)
               {
                  case HOUR_24:
                  case HOUR2_24:
                  case SECOND:
                  case SECOND2:
                  case TIME_FRAC:
                     pParsedFormat[i].code = (pParsedFormat[i].code == MONTH_NUMBER)? MINUTE : MINUTE2;
                     goto done;

                  case QUOTED_INSERT:
                  case ESC_CHAR_INSERT:
                  case NO_ESC_CHAR_INSERT:
                     break;

                  default:
                     goto tryLeft;
               }
            }

tryLeft:    for (j = i - 1; j >= 0; j--) {
               switch (pParsedFormat[j].code)
               {
                  case HOUR_24:
                  case HOUR2_24:
                  case SECOND:
                  case SECOND2:
                  case TIME_FRAC:
                     pParsedFormat[i].code = (pParsedFormat[i].code == MONTH_NUMBER)? MINUTE : MINUTE2;
                     goto done;

                  case QUOTED_INSERT:
                  case ESC_CHAR_INSERT:
                  case NO_ESC_CHAR_INSERT:
                     break;

                  default:
                     goto done;
               }
            }
done:       ;
         }
      }
      /*
      ** The semantics of "h" or "H" is best described as:
      **
      ** Display the hour as a one or two digit number in 24-hour
      ** format (0-23) if the format does not include ampm or AMPM.
      ** If the format includes ampm or AMPM, h or H displays the hour
      ** as a one or two digit number in 12-hour format (1-12)
      **
      ** The parsing always treats h or H as HOUR_24.  In this post-processing
      ** scan, we turn HOUR_24 into HOUR_12 if we have seen an AMPM
      */
      if (GetSeenAMPM(pGlobals) == TRUE) 
      {
         for (i = 0; i < storedTokenCount; i++) {
            if (pParsedFormat[i].code == HOUR_24)
               pParsedFormat[i].code = HOUR_12;

            if (pParsedFormat[i].code == HOUR2_24)
               pParsedFormat[i].code = HOUR2_12;
         }
      }

      /*
      ** In a date time format the '/' character must be treated as a character
      ** insert.  The '.' and '0' characters alos may be character inserts or
      ** time fraction marks
      */
      for (i = 0; i < storedTokenCount; i++) {
         if (pParsedFormat[i].code == FRACTION) {
            pParsedFormat[i].code  = NO_ESC_CHAR_INSERT;
            pParsedFormat[i].info1 = '/';
            pParsedFormat[i].info2 = 0;
         }
         else if (pParsedFormat[i].code == DIGIT0) {
            if ((i > 0) && (pParsedFormat[i - 1].code == TIME_FRAC) || (pParsedFormat[i - 1].code == TIME_FRAC_DIGIT))
               pParsedFormat[i].code  = TIME_FRAC_DIGIT;
            else {
               pParsedFormat[i].code  = NO_ESC_CHAR_INSERT;
               pParsedFormat[i].info1 = '0';
               pParsedFormat[i].info2 = 0;
            }
         }
         else if (pParsedFormat[i].code == DECIMAL_SEPARATOR) {
            if ((i < (storedTokenCount - 1)) && (pParsedFormat[i + 1].code == DIGIT0))
               pParsedFormat[i].code = TIME_FRAC;
            else {
               pParsedFormat[i].code  = NO_ESC_CHAR_INSERT;
               pParsedFormat[i].info1 = '.';
               pParsedFormat[i].info2 = 0;
            }
         }
      }
   }

   *parseResult = pResult;
   return (FMT_errSuccess);
}

/*--------------------------------------------------------------------------*/

#ifdef WIN32
private int UnParseToWin32Format
       (CP_INFO __far *pIntlInfo, char __far *formatString, FIP formatInfo, DTIP pFormat)
{
   byte  code;
   int   i, ctParsedFormat;
   FC    __far *pParsedFormat;
   char  __far *dest;
   char  __far *source;
   int   offset, count, pos;

   #define SINGLE_QUOTE 0x27

   pParsedFormat  = pFormat->formatCodes;
   ctParsedFormat = pFormat->formatCodeCount;

   dest = formatString;

   for (i = 0; i < ctParsedFormat; i++)
   {
      code = pParsedFormat[i].code;

      switch (code)
      {
         case QUOTED_INSERT:
            offset = pParsedFormat[i].info1 + 1;
            count  = pParsedFormat[i].info2 - 2;
            source = &(formatInfo->formatString[offset]);

            if ((dest != formatString) && (*(dest - 1) == SINGLE_QUOTE))
               dest--;
            else
               *dest++ = SINGLE_QUOTE;

            for (pos = 0; pos < count; pos++) {
               if ((*dest++ = *source++) == SINGLE_QUOTE)
                  *dest++ = SINGLE_QUOTE;
            }
            *dest++ = SINGLE_QUOTE;
            break;

         case ESC_CHAR_INSERT:
         case NO_ESC_CHAR_INSERT:
            if ((dest != formatString) && (*(dest - 1) == SINGLE_QUOTE))
               dest--;
            else
               *dest++ = SINGLE_QUOTE;

            if (pParsedFormat[i].info1 == '/')
               *dest++ = pIntlInfo->dateSeparator;
            else if ((*dest++ = pParsedFormat[i].info1) == SINGLE_QUOTE)
               *dest++ = SINGLE_QUOTE;

            #ifdef DBCS
               if (pParsedFormat[i].info2 != 0)
                  *dest++ = pParsedFormat[i].info2;
            #endif

            *dest++ = SINGLE_QUOTE;
            break;

         case DAY_NUMBER:
            *dest++ = 'd';
            break;
         case DAY_NUMBER2:
            *dest++ = 'd';
            *dest++ = 'd';
            break;
         case WEEKDAY3:
            strcpy (dest, "ddd");
            dest += 3;
            break;
         case WEEKDAY:
            strcpy (dest, "dddd");
            dest += 4;
            break;
         case MONTH_NUMBER:
            *dest++ = 'M';
            break;
         case MONTH_NUMBER2:
            *dest++ = 'M';
            *dest++ = 'M';
            break;
         case MONTH_NAME3:
            strcpy (dest, "MMM");
            dest += 3;
            break;
         case MONTH_NAME:
            strcpy (dest, "MMMM");
            dest += 4;
            break;
         case YEAR2:
            *dest++ = 'y';
            *dest++ = 'y';
            break;
         case YEAR4:
            strcpy (dest, "yyyy");
            dest += 4;
            break;

         case HOUR_12:
            *dest++ = 'h';
            break;
         case HOUR2_12:
            *dest++ = 'h';
            *dest++ = 'h';
            break;
         case HOUR_24:
            *dest++ = 'H';
            break;
         case HOUR2_24:
            *dest++ = 'H';
            *dest++ = 'H';
            break;
         case MINUTE:
            *dest++ = 'm';
            break;
         case MINUTE2:
            *dest++ = 'm';
            *dest++ = 'm';
            break;
         case SECOND:
            *dest++ = 's';
            break;
         case SECOND2:
            *dest++ = 's';
            *dest++ = 's';
            break;
         case AMPM_UC:
            *dest++ = 't';
            *dest++ = 't';
            break;
         case AP_UC:
            *dest++ = 't';
            break;

         default:
            return (FMT_errInvalidFormat);  // Some sequence that the WIN32 function can't do
      }
   }

   *dest = EOS;
   return (FMT_errSuccess);
}
#endif

/* FMTParse -- Translate a format string to it's internal form */
public int FMTParse
      (void * pGlobals, char __far *formatString, CP_INFO __far *pIntlInfo, FIP formatData)
{
   int   rc;
   int   length;
   NIP   parsedSubFormat;
   
   FINFO  Format;
   FINFO * pFormat = &Format;

   if ((length = strlen(formatString)) == 0)
      return (FMT_errEmptyFormatString);

   Format.string = formatString;
   Format.last = length - 1;
   Format.next = 0;
   Format.data = formatData;

   formatData->subFormatCount = 0;
   rc = FMT_errSuccess;

   forever {
      if ((rc = ParseSubFormat(pGlobals, pFormat, pIntlInfo, &parsedSubFormat)) == FMT_errEOS) {
         rc = FMT_errSuccess;
         break;
      }

      if (formatData->subFormatCount == MAX_SUB_FORMATS) {
         rc = FMT_errTooManySubFormats;
         break;
      }

      if ((rc != FMT_errEmptyFormatString) && (rc != FMT_errSuccess))
         return (rc);
      else if (rc == FMT_errSuccess)
         formatData->subFormat[formatData->subFormatCount] = parsedSubFormat;

      formatData->subFormatCount += 1;
   }

   #ifdef WIN32
   if (rc == FMT_errSuccess) {
      DTIP pDateFormat;
      char OSFormat[MAX_FORMAT_IMAGE + 1];

      if ((formatData->subFormatCount == 1) && (formatData->subFormat[0]->tag == tagDATE_TIME)) {
         pDateFormat = (DTIP)(formatData->subFormat[0]);

         if ((((pDateFormat->formatNeeds & dtMASK_DATE) != 0) && ((pDateFormat->formatNeeds & dtMASK_TIME) == 0)) ||
             (((pDateFormat->formatNeeds & dtMASK_DATE) == 0) && ((pDateFormat->formatNeeds & dtMASK_TIME) != 0)))
         {
            if (UnParseToWin32Format(pIntlInfo, OSFormat, formatData, pDateFormat) == FMT_errSuccess) {
               if ((pDateFormat->pOSFormat = MemAllocate(pGlobals, strlen(OSFormat) + 1)) == NULL)
                  return (FMT_errOutOfMemory);

               strcpy (pDateFormat->pOSFormat, OSFormat);
            }
         }
      }
   }
   #endif

   return (rc);
}

/*--------------------------------------------------------------------------*/

private int UnParseSubFormat (char __far *formatString, FIP formatInfo, NIP pSubFormat)
{
   int   i, j;
   byte  code;
   int   ctParsedFormat;
   FC    __far *pParsedFormat;
   char  __far *dest;
   char  __far *source;
   int   offset, count, pos;
   char  __far *temp;
   char  tempBuffer[MAX_FORMAT_IMAGE + 1];
   int   digitCount, insertCount;
   BOOL  inDigits;

   if (pSubFormat->tag == tagNUMERIC) {
      pParsedFormat  = pSubFormat->formatCodes;
      ctParsedFormat = pSubFormat->formatCodeCount;
   }
   else if (pSubFormat->tag == tagDATE_TIME) {
      pParsedFormat  = ((DTIP)pSubFormat)->formatCodes;
      ctParsedFormat = ((DTIP)pSubFormat)->formatCodeCount;
   }
   else if (pSubFormat->tag == tagTEXT) {
      pParsedFormat  = ((TIP)pSubFormat)->formatCodes;
      ctParsedFormat = ((TIP)pSubFormat)->formatCodeCount;
   }
   else {
      pParsedFormat  = ((GIP)pSubFormat)->formatCodes;
      ctParsedFormat = ((GIP)pSubFormat)->formatCodeCount;
   }

   temp = tempBuffer;
   tempBuffer[0] = EOS;
   insertCount = 0;

   if (pSubFormat->tag == tagNUMERIC) {
      if (pSubFormat->commaEnable == TRUE) {
         digitCount = 0;
         inDigits = FALSE;

         for (i = 0; i < ctParsedFormat; i++) {
            code = pParsedFormat[i].code;

            if (inDigits == FALSE) {
               if ((code == DIGIT0) || (code == DIGIT_NUM) || (code == DIGIT_QM))
                  inDigits = TRUE;
            }

            if (inDigits == TRUE) {
               if (code == DIGIT0) {
                  digitCount++; *temp++ = '0';
               }
               else if (code == DIGIT_NUM) {
                  digitCount++; *temp++ = '#';
               }
               else if (code == DIGIT_QM) {
                  digitCount++; *temp++ = '?';
               }
               else
                  break;
            }
         }
         *temp = EOS;

         FMTInsertCommas (tempBuffer, sizeof(tempBuffer) - 1, digitCount, TRUE);
         insertCount = strlen(tempBuffer) - digitCount;
      }
   }

   dest = formatString;
   temp = tempBuffer;

   for (i = 0; i < ctParsedFormat; i++)
   {
      code = pParsedFormat[i].code;

      if ((code == DIGIT0) || (code == DIGIT_NUM) || (code == DECIMAL_SEPARATOR)) {
         if (insertCount > 0) {
            for (j = 0; j < insertCount; j++)
               *dest++ = *temp++;
         }
         insertCount = 0;
      }

      switch (code)
      {
         case TOK_UNDEFINED:
            break;

         case QUOTED_INSERT:
            offset = pParsedFormat[i].info1 + 1;
            count  = pParsedFormat[i].info2 - 2;
            source = &(formatInfo->formatString[offset]);
            *dest++ = QUOTE_CHAR;
            for (pos = 0; pos < count; pos++)
               *dest++ = *source++;
            *dest++ = QUOTE_CHAR;
            break;

         case ESC_CHAR_INSERT:
            *dest++ = FORMAT_ESCAPE_CHAR;
            // Fall through

         case NO_ESC_CHAR_INSERT:
            *dest++ = pParsedFormat[i].info1;

            #ifdef DBCS
               if (pParsedFormat[i].info2 != 0)
                  *dest++ = pParsedFormat[i].info2;
            #endif
            break;

         case COLUMN_FILL:
            *dest++ = FILL_MARKER;
            *dest++ = pParsedFormat[i].info1;

            #ifdef DBCS
               if (pParsedFormat[i].info2 != 0)
                  *dest++ = pParsedFormat[i].info2;
            #endif
            break;

         case COLOR_SET:
         case CONDITIONAL:
            offset = pParsedFormat[i].info1 + 1;
            count  = pParsedFormat[i].info2 - 2;
            source = &(formatInfo->formatString[offset]);
            *dest++ = COLOR_MARKER_START;
            for (pos = 0; pos < count; pos++)
               *dest++ = *source++;
            *dest++ = COLOR_MARKER_END;
            break;

         case UNDERLINE:
            *dest++ = '_';
            *dest++ = pParsedFormat[i].info1;
            #ifdef DBCS
               if (pParsedFormat[i].info2 != 0)
                  *dest++ = pParsedFormat[i].info2;
            #endif
            break;


         case DAY_NUMBER:
            *dest++ = 'd';
            break;
         case DAY_NUMBER2:
            *dest++ = 'd';
            *dest++ = 'd';
            break;
         case WEEKDAY3:
            strcpy (dest, "ddd");
            dest += 3;
            break;
         case WEEKDAY:
            strcpy (dest, "dddd");
            dest += 4;
            break;
         case MONTH_NUMBER:
            *dest++ = 'm';
            break;
         case MONTH_NUMBER2:
            *dest++ = 'm';
            *dest++ = 'm';
            break;
         case MONTH_NAME3:
            strcpy (dest, "mmm");
            dest += 3;
            break;
         case MONTH_NAME:
            strcpy (dest, "mmmm");
            dest += 4;
            break;
         case MONTH_LETTER:
            strcpy (dest, "mmmmm");
            dest += 5;
            break;
         case YEAR2:
            *dest++ = 'y';
            *dest++ = 'y';
            break;
         case YEAR4:
            strcpy (dest, "yyyy");
            dest += 4;
            break;

         case HOUR_12:
         case HOUR_24:
            *dest++ = 'h';
            break;
         case HOUR2_12:
         case HOUR2_24:
            *dest++ = 'h';
            *dest++ = 'h';
            break;
         case MINUTE:
            *dest++ = 'm';
            break;
         case MINUTE2:
            *dest++ = 'm';
            *dest++ = 'm';
            break;
         case SECOND:
            *dest++ = 's';
            break;
         case SECOND2:
            *dest++ = 's';
            *dest++ = 's';
            break;
         case HOUR_GT:
            strcpy (dest, "[h]");
            dest += 3;
            break;
         case MINUTE_GT:
            strcpy (dest, "[m]");
            dest += 3;
            break;
         case SECOND_GT:
            strcpy (dest, "[s]");
            dest += 3;
            break;
         case AMPM_UC:
            strcpy (dest, "AM/PM");
            dest += 5;
            break;
         case AMPM_LC:
            strcpy (dest, "am/pm");
            dest += 5;
            break;
         case AP_UC:
            strcpy (dest, "A/P");
            dest += 3;
            break;
         case AP_LC:
            strcpy (dest, "a/p");
            dest += 3;
            break;
         case TIME_FRAC:
            *dest++ = '.';
            break;
         case TIME_FRAC_DIGIT:
            *dest++ = '0';
            break;

         case GENERAL:
            strcpy (dest, GENERAL_NAME);
            dest += strlen(GENERAL_NAME);
            break;

         case DIGIT0:
            *dest++ = (*temp != EOS) ? *temp++ : '0';
            break;
         case DIGIT_NUM:
            *dest++ = (*temp != EOS) ? *temp++ : '#';
            break;
         case DIGIT_QM:
            *dest++ = (*temp != EOS) ? *temp++ : '?';
            break;

         case DECIMAL_SEPARATOR:
            *dest++ = DP;
            break;
         case EXPONENT_NEG_UC:
            *dest++ = 'E';
            *dest++ = '-';
            break;
         case EXPONENT_NEG_LC:
            *dest++ = 'e';
            *dest++ = '-';
            break;
         case EXPONENT_POS_UC:
            *dest++ = 'E';
            *dest++ = '+';
            break;
         case EXPONENT_POS_LC:
            *dest++ = 'e';
            *dest++ = '+';
            break;

         case PERCENT:
            *dest++ = '%';
            break;

         case FRACTION:
            *dest++ = '/';
            break;

         case SCALE:
            *dest++ = ',';
            break;

         case AT_SIGN:
            *dest++ = '@';
            break;

         default:
            ASSERTION (FALSE);
      }
   }

   *dest = EOS;
   return (FMT_errSuccess);
}

/* Return part of the printable representation of the format string */
public int FMTUnParseQuotedParts (char __far *pBuffer, char __far *pSep, FIP formatData)
{
   int   subIdx;
   NIP   pSubFormat;
   char  __far *pDest;
   char  __far *pSource;
   FC    __far *pParsedFormat;
   int   ctParsedFormat;
   int   offset, count, i, cbSep;

   *pBuffer = EOS;
   pDest = pBuffer;

   cbSep = strlen(pSep);

   for (subIdx = 0; subIdx < formatData->subFormatCount; subIdx++)
   {
      if ((pSubFormat = formatData->subFormat[subIdx]) != NULL)
      {
         if (pSubFormat->tag == tagNUMERIC) {
            pParsedFormat  = pSubFormat->formatCodes;
            ctParsedFormat = pSubFormat->formatCodeCount;
         }
         else if (pSubFormat->tag == tagDATE_TIME) {
            pParsedFormat  = ((DTIP)pSubFormat)->formatCodes;
            ctParsedFormat = ((DTIP)pSubFormat)->formatCodeCount;
         }
         else if (pSubFormat->tag == tagTEXT) {
            pParsedFormat  = ((TIP)pSubFormat)->formatCodes;
            ctParsedFormat = ((TIP)pSubFormat)->formatCodeCount;
         }
         else {
            pParsedFormat  = ((GIP)pSubFormat)->formatCodes;
            ctParsedFormat = ((GIP)pSubFormat)->formatCodeCount;
         }

         for (i = 0; i < ctParsedFormat; i++) {
            if (pParsedFormat[i].code == QUOTED_INSERT) {
               offset = pParsedFormat[i].info1 + 1;
               count  = pParsedFormat[i].info2 - 2;
               pSource = &(formatData->formatString[offset]);

               strncpy (pDest, pSource, count);
               pDest += count;

               strcpy (pDest, pSep);
               pDest += cbSep;
            }
         }
      }
   }

   if ((pDest != pBuffer) && (cbSep > 0))
      *(pDest - cbSep) = EOS;

   return (FMT_errSuccess);
}

#endif // !VIEWER

/* end EXFMTPRS.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmipp8st.hpp ===
#ifndef PP8STM_HPP
#define PP8STM_HPP

#if !VIEWER

#ifdef FILTER
   #include "pp97rdr.h"   
   #include "dmifstrm.hpp"
   #include "dmippst2.h"
#else
   #include "ifstrm.hpp"
   #include "ppstream.h"
#endif

class CPowerPoint8Stream : public IFilterStream
 {
    public:
	  CPowerPoint8Stream();
      ULONG   AddRef();
      HRESULT Load(TCHAR *lpszFileName);
      HRESULT LoadStg(IStorage * pstg);
      HRESULT ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead);
      HRESULT GetNextEmbedding(IStorage ** ppstg);
      HRESULT Unload();
      ULONG   Release();
      HRESULT GetChunk(STAT_CHUNK * pStat);


    private:
      LCID GetDocLanguage(void);

      PPTHandle hFile;
      FileReader* _pFI;
	   IStorage *_pStgFrom;
      BOOL _bRet;
	  BOOL _bDeleteStorage;
      BOOL fFirstChunk;

 };

#endif // !VIEWER

#endif // PP8STM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifmtv5.c ===
/*
** File: EXFMTV5.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/94  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <stdlib.h>
#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

static const FMTType V5BuiltinFormatTypes[] =
{
   FMTGeneral,    //   0: ifmtGen
   FMTNumeric,    //   1: ifmtNoComFixed0
   FMTNumeric,    //   2: ifmtNoComFixed
   FMTNumeric,    //   3: ifmtFixed0
   FMTNumeric,    //   4: ifmtFixed

   FMTCurrency,   //   5: ifmtCurrency
   FMTCurrency,   //   6: ifmtCoCurrency
   FMTCurrency,   //   7: ifmtCurrencyDec
   FMTCurrency,   //   8: ifmtCoCurrencyDec

   FMTNumeric,    //   9: ifmtPct0
   FMTNumeric,    //  10: ifmtPct
   FMTNumeric,    //  11: ifmtExp
   FMTNumeric,    //  12: ifmtFract
   FMTNumeric,    //  13: ifmtFractBond

   FMTDateTime,   //  14: ifmtMMDDYY
   FMTDateTime,   //  15: ifmtDDMMMYY
   FMTDateTime,   //  16: ifmtDDMMM
   FMTDateTime,   //  17: ifmtMMMYY
   FMTDateTime,   //  18: ifmtHHMMAP
   FMTDateTime,   //  19: ifmtHHMMSSAP
   FMTDateTime,   //  20: ifmtHHMM
   FMTDateTime,   //  21: ifmtHHMMSS
   FMTDateTime,   //  22: ifmtMDYHMS

   // Excel 3 FE Additions

   FMTCurrency,   //  23: ifmtUSCurrency
   FMTCurrency,   //  24: ifmtUSCoCurrency
   FMTCurrency,   //  25: ifmtUSCurrencyDec
   FMTCurrency,   //  26: ifmtUSCoCurrencyDec

   //  retired in Excel 5:
   FMTDateTime,   //  27 ifmtRMD: ifmtGEMD_J
   FMTDateTime,   //  28 ifmtKRMD: ifmtKGGGEMD_J
   FMTDateTime,   //  29 ifmtKRRMD: ifmtKGGGEMD_J

   FMTDateTime,   //  30: ifmtMMDDYYUS
   FMTDateTime,   //  31: ifmtKYYMMDD
   FMTDateTime,   //  32: ifmtKHHMM
   FMTDateTime,   //  33: ifmtKHHMMSS

   FMTDateTime,   //  34: ifmtKHHMMAP_T
   FMTDateTime,   //  35: ifmtKHHMMSSAP_T
   FMTDateTime,   //  36: ifmtKYYYYMMDD_K

   // Excel 4 Additions

   FMTNumeric,    //  37: ifmtCurrency2
   FMTNumeric,    //  38: ifmtCoCurrency2
   FMTNumeric,    //  39: ifmtCurrencyDec2
   FMTNumeric,    //  40: ifmtCoCurrencyDec2

   // Excel 5 Additions

   FMTCurrency,   //  41: ifmtAcct
   FMTCurrency,   //  42: ifmtAcctCur
   FMTCurrency,   //  43: ifmtAcctDec
   FMTCurrency,   //  44: ifmtAcctDecCur

   FMTDateTime,   //  45: ifmtMMSS
   FMTDateTime,   //  46: ifmtAbsHMMSS
   FMTDateTime,   //  47: ifmtSS0
   FMTNumeric,    //  48: ifmtEng
   FMTText,       //  49: ifmtText

   // fJapan

   FMTDateTime,   //  50: ifmtGEMD_J
   FMTDateTime,   //  51: ifmtKGGGEMD_J
   FMTDateTime,   //  52: ifmtKYYMM_J
   FMTDateTime,   //  53: ifmtKMMDD_J

   // fKorea

   FMTDateTime,   //  54: ifmtMMDD_K
   FMTDateTime,   //  55: ifmtMMDDYY2_K
   FMTDateTime,   //  56: ifmtMMDDYYYY_K

   // fTaiwan

   FMTDateTime,   //  57: ifmtEMD_T
   FMTDateTime    //  58: ifmtKEMD_T
};

#define EXCEL5_MAX_BUILTIN_FORMATS ((sizeof(V5BuiltinFormatTypes) / sizeof(FMTType)) - 1)

#define MY_DATE_SEP '-'
#define MY_TIME_SEP ':'

static const char __far * const V5BuiltinFormatStrings[] =
   {/*  0 */ "General",
    /*  1 */ "0",
    /*  2 */ "0.00",
    /*  3 */ "#,##0",
    /*  4 */ "#,##0.00",
    /*  5 */ "\"$\"#,##0_);(\"$\"#,##0)",
    /*  6 */ "\"$\"#,##0_);[Red](\"$\"#,##0)",
    /*  7 */ "\"$\"#,##0.00_);(\"$\"#,##0.00)",
    /*  8 */ "\"$\"#,##0.00_);[Red](\"$\"#,##0.00)",
    /*  9 */ "0%",
    /* 10 */ "0.00%",
    /* 11 */ "0.00E+00",
    /* 12 */ "# \?/\?",
    /* 13 */ "# \?\?/\?\?",
    /* 14 */ "mm-d-yyyy",
    /* 15 */ "d-mmm-yy",
    /* 16 */ "d-mmm",
    /* 17 */ "mmm-yy",
    /* 18 */ "h:mm AM/PM",
    /* 19 */ "h:mm:ss AM/PM",
    /* 20 */ "h:mm",
    /* 21 */ "h:mm:ss",
    /* 22 */ "mm-dd-yyyy hh:mm",
    /* 23 */ "",
    /* 24 */ "",
    /* 25 */ "",
    /* 26 */ "",
    /* 27 */ "",
    /* 28 */ "",
    /* 29 */ "",
    /* 30 */ "",
    /* 31 */ "",
    /* 32 */ "",
    /* 33 */ "",
    /* 34 */ "",
    /* 35 */ "",
    /* 36 */ "",
    /* 37 */ "#,##0_);(#,##0)",
    /* 38 */ "#,##0_);[Red](#,##0)",
    /* 39 */ "#,##0.00_);(#,##0.00)",
    /* 40 */ "#,##0.00_);[Red](#,##0.00)",
    /* 41 */ "_(* #,##0_);_(* (#,##0);_(* \"-\"_);_(@_)",
    /* 42 */ "_(\"$\"* #,##0_);_(\"$\"* (#,##0);_(\"$\"* \"-\"_);_(@_)",
    /* 43 */ "_(* #,##0.00_);_(* (#,##0.00);_(* \"-\"??_);(@_)",
    /* 44 */ "_(\"$\"* #,##0.00_);_(\"$\"* (#,##0.00);_(\"$\"* \"-\"??_);(@_)",
    /* 45 */ "mm:ss",
    /* 46 */ "[h]:mm:ss",
    /* 47 */ "mm:ss.0",
    /* 48 */ "##0.0E+0",
    /* 49 */ "@",
    /* 50 */ "",
    /* 51 */ "",
    /* 52 */ "",
    /* 53 */ "",
    /* 54 */ "",
    /* 55 */ "",
    /* 56 */ "",
    /* 57 */ "",
    /* 58 */ ""
   };

/* IMPLEMENTATION */

public FMTType FMTV5FormatType (int ifmt)
{
   if ((ifmt >= 0) && (ifmt <= EXCEL5_MAX_BUILTIN_FORMATS))
      return (V5BuiltinFormatTypes[ifmt]);
   else
      return (FMTNone);
}

private void FormatWithLeadingZeros (char __far *pDest, const char __far *pSource, char c)
{
   while (*pSource != EOS) {
      if (*pSource == c)
         *pDest++ = c;
      *pDest++ = *pSource++;
   }
   *pDest = EOS;
}

private void Substitute (char __far *pSource, char find, char replace)
{
   while (*pSource != EOS) {
      if (*pSource == find)
         *pSource = replace;
      pSource++;
   }
}

#endif // !VIEWER

/* end EXFMTV5.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmipp8st.cpp ===
#include <windows.h>

#ifdef FILTER
   #include "dmipp8st.hpp"
   #include "filterr.h"
#else
   #include "ppstm.hpp"
   #include "filterr.h"
#endif

//
//  Added so as to support DRM errors
//
#include "drm.h"



//////////////////////////////////////////////////////////////////////////////////

CPowerPoint8Stream::CPowerPoint8Stream()
{
        hFile = 0;
        _pFI = 0;
        _pStgFrom = 0;
        _bRet = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////

ULONG CPowerPoint8Stream::AddRef()
{
   return (1);
}

//////////////////////////////////////////////////////////////////////////////////

ULONG CPowerPoint8Stream::Release()
{
   return (0);
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::Load(TCHAR *lpszFileName)
{
   HRESULT rc;
   int nAttemps = 0;

   fFirstChunk = TRUE;

   _bDeleteStorage = TRUE;

   rc = StgOpenStorage(lpszFileName, NULL, STGM_READ | STGM_DIRECT | 
                   STGM_SHARE_DENY_WRITE, NULL, 0, &_pStgFrom);
        
   if (!FAILED(rc))
   {
       rc = CheckIfDRM( _pStgFrom );

       if ( FAILED( rc ) )
           return rc;

        GUID classid;
        STATSTG statstg;

        rc = _pStgFrom->Stat( &statstg, STATFLAG_NONAME );
        classid = statstg.clsid;
        if(FAILED(rc) || (SUCCEEDED(rc) && classid.Data1 == 0))
        {
            rc = GetClassFile ( lpszFileName, &classid );
            if(FAILED(rc) || (SUCCEEDED(rc) && classid.Data1 == 0))
            {
                if(_pStgFrom)
                {
                    _pStgFrom->Release();
                    _pStgFrom = 0;
                }
                             
                _bRet = FALSE;
                return FILTER_E_UNKNOWNFORMAT;
            }
        }


       _pFI = new FileReader( _pStgFrom );
           if(_pFI)
           {
                  if(_pFI->GetErr() != S_OK)
                  {
                         rc = _pFI->GetErr();
                         _pStgFrom->Release();
                         _pStgFrom = 0;
                         delete _pFI; _pFI = NULL;
                          _bRet = FALSE;
                  }
                  else if( !_pFI->IsPowerPoint() )
                  {
                         _pStgFrom->Release();
                         _pStgFrom = 0;
                         delete _pFI; _pFI = NULL;
                         rc = FILTER_E_UNKNOWNFORMAT;
                          _bRet = FALSE;
                  }
                  else
                  {
                         rc = _pFI->ReadPersistDirectory();
                         if (STG_E_DOCFILECORRUPT == rc)
                         {
                                 _pStgFrom->Release();
                                 _pStgFrom = 0;
                                 delete _pFI; _pFI = NULL;
                                 _bRet = FALSE;
                         }
                         else
                         {
                                 _pFI->ReadSlideList();
                                 _bRet = TRUE;
                         }
                  }
           }
       else
       {
          //The allocation of the file reader failed.
          //Return an error message that won't confuse the caller
          rc = FILTER_E_UNKNOWNFORMAT;
       }
        }
    else
    {
        if(rc == STG_E_FILEALREADYEXISTS)
            rc = FILTER_E_UNKNOWNFORMAT;
    }
        return (rc);
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::LoadStg(IStorage *pstg)
{
   HRESULT rc = S_OK;

   fFirstChunk = TRUE;
   _bDeleteStorage = FALSE;

   rc = CheckIfDRM( pstg );

   if ( FAILED( rc ) )
       return rc;

    _pFI = new FileReader( pstg );
   if(_pFI)
   {
      if( !_pFI->IsPowerPoint() )
      {
         delete _pFI; _pFI = NULL;
         rc = FILTER_E_UNKNOWNFORMAT;
          _bRet = FALSE;

      }
      else
      {
         rc = _pFI->ReadPersistDirectory();
         if (STG_E_DOCFILECORRUPT != rc)
         {
                 _pFI->ReadSlideList();
                 _bRet = TRUE;
         }
      }
   }
   else
   {
      //The allocation of the file reader failed.
      //Return an error message that won't confuse the caller
      rc = FILTER_E_UNKNOWNFORMAT;
   }

   return (rc);
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::Unload()
{
   HRESULT rc = S_OK;
   if(_pFI)
   {
                delete _pFI;
           _pFI = 0;

   }

   if(_bDeleteStorage && _pStgFrom)
   {
                _pStgFrom->Release();
                _pStgFrom = 0;
   }
   return (rc);
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::ReadContent (VOID *pv, ULONG cb, ULONG *pcbRead)
{
    if(_pFI && _bRet)
    {
        _bRet = _pFI->ReadText((WCHAR*)pv, cb, pcbRead);
        *pcbRead *= sizeof(WCHAR);

            if (*pcbRead == 0)
                return (FILTER_E_NO_MORE_TEXT);

            if (*pcbRead < cb)
                return (FILTER_S_LAST_TEXT);

                return S_OK;
    }

        *pcbRead = 0;
        ((WCHAR *)pv)[0] = 0;

    return FILTER_E_NO_MORE_TEXT;
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::GetNextEmbedding(IStorage ** ppstg)
{
        return _pFI->GetNextEmbedding(ppstg);
}

//////////////////////////////////////////////////////////////////////////////////

HRESULT CPowerPoint8Stream::GetChunk(STAT_CHUNK * pStat)
{
#if(0)
    if(fFirstChunk)
    {
        pStat->locale = GetDocLanguage();
        fFirstChunk = FALSE;
        return S_OK;
    }
    else
    {
        return FILTER_E_NO_MORE_TEXT;
    }
#else
    return _pFI->GetChunk(pStat);
#endif
}

//////////////////////////////////////////////////////////////////////////////////

LCID CPowerPoint8Stream::GetDocLanguage(void)
{
    if(_pFI->GetLCD())
    {
        return _pFI->GetLCD();
    }
    else
    {
        return GetSystemDefaultLCID();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmippst2.c ===
/*
** PPSTREAM.C
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Windows powerpoint filter.
**
** Edit History:
**  12/30/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifndef INC_OLE2
   #define INC_OLE2
#endif

#include <string.h>
#include <windows.h>

#ifndef FILTER_LIB
#include "msostr.h"
#else // FILTER_LIB
#define MsoMultiByteToWideChar MultiByteToWideChar
#define MsoWideCharToMultiByte WideCharToMultiByte
#endif // FILTER_LIB

#ifndef WIN32
   #include <ole2.h>
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmippst2.h"
   #include "filterr.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "ppstream.h"
   #include "filterr.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

typedef struct {
   LPSTORAGE     pRootStorage;
   LPSTREAM      pTextStream;
   LPSTORAGE     pEnumStorage;
   LPENUMSTATSTG pEnum;
   BOOL          releaseStorageOnClose;
   BOOL          isStreamUnicode;
} FileData;

typedef FileData *FDP;

#define STORAGE_ACCESS (STGM_DIRECT | STGM_SHARE_DENY_WRITE | STGM_READ)
#define STREAM_ACCESS  (STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ)

#if (defined(WIN32) && !defined(OLE2ANSI))
   #define ANSI_TEXT_NAME     L"Text_Content"
   #define UNICODE_TEXT_NAME  L"Unicode_Content"
#else
   #define ANSI_TEXT_NAME     "Text_Content"
   #define UNICODE_TEXT_NAME  "Unicode_Content"
#endif


#define FreeString(s)                            \
        {                                        \
           LPMALLOC pIMalloc;                    \
           if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc)) \
               {                                     \
               pIMalloc->lpVtbl->Free(pIMalloc, s);  \
               pIMalloc->lpVtbl->Release(pIMalloc);  \
               }                                     \
        }


/* IMPLEMENTATION */

public HRESULT PPTInitialize (void)
{
   return ((HRESULT)0);
}

public HRESULT PPTTerminate (void)
{
   return ((HRESULT)0);
}

public HRESULT PPTFileOpen (TCHAR *pathname, PPTHandle *hPPTFile)
{
   HRESULT olerc;
   FDP     pFile;
   int          nAttemps = 0;

   *hPPTFile = NULL;

   if ((pFile = calloc(1, sizeof(FileData))) == NULL)
      return (E_OUTOFMEMORY);

#if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      short *pPathInUnicode;
      int   cbPath, cbPathInUnicode;

      cbPath = strlen(pathname);
      cbPathInUnicode = (cbPath + 1) * 2;

      if ((pPathInUnicode = MemAllocate(cbPathInUnicode)) == NULL) {
         MemFree (pFile);
         return (E_OUTOFMEMORY);
      }

      int cwc = MultiByteToWideChar(CP_ACP, 0, pathname, cbPath, pPathInUnicode, cbPathInUnicode/sizeof(wchar_t));
      if(cwc == 0)
      {
          olerc = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
          olerc = StgOpenStorage(pPathInUnicode, NULL, STORAGE_ACCESS, NULL, 0, &(pFile->pRootStorage));
      }

      MemFree (pPathInUnicode);
   }

   #else
   olerc = StgOpenStorage(pathname, NULL, STORAGE_ACCESS, NULL, 0, &(pFile->pRootStorage));
   #endif

   if (GetScode(olerc) != S_OK) 
   {
                free (pFile);
                return (FILTER_E_UNKNOWNFORMAT);
   }
   else
   {     
        GUID classid;
                STATSTG statstg;

        HRESULT rc = pFile->pRootStorage->lpVtbl->Stat(pFile->pRootStorage, &statstg, STATFLAG_NONAME );
        classid = statstg.clsid;
        if(FAILED(rc) || (SUCCEEDED(rc) && classid.Data1 == 0))
        {
                        if(pFile->pRootStorage)
            {
                 pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);
                 free (pFile);
            }
                        return FILTER_E_UNKNOWNFORMAT;
        }
   }

   pFile->isStreamUnicode = TRUE;

#if (0)
   {
           STATSTG  ss;
           ULONG    ulCount;
           SCODE    sc;

           olerc = pFile->pRootStorage->lpVtbl->EnumElements
                                        (pFile->pRootStorage, 0, NULL, 0, &(pFile->pEnum));

           forever {
                  olerc = pFile->pEnum->lpVtbl->Next(pFile->pEnum, 1, &ss, &ulCount);
                  if ((sc = GetScode(olerc)) != S_OK) 
                  {
                         pFile->pEnum->lpVtbl->Release(pFile->pEnum);
                         pFile->pEnum = NULL;
                  }
                }
   }
#endif

   olerc = pFile->pRootStorage->lpVtbl->OpenStream
          (pFile->pRootStorage, UNICODE_TEXT_NAME, NULL, STREAM_ACCESS, 0, &pFile->pTextStream);

   if (GetScode(olerc) != S_OK)
   {
      pFile->isStreamUnicode = FALSE;
      olerc = pFile->pRootStorage->lpVtbl->OpenStream
          (pFile->pRootStorage, ANSI_TEXT_NAME, NULL, STREAM_ACCESS, 0, &pFile->pTextStream);

      if (GetScode(olerc) != S_OK) {
         pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);
         free (pFile);
         return (FILTER_E_UNKNOWNFORMAT);
      }
   }

   pFile->releaseStorageOnClose = TRUE;
   *hPPTFile = (PPTHandle)pFile;

   return ((HRESULT)0);
}

public HRESULT PPTStorageOpen (LPSTORAGE pStorage, PPTHandle *hPPTFile)
{
   FDP      pFile;
   LPSTREAM pTextStream;
   HRESULT  olerc;
   BOOL     isStreamUnicode;

   *hPPTFile = NULL;

   isStreamUnicode = TRUE;
   olerc = pStorage->lpVtbl->OpenStream
          (pStorage, UNICODE_TEXT_NAME, NULL, STREAM_ACCESS, 0, &pTextStream);

   if (GetScode(olerc) != S_OK) {
      isStreamUnicode = FALSE;
      olerc = pStorage->lpVtbl->OpenStream
             (pStorage, ANSI_TEXT_NAME, NULL, STREAM_ACCESS, 0, &pTextStream);

      if (GetScode(olerc) != S_OK)
         return (olerc);
   }

   if ((pFile = calloc(1, sizeof(FileData))) == NULL) {
      pTextStream->lpVtbl->Release(pTextStream);
      return (E_OUTOFMEMORY);
   }

   pFile->pRootStorage = pStorage;
   pFile->pTextStream  = pTextStream;
   pFile->releaseStorageOnClose = FALSE;
   pFile->isStreamUnicode = isStreamUnicode;

   *hPPTFile = (PPTHandle)pFile;
   return ((HRESULT)0);
}

public HRESULT PPTFileClose (PPTHandle hPPTFile)
{
   FDP pFile = (FDP)hPPTFile;

   if (pFile == NULL)
      return ((HRESULT)0);

   // the stuff below is released outside in the wrapper(offfilt.cxx)
   
   //if (pFile->pEnumStorage != NULL)
   //   pFile->pEnumStorage->lpVtbl->Release(pFile->pEnumStorage);

   if (pFile->pEnum != NULL)
      pFile->pEnum->lpVtbl->Release(pFile->pEnum);

   pFile->pTextStream->lpVtbl->Release(pFile->pTextStream);

   if (pFile->releaseStorageOnClose == TRUE)
      pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);

   free (pFile);
   return ((HRESULT)0);
}

public HRESULT PPTNextStorage (PPTHandle hPPTFile, LPSTORAGE *pStorage)
{
   HRESULT  olerc;
   SCODE    sc;
   FDP      pFile = (FDP)hPPTFile;
   STATSTG  ss;
   ULONG    ulCount;

   if (pFile == NULL)
      return (OLEOBJ_E_LAST);

   /*
   ** First time called?
   */
   if (pFile->pEnum == NULL) {
      olerc = pFile->pRootStorage->lpVtbl->EnumElements
                        (pFile->pRootStorage, 0, NULL, 0, &(pFile->pEnum));
      if (GetScode(olerc) != S_OK)
         return (olerc);

      pFile->pEnumStorage = NULL;
   }

   /*
   ** Close storage opened on last call
   */
   if (pFile->pEnumStorage != NULL) {
      //pFile->pEnumStorage->lpVtbl->Release(pFile->pEnumStorage);
      pFile->pEnumStorage = NULL;
   }

   /*
   ** Locate and open next storage
   */
   forever {
      olerc = pFile->pEnum->lpVtbl->Next(pFile->pEnum, 1, &ss, &ulCount);
      if ((sc = GetScode(olerc)) != S_OK) {
         pFile->pEnum->lpVtbl->Release(pFile->pEnum);
         pFile->pEnum = NULL;

         if (sc == S_FALSE)
            return (OLEOBJ_E_LAST);
         else
            return (olerc);
      }

      if (ss.type == STGTY_STORAGE) {
         olerc = pFile->pRootStorage->lpVtbl->OpenStorage
            (pFile->pRootStorage, ss.pwcsName, NULL, 
                        (STGM_READ | STGM_SHARE_EXCLUSIVE), NULL, 0, &(pFile->pEnumStorage));

         FreeString (ss.pwcsName);

         if (GetScode(olerc) != S_OK)
            return (olerc);

         *pStorage = pFile->pEnumStorage;
         return ((HRESULT)0);
      }
      FreeString (ss.pwcsName);
   }
}

/*---------------------------------------------------------------------------*/

public HRESULT PPTFileRead
      (PPTHandle hPPTFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed)
{
   HRESULT rc;
   FDP     pFile = (FDP)hPPTFile;

   *cbUsed = 0;

#ifdef UNICODE
   if (pFile->isStreamUnicode) {
      //
      // Want unicode and got unicode
      //
      rc = pFile->pTextStream->lpVtbl->Read(pFile->pTextStream, pBuffer, cbBuffer, cbUsed);
   }
   else {
      //
      // Want unicode and got ansi
      //
      unsigned long cbAnsiMax, cbAnsi;
      int  ctUnicodeChars;
      char *pAnsi;

      cbAnsiMax = cbBuffer / 2;
      if ((pAnsi = calloc(1, cbAnsiMax)) == NULL)
         return (E_OUTOFMEMORY);

      rc = pFile->pTextStream->lpVtbl->Read(pFile->pTextStream, pAnsi, cbAnsiMax, &cbAnsi);

      ctUnicodeChars = MsoMultiByteToWideChar(CP_ACP, 0, pAnsi, cbAnsi, (unsigned short *)pBuffer, cbBuffer);
      free (pAnsi);

      *cbUsed = ctUnicodeChars * sizeof(wchar_t);
   }
#else
   if (!pFile->isStreamUnicode) {
      //
      // Want ansi and got ansi
      //
      rc = pFile->pTextStream->lpVtbl->Read(pFile->pTextStream, pBuffer, cbBuffer, cbUsed);
   }
   else {
      //
      // Want ansi and got unicode
      //
      unsigned long cbUnicodeMax, cbUnicode;
      wchar_t *pUnicode;

      cbUnicodeMax = cbBuffer / 2;
      if ((pUnicode = calloc(1, cbUnicodeMax)) == NULL)
         return (FILTER_E_FF_OUT_OF_MEMORY);

      rc = pFile->pTextStream->lpVtbl->Read(pFile->pTextStream, pUnicode, cbUnicodeMax, &cbUnicode);

      *cbUsed = MsoWideCharToMultiByte(CP_ACP, 0, pUnicode, cbUnicode, pBuffer, cbBuffer, NULL, NULL);
      free (pUnicode);
   }
#endif

   return (rc);
}

#endif // !VIEWER

/* end PPSTREAM.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmifstrm.hpp ===
// ifstrm.hpp
//
// Interface for format-specific streams to be plugged into filters.

#include "filter.h"

#ifndef IFSTRM_HPP
#define IFSTRM_HPP

class IFilterStream
{
public:
	virtual ~IFilterStream()=0;

	// ------------------------------------------------------------------------
	// Methods.
	
	// This function adds a reference to the given object.  If there is one
	// time initialization that needs to be done, including memory that needs
	// to be allocated, it should be done on the first call to this function.
	// NOTE: This function must be called before any other function on this
	// object.
	// Returns: number of references to this object

	virtual ULONG AddRef()=0;

	// This function loads a file and allocates any memory needed for a
	// particular file.  This function must be called before any of the other
	// functions for this class except AddRef() and Release().
	// Returns: anything that IPersistFile::Load can return (S_OK, E_FAIL,
	// E_OUTOFMEMORY, any STG_E errors) plus the following errors:
	// FILTER_E_ACCESS, and FILTER_E_FF_INCORRECT_FORMAT.

	virtual HRESULT Load(LPTSTR lpszFileName)=0;

	// This function is the equivalent of Load except that it takes an IStream
	// handle instead of a file name.
	// Returns: anything that Load can return.

	virtual HRESULT LoadStg(IStorage * pstg)=0;

	// This function reads successive chunks of the file with each call.
	// An empty buffer of size cb is passed in through the pv variable.
	// This function fills the buffer and returns the number of bytes
	// placed in the buffer in the variable pcbRead.
	// Returns: any errors that IStream::Read can return, plus
	// FILTER_S_LAST_TEXT (after this buffer, there will be no more text to
	// return from the file) and FILTER_E_NO_MORE_TEXT (there is no more text
	// to return from the file).

	virtual HRESULT ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead)=0;

	// This function reads the next embedding from the loaded file.  If there
	// are no more embeddings, it returns FILTER_E_FF_END_OF_EMBEDDINGS.

	virtual HRESULT GetNextEmbedding(IStorage ** ppstg)=0;

	// This function releases all memory allocated by Load and closes the open
	// file.
	// Returns: this function should probably only have to ever return S_OK,
	// but any of the errors from Load may be returned.

	virtual HRESULT Unload()=0;

	// This function releases a reference to the given object.  If there is
	// any memory that was allocated in AddRef() it should be released in this
	// function when the reference count reaches zero.
	// Returns: number of references to this object

	virtual ULONG Release()=0;

   	// Positions the filter at the beginning of the next chunk
    // and returns the description of the chunk in pStat
    
    virtual HRESULT GetChunk(STAT_CHUNK * pStat){ return 0;}
};

#endif // IFSTRM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmippst2.h ===
/*
** PPSTREAM.H
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Windows powerpoint filter.
**
** Edit History:
**  12/30/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define PPSTREAM_H


/* DEFINITIONS */

#ifdef  __cplusplus
extern "C" {
#endif

#ifdef WIN32
   #define __far
#endif

typedef byte *PPTHandle;

// Connects to AddRef
extern HRESULT PPTInitialize (void);

// Connects to Release
extern HRESULT PPTTerminate  (void);

// Connects to Load
extern HRESULT PPTFileOpen (TCHAR *pathname, PPTHandle *hPPTFile);

// Connects to LoadStg
extern HRESULT PPTStorageOpen (LPSTORAGE pStorage, PPTHandle *hPPTFile);

// Connects to GetNextEmbedding
extern HRESULT PPTNextStorage (PPTHandle hPPTFile, LPSTORAGE *pStorage);

// Connects to Unload
extern HRESULT PPTFileClose (PPTHandle hPPTFile);

// Connects to ReadContent
extern HRESULT PPTFileRead
      (PPTHandle hPPTFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed);

#ifdef  __cplusplus
}
#endif

#endif // !VIEWER
/* end PPSTREAM.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmippstm.hpp ===
#ifndef PPSTM_HPP
#define PPSTM_HPP

#if !VIEWER

#ifdef FILTER
   #include "dmifstrm.hpp"
   #include "dmippst2.h"
#else
   #include "ifstrm.hpp"
   #include "ppstream.h"
#endif

class CPowerPointStream : public IFilterStream
 {
    public:
      ULONG   AddRef();
      HRESULT Load(TCHAR *lpszFileName);
      HRESULT LoadStg(IStorage * pstg);
      HRESULT ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead);
      HRESULT GetNextEmbedding(IStorage ** ppstg);
      HRESULT Unload();
      ULONG   Release();
      HRESULT GetChunk(STAT_CHUNK * pStat);


    private:
      LCID GetDocLanguage(void);

      PPTHandle hFile;
      BOOL fFirstChunk;
 };

#endif // !VIEWER

#endif // PPSTM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmippstm.cpp ===
#include <windows.h>

#if !VIEWER

#ifdef FILTER
        #include "dmippstm.hpp"
   #include "filterr.h"
#else
   #include "ppstm.hpp"
   #include "filterr.h"
#endif
//
//  Added so as to support DRM errors
//
#include "drm.h"

ULONG CPowerPointStream::AddRef()
{
   HRESULT rc;

   /* What do I do about errors from Initialize? */

   rc = PPTInitialize();
   return (1);
}

HRESULT CPowerPointStream::Load(TCHAR *lpszFileName)
{
   HRESULT rc;

   rc = PPTFileOpen(lpszFileName, &hFile);
   fFirstChunk = TRUE;
   return (rc);
}

HRESULT CPowerPointStream::LoadStg(IStorage *pstg)
{
   HRESULT rc = CheckIfDRM( pstg );

   if ( FAILED( rc ) )
       return rc;

   rc = PPTStorageOpen(pstg, &hFile);
   fFirstChunk = TRUE;
   return (rc);
}

HRESULT CPowerPointStream::ReadContent (VOID *pv, ULONG cb, ULONG *pcbRead)
{
   HRESULT rc;

   rc = PPTFileRead(hFile, (byte *)pv, cb, pcbRead);
   if (rc != 0)
      return (rc);

        if (*pcbRead == 0)
                return (FILTER_E_NO_MORE_TEXT);

   if (*pcbRead < cb)
      return (FILTER_S_LAST_TEXT);
   else
      return ((HRESULT)0);
}

HRESULT CPowerPointStream::GetNextEmbedding(IStorage ** ppstg)
{
   HRESULT rc;

   rc = PPTNextStorage(hFile, ppstg);
   return (rc);
}

HRESULT CPowerPointStream::Unload()
{
   HRESULT rc;

   rc = PPTFileClose(hFile);
   return (rc);
}

ULONG CPowerPointStream::Release()
{
   HRESULT rc;

   /* What do I do about errors from terminate? */

   rc = PPTTerminate();
   return (0);
}

HRESULT CPowerPointStream::GetChunk(STAT_CHUNK * pStat)
{
    if(fFirstChunk)
    {
        pStat->locale = GetDocLanguage();
        fFirstChunk = FALSE;
        return S_OK;
    }
    else
    {
        return FILTER_E_NO_MORE_TEXT;
    }
}

LCID CPowerPointStream::GetDocLanguage(void)
{
    return GetSystemDefaultLCID();
}

#endif // !VIEWER

/* end PPTSTM.CPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiwd8st.cpp ===
#include <windows.h>

extern "C" ULONG _cdecl DbgPrint(PCSTR, ...);

#if !VIEWER

#include "dmiwd8st.hpp"
#include "filterr.h"

//
//  Added so as to support DRM errors
//
#include "drm.h"


#ifdef FILTER_LIB
CGlobals g_globals;
CGlobals * g_pglobals;
#endif // FILTER_LIB

// Various parts of FIB that we need, in Word 8 format.
// (plus, of course, m_wFlagsAt10)

#define FIB_OFFSET_lid 6
#define FIB_OFFSET_csw 32
#define FIB_OFFSET_fcStshf  8
#define FIB_OFFSET_lcbStshf 12
#define BX_SIZE 13
#define istdNil 0xfff

#define RGFCLCB_OFFSET_fcClx    264

#define RGFCLCB_OFFSET_fcPlcfbteChpx 96

#define W96_MAGIC_NUMBER 0xa5ec

#define W96_nFibCurrent 193

// SPRM opcode is 2 bytes in W96 (1 byte inside PRM1).
#define sprmCFSpec              0x0855
#define isprmCFSpec             117
#define sprmCFStrikeRM  0x0800
#define isprmCFStrikeRM 65
#define sprmCLid 0x4a41
#define sprmCRgLid0 0x486d
#define sprmCRgLid1 0x486e
#define sprmCIdctHint 0x286F

// Special characters we are interested in.
#define ChSpec_FIELD_BEGIN 0x13
#define ChSpec_FIELD_SEP 0x14
#define ChSpec_FIELD_END 0x15
// Different between W8 and W6 for some unknown reason.
#define ChSpec_EMPTY_FORMFIELD 0x2002

// Complex part of the file consists of pieces preceded by these bytes:
#define clxtGrpprl 1
#define clxtPlcfpcd 2

extern "C" UINT CodePageFromLid(UINT wLid);

#ifdef MAC
// These two functions are defined in docfil.cpp
WORD    SwapWord( WORD theWord );
DWORD   SwapDWord( DWORD theDWord );
#else
#define SwapWord( theWord )             theWord
#define SwapDWord( theDWord )   theDWord
#endif // MAC


CWord8Stream::CWord8Stream() :
        m_pStg(NULL),
        m_pstgEmbed(NULL),
        m_pestatstg(NULL),
        m_pstgOP(NULL),
        m_pStmMain(NULL),
        m_pStmTable(NULL),
        m_rgcp(NULL),
        m_rgpcd(NULL),
        m_rgbte(NULL),
        m_rgfcBinTable(NULL),
        m_pCache(NULL),
        m_rgchANSIBuffer(NULL), 
    m_pLangRuns(NULL), 
    m_rgbtePap(NULL), 
    m_rgfcBinTablePap(NULL),
    m_pSTSH(NULL), 
        m_lcbStshf(0),
        m_bFEDoc(FALSE),
        m_FELid(0)
        {
        AssureDtorCalled(CWord8Stream);
        }

CWord8Stream::~CWord8Stream()
        {
        Unload();

        // Delete m_rgchANSIBuffer in the destructor, not in Unload, so it will be
        // re-used from one document to another.
        if (m_rgchANSIBuffer)
                {
                FreePv (m_rgchANSIBuffer);
                m_rgchANSIBuffer = NULL;
                }
        }

#ifdef WIN
HRESULT CWord8Stream::Load(LPTSTR lpszFileName)
        {
        IStorage * pstg;

#if defined OLE2ANSI || defined UNICODE
        HRESULT hr = StgOpenStorage(lpszFileName,
                                                                0,
                                                                STGM_PRIORITY,
                                                                0,
                                                                0,
                                                                &pstg);
#else // !defined OLE2ANSI
        CConsTP lszFileName(lpszFileName);
        int cbwsz = (lszFileName.Cch() + 1) * sizeof(WCHAR);
        CHeapStr wszFileName;
        Protect0;
        wszFileName.SetCb(cbwsz);
        int retValue = MultiByteToWideChar(CP_ACP,
                                                                                MB_PRECOMPOSED,
                                                                                lszFileName,
                                                                                lszFileName.Cb(),
                                                                                (WCHAR *)(CHAR *)wszFileName,
                                                                                cbwsz/sizeof(WCHAR));

        if (retValue == 0)
                return FILTER_E_FF_UNEXPECTED_ERROR;

        HRESULT hr = StgOpenStorage((WCHAR *)(CHAR *)wszFileName,
                                                                0,
                                                                STGM_PRIORITY,
                                                                0,
                                                                0,
                                                                &pstg);
#endif // OLE2ANSI

        if (FAILED(hr)) // this is where we can plug in for 2.0 files
    {
                return FILTER_E_UNKNOWNFORMAT;
    }

        hr = LoadStg(pstg);
        pstg->Release();

        return hr;
        }

#endif // WIN

#ifdef  MAC
HRESULT CWord8Stream::Load(FSSpec *pfss)
        {
        Unload();
        m_ccpRead = 0;
        HRESULT hr = StgOpenStorageFSp( pfss,
                                                                 0,
                                                                 STGM_PRIORITY,
                                                                 0,
                                                                 0,
                                                                 &m_pStg );

        if (FAILED(hr)) // This is where we can plug in for 2.0 files.
                return hr;

        hr = m_pStg->OpenStream( (LPOLESTR)"WordDocument",
                                                         0,
                                                         STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                         0,
                                                         &m_pStmMain );

        if (FAILED(hr))
                return hr;

        unsigned short magicNumber;
        hr = Read (&magicNumber, sizeof(unsigned short), m_pStmMain);
        if (FAILED(hr))
                return hr;
        magicNumber = SwapWord(magicNumber);

        // This is where we plug in for 6.0 and 95 files.
        if (magicNumber != W96_MAGIC_NUMBER)
                return FILTER_E_FF_VERSION;

        // Read the flags we need.
        hr = SeekAndRead (0xA, STREAM_SEEK_SET,
                &m_wFlagsAt10, sizeof(m_wFlagsAt10),
                m_pStmMain);
        if (FAILED(hr))
                return hr;
        m_wFlagsAt10 = SwapWord (m_wFlagsAt10);

        // Open the other docfile we will need.
        hr = m_pStg->OpenStream (
#ifdef OLE2ANSI
                                                        m_fWhichTblStm ? "1Table" : "0Table",
#else // !defined OLE2ANSI
                                                        m_fWhichTblStm ? L"1Table" : L"0Table",
#endif // OLE2ANSI
                                                        0,
                                                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                        0,
                                                        &m_pStmTable);
        if (FAILED(hr))
                return hr;

        hr = ReadFileInfo();

        return hr;
        }
#endif  // MAC

HRESULT CWord8Stream::LoadStg(IStorage * pstg)
        {
        Assert(m_pStg == NULL);

        m_pStg = pstg;
        m_pStg->AddRef();

        m_ccpRead = 0;
    
        HRESULT hr = CheckIfDRM( pstg );

        if ( FAILED( hr ) )
            return hr;

        hr = m_pStg->OpenStream (
#ifdef OLE2ANSI
                                                                        "WordDocument",
#else // !defined OLE2ANSI
                                                                        L"WordDocument",
#endif // OLE2ANSI
                                                                        0,
                                                                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                                        0,
                                                                        &m_pStmMain );
    if (FAILED(hr))
                return hr;

        // Make sure we have a W96 document.
        unsigned short magicNumber;
        hr = Read (&magicNumber, sizeof(unsigned short), m_pStmMain);
        if (FAILED(hr))
                return FILTER_E_UNKNOWNFORMAT;

        if (magicNumber != W96_MAGIC_NUMBER)
                return FILTER_E_UNKNOWNFORMAT;

        // Read the flags we need.
        hr = SeekAndRead (0xA, STREAM_SEEK_SET,
                &m_wFlagsAt10, sizeof(m_wFlagsAt10),
                m_pStmMain);
        if (FAILED(hr))
                return hr;
        m_wFlagsAt10 = SwapWord (m_wFlagsAt10);

        if (m_fEncrypted)
                return FILTER_E_PASSWORD;

        // Open the other docfile we will need.
        hr = m_pStg->OpenStream (
#ifdef OLE2ANSI
                                                        m_fWhichTblStm ? "1Table" : "0Table",
#else // !defined OLE2ANSI
                                                        m_fWhichTblStm ? L"1Table" : L"0Table",
#endif // OLE2ANSI
                                                        0,
                                                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                        0,
                                                        &m_pStmTable);
        if (FAILED(hr))
                return hr;

        hr = ReadFileInfo();

        return hr;
        }


HRESULT CWord8Stream::Unload()
        {
        if (m_pStmMain)
                {
#ifdef DEBUG
                ULONG cref =
#endif // DEBUG
                m_pStmMain->Release();
                m_pStmMain = NULL;
                Assert (cref==0);
                }
        if (m_pStmTable)
                {
#ifdef DEBUG
                ULONG cref =
#endif // DEBUG
                m_pStmTable->Release();
                m_pStmTable = NULL;
                Assert (cref==0);
                }
        if (m_pStg)
                {
                m_pStg->Release();
                m_pStg = NULL;
                }
        if (m_pstgEmbed)
                {
                //m_pstgEmbed->Release();
                m_pstgEmbed = NULL;
                }
        if (m_pestatstg)
                {
                m_pestatstg->Release();
                m_pestatstg = NULL;
                }
        if (m_pstgOP)
                {
                m_pstgOP->Release();
                m_pstgOP = NULL;
                }

        if (m_rgcp)
                {
                FreePv (m_rgcp);
                m_rgcp = NULL;
                }
        if (m_rgpcd)
                {
                FreePv (m_rgpcd);
                m_rgpcd = NULL;
                }
        
    if (m_rgfcBinTable)
                {
                FreePv (m_rgfcBinTable);
                m_rgfcBinTable = NULL;
                }
        if (m_rgbte)
                {
                FreePv (m_rgbte);
                m_rgbte = NULL;
                }

    if (m_rgfcBinTablePap)
                {
                FreePv (m_rgfcBinTablePap);
                m_rgfcBinTablePap = NULL;
                }
        if (m_rgbtePap)
                {
                FreePv (m_rgbtePap);
                m_rgbtePap = NULL;
                }
        if (m_pSTSH)
                {
                FreePv (m_pSTSH);
                m_pSTSH = NULL;
                m_lcbStshf = 0;
                }
    if(m_pLangRuns)
        {
        DeleteAll(m_pLangRuns);
        m_pLangRuns = NULL;
        }

    if (m_pCache!=NULL && m_pCache->pbExcLarge!=NULL)
                FreePv (m_pCache->pbExcLarge);
        delete m_pCache;
        m_pCache = NULL;

        return S_OK;
        }


///////////////////////////////////////////////////////////////////////////////
// ReadContent
//
// Read the file into the buffer.  Pieces that are ANSI rather than UNICODE
// are read into m_rgchANSIBuffer, and then converted into the buffer (note
// that these pieces are really ANSI, rather than current codepage's).
//
// Things we don't want in the buffer: special characters, revision text, and
// text that is between field begin and field separator characters (or a field end
// character, if the field separator character has been omitted).  However, we
// must read in special characters to parse them, but we will write over them in
// the buffer after we've parsed them.  Unless there is an error, we never leave
// this function while reading between a field begin and field separator
// character.
// Assumption: we are at the place in the stream where we will be reading text
// from next.
//
HRESULT CWord8Stream::ReadContent (VOID *pv, ULONG cb, ULONG *pcbRead)
{
    *pcbRead = 0;
    HRESULT hr = S_OK;

    if (m_ipcd==m_cpcd)     // At the end of the piece table?
        return FILTER_E_NO_MORE_TEXT;

    // 1 if in an ANSI piece; 2 if in a UNICODE one.
    ULONG cbChar = m_rgpcd[m_ipcd].CbChar();

    // Current position in the stream,
    FC fcCur = m_rgpcd[m_ipcd].GetFC() + (m_ccpRead - m_rgcp[m_ipcd]) * cbChar;

    // Bytes of text left in this piece.
    ULONG cbLeftInPiece = (m_rgcp[m_ipcd+1] - m_ccpRead) * cbChar;

    // How many bytes we can read from the file?
    // Note that if the piece is ANSI, we will have to expand it.
    Assert (cb%sizeof(WCHAR)==0);

    // We pretend we just have half cb size so that later we can safely change 0D to 0D0A
    // to be able to keep end of paragraph info

    cb = cb / 2;
    cb = cb & ~1;

    // If the document is corrupt and cbLeftInPiece is negative, we don't want to use it.
    ULONG cbToRead = (cbLeftInPiece > 0) ? min (cbLeftInPiece, cb*cbChar/sizeof(WCHAR)) : cb*cbChar/sizeof(WCHAR);

    long lcFieldSep = 0;    // count of field begins that haven't been matched
                                                    // with field separators.
    long lcFieldEnd = 0;    // count of field begins that haven't been matched
                                                    // with field ends.
    BYTE *pbBufferCur = (BYTE *)pv;         // pointer to the position in the buffer
                                                                            // where text will be read next.

    while (cbToRead != 0)
    {
        FC fcSpecCur;   // the fc where the next special char run begins
        FC fcSpecEnd;   // the fc where the next special char run ends

        LCID lid;
        if (lcFieldSep == 0)  // Office QFE 1663: No unmatched field begin chars
        {
            HRESULT res = CheckLangID(fcCur, &cbToRead, &lid);
            if(res == FILTER_E_NO_MORE_TEXT)
            {
                hr = res;
                cbToRead = 0;
                goto LCheckNonReqHyphen;
            }
        }

        if (m_fsstate == FSPEC_NONE)
        {
            fcSpecCur = 0;
            fcSpecEnd = 0;
        }
        else if (m_fsstate == FSPEC_ALL)
        {
            fcSpecCur = fcCur;
            fcSpecEnd = fcCur + cbLeftInPiece;
        }
        else
        {               // use the current positions from the fkp
            Assert (m_fsstate == FSPEC_EITHER);
            fcSpecCur = ((FC *)m_fkp)[m_ifcfkp];
            fcSpecEnd = ((FC *)m_fkp)[m_ifcfkp + 1];

            if (fcSpecCur >= fcCur + cbLeftInPiece)
            {       // the next special char is after the current piece of text
                fcSpecCur = 0;
                fcSpecEnd = 0;
            }
            else if (fcSpecEnd > fcCur + cbLeftInPiece)
            {       // the next run extends beyond the current piece of text
                fcSpecEnd = fcCur + cbLeftInPiece;
            }
            else if (fcSpecCur < fcCur)
            {       // we're in the middle of a run of special text
                fcSpecCur = fcCur;
            }
        }

        // If special characters follow text, read both at once.  Also convert
        // to UNICODE both at once if necessary.
        ULONG cbSpecRead = min(cbToRead, fcSpecEnd - fcSpecCur);

        if (lcFieldSep == 0)    // no unmatched field begin characters
        {
            if (fcSpecCur >= fcCur + cbToRead)
            {       // the first special character is too far to fit in buffer
                fcSpecCur = 0;
                fcSpecEnd = 0;
                cbSpecRead = 0;
            }
            else if (fcSpecEnd >= fcCur + cbToRead)
            {
                // the last spec character is too far to fit in buffer
                fcSpecEnd = fcCur + cbToRead;
                cbSpecRead = fcSpecEnd - fcSpecCur;
            }

            // Read up to the end of a run of special characters.
            if (fcSpecEnd != 0)
                cbToRead = fcSpecEnd - fcCur;

            // ANSI?  Read the stuff into m_rgchANSIBuffer, and then expand.
            if (m_rgpcd[m_ipcd].fCompressed)
            {
                if (m_rgchANSIBuffer==NULL)
                    m_rgchANSIBuffer = (char *) PvAllocCb (cbToRead);
                else if (cbToRead>(ULONG)CbAllocatedPv(m_rgchANSIBuffer))
                    m_rgchANSIBuffer = (char *) PvReAllocPvCb (m_rgchANSIBuffer,cbToRead);

                hr = Read (m_rgchANSIBuffer, cbToRead, m_pStmMain);
                if (FAILED(hr))
                    goto LCheckNonReqHyphen;

                int cchWideChar = MultiByteToWideChar( CodePageFromLid(m_currentLid),  // Mark Walker says - use US codepage.
                                                       0,              // No flags - this is supposed to be ANSI.
                                                       m_rgchANSIBuffer,
                                                       cbToRead,
                                                       (WCHAR *)pbBufferCur,
                                                       cbToRead);
                // No multibyte expansion.
                Assert ((ULONG)cchWideChar==cbToRead);

                // Set pbBufferCur to just before the special character run.
                if (cbToRead > cbSpecRead)
                    pbBufferCur += (cbToRead - cbSpecRead)*sizeof(WCHAR);
            }
            else // UNICODE - read directly into the buffer.
            {
                hr = Read (pbBufferCur, cbToRead, m_pStmMain);
                if (FAILED(hr))
                    goto LCheckNonReqHyphen;

                // Set pbBufferCur to just before the special character run.
                if (cbToRead > cbSpecRead)
                    pbBufferCur += cbToRead - cbSpecRead;
            }

            // Only count the non-special characters.
            *pcbRead = (ULONG)(pbBufferCur - (BYTE *)pv);
        }
        else  // lcFieldSep != 0, there are unmatched field begin characters
        {
            if (cbSpecRead > cbToRead)
                cbSpecRead = cbToRead;

            // Bytes to skip.
            ULONG cbSkip;
            if (fcSpecCur==0)
            {
                cbSkip = cbToRead;
                Assert (cbSpecRead==0);
            }
            else
            {
                cbSkip = fcSpecCur - fcCur;
                // Total # bytes we advance in stream.
                cbToRead = cbSkip + cbSpecRead;
            }

            // Seek past non-special chars and read the run of special chars.
            // ANSI?  Read the stuff into m_rgchANSIBuffer, and then expand.
            if (m_rgpcd[m_ipcd].fCompressed)
            {
                if (m_rgchANSIBuffer==NULL)
                    m_rgchANSIBuffer = (char *) PvAllocCb (cbSpecRead);
                else if (cbSpecRead>(ULONG)CbAllocatedPv(m_rgchANSIBuffer))
                    m_rgchANSIBuffer = (char *) PvReAllocPvCb (m_rgchANSIBuffer,cbSpecRead);

                hr = SeekAndRead (cbSkip, STREAM_SEEK_CUR,
                                  m_rgchANSIBuffer, cbSpecRead, m_pStmMain);
                if (FAILED(hr))
                    goto LCheckNonReqHyphen;

                int cchWideChar = MultiByteToWideChar( CodePageFromLid(m_currentLid),  // Mark Walker says - use US codepage.
                                                       0,              // No flags - this is supposed to be ANSI.
                                                       m_rgchANSIBuffer,
                                                       cbSpecRead,
                                                       (WCHAR *)pbBufferCur,
                                                       cbSpecRead);
                // No multibyte expansion.
                Assert ((ULONG)cchWideChar==cbSpecRead);
            }
            else  // UNICODE - read directly into the buffer.
            {
                hr = SeekAndRead (cbSkip, STREAM_SEEK_CUR,
                                  pbBufferCur, cbSpecRead, m_pStmMain);
                if (FAILED(hr))
                    goto LCheckNonReqHyphen;
            }
        }

        // Go through special characters.  Assume that they are unchanged
        // in UNICODE (eg ChSpec_FIELD_BEGIN==0x13 is converted into 0x0013).
        // Only do this for true special characters, not struck-out text.
        if (!m_fStruckOut)
        {
            for (BYTE *pbSpec = pbBufferCur,
                 *pbLim = pbBufferCur+(min(cbToRead,cbSpecRead)*sizeof(WCHAR)/cbChar);
                 pbSpec < pbLim;
                 pbSpec += sizeof(WCHAR))
            {
                #ifdef DEBUG
                    // The second byte of a converted special char should be 0.
                    if (! ((*(WCHAR UNALIGNED *)pbSpec & ~0x7F) == 0x0000 ||
                                    *(WCHAR UNALIGNED *)pbSpec==ChSpec_EMPTY_FORMFIELD))
                    {
                        char szMsg[64];
                        wsprintfA (szMsg, "Unknown special char: %#04X", *(WCHAR UNALIGNED *)pbSpec);
                        AssertSzA (fFalse,szMsg);
                    }
                #endif

                switch (*pbSpec)
                {
                    case ChSpec_FIELD_BEGIN:
                        lcFieldSep++;
                        lcFieldEnd++;
                        break;
                    case ChSpec_FIELD_SEP:
                        lcFieldSep--;
                        break;
                    case ChSpec_FIELD_END:
                        // we only care about field ends when they match a field begin
                        // that a field separator has not matched.
                        if (lcFieldEnd > 0)
                            lcFieldEnd--;
                        if (lcFieldEnd < lcFieldSep)
                            lcFieldSep = lcFieldEnd;
                        break;
                    default:
                        break;
                }
            }
        }

        // This is the *total* number of characters we've read or sought past.

        m_ccpRead += cbToRead / cbChar;
        fcCur += cbToRead;
        cbLeftInPiece -= cbToRead;

        if (cbLeftInPiece == 0)
        {
            // We've exhausted the text in the current pcd.
            if (++m_ipcd == m_cpcd) // EOF!
            {
                if (*pcbRead != 0)
                {
                    hr = FILTER_S_LAST_TEXT;
                    goto LCheckNonReqHyphen;
                }
                else
                {
                    hr = FILTER_E_NO_MORE_TEXT;
                    goto LCheckNonReqHyphen;
                }
            }

            cbChar = m_rgpcd[m_ipcd].CbChar();
            cbLeftInPiece = (m_rgcp[m_ipcd+1] - m_rgcp[m_ipcd]) * cbChar;
            fcCur = m_rgpcd[m_ipcd].GetFC();

            hr = FindNextSpecialCharacter (fTrue);
            if (FAILED(hr))
                goto LCheckNonReqHyphen;
        }
        else if (((FC *)m_fkp)[m_ifcfkp + 1] == fcCur)
        {       // the current file position is the end of a special character run
            hr = FindNextSpecialCharacter ();
            if (FAILED(hr))
                goto LCheckNonReqHyphen;
        }

        // Limited by PCD constraints and size of the buffer.
        cbToRead = min( (cb-*pcbRead)*m_rgpcd[m_ipcd].CbChar()/sizeof(WCHAR),
                        cbLeftInPiece);
    }

    if (*pcbRead == 0)
        hr = FILTER_E_NO_MORE_TEXT;

LCheckNonReqHyphen:

    #define xchNonReqHyphen         31

    // QFE 2255: add table cell delimiter checking

    #define xchTableCellDelimiter   7

    WCHAR *pwchSrc = (WCHAR *)pv;
    WCHAR *pwchDest = (WCHAR *)pv;
    WCHAR *pwchLim = pwchSrc + *pcbRead/sizeof(WCHAR);
    ULONG cPara = 0;

    for (; pwchSrc != pwchLim; pwchSrc++)
    {
        if (*(WCHAR UNALIGNED *)pwchSrc != xchNonReqHyphen)
        {
            if (*(WCHAR UNALIGNED *)pwchSrc == xchTableCellDelimiter)
                *(WCHAR UNALIGNED *)pwchSrc = 0x0009;

            if (pwchDest == pwchSrc)
                pwchDest++;
            else
                *(WCHAR UNALIGNED *)pwchDest++ = *(WCHAR UNALIGNED *)pwchSrc;
        }

        // count number of paragraph marks
        if (*(WCHAR UNALIGNED *)pwchSrc == 0x000d)
        {
            if ((pwchSrc+1) != pwchLim)
            {
                if (*(WCHAR UNALIGNED *)(pwchSrc+1) != 0x000a)
                cPara++;
            }
            else
                cPara++;
        }
    }

    *pcbRead = (ULONG)((pwchDest - (WCHAR *)pv) * sizeof(WCHAR));

    if (cPara)
    {
        WCHAR *pwchLimReverse = (WCHAR *)pv - 1;
        pwchLim = (WCHAR *)pv + *pcbRead/sizeof(WCHAR);
        pwchDest = (pwchLim-1) + cPara;

        for (pwchSrc = pwchLim-1; pwchSrc != pwchLimReverse; pwchSrc--)
        {
            if (*(WCHAR UNALIGNED *)pwchSrc == 0x000d)
            {
                if (pwchSrc != pwchLim-1)
                {
                    if (*(WCHAR UNALIGNED *)(pwchSrc+1) != 0x000a)
                    {
                        *(WCHAR UNALIGNED *)(pwchDest--) = 0x000a;
                        *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                    }
                    else
                        *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                }
                else
                {
                    *(WCHAR UNALIGNED *)(pwchDest--) = 0x000a;
                    *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                }
            }
            else
                *(WCHAR UNALIGNED *)(pwchDest--) = *(WCHAR UNALIGNED *)pwchSrc;
        }

        *pcbRead += (cPara * sizeof(WCHAR));
    }

    return hr;
} //ReadContent

HRESULT CWord8Stream::GetNextEmbedding(IStorage ** ppstg)
        {
        HRESULT hr;

        // release any previous embeddings
        if (m_pstgEmbed != NULL)
                {
                //m_pstgEmbed->Release();
                m_pstgEmbed = NULL;
                }
        else if (m_pstgOP == NULL)
                {
#ifdef OLE2ANSI
                hr = m_pStg->OpenStorage("ObjectPool",
#else // !defined OLE2ANSI
                hr = m_pStg->OpenStorage(L"ObjectPool",
#endif // OLE2ANSI
                                                                        NULL,   // pstgPriority
                                                                        STGM_SHARE_EXCLUSIVE,
                                                                        NULL,   // snbExclude
                                                                        0,              // reserved
                                                                        &m_pstgOP);

                if (FAILED(hr))
                        return hr;
                }

        Assert(m_pstgOP != NULL);
        
        if (m_pstgOP != NULL && m_pestatstg == NULL)
                {
                hr = m_pstgOP->EnumElements(0, NULL, 0, &m_pestatstg);
                if (FAILED(hr))
                        return hr;
                }

        Assert(m_pestatstg != NULL);
        Assert(m_pstgEmbed == NULL);

        STATSTG statstg;
        hr = m_pestatstg->Next(1, &statstg, NULL);
        if (FAILED(hr))
                return hr;
        if (hr == S_FALSE)
                return OLEOBJ_E_LAST;

        hr = m_pstgOP->OpenStorage(statstg.pwcsName,
                                                                NULL,   // pstgPriority
                                                                STGM_SHARE_EXCLUSIVE,
                                                                NULL,   // snbExclude
                                                                0,              // reserved
                                                                &m_pstgEmbed);

        LPMALLOC pMalloc;
        if (S_OK == CoGetMalloc(MEMCTX_TASK, &pMalloc))
                {
                pMalloc->Free(statstg.pwcsName);
                pMalloc->Release();
                }

        *ppstg = m_pstgEmbed;
        return hr;
        }


///////////////////////////////////////////////////////////////////////////////
// ReadFileInfo
//
// Read the piece table and the bin table.  In Word 96, full-saved files have
// a piece table, too.
//
HRESULT CWord8Stream::ReadFileInfo ()
        {
        // read default doc language id
        HRESULT hr = SeekAndRead (FIB_OFFSET_lid,
                STREAM_SEEK_SET,
                &m_lid, sizeof(WORD), m_pStmMain);
        if (FAILED(hr))
                return hr;

    m_ipcd = 0;

        // Skip over all the shorts in the FIB.
        WORD csw;
        hr = SeekAndRead (FIB_OFFSET_csw,
                STREAM_SEEK_SET,
                &csw, sizeof(WORD), m_pStmMain);
        if (FAILED(hr))
                return hr;
        csw = SwapWord(csw);

        // Skip over all the longs in the FIB.
        WORD clw;
        hr = SeekAndRead (
                FIB_OFFSET_csw+sizeof(WORD)+csw*sizeof(WORD),
                STREAM_SEEK_SET,
                &clw, sizeof(WORD), m_pStmMain);
        if (FAILED(hr))
                return hr;
        clw = SwapWord(clw);
        m_FIB_OFFSET_rgfclcb = FIB_OFFSET_csw+3*sizeof(WORD)+csw*sizeof(WORD)+clw*sizeof(DWORD);

        // Read offset of the complex part of the file from the beginning of
        // docfile xTable.
        hr = SeekAndRead (
                m_FIB_OFFSET_rgfclcb+RGFCLCB_OFFSET_fcClx,
                STREAM_SEEK_SET,
                &m_fcClx, sizeof(FC), m_pStmMain);
        if (FAILED(hr))
                return hr;
        m_fcClx = (FC)(SwapDWord((DWORD)m_fcClx));

        // Skip the grppls part of the complex part of the file.
        BYTE clxt;
        hr = SeekAndRead (m_fcClx, STREAM_SEEK_SET,
                &clxt, sizeof(BYTE), m_pStmTable);

        while (SUCCEEDED(hr) && clxt==clxtGrpprl)
                {
                Assert (m_fComplex);

                USHORT cb;
                hr = Read (&cb, sizeof(USHORT), m_pStmTable);
                cb = SwapWord(cb);
                if (FAILED(hr))
                        return hr;

                hr = Seek (cb, STREAM_SEEK_CUR, m_pStmTable);
                if (FAILED(hr))
                        return hr;

                hr = Read (&clxt, sizeof(BYTE), m_pStmTable);
                }

        Assert (clxt==clxtPlcfpcd);
        if (clxt!=clxtPlcfpcd)  // something went really wrong
                {
                if (SUCCEEDED(hr))
                        hr = ResultFromScode(E_UNEXPECTED);
                }
        if (FAILED(hr))
                return hr;

        // Read the piece table.
        ULONG cbPlcfpcd;
        hr = Read (&cbPlcfpcd, sizeof(ULONG), m_pStmTable);
        cbPlcfpcd = SwapDWord(cbPlcfpcd);
        if (FAILED(hr))
                return hr;

        m_cpcd = (cbPlcfpcd-sizeof(FC))/(sizeof(FC)+sizeof(PCD));
        m_rgcp = (FC *) PvAllocCb ((m_cpcd+1)*sizeof(FC));
        m_rgpcd = (PCD *) PvAllocCb (m_cpcd*sizeof(PCD));

        hr = Read (m_rgcp, sizeof(FC)*(m_cpcd+1), m_pStmTable);
        if (FAILED(hr))
                return hr;

#if defined MAC
        for (FC * pfc = m_rgcp; pfc <= m_rgcp + m_cpcd; pfc++)
                {
                *pfc = SwapDWord(*pfc);
                }
#endif // MAC || MBCS

        hr = Read(m_rgpcd, sizeof(PCD)*m_cpcd, m_pStmTable);
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (PCD * pcd = m_rgpcd; pcd < m_rgpcd + m_cpcd; pcd++)
                pcd->fc = SwapDWord(pcd->fc);
#endif // MAC

        if (m_fComplex)
                {
                m_pCache = new CacheGrpprl;
                if (m_pCache==NULL)
                        ThrowMemoryException ();
                }
        else
                m_pCache = NULL;

        hr = ReadBinTable();
        if (FAILED(hr))
                return hr;

        hr = Seek (m_rgpcd[m_ipcd].GetFC(), STREAM_SEEK_SET, m_pStmMain);

        return hr;
        }


HRESULT CWord8Stream::ReadBinTable ()
        {
        // Seek to and read the char property bin table offset
        FC fcPlcfbteChpx;
        HRESULT hr = SeekAndRead(
                m_FIB_OFFSET_rgfclcb+RGFCLCB_OFFSET_fcPlcfbteChpx,
                STREAM_SEEK_SET,
                &fcPlcfbteChpx, sizeof(FC), m_pStmMain);
        if (FAILED(hr))
                return hr;
        fcPlcfbteChpx = SwapDWord(fcPlcfbteChpx);

        // Read the size of the char property bin table
        long lcbPlcfbteChpx;
        hr = Read(&lcbPlcfbteChpx, sizeof(long), m_pStmMain);
        if (FAILED(hr))
                return hr;

        lcbPlcfbteChpx = SwapDWord(lcbPlcfbteChpx);

        m_cbte = (lcbPlcfbteChpx - sizeof(FC))/(sizeof(FC) + sizeof(BTE));

        // Read the paragraph property bin table offset
        FC fcPlcfbtePapx;
        hr = Read(&fcPlcfbtePapx, sizeof(FC), m_pStmMain);
        if (FAILED(hr))
                return hr;
        fcPlcfbtePapx = SwapDWord(fcPlcfbtePapx);

        // Read the size of the paragraph property bin table
        long lcbPlcfbtePapx;
        hr = Read(&lcbPlcfbtePapx, sizeof(long), m_pStmMain);
        if (FAILED(hr))
                return hr;

        lcbPlcfbtePapx = SwapDWord(lcbPlcfbtePapx);
    
    if (!m_fComplex)
                {
                // seek past the FC array from the bin table
                hr = Seek(fcPlcfbteChpx + sizeof(FC)*(m_cbte+1), STREAM_SEEK_SET, m_pStmTable);
                if (FAILED(hr))
                        return hr;
                }
        else
                {
                m_rgfcBinTable = (FC *) PvAllocCb ((m_cbte+1)*sizeof(FC));

                hr = SeekAndRead(fcPlcfbteChpx, STREAM_SEEK_SET,
                        m_rgfcBinTable, sizeof(FC)*(m_cbte+1), m_pStmTable);
                if (FAILED(hr))
                        return hr;

#ifdef MAC
                for (FC * pfc = m_rgfcBinTable; pfc <= m_rgfcBinTable + m_cbte; pfc++)
                        *pfc = SwapDWord(*pfc);
#endif // MAC
                }

        // Read in the BTE array from the bin table.
        m_rgbte = (BTE *) PvAllocCb (m_cbte*sizeof(BTE));

        hr = Read(m_rgbte, sizeof(BTE)*m_cbte, m_pStmTable);
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (BTE *pbte = m_rgbte; pbte < m_rgbte + m_cbte; pbte++)
                *pbte = SwapWord(*pbte);
#endif // MAC

// same for paragraph BIN table

        m_cbtePap = (lcbPlcfbtePapx - sizeof(FC))/(sizeof(FC) + sizeof(BTE));

    if (!m_fComplex)
                {
                // seek past the FC array from the bin table
                hr = Seek(fcPlcfbtePapx + sizeof(FC)*(m_cbtePap+1), STREAM_SEEK_SET, m_pStmTable);
                if (FAILED(hr))
                        return hr;
                }
        else
                {
                m_rgfcBinTablePap = (FC *) PvAllocCb ((m_cbtePap+1)*sizeof(FC));

                hr = SeekAndRead(fcPlcfbtePapx, STREAM_SEEK_SET,
                        m_rgfcBinTablePap, sizeof(FC)*(m_cbtePap+1), m_pStmTable);
                if (FAILED(hr))
                        return hr;

#ifdef MAC
                for (FC * pfc = m_rgfcBinTablePap; pfc <= m_rgfcBinTablePap + m_cbtePap; pfc++)
                        *pfc = SwapDWord(*pfc);
#endif // MAC
                }

        // Read in the BTE array from the bin table.
        m_rgbtePap = (BTE *) PvAllocCb (m_cbtePap*sizeof(BTE));

        hr = Read(m_rgbtePap, sizeof(BTE)*m_cbtePap, m_pStmTable);
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (BTE *pbte = m_rgbtePap; pbte < m_rgbtePap + m_cbtePap; pbte++)
                *pbte = SwapWord(*pbte);
#endif // MAC

        // read in style sheet (STSH)

    // offset of STSH in table stream
    FC fcStshf;
        hr = SeekAndRead(
                m_FIB_OFFSET_rgfclcb + FIB_OFFSET_fcStshf, 
                STREAM_SEEK_SET,
                &fcStshf, sizeof(FC), m_pStmMain);
        if (FAILED(hr))
                return hr;
        fcStshf = SwapDWord(fcStshf);

    // size of STSH
    unsigned long lcbStshf;
        hr = SeekAndRead(
                m_FIB_OFFSET_rgfclcb + FIB_OFFSET_lcbStshf, 
                STREAM_SEEK_SET,
                &lcbStshf, sizeof(unsigned long), m_pStmMain);
        if (FAILED(hr))
                return hr;
        lcbStshf = SwapDWord(lcbStshf);

    if(lcbStshf)
    {
        // allocate STSH
            m_pSTSH = (BYTE*)PvAllocCb (lcbStshf);
        if(!m_pSTSH)
            return E_OUTOFMEMORY;
                m_lcbStshf = lcbStshf;

        // seek and read STSH from table stream
            hr = SeekAndRead(fcStshf, STREAM_SEEK_SET, m_pSTSH, lcbStshf, m_pStmTable);
            if (FAILED(hr))
                    return hr;
    }
 
    hr = CreateLidsTable();
    if(hr)
        return hr;

    hr = FindNextSpecialCharacter (fTrue);

        return hr;
        }


HRESULT CWord8Stream::FindNextSpecialCharacter (BOOL fFirstChar)
        {
        // NOTE: This function only works for complex files when the pcd changes
        // if fFirstChar is TRUE
        // CONSIDER: This could also be more efficient if revision text were marked
        // so that it doesn't get parsed along with the rest of the special text.
        HRESULT hr = S_OK;
        BYTE crun;                      // count of runs in the current

        FC fcCurrent = m_rgpcd[m_ipcd].GetFC() + (m_ccpRead - m_rgcp[m_ipcd]) *
                (m_rgpcd[m_ipcd].fCompressed ? sizeof(char) : sizeof(WCHAR));

        if (fFirstChar)
                {       // reset all of the appropriate variables
                m_ifcfkp = 0;
                m_ibte = -1;    // this gets incremented before it is used.
                crun = 0;
                m_fsstate = FSPEC_EITHER;
                if (m_fComplex)
                        {
                        // parse the grpprls
                        hr = ParseGrpPrls();
                        if (m_fsstate != FSPEC_EITHER || FAILED(hr))
                                {       // there's no point in parsing the fkps
                                m_ibte = 0;
                                // Seek back to the current text
                                if (SUCCEEDED(hr))
                                        hr = Seek(fcCurrent, STREAM_SEEK_SET, m_pStmMain);
                                return hr;
                                }
                        // find the right FKP.
                        for (m_ibte=0;  m_ibte<m_cbte;  m_ibte++)
                                if (fcCurrent>=m_rgfcBinTable[m_ibte] &&
                                        fcCurrent<m_rgfcBinTable[m_ibte+1])
                                        break;
                        if (m_ibte==m_cbte)
                                return FILTER_E_NO_MORE_TEXT;
                        m_ibte --;      // gets incremented before it is used.
                        }
                }
        else
                {
                crun = m_fkp[FKP_PAGE_SIZE - 1];
                m_ifcfkp++;
                if (m_fsstate != FSPEC_EITHER)  // no point in parsing the fkps
                        return hr;
                }

        while (m_ibte < m_cbte)
                {
                if (m_ifcfkp == crun)
                        {
                        m_ibte++;
                        if (m_ibte == m_cbte)
                                break;

                        // seek to and read current FKP
                        hr = SeekAndRead(m_rgbte[m_ibte]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                                m_fkp, FKP_PAGE_SIZE, m_pStmMain);
                        if (FAILED(hr))
                                return hr;

                        // Seek back to the current text
                        hr = Seek(fcCurrent, STREAM_SEEK_SET, m_pStmMain);
                        if (FAILED(hr))
                                return hr;

                        m_ifcfkp = 0;
                        crun = m_fkp[FKP_PAGE_SIZE-1];

#ifdef MAC
                        FC * pfc = (FC *)m_fkp;
                        for (BYTE irun = 0; irun < crun; irun++)
                                {
                                *pfc = SwapDWord(*pfc);
                                pfc++;
                                }
#endif // MAC
                        }

                FC * rgfcfkp = (FC *)m_fkp;
                for (;  m_ifcfkp<crun;  m_ifcfkp++)
                        {
                        if (rgfcfkp[m_ifcfkp + 1] <= fcCurrent)
                                continue;

                        BYTE bchpxOffset = *(m_fkp + (crun+1)*sizeof(FC) + m_ifcfkp);
                        if (bchpxOffset == 0)
                                continue;       // there is nothing in the CHPX.

                        BYTE *chpx = m_fkp + bchpxOffset*sizeof(WORD);
                        BYTE cbchpx = chpx[0];

                        for (unsigned i=1;  i<cbchpx;  )
                                {
                                WORD sprm = *(WORD UNALIGNED *)(chpx+i);

                                // Anything else we don't need?
                                if (sprm==sprmCFSpec && chpx[i+sizeof(sprm)]==fTrue ||
                                        sprm==sprmCFStrikeRM && (chpx[i+sizeof(sprm)] & 1))
                                        {
                                        m_fStruckOut = (sprm == sprmCFStrikeRM);
                                        return hr;
                                        }

                                WORD spra = (WORD) ((sprm>>13) & 0x0007);
                                i += sizeof(sprm) +
                                        (spra==0 || spra==1 ? 1 :
                                         spra==2 || spra==4 || spra==5 ? 2 :
                                         spra==3 ? 4 :
                                         spra==7 ? 3 :
                                         /*spra==6*/ 1 + *(BYTE *)(chpx+i+sizeof(sprm)) );
                                }
                        }
                }

        // We're at the end of the bin table -- no more special characters.
        m_fsstate = FSPEC_NONE;

        return hr;
        }


// This function changes the current pointer and does not put it back.  It
// cannot be called directly from ReadText().  It needs to be called by a
// function that will replace the pointer.
HRESULT CWord8Stream::ParseGrpPrls ()
        {
        HRESULT hr = S_OK;
        PCD pcdCur = m_rgpcd[m_ipcd];

        if (!pcdCur.prm1.fComplex)
                {       // self-contained sprm -- no need to parse grpprl.
                if (pcdCur.prm1.isprm==isprmCFSpec ||
                        pcdCur.prm1.isprm==isprmCFStrikeRM)
                        {
                        m_fStruckOut = (pcdCur.prm1.isprm==isprmCFStrikeRM);
                        if (!(pcdCur.prm1.val & 1))
                                m_fsstate = FSPEC_NONE;
                        else
                                m_fsstate = FSPEC_ALL;
                        }
                }
        else
                {
                BYTE *grpprl;
                USHORT cb;
                grpprl = GrpprlCacheGet (pcdCur.prm2.igrpprl, &cb);

                // Not found in cache - read it manually.
                if (grpprl==NULL)
                        {
                        // seek to the fc where the complex part of the file starts
                        hr = Seek (m_fcClx, STREAM_SEEK_SET, m_pStmTable);
                        if (FAILED(hr))
                                return hr;

                        // seek to the right grpprl
                        for (short igrpprlTemp = 0;  igrpprlTemp <= pcdCur.prm2.igrpprl;  igrpprlTemp++)
                                {
                                BYTE clxt;
                                hr = Read (&clxt, sizeof(BYTE), m_pStmTable);
                                if (FAILED(hr))
                                        return hr;

                                if (clxt!=clxtGrpprl)
                                        {       // this is actually bad, but recoverable.
                                        m_fsstate = FSPEC_EITHER;
                                        return hr;
                                        }

                                hr = Read (&cb, sizeof(USHORT), m_pStmTable);
                                if (FAILED(hr))
                                        return hr;
                                cb = SwapWord(cb);

                                if (igrpprlTemp < pcdCur.prm2.igrpprl)
                                        {
                                        hr = Seek (cb, STREAM_SEEK_CUR, m_pStmTable);
                                        if (FAILED(hr))
                                                return hr;
                                        }
                                }

                        // Put it into the cache.
                        grpprl = GrpprlCacheAllocNew (cb, pcdCur.prm2.igrpprl);
                        hr = Read (grpprl, cb, m_pStmTable);
                        if (FAILED(hr))
                                return hr;
                        }

                for (unsigned i=0;  i<cb;  )
                        {
                        WORD sprm = *(WORD UNALIGNED *)(grpprl+i);

                        // Anything else we don't need?
                        if (sprm==sprmCFSpec || sprm==sprmCFStrikeRM)
                                {
                                m_fStruckOut = (sprm==sprmCFStrikeRM);
                                if (!(grpprl[i+sizeof(sprm)] & 1))
                                        m_fsstate = FSPEC_NONE;
                                else
                                        m_fsstate = FSPEC_ALL;
                                return hr;
                                }

                        WORD spra = (WORD) ((sprm>>13) & 0x0007);
                        i += sizeof(sprm) +
                                (spra==0 || spra==1 ? 1 :
                                 spra==2 || spra==4 || spra==5 ? 2 :
                                 spra==3 ? 4 :
                                 spra==7 ? 3 :
                                 /*spra==6*/ 1 + *(BYTE *)(grpprl+i+sizeof(sprm)) );
                        }
                }

        m_fsstate = FSPEC_EITHER;
        return hr;
        }


////////////////////////////////////////////////////////////////////////////////
// Return a pointer to the grpprl with this index and its size.
// Return NULL if there is none.
//
BYTE *CWord8Stream::GrpprlCacheGet (short igrpprl, USHORT *pcb)
        {
        NoThrow();
        for (int i=0;  i<m_pCache->cItems;  i++)
                if (igrpprl==m_pCache->rgIdItem[i])
                        {
                        m_pCache->rglLastAccTmItem[i] = m_pCache->lLastAccTmCache;
                        m_pCache->lLastAccTmCache ++;
                        *pcb = (USHORT) (m_pCache->ibFirst[i+1] - m_pCache->ibFirst[i]);
                        return m_pCache->rgb+m_pCache->ibFirst[i];
                        }
        if (m_pCache->pbExcLarge && igrpprl==m_pCache->idExcLarge)
                {
                *pcb = (USHORT)m_pCache->cbExcLarge;
                return m_pCache->pbExcLarge;
                }
        return NULL;
        }


////////////////////////////////////////////////////////////////////////////////
// Allocate a new grpprl in the cache.  If there is not enough space,
// remove least recently used items until there is enough.
//
BYTE *CWord8Stream::GrpprlCacheAllocNew (int cb, short igrpprl)
        {
        AssertCanThrow();
        // Doesn't fit into the cache - use the exceptionally large pointer.
        if (cb > CacheGrpprl::CACHE_SIZE)
                {
                FreePv (m_pCache->pbExcLarge);
                m_pCache->pbExcLarge = (BYTE *) PvAllocCb (cb);
                m_pCache->cbExcLarge = cb;
                m_pCache->idExcLarge = igrpprl;
                return m_pCache->pbExcLarge;
                }

        // While there is not enough space.
        while (cb > CacheGrpprl::CACHE_SIZE-m_pCache->ibFirst[m_pCache->cItems] ||
                m_pCache->cItems >= CacheGrpprl::CACHE_MAX)
                {
                // Find the least recently accessed items.
                int imin = 0;
                for (int i=1;  i<m_pCache->cItems;  i++)
                        if (m_pCache->rglLastAccTmItem[i]<m_pCache->rglLastAccTmItem[imin])
                                imin = i;

                // Remove it.
                memmove (m_pCache->rgb+m_pCache->ibFirst[imin],
                        m_pCache->rgb+m_pCache->ibFirst[imin+1],
                        m_pCache->ibFirst[m_pCache->cItems]-m_pCache->ibFirst[imin+1]);
                int cbRemoved = m_pCache->ibFirst[imin+1] - m_pCache->ibFirst[imin];
                for (i=imin;  i<m_pCache->cItems;  i++)
                        m_pCache->ibFirst[i] = m_pCache->ibFirst[i+1]-cbRemoved;
                memmove (m_pCache->rgIdItem+imin, m_pCache->rgIdItem+imin+1,
                        (m_pCache->cItems-imin-1)*sizeof(*m_pCache->rgIdItem));
                memmove (m_pCache->rglLastAccTmItem+imin,
                        m_pCache->rglLastAccTmItem+imin+1,
                        (m_pCache->cItems-imin-1)*sizeof(*m_pCache->rglLastAccTmItem));
                m_pCache->cItems --;
                }

        // Allocate space for a new item.
        m_pCache->ibFirst[m_pCache->cItems+1] =
                m_pCache->ibFirst[m_pCache->cItems] + cb;
        m_pCache->rgIdItem[m_pCache->cItems] = igrpprl;
        m_pCache->rglLastAccTmItem[m_pCache->cItems] = m_pCache->lLastAccTmCache;
        m_pCache->cItems ++;
        return m_pCache->rgb + m_pCache->ibFirst[m_pCache->cItems-1];
        }


// This function should only be used when it is considered an error to not
// read everything we intended to read
HRESULT CWord8Stream::Read (VOID* pv, ULONG cbToRead, IStream *pStm)
        {
        NoThrow();
        HRESULT hr = S_OK;
        ULONG cbRead;

        hr = pStm->Read(pv, cbToRead, &cbRead);
        if ((cbRead != cbToRead) && SUCCEEDED(hr))
                hr = ResultFromScode(E_UNEXPECTED);

        return hr;
        }

HRESULT CWord8Stream::Seek (ULONG cbSeek, STREAM_SEEK origin, IStream *pStm)
        {
        NoThrow();
        LARGE_INTEGER li;

        li.HighPart = 0;
        li.LowPart = cbSeek;
        return pStm->Seek(li, origin, 0);
        }

// This function should only be used when it is considered an error to not
// read everything we intended to read
HRESULT CWord8Stream::SeekAndRead (ULONG cbSeek, STREAM_SEEK origin,
                                                                   VOID* pv, ULONG cbToRead, IStream *pStm)
        {
        HRESULT hr = S_OK;

        hr = Seek(cbSeek, origin, pStm);
        if (FAILED(hr))
                return hr;

        hr = Read(pv, cbToRead, pStm);
        return hr;
        }

template<class T> class XParanoidPtr
{
public:
    XParanoidPtr( unsigned c = 0 ) : _p(0)
    {
        if ( 0 != c )
            SetSize( c );
    }

    XParanoidPtr( T * p ) : _p( p ) {}

    ~XParanoidPtr() { Free(); }

    void SetSize( unsigned c )
    {
        Free();

        SYSTEM_INFO si;
        GetSystemInfo( &si );
        const ULONG cbPage = si.dwPageSize;

        ULONG cbAlloc = c * sizeof T;
        ULONG cPages = ( cbAlloc / cbPage ) + 1;
        ULONG cbRemainder = ( cbAlloc % cbPage );

        if ( 0 != cbRemainder )
            cPages++;

        ULONG cbTotalAlloc = cPages * cbPage;

        void * pv = VirtualAlloc( 0, cbTotalAlloc, MEM_RESERVE, PAGE_READONLY );
        if ( 0 == pv )
            return;

        pv = VirtualAlloc( pv, cbTotalAlloc - cbPage, MEM_COMMIT, PAGE_READWRITE );
        if ( 0 == pv )
            return;

        if ( 0 != cbRemainder )
            _p = (T *) ( (BYTE *) pv + cbPage - cbRemainder );
        else
            _p = (T *) pv;
    }

    void Set ( T * p ) { _p = p; }

    T * Get() const { return _p ; }

    void Free()
    {
        T * pt = Acquire();

        if ( 0 != pt )
            VirtualFree( pt, 0, MEM_RELEASE );
    }

    T & operator[]( unsigned i ) { return _p[i]; }
    T const & operator[]( unsigned i ) const { return _p[i]; }
    T * Acquire() { T * p = _p; _p = 0; return p; }
    BOOL IsNull() const { return ( 0 == _p ); }

private:
    T * _p;
};

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::GetChunk(STAT_CHUNK * pStat)
{
    LCID lid;
    ULONG cbToRead = 0;
    HRESULT hr;
 
    if (m_ipcd==m_cpcd)  // At the end of the piece table?
                 return FILTER_E_NO_MORE_TEXT;
 
    FC fcCurrent = m_rgpcd[m_ipcd].GetFC() + (m_ccpRead - m_rgcp[m_ipcd]) *
     (m_rgpcd[m_ipcd].fCompressed ? sizeof(char) : sizeof(WCHAR));
 
    if(!m_ccpRead && !m_currentLid)
    {
        // first chunk, just get LCID and quit
        hr = CheckLangID(fcCurrent, &cbToRead, &lid);
            if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
                     return hr;
 
        m_currentLid = lid;
         pStat->locale = m_currentLid;
         //pStat->locale = (m_bFEDoc) ? m_FELid : m_currentLid;
 
        return S_OK;
    }
    else
    {
        if (m_bFEDoc)
            pStat->breakType = CHUNK_NO_BREAK;

        hr = CheckLangID( fcCurrent, &cbToRead, &lid, FALSE );

        if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
            return hr;

        if (lid == m_currentLid)
        {
            // there was no call to GetText() between GetChunk(), 
            // so we need to seek text stream manualy to the next language run
            // Add some fudge here since ReadContent may have off by one bugs
 
            XParanoidPtr<char> xBuf( 1024 );
 
            if ( 0 == xBuf.Get() )
                return HRESULT_FROM_WIN32( GetLastError() );
 
            HRESULT res;
 
            do
            {
                ULONG cb;
                res = ReadContent( xBuf.Get(), 512, &cb );
            } while(res == S_OK);
 
            if (res == FILTER_E_NO_MORE_TEXT)
            {
                fcCurrent = m_rgpcd[m_ipcd].GetFC() + (m_ccpRead - m_rgcp[m_ipcd]) *
                     (m_rgpcd[m_ipcd].fCompressed ? sizeof(char) : sizeof(WCHAR));               
                
                hr = CheckLangID(fcCurrent, &cbToRead, &lid);
                    if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
                             return hr;
                
                pStat->locale = m_currentLid;
 
                return S_OK;
            }
            else
                return res;
        }
        else
        {
            m_currentLid = lid;
            pStat->locale = m_currentLid;
 
        }
    }

    return S_OK;
} //GetChunk

/////////////////////////////////////////////////////////////////////////////////////

LCID CWord8Stream::GetDocLanguage(void)
{
    if(m_lid < 999)
        return m_lid;
    else
        return MAKELCID(m_lid, SORT_DEFAULT);
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::CreateLidsTable(void)
   {
   HRESULT hr = S_OK;

   FC fcCurrent = m_rgpcd[m_ipcd].GetFC() + (m_ccpRead - m_rgcp[m_ipcd]) *
   (m_rgpcd[m_ipcd].fCompressed ? sizeof(char) : sizeof(WCHAR));

   // init lid table
   m_currentLid = 0;
   m_nLangRunSize = 0;
   if (FBidiLid(m_lid))
      m_pLangRuns = new CLidRun8(0, 0x7fffffff, m_lid, m_lid, 0, NULL, NULL, m_lid, 0);
   else
      m_pLangRuns = new CLidRun8(0, 0x7fffffff, m_lid, m_lid, 0, NULL, NULL, 0, 0);
   if(!m_pLangRuns)
      return E_OUTOFMEMORY;

   hr = ProcessParagraphBinTable();
   if (FAILED(hr))
      return hr;

   m_pLangRuns->Reduce(this);

   hr = ProcessCharacterBinTable();
   if (FAILED(hr))
      return hr;

   //hr = ProcessPieceTable();
   if (FAILED(hr))
      return hr;

   m_pLangRuns->Reduce(this);

   m_pLangRuns->TransformBi();
   m_pLangRuns->Reduce(this, TRUE /*fIgnoreBi*/);

   ScanLidsForFE();

   // Seek back to the current text
   hr = Seek(fcCurrent, STREAM_SEEK_SET, m_pStmMain);
   return hr;
   }

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::CheckLangID(FC fcCur, ULONG * pcbToRead, LCID * plid, BOOL fUpdate)
{
    if (!m_pLangRuns)
            return E_FAIL;

    LCID lid = GetDocLanguage();
    FC fcLangRunEnd = 0xffffffff;

    CLidRun8 * pRun = m_pLangRuns;
    do
    {
        if(fcCur >= pRun->m_fcStart && fcCur < pRun->m_fcEnd)
        {
            if(pRun->m_bUseFE)
                lid = MAKELCID(pRun->m_lidFE, SORT_DEFAULT);
            else
                lid = MAKELCID(pRun->m_lid, SORT_DEFAULT);

            fcLangRunEnd = pRun->m_fcEnd;
            break;
        }
        else
        {
            if(pRun->m_pNext)
                pRun = pRun->m_pNext;
            else
            {
                return E_FAIL;
            }
        }
    } while(pRun->m_pNext);

    *plid = lid;

    *pcbToRead = min(*pcbToRead, fcLangRunEnd - fcCur);

    if (lid != m_currentLid)
        return FILTER_E_NO_MORE_TEXT;

    if ( fUpdate )
        m_currentLid = lid;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::GetLidFromSyle(short istd, WORD * pLID, WORD * pLIDFE, WORD * pbUseFE,
                                                                         WORD * pLIDBi, WORD * pbUseBi, BOOL fParaBidi)
{
    WORD cbStshi = *((WORD UNALIGNED *)m_pSTSH);
    m_pSTSHI = (STSHI*)(m_pSTSH + 2);
        BYTE * pLim = m_pSTSH + m_lcbStshf;
        WORD cbSTD = m_pSTSHI->csSTDBaseInFile;
    
    if(istd >= m_pSTSHI->cstd)
    {
        // something wrong, just return default doc lid
LWrong:
        *pLID = m_lid;
        *pLIDFE = m_lid;
        *pbUseFE = 0;
        return S_OK;
    }

    // go to the istd
    short stdInd = 0;
    WORD * pcbStd = ((WORD*)(m_pSTSH + sizeof(WORD) + cbStshi));

    while(stdInd++ < istd)
    {
        pcbStd = ((WORD*)((BYTE*)pcbStd + sizeof(WORD) + *pcbStd));
    }
    
    STD * pStd = (STD*)(pcbStd + 1);

    // go to UPX and check if it has lid
        // NOTE (1/5/2001):  the STD structure defined in dmiwd8st.hpp is no longer correct!!!
        // Word has changed the size, so any references to pStd->xstzName actually point to the
        // middle of the real structure.  Lucky for us, they have a cb in the STSHI that is correct
        // for both the Word2000 and Word10 cases.  So now we use that to get to the string, then
        // we use the length of the string to get past that and right to the UPX's.
        WCHAR * xstzName = (WCHAR *)((BYTE *)pStd + cbSTD); // Find the name based on the cbSTD
    BYTE * pUPX = (BYTE *)xstzName +                    // start of style name
        sizeof(WCHAR) * (2 + xstzName[0]) +             // style name lenght
        (sizeof(WCHAR) * xstzName[0])%2;                // should be on even-byte boundary 

    WORD LidPara = 0, LidParaFE = 0, LidChar = 0, LidCharFE = 0, bParaUseFE = 0, bCharUseFE = 0;
        WORD LidParaBi = 0, LidCharBi = 0, bParaUseBi = 0, bCharUseBi = 0;
    WORD cbpapx, cbchpx;
    BYTE * papx,  * pchpx; 

    if(pStd->sgc == stkPara)
    {
        // paragraph style
        cbpapx = *((WORD UNALIGNED *)pUPX);
        papx = pUPX + 2;

                if (papx + cbpapx > pLim)
                        goto LWrong;
        
                if(cbpapx >= 2)
                {
                        ScanGrpprl(cbpapx - 2, papx + 2, &LidPara, &LidParaFE, &bParaUseFE, 
                                &LidParaBi, &bParaUseBi, &fParaBidi); // - + 2 for istd in papx
                }
        
        cbchpx = *(papx + cbpapx + cbpapx%2);
        pchpx = papx + cbpapx + cbpapx%2 + 2;
                if (pchpx + cbchpx > pLim)
                        goto LWrong;
        if(cbchpx > 0)
                                ScanGrpprl(cbchpx, pchpx, &LidChar, &LidCharFE, &bCharUseFE,
                                &LidCharBi, &bCharUseBi, &fParaBidi);

    }
    else if(pStd->sgc == stkChar)
    {
        // character style
        cbchpx = *((WORD*)pUPX);
        pchpx = pUPX + 2;
                if (pchpx + cbchpx > pLim)
                        goto LWrong;
        if(cbchpx > 0)
                                ScanGrpprl(cbchpx, pchpx, &LidChar, &LidCharFE, &bCharUseFE, &LidCharBi, &bCharUseBi);
    }

        // We want to save the values we got through the recursion, so assign em if you got em!
        // NOTE: LidPara, LidParaFE and bParaUseFE will always be NULL, so don't bother checking
        //       them here...if they ever are non-zero, we've got a corrupt document and will
        //       end up shooting ourselves in the foot, and if they ever are used, we wouldn't
        //       get them from ScanGrpprl anyway.
        if (LidChar && !*pLID)
                *pLID = LidChar;

        if (LidCharFE && !*pLIDFE)
                *pLIDFE = LidCharFE;

        if (bCharUseFE && !*pbUseFE)
                *pbUseFE = bCharUseFE;

        if (LidCharBi && !*pLIDBi)
                *pLIDBi = LidCharBi;
        if (LidParaBi && !*pLIDBi)
                *pLIDBi = LidParaBi;

        if (bCharUseBi && !*pbUseBi)
                *pbUseBi = bCharUseBi;
        if (bParaUseBi && !*pbUseBi)
                *pbUseBi = bParaUseBi;
                
    if(*pLID && *pLIDFE && *pLIDBi) // we've got everything we're looking for...we're done!
        return S_OK;
    else if(pStd->istdBase != istdNil)
        GetLidFromSyle(pStd->istdBase, pLID, pLIDFE, pbUseFE, pLIDBi, pbUseBi, fParaBidi);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////

#define sprmCFBidi      (0x85a)
#define sprmPFBidi      (0x2441)
#define sprmCLidBi      (0x485f)
#define idctBi                  2               // Characters should use lid and ftc, both calculated for Bidi
#define idctFE                  1               // Characters should use lidFE and ftcFE
#define idctDefault             0               // Characters should use lidDefault and non-FE font

#define WLangBase(lid)  ((lid)&0x3ff)   // lower 10 bits == base language
#define lidArabic       (0x0401)
#define lidHebrew       (0x040d)
// is this Bidi language?
BOOL FBidiLid(WORD lid)
{
        return (WLangBase(lid) == WLangBase(lidArabic)  ||
                        WLangBase(lid) == WLangBase(lidHebrew)  );
}

void CWord8Stream::ScanGrpprl(WORD cbgrpprl, BYTE * pgrpprl, WORD * plid, WORD * plidFE, WORD * bUseFE,
                                                          WORD * plidBi, WORD * bUseBi, BOOL *pfParaBidi)
{
        WORD lidSprm0 = 0;
        WORD lidSprm1 = 0;
        BYTE bUselidSprm1 = 0;
        BOOL fBidiChar = fFalse, fBidiPara = fFalse;
        WORD lidBi = 0;


        for (unsigned i=0;  i<cbgrpprl;  )
        {
                WORD sprm = *(WORD UNALIGNED *)(pgrpprl+i);

                if (sprm == sprmCFBidi)
                {
                        BYTE value = *(BYTE UNALIGNED *)(pgrpprl+i+2);
                        if ((value&1) == 1)
                                fBidiChar = fTrue;
                }

                if (sprm == sprmPFBidi)
                {
                        BYTE value = *(BYTE UNALIGNED *)(pgrpprl+i+2);
                        if (value == 1)
                        {
                                fBidiPara = fTrue;
                                if (pfParaBidi)
                                        *pfParaBidi = TRUE;
                        }
                }

                if (sprm == sprmCLid || sprm == sprmCRgLid0 )
                {
                        lidSprm0 = *(WORD UNALIGNED *)(pgrpprl+i+2);
                }
                else if (sprm == sprmCRgLid1)
                {
                        lidSprm1 = *(WORD UNALIGNED *)(pgrpprl+i+2);
                }
                else if(sprm == sprmCIdctHint)
                {
                        bUselidSprm1 = *(BYTE UNALIGNED *)(pgrpprl+i+2);
                }
                else if (sprm == sprmCLidBi)
                {
                        lidBi = *(WORD UNALIGNED *)(pgrpprl+i+2);
                }

                WORD spra = (WORD) ((sprm>>13) & 0x0007);
                i += sizeof(sprm) +
                        (spra==0 || spra==1 ? 1 :
                        spra==2 || spra==4 || spra==5 ? 2 :
                        spra==3 ? 4 :
                        spra==7 ? 3 :
                        /*spra==6*/ 1 + *(BYTE UNALIGNED *)(pgrpprl+i+sizeof(sprm)) );
        }

        if (fBidiChar)
        {
                if (FBidiLid(lidBi))
                        *plid = lidBi;
                else if (FBidiLid (lidSprm0))
                        *plid = lidSprm0;
                else 
                        *plid = 0;

                if (*plid) // *plid is of Bidi
                {
                        *plidFE = 0;
                        *bUseFE = 0;
                        *plidBi = 0;
                        *bUseBi = 0;
                        return;
                }

                *bUseBi = TRUE;
        }

        if (fBidiPara || (pfParaBidi && *pfParaBidi))
        {
                if (FBidiLid(lidBi))
                        *plidBi = lidBi;
        }

        if (bUselidSprm1 == idctBi)
                bUselidSprm1 = idctDefault;
        *plid = lidSprm0;
        *plidFE = lidSprm1;
        *bUseFE = bUselidSprm1;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::ProcessParagraphBinTable(void)
{
    // reset all of the appropriate variables
    
    HRESULT hr = S_OK;
    short ifcfkpPap = 0;
    long ibtePap = -1;  // this gets incremented before it is used.
    short crunPap = 0;

    while (ibtePap < m_cbtePap)
    {
        if (ifcfkpPap == crunPap) // go to next FKP in bin table
        {
            ibtePap++;
            if (ibtePap == m_cbtePap)
            {
                // end of the paragraph bin table
                break;
            }

            // seek to and read current FKP
            hr = SeekAndRead(m_rgbtePap[ibtePap]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                    m_fkpPap, FKP_PAGE_SIZE, m_pStmMain);
            if (FAILED(hr))
                    return hr;

            ifcfkpPap = 0;
            crunPap = m_fkpPap[FKP_PAGE_SIZE-1];
        }

        FC * rgfcfkpPap = (FC *)m_fkpPap;
        for (;  ifcfkpPap<crunPap;  ifcfkpPap++)
        {
            BYTE bpapxOffset = *(m_fkpPap + (crunPap+1)*sizeof(FC) + (ifcfkpPap * BX_SIZE));
            if (bpapxOffset == 0)
                    continue;       // there is nothing in the PAPX.

            BYTE *papx = m_fkpPap + bpapxOffset*sizeof(WORD);
            // we are inside FKP so first byte contain count of words
            BYTE cwpapx = papx[0];
            BYTE istd; // index to style descriptor
            unsigned int sprmInd;
    
            if(!cwpapx)
            {
                // this is zero, in this case the next byte contains count of words
                cwpapx = papx[1];
                istd = papx[2]; //possible bug ( short?)
                sprmInd = 3;
            }
            else
            {
                cwpapx--;
                istd = papx[1]; //possible bug ( short?)
                sprmInd = 2;
            }
    
            WORD lidSprm = 0, lidSprmFE = 0, bUseSprmFE = 0;
            WORD lidSprmBi = 0, bUseSprmBi = 0;
            BOOL fParaBidi = FALSE;
            WORD lidStyle = 0, lidStyleFE = 0, bUseStyleFE = 0;
            WORD lidStyleBi = 0, bUseStyleBi = 0;
    
            FC  fcStart, fcEnd;

            if ( ifcfkpPap >= FKP_PAGE_SIZE )
            {
                return FILTER_E_UNKNOWNFORMAT;
            }

            fcStart = rgfcfkpPap[ifcfkpPap];
            fcEnd = rgfcfkpPap[ifcfkpPap + 1];
                        
            // check for possible lid in sprm
            ScanGrpprl(cwpapx * 2, papx + sprmInd, &lidSprm, &lidSprmFE, &bUseSprmFE,
                                &lidSprmBi, &bUseSprmBi, &fParaBidi);
            
            // check for possible lid in the syle descriptor
            GetLidFromSyle(istd, &lidStyle, &lidStyleFE, &bUseStyleFE,
                                &lidStyleBi, &bUseStyleBi, fParaBidi);
    
            if(!lidSprm)
                lidSprm = lidStyle;
            if(!lidSprmFE)
                lidSprmFE = lidStyleFE;
            if(!bUseSprmFE)
                bUseSprmFE = bUseStyleFE;
            if(!lidSprmBi)
                lidSprmBi = lidStyleBi;
            if(!bUseSprmBi)
                bUseSprmBi = bUseStyleBi;
    
            if(lidSprm || lidSprmFE || bUseSprmFE || lidSprmBi || bUseSprmBi)
            {
                hr = m_pLangRuns->Add(lidSprm, lidSprmFE, bUseSprmFE, fcStart, fcEnd, lidSprmBi, bUseSprmBi);
                if (FAILED(hr))
                    return hr;
            }
        }
    }
    return hr;
} //ProcessParagraphBinTable

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::ProcessCharacterBinTable(void)
{
    // reset all of the appropriate variables
    HRESULT hr = S_OK;
    m_ifcfkp = 0;
    m_ibte = -1;        // this gets incremented before it is used.
    WORD crun = 0;

        while (m_ibte < m_cbte)
        {
                if (m_ifcfkp == crun) // go to next FKP in bin table
                {
                        m_ibte++;
                        if (m_ibte == m_cbte)
            {
                                // end of the bin table
                break;
            }

                        // seek to and read current FKP
                        hr = SeekAndRead(m_rgbte[m_ibte]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                                m_fkp, FKP_PAGE_SIZE, m_pStmMain);
                        if (FAILED(hr))
                                return hr;

                        m_ifcfkp = 0;
                        crun = m_fkp[FKP_PAGE_SIZE-1];

                }

                FC * rgfcfkp = (FC *)m_fkp;
                for (;  m_ifcfkp<crun;  m_ifcfkp++)
                {
                        BYTE bchpxOffset = *(m_fkp + (crun+1)*sizeof(FC) + m_ifcfkp);
                        if (bchpxOffset == 0)
                                continue;       // there is nothing in the CHPX.

                        BYTE *chpx = m_fkp + bchpxOffset*sizeof(WORD);
                        BYTE cbchpx = chpx[0];

            FC  fcStart, fcEnd;

            fcStart = rgfcfkp[m_ifcfkp];
            fcEnd = rgfcfkp[m_ifcfkp + 1];

            WORD lid = 0, lidFE = 0, bUseFE = 0;
                        WORD lidBi = 0, bUseBi = 0;

            ScanGrpprl(cbchpx, chpx + 1, &lid, &lidFE, &bUseFE, &lidBi, &bUseBi);
            if(lid || lidFE || bUseFE || lidBi || bUseBi)
            {
                                hr = m_pLangRuns->Add(lid, lidFE, bUseFE, fcStart, fcEnd, lidBi, bUseBi);
                            if (FAILED(hr))
                                    return hr;
            }
                }
        }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord8Stream::ProcessPieceTable(void)
{
        HRESULT hr = S_OK;

#if (0)
    for(ULONG ipcd = 0; ipcd < m_cpcd; ipcd++)
        {
            PCD pcdCur = m_rgpcd[ipcd];

            if (!pcdCur.prm1.fComplex)
                    {   // self-contained sprm -- no need to parse grpprl.
                    if (pcdCur.prm1.isprm==sprmCLid ||
                            pcdCur.prm1.isprm==sprmCRgLid0 || 
                pcdCur.prm1.isprm==sprmCRgLid1)
                            {
                    WORD lid = *((WORD*)((&pcdCur.prm1) + 2));
                                    hr = m_pLangRuns->Add(lid, fcStart, fcEnd);
                                        if (FAILED(hr))
                                                return hr;
                            }
                    }
            else
                    {
                    BYTE *grpprl;
                    USHORT cb;
                    grpprl = GrpprlCacheGet (pcdCur.prm2.igrpprl, &cb);

                    // Not found in cache - read it manually.
                    if (grpprl==NULL)
                            {
                            // seek to the fc where the complex part of the file starts
                            hr = Seek (m_fcClx, STREAM_SEEK_SET, m_pStmTable);
                            if (FAILED(hr))
                                    return hr;

                            // seek to the right grpprl
                            for (short igrpprlTemp = 0;  igrpprlTemp <= pcdCur.prm2.igrpprl;  igrpprlTemp++)
                                    {
                                    BYTE clxt;
                                    hr = Read (&clxt, sizeof(BYTE), m_pStmTable);
                                    if (FAILED(hr))
                                            return hr;

                                    if (clxt!=clxtGrpprl)
                                            {   // this is actually bad, but recoverable.
                                            return hr;
                                            }

                                    hr = Read (&cb, sizeof(USHORT), m_pStmTable);
                                    if (FAILED(hr))
                                            return hr;
                                    cb = SwapWord(cb);

                                    if (igrpprlTemp < pcdCur.prm2.igrpprl)
                                            {
                                            hr = Seek (cb, STREAM_SEEK_CUR, m_pStmTable);
                                            if (FAILED(hr))
                                                    return hr;
                                            }
                                    }

                            // Put it into the cache.
                            grpprl = GrpprlCacheAllocNew (cb, pcdCur.prm2.igrpprl);
                            hr = Read (grpprl, cb, m_pStmTable);
                            if (FAILED(hr))
                                    return hr;
                            }

                    WORD lid = ScanGrpprl(cb, grpprl);
            if(lid)
            {
                            hr = m_pLangRuns->Add(lid, fcStart, fcEnd);
                                if (FAILED(hr))
                                        return hr;
            }
                }
    }
#endif

        return hr;
}

void DeleteAll(CLidRun8 * pElem)
{
   if(pElem)
   {
      CLidRun8 * pNext = pElem->m_pNext;

      while(pNext) 
      {
         CLidRun8 * pNextNext = pNext->m_pNext;
         delete pNext;
         pNext = pNextNext;
      }

      delete pElem;
   }
}

HRESULT CWord8Stream::ScanLidsForFE(void)
{
        CLidRun8 * pLangRun = m_pLangRuns;

        while(1)
        {
                if(pLangRun->m_bUseFE && pLangRun->m_lidFE == 0x411)
                {
                        // J document
                        m_bFEDoc = TRUE;
                        m_FELid = 0x411;
                        break;
                }
                else if(pLangRun->m_bUseFE && pLangRun->m_lidFE == 0x412)
                {
                        // Korean document
                        m_bFEDoc = TRUE;
                        m_FELid = 0x412;
                        break;
                }
                else if(pLangRun->m_bUseFE && pLangRun->m_lidFE == 0x404)
                {
                        // Chinese document
                        m_bFEDoc = TRUE;
                        m_FELid = 0x404;
                        break;
                }
                else if(pLangRun->m_bUseFE && pLangRun->m_lidFE == 0x804)
                {
                        // Chinese document
                        m_bFEDoc = TRUE;
                        m_FELid = 0x804;
                        break;
                }

                pLangRun = pLangRun->m_pNext;
                if(pLangRun == NULL)
                {
                        break;
                }
        };
        
        return S_OK;
}

#endif // !VIEWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmitext.h ===
/*
** File: EXTEXT.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes: Implements a string space for storage of text.  The strings
**        are stored in such a way that if their TEXT values are equal,
**        the strings are exactly the same.
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* DEFINITIONS */

#ifndef EXTEXT_H
#define EXTEXT_H

#if !VIEWER

#ifdef __cplusplus
   extern "C" {
#endif

#define TEXT_STORAGE_DEFAULT 0

#ifdef _WIN64
typedef ULONG_PTR TEXT;
typedef ULONG_PTR TextStorage;
#else
typedef unsigned long TEXT;
typedef unsigned long TextStorage;
#endif // !_WIN64

#define TextStorageNull 0
                              
extern TextStorage TextStorageCreate (void * pGlobals);
extern void TextStorageDestroy (void * pGlobals, TextStorage hStorage);

#define NULLTEXT   0                 // The string ""
#define NULLSTR    0                 // The string ""
#define TEXT_ERROR 0xffffffff        // OutOfMemory while storing string

extern TEXT TextStoragePut    (void * pGlobals, TextStorage hStorage, char *pString, unsigned int cbString);
extern char *TextStorageGet   (TextStorage hStorage, TEXT t);
extern void TextStorageDelete (void * pGlobals, TextStorage hStorage, TEXT t);

extern void TextStorageIncUse (TextStorage hStorage, TEXT t);

#ifdef __cplusplus
   }
#endif

#endif // !VIEWER

#endif

/* end EXTEXT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiwd6st.cpp ===
#if !VIEWER

#include "dmiwd6st.hpp"
#include "filterr.h"
//
//  Added so as to support DRM errors
//
#include "drm.h"



#define TEMP_BUFFER_SIZE 1024
#define COMPLEX_BYTE_OFFSET 10
#define CLX_OFFSET 352
#define TEXT_STREAM_OFFSET 24
#define TEXT_STREAM_LENGTH_OFFSET 52
#define BIN_TABLE_OFFSET 184
#define FKP_CRUN_OFFSET 511
#define BIN_TABLE_COUNT_OFFSET 398
#define PARA_BIN_TABLE_COUNT_OFFSET 400
#define ENCRYPTION_FLAG_OFFSET 11 
#define FIB_OFFSET_lid 6

#define COMPLEX_BYTE_MASK 0x04
#define T3J_MAGIC_NUMBER 0xa697
#define T3_MAGIC_NUMBER 0xa5dc
#define KOR_W6_MAGIC_NUMBER 0xa698
#define KOR_W95_MAGIC_NUMBER 0x8098
#define CHT_W6_MAGIC_NUMBER 0xa699
#define CHS_W6_MAGIC_NUMBER 0x8099

#define sprmCFSpec 117
#define sprmCFStrikeRM 65
#define sprmCLid 97

#define BX_SIZE 7
#define istdNil 0xfff
#define FIB_OFFSET_fcStshf  0x60
#define FIB_OFFSET_lcbStshf 0x64


#define FIELD_BEGIN 19
#define FIELD_SEP 20
#define FIELD_END 21
// Different between W8 and W6 for some unknown reason.
#define CSpec_EMPTY_FORMFIELD 0x2013

#pragma pack(1)
typedef struct
{
        BYTE    fEncrypted:1;
        BYTE    fReserved:7;
} WORD_FIB_FLAGS;
#pragma pack()

extern "C" UINT CodePageFromLid(UINT wLid);

#ifdef MAC
// These two functions are defined in docfil.cpp
WORD    SwapWord( WORD theWord );
DWORD   SwapDWord( DWORD theDWord );
#else
#define SwapWord( theWord )             theWord
#define SwapDWord( theDWord )   theDWord
#endif // MAC


CWord6Stream::CWord6Stream()
:m_pStg(0),
        m_pstgEmbed(NULL),
        m_pestatstg(NULL),
        m_pstgOP(NULL),
        m_pStm(0),
        m_rgcp(0),
        m_rgpcd(0),
        m_rgbte(0),
        m_rgfcBinTable(0),
        m_pCache(0),
        m_rgchANSIBuffer(0),
    m_pLangRuns(NULL), 
    m_rgbtePap(NULL), 
    m_rgfcBinTablePap(NULL),
        m_lcbStshf(0),
    m_pSTSH(NULL)
        {
        AssureDtorCalled(CWord6Stream);

                lcFieldSep = 0;                                                 // count of field begins that haven't been matched
                                                                                                // with field separators.
                lcFieldEnd = 0;                                                 // count of field begins that haven't been matched

        }

CWord6Stream::~CWord6Stream()
        {
        Unload();

        // Delete m_rgchANSIBuffer in the destructor, not in Unload, so it will be
        // re-used from one document to another.
        if (m_rgchANSIBuffer)
                {
                FreePv (m_rgchANSIBuffer);
                m_rgchANSIBuffer = NULL;
                }
        }

#ifdef WIN
HRESULT CWord6Stream::Load(LPTSTR lpszFileName)
        {
        IStorage * pstg;

#if (defined OLE2ANSI || defined UNICODE)
    HRESULT hr = StgOpenStorage(lpszFileName,
                                                                0,
                                                                STGM_PRIORITY,
                                                                0,
                                                                0,
                                                                &pstg);
#else // !defined OLE2ANSI
        CConsTP lszFileName(lpszFileName);
        int cbwsz = (lszFileName.Cch() + 1) * sizeof(WCHAR);
        CHeapStr wszFileName;
        Protect0;
        wszFileName.SetCb(cbwsz);
        int retValue = MultiByteToWideChar(CP_ACP,
                                                                                MB_PRECOMPOSED,
                                                                                lszFileName,
                                                                                lszFileName.Cb(),
                                                                                (WCHAR *)(CHAR *)wszFileName,
                                                                                cbwsz/sizeof(WCHAR));

        if (retValue == 0)
                return FILTER_E_FF_UNEXPECTED_ERROR;

    HRESULT hr = StgOpenStorage((WCHAR *)(CHAR *)wszFileName,
                                                                0,
                                                                STGM_PRIORITY,
                                                                0,
                                                                0,
                                                                &pstg);
#endif // OLE2ANSI

        if (FAILED(hr)) // this is where we can plug in for 2.0 files
    {
                return FILTER_E_UNKNOWNFORMAT;
    }
                
        hr = LoadStg(pstg);
        pstg->Release();

    return hr;
        }

#endif // WIN

#ifdef  MAC
HRESULT CWord6Stream::Load(FSSpec *pfss)
        {
        Unload();
        m_ccpRead = 0;
    HRESULT hr = StgOpenStorageFSp( pfss,
                                                         0,
                                                         STGM_PRIORITY,
                                                         0,
                                                         0,
                                                         &m_pStg );

        if (FAILED(hr)) // this is where we can plug in for 2.0 files
                return hr;
                
        char *strmName = "WordDocument";
        
        hr = m_pStg->OpenStream( (LPOLESTR)strmName,
                                                 0,
                                                 STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                 0,
                                                 &m_pStm );
                                                
        if (FAILED(hr)) 
        return hr;
        
    STATSTG sstg;
    hr = m_pStm->Stat(&sstg, STATFLAG_NONAME);

    if (FAILED(hr))
        return hr;

        // Assume we already know this isn't Word 96.
        unsigned short magicNumber;
        hr = Read(&magicNumber, sizeof(short));
        if (FAILED(hr))
                return hr;
        magicNumber = SwapWord(magicNumber);

        // set m_fT3J if it's any of the FE versions
        m_fT3J = ((magicNumber == (unsigned short)T3J_MAGIC_NUMBER) ||
                                (magicNumber == (unsigned short)KOR_W6_MAGIC_NUMBER) ||
                                (magicNumber == (unsigned short)KOR_W95_MAGIC_NUMBER) ||
                                (magicNumber == (unsigned short)CHT_W6_MAGIC_NUMBER) ||
                                (magicNumber == (unsigned short)CHS_W6_MAGIC_NUMBER));


        // Seek to and read the flag to tell us whether this is a complex file
        BYTE grfTemp;
        hr = SeekAndRead(COMPLEX_BYTE_OFFSET, STREAM_SEEK_SET,
                                         (VOID HUGEP*)(&grfTemp), sizeof(BYTE));
    if (FAILED(hr))
        return hr;

    m_fComplex = ((grfTemp & COMPLEX_BYTE_MASK) == COMPLEX_BYTE_MASK);
                                
    if (m_fComplex)
        {
        hr = ReadComplexFileInfo();
        }
    else
        {
        hr = ReadNonComplexFileInfo();
        }

    return hr;
        }
#endif  // MAC

HRESULT CWord6Stream::LoadStg(IStorage * pstg)
        {
        Assert(m_pStg == NULL);

        m_pStg = pstg;
        m_pStg->AddRef();

        m_ccpRead = 0;

        HRESULT hr = CheckIfDRM( pstg );

        if ( FAILED( hr ) )
            return hr;

#ifdef OLE2ANSI
        hr = m_pStg->OpenStream( "WordDocument",
#else // !defined OLE2ANSI
        hr = m_pStg->OpenStream( L"WordDocument",
#endif // OLE2ANSI
                                                                 0,
                                                                 STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                                 0,
                                                                 &m_pStm );

        if (FAILED(hr)) 
        return hr;

        // Assume we already know this isn't Word 96.
        unsigned short magicNumber;
        hr = Read(&magicNumber, sizeof(unsigned short));
        if (FAILED(hr))
                return FILTER_E_UNKNOWNFORMAT;

        if (magicNumber != T3_MAGIC_NUMBER)
                {
                // set m_fT3J if it's any of the FE versions
                m_fT3J = ((magicNumber == (unsigned short)T3J_MAGIC_NUMBER) ||
                                        (magicNumber == (unsigned short)KOR_W6_MAGIC_NUMBER) ||
                                        (magicNumber == (unsigned short)KOR_W95_MAGIC_NUMBER) ||
                                        (magicNumber == (unsigned short)CHT_W6_MAGIC_NUMBER) ||
                                        (magicNumber == (unsigned short)CHS_W6_MAGIC_NUMBER));
                if (!m_fT3J)
                return FILTER_E_UNKNOWNFORMAT;
                }
        else
                m_fT3J = fFalse;

    if(m_fT3J)
        {
                GetLidFromMagicNumber(magicNumber);     
        }

        hr = SeekAndRead (FIB_OFFSET_lid, STREAM_SEEK_SET, &m_lid, sizeof(WORD));
        if (FAILED(hr))
                return hr;

        // Seek to and read whether the file is encrypted (if so, fail)
        WORD_FIB_FLAGS wff;
        hr = SeekAndRead(ENCRYPTION_FLAG_OFFSET,
                                                STREAM_SEEK_SET,
                                                (VOID HUGEP*)(&wff),
                                                sizeof(BYTE));
    if (FAILED(hr))
        return hr;

        if (wff.fEncrypted == 1)
                return FILTER_E_PASSWORD;

        // Seek to and read the flag to tell us whether this is a complex file
        BYTE grfTemp;
        hr = SeekAndRead(COMPLEX_BYTE_OFFSET,
                                                STREAM_SEEK_SET,
                                                (VOID HUGEP*)(&grfTemp),
                                                sizeof(BYTE));
    if (FAILED(hr))
        return hr;

        m_fComplex = ((grfTemp & COMPLEX_BYTE_MASK) == COMPLEX_BYTE_MASK);

    if (m_fComplex)
        hr = ReadComplexFileInfo();
    else
        hr = ReadNonComplexFileInfo();

        return hr;
        }


HRESULT CWord6Stream::Unload ()
        {
    if (m_pStm != NULL)
                {
#ifdef DEBUG
                ULONG cref =
#endif // DEBUG
        m_pStm->Release();
                m_pStm = NULL;
                Assert (cref == 0);
                }
    if (m_pStg != NULL)
                {
        m_pStg->Release();
                m_pStg = NULL;
                }
        if (m_pstgEmbed != NULL)
                {
                //m_pstgEmbed->Release();
                m_pstgEmbed = NULL;
                }
        if (m_pestatstg != NULL)
                {
                m_pestatstg->Release();
                m_pestatstg = NULL;
                }
        if (m_pstgOP != NULL)
                {
                m_pstgOP->Release();
                m_pstgOP = NULL;
                }

        if (m_rgcp)
                {
                delete m_rgcp;
                m_rgcp = 0;
                }
        if (m_rgpcd)
                {
                delete m_rgpcd;
                m_rgpcd = 0;
                }
        if (m_rgfcBinTable)
                {
                delete m_rgfcBinTable;
                m_rgfcBinTable = 0;
                }
        if (m_rgbte)
                {
                delete m_rgbte;
                m_rgbte = 0;
                }

    if (m_rgfcBinTablePap)
                {
                FreePv (m_rgfcBinTablePap);
                m_rgfcBinTablePap = NULL;
                }
        if (m_rgbtePap)
                {
                FreePv (m_rgbtePap);
                m_rgbtePap = NULL;
                }
        if (m_pSTSH)
                {
                FreePv (m_pSTSH);
                m_pSTSH = NULL;
                m_lcbStshf = 0;
                }
    if(m_pLangRuns)
        {
        DeleteAll6(m_pLangRuns);
        m_pLangRuns = NULL;
        }

        if (m_pCache!=NULL)
                delete m_pCache->pbExcLarge;
        delete m_pCache;
        m_pCache = 0;

        return S_OK;
        }

// Things we don't want in the buffer: special characters, revision text, and
// text that is between field begin and field separator characters (or a field end
// character, if the field separator character has been omitted).  However, we
// must read in special characters to parse them, but we will write over them in
// the buffer after we've parsed them.  Unless there is an error, we never leave
// this function while reading between a field begin and field separator
// character.
// Assumption: we are at the place in the stream where we will be reading text
// from next.
HRESULT CWord6Stream::ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead)
        {
        // We pretend we just have half cb size so that later we can safely change 0D to 0D0A
        // to be able to keep end of paragraph info
        cb = cb / 2;
        cb = cb & ~1;

        if (cb == 0)
                {
                // We can't ask for one character...we loop forever.  Dodge that now.
                if (pcbRead)  // We're almost done...don't crash here.
                        *pcbRead = 0;
                return FILTER_E_NO_MORE_TEXT;
                }

StartAgain:
        *pcbRead = 0;
        HRESULT hr = S_OK;
        ULONG cbRead = 0;
        WCHAR * pUnicode = (WCHAR*)pv;

        FC fcCur;               // the current position in the stream
        ULONG ccpLeft;  // count of characters left to read from stream
        if (m_fComplex)
                {
                if (m_ipcd == m_cpcd)   // at the end of the piece table
                        return FILTER_E_NO_MORE_TEXT;
                fcCur = m_rgpcd[m_ipcd].fc + (m_ccpRead - m_rgcp[m_ipcd]);
                ccpLeft = m_rgcp[m_ipcd+1] - m_ccpRead; // cp's left in this piece
                }
        else
                {
                fcCur = m_fcMin + m_ccpRead;
                ccpLeft = m_ccpText - m_ccpRead;
                if (ccpLeft == 0)       // read all of the text in the stream
                        return FILTER_E_NO_MORE_TEXT;
                }
        if (ccpLeft == 1)
                {
                if (m_fT3J)
                        {
                        // something has gone seriously wrong, but prevent a hang
                        return FILTER_E_NO_MORE_TEXT;
                        }
                }


        ULONG cchBuffer = cb/sizeof(WCHAR);                                             
        ULONG cbToRead = min(cchBuffer, ccpLeft);               // count of bytes left that can be
                                                                                                        // read until the function returns
                                                                                                        // or m_ipcd changes.
        if(!m_fT3J)
        {
                lcFieldSep = 0;                                                                 // count of field begins that haven't been matched
                                                                                                                // with field separators.
                lcFieldEnd = 0;                                                                 // count of field begins that haven't been matched
        }                                                                                                       // with field ends.

        if (m_rgchANSIBuffer==NULL)
                m_rgchANSIBuffer = (char *) PvAllocCb (cchBuffer);
        else if (cchBuffer>(ULONG)CbAllocatedPv(m_rgchANSIBuffer))
                m_rgchANSIBuffer = (char *) PvReAllocPvCb (m_rgchANSIBuffer,cchBuffer);

        char * pbBufferCur = m_rgchANSIBuffer;          // pointer to the position in
                                                                                                // the buffer where text will
                                                                                                // be copied next

        while (cbToRead > 1 || (cbToRead != 0 && !m_fT3J))
                {
                FC fcspecCur;   // the fc where the next special char run begins
                FC fcspecEnd;   // the fc where the next special char run ends

                if (lcFieldSep == 0)  // Office QFE 1663: No unmatched field begin chars.
                        {
                LCID lid;
                        HRESULT res = CheckLangID(fcCur, &cbToRead, &lid);
                        if(res == FILTER_E_NO_MORE_TEXT)
                                {
                            if(!m_fT3J)
                                        {
                                        int cchWideChar = MultiByteToWideChar (
                                                CodePageFromLid(m_currentLid), 
                                                0,              
                                                m_rgchANSIBuffer,
                                                *pcbRead,
                                                (WCHAR *)pv,
                                                *pcbRead);
                                        Assert((unsigned int)cchWideChar <= *pcbRead);
                                        Assert(cchWideChar*sizeof(WCHAR) <= cb);
                                        *pcbRead = cchWideChar*sizeof(WCHAR);
                                        }
                                else
                                        {
                                        // all conversion has already been done in CompactBuffer
                                        // just update pcbRead
                                        *pcbRead = (ULONG) ( (char*)pUnicode - (char*)pv );
                                        }
                                hr = FILTER_E_NO_MORE_TEXT;
                                goto Done;
                                }
                        }

                if (m_fsstate == FSPEC_NONE)
                        {
                        fcspecCur = 0;
                        fcspecEnd = 0;
                        }
                else if (m_fsstate == FSPEC_ALL)
                        {
                        fcspecCur = fcCur;
                        fcspecEnd = fcCur + ccpLeft;
                        }
                else            // m_fsstate == FSPEC_EITHER
                        {               // use the current positions from the fkp
                fcspecCur = ((FC *)m_fkp)[m_irgfcfkp];
                fcspecEnd = ((FC *)m_fkp)[m_irgfcfkp + 1];
                }

        if (m_fComplex)
                {
                if (fcspecCur >= fcCur + ccpLeft)
                        {       // the next special char is after the current piece of text
                        fcspecCur = 0;
                        fcspecEnd = 0;
                        }
                else
                        {
                        if (fcspecEnd > fcCur + ccpLeft)
                                {       // the next run extends beyond the current piece of text
                                fcspecEnd = fcCur + ccpLeft;
                                }
                        }
                }               
        if (fcspecCur < fcCur)
                {       // we're in the middle of a run of special text
                if (fcspecCur != 0)
                        fcspecCur = fcCur;
                }
                ULONG cbThruSpec = 0;   // count of bytes through end of spec char run
                ULONG cchSpecRead = fcspecEnd - fcspecCur;      // count of special characters
                                                                                                        // that will be read

                if (lcFieldSep == 0)    // no unmatched field begin characters
                        {
                if (fcspecCur >= fcCur + cbToRead)
                        {       // the first special character is too away to fit in buffer
                        fcspecCur = 0;
                        fcspecEnd = 0;
                        cchSpecRead = 0;
                        }
                else if (fcspecEnd >= (fcCur + cbToRead))
                        {
                                // the last spec character is too away to fit in buffer
                        fcspecEnd = fcCur + cbToRead;
                        cchSpecRead = fcspecEnd - fcspecCur;
                        }
                        if (fcspecEnd != 0)                                     // how many characters will             
                                cbThruSpec = fcspecEnd - fcCur; // we be reading from the
                        else                                                            // stream?
                                cbThruSpec = cbToRead;

                        // Don't read an uneven number of bytes
                        if (m_fT3J)
                                {
                                if (cbThruSpec%2 == 1 && cbThruSpec != 1)       // it's an odd number
                                        cbThruSpec--;
                                }

                        hr = Read(pbBufferCur, cbThruSpec);

                        if (FAILED(hr))
                                {
                                goto LCheckNonReqHyphen;
                                }

                        // set pbBufferCur to before the special character run
                        char FAR * pbBeg = pbBufferCur;
                        pbBufferCur += (cbThruSpec - cchSpecRead);

                        *pcbRead += CompactBuffer(&pbBufferCur, &pbBeg, &pUnicode);

                        }
                else    // lcFieldSep != 0, there are unmatched field begin characters
                        {
                        if (cchSpecRead > cbToRead)
                                cchSpecRead = cbToRead;
                        ULONG cbSeek = fcspecCur - fcCur;       // how do we seek?
                        if (fcspecCur == 0)                     // seek to the end of our current range
                                cbSeek = cbToRead;
                        cbThruSpec = cbSeek + cchSpecRead;      // total bytes to advance
                                                                                                // in stream

                // seek past non-special chars and read the run of special chars
                        HRESULT hr = SeekAndRead(cbSeek, STREAM_SEEK_CUR,
                                                                         pbBufferCur, cchSpecRead);

                        if (FAILED(hr))
                                goto LCheckNonReqHyphen;
                }

                // iterate through special characters, parsing them.
                // Only do this for true special characters, not struck-out text.
                if (!m_fStruckOut)
                        {
                        for (char * pbspec = pbBufferCur;
                                 pbspec<(pbBufferCur+cchSpecRead);
                                 pbspec++)
                                {
                                switch(*pbspec)
                                        {
                                        case FIELD_BEGIN:
                                                lcFieldSep++;
                                                lcFieldEnd++;
                                                break;
                                        case FIELD_SEP:
                                                lcFieldSep--;
                                                break;
                                        case FIELD_END:
                                                // we only care about field ends when they match a field begin
                                                // that a field separator has not matched.
                                                if (lcFieldEnd > 0)
                                                        lcFieldEnd--;
                                                if (lcFieldEnd < lcFieldSep)
                                                        lcFieldSep = lcFieldEnd;
                                                break;
                                        default:
                                                break;
                                        }
                                }
                        }
                m_ccpRead += cbThruSpec;        // this is the *total* number of characters
                                                                        // we've read or seeked past.
                fcCur += cbThruSpec;
                ccpLeft -= cbThruSpec;

                // because of buffer compaction, pbBufferCur may not be in the right
                // place.
                if (m_fT3J)
                        pbBufferCur = m_rgchANSIBuffer + *pcbRead;

                if (ccpLeft == 0)
                {
                        if (m_fComplex) // we've exhausted the text in the current pcd.
                        {       
                                if (++m_ipcd == m_cpcd) // EOF!
                                {
                                        hr = FILTER_S_LAST_TEXT;
                                        goto Done;
                                }
                                ccpLeft = m_rgcp[m_ipcd+1] - m_rgcp[m_ipcd];
                                fcCur = m_rgpcd[m_ipcd].fc;

                                hr = FindNextSpecialCharacter(TRUE);
                                if (FAILED(hr))
                                        goto LCheckNonReqHyphen;
                        }
                }
                else if (((FC *)m_fkp)[m_irgfcfkp + 1] == fcCur)
                {       // the current file position is the end of a special character run
                        hr = FindNextSpecialCharacter ();
                        if (FAILED(hr))
                                goto LCheckNonReqHyphen;
                }
                cbToRead = min(cchBuffer - *pcbRead, ccpLeft);  // this is limited either by
                                                                                                                // the size of the buffer or
                                                                                                                // the size of the pcd
        }
Done:
        if (SUCCEEDED(hr))
        {
                // if the code page is not installed, we may not get anything useful
                // out of the MultiByteToWideChar() call.
                if(!m_fT3J)
                {
                        int cchWideChar = MultiByteToWideChar (
                                CodePageFromLid(m_currentLid), 
                                0,              
                                m_rgchANSIBuffer,
                                *pcbRead,
                                (WCHAR *)pv,
                                *pcbRead);
                        Assert((unsigned int)cchWideChar <= *pcbRead);
                        Assert(cchWideChar*sizeof(WCHAR) <= cb);
                        *pcbRead = cchWideChar*sizeof(WCHAR);

                        if (cchWideChar == 0)
                                goto StartAgain;
                }
                else
                {
                        // all conversion has already been done in CompactBuffer
                        // just update pcbRead
                        *pcbRead = (ULONG)((char*)pUnicode - (char*)pv);
                }

        }

LCheckNonReqHyphen:

#define xchNonReqHyphen         31

// QFE 2255: add table cell delimiter checking
#define xchTableCellDelimiter   7

        WCHAR *pwchSrc = (WCHAR *)pv;
        WCHAR *pwchDest = (WCHAR *)pv;
        WCHAR *pwchLim = pwchSrc + *pcbRead/sizeof(WCHAR);
        ULONG cPara = 0;

        for (; pwchSrc != pwchLim; pwchSrc++)
                {
                if (*(WCHAR UNALIGNED *)pwchSrc != xchNonReqHyphen)
                        {
                        if (*(WCHAR UNALIGNED *)pwchSrc == xchTableCellDelimiter)
                                *(WCHAR UNALIGNED *)pwchSrc = 0x0009;

                        if (pwchDest == pwchSrc)
                                pwchDest++;
                        else
                                *(WCHAR UNALIGNED *)pwchDest++ = *(WCHAR UNALIGNED *)pwchSrc;
                        }

                // count number of paragraph marks
                if (*(WCHAR UNALIGNED *)pwchSrc == 0x000d)
                        {
                        if ((pwchSrc+1) != pwchLim)
                                {
                                if (*(WCHAR UNALIGNED *)(pwchSrc+1) != 0x000a)
                                        cPara++;
                                }
                        else
                                cPara++;
                        }
                }

        *pcbRead = (ULONG)((pwchDest - (WCHAR *)pv) * sizeof(WCHAR));

        if (cPara)
                {
                WCHAR *pwchLimReverse = (WCHAR *)pv - 1;
                pwchLim = (WCHAR *)pv + *pcbRead/sizeof(WCHAR);
                pwchDest = (pwchLim-1) + cPara;

                for (pwchSrc = pwchLim-1; pwchSrc != pwchLimReverse; pwchSrc--)
                        {
                        if (*(WCHAR UNALIGNED *)pwchSrc == 0x000d)
                                {
                                if (pwchSrc != pwchLim-1)
                                        {
                                        if (*(WCHAR UNALIGNED *)(pwchSrc+1) != 0x000a)
                                                {
                                                *(WCHAR UNALIGNED *)(pwchDest--) = 0x000a;
                                                *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                                                }
                                        else
                                                *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                                        }
                                else
                                        {
                                        *(WCHAR UNALIGNED *)(pwchDest--) = 0x000a;
                                        *(WCHAR UNALIGNED *)(pwchDest--) = 0x000d;
                                        }
                                }
                        else
                                *(WCHAR UNALIGNED *)(pwchDest--) = *(WCHAR UNALIGNED *)pwchSrc;
                        }

                *pcbRead += (cPara * sizeof(WCHAR));
                }

        return hr;
}


HRESULT CWord6Stream::GetNextEmbedding(IStorage ** ppstg)
        {
        HRESULT hr;

        // release any previous embeddings
        if (m_pstgEmbed != NULL)
                {
                //m_pstgEmbed->Release();
                m_pstgEmbed = NULL;
                }
        else if (m_pstgOP == NULL)
                {
#ifdef OLE2ANSI
                hr = m_pStg->OpenStorage("ObjectPool",
#else // !defined OLE2ANSI
                hr = m_pStg->OpenStorage(L"ObjectPool",
#endif // OLE2ANSI
                                                                        NULL,   // pstgPriority
                                                                        STGM_SHARE_EXCLUSIVE,
                                                                        NULL,   // snbExclude
                                                                        0,              // reserved
                                                                        &m_pstgOP);

                if (FAILED(hr))
                        return OLEOBJ_E_LAST;
                }

        Assert(m_pstgOP != NULL);

        if (m_pstgOP != NULL && m_pestatstg == NULL)
                {
                hr = m_pstgOP->EnumElements(0, NULL, 0, &m_pestatstg);
                if (FAILED(hr))
                        return hr;
                }


        Assert(m_pestatstg != NULL);
        Assert(m_pstgEmbed == NULL);

        STATSTG statstg;
        hr = m_pestatstg->Next(1, &statstg, NULL);
        if (FAILED(hr))
                return hr;
        if (hr == S_FALSE)
                return OLEOBJ_E_LAST;

        hr = m_pstgOP->OpenStorage(statstg.pwcsName,
                                                                NULL,   // pstgPriority
                                                                STGM_SHARE_EXCLUSIVE,
                                                                NULL,   // snbExclude
                                                                0,              // reserved
                                                                &m_pstgEmbed);

        LPMALLOC pMalloc;
        if (S_OK == CoGetMalloc(MEMCTX_TASK, &pMalloc))
                {
                pMalloc->Free(statstg.pwcsName);
                pMalloc->Release();
                }

        *ppstg = m_pstgEmbed;
        return hr;
        }


HRESULT CWord6Stream::ReadComplexFileInfo()
        {
        // The following two variables are not used for complex files.
        m_fcMin = 0;
        m_ccpText = 0;
        m_ipcd = 0;

        // Seek to and read the offset of the complex part of the file
        HRESULT hr = SeekAndRead(CLX_OFFSET, STREAM_SEEK_SET,
                                                         &m_fcClx, sizeof(FC));
        if (FAILED(hr))
                return hr;
    m_fcClx = (FC)(SwapDWord((DWORD)m_fcClx));

        // Seek to and read the first part of the complex part of the file
        BYTE clxt;
        hr = SeekAndRead(m_fcClx, STREAM_SEEK_SET,
                                         &clxt, sizeof(BYTE));

        USHORT cb;
        while ((SUCCEEDED(hr)) && (clxt == 1))
                {
                hr = Read(&cb, sizeof(USHORT));
                cb = SwapWord(cb);
                if (FAILED(hr))
                        return hr;

                hr = Seek(cb, STREAM_SEEK_CUR);
                if (FAILED(hr))
                        return hr;

                hr = Read(&clxt, sizeof(BYTE));
                }
        if (clxt != 2)  // something went really wrong
                {
                if (SUCCEEDED(hr))
                        hr = ResultFromScode(E_UNEXPECTED);
                }
        if (FAILED(hr))
                return hr;

        ULONG cbPlcfpcd;
        hr = Read(&cbPlcfpcd, sizeof(ULONG));   // read in size of plex
        cbPlcfpcd = SwapDWord(cbPlcfpcd);
        if (FAILED(hr))
                return hr;

        m_cpcd=(cbPlcfpcd-sizeof(FC))/(sizeof(FC)+sizeof(PCD));
        m_rgcp = new FC [m_cpcd + 1];

        if ( 0 == m_rgcp )
            return E_OUTOFMEMORY;

        m_rgpcd = new PCD [m_cpcd];

        if ( 0 == m_rgpcd )
            return E_OUTOFMEMORY;

        hr = Read(m_rgcp, sizeof(FC)*(m_cpcd+1));
        if (FAILED(hr))
                return hr;

        for (FC * pfc = m_rgcp; pfc <= m_rgcp + m_cpcd; pfc++)
                {
                *pfc = SwapDWord(*pfc);
                if (m_fT3J)
                        *pfc *= 2;
                }

        hr = Read(m_rgpcd, sizeof(PCD)*(m_cpcd));
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (PCD * pcd = m_rgpcd; pcd < m_rgpcd + m_cpcd; pcd++)
                pcd->fc = SwapDWord(pcd->fc);
#endif // MAC

        m_pCache = new CacheGrpprl;

        if ( 0 == m_pCache )
            return E_OUTOFMEMORY;

        hr = ReadBinTable();
        if (FAILED(hr))
                return hr;

        hr = Seek(m_rgpcd[m_ipcd].fc, STREAM_SEEK_SET);

        return hr;
        }


HRESULT CWord6Stream::ReadNonComplexFileInfo ()
        {
        // The following member variables are not used for non-complex files.
        // m_rgcp = 0;  set in constructor
        // m_rgpcd = 0; set in constructor
        m_cpcd = 0;
        m_ipcd = 0;
        m_fcClx = 0;

        // seek to and read fcMin from the stream       
        HRESULT hr = SeekAndRead(TEXT_STREAM_OFFSET, STREAM_SEEK_SET,
                                                         &m_fcMin, sizeof(FC));
        if (FAILED(hr))
                return hr;

        m_fcMin = SwapDWord(m_fcMin);

        // read the fc of the end of the text
        FC fcEnd;
        hr = Read(&fcEnd, sizeof(FC));
        if (FAILED(hr))
                return hr;

        fcEnd = SwapDWord(fcEnd);

        m_ccpText = fcEnd - m_fcMin;

        hr = ReadBinTable();
        if (FAILED(hr))
                return hr;

        // Seek to beginning of text
        hr = Seek(m_fcMin, STREAM_SEEK_SET);

        return hr;
        }


HRESULT CWord6Stream::ReadBinTable ()
        {
        // Seek to and read the char property bin table offset
        FC fcPlcfbteChpx;
        HRESULT hr = SeekAndRead(BIN_TABLE_OFFSET, STREAM_SEEK_SET,
                                                         &fcPlcfbteChpx, sizeof(FC));
        if (FAILED(hr))
                return hr;

        fcPlcfbteChpx = SwapDWord(fcPlcfbteChpx);

        // Read the size of the char property bin table
        long lcbPlcfbteChpx;
        hr = Read(&lcbPlcfbteChpx, sizeof(long));
        if (FAILED(hr))
                return hr;

        lcbPlcfbteChpx = SwapDWord(lcbPlcfbteChpx);

        m_cbte = (lcbPlcfbteChpx - sizeof(FC))/(sizeof(FC) + sizeof(BTE));
        long cbteRecorded = m_cbte;

        // Read the paragraph property bin table offset
        FC fcPlcfbtePapx;
        hr = Read(&fcPlcfbtePapx, sizeof(FC));
        if (FAILED(hr))
                return hr;
        fcPlcfbtePapx = SwapDWord(fcPlcfbtePapx);

        // Read the size of the paragraph property bin table
        long lcbPlcfbtePapx;
        hr = Read(&lcbPlcfbtePapx, sizeof(long));
        if (FAILED(hr))
                return hr;

        lcbPlcfbtePapx = SwapDWord(lcbPlcfbtePapx);

    if (!m_fComplex)    
                {
                // in case bin table needs to be reconstructed, read in size of it
                short usTemp;
                hr = SeekAndRead(BIN_TABLE_COUNT_OFFSET, STREAM_SEEK_SET,
                                                 &usTemp, sizeof(short));
                if (FAILED(hr))
                        return hr;

                m_cbte = (long)SwapWord(usTemp);

                // seek past the FC array from the bin table
                hr = Seek(fcPlcfbteChpx + sizeof(FC)*(cbteRecorded+1), STREAM_SEEK_SET);
                if (FAILED(hr))
                        return hr;
                }
        else    // read in the FC array from the bin table
                {
                m_rgfcBinTable = new FC [m_cbte+1];

                if ( 0 == m_rgfcBinTable )
                    return E_OUTOFMEMORY;

                hr = SeekAndRead(fcPlcfbteChpx, STREAM_SEEK_SET,
                                                 m_rgfcBinTable, sizeof(FC)*(cbteRecorded+1));
                if (FAILED(hr))
                        return hr;

#ifdef MAC
                for (FC * pfc = m_rgfcBinTable; pfc <= m_rgfcBinTable + m_cbte; pfc++)
                        *pfc = SwapDWord(*pfc);
#endif // MAC
                }

        // Read in the BTE array from the bin table
        m_rgbte = new BTE [m_cbte];

        if ( 0 == m_rgbte )
            return E_OUTOFMEMORY;

        if (cbteRecorded > m_cbte)
                return FILTER_E_UNKNOWNFORMAT;

        hr = Read(m_rgbte, sizeof(BTE)*cbteRecorded);
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (BTE *pbte = m_rgbte; pbte < m_rgbte + cbteRecorded; pbte++)
                *pbte = SwapWord(*pbte);
#endif // MAC

    // reconstruct the bin table BTE's, if necessary
        if (!m_fComplex)
                {
                BTE bteTemp = m_rgbte[cbteRecorded-1];
                for (; cbteRecorded < m_cbte; cbteRecorded++)
                        m_rgbte[cbteRecorded] = ++bteTemp;
                }

// same for paragraph BIN table

        m_cbtePap = (lcbPlcfbtePapx - sizeof(FC))/(sizeof(FC) + sizeof(BTE));
    long cbteRecordedPap = m_cbtePap;


    if (!m_fComplex)
                {
                // in case bin table needs to be reconstructed, read in size of it
                short usTemp;
                hr = SeekAndRead(PARA_BIN_TABLE_COUNT_OFFSET, STREAM_SEEK_SET,
                                                 &usTemp, sizeof(short));
                if (FAILED(hr))
                        return hr;

                m_cbtePap = (long)SwapWord(usTemp);

                // seek past the FC array from the bin table
                hr = Seek(fcPlcfbtePapx + sizeof(FC)*(cbteRecordedPap+1), STREAM_SEEK_SET);
                if (FAILED(hr))
                        return hr;
                }
        else
                {
                m_rgfcBinTablePap = (FC *) PvAllocCb ((m_cbtePap+1)*sizeof(FC));
                if(!m_rgfcBinTablePap)
                        return E_OUTOFMEMORY;

                hr = SeekAndRead(fcPlcfbtePapx, STREAM_SEEK_SET,
                        m_rgfcBinTablePap, sizeof(FC)*(cbteRecordedPap+1));
                if (FAILED(hr))
                        return hr;

#ifdef MAC
                for (FC * pfc = m_rgfcBinTablePap; pfc <= m_rgfcBinTablePap + m_cbtePap; pfc++)
                        *pfc = SwapDWord(*pfc);
#endif // MAC
                }

        // Read in the BTE array from the bin table.
        m_rgbtePap = (BTE *) PvAllocCb (m_cbtePap*sizeof(BTE));
        if(!m_rgbtePap)
                return E_OUTOFMEMORY;

        hr = Read(m_rgbtePap, sizeof(BTE)*cbteRecordedPap);
        if (FAILED(hr))
                return hr;

#ifdef MAC
        for (BTE *pbte = m_rgbtePap; pbte < m_rgbtePap + m_cbtePap; pbte++)
                *pbte = SwapWord(*pbte);
#endif // MAC

    // reconstruct the bin table BTE's, if necessary
        if (!m_fComplex)
                {
                BTE bteTempPap = m_rgbtePap[cbteRecordedPap-1];
                for (; cbteRecordedPap < m_cbtePap; cbteRecordedPap++)
                        m_rgbtePap[cbteRecordedPap] = ++bteTempPap;
                }

        // read in style sheet (STSH)

    // offset of STSH in table stream
    FC fcStshf;
        hr = SeekAndRead(
                FIB_OFFSET_fcStshf, //0xA2
                STREAM_SEEK_SET,
                &fcStshf, sizeof(FC));
        if (FAILED(hr))
                return hr;
        fcStshf = SwapDWord(fcStshf);

    // size of STSH
    unsigned long lcbStshf;
        hr = SeekAndRead(
                FIB_OFFSET_lcbStshf, //0xA6
                STREAM_SEEK_SET,
                &lcbStshf, sizeof(unsigned long));
        if (FAILED(hr))
                return hr;
        lcbStshf = SwapDWord(lcbStshf);

    if(lcbStshf)
    {
        // allocate STSH
            m_pSTSH = (BYTE*)PvAllocCb (lcbStshf);
        if(!m_pSTSH)
            return E_OUTOFMEMORY;
                m_lcbStshf = lcbStshf;

        // seek and read STSH from table stream
            hr = SeekAndRead(fcStshf, STREAM_SEEK_SET, m_pSTSH, lcbStshf);
            if (FAILED(hr))
                    return hr;
    }

    hr = CreateLidsTable();
    if(hr)
        return hr;

    hr = FindNextSpecialCharacter (TRUE);

        return hr;
        }


HRESULT CWord6Stream::FindNextSpecialCharacter(BOOL fFirstChar)
        {
        // NOTE: This function only works for complex files when the pcd changes
        // if fFirstChar is TRUE
        // CONSIDER: This could also be more efficient if revision text were marked
        // so that it doesn't get parsed along with the rest of the special text.
        HRESULT hr = S_OK;
        BYTE crun;                      // count of runs in the current

        FC fcCurrent;
        if (m_fComplex)
                fcCurrent = m_rgpcd[m_ipcd].fc + (m_ccpRead - m_rgcp[m_ipcd]);
        else
                fcCurrent = m_fcMin + m_ccpRead;

        if (fFirstChar)
                {       // reset all of the appropriate variables
                m_irgfcfkp = 0;
                m_ibte = -1;    // this gets incremented before it is used.
                crun = 0;
                m_fsstate = FSPEC_EITHER;
                if (m_fComplex)
                        {
                        // parse the grpprls
                        hr = ParseGrpPrls();
                        if (m_fsstate != FSPEC_EITHER || FAILED(hr))
                                {       // there's no point in parsing the fkps
                                m_ibte = 0;
                                // Seek back to the current text
                                if (SUCCEEDED(hr))
                                        hr = Seek(fcCurrent, STREAM_SEEK_SET);
                                return hr;
                                }
                        // find the right FKP.
                        for (m_ibte=0;  m_ibte<m_cbte;  m_ibte++)
                                if (fcCurrent>=m_rgfcBinTable[m_ibte] &&
                                        fcCurrent<m_rgfcBinTable[m_ibte+1])
                                        break;
                        if (m_ibte==m_cbte)
                                return FILTER_E_NO_MORE_TEXT;
                        m_ibte --;      // gets incremented before it is used.
                        }
                }
        else
                {
                crun = m_fkp[FKP_PAGE_SIZE - 1];
                m_irgfcfkp++;
                if (m_fsstate != FSPEC_EITHER)  // no point in parsing the fkps
                        return hr;
        }

        while (m_ibte < m_cbte)
                {
                if (m_irgfcfkp == crun)
                        {
                        m_ibte++;
                        if (m_ibte == m_cbte)
                                break;

                        // seek to and read current FKP
                        hr = SeekAndRead(m_rgbte[m_ibte]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                                                         m_fkp, FKP_PAGE_SIZE);
                        if (FAILED(hr))
                                return hr;

                        // Seek back to the current text
                        hr = Seek(fcCurrent, STREAM_SEEK_SET);
                        if (FAILED(hr))
                                return hr;

                m_irgfcfkp = 0;
                        crun = m_fkp[FKP_PAGE_SIZE-1];

#ifdef MAC
                        FC * pfc = (FC *)m_fkp;
                        for (BYTE irun = 0; irun < crun; irun++)
                                {
                                *pfc = SwapDWord(*pfc);
                                pfc++;
                                }
#endif // MAC
                        }

                FC * rgfcfkp = (FC *)m_fkp;
                for(;  m_irgfcfkp<crun;  m_irgfcfkp++)
                        {
                        if (m_fComplex)
                                {
                                if (rgfcfkp[m_irgfcfkp + 1] <= fcCurrent)
                                        continue;
                                }

                        BYTE bchpxOffset = *(m_fkp + (crun+1)*sizeof(FC) + m_irgfcfkp);
                        if (bchpxOffset == 0)
                                continue;       // there is nothing in the CHPX.

                        BYTE * chpx = m_fkp + bchpxOffset*sizeof(WORD);
                        BYTE cbchpx = chpx[0];

                        for (BYTE i = 1; i < cbchpx - 1; i++)
                                {
                                if ((chpx[i] == sprmCFSpec && chpx[i+1] == 1) ||
                                        chpx[i] == sprmCFStrikeRM)
                                        {
                                        m_fStruckOut = (chpx[i] == sprmCFStrikeRM);
                                        return hr;
                                        }
                                }
                        }
                }

        // We're at the end of the bin table -- no more special characters.
        m_fsstate = FSPEC_NONE;

        return hr;
        }


// This function changes the current pointer and does not put it back.  It
// cannot be called directly from ReadText().  It needs to be called by a
// function that will replace the pointer.
HRESULT CWord6Stream::ParseGrpPrls ()
        {
        HRESULT hr = S_OK;
        PCD pcdCur = m_rgpcd[m_ipcd];

        if (pcdCur.prm.fComplex == 0)
                {       // self-contained sprm -- no need to parse grpprl
                if (pcdCur.prm.sprm == sprmCFSpec ||
                        pcdCur.prm.sprm == sprmCFStrikeRM)
                        {
                        m_fStruckOut = (pcdCur.prm.sprm == sprmCFStrikeRM);
                        if (pcdCur.prm.val == 0)
                                m_fsstate = FSPEC_NONE;
                        else
                                m_fsstate = FSPEC_ALL;
                        }
                }

        else
                {
                short igrpprl = ((PRM2*)&pcdCur.prm)->igrpprl;
                BYTE *grpprl;
                USHORT cb;
                grpprl = GrpprlCacheGet (igrpprl, &cb);

                // Not found in cache - read it manually.
                if (grpprl==NULL)
                        {
                        // seek to the fc where the complex part of the file starts
                        hr = Seek (m_fcClx, STREAM_SEEK_SET);
                        if (FAILED(hr))
                                return hr;

                        BYTE clxt;
                // seek to the right grpprl
                        for (short igrpprlTemp = 0;  igrpprlTemp <= igrpprl;  igrpprlTemp++)
                                {
                                hr = Read(&clxt, sizeof(BYTE));
                                if (FAILED(hr))
                                        return hr;

                                if (clxt!=1)
                                        {       // this is actually bad, but recoverable.
                                        m_fsstate = FSPEC_EITHER;
                                        return hr;
                                        }

                                hr = Read(&cb, sizeof(USHORT));
                                if (FAILED(hr))
                                        return hr;

                                cb = SwapWord(cb);

                                if (igrpprlTemp < igrpprl)
                                        {
                                        hr = Seek (cb,STREAM_SEEK_CUR);
                                        if (FAILED(hr))
                                                return hr;
                                        }
                                }

                        // Put it into the cache.
                        grpprl = GrpprlCacheAllocNew (cb,igrpprl);
                        hr = Read (grpprl, sizeof(BYTE)*cb);
                        if (FAILED(hr))
                                return hr;
                        }

                for (unsigned short isprm=0;  isprm<cb-1;  isprm++)
                        {
                        if (grpprl[isprm] == sprmCFSpec ||
                                grpprl[isprm] == sprmCFStrikeRM)
                                {
                                m_fStruckOut = (grpprl[isprm] == sprmCFStrikeRM);
                                if (grpprl[isprm+1] == 0)
                                        m_fsstate = FSPEC_NONE;
                                else
                                        m_fsstate = FSPEC_ALL;
                                return hr;
                                }
                        }
                }

        m_fsstate = FSPEC_EITHER;
        return hr;
        }


////////////////////////////////////////////////////////////////////////////////
// Return a pointer to the grpprl with this index and its size.
// Return NULL if there is none.
//
BYTE *CWord6Stream::GrpprlCacheGet (short igrpprl, USHORT *pcb)
        {
        NoThrow();
        if (!m_pCache)
                {
                return NULL;
                }
        for (int i=0;  i<m_pCache->cItems;  i++)
                if (igrpprl==m_pCache->rgIdItem[i])
                        {
                        m_pCache->rglLastAccTmItem[i] = m_pCache->lLastAccTmCache;
                        m_pCache->lLastAccTmCache ++;
                        *pcb = (USHORT) (m_pCache->ibFirst[i+1] - m_pCache->ibFirst[i]);
                        return m_pCache->rgb+m_pCache->ibFirst[i];
                        }
        if (m_pCache->pbExcLarge && igrpprl==m_pCache->idExcLarge)
                {
                *pcb = (USHORT)m_pCache->cbExcLarge;
                return m_pCache->pbExcLarge;
                }
        return NULL;
        }


////////////////////////////////////////////////////////////////////////////////
// Allocate a new grpprl in the cache.  If there is not enough space,
// remove least recently used items until there is enough.
//
BYTE *CWord6Stream::GrpprlCacheAllocNew (int cb, short igrpprl)
        {
        AssertCanThrow();

        if (!m_pCache)
                {
                ThrowMemoryException();
                }

        // Doesn't fit into the cache - use the exceptionally large pointer.
        if (cb > CacheGrpprl::CACHE_SIZE)
                {
                delete m_pCache->pbExcLarge;
                m_pCache->pbExcLarge = new BYTE [cb];
                if (m_pCache->pbExcLarge == NULL)
                        ThrowMemoryException();

                m_pCache->cbExcLarge = cb;
                m_pCache->idExcLarge = igrpprl;
                return m_pCache->pbExcLarge;
                }

        // While there is not enough space.
        while (cb > CacheGrpprl::CACHE_SIZE-m_pCache->ibFirst[m_pCache->cItems] ||
                m_pCache->cItems >= CacheGrpprl::CACHE_MAX)
                {
                // Find the least recently accessed items.
                int imin = 0;
                for (int i=1;  i<m_pCache->cItems;  i++)
                        if (m_pCache->rglLastAccTmItem[i]<m_pCache->rglLastAccTmItem[imin])
                                imin = i;

                // Remove it.
                memmove (m_pCache->rgb+m_pCache->ibFirst[imin],
                        m_pCache->rgb+m_pCache->ibFirst[imin+1],
                        m_pCache->ibFirst[m_pCache->cItems]-m_pCache->ibFirst[imin+1]);
                int cbRemoved = m_pCache->ibFirst[imin+1] - m_pCache->ibFirst[imin];
                for (i=imin;  i<m_pCache->cItems;  i++)
                        m_pCache->ibFirst[i] = m_pCache->ibFirst[i+1]-cbRemoved;
                memmove (m_pCache->rgIdItem+imin, m_pCache->rgIdItem+imin+1,
                        (m_pCache->cItems-imin-1)*sizeof(*m_pCache->rgIdItem));
                memmove (m_pCache->rglLastAccTmItem+imin,
                        m_pCache->rglLastAccTmItem+imin+1,
                        (m_pCache->cItems-imin-1)*sizeof(*m_pCache->rglLastAccTmItem));
                m_pCache->cItems --;
                }

        // Allocate space for a new item.
        m_pCache->ibFirst[m_pCache->cItems+1] =
                m_pCache->ibFirst[m_pCache->cItems] + cb;
        m_pCache->rgIdItem[m_pCache->cItems] = igrpprl;
        m_pCache->rglLastAccTmItem[m_pCache->cItems] = m_pCache->lLastAccTmCache;
        m_pCache->cItems ++;
        return m_pCache->rgb + m_pCache->ibFirst[m_pCache->cItems-1];
        }


// This function should only be used when it is considered an error to not
// read everything we intended to read
inline HRESULT CWord6Stream::Read(VOID HUGEP* pv, ULONG cbToRead)
        {
        NoThrow();
    HRESULT hr = S_OK;
    ULONG cbRead;

        hr = m_pStm->Read(pv, cbToRead, &cbRead);
        if ((cbRead != cbToRead) && SUCCEEDED(hr))
                hr = ResultFromScode(E_UNEXPECTED);

        return hr;
        }

inline HRESULT CWord6Stream::Seek(ULONG cbSeek, STREAM_SEEK origin)
        {
        NoThrow();
        LARGE_INTEGER li;

        li.HighPart = 0;
        li.LowPart = cbSeek;
        return m_pStm->Seek(li, origin, 0);
        }

// This function should only be used when it is considered an error to not
// read everything we intended to read
HRESULT CWord6Stream::SeekAndRead(ULONG cbSeek, STREAM_SEEK origin,
                                                                                VOID HUGEP* pv, ULONG cbToRead)
        {
        HRESULT hr = S_OK;

        hr = Seek(cbSeek, origin);
        if (FAILED(hr))
                return hr;

        hr = Read(pv, cbToRead);
        return hr;
        }

ULONG CWord6Stream::CompactBuffer(char ** const ppbCur, char ** const ppBuf, WCHAR ** ppUnicode)
{
        NoThrow();
        if (m_fT3J)
        {
                int cchWideChar;
                BOOL bFE = TRUE;
                BYTE * pbSrc = (BYTE *)*ppBuf;
                
                BYTE * pbDest = pbSrc;
                BYTE * pbLRStart = pbSrc;
        
                for (; (pbSrc) < (BYTE *)*ppbCur; )
                {
                        *((unsigned short UNALIGNED *)pbSrc) = SwapWord(*((unsigned short UNALIGNED *)pbSrc));
#ifndef MAC
                        // We really do need to Swap, but the above line does nothing.
                        // Do it by hand.
                        BYTE bSave = pbSrc[0];
                        pbSrc[0] = pbSrc[1];
                        pbSrc[1] = bSave;
#endif // !MAC
                        
                        
                        switch (*pbSrc)
                        {
                        case 0x00:
                                // non-FE text
                                if(bFE)
                                {
                                        // first non-FE character after FE run
                                        // flash FE text
                                        if(pbDest - pbLRStart)
                                        {
                                                // convert to Unicode
                                                cchWideChar = MultiByteToWideChar (
                                                        CodePageFromLid(m_nFELid), 
                                                        0,              
                                                        (char*)pbLRStart,
                                                        (int) ( pbDest - pbLRStart),
                                                        (WCHAR *)*ppUnicode,
                                                        (int) ( pbDest - pbLRStart) );
                                                *ppUnicode += cchWideChar;
                                        }
                                        
                                        bFE = FALSE;
                                        pbLRStart = pbDest;     
                                }
                                        
                                pbSrc++;
                                *pbDest = *pbSrc;
                                pbDest++;
                                pbSrc++;
                                break;

                        case 0x20:
                                // Half-width katakana?
                                if(!bFE)
                                {
                                        // first FE character after non-FE run
                                        // flash non-FE text
                                        if(pbDest - pbLRStart)
                                        {
                                                // convert to Unicode
                                                cchWideChar = MultiByteToWideChar (
                                                        CodePageFromLid(m_currentLid), 
                                                        0,              
                                                        (char*)pbLRStart,
                                                        (int) ( pbDest - pbLRStart),
                                                        (WCHAR *)*ppUnicode,
                                                        (int) ( pbDest - pbLRStart) );
                                                *ppUnicode += cchWideChar;
                                        }
                                        
                                        bFE = TRUE;
                                        pbLRStart = pbDest;     
                                }
                                        
                                pbSrc++;
                                *pbDest = *pbSrc;
                                pbDest++;
                                pbSrc++;

                                break;

                        case 0x10:
                                // something really bad happened here.... but we'll keep going
                                pbSrc += 2;
                                break;

                        default:
                                if (*pbSrc >= 0x80)     // keep the whole thing
                                {
                                        if(!bFE)
                                        {
                                                // first FE char after non-FE text
                                                // flash non-FE text
                                                if(pbDest - pbLRStart)
                                                {
                                                        // convert to Unicode
                                                        cchWideChar = MultiByteToWideChar (
                                                                CodePageFromLid(m_currentLid), 
                                                                0,              
                                                                (char*)pbLRStart,
                                                                (int) ( pbDest - pbLRStart),
                                                                (WCHAR *)*ppUnicode,
                                                                (int) ( pbDest - pbLRStart) );

                                                        *ppUnicode += cchWideChar;
                                                }

                                                bFE = TRUE;
                                                pbLRStart = pbDest;     
                                        }

                                        if (pbSrc != pbDest)
                                                *((short UNALIGNED *)pbDest) = *((short UNALIGNED *)pbSrc);
                                        pbDest += 2;
                                }
                                // else skip the character by doing nothing with pbDest

                                pbSrc += 2;
                                break;
                        }
                }
                
#if(1)
                // flash what is left 
                if(bFE)
                {
                        // convert to Unicode
                        cchWideChar = MultiByteToWideChar (
                                CodePageFromLid(m_nFELid), 
                                0,              
                                (char*)pbLRStart,
                                (int) ( pbDest - pbLRStart),
                                (WCHAR *)*ppUnicode,
                                (int) ( pbDest - pbLRStart) );

                }
                else
                {
                        // convert to Unicode
                        cchWideChar = MultiByteToWideChar (
                                CodePageFromLid(m_currentLid), 
                                0,              
                                (char*)pbLRStart,
                                (int) ( pbDest - pbLRStart),
                                (WCHAR *)*ppUnicode,
                                (int) ( pbDest - pbLRStart) );
                }
                
                *ppUnicode += cchWideChar;
#endif
                
                return (ULONG)((char *)pbDest - *ppBuf);
        }

        return (ULONG)(*ppbCur - *ppBuf);
}

HRESULT CWord6Stream::GetChunk(STAT_CHUNK * pStat)
{
    HRESULT hr = S_OK;
#if(0)
    pStat->locale = GetDocLanguage();
    return S_OK;
#else
    LCID lid = 0;
    ULONG cbToRead = 0;
    FC fcCur;           // the current position in the stream
    ULONG ccpLeft;      // count of characters left to read from stream

        if (m_fComplex)
        {
                if (m_ipcd == m_cpcd)   // at the end of the piece table
                        return FILTER_E_NO_MORE_TEXT;
        }
        else
        {
                fcCur = m_fcMin + m_ccpRead;
                ccpLeft = m_ccpText - m_ccpRead;
                if (m_fT3J ? ccpLeft < 2 : ccpLeft == 0) // read all of the text in the stream
                        return FILTER_E_NO_MORE_TEXT;
    }

        FC fcCurrent;
        if (m_fComplex)
                fcCurrent = m_rgpcd[m_ipcd].fc + (m_ccpRead - m_rgcp[m_ipcd]);
        else
                fcCurrent = m_fcMin + m_ccpRead;

   if(!m_ccpRead && !m_currentLid)
   {
       // first chunk, just get LCID and quit
       CheckLangID(fcCurrent, &cbToRead, &lid);
           if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
                    return hr;

       m_currentLid = lid;
       pStat->locale = (!m_bScanForFE && m_fT3J) ? m_nFELid : m_currentLid;
       return S_OK;
   }
   else
   {
       if(m_fT3J) pStat->breakType = CHUNK_NO_BREAK;

       CheckLangID(fcCurrent, &cbToRead, &lid);
           if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
                    return hr;

       if(lid == m_currentLid)
       {
           // there was no call to GetText() between GetChunk(), 
           // so we need to seek text stream manualy to the next language run
           // Add some fudge here since ReadContent may have off by one bugs.
           // So use 2048 instead of 1024

           char chbuff[2048];
           ULONG cb;
           HRESULT res;
           do {
               res = ReadContent (chbuff, 512, &cb);
           } while(res == S_OK);
           if(res == FILTER_E_NO_MORE_TEXT)
           {
                   if (m_fComplex)
               {
                    if (m_ipcd == m_cpcd)       // at the end of the piece table
                                    return FILTER_E_NO_MORE_TEXT;
                            fcCurrent = m_rgpcd[m_ipcd].fc + (m_ccpRead - m_rgcp[m_ipcd]);
               }
                   else
               {
                            if ((m_ccpText - m_ccpRead) <= (m_fT3J ? 1u : 0u))   // read all of the text in the stream
                                    return FILTER_E_NO_MORE_TEXT;
                            fcCurrent = m_fcMin + m_ccpRead;
               }
               CheckLangID(fcCurrent, &cbToRead, &lid);
                   if (FAILED(hr) && hr != FILTER_E_NO_MORE_TEXT)
                            return hr;
 
               m_currentLid = lid;
                           pStat->locale = (!m_bScanForFE && m_fT3J) ? m_nFELid : m_currentLid;
               return S_OK;
           }
           else
               return res;

       }
       else
       {
           m_currentLid = lid;
           pStat->locale = (!m_bScanForFE && m_fT3J) ? m_nFELid : m_currentLid;
       }
       return S_OK;
   }
#endif
}

LCID CWord6Stream::GetDocLanguage(void)
{
    if(m_lid < 999)
        return m_lid;
    else
        return MAKELCID(m_lid, SORT_DEFAULT);
}

HRESULT CWord6Stream::CreateLidsTable(void)
        {
        HRESULT hr = S_OK;
    FC fcCurrent;

    if (m_fComplex)
                fcCurrent = m_rgpcd[m_ipcd].fc + (m_ccpRead - m_rgcp[m_ipcd]);
        else
                fcCurrent = m_fcMin + m_ccpRead;

    // init lid table
    m_currentLid = 0;
    m_nLangRunSize = 0;
    m_pLangRuns = new CLidRun(0, 0x7fffffff, m_lid, NULL, NULL);
    if(!m_pLangRuns)
        return E_OUTOFMEMORY;
                
    hr = ProcessParagraphBinTable();
        if (FAILED(hr))
                return hr;

    hr = ProcessCharacterBinTable();
        if (FAILED(hr))
                return hr;

    //hr = ProcessPieceTable();
        if (FAILED(hr))
                return hr;

    m_pLangRuns->Reduce(this);

        m_bScanForFE = FALSE;
        //ScanForFarEast();

        // Seek back to the current text
        hr = Seek(fcCurrent, STREAM_SEEK_SET);
    return hr;
}

HRESULT CWord6Stream::CheckLangID(FC fcCur, ULONG * pcbToRead, LCID * plid)
{
    
    LCID lid = GetDocLanguage();
    FC fcLangRunEnd = 0xffffffff;

    CLidRun * pRun = m_pLangRuns;
    do
    {
        if(fcCur >= pRun->m_fcStart && fcCur < pRun->m_fcEnd)
        {
            lid = MAKELCID(pRun->m_lid, SORT_DEFAULT);
            fcLangRunEnd = pRun->m_fcEnd;
            break;
        }
        else
        {
            if(pRun->m_pNext)
                pRun = pRun->m_pNext;
            else
            {
                return E_FAIL;
            }
        }
    }while(pRun->m_pNext);

        *plid = lid;

#if(1)
    if(m_fT3J)
        {
        *pcbToRead = min(*pcbToRead, fcLangRunEnd - fcCur);
                m_currentLid = lid;
        }
        else if(lid != m_currentLid)
#else
        if(lid != m_currentLid)
#endif
    {
        // we need to start new chunk
        *pcbToRead = 0;
        return FILTER_E_NO_MORE_TEXT;
    }
    else
    {
        *pcbToRead = min(*pcbToRead, fcLangRunEnd - fcCur);
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::ProcessParagraphBinTable(void)
{
    // reset all of the appropriate variables
    
    HRESULT hr = S_OK;
    short ifcfkpPap = 0;
    long ibtePap = -1;  // this gets incremented before it is used.
    short crunPap = 0;

        while (ibtePap < m_cbtePap)
        {
                if (ifcfkpPap == crunPap) // go to next FKP in bin table
                {
                        ibtePap++;
                        if (ibtePap == m_cbtePap)
            {
                                // end of the paragraph bin table
                break;
            }

                        // seek to and read current FKP
                        hr = SeekAndRead(m_rgbtePap[ibtePap]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                                                         m_fkpPap, FKP_PAGE_SIZE);
                        if (FAILED(hr))
                                return hr;

                        ifcfkpPap = 0;
                        crunPap = m_fkpPap[FKP_PAGE_SIZE-1];

                }

                FC * rgfcfkpPap = (FC *)m_fkpPap;
                for (;  ifcfkpPap<crunPap;  ifcfkpPap++)
                {
                        BYTE bpapxOffset = *(m_fkpPap + (crunPap+1)*sizeof(FC) + (ifcfkpPap * BX_SIZE));
                        if (bpapxOffset == 0)
                                continue;       // there is nothing in the PAPX.

                        BYTE *papx = m_fkpPap + bpapxOffset*sizeof(WORD);
                        // we are inside FKP so first byte contain count of words
            BYTE cwpapx = papx[0];
            BYTE istd;          // index to style descriptor

            istd = papx[1];     //possible bug ( short?)

            WORD lidStyle = 0, lidSprm = 0;
            FC  fcStart, fcEnd;
            fcStart = rgfcfkpPap[ifcfkpPap];
            fcEnd = rgfcfkpPap[ifcfkpPap + 1];
                        
            // check for possible lid in sprm
            lidSprm = ScanGrpprl(cwpapx * 2 - 1, papx + 2);
            if(!lidSprm)
            {
                // check for possible lid in the syle descriptor
                GetLidFromSyle(istd, &lidSprm);
            }

            if(lidSprm)
            {
                                hr = m_pLangRuns->Add(lidSprm, fcStart, fcEnd);
                            if (FAILED(hr))
                                    return hr;
            }
                }
        }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::ProcessCharacterBinTable(void)
{
    HRESULT hr = S_OK;

    m_irgfcfkp = 0;
    m_ibte = -1;        // this gets incremented before it is used.
    WORD crun = 0;

    while (m_ibte < m_cbte)
        {
                if (m_irgfcfkp == crun)
                {
                        m_ibte++;
                        if (m_ibte == m_cbte)
            {
                                // end of the table
                break;
            }

                        // seek to and read current FKP
                        hr = SeekAndRead(m_rgbte[m_ibte]*FKP_PAGE_SIZE, STREAM_SEEK_SET,
                                                         m_fkp, FKP_PAGE_SIZE);
                        if (FAILED(hr))
                                return hr;

                m_irgfcfkp = 0;
                        crun = m_fkp[FKP_PAGE_SIZE-1];

                }

                FC * rgfcfkp = (FC *)m_fkp;
                for(;  m_irgfcfkp<crun;  m_irgfcfkp++)
                {
                        BYTE bchpxOffset = *(m_fkp + (crun+1)*sizeof(FC) + m_irgfcfkp);
                        if (bchpxOffset == 0)
                                continue;       // there is nothing in the CHPX.

                        BYTE * chpx = m_fkp + bchpxOffset*sizeof(WORD);
                        BYTE cbchpx = chpx[0];

                        for (BYTE i = 1; i < cbchpx - 1; i++)
                        {
                WORD lid;
                FC  fcStart, fcEnd;

                if (chpx[i] == sprmCLid)
                                {
                    lid = *(WORD UNALIGNED *)(chpx+i+1);
                    fcStart = rgfcfkp[m_irgfcfkp];
                    fcEnd = rgfcfkp[m_irgfcfkp + 1];
                                hr = m_pLangRuns->Add(lid, fcStart, fcEnd);
                                if (FAILED(hr))
                                        return hr;
                                }
                        }
                }
        }

        return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

WORD CWord6Stream::ScanGrpprl(WORD cbgrpprl, BYTE * pgrpprl)
{
    WORD lidSprm = 0;

        for (WORD i = 0; i < cbgrpprl; i++)
        {
        if (pgrpprl[i] == sprmCLid)
                {
            lidSprm = *(WORD UNALIGNED *)(pgrpprl+i+1);
            break;
                }
        }
    return lidSprm;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::GetLidFromSyle(short istd, WORD * pLID)
{
    WORD cbStshi = *((WORD*)m_pSTSH);
    m_pSTSHI = (STSHI*)(m_pSTSH + 2);
        BYTE * pLim = m_pSTSH + m_lcbStshf;
    
    if(istd >= m_pSTSHI->cstd)
    {
LWrong:
                // something wrong, just return default doc lid
        *pLID = m_lid;
        return S_OK;
    }

    // go to the istd
    short stdInd = 0;
    WORD UNALIGNED * pcbStd = ((WORD*)(m_pSTSH + sizeof(WORD) + cbStshi));

    while(stdInd++ < istd)
    {
        pcbStd = ((WORD UNALIGNED *)((BYTE*)pcbStd + sizeof(WORD) + *pcbStd));
    }
    
    STD UNALIGNED * pStd = (STD*)(pcbStd + 1);

    // go to UPX and check if it has lid
    BYTE * pUPX = &pStd->xstzName[0] +                  // start of style name
        sizeof(CHAR) * (2 + pStd->xstzName[0]) +       // style name lenght
        (sizeof(CHAR) * pStd->xstzName[0])%2;          // should be on even-byte boundary 

    WORD LidPara = 0, LidChar = 0;
    WORD cbpapx, cbchpx;
    BYTE * papx,  * pchpx; 

    if(pStd->cupx >= 2)
    {
        // paragraph style
        cbpapx = *((WORD UNALIGNED *)pUPX);
        papx = pUPX + 2;
                if (papx + cbpapx > pLim)
                        goto LWrong;
        LidPara = ScanGrpprl(cbpapx - 2, papx + 2); // - + 2 for istd in papx
        
        cbchpx = *(papx + cbpapx + cbpapx%2);
        pchpx = papx + cbpapx + cbpapx%2 + 2;
                if (pchpx + cbchpx > pLim)
                        goto LWrong;
        LidChar = ScanGrpprl(cbchpx, pchpx);

    }
    else
    {
        // character style
        cbchpx = *((WORD UNALIGNED *)pUPX);
        pchpx = pUPX + 2;
                if (pchpx + cbchpx > pLim)
                        goto LWrong;
        LidChar = ScanGrpprl(cbchpx, pchpx);
    }

    if(LidChar || LidPara)
    {
        // no need to recurse base styles
        if(LidChar)
        {
            *pLID =  LidChar;
            return S_OK;
        }
        else
        {
            *pLID =  LidPara;
            return S_OK;
        }
    }
    else if(pStd->istdBase != istdNil)
    {
        GetLidFromSyle(pStd->istdBase, pLID);
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////

void DeleteAll6(CLidRun * pElem)
{
   if(pElem)
   {
      CLidRun * pNext = pElem->m_pNext;

      while(pNext) 
      {
         CLidRun * pNextNext = pNext->m_pNext;
         delete pNext;
         pNext = pNextNext;
      }

      delete pElem;
   }
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::ScanForFarEast(void)
{
        // Word 6 contains language information only for non-FE language.
        // We need to scan the text in order to separate non-FE from FE text
        
        HRESULT hr = S_OK;
        int nRunSize;
        FC fcStart;

        if (m_fComplex)
        {
                for(ULONG i = 0; i < m_cpcd; i++)
                {
                        fcStart = m_rgpcd[m_ipcd].fc;
                        nRunSize = m_rgcp[m_ipcd+1];
                        ScanPiece(fcStart, nRunSize);
                        if (FAILED(hr))
                        return hr;
                }

        }
        else
        {
                fcStart = m_fcMin;
                nRunSize = m_ccpText;
                ScanPiece(fcStart, nRunSize);
                if (FAILED(hr))
                return hr;
        }
        
        m_bScanForFE = TRUE;
        return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::ScanPiece(int fcStart, int nPieceSize)
{
        char pBuff[TEMP_BUFFER_SIZE];
        HRESULT hr = STG_E_INVALIDFUNCTION;
        int nReadCnt;

        while(nReadCnt = min(nPieceSize, TEMP_BUFFER_SIZE))
        {
                hr = SeekAndRead(fcStart, STREAM_SEEK_SET, pBuff, nReadCnt);
                if (FAILED(hr))
                return hr;

                hr = ProcessBuffer(pBuff, fcStart, nReadCnt);
                if (FAILED(hr))
                return hr;

                fcStart += nReadCnt;
                nPieceSize -= nReadCnt; 
                if(nPieceSize < 0) nPieceSize = 0;
        }
        return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

HRESULT CWord6Stream::ProcessBuffer(char * pBuf, int fcStart, int nReadCnt)
{
        NoThrow();
        HRESULT hr = S_OK;
        BOOL bFE = FALSE;
        int i, fcSubRunStart;

        if (m_fT3J)
                {
                BYTE * pbSrc = (BYTE *)pBuf;
                for (i = 0; i < nReadCnt; )
                {
                        switch (pbSrc[i+1])
                        {
                                case 0x00:
                                        if(pbSrc[i] == 0x0d || pbSrc[i] == 0x20)
                                        {
                                                //i += 2;
                                        }
                                        else
                                        {
                                                if(bFE)
                                                {
                                                        // end of FE subrun
                                                        bFE = FALSE;
                                                hr = m_pLangRuns->Add((WORD)m_nFELid, fcSubRunStart, fcStart + i);
                                                        if (FAILED(hr))
                                                                return hr;
                                                }
                                        }
                                        i += 2;
                                        break;

                                case 0x10:
                                case 0x20:
                                if(bFE)
                                {
                                        // end of FE subrun
                                        bFE = FALSE;
                                hr = m_pLangRuns->Add((WORD)m_nFELid, fcSubRunStart, fcStart + i);
                                if (FAILED(hr))
                                        return hr;
                                }
                                i += 2;
                                break;

                        default:
                                if (pbSrc[i+1] >= 0x80)
                                {
                                        // this is supposed to be FE text
                                        if(!bFE)
                                        {
                                                bFE = TRUE;
                                                fcSubRunStart = fcStart + i;
                                        }
                                }

                                i += 2;
                                break;
                                }
                        }
                
                        if(bFE && (fcSubRunStart != fcStart + i))
                        {
                        hr = m_pLangRuns->Add((WORD)m_nFELid, fcSubRunStart, fcStart + i);
                            if (FAILED(hr))
                                    return hr;
                        }
                }
        return hr;
}

/////////////////////////////////////////////////////////////////////////////////////

void CWord6Stream::GetLidFromMagicNumber(unsigned short magicNumber)
{
        if(magicNumber == (unsigned short)T3J_MAGIC_NUMBER)
        {
                m_nFELid = 0x411;
        }
        else if(magicNumber == (unsigned short)KOR_W6_MAGIC_NUMBER)
        {
                m_nFELid = 0x412;
        }
        else if(magicNumber == (unsigned short)KOR_W95_MAGIC_NUMBER)
        {
                m_nFELid = 0x412;
        }
        else if(magicNumber == (unsigned short)CHT_W6_MAGIC_NUMBER)
        {
                m_nFELid = 0x404;
        }
        else if(magicNumber == (unsigned short)CHS_W6_MAGIC_NUMBER)
        {
                m_nFELid = 0x804;
        }
        else
                m_nFELid = m_lid;
}

#endif // !VIEWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmitext.c ===
/*
** File: EXTEXT.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmitext.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "extext.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

#define POOL_SIZE 4096

typedef struct TextPool {
   unsigned int iNext;   
   struct TextPool *pNext;
   char data[POOL_SIZE];
} TextPool;

typedef TextPool *TPP;

#define PoolAllocated 0x80
#define UseCountMask  0x7F
#define MaxUseCount   0x7F

typedef struct TextNode {
   struct TextNode *pNext;
   unsigned short cbText;
   unsigned char info;
   char s[1];
} TextNode;

typedef TextNode *TNP;

#define MAXHASH (11 * 7)

typedef struct {
   TPP  pPoolList;
   TPP  pCurrentPool;
   TNP  hashTable[MAXHASH];
} TextStore;

typedef TextStore *TSP;

static char NullString[1] = {EOS};

/* IMPLEMENTATION */

public TextStorage TextStorageCreate (void * pGlobals)
{
   TSP pStorage;

   if ((pStorage = MemAllocate(pGlobals, sizeof(TextStore))) == NULL)
      return (TextStorageNull);

   return ((TextStorage)pStorage);
}

public void TextStorageDestroy (void * pGlobals, TextStorage hStorage)
{
   TSP  pStorage = (TSP)hStorage;
   int  iHash;
   TNP  pNode, pNext;
   TPP  pPool, pNextPool;

   if (pStorage == NULL)
      return;

   for (iHash = 0; iHash < MAXHASH; iHash++) {
      pNode = pStorage->hashTable[iHash];
      while (pNode != NULL) {
         pNext = pNode->pNext;
         if ((pNode->info & PoolAllocated) == 0)
            MemFree (pGlobals, pNode);
         pNode = pNext;
      }
   }

   pPool = pStorage->pPoolList;
   while (pPool != NULL) {
      pNextPool = pPool->pNext;
      MemFree (pGlobals, pPool);
      pPool = pNextPool;
   }

   MemFree (pGlobals, pStorage);
}

public char *TextStorageGet (TextStorage hStorage, TEXT t)
{
   TNP pNode = (TNP)t;

   if ((t == NULLTEXT) || (t == TEXT_ERROR))
      return (NullString);
   else
      return (pNode->s);
}

int AlignBlock( int x )
{
    return ( x + ( 8 - 1 ) ) & ~( 8 - 1 );
}

private TNP AllocateTextNode (void * pGlobals, TSP pStorage, unsigned int cbText)
{
   unsigned int cbNeeded;
   TNP pNewNode;
   TPP pPool, pNewPool;

   cbNeeded = cbText + sizeof(TextNode);
   cbNeeded = AlignBlock(cbNeeded);

   if (cbNeeded > POOL_SIZE) {
      if ((pNewNode = MemAllocate(pGlobals, cbNeeded)) == NULL)
         return (NULL);
      return (pNewNode);
   }

   if ((pPool = pStorage->pCurrentPool) != NULL) {
      if ((POOL_SIZE - pPool->iNext) < cbNeeded) {
         //
         // At this point we could shrink the ppol node to just what is used.
         // That is:
         //   sizeof(TextPool) - POOL_SIZE + pPool->iNext
         //
         // But we would have to guarentee that the reallocation does not
         // move the block in memory as all the allocated TEXTs are just
         // pointers into this block
         //
      }
      else {
         pNewNode = (TNP)(pPool->data + pPool->iNext);
         pPool->iNext += cbNeeded;
         pNewNode->info |= PoolAllocated;
         return (pNewNode);
      }
   }

   if ((pNewPool = MemAllocate(pGlobals, sizeof(TextPool))) == NULL)
      return (NULL);

   pNewPool->pNext = pStorage->pPoolList;
   pStorage->pPoolList = pNewPool;
   pStorage->pCurrentPool = pNewPool;

   pNewNode = (TNP)(pNewPool->data);
   pNewPool->iNext += cbNeeded;
   pNewNode->info |= PoolAllocated;

   return (pNewNode);
}

private unsigned int Hash (char *pString, unsigned int cbString)
{
   unsigned int i;
   unsigned int sum = 0;

   for (i = 0; i < cbString; i++)
      sum += *pString++;

   return (sum % MAXHASH);
}

/* TextPut -- Add a string to the text pool */
public TEXT TextStoragePut (void * pGlobals, TextStorage hStorage, char *pString, unsigned int cbString)
{
   TSP  pStorage = (TSP)hStorage;
   TNP  pCurrent, pPrevious, pNewNode;
   unsigned int iHash;

   /*
   ** Attempt to find the string in the text pool.  If it exists return a handle to it
   */
   if ((pString == NULL) || (cbString == 0))
      return (NULLSTR);

   iHash = Hash(pString, cbString);

   pCurrent = pStorage->hashTable[iHash];
   pPrevious = NULL;

   /*
   ** Since the text pool nodes are stored in string length increasing
   ** we only have to search those nodes up to the point where
   ** the strings get too long.
   */
   while (pCurrent != NULL) {
      if (pCurrent->cbText > cbString)
         break;

      if ((pCurrent->cbText == cbString) && (memcmp(pCurrent->s, pString, cbString) == 0)) {
         pCurrent->info = min((pCurrent->info & UseCountMask) + 1, MaxUseCount) | (pCurrent->info & ~UseCountMask);
         return ((TEXT)pCurrent);
      }

      pPrevious = pCurrent;
      pCurrent = pCurrent->pNext;
   }

   /*
   ** Either the whole list was searched or the strings got too long
   ** so we stopped early.  In either case the string must now be
   ** added to the text pool.
   */
   if ((pNewNode = AllocateTextNode(pGlobals, pStorage, cbString)) == NULL)
      return (TEXT_ERROR);

   pNewNode->pNext = pCurrent;
   pNewNode->cbText = (unsigned short) cbString;
   memcpy (pNewNode->s, pString, cbString);

   if (pPrevious != NULL)
      pPrevious->pNext = pNewNode;
   else
      pStorage->hashTable[iHash] = pNewNode;

   return ((TEXT)pNewNode);
}

public void TextStorageDelete (void * pGlobals, TextStorage hStorage, TEXT t)
{
   TSP  pStorage = (TSP)hStorage;
   TNP  pNode = (TNP)t;
   TNP  pCurrent, pPrevious;
   unsigned char useCount;
   unsigned int  iHash;

   if ((t == NULLTEXT) || (t == TEXT_ERROR))
      return;

   if ((useCount = (pNode->info & UseCountMask)) == MaxUseCount)
      return;

   if (useCount > 0) {
      pNode->info = (pNode->info & ~UseCountMask) | (useCount - 1);
      return;
   }

   iHash = Hash(pNode->s, pNode->cbText);

   pCurrent = pStorage->hashTable[iHash];
   pPrevious = NULL;

   while (pCurrent != NULL) {
      if (pCurrent == pNode)
         break;
      pPrevious = pCurrent;
      pCurrent = pCurrent->pNext;
   }

   ASSERTION (pCurrent != NULL);

   if(pCurrent)
   {
       if (pPrevious == NULL)
          pStorage->hashTable[iHash] = pCurrent->pNext;
       else
          pPrevious->pNext = pCurrent->pNext;

       if ((pCurrent->info & PoolAllocated) == 0)
          MemFree (pGlobals, pCurrent);
  }
}

public void TextStorageIncUse (TextStorage hStorage, TEXT t)
{
   TSP  pStorage = (TSP)hStorage;
   TNP  pNode = (TNP)t;
   unsigned char useCount;

   if ((t == NULLTEXT) || (t == TEXT_ERROR))
      return;

   useCount = (pNode->info & UseCountMask);
   pNode->info = (pNode->info & ~UseCountMask) | (useCount + 1);
}

#endif // !VIEWER

/* end EXTEXT.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiwd6st.hpp ===
#ifndef _WRD6STM_HPP
#define _WRD6STM_HPP

#if !VIEWER

#include "dmfltinc.h"
#include "dmifstrm.hpp"
#include "clidrun.h"

void DeleteAll6(CLidRun * pElem);

class CWord6Stream : public IFilterStream
{
    friend class CLidRun;
public:

	CWord6Stream();
	
	~CWord6Stream();

	ULONG AddRef() { return 1; }

#ifdef MAC
	HRESULT Load(FSSpec *pfss);
#else // WIN
	HRESULT Load(LPTSTR pszFileName);
#endif // MAC

	HRESULT LoadStg(IStorage * pstg);

	HRESULT ReadContent(VOID *pv, ULONG cb,
						ULONG *pcbRead);

	HRESULT GetNextEmbedding(IStorage ** ppstg);

	HRESULT Unload ();

	ULONG Release() { return 0; }

    HRESULT GetChunk(STAT_CHUNK * pStat);


private:

	typedef ULONG FC;
	// BTE is 2 bytes in Word 6/7, and 4 bytes in Word 8.
	typedef USHORT BTE;

    typedef struct _STSHI
    {
      //WORD cbStshi;
      WORD cstd;
      WORD csSTDBaseInFile;
      WORD fStdStylenamesWrite: 1;
      WORD fRes: 15;
      WORD stiMaxWhenSaved;
      WORD istdMaxFixedWhenSaved;
      WORD nVerBuiltInNamesWhenSaved;
      WORD ftsStandartChpStsh;
    } STSHI, FAR * lpSTHI;

    typedef struct _STD
    {
      //WORD cbStd;
      WORD sti         : 12;
      WORD fScrath     : 1;
      WORD fInvalHeight: 1;
      WORD fHasUpe     : 1;
      WORD fMassCopy   : 1;

      WORD sgc         : 4;
      WORD istdBase    : 12;

      WORD cupx        : 4;
      WORD istdNext    : 12;

      WORD bchUpe;

      BYTE xstzName[2];
    } STD;


    int m_nLangRunSize;
    CLidRun * m_pLangRuns;
    LCID m_currentLid;
	LCID m_nFELid;

	long lcFieldSep;							// count of field begins that haven't been matched
												// with field separators.
	long lcFieldEnd;							// count of field begins that haven't been matched

	BOOL m_bScanForFE;	
	
	#pragma pack(1)
	// Simple PRM.
	struct PRM1
		{
		char fComplex:1;
		char sprm:7;
		char val;
		};

	// Complex PRM.
	struct PRM2
		{
		short fComplex:1;
		short igrpprl:15;
		};

	struct PCD
		{
		WORD : 16;
		FC fc;
		PRM1 prm;
		};
	#pragma pack()

	enum FSPEC_STATE
		{
		FSPEC_ALL,
		FSPEC_NONE,
		FSPEC_EITHER
		};

	enum {FKP_PAGE_SIZE = 512};

	HRESULT ReadComplexFileInfo();

	HRESULT ReadNonComplexFileInfo();

	HRESULT ReadBinTable();

	HRESULT FindNextSpecialCharacter (BOOL fFirstChar=fFalse);

	HRESULT ParseGrpPrls();

	HRESULT Read (VOID *pv, ULONG cbToRead);

	HRESULT Seek (ULONG cbSeek, STREAM_SEEK origin);

	HRESULT SeekAndRead (ULONG cbSeek, STREAM_SEEK origin,
						VOID *pv, ULONG cbToRead);

	BYTE *GrpprlCacheGet (short igrpprl, USHORT *pcb);

	BYTE *GrpprlCacheAllocNew (int cb, short igrpprl);

	ULONG	CompactBuffer(char ** const ppbCur, char ** const ppBuf, WCHAR ** ppUnicode);

    LCID GetDocLanguage(void);
    HRESULT CreateLidsTable(void);
    HRESULT CheckLangID(FC fcCur, ULONG * pcbToRead, LCID * plid);
    HRESULT ProcessCharacterBinTable(void);
    HRESULT ProcessParagraphBinTable(void);
    WORD ScanGrpprl(WORD cbgrpprl, BYTE * pgrpprl);
    HRESULT GetLidFromSyle(short istd, WORD * pLID);
	HRESULT ScanForFarEast(void);
	HRESULT ProcessBuffer(char * pBuf, int fcStart, int nReadCnt);
	HRESULT ScanPiece(int fcStart, int nPieceSize);
	void GetLidFromMagicNumber(unsigned short magicNumber);


	IStorage *      m_pStg;		// IStorage for file
	IStream *       m_pStm;		// IStream for current stream
	IStorage * 		m_pstgEmbed;	// IStorage for the current embedding
	IEnumSTATSTG *	m_pestatstg;	// storage enumerator for embeddings
	IStorage *		m_pstgOP;	// IStorage for the object pool (embeddings)
	BOOL            m_fComplex;	// if file is complex format or not.
	FC				m_fcMin;	// if !m_fComplex, then this is the position
								// of the first character in the text section.
								// Otherwise, this is set to zero.
	ULONG           m_ccpText;	// if !m_fComplex, then this is the count of
								// bytes in the text section.  Otherwise,
								// this is set to zero.
	FC				m_fcClx;	// offset of the complex part of the file
	FC *            m_rgcp;		// if m_fComplex, this is the array of
								// character positions from within the
								// document.  Otherwise, this is set to zero.
	PCD *           m_rgpcd;	// if m_fComplex, this is the corresponding
								// piece descriptor array to go with m_rgcp.
								// Otherwise, this is set to zero.
	ULONG           m_cpcd;		// This is the count of piece descriptors in
								// m_rgpcd.  The count of cps in m_rgcp is
								// m_cpcd + 1.
	ULONG           m_ipcd;		// The current index into both m_rgcp and
								// m_rgpcd.
	ULONG           m_ccpRead;	// count of characters read so far
	long            m_cbte;		// count of BTE's in bin table
	long            m_cbtePap;	// count of BTE's in paragraph bin table

    FC *            m_rgfcBinTable;	// only used if m_fComplex.
									// size is m_cbte + 1
	FC *            m_rgfcBinTablePap;	// only used if m_fComplex.
									    // size is m_cbte + 1

    BTE *           m_rgbte;	// The BTE array from the bin table
    BTE *           m_rgbtePap;	// The BTE array from the paragraph bin table

    long            m_ibte;		// The current index into m_rgbte.
	BYTE            m_fkp[FKP_PAGE_SIZE];	// current fkp
    BYTE            m_fkpPap[FKP_PAGE_SIZE];    // current paragraph fkp

    BYTE            m_irgfcfkp;	// index into m_fkp that indicates next special
								// character range.
	FSPEC_STATE     m_fsstate;	// Keeps track of whether the rest of the
								// characters (in the current piece, if a
								// complex file) are special characters, not
								// special characters, or either, depending on
								// the FKP.
	BOOL		m_fT3J;			// set during Load to indicate whether the file
								// is a Japanese (two bytes for each character)
								// file or not.

	BOOL		m_fMac;			// if m_fT3J is TRUE, this flag is true if
								// the document is in the Mac character set.

	BOOL		m_fStruckOut;	// Whether struck-out text or "true" special
								// characters follow our text.

	// LRU Cache for the incoming grpprls.
	struct CacheGrpprl
		{
		enum {CACHE_SIZE = 1024};
		enum {CACHE_MAX = 64};

		BYTE    rgb[CACHE_SIZE];				// The buffer.
		int     ibFirst[CACHE_MAX+1];		// Boundaries between items.
		short   rgIdItem[CACHE_MAX];			// # in the file, used as an ID.
		long    rglLastAccTmItem[CACHE_MAX];     // Last time an item was accessed.
		long    lLastAccTmCache;	// Max over all items.
		int     cItems;				// # items in cache
		BYTE    *pbExcLarge;		// an item larger than the cache.
		long    cbExcLarge;
		short   idExcLarge;

		// Constructor.
		CacheGrpprl () :
			cItems(0), lLastAccTmCache(0L), pbExcLarge(0)
			{ibFirst[0] = 0; }
		} *m_pCache;

	// doc language id
    WORD m_lid;
    BYTE * m_pSTSH;
    STSHI * m_pSTSHI;
	unsigned long m_lcbStshf;
    
    // Buffer used for ANSI->UNICODE conversion.
	char *m_rgchANSIBuffer;
};

#endif // !VIEWER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixll.h ===
/*
** File: EXCELL.H
**
** Copyright (C) Advanced Quonset Technology, 1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  12/08/95  kmh  Created.
*/


/* INCLUDE TESTS */
#ifndef EXCELL_H
#define EXCELL_H

/* DEFINITIONS */

#define cellvalueBLANK     0x0001       // Cell is blank
#define cellvalueNUM       0x0002       // Cell contains a number
#define cellvalueBOOL      0x0004       // Cell contains a boolean
#define cellvalueERR       0x0008       // Cell contains an error id
#define cellvalueTEXT      0x0010       // Cell contains text

#define cellvalueCURR      0x0020       // Number is currency
#define cellvalueDATE      0x0040       // Number is a date
#define cellvalueLONGTEXT  0x0080       // Text is longer 255 bytes

#define cellvalueFORM      0x0100       // Cell contains a formula
#define cellvalueLOCKED    0x0200       // Cell is marked locked

#define cellvalueUSERSET   0x0400       // On write this cell should be written
#define cellvalueDELETE    0x0800       // On write delete this cell

#define cellvalueUSER1     0x1000

#define cellvalueRESERVED1 0x2000
#define cellvalueRESERVED2 0x4000
#define cellvalueRESERVED3 0x8000

#define cellvalueRK        0x2000       // private
#define cellvalueMULREC    0x4000       // private
#define cellvalueSPLIT     0x8000       // private

#define cellErrorNULL      0            // value.error
#define cellErrorDIV0      1
#define cellErrorVALUE     2
#define cellErrorREF       3
#define cellErrorNAME      4
#define cellErrorNUM       5
#define cellErrorNA        6
#define cellErrorERR       7
#define cellErrorMax       7

#ifndef FORMULA_DEFINED
   typedef int FORM;
#endif

typedef union {
   double  IEEEdouble;
   int     boolean;
   int     error;
   TEXT    text;
} CVU;

typedef struct {
   unsigned short flags;
   int      iFmt;
   long     reserved;
   CVU      value;
   FORM     formula;
} CellValue, CV;

typedef struct CellValueList {
   struct CellValueList __far *next;
   byte       iColumn;
   CellValue  data;
} CellValueList;

typedef CellValueList __far *CVLP;

#endif

/* end EXCELL.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlate.h ===
// Uppercase map for Western Europe
	'\x00',	//00->00
	'\x01',	//01->01
	'\x02',	//02->02
	'\x03',	//03->03
	'\x04',	//04->04
	'\x05',	//05->05
	'\x06',	//06->06
	'\x07',	//07->07
	'\x08',	//08->08
	'\x09',	//09->09
	'\x0A',	//0A->0A
	'\x0B',	//0B->0B
	'\x0C',	//0C->0C
	'\x0D',	//0D->0D
	'\x0E',	//0E->0E
	'\x0F',	//0F->0F
	'\x10',	//10->10
	'\x11',	//11->11
	'\x12',	//12->12
	'\x13',	//13->13
	'\x14',	//14->14
	'\x15',	//15->15
	'\x16',	//16->16
	'\x17',	//17->17
	'\x18',	//18->18
	'\x19',	//19->19
	'\x1A',	//1A->1A
	'\x1B',	//1B->1B
	'\x1C',	//1C->1C
	'\x1D',	//1D->1D
	'\x1E',	//1E->1E
	'\x1F',	//1F->1F
	'\x20',	// ->
	'\x21',	//!->!
	'\x22',	//"->"
	'\x23',	//#->#
	'\x24',	//$->$
	'\x25',	//%->%
	'\x26',	//&->&
	'\x27',	//'->'
	'\x28',	//(->(
	'\x29',	//)->)
	'\x2A',	//*->*
	'\x2B',	//+->+
	'\x2C',	//,->,
	'\x2D',	//-->-
	'\x2E',	//.->.
	'\x2F',	///->/
	'\x30',	//0->0
	'\x31',	//1->1
	'\x32',	//2->2
	'\x33',	//3->3
	'\x34',	//4->4
	'\x35',	//5->5
	'\x36',	//6->6
	'\x37',	//7->7
	'\x38',	//8->8
	'\x39',	//9->9
	'\x3A',	//:->:
	'\x3B',	//;->;
	'\x3C',	//<-><
	'\x3D',	//=->=
	'\x3E',	//>->>
	'\x3F',	//?->?
	'\x40',	//@->@
	'\x41',	//A->A
	'\x42',	//B->B
	'\x43',	//C->C
	'\x44',	//D->D
	'\x45',	//E->E
	'\x46',	//F->F
	'\x47',	//G->G
	'\x48',	//H->H
	'\x49',	//I->I
	'\x4A',	//J->J
	'\x4B',	//K->K
	'\x4C',	//L->L
	'\x4D',	//M->M
	'\x4E',	//N->N
	'\x4F',	//O->O
	'\x50',	//P->P
	'\x51',	//Q->Q
	'\x52',	//R->R
	'\x53',	//S->S
	'\x54',	//T->T
	'\x55',	//U->U
	'\x56',	//V->V
	'\x57',	//W->W
	'\x58',	//X->X
	'\x59',	//Y->Y
	'\x5A',	//Z->Z
	'\x5B',	//[->[
	'\x5C',	//\->\ (backspace; don't make it the last char in the line)
	'\x5D',	//]->]
	'\x5E',	//^->^
	'\x5F',	//_->_
	'\x60',	//`->`
	'\x41',	//a->A
	'\x42',	//b->B
	'\x43',	//c->C
	'\x44',	//d->D
	'\x45',	//e->E
	'\x46',	//f->F
	'\x47',	//g->G
	'\x48',	//h->H
	'\x49',	//i->I
	'\x4A',	//j->J
	'\x4B',	//k->K
	'\x4C',	//l->L
	'\x4D',	//m->M
	'\x4E',	//n->N
	'\x4F',	//o->O
	'\x50',	//p->P
	'\x51',	//q->Q
	'\x52',	//r->R
	'\x53',	//s->S
	'\x54',	//t->T
	'\x55',	//u->U
	'\x56',	//v->V
	'\x57',	//w->W
	'\x58',	//x->X
	'\x59',	//y->Y
	'\x5A',	//z->Z
	'\x7B',	//{->{
	'\x7C',	//|->|
	'\x7D',	//}->}
	'\x7E',	//~->~
	'\x7F',	//7F->7F
	'\x80',	//80->80
	'\x81',	//81->81
	'\x82',	//82->82
	'\x83',	//83->83
	'\x84',	//84->84
	'\x85',	//85->85
	'\x86',	//86->86
	'\x87',	//87->87
	'\x88',	//88->88
	'\x89',	//89->89
	'\x8A',	//8A->8A
	'\x8B',	//8B->8B
	'\x8C',	//8C->8C
	'\x8D',	//8D->8D
	'\x8E',	//8E->8E
	'\x8F',	//8F->8F
	'\x90',	//90->90
	'\x91',	//91->91
	'\x92',	//92->92
	'\x93',	//93->93
	'\x94',	//94->94
	'\x95',	//95->95
	'\x96',	//96->96
	'\x97',	//97->97
	'\x98',	//98->98
	'\x99',	//99->99
	'\x8A',	//9A->8A
	'\x9B',	//9B->9B
	'\x8C',	//9C->8C
	'\x9D',	//9D->9D
	'\x9E',	//9E->9E
	'\x9F',	//9F->9F
	'\xA0',	//A0->A0
	'\xA1',	//A1->A1
	'\xA2',	//A2->A2
	'\xA3',	//A3->A3
	'\xA4',	//A4->A4
	'\xA5',	//A5->A5
	'\xA6',	//A6->A6
	'\xA7',	//A7->A7
	'\xA8',	//A8->A8
	'\xA9',	//A9->A9
	'\xAA',	//AA->AA
	'\xAB',	//AB->AB
	'\xAC',	//AC->AC
	'\xAD',	//AD->AD
	'\xAE',	//AE->AE
	'\xAF',	//AF->AF
	'\xB0',	//B0->B0
	'\xB1',	//B1->B1
	'\xB2',	//B2->B2
	'\xB3',	//B3->B3
	'\xB4',	//B4->B4
	'\xB5',	//B5->B5
	'\xB6',	//B6->B6
	'\xB7',	//B7->B7
	'\xB8',	//B8->B8
	'\xB9',	//B9->B9
	'\xBA',	//BA->BA
	'\xBB',	//BB->BB
	'\xBC',	//BC->BC
	'\xBD',	//BD->BD
	'\xBE',	//BE->BE
	'\xBF',	//BF->BF
	'\xC0',	//C0->C0
	'\xC1',	//C1->C1
	'\xC2',	//C2->C2
	'\xC3',	//C3->C3
	'\xC4',	//C4->C4
	'\xC5',	//C5->C5
	'\xC6',	//C6->C6
	'\xC7',	//C7->C7
	'\xC8',	//C8->C8
	'\xC9',	//C9->C9
	'\xCA',	//CA->CA
	'\xCB',	//CB->CB
	'\xCC',	//CC->CC
	'\xCD',	//CD->CD
	'\xCE',	//CE->CE
	'\xCF',	//CF->CF
	'\xD0',	//D0->D0
	'\xD1',	//D1->D1
	'\xD2',	//D2->D2
	'\xD3',	//D3->D3
	'\xD4',	//D4->D4
	'\xD5',	//D5->D5
	'\xD6',	//D6->D6
	'\xD7',	//D7->D7
	'\xD8',	//D8->D8
	'\xD9',	//D9->D9
	'\xDA',	//DA->DA
	'\xDB',	//DB->DB
	'\xDC',	//DC->DC
	'\xDD',	//DD->DD
	'\xDE',	//DE->DE
	'\xDF',	//DF->DF
	'\xC0',	//E0->C0
	'\xC1',	//E1->C1
	'\xC2',	//E2->C2
	'\xC3',	//E3->C3
	'\xC4',	//E4->C4
	'\xC5',	//E5->C5
	'\xC6',	//E6->C6
	'\xC7',	//E7->C7
	'\xC8',	//E8->C8
	'\xC9',	//E9->C9
	'\xCA',	//EA->CA
	'\xCB',	//EB->CB
	'\xCC',	//EC->CC
	'\xCD',	//ED->CD
	'\xCE',	//EE->CE
	'\xCF',	//EF->CF
	'\xD0',	//F0->D0
	'\xD1',	//F1->D1
	'\xD2',	//F2->D2
	'\xD3',	//F3->D3
	'\xD4',	//F4->D4
	'\xD5',	//F5->D5
	'\xD6',	//F6->D6
	'\xF7',	//F7->F7
	'\xD8',	//F8->D8
	'\xD9',	//F9->D9
	'\xDA',	//FA->DA
	'\xDB',	//FB->DB
	'\xDC',	//FC->DC
	'\xDD',	//FD->DD
	'\xDE',	//FE->DE
	'\x9F'	//FF->9F
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixfmcp.c ===
/*
** File: EXFMTCP.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  01/01/94  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <stdlib.h>
#include <string.h>

#if !defined(FILTER) || defined(FILTER_LIB)
   #if defined(ALPHA) || defined(PPCNT) || defined(MIPS)
   #define _CTYPE_DISABLE_MACROS
   #endif

	#include <ctype.h>
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmiexfmt.h"

	#ifndef FILTER_LIB
	#undef isalpha
	#define isalpha(x)	((x>='a' && x<='z') && !(x>='A' && x<='Z'))
	#endif

#else
   #include "qstd.h"
   #include "winutil.h"
   #include "exformat.h"
#endif

#ifdef EXCEL
   #ifdef FILTER
      #include "dmixlcfg.h"
   #else
      #include "excelcfg.h"
   #endif
#endif


#ifdef LOTUS
   #include "lotuscfg.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

#ifdef UNUSED

static const char __far * const CurrencyPosFormatPre[] =
       {"\"$\"", "", "\"$\" ", ""};
static const char __far * const CurrencyPosFormatPost[] =
       {"", "\"$\"", "", " \"$\""};

static const char __far * const CurrencyNegFormatPre[] =
       {"(\"$\"", "-\"$\"", "\"$\"-", "\"$\"", "(",  "-", "", "",
        "-", "-\"$\" ", "", "\"$\" ", "\"$\" -", "", "(\"$\" ", "("};

static const char __far * const CurrencyNegFormatPost[] =
       {")",  "", "", "-", "\"$\")", "\"$\"", "-\"$\"", "\"$\"-", " \"$\"",
        "", " \"$\"-", "-", "", "- \"$\"", ")", " \"$\")"};

#ifndef WIN32
   static const char __far * const shortDayNames[] =
         {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

   static const char __far * const fullDayNames[] =
         {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

   static const short cbShortDayNames[] = {3, 3, 3, 3, 3, 3, 3};
   static const short cbFullDayNames[]  = {6, 6, 7, 9, 8, 6, 8};


   static const char __far * const shortMonthNames[] =
         {"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"};

   static const char __far * const fullMonthNames[] =
         {"january", "feburary", "march",     "april",   "may",      "june",
          "july",    "august",   "september", "october", "november", "december"};

   static const short cbShortMonthNames[] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
   static const short cbFullMonthNames[]  = {7, 8, 5, 5, 3, 4, 4, 6, 9, 7, 8, 8};
#endif

#endif // UNUSED


/* IMPLEMENTATION */

#ifdef WIN32
private int GetProfile32Int (int itemId)
{
   //WCHAR  unicodeData[16];
   char   data[16];
   int    cch;

   //if (isWindows95 == 0) {
   //   cch = GetLocaleInfo
   //      (GetUserDefaultLCID(), itemId, unicodeData, sizeof(unicodeData)/sizeof(WCHAR));
   //
   //   WideCharToMultiByte
   //      (CP_ACP, 0, unicodeData, cch + 1, data, sizeof(data), NULL, NULL);
   //}
   //else {
      cch = GetLocaleInfoA(GetUserDefaultLCID(), itemId, data, sizeof(data));
      data[cch] = EOS;
   //}

   return (atoi(data));
}

private void GetProfile32String (int itemId, char __far *value, int cbValue)
{
   //WCHAR  unicodeData[128];
   int    cch;

   //if (isWindows95 == 0) {
   //   cch = GetLocaleInfo
   //      (GetUserDefaultLCID(), itemId, unicodeData, sizeof(unicodeData)/sizeof(WCHAR));
   //
   //   WideCharToMultiByte
   //     (CP_ACP, 0, unicodeData, cch + 1, value, cbValue, NULL, NULL);
   //}
   //else {
      cch = GetLocaleInfoA(GetUserDefaultLCID(), itemId, value, cbValue);
      value[cch] = EOS;
   //}
}
#endif

public int FMTControlPanelGetSettings (void * pGlobals, CP_INFO __far *pIntlInfo)
{
   char iniString[64];
   char __far *pPicture;

   #ifdef WIN32
      int    i;

      GetProfile32String (LOCALE_SCURRENCY, pIntlInfo->currencySymbol, sizeof(pIntlInfo->currencySymbol));
      pIntlInfo->currencyPosFormat = GetProfile32Int(LOCALE_ICURRENCY);
      pIntlInfo->currencyNegFormat = GetProfile32Int(LOCALE_INEGCURR);
      pIntlInfo->currencyDigits    = min(GetProfile32Int(LOCALE_ICURRDIGITS), 9);

      GetProfile32String(LOCALE_SMONDECIMALSEP, iniString, sizeof(iniString));
      pIntlInfo->currencyDecimalSeparator = iniString[0];

      GetProfile32String(LOCALE_SMONTHOUSANDSEP, iniString, sizeof(iniString));
      pIntlInfo->currencyThousandSeparator = iniString[0];

      pIntlInfo->numberDigits      = min(GetProfile32Int(LOCALE_IDIGITS), 9);
      pIntlInfo->numbersHaveLeadingZeros = GetProfile32Int(LOCALE_ILZERO);

      GetProfile32String(LOCALE_SDECIMAL, iniString, sizeof(iniString));
      pIntlInfo->numberDecimalSeparator = iniString[0];

      GetProfile32String(LOCALE_STHOUSAND, iniString, sizeof(iniString));
      pIntlInfo->numberThousandSeparator = iniString[0];

      pIntlInfo->iTime    = GetProfile32Int(LOCALE_ITIME);
      pIntlInfo->iTLZero  = GetProfile32Int(LOCALE_ITLZERO);
      pIntlInfo->iAMPMPos = GetProfile32Int(LOCALE_ITIMEMARKPOSN);

      GetProfile32String(LOCALE_S1159, pIntlInfo->AMString, sizeof(pIntlInfo->AMString));
      GetProfile32String(LOCALE_S2359, pIntlInfo->PMString, sizeof(pIntlInfo->PMString));
      GetProfile32String(LOCALE_STIME, iniString, sizeof(iniString));
      pIntlInfo->timeSeparator = iniString[0];

      GetProfile32String(LOCALE_SSHORTDATE, pIntlInfo->datePicture, sizeof(pIntlInfo->datePicture));

      pIntlInfo->monthAndDayNamesOnHeap = TRUE;

      for (i = 0; i < DAYS_PER_WEEK; i++) {
         GetProfile32String(LOCALE_SDAYNAME1 + i, iniString, sizeof(iniString));
         pIntlInfo->cbFullDayName[i] = (short) strlen(iniString);

         if ((pIntlInfo->fullDayName[i] = MemAllocate(pGlobals, pIntlInfo->cbFullDayName[i] + 1)) == NULL)
            return (FMT_errOutOfMemory);
         strcpy (pIntlInfo->fullDayName[i], iniString);

         GetProfile32String(LOCALE_SABBREVDAYNAME1 + i, iniString, sizeof(iniString));
         pIntlInfo->cbShortDayName[i] = (short) strlen(iniString);

         if ((pIntlInfo->shortDayName[i] = MemAllocate(pGlobals, pIntlInfo->cbShortDayName[i] + 1)) == NULL)
            return (FMT_errOutOfMemory);
         strcpy (pIntlInfo->shortDayName[i], iniString);
      }

      for (i = 0; i < MONTHS_PER_YEAR; i++) {
         GetProfile32String(LOCALE_SMONTHNAME1 + i, iniString, sizeof(iniString));
         pIntlInfo->cbFullMonthName[i] = (short)strlen(iniString);

         if ((pIntlInfo->fullMonthName[i] = MemAllocate(pGlobals, pIntlInfo->cbFullMonthName[i] + 1)) == NULL)
            return (FMT_errOutOfMemory);
         strcpy (pIntlInfo->fullMonthName[i], iniString);

         GetProfile32String(LOCALE_SABBREVMONTHNAME1 + i, iniString, sizeof(iniString));
         pIntlInfo->cbShortMonthName[i] = (short)strlen(iniString);

         if ((pIntlInfo->shortMonthName[i] = MemAllocate(pGlobals, pIntlInfo->cbShortMonthName[i] + 1)) == NULL)
            return (FMT_errOutOfMemory);
         strcpy (pIntlInfo->shortMonthName[i], iniString);
      }
   #else

      GetProfileString("Intl", "sCurrency",  "", pIntlInfo->currencySymbol, sizeof(pIntlInfo->currencySymbol));
      pIntlInfo->currencyPosFormat = GetProfileInt("Intl", "iCurrency", 0);
      pIntlInfo->currencyNegFormat = GetProfileInt("Intl", "iNegCurr", 0);
      pIntlInfo->currencyDigits    = min(GetProfileInt("Intl", "iCurrDigits", 0), 9);

      GetProfileString("Intl", "sDecimal",   "", iniString, sizeof(iniString));
      pIntlInfo->numberDecimalSeparator = iniString[0];
      pIntlInfo->currencyDecimalSeparator = iniString[0];

      GetProfileString("Intl", "sThousand",   "", iniString, sizeof(iniString));
      pIntlInfo->numberThousandSeparator = iniString[0];
      pIntlInfo->currencyThousandSeparator = iniString[0];

      pIntlInfo->numberDigits = min(GetProfileInt("Intl", "iDigits", 0), 9);
      pIntlInfo->numbersHaveLeadingZeros = GetProfileInt("Intl", "iLzero", 0);

      pIntlInfo->iTime    = GetProfileInt("Intl", "iTime", 0);
      pIntlInfo->iTLZero  = GetProfileInt("Intl", "iTLZero", 0);
      pIntlInfo->iAMPMPos = 0;
      GetProfileString("Intl", "s1159", "", pIntlInfo->AMString, sizeof(pIntlInfo->AMString));
      GetProfileString("Intl", "s2359", "", pIntlInfo->PMString, sizeof(pIntlInfo->PMString));
      GetProfileString("Intl", "sTime", "", iniString, sizeof(iniString));
      pIntlInfo->timeSeparator = iniString[0];

      GetProfileString("Intl", "sShortDate", "", pIntlInfo->datePicture, sizeof(pIntlInfo->datePicture));

      if ((pIntlInfo->shortDayName[0]   == NULL) ||
          (pIntlInfo->fullDayName[0]    == NULL) ||
          (pIntlInfo->shortMonthName[0] == NULL) ||
          (pIntlInfo->fullMonthName[0]  == NULL))
      {
         pIntlInfo->monthAndDayNamesOnHeap = FALSE;

         memcpy (pIntlInfo->shortDayName,   shortDayNames,   sizeof(pIntlInfo->shortDayName));
         memcpy (pIntlInfo->cbShortDayName, cbShortDayNames, sizeof(pIntlInfo->cbShortDayName));

         memcpy (pIntlInfo->fullDayName,   fullDayNames,    sizeof(pIntlInfo->fullDayName));
         memcpy (pIntlInfo->cbFullDayName, cbFullDayNames,  sizeof(pIntlInfo->cbFullDayName));

         memcpy (pIntlInfo->shortMonthName,   shortMonthNames,   sizeof(pIntlInfo->shortMonthName));
         memcpy (pIntlInfo->cbShortMonthName, cbShortMonthNames, sizeof(pIntlInfo->cbShortMonthName));

         memcpy (pIntlInfo->fullMonthName,   fullMonthNames,    sizeof(pIntlInfo->fullMonthName));
         memcpy (pIntlInfo->cbFullMonthName, cbFullMonthNames,  sizeof(pIntlInfo->cbFullMonthName));
      }

   #endif

   /*
   ** From the date picture get the date separator character
   */
   pPicture = pIntlInfo->datePicture;
   while (*pPicture != EOS) {
      if (!isalpha(*pPicture)) {
         pIntlInfo->dateSeparator = *pPicture;
      }
      IncCharPtr(pPicture);
   }
   return (FMT_errSuccess);
}

public int FMTControlPanelFreeSettings (void * pGlobals, CP_INFO __far *pIntlInfo)
{
   int  i;

   if (pIntlInfo->monthAndDayNamesOnHeap == TRUE) {
      for (i = 0; i < DAYS_PER_WEEK; i++) {
         MemFree (pGlobals, pIntlInfo->fullDayName[i]);
         MemFree (pGlobals, pIntlInfo->shortDayName[i]);
      }

      for (i = 0; i < MONTHS_PER_YEAR; i++) {
         MemFree (pGlobals, pIntlInfo->fullMonthName[i]);
         MemFree (pGlobals, pIntlInfo->shortMonthName[i]);
      }
   }

   return (FMT_errSuccess);
}

#endif // !VIEWER

/* end EXFMTCP.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlcfg.h ===
/*
** File: EXCELCFG.H
**
** Copyright (C) Advanced Quonset Technology, 1994.  All rights reserved.
**
** Notes:
**    This module is intended to be modified for each project that uses
**    the Excel package.
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* INCLUDE TESTS */
#define EXCELCFG_H

/* DEFINITIONS */

/*
** ----------------------------------------------------------------------------
** Compile options
**
** There are eight major compile options for the Excel module:
**
** EXCEL_ENABLE_WRITE
**    If this option is defined Biff file write facilities are available
**
** EXCEL_ENABLE_V5
**    If this option is defined version 5 files can be opened.  The major
**    consequence of disabling V5 files is to not require the OLE DLL's
**
** EXCEL_ENABLE_FUNCTION_INFO
**    If this option is enabled the spellings of functions and macros
**    are available.  If the application does not need the spellings, memory
**    use can be saved by disabling.
**
** EXCEL_ENABLE_FORMULA_EXPAND
**    Enable the facilities to expand array and shared formulas in cells that
**    contain them.  This requires a preliminary scan of the whole file to
**    collect the array and shared formulas.
**
** EXCEL_ENABLE_DIRECT_CELL_READS
**    Enable the functions to read cells by their row,col.  Requires the
**    support of the file index structures.
**
** EXCEL_ENABLE_CHART_BIFF
**    All the open of .XLC files and the scan of some limited records
**
** EXCEL_ENABLE_STORAGE_OPEN
**    Support opening of excel files by a STORAGE argument in addition to
**    a pathname
**
** EXCEL_ENABLE_SUMMARY_INFO
**    Enable the summary info api
** ----------------------------------------------------------------------------
*/

#undef  EXCEL_ENABLE_WRITE
#define EXCEL_ENABLE_V5
#undef  EXCEL_ENABLE_FUNCTION_INFO
#undef  EXCEL_ENABLE_FORMULA_EXPAND
#undef  EXCEL_ENABLE_DIRECT_CELL_READS
#define EXCEL_ENABLE_CHART_BIFF
#define EXCEL_ENABLE_STORAGE_OPEN
#undef  EXCEL_ENABLE_SUMMARY_INFO

#undef  ENABLE_PRINTF_FOR_GENERAL

#ifndef FILTER_LIB
#include "msostr.h"
#define MultiByteToWideChar MsoMultiByteToWideChar
#define WideCharToMultiByte MsoWideCharToMultiByte
#endif // FILTER_LIB

/*
** ----------------------------------------------------------------------------
** BIFF Record decode options
**
** If the client application only needs a subset of the supported record
** types, the code for those that are not needed can be eliminated
**
** In the following if the constant if defined then the code for that
** record type is included.
*/
#undef  EXCEL_ENABLE_TEMPLATE
#undef  EXCEL_ENABLE_ADDIN
#undef  EXCEL_ENABLE_INTL
#define EXCEL_ENABLE_DATE_SYSTEM
#define EXCEL_ENABLE_CODE_PAGE
#define EXCEL_ENABLE_PROTECTION
#define EXCEL_ENABLE_COL_INFO
#define EXCEL_ENABLE_STD_WIDTH
#define EXCEL_ENABLE_DEF_COL_WIDTH
#undef  EXCEL_ENABLE_DEF_ROW_HEIGHT
#define EXCEL_ENABLE_GCW
#undef  EXCEL_ENABLE_FONT
#define EXCEL_ENABLE_FORMAT
#define EXCEL_ENABLE_XF
#undef  EXCEL_ENABLE_WRITER_NAME
#undef  EXCEL_ENABLE_REF_MODE
#undef  EXCEL_ENABLE_FN_GROUP_COUNT
#undef  EXCEL_ENABLE_FN_GROUP_NAME
#undef  EXCEL_ENABLE_EXTERN_COUNT
#undef  EXCEL_ENABLE_EXTERN_SHEET
#undef  EXCEL_ENABLE_EXTERN_NAME
#define EXCEL_ENABLE_NAME
#undef  EXCEL_ENABLE_DIMENSION
#define EXCEL_ENABLE_TEXT_CELL
#define EXCEL_ENABLE_NUMBER_CELL
#undef  EXCEL_ENABLE_BLANK_CELL
#undef  EXCEL_ENABLE_ERROR_CELL
#undef  EXCEL_ENABLE_BOOLEAN_CELL
#define EXCEL_ENABLE_FORMULA_CELL
#define EXCEL_ENABLE_ARRAY_FORMULA_CELL
#define EXCEL_ENABLE_STRING_CELL
#define EXCEL_ENABLE_NOTE
#define EXCEL_ENABLE_OBJECT
#undef  EXCEL_ENABLE_IMAGE_DATA
#define EXCEL_ENABLE_SCENARIO

#undef  EXCEL_ENABLE_V5INTERFACE          //V5
#undef  EXCEL_ENABLE_DOC_ROUTING          //V5
#undef  EXCEL_ENABLE_SHARED_FORMULA_CELL  //V5
#define EXCEL_ENABLE_SCENARIO             //V5

#define EXCEL_ENABLE_STRING_POOL_SCAN     //V8

#undef  EXCEL_ENABLE_RAW_RECORD_READ

/* end EXCELCFG.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmiwd8st.hpp ===
#ifndef _WRD8STM_HPP
#define _WRD8STM_HPP

#if !VIEWER

#include "dmifstrm.hpp"
#include "dmfltinc.h"
#include "clidrun.h"

class CWord8Stream : public IFilterStream
{
    friend class CLidRun8;
public:

        CWord8Stream();
        
        ~CWord8Stream();

        ULONG AddRef() { return 1; }

#ifdef MAC
        HRESULT Load(FSSpec *pfss);
#else // WIN
        HRESULT Load(LPTSTR pszFileName);
#endif // MAC

        HRESULT LoadStg(IStorage * pstg);

        HRESULT ReadContent(VOID *pv, ULONG cb,
                                                ULONG *pcbRead);

        HRESULT GetNextEmbedding(IStorage ** ppstg);

        HRESULT Unload();

        ULONG Release() { return 0; }

        // Positions the filter at the beginning of the next chunk
    // and returns the description of the chunk in pStat
    
    HRESULT GetChunk(STAT_CHUNK * pStat);


private:

        typedef ULONG FC;
        // BTE is 2 bytes in Word 6/7, and 4 bytes in Word 8.
        typedef ULONG BTE;

    typedef struct _STSHI
    {
      //WORD cbStshi;
      WORD cstd;
      WORD csSTDBaseInFile;
      WORD fStdStylenamesWrite: 1;
      WORD fRes: 15;
      WORD stiMaxWhenSaved;
      WORD istdMaxFixedWhenSaved;
      WORD nVerBuiltInNamesWhenSaved;
      WORD ftsStandartChpStsh;
    } STSHI, FAR * lpSTHI;

    typedef struct _STD
    {
      //WORD cbStd;
      WORD sti         : 12;
      WORD fScrath     : 1;
      WORD fInvalHeight: 1;
      WORD fHasUpe     : 1;
      WORD fMassCopy   : 1;

      WORD sgc         : 4;
      WORD istdBase    : 12;

      WORD cupx        : 4;
      WORD istdNext    : 12;

      WORD bchUpe;

      WORD fAutoRedef : 1;
      WORD fHidden    : 1;
      WORD unused     : 14;

      BYTE xstzName[2];
    } STD;

        // The following are values that STD->sgc can take for determining if it's a Para style or Char style
        #define stkPara 1
        #define stkChar 2
    
    int m_nLangRunSize;
    CLidRun8 * m_pLangRuns;
    LCID m_currentLid;
    LCID m_FELid;
        BOOL m_bFEDoc;


    #pragma pack(1)
        // Simple PRM.  Note that isprm is an index into rgsprmPrm in W96.
        struct PRM1
                {
                BYTE fComplex:1;
                BYTE isprm:7;
                BYTE val;
                };

        // Complex PRM.
        struct PRM2
                {
                WORD fComplex:1;
                WORD igrpprl:15;
                };

        struct PCD
                {
                WORD :16;       // don't care.
                union
                        {
                        FC fcNotCompressed;
                        struct
                                {
                                DWORD :1;
                                DWORD fcCompressed :29;
                                DWORD fCompressed :1;
                                DWORD :1;
                                };
                        };
                union
                        {
                        PRM1 prm1;
                        PRM2 prm2;
                        };
                FC GetFC() const
                        {return fCompressed ? fcCompressed : fcNotCompressed; }
                int CbChar() const
                        {return fCompressed ? sizeof(CHAR) : sizeof(WCHAR); }
                };
        #pragma pack()

        enum FSPEC_STATE
                {
                FSPEC_ALL,
                FSPEC_NONE,
                FSPEC_EITHER
                };

        enum {FKP_PAGE_SIZE = 512};

        HRESULT ReadFileInfo();

        HRESULT ReadBinTable();

        HRESULT FindNextSpecialCharacter (BOOL fFirstChar=fFalse);

        HRESULT ParseGrpPrls();

        HRESULT Read (VOID *pv, ULONG cbToRead, IStream *pStm);

        HRESULT Seek (ULONG cbSeek, STREAM_SEEK origin, IStream *pStm);

        HRESULT SeekAndRead (ULONG cbSeek, STREAM_SEEK origin,
                                                VOID *pv, ULONG cbToRead, IStream *pStm);

        BYTE *GrpprlCacheGet (short igrpprl, USHORT *pcb);

        BYTE *GrpprlCacheAllocNew (int cb, short igrpprl);

    LCID GetDocLanguage(void);
    HRESULT CreateLidsTable(void);
    HRESULT CheckLangID(FC fcCur, ULONG * pcbToRead, LCID * plid, BOOL fUpdate = TRUE);
    HRESULT GetLidFromSyle(short istd, WORD * pLID, WORD * pLIDFE, WORD * pbUseFE, 
                WORD * pLIDBi, WORD * pbUseBi, BOOL fParaBidi=FALSE);
    void ScanGrpprl(WORD cbgrpprl, BYTE * pgrpprl, WORD * plid, WORD * plidFE, WORD * bUseFE,
                WORD * pLIDBi, WORD * pbUseBi, BOOL *pfParaBidi=NULL);
    HRESULT ProcessCharacterBinTable(void);
    HRESULT ProcessParagraphBinTable(void);
    HRESULT ProcessPieceTable(void);
        HRESULT ScanLidsForFE(void);


        IStorage *      m_pStg;         // IStorage for file
        IStream *       m_pStmMain;             // IStream for WordDocument stream.
        IStream *               m_pStmTable;    // IStream for the TableX stream.
        IStorage *              m_pstgEmbed;    // IStorage for the current embedding
        IEnumSTATSTG *  m_pestatstg;    // storage enumerator for embeddings
        IStorage *              m_pstgOP;       // IStorage for the object pool (embeddings)
        FC                              m_fcClx;        // offset of the complex part of the file
        FC *            m_rgcp;         // Character positions in the main docfile.
        PCD *           m_rgpcd;        // The corresponding piece descriptor array
                                                                // to go with m_rgcp.
        ULONG           m_cpcd;         // This is the count of piece descriptors in
                                                                // m_rgpcd.  The count of cps in m_rgcp is
                                                                // m_cpcd + 1.
        ULONG           m_ipcd;         // The current index into both m_rgcp and
                                                                // m_rgpcd.
        ULONG           m_ccpRead;      // count of characters read so
        long            m_cbte;         // count of BTE's in char bin table
        long            m_cbtePap;      // count of BTE's in paragraph bin table

        FC *            m_rgfcBinTable;     // only used if m_fComplex.
                                                                            // size is m_cbte + 1
        FC *            m_rgfcBinTablePap;      // only used if m_fComplex.
                                                                            // size is m_cbte + 1
        
    BTE *           m_rgbte;    // The BTE array from the char bin table
    BTE *           m_rgbtePap; // The BTE array from the paragraph bin table

    long            m_ibte;             // The current index into m_rgbte.
        BYTE            m_fkp[FKP_PAGE_SIZE];       // current character fkp
    BYTE            m_fkpPap[FKP_PAGE_SIZE];    // current paragraph fkp

        BYTE            m_ifcfkp;       // index into m_fkp that indicates next special
                                                                // character range.
        FSPEC_STATE     m_fsstate;      // Keeps track of whether the rest of the
                                                                // characters (in the current piece, if a
                                                                // complex file) are special characters, not
                                                                // special characters, or either, depending on
                                                                // the FKP.
        BOOL            m_fStruckOut;   // Whether struck-out text or "true" special
                                                                // characters follow our text.

        // Some flags we should read from the document's file information block.
        // Below is the contents of bytes 10 and 11 of Word 96 FIB.
        union
                {
                struct
                        {
                        BF m_fDot       :1;     //              file is a DOT
                        BF m_fGlsy      :1;     //              file is a glossary co-doc
                        BF m_fComplex   :1;     //      file pice table/etc stored (FastSave)
                        BF m_fHasPic    :1;     //              one or more graphics in file
                        BF m_cQuickSaves        :4;     //      count of times file quicksaved
                        BF m_fEncrypted :1;     //      Is file encrypted?
                        BF m_fWhichTblStm       :1;     // Is the bin table stored in docfile 1Table or 0Table?
                        BF m_fReadOnlyRecommended       :1;     //      user recommends opening R/O
                        BF m_fWriteReservation  :1;     //      owner made file write-reserved
                        BF m_fExtChar   :1;     //      extended character set;
                        BF m_fLoadOverride      :1;     // for internation use, settable by debug .exe only
                                                                                // override doc's margins, lang with internal defaults
                        BF m_fFarEast   :1;             // doc written by FarEast version of W96
                        BF m_fCrypto    :1;             // Encrypted using the Microsoft Cryptography APIs
                        };
                WORD m_wFlagsAt10;
                };

        DWORD m_FIB_OFFSET_rgfclcb;

        // LRU Cache for the incoming grpprls.
        struct CacheGrpprl
                {
                enum {CACHE_SIZE = 1024};
                enum {CACHE_MAX = 64};

                BYTE    rgb[CACHE_SIZE];                                // The buffer.
                int     ibFirst[CACHE_MAX+1];           // Boundaries between items.
                short   rgIdItem[CACHE_MAX];                    // # in the file, used as an ID.
                long    rglLastAccTmItem[CACHE_MAX];     // Last time an item was accessed.
                long    lLastAccTmCache;        // Max over all items.
                int     cItems;                         // # items in cache
                BYTE    *pbExcLarge;            // an item larger than the cache.
                long    cbExcLarge;
                short   idExcLarge;

                // Constructor.
                CacheGrpprl () :
                        cItems(0), lLastAccTmCache(0L), pbExcLarge(0)
                        {ibFirst[0] = 0; }
                } *m_pCache;

        // doc lid
    WORD m_lid;
    BYTE * m_pSTSH;
    STSHI * m_pSTSHI;
        unsigned long m_lcbStshf;
    
    // Buffer used for ANSI->UNICODE conversion.
        char *m_rgchANSIBuffer;
};

#endif // !VIEWER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlrd.c ===
/*
** File: EXCELRD.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifdef FILTER
   #include "dmixlcfg.h"
#else
   #include "excelcfg.h"
#endif

#if (defined(EXCEL_ENABLE_STORAGE_OPEN) && !defined(INC_OLE2))
   #define INC_OLE2
#endif

#include <stdlib.h>
#include <string.h>
#include <windows.h>

#if (!defined(WIN32) && defined(EXCEL_ENABLE_STORAGE_OPEN))
   #include <ole2.h>
#endif
#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmixltyp.h"
   #include "dmitext.h"
   #include "dmiexcel.h"
   #include "dmixlrec.h"
   #include "dmubfile.h"
   #include "dmixlp.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "extypes.h"
   #include "extext.h"
   #include "excel.h"
   #include "exrectyp.h"
   #include "bfile.h"
   #include "excelp.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */

/* MODULE DATA, TYPES AND MACROS  */

/*
** ----------------------------------------------------------------------------
** Globals
** ----------------------------------------------------------------------------
*/

//static int NoteExtra;
extern void InitNoteExtra(void * pGlobals);
extern void AddNoteExtra(void * pGlobals, short);
extern int GetNoteExtra(void * pGlobals);

//public TCHAR   ExcelRecordTextBuffer[CCH_RECORD_TEXT_BUFFER_MAX];
extern TCHAR * GetExcelRecordTextBuffer(void * pGlobals);
#define ExcelRecordTextBuffer GetExcelRecordTextBuffer(pGlobals)
 

//public wchar_t UnicodeExpansionBuffer[CCH_UNICODE_EXPANSION_BUFFER_MAX];
extern wchar_t * GetUnicodeExpansionBuffer(void * pGlobals);
#define UnicodeExpansionBuffer GetUnicodeExpansionBuffer(pGlobals)

//public byte __far *pExcelRecordBuffer;
extern byte __far * GetExcelRecBuffer(void * pGlobals);
#define pExcelRecordBuffer GetExcelRecBuffer(pGlobals)

/*
** ----------------------------------------------------------------------------
** Forward function prototypes
** ----------------------------------------------------------------------------
*/

private HRESULT AddStringToBuffer(void * pGlobals, WBP pWorkbook, byte __far *pRec);
public HRESULT AddToBufferPublic(void * pGlobals, TCHAR *pText, unsigned int cbText);

#ifdef EXCEL_ENABLE_SUMMARY_INFO
forward int FileSummaryInfo (WBP pWorkbook, ExcelOLESummaryInfo __far *pInfo);
#endif


/* IMPLEMENTATION */

// this one is always NULL, so there is no real danger for the multithreding
static ExcelLocalizeBuiltinName *NameLocalizer = NULL;

public int ExcelInstallNameLocalizer (ExcelLocalizeBuiltinName *pfnLocalizer)
{
   NameLocalizer = pfnLocalizer;
   return (EX_errSuccess);
}

public void ExcelFreeCellIndex (void * pGlobals, CIP pCellIndex)
{
   int  i;

   if (pCellIndex == NULL)
      return;

   for (i = 0; i < pCellIndex->ctRowBlocks; i++) {
      if (pCellIndex->rowIndex[i] != NULL)
         MemFree (pGlobals, pCellIndex->rowIndex[i]);
   }

   MemFree (pGlobals, pCellIndex);
}

/*---------------------------------------------------------------------------*/

private int Peek (WBP pWorkbook, byte __far *pData, int cbData)
{
   int  rc;

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      rc = ExcelMIPeekRecordData(pWorkbook, pData, cbData);
      return (rc);
   }
   #endif

   if ((rc = BFReadFile(pWorkbook->hFile, pData, cbData)) != BF_errSuccess)
      return (ExcelTranslateBFError(rc));

   BFSetFilePosition (pWorkbook->hFile, FROM_CURRENT, -cbData);
   return (EX_errSuccess);
}

private int PeekAtRowCol (WBP pWorkbook, unsigned short __far *row, short __far *col)
{
   typedef struct {
      unsigned short row;
      short col;
   } RC;

   RC rowCol;

   #define ROW_COL_SIZE  (long)(sizeof(RC))

   ASSERTION (pWorkbook->use == IsWorkbook);

   if (Peek(pWorkbook, (byte __far *)&rowCol, sizeof(RC)) != EX_errSuccess)
      return (NOT_EXPECTED_FORMAT);

   *row = XSHORT(rowCol.row);
   *col = XSHORT(rowCol.col);
   return (EX_errSuccess);
}


public int ExcelReadRecordHeader (WBP pWorkbook, RECHDR __far *hdr)
{
   int  rc;

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      rc = ExcelMIReadRecordHeader(pWorkbook, hdr);
      return (rc);
   }
   #endif

   if ((rc = BFReadFile(pWorkbook->hFile, (byte __far *)hdr, sizeof(RECHDR))) != EX_errSuccess)
      return (ExcelTranslateBFError(rc));

   #ifdef MAC
   hdr->type = XSHORT(hdr->type);
   hdr->length = XSHORT(hdr->length);
   #endif

   // O10 Bug 335359:  If the file is corrupt, this may be our best chance at finding it...
   if((hdr->length > MAX_EXCEL_REC_LEN) || (hdr->length < 0))
   {
        return EX_errBIFFCorrupted;
   }

   return (EX_errSuccess);
}

public int ExcelPeekRecordHeader (WBP pWorkbook, RECHDR __far *hdr)
{
   int rc;

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      rc = ExcelMIReadRecordHeader(pWorkbook, hdr);
      return (rc);
   }
   #endif

   if ((rc = BFReadFile(pWorkbook->hFile, (byte __far *)hdr, sizeof(RECHDR))) != EX_errSuccess)
      return (ExcelTranslateBFError(rc));

   #ifdef MAC
   hdr->type = XSHORT(hdr->type);
   hdr->length = XSHORT(hdr->length);
   #endif

   BFSetFilePosition (pWorkbook->hFile, FROM_CURRENT, -((int)sizeof(RECHDR)));
   return (EX_errSuccess);
}


#define CanBeContinued(x) \
        ((x == ARRAY)      || (x == NOTE)          || (x == IMDATA) || \
         (x == EXTERNNAME) || (x == EXTERNNAME_V5) || (x == OBJ)    || \
         (x == NAME)       || (x == NAME_V5)       || (x == STRING) || \
         (x == FORMULA_V3) || (x == FORMULA_V4)    || (x == FORMULA_V5) || \
         (x == TXO_V8))

public int ExcelReadTotalRecord (void * pGlobals, WBP pWorkbook, RECHDR __far *hdr, byte __far * __far *pResult)
{
   int     rc;
   int     cbTotalRecord;
   byte    __far *pRec;
   byte    __far *pNewRec;
   RECHDR  checkHdr;

   struct {
      short row;
      short reserved;
      short cbData;
   } noteHdr;

   #define HDR_SIZE  (long)(sizeof(RECHDR))
   #define NHDR_SIZE (long)(sizeof(noteHdr))

   #define CONTINUE_CHECK_LIMIT 1024

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      rc = ExcelMIReadRecord(pWorkbook, hdr, pResult);
      return (rc);
   }
   #endif

   InitNoteExtra(pGlobals);  //NoteExtra = 0;

   if (hdr->length == 0) {
      *pResult = NULL;
      return (EX_errSuccess);
   }

   if((hdr->length > MAX_EXCEL_REC_LEN) || (hdr->length < 0))
   {
        return EX_errBIFFCorrupted;
   }

   if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr->length)) != BF_errSuccess)
      return (ExcelTranslateBFError(rc));

   /*
   ** I'm unsure of the rules Excel uses for how data is broken between the
   ** main record and the continue records.  Does it just fill to 2084 bytes
   ** and cut off or does it break at some logical point?  Don't know.  However
   ** to prevent unnecessary checking of the next record for a continue I do
   ** two things:
   ** 1) Only check for records that I known may get large enough to be continued
   ** 2) Only check is the main record is over 1024 bytes
   */
   if (!CanBeContinued(hdr->type) || ((hdr->length < CONTINUE_CHECK_LIMIT) && (hdr->type != TXO_V8))) {
      *pResult = pExcelRecordBuffer;
      pWorkbook->currentRecordLen = sizeof(RECHDR) + hdr->length;
      return (EX_errSuccess);
   }

   cbTotalRecord = hdr->length;
   pRec = NULL;

   forever {
      if ((rc = BFReadFile(pWorkbook->hFile, (byte __far *)&checkHdr, sizeof(RECHDR))) != BF_errSuccess) {
         if (pRec != NULL) MemFree(pGlobals, pRec);
         return (ExcelTranslateBFError(rc));
      }

      /*
      ** NOTE records are extended without CONTINUE records.  They are
      ** extended using additional NOTE records with the row field of the
      ** record set to -1
      */
      if ((hdr->type == NOTE) && (checkHdr.type == NOTE)) {
         if ((rc = BFReadFile(pWorkbook->hFile, (byte __far *)&noteHdr, sizeof(noteHdr))) != BF_errSuccess) {
            if (pRec != NULL) MemFree(pGlobals, pRec);
            return (ExcelTranslateBFError(rc));
         }

         #ifdef MAC
         noteHdr.row = XSHORT(noteHdr.row);
         noteHdr.cbData = XSHORT(noteHdr.cbData);
         #endif

         if (noteHdr.row != -1) {
            BFSetFilePosition (pWorkbook->hFile, FROM_CURRENT, -(HDR_SIZE + NHDR_SIZE));
            break;
         }

         AddNoteExtra(pGlobals, noteHdr.cbData); //NoteExtra += noteHdr.cbData;

         if ((pNewRec = MemAllocate(pGlobals, cbTotalRecord + noteHdr.cbData)) == NULL) {
            if (pRec != NULL) MemFree(pGlobals, pRec);
            return (EX_errOutOfMemory);
         }

         if (pRec != NULL) {
            memcpy (pNewRec, pRec, cbTotalRecord);
            MemFree (pGlobals, pRec);
         }
         else {
            memcpy (pNewRec, pExcelRecordBuffer, cbTotalRecord);
         }

         if ((rc = BFReadFile(pWorkbook->hFile, pNewRec + cbTotalRecord, noteHdr.cbData)) != BF_errSuccess) {
            MemFree (pGlobals, pNewRec);
            return (ExcelTranslateBFError(rc));
         }

         pRec = pNewRec;
         cbTotalRecord += noteHdr.cbData;
      }

      else {
         if (checkHdr.type != CONTINUE) {
            BFSetFilePosition (pWorkbook->hFile, FROM_CURRENT, -HDR_SIZE);
            break;
         }

         if ((pNewRec = MemAllocate(pGlobals, cbTotalRecord + checkHdr.length)) == NULL) {
            if (pRec != NULL) MemFree(pGlobals, pRec);
            return (EX_errOutOfMemory);
         }

         if (pRec != NULL) {
            memcpy (pNewRec, pRec, cbTotalRecord);
            MemFree (pGlobals, pRec);
         }
         else {
            memcpy (pNewRec, pExcelRecordBuffer, cbTotalRecord);
         }

         if ((rc = BFReadFile(pWorkbook->hFile, pNewRec + cbTotalRecord, checkHdr.length)) != BF_errSuccess) {
            MemFree (pGlobals, pNewRec);
            return (ExcelTranslateBFError(rc));
         }

         pRec = pNewRec;
         cbTotalRecord += checkHdr.length;
      }
   }

   if (pRec == NULL)
      *pResult = pExcelRecordBuffer;
   else
      *pResult = pRec;

   hdr->length = (short) cbTotalRecord;
   pWorkbook->currentRecordLen = cbTotalRecord + sizeof(RECHDR);

   return (EX_errSuccess);
}

public int ExcelSkipRecord (WBP pWorkbook, RECHDR __far *hdr)
{
   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      return (ExcelMISkipRecord(pWorkbook, hdr));
   }
   #endif

   BFSetFilePosition(pWorkbook->hFile, FROM_CURRENT, hdr->length);
   return (EX_errSuccess);
}


#ifdef EXCEL_ENABLE_IMAGE_DATA
private int ReadIMDataRecord
       (BFile hFile, int cbRecord, unsigned long cbPicture,
        byte __huge * __far *pResult, HGLOBAL __far *pHandle)
{
   int      rc;
   byte     __huge *pPicture;
   byte     __huge *pData;
   HGLOBAL  hPicture;
   RECHDR   hdr;
   unsigned long cbRemaining;

   if (WORKBOOK_IN_MEMORY(pWorkbook))
      return (EX_errMemoryImageNotSupported);

   pPicture = AllocateHugeSpace(cbPicture + sizeof(IMHDR), &hPicture);
   if (pPicture == NULL)
      return (EX_errOutOfMemory);

   pData = pPicture;
   cbRemaining = cbPicture + sizeof(IMHDR);

   /*
   ** Read first part ...
   */
   if ((rc = BFReadFile(hFile, pExcelRecordBuffer, cbRecord)) != EX_errSuccess)
      return (ExcelTranslateBFError(rc));

   if (cbRemaining < (unsigned int)cbRecord) {
      FreeSpace (hPicture);
      return (NOT_EXPECTED_FORMAT);
   }

   memcpy (pData, pExcelRecordBuffer, cbRecord);
   pData += cbRecord;
   cbRemaining -= cbRecord;

   /*
   ** Read all the continue records ...
   */
   forever {
      if ((rc = BFReadFile(hFile, (byte __far *)&hdr, sizeof(RECHDR))) != EX_errSuccess) {
         FreeSpace (hPicture);
         return (ExcelTranslateBFError(rc));
      }

      #ifdef MAC
      hdr.type = XSHORT(hdr.type);
      hdr.length = XSHORT(hdr.length);
      #endif

      if (hdr.type != CONTINUE) {
         BFSetFilePosition (hFile, FROM_CURRENT, -HDR_SIZE);
         break;
      }

      if ((rc = BFReadFile(hFile, pExcelRecordBuffer, hdr.length)) != EX_errSuccess) {
         FreeSpace (hPicture);
         return (ExcelTranslateBFError(rc));
      }

      if (cbRemaining < (unsigned short)hdr.length) {
         FreeSpace (hPicture);
         return (NOT_EXPECTED_FORMAT);
      }

      memcpy (pData, pExcelRecordBuffer, hdr.length);
      pData += hdr.length;
      cbRemaining -= hdr.length;
   }

   *pResult = pPicture;
   *pHandle = hPicture;

   return (EX_errSuccess);
}
#endif

/*---------------------------------------------------------------------------*/

public int ExcelExtractString
      (WBP pWorkbook, TCHAR __far *pDest, int cchDestMax, byte __far *pSource, int cchSource)
{
   int     i;
   int     cchDest;
   wchar_t *pUnicode;
   byte    *pCUnicode;

   #ifndef UNICODE
   wchar_t *pExpansionBuffer;
   #endif

   if (pWorkbook->version < versionExcel8) {
      #ifdef UNICODE
         cchDest = MultiByteToWideChar(CP_ACP, 0, pSource, cchSource, pDest, cchDestMax);
      #else
         memcpy (pDest, pSource, cchSource);
         cchDest = cchSource;
      #endif
   }
   else {
      unsigned char tag = *pSource++;

      #ifdef UNICODE
         if (tag == V8_UNICODE_STRING_TAG) {
            if (cchSource < cchDestMax) {
               memcpy (pDest, pSource, cchSource * sizeof(wchar_t));
               cchDest = cchSource;
            }
            else {
               *pDest = EOS;
               return (0);
            }
         }
         else if (tag == V8_CUNICODE_STRING_TAG)
         {
            if (cchSource < cchDestMax) {
               pUnicode  = pDest;
               pCUnicode = pSource;
               for (i = 0; i < cchSource; i++)
                  *pUnicode++ = *pCUnicode++;
               cchDest = cchSource;
            }
            else {
               *pDest = EOS;
               return (0);
            }
         }
         else {
            cchDest = MultiByteToWideChar(CP_ACP, 0, pSource, cchSource, pDest, cchDestMax);
         }
      #else
         if (tag == V8_UNICODE_STRING_TAG) {
            cchDest = WideCharToMultiByte(CP_ACP, 0, (wchar_t *)pSource, cchSource, pDest, cchDestMax, NULL, NULL);
         }
         else if (tag == V8_CUNICODE_STRING_TAG) {
            if (cchSource <= CCH_UNICODE_EXPANSION_BUFFER_MAX) {
               pUnicode = UnicodeExpansionBuffer;
               pCUnicode = pSource;
               for (i = 0; i < cchSource; i++)
                  *pUnicode++ = *pCUnicode++;
               cchDest = WideCharToMultiByte(CP_ACP, 0, UnicodeExpansionBuffer, cchSource, pDest, cchDestMax, NULL, NULL);
            }
            else {
               if ((pExpansionBuffer = MemAllocate(cchSource * sizeof(wchar_t))) == NULL) {
                  *pDest = EOS;
                  return (0);
               }
               pUnicode  = pExpansionBuffer;
               pCUnicode = pSource;
               for (i = 0; i < cchSource; i++)
                  *pUnicode++ = *pCUnicode++;

               cchDest = WideCharToMultiByte(CP_ACP, 0, pExpansionBuffer, cchSource, pDest, cchDestMax, NULL, NULL);
               MemFree (pExpansionBuffer);
            }
         }
         else {
            memcpy (pDest, pSource, cchSource);
            cchDest = cchSource;
         }
      #endif
   }

  *(pDest + cchDest) = EOS;

   #ifdef UNICODE
      return (cchDest * sizeof(wchar_t));
   #else
      return (cchDest);
   #endif
}


private int MaxResultCharacters (byte tag, int cchString)
{
   //
   // Determine maximum number of characters needed to hold a string
   //
   // String is:           Want Unicode     Want Ansi
   // -----------------    ------------     ---------
   // unicode                   n               2n
   // compressedUnicode         n               2n
   // DBCS                      n               n
   //
   #ifdef UNICODE
      return (cchString + 1);
   #else
      if ((tag & V8_TAG_MASK) == V8_ANSI_DBCS_TAG)
         return (cchString + 1);
      else
         return ((cchString + 1) * 2);
   #endif
}

public int ExcelExtractBigString
      (void * pGlobals, WBP pWorkbook, TCHAR __far **pDest, byte __far *pSource, int cchSource)
{
   TCHAR *pResult;
   int   cchResultMax, cbResult;

   if (pWorkbook->version == versionExcel8)
      cchResultMax = MaxResultCharacters(*pSource, cchSource);
   else
      cchResultMax = MaxResultCharacters(V8_ANSI_DBCS_TAG, cchSource);

   if (cchResultMax > CCH_RECORD_TEXT_BUFFER_MAX) {
      if ((pResult = MemAllocate(pGlobals, cchResultMax * sizeof(TCHAR))) == NULL)
         return (EX_errOutOfMemory);

      cbResult = ExcelExtractString(pWorkbook, pResult, cchResultMax, pSource, cchSource);
      *pDest   = pResult;
   }
   else {
      cbResult = ExcelExtractString(pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pSource, cchSource);
      *pDest   = ExcelRecordTextBuffer;
   }
   return (cbResult);
}


#if (defined(EXCEL_ENABLE_STRING_POOL_SCAN) || defined(EXCEL_ENABLE_TEXT_CELL))

public int ExcelStringPoolNextString
   (void * pGlobals, WBP pWorkbook, PoolInfo *pPoolInfo, TCHAR **pResult, unsigned int *cbResult, BOOL *resultOnHeap)
{
   typedef enum {
      SPDone,
      SPNewString,
      SPContainedString,
      SPSplitString,
      SPMissingLength,
      SPMissingFormatCount,
          SPSkipExtRSTData
   } SPState;

   SPState state = SPNewString;
   int rc;
   unsigned char tag;
   unsigned int ctFormat;
   unsigned int cbPiece, cbFormat, cchPiece;
   unsigned int ctCharacters, ctTotalCharacters;
   unsigned int cbString, cbTotalString, i;
   unsigned int cbExtRSTData;
   BOOL fExtRST = FALSE;
   int cchTemp, cchDest;
   TCHAR   *pTemp;
   RECHDR  hdr;

   wchar_t *pUnicode;
   byte    *pCUnicode;
#ifndef UNICODE
   char    *pAnsi;
   wchar_t *pExpansionBuffer;
#endif

   *resultOnHeap = FALSE;

   while (state == SPNewString) {
           fExtRST = FALSE;
      if (pPoolInfo->cbRemaining >= (sizeof(unsigned short) + sizeof(unsigned char))) {
         ctCharacters = XSHORT(*((unsigned short UNALIGNED *)(pPoolInfo->pRec)));
         tag = *(pPoolInfo->pRec + 2);
         pPoolInfo->pRec += 3;
         pPoolInfo->cbRemaining -= 3;

         if (!V8_OK_TAG(tag))
            return (NOT_EXPECTED_FORMAT);

         cbString = ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) ? ctCharacters * 2 : ctCharacters;
         cbTotalString = cbString;
                 cbExtRSTData = 0;

         if ((tag & V8_RTF_MODIFIER) != 0) {
            if (pPoolInfo->cbRemaining >= sizeof(unsigned short)) {
               ctFormat = XSHORT(*((unsigned short UNALIGNED *)(pPoolInfo->pRec)));

               pPoolInfo->pRec += sizeof(unsigned short);
               pPoolInfo->cbRemaining -= sizeof(unsigned short);

               cbTotalString = cbString + (ctFormat * 4);
               state = (pPoolInfo->cbRemaining >= cbTotalString) ? SPContainedString : SPSplitString;
            }
            else {
               state = SPMissingFormatCount;
            }
         }

                 // Office96.107932 Extended RST
                 // I believe Excel FE should be putting out the cbExtRSTData in this initial header, but
                 // they aren't. Check on this as things move along.
                 // (ie. track \xl96\shr\loadz.c and savez.c for changes)
                 if ((state != SPMissingFormatCount) && ((tag & V8_EXTRST_MODIFIER) != 0))
                         {
                         fExtRST = TRUE;
                         pPoolInfo->pRec += sizeof(DWORD);
                         pPoolInfo->cbRemaining -= sizeof(DWORD);
                         }

                if (state != SPMissingFormatCount)
                        state = (pPoolInfo->cbRemaining >= cbTotalString) ? SPContainedString : SPSplitString;

      }
      else {
         state = SPMissingLength;
      }

          //Office97.107932 This loop was needed all along but 107932 exposed its absence as a problem.
          while (state != SPDone)
                  {
      switch (state) {
         case SPContainedString:
            #ifdef UNICODE
            //
            // Regardless of how the string is stored - return unicode
            //
            if ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) {
               //
               // String is unicode, totally contained in the current record
               //
               *pResult = (wchar_t *)(pPoolInfo->pRec);
               *cbResult = cbString;
            }
            else if ((tag & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG) {
               if (ctCharacters < CCH_UNICODE_EXPANSION_BUFFER_MAX) {
                  //
                  // String is compressed unicode, totally contained in the current record, and small
                  //
                  pUnicode  = UnicodeExpansionBuffer;
                  pCUnicode = pPoolInfo->pRec;
                  for (i = 0; i < cbString; i++)
                     *pUnicode++ = *pCUnicode++;

                  *pResult = UnicodeExpansionBuffer;
                  *cbResult = ctCharacters * sizeof(wchar_t);
               }
               else {
                  //
                  // String is compressed unicode, totally contained in the current record, and big
                  //
                  if ((pUnicode = MemAllocate(pGlobals, ctCharacters * 2)) == NULL)
                     return (EX_errOutOfMemory);

                  *pResult = pUnicode;
                  *resultOnHeap = TRUE;

                  pCUnicode = pPoolInfo->pRec;
                  for (i = 0; i < cbString; i++)
                     *pUnicode++ = *pCUnicode++;

                  *cbResult = ctCharacters * sizeof(wchar_t);
               }
            }
            else {
               if (ctCharacters < CCH_RECORD_TEXT_BUFFER_MAX) {
                  //
                  // String is DBCS, totally contained in the current record, and small
                  //
                  ctCharacters = MultiByteToWideChar
                     (CP_ACP, 0, pPoolInfo->pRec, ctCharacters, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX);

                  *pResult = ExcelRecordTextBuffer;
                  *cbResult = ctCharacters * sizeof(wchar_t);
               }
               else {
                  //
                  // String is DBCS, totally contained in the current record, and big
                  //
                  if ((pUnicode = MemAllocate(pGlobals, (ctCharacters+1) * sizeof(wchar_t))) == NULL)
                     return (EX_errOutOfMemory);

                  ctCharacters = MultiByteToWideChar
                     (CP_ACP, 0, pPoolInfo->pRec, ctCharacters, pUnicode, ctCharacters);
                  pUnicode[ctCharacters] = 0;

                  *pResult = pUnicode;
                  *cbResult = ctCharacters * sizeof(wchar_t);
                  *resultOnHeap = TRUE;
               }
            }

            #else
            //
            // Regardless of how the string is stored - return ansi
            //
            if ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) {
               if (ctCharacters * 2 < CCH_RECORD_TEXT_BUFFER_MAX) {
                  //
                  // String is unicode, totally contained in the current record, and small
                  //
                  ctCharacters = WideCharToMultiByte
                     (CP_ACP, 0, (wchar_t *)(pPoolInfo->pRec), ctCharacters, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, NULL, NULL);

                  *pResult = ExcelRecordTextBuffer;
                  *cbResult = ctCharacters;
               }
               else {
                  //
                  // String is unicode, totally contained in the current record, and big
                  //
                  if ((pAnsi = MemAllocate(ctCharacters * 2)) == NULL)
                     return (EX_errOutOfMemory);

                  ctCharacters = WideCharToMultiByte
                     (CP_ACP, 0, (wchar_t *)(pPoolInfo->pRec), ctCharacters, pAnsi, ctCharacters * 2, NULL, NULL);

                  *pResult = pAnsi;
                  *cbResult = ctCharacters;
                  *resultOnHeap = TRUE;
               }
            }
            else if ((tag & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG) {
               if (ctCharacters * 2 < CCH_RECORD_TEXT_BUFFER_MAX) {
                  //
                  // String is compressed unicode, totally contained in the current record, and small
                  //
                  pUnicode  = UnicodeExpansionBuffer;
                  pCUnicode = pPoolInfo->pRec;
                  for (i = 0; i < cbString; i++)
                     *pUnicode++ = *pCUnicode++;

                  ctCharacters = WideCharToMultiByte
                     (CP_ACP, 0, UnicodeExpansionBuffer, ctCharacters, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, NULL, NULL);

                  *pResult = ExcelRecordTextBuffer;
                  *cbResult = ctCharacters;
               }
               else {
                  //
                  // String is compressed unicode, totally contained in the current record, and big
                  //
                  if ((pExpansionBuffer = MemAllocate(ctCharacters * sizeof(wchar_t))) == NULL)
                     return (EX_errOutOfMemory);

                  if ((pAnsi = MemAllocate(ctCharacters * 2)) == NULL)
                     return (EX_errOutOfMemory);

                  pUnicode = pExpansionBuffer;
                  pCUnicode = pPoolInfo->pRec;
                  for (i = 0; i < cbString; i++)
                     *pUnicode++ = *pCUnicode++;

                  ctCharacters = WideCharToMultiByte
                     (CP_ACP, 0, pExpansionBuffer, ctCharacters, pAnsi, ctCharacters * 2, NULL, NULL);

                  MemFree (pExpansionBuffer);

                  *pResult = pAnsi;
                  *cbResult = ctCharacters;
                  *resultOnHeap = TRUE;
               }
            }
            else {
               //
               // String is DBCS, totally contained in the current record
               //
               *pResult  = pPoolInfo->pRec;
               *cbResult = cbString;
            }
            #endif

            pPoolInfo->pRec += cbTotalString;
            pPoolInfo->cbRemaining -= cbTotalString;
                        if (fExtRST)
                                state = SPSkipExtRSTData;
                        else
                                state = SPDone;
            break;

         case SPSplitString:
            ctTotalCharacters = ctCharacters;
            #ifdef UNICODE
               if ((pTemp = MemAllocate(pGlobals, ctCharacters * sizeof(wchar_t))) == NULL)
                  return (EX_errOutOfMemory);
            #else
               if ((pTemp = MemAllocate(ctCharacters * 2)) == NULL)
                  return (EX_errOutOfMemory);
            #endif

            cchTemp = 0;

            while (ctCharacters > 0) {
               if ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) {
                  cchPiece = min(ctCharacters, pPoolInfo->cbRemaining / 2);
                  cbPiece = cchPiece * sizeof(wchar_t);
               }
               else {
                  cchPiece = min(ctCharacters, pPoolInfo->cbRemaining);
                  cbPiece = cchPiece;
               }

               #ifdef UNICODE
               if ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) {
                  memcpy (pTemp + cchTemp, pPoolInfo->pRec, cchPiece * sizeof(wchar_t));
                  cchTemp += cchPiece;
               }
               else if ((tag & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG) {
                  pUnicode = pTemp + cchTemp;
                  for (i = 0; i < cchPiece; i++)
                     *pUnicode++ = *(pPoolInfo->pRec + i);
                  cchTemp += cchPiece;
               }
               else {
                  cchDest = MultiByteToWideChar(CP_ACP, 0, pPoolInfo->pRec, cchPiece, pTemp + cchTemp, cchPiece);
                  cchTemp += cchDest;
               }

               #else

               if ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) {
                  cchDest = WideCharToMultiByte(CP_ACP, 0, (wchar_t *)(pPoolInfo->pRec), cchPiece, pTemp + cchTemp, cchPiece * 2, NULL, NULL);
                  cchTemp += cchDest;
               }
               else if ((tag & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG) {
                  if (cchPiece <= CCH_UNICODE_EXPANSION_BUFFER_MAX) {
                     pUnicode = UnicodeExpansionBuffer;
                     pCUnicode = pPoolInfo->pRec;

                     for (i = 0; i < cchPiece; i++)
                        *pUnicode++ = *pCUnicode++;

                     cchDest = WideCharToMultiByte(CP_ACP, 0, UnicodeExpansionBuffer, cchPiece, pTemp + cchTemp, cchPiece * 2, NULL, NULL);
                     cchTemp += cchDest;
                  }
                  else {
                     if ((pExpansionBuffer = MemAllocate(cchPiece * sizeof(wchar_t))) == NULL)
                        return (EX_errOutOfMemory);

                     pUnicode  = pExpansionBuffer;
                     pCUnicode = pPoolInfo->pRec;

                     for (i = 0; i < cchPiece; i++)
                        *pUnicode++ = *pCUnicode++;

                     cchDest = WideCharToMultiByte(CP_ACP, 0, pExpansionBuffer, cchPiece, pTemp + cchTemp, cchPiece * 2, NULL, NULL);
                     MemFree (pExpansionBuffer);

                     cchTemp += cchDest;
                  }
               }
               else {
                  memcpy (pTemp + cchTemp, pPoolInfo->pRec, cchPiece);
                  cchTemp += cchPiece;
               }
               #endif

               pPoolInfo->cbRemaining -= cbPiece;
               pPoolInfo->pRec += cbPiece;

               if ((ctCharacters -= cchPiece) == 0)
                  break;

               if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
                  return (rc);

               if (hdr.type != CONTINUE)
                  return (NOT_EXPECTED_FORMAT);

               if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
                  return (NOT_EXPECTED_FORMAT);

               if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess)
                  return (ExcelTranslateBFError(rc));

               tag = *pExcelRecordBuffer;

               pPoolInfo->pRec = pExcelRecordBuffer + 1;
               pPoolInfo->cbRemaining = hdr.length - 1;
            }

            if ((cbFormat = (cbTotalString - cbString)) > 0) {
               // Skip formating information on RTF strings
               while (cbFormat > 0) {
                  cbPiece = min(cbFormat, pPoolInfo->cbRemaining);

                  pPoolInfo->cbRemaining -= cbPiece;
                  pPoolInfo->pRec += cbPiece;

                  if ((cbFormat -= cbPiece) == 0)
                     break;

                  if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
                     return (rc);

                  if (hdr.type != CONTINUE)
                     return (NOT_EXPECTED_FORMAT);

                  if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
                     return (NOT_EXPECTED_FORMAT);

                  if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess)
                     return (ExcelTranslateBFError(rc));

                  pPoolInfo->pRec = pExcelRecordBuffer;
                  pPoolInfo->cbRemaining = hdr.length;
               }
            }

            *pResult = pTemp;
            *resultOnHeap = TRUE;
            *cbResult = cchTemp * sizeof(TCHAR);
                        if (fExtRST)
                                state = SPSkipExtRSTData;
                        else
                                state = SPDone;
            break;

         case SPMissingLength:
            if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
               return (rc);

            if (hdr.type != CONTINUE)
               return (NOT_EXPECTED_FORMAT);

            // BFGetFilePosition (pWorkbook->hFile, &(pWorkbook->currentRecordPos));

            if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
               return (NOT_EXPECTED_FORMAT);

            if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess)
               return (ExcelTranslateBFError(rc));

            pPoolInfo->pRec = pExcelRecordBuffer;
            pPoolInfo->cbRemaining = hdr.length;

            ctCharacters = XSHORT(*((unsigned short UNALIGNED *)(pPoolInfo->pRec)));
            tag = *(pPoolInfo->pRec + 2);
            pPoolInfo->pRec += 3;
            pPoolInfo->cbRemaining -= 3;

            if (!V8_OK_TAG(tag))
               return (NOT_EXPECTED_FORMAT);

            cbString = ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG) ? ctCharacters * 2 : ctCharacters;
            cbTotalString = cbString;

            /* fall through */

         case SPMissingFormatCount:
                         // REVIEW kander: This code doesn't work correctly when the state actually gets set to
                         // SPMIssingFormatCount (ie other than the "fall through" case).
            if ((tag & V8_RTF_MODIFIER) != 0) {
               ctFormat = XSHORT(*((unsigned short UNALIGNED *)(pPoolInfo->pRec)));
               pPoolInfo->pRec += sizeof(unsigned short);
               pPoolInfo->cbRemaining -= sizeof(unsigned short);
               cbTotalString = cbString + (ctFormat * 4);
            }

                        // Office97.107932 Handing Ext RST....
            if ((tag & V8_EXTRST_MODIFIER) != 0)
                                {
                                fExtRST = TRUE;
                                pPoolInfo->pRec += sizeof(DWORD);
                                pPoolInfo->cbRemaining -= sizeof(DWORD);
                                }

            if (pPoolInfo->cbRemaining >= cbTotalString)
               state = SPContainedString;
            else
               state = SPSplitString;
            break;

         case SPSkipExtRSTData:
                         // Office97.107932 This is patterned after the code in Excel shr\loadz.c.  Any changes
                         // to loadz in this area as of 8/9/96 should be rolled into this code.
                        if (pPoolInfo->cbRemaining < sizeof(EXTRST))
                                {
                                if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
                                        return (rc);
                                
                                if (hdr.type != CONTINUE)
                                        return (NOT_EXPECTED_FORMAT);

                                if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
                                        return (NOT_EXPECTED_FORMAT);

                                if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess)
                                        return (ExcelTranslateBFError(rc));
                                
                                pPoolInfo->pRec = pExcelRecordBuffer;
                                pPoolInfo->cbRemaining = hdr.length;
                                }

                        cbExtRSTData = ((EXTRST UNALIGNED *) pPoolInfo->pRec)->cb + sizeof(EXTRST);
                        // Skip formating information on Extended RTF strings
                        while (cbExtRSTData > 0) {
                                cbPiece = min(cbExtRSTData, pPoolInfo->cbRemaining);

                                pPoolInfo->cbRemaining -= cbPiece;
                                pPoolInfo->pRec += cbPiece;
                                
                                if ((cbExtRSTData -= cbPiece) == 0)
                                        break;

                                if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
                                        return (rc);

                                if (hdr.type != CONTINUE)
                                        return (NOT_EXPECTED_FORMAT);
                                
                                if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
                                        return (NOT_EXPECTED_FORMAT);
                                
                                if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess)
                                        return (ExcelTranslateBFError(rc));

                                pPoolInfo->pRec = pExcelRecordBuffer;
                                pPoolInfo->cbRemaining = hdr.length;
            }
                        state = SPDone;
                        break;
                }
                } // end of new while(state != SPDone) ....Office97.107932
   }
   return (EX_errSuccess);
}

private int GetStringPoolEntry
       (void * pGlobals, WBP pWorkbook, int iString, TCHAR **pResult, unsigned int *cbResult, BOOL *resultOnHeap)
{
   int      rc;
   int      iEntry, iSkip, i;
   RECHDR   hdr;
   TCHAR    *pString;
   PoolInfo poolInfo;
   BOOL     stringOnHeap;
   unsigned long startOffset, blockOffset, currentOffset;
   unsigned int  cbString;

   ASSERTION (pWorkbook->use == IsWorkbook);

   if (WORKBOOK_IN_MEMORY(pWorkbook))
      return (EX_errMemoryImageNotSupported);

   iEntry = iString / pWorkbook->pV8StringIndex->granularity;
   iSkip = iString - (iEntry * pWorkbook->pV8StringIndex->granularity);

   startOffset = pWorkbook->pV8StringIndex->entry[iEntry].offset;
   blockOffset = startOffset - pWorkbook->pV8StringIndex->entry[iEntry].blockOffset;

   BFGetFilePosition (pWorkbook->hFile, &currentOffset);

   BFSetFilePosition (pWorkbook->hFile, FROM_START, blockOffset);

   if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
      goto done;

   if ((hdr.type != CONTINUE) && (hdr.type != STRING_POOL_TABLE)) {
      rc = NOT_EXPECTED_FORMAT;
      goto done;
   }

   if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess) {
      rc = NOT_EXPECTED_FORMAT;
      goto done;
   }

   if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess) {
      rc = ExcelTranslateBFError(rc);
      goto done;
   }

   poolInfo.pRec = pExcelRecordBuffer + (startOffset - (blockOffset + 4));
   poolInfo.cbRemaining = hdr.length - (startOffset - (blockOffset + 4));

   for (i = 0; i < iSkip; i++) {
      rc = ExcelStringPoolNextString(pGlobals, pWorkbook, &poolInfo, &pString, &cbString, &stringOnHeap);
      if (rc != EX_errSuccess)
         goto done;

      if (stringOnHeap)
         MemFree (pGlobals, pString);
   }

   rc = ExcelStringPoolNextString(pGlobals, pWorkbook, &poolInfo, &pString, &cbString, &stringOnHeap);
   if (rc != EX_errSuccess)
      goto done;

   *pResult = pString;
   *cbResult = cbString;
   *resultOnHeap = stringOnHeap;

   rc = EX_errSuccess;

done:
   BFSetFilePosition (pWorkbook->hFile, FROM_START, currentOffset);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_FORMULA_CELL
   #define EXCEL_EFC
#endif

#ifdef EXCEL_ENABLE_ARRAY_FORMULA_CELL
   #define EXCEL_EAFC
#endif

#ifdef EXCEL_ENABLE_NAME
   #define EXCEL_EN
#endif

#ifdef EXCEL_ENABLE_OBJECT
   #define EXCEL_EO
#endif

#if (defined(EXCEL_EFC) || defined(EXCEL_EAFC) || defined(EXCEL_EN) || defined(EXCEL_EO))
private int BreakoutArrayConstant (void * pGlobals, WSP pWorksheet, byte __far *pExtra, ACP __far *pConstant)
{
   int     i;
   unsigned int cbNode;
   int     ctCols, ctRows, ctElements;
   int     ctExtra;
   byte    type, val;
   int     cchString, cbResult, cbString;
   ACP     pArrayConstant;
   char    *pString;
   TCHAR   *pResult;
   double  xdouble;
   TEXT    text;

   // Works with Workbook or Worksheet

   ctExtra = 3;

   ctCols = *pExtra++;
   ctRows = XSHORT(*((unsigned short __far UNALIGNED *)pExtra));
   pExtra += 2;

   if (ctCols == 0)
      ctCols = 256;

   ctElements = ctCols * ctRows;

   cbNode = sizeof(ArrayConstant) + ((ctElements - 1) * sizeof(AITEM));
   if ((pArrayConstant = MemAllocate(pGlobals, cbNode)) == NULL) {
      *pConstant = NULL;
      return (EX_errOutOfMemory);
   }

   pArrayConstant->next = NULL;
   pArrayConstant->colCount = ctCols;
   pArrayConstant->rowCount = ctRows;

   for (i = 0; i < ctCols * ctRows; i++) {
      type = *pExtra++;
      if (type == tagISNUMBER) {
         xdouble = XDOUBLE(*((double __far UNALIGNED *)pExtra));
         pExtra += sizeof(double);

         pArrayConstant->values[i].AIN.tag = tagISNUMBER;
         pArrayConstant->values[i].AIN.value = xdouble;
         ctExtra += sizeof(double) + sizeof(byte);
      }

      else if (type == tagISSTRING) {
         if (pWorksheet->version >= versionExcel8) {
            cchString = *(unsigned short UNALIGNED *)pExtra;
            pString   = pExtra + sizeof(short);
            cbString  = 1 + ((*pString == V8_UNICODE_STRING_TAG) ? cchString * sizeof(wchar_t) : cchString);
            ctExtra  += cbString + sizeof(short) + 1;
            pExtra   += cbString + sizeof(short);
         }
         else {
            cchString = *pExtra++;
            pString   = pExtra;
            ctExtra  += cchString + 2;  // length of string + type tag byte + length byte
            pExtra   += cchString;
         }

         if (cchString > 0) {
            if ((cbResult = ExcelExtractBigString(pGlobals, (WBP)pWorksheet, &pResult, pString, cchString)) < 0)
               return (cbResult);
         }
         else {
            cbResult = 0;
            pResult  = NULL;
         }

         pArrayConstant->values[i].AIS.tag = tagISSTRING;
         text = TextStoragePut(pGlobals, pWorksheet->textStorage, (char *)pResult, cbResult);

         if (pResult != ExcelRecordTextBuffer)
            MemFree (pGlobals, pResult);

         if (text == TEXT_ERROR) {
            MemFree (pGlobals, pArrayConstant);
            *pConstant = NULL;
            return (EX_errOutOfMemory);
         }

         pArrayConstant->values[i].AIS.value = text;
      }

      else if (type == tagISERR) {
         val = *pExtra;
         pExtra += sizeof(double);

         pArrayConstant->values[i].AIE.tag = tagISERR;
         pArrayConstant->values[i].AIE.value = val;
         ctExtra += sizeof(double) + 1;
      }

      else if (type == tagISBOOL) {
         val = *pExtra;
         pExtra += sizeof(double);

         pArrayConstant->values[i].AIB.tag = tagISBOOL;
         pArrayConstant->values[i].AIB.value = val;
         ctExtra += sizeof(double) + 1;
      }

      else {
         *pConstant = NULL;
         return (EX_errBIFFUnknownArrayType);
      }
   }

   *pConstant = pArrayConstant;
   return (ctExtra);
}


private void FreeArrayConstantList (void * pGlobals, ACP pArrayConstantList)
{
   ACP  pArrayConstantNext;

   while (pArrayConstantList != NULL) {
      pArrayConstantNext = pArrayConstantList->next;
      MemFree (pGlobals, pArrayConstantList);
      pArrayConstantList = pArrayConstantNext;
   }
}


private int BreakoutFormulaParts
       (void * pGlobals, WSP pWorksheet,
        int cbRecord, byte __far *pDefinition, int cbDefinition, FORM __far *formula)

{
   int   rc;
   byte  __far *pDef;
   byte  __far *pLast;
   byte  __far *pExtra;
   byte  __far *pExtraLast;
   int   ptg, ptgBase;
   byte  attrOptions, cbString, iExtend, tag;
   unsigned int dataWord;
   int   ctArrayConstants, ctExtra;
   int   ctRectangles;
   int   cbPtg;
   ACP   pArrayConstants, pLastArrayConstant, pArrayConstant;

   // Works with Workbook or Worksheet

   ctArrayConstants = 0;
   pArrayConstants = NULL;

   if (cbDefinition > cbRecord) {
      rc = EX_errBIFFFormulaPostfixLength;
      goto RejectFormula;
   }

   pDef   = pDefinition;
   pLast  = pDefinition + cbDefinition - 1;

   pExtra     = pLast + 1;
   pExtraLast = pDefinition + cbRecord;
   
   while (pDef <= pLast) {
      ptg = *pDef++;

      ptgBase = PTGBASE(ptg);

      if (ptgBase > PTG_LAST) {
         rc = EX_errBIFFFormulaUnknownToken;
         goto RejectFormula;
      }

      if ((cbPtg = pWorksheet->PTGSize[ptgBase]) < 0) {
         rc = EX_errBIFFFormulaUnknownToken;
         goto RejectFormula;
      }

      switch (ptgBase) {
         case ptgAttr:
            attrOptions = *pDef++;
            dataWord    = XSHORT(*((unsigned short __far UNALIGNED *)pDef));
            pDef += 2;

            if ((attrOptions & bitFAttrChoose) != 0) {
               pDef += ((dataWord + 1) * 2);
               if (pDef > pLast + 1) {
                  rc = EX_errBIFFFormulaPostfixLength;
                  goto RejectFormula;
               }
            }
            break;

         case ptgStr:
                                cbString = *pDef++;
                                if (pWorksheet->version == versionExcel8)
                                        tag = *pDef++;

                                if (cbString > 0) {
                                        if (pWorksheet->version == versionExcel8) {
                                                if (tag & V8_UNICODE_STRING_TAG)
                                                        cbString *= 2;
                                        }
                                        pDef += cbString;
                                }

                                if (pDef > pLast + 1) {
               rc = EX_errBIFFFormulaPostfixLength;
               goto RejectFormula;
            }
            break;

         case ptgMemArea:
            pDef += pWorksheet->PTGSize[ptgBase];

            /*
            ** According to the documentation, the cce field of this ptg
            ** supplies the length of the subexpression that is stored
            ** after the postfix.  It appears from examining biff files
            ** that this is not correct.  The number of bytes taken in the
            ** extra area can be computed from the data stored there and
            ** the cce field ignored.
            **
            ** The number of bytes used is the number of rectangles
            ** times the size of each (6 bytes).
            */
            ctRectangles = XSHORT(*((unsigned short __far UNALIGNED *)pExtra));
            pExtra += (2 + (6 * ctRectangles));
            if (pExtra > pExtraLast) {
               rc = EX_errBIFFFormulaExtraLength;
               goto RejectFormula;
            }
            break;

         case ptgArray:
            if (pExtra >= pExtraLast) {
               rc = EX_errBIFFFormulaExtraLength;
               goto RejectFormula;
            }
            
                        ctExtra = BreakoutArrayConstant(pGlobals, pWorksheet, pExtra, &pArrayConstant);
            if (ctExtra < 0) {
               rc = ctExtra;
               goto RejectFormula;
            }

            /*
            ** Add this new value to the end of the constant list
            */
            if (pArrayConstants == NULL)
               pArrayConstants = pArrayConstant;
            else
               pLastArrayConstant->next = pArrayConstant;

            pLastArrayConstant = pArrayConstant;
            ctArrayConstants++;

            pExtra += ctExtra;
            if (pExtra > pExtraLast) {
               rc = EX_errBIFFFormulaExtraLength;
               goto RejectFormula;
            }

            pDef += pWorksheet->PTGSize[ptgBase];
            break;

         case ptgV8Extended:
            iExtend = *((byte __far *)pDef);
            pDef += (pWorksheet->ExtPTGSize[iExtend] + 1);
            break;

         case ptgNameX:
            pDef += 2;          // in Excel Code: fmf.pce += sizeof(IXTIPTG);

         default:
            pDef += pWorksheet->PTGSize[ptgBase];
            break;
      }
   }

   formula->cbPostfix = cbDefinition;
   formula->postfix   = pDefinition;

   formula->ctArrayConstants = ctArrayConstants;
   formula->arrayConstants   = pArrayConstants;

   return (EX_errSuccess);

RejectFormula:
   FreeArrayConstantList (pGlobals, pArrayConstants);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_EXTERN_SHEET
#error This code has been removed because it had some security bugs
#endif

/*---------------------------------------------------------------------------*/

private void ParseBOFRecord
       (int recType, byte __far *pRec,
        int __far *version, int __far *docType, int __far *buildId, int __far *buildYear)
{
   int docVersion;

   if (recType == BOF_V3)
      *version = versionExcel3;
   else if (recType == BOF_V4)
      *version = versionExcel4;
   else
      *version = versionExcel5;

   docVersion = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   *docType   = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   *buildId   = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
   *buildYear = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));

   if ((*version == versionExcel5) && (docVersion == 0x0600))
      *version = versionExcel8;
}

private int ProcessBOFRecord
       (void * pGlobals, ExcelBOF __far *pfunc, int recType, byte __far *pRec)
{
   int  rc;
   int  version, docType;
   int  buildId, buildYear;

   ParseBOFRecord (recType, pRec, &version, &docType, &buildId, &buildYear);

   rc = pfunc(pGlobals, version, docType);
   return (rc);
}

/*---------------------------------------------------------------------------*/

private int ProcessBundleSheetRecord
       (void * pGlobals, ExcelWBBundleSheet __far *pfunc, byte __far *pRec)
{
   char __far *pPath;
   char sheetName[EXCEL_MAX_SHEETNAME_LEN + 1];
   int  cbPath;
   int  rc;

   cbPath = *((byte __far *)(pRec + 0));
   pPath  =  ((byte __far *)(pRec + 1));

   memcpy (sheetName, pPath, cbPath);
   sheetName[cbPath] = EOS;

   rc = pfunc(pGlobals, sheetName);
   return (rc);
}

private int ProcessBundleHeaderRecord
       (void * pGlobals, ExcelWBBundleHeader __far *pfunc, byte __far *pRec)
{
   int   rc;
   char  __far *pName;
   char  sheetName[EXCEL_MAX_SHEETNAME_LEN + 1];
   int   cbName;

   cbName = *((byte __far *)(pRec + 4));
   pName  =  ((byte __far *)(pRec + 5));

   memcpy (sheetName, pName, cbName);
   sheetName[cbName] = EOS;

   rc = pfunc(pGlobals, sheetName, 0, 0);
   return (rc);
}

#ifdef EXCEL_ENABLE_EXTERN_SHEET
private int ProcessProjExtSheetRecord
       (WBP pWorkbook, ExcelWBExternSheet __far *pfunc, byte __far *pRec)
{
   int  rc;
   int  cbPath, sheetType;
   char __far *pPath;
   char resultPath[MAXPATH + 1];
   EXA_GRBIT  flags;

   // Works with workbook or worksheet

   sheetType = *((byte __far *)(pRec + 0));
   cbPath    = *((byte __far *)(pRec + 2));
   pPath     =  ((byte __far *)(pRec + 3));

   ExpandPathname (pWorkbook, pPath, cbPath, resultPath, &flags);

   rc = pfunc(sheetType, resultPath);
   return (rc);
}
#endif

private int ProcessV5BoundSheetRecord
       (void * pGlobals, WBP pWorkbook, ExcelWorkbookBoundSheet __far *pfunc, byte __far *pRec)
{
   int   rc;
   byte  sheetType, sheetState;

   // Works with workbook or worksheet

   sheetState = *((byte __far *)(pRec + 4));
   sheetType  = *((byte __far *)(pRec + 5));

   ExcelExtractString
      (pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, ((byte __far *)(pRec + 7)), *((byte __far *)(pRec + 6)));

   rc = pfunc(pGlobals, ExcelRecordTextBuffer, sheetType, sheetState);
   return (rc);
}

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_COL_INFO
private int ProcessColInfoRecord
       (void * pGlobals, ExcelColInfo __far *pfunc, byte __far *pRec)
{
   int  rc;
   unsigned int colFirst, colLast;
   unsigned int width;
   EXA_GRBIT options;

   colFirst = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));
   colLast  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 2)));
   width    = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 4)));
   options  = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 8)));

   rc = pfunc(pGlobals, colFirst, colLast, width, options);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_STD_WIDTH
private int ProcessStandardWidthRecord
       (void * pGlobals, ExcelStandardWidth __far *pfunc, byte __far *pRec)
{
   int  rc;
   unsigned int width;

   width = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));

   rc = pfunc(pGlobals, width);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_DEF_COL_WIDTH
private int ProcessDefColWidthRecord
       (void * pGlobals, ExcelDefColWidth __far *pfunc, byte __far *pRec)
{
   int  rc;
   unsigned int width;

   width = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));

   rc = pfunc(pGlobals, width);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_GCW
private int ProcessGCWRecord
       (void * pGlobals, ExcelGCW __far *pfunc, byte __far *pRec)
{
   int  rc;
   unsigned int cbBitArray;
   byte __far *pBitArray;

   cbBitArray = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));
   pBitArray  =  ((byte __far *)(pRec + 2));

   rc = pfunc(pGlobals, cbBitArray, pBitArray);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_DEF_ROW_HEIGHT
private int ProcessDefRowHeightRecord
       (ExcelDefRowHeight __far *pfunc, byte __far *pRec)
{
   int  rc;
   unsigned int height;
   EXA_GRBIT options;

   options = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));
   height  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 2)));

   rc = pfunc(height, options);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_FONT
private int ProcessFontRecord
       (WBP pWorkbook, ExcelFont __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int  rc;
   unsigned int height, cchName;
   char __far *pName;
   EXA_GRBIT options;

   // Works with workbook or worksheet

   height  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));
   options = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 2)));

   if (hdr.type == FONT_V5) {
      cchName = *((byte __far *)(pRec + 14));
      pName   =  ((char __far *)(pRec + 15));
   }
   else {
      cchName = *((byte __far *)(pRec + 6));
      pName   =  ((char __far *)(pRec + 7));
   }

    #error "ExcelRecordTextTemp is a global function, it used to be an array."
   ExcelExtractString (pWorkbook, ExcelRecordTextTemp, sizeof(ExcelRecordTextTemp)/sizeof(ExcelRecordTextTemp[0]), pName, cchName);

   rc = pfunc(height, options, pName);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_XF
private int ProcessXFRecord
       (void * pGlobals, int recType, ExcelXF __far *pfunc, byte __far *pRec)
{
   int  rc;
   int  iFont, iFormat;
   EXA_GRBIT options;

   if (recType == XF_V5) {
      iFont   = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
      iFormat = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
      options = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 4)));
   }
   else {
      /*
      ** For the fields we need the version 3 and 4 record layouts are the same
      */
      iFont   = *((byte __far *)(pRec + 0));
      iFormat = *((byte __far *)(pRec + 1));
      options = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 2)));
   }

   rc = pfunc(pGlobals, iFont, iFormat, options);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_FORMAT
private int ProcessFormatRecord
       (void * pGlobals, WBP pWorkbook, int recType, ExcelFormat __far *pfunc, byte __far *pRec)
{
   int  rc;
   int  cchString, indexCode;
   char __far *pString;

   // Works with workbook or worksheet

   if ((recType == FORMAT_V3) && (pWorkbook->version < versionExcel5)) {
      cchString = *((byte __far *)(pRec + 0));
      pString   =   (char __far *)(pRec + 1);
      indexCode = 0;
   }
   else {
      indexCode = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));

      if (pWorkbook->version <= versionExcel5) {
         cchString = *((byte __far *)(pRec + 2));
         pString   =   (char __far *)(pRec + 3);
      }
      else {
         cchString = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
         pString   = (char __far *)(pRec + 4);
      }
   }

   ExcelExtractString (pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pString, cchString);

   rc = pfunc(pGlobals, ExcelRecordTextBuffer, indexCode);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_TEMPLATE
private int ProcessTemplateRecord
       (ExcelIsTemplate __far *pfunc, byte __far *pRec)
{
   return (pfunc());
}
#endif

#ifdef EXCEL_ENABLE_ADDIN
private int ProcessAddinRecord
       (ExcelIsAddin __far *pfunc, byte __far *pRec)
{
   return (pfunc());
}
#endif

#ifdef EXCEL_ENABLE_V5INTERFACE
private int ProcessMMSRecord
       (ExcelInterfaceChanges __far *pfunc, byte __far *pRec)
{
   byte ctAddMenu, ctDelMenu;

   ctAddMenu = *((byte __far *)(pRec + 0));
   ctDelMenu = *((byte __far *)(pRec + 1));

   return (pfunc(ctAddMenu, ctDelMenu));
}

private int ProcessAddMenuRecord
       (ExcelAddMenu __far *pfunc, byte __far *pRec)
{
   int  rc, i;
   int  icetabItem, icetabBefore;
   byte ctChildren, use, cbItem;
   char __far *pString;
   char __far *parts[5];

   icetabItem   = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   icetabBefore = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   ctChildren   = *((byte  __far *)(pRec + 4));
   use          = *((byte  __far *)(pRec + 5));
   pString      =   (byte  __far *)(pRec + 6);

   for (i = 0; i < 5; i++) {
      if ((cbItem = *pString) != 0) {
         if ((parts[i] = MemAllocate(cbItem + 1)) == NULL)
            return (EX_errOutOfMemory);

         memcpy (parts[i], pString + 1, cbItem);
         *(parts[i] + cbItem) = EOS;
         pString += (cbItem + 1);
      }
      else {
         pString++;
         parts[i] = NULL;
      }
   }

   rc = pfunc(icetabItem, icetabBefore, ctChildren, use,
              parts[0], parts[1], parts[2], parts[3], parts[4]);

   for (i = 0; i < 5; i++) {
      if (parts[i] != NULL)
         MemFree (parts[i]);
   }
   return (rc);
}

private int ProcessDeleteMenuRecord
       (ExcelDeleteMenu __far *pfunc, byte __far *pRec)
{
   int  icetabItem;
   byte ctChildren, use, cbItem;
   char __far *pString;

   icetabItem   = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   ctChildren   = *((byte  __far *)(pRec + 2));
   use          = *((byte  __far *)(pRec + 3));
   pString      =   (byte  __far *)(pRec + 5);

   if ((cbItem = *pString) != 0) {
      pString++;
      *(pString + cbItem) = EOS;
   }
   else {
      pString = NULL;
   }

   return (pfunc(icetabItem, ctChildren, use, pString));
}

private int ProcessToolbarRecord
       (ExcelAddToolbar __far *pfunc, byte __far *pRec)
{
   char __far *pString;
   byte cbItem;

   /*
   ** This record is undocumented
   */
   pString = (byte __far *)(pRec + 30);

   if ((cbItem = *pString) != 0) {
      pString++;
      *(pString + cbItem) = EOS;
   }
   else {
      pString = NULL;
   }

   return (pfunc(pString));
}
#endif

#ifdef EXCEL_ENABLE_INTL
private int ProcessIntlRecord
       (ExcelIsInternationalSheet __far *pfunc, byte __far *pRec)
{
   return (pfunc());
}
#endif

#ifdef EXCEL_ENABLE_PROTECTION
private int ProcessProtectionRecord
       (void * pGlobals, int recType, ExcelProtection __far *pfunc, byte __far *pRec)
{
   int  iType;
   BOOL enabled;

   switch (recType) {
      case FILESHARING:
         iType = protectRECOMMENED_READ_ONLY;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case OBJPROTECT:
         iType = protectOBJECTS;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case PASSWORD:
         iType = protectPASSWORD;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case PROTECT:
         iType = protectCELLS;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case SCENPROTECT:
         iType = protectSCENARIOS;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case WINDOW_PROTECT:
         iType = protectWINDOWS;
                 if (!pRec)
                         return EX_errSuccess;
         enabled = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         break;

      case WRITEPROT:
         iType = protectWRITE_RESERVATION;
         enabled = TRUE;
         break;

      case FILESHARING2:
         iType = protectWRITE_RESERVATION;
         enabled = TRUE;
         break;
   }

   return (pfunc(pGlobals, iType, enabled));
}
#endif

#ifdef EXCEL_ENABLE_DATE_SYSTEM
private int ProcessDateSystemRecord
       (void * pGlobals, ExcelDateSystem __far *pfunc, byte __far *pRec)
{
   int  system;

   if (!pRec)
                return EX_errSuccess;
   system = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   return (pfunc(pGlobals, system));
}
#endif

#ifdef EXCEL_ENABLE_CODE_PAGE
private int ProcessCodePageRecord
       (void * pGlobals, ExcelCodePage __far *pfunc, byte __far *pRec)
{
   int  codePage;

   codePage = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   return (pfunc(pGlobals, codePage));
}
#endif

#ifdef EXCEL_ENABLE_REF_MODE
private int ProcessRefModeRecord
       (ExcelReferenceMode __far *pfunc, byte __far *pRec)
{
   int  mode;

   mode = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   return (pfunc(mode));
}
#endif

#ifdef EXCEL_ENABLE_FN_GROUP_COUNT
private int ProcessFNGroupCountRecord
       (ExcelFNGroupCount __far *pfunc, byte __far *pRec)
{
   int  count;

   count = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   return (pfunc(count));
}
#endif

#ifdef EXCEL_ENABLE_FN_GROUP_NAME
private int ProcessFNGroupNameRecord
       (ExcelFNGroupName __far *pfunc, byte __far *pRec)
{
   char name[EXCEL_MAX_NAME_LEN + 1];
   int  cch;

   cch = *((byte __far *)(pRec + 0));
   memcpy (name, pRec + 1, cch);
   name[cch] = EOS;

   return (pfunc(name));
}
#endif

#ifdef EXCEL_ENABLE_WRITER_NAME
private int ProcessWriteAccessRecord
       (WBP pWorkbook, ExcelWriterName __far *pfunc, byte __far *pRec)
{
   char userName[EXCEL_MAX_WRITERNAME_LEN + 1];
   int  cch;

   // Works with workbook or worksheet

   if (pWorkbook->version < versionExcel8) {
      cch   = *((byte __far *)(pRec + 0));
      pName =   (byte __far *)(pRec + 1));
   }
   else {
      cch   = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
      pName = (byte __far *)(pRec + 2));
   }

   ExtractString(pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pName, cchName);

   return (pfunc(RecordTextBuffer));
}
#endif

#ifdef EXCEL_ENABLE_EXTERN_COUNT
private int ProcessExternCountRecord
       (ExcelExternCount __far *pfunc, byte __far *pRec)
{
   int  ctExtDocs;

   ctExtDocs = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   return (pfunc(ctExtDocs));
}
#endif

#ifdef EXCEL_ENABLE_EXTERN_SHEET
private int ProcessExternSheetRecord
       (WBP pWorkbook, ExcelExternSheet __far *pfunc, byte __far *pRec)
{
   int   rc;
   char  __far *pPath;
   char  resultPath[MAXPATH + 1];
   int   ctPathChars;
   byte  flag;
                                                                                                                                                                                      EXA_GRBIT flags = 0;
   // Works with workbook or worksheet BUT there are differences

   if (pWorkbook->version == versionExcel8)
      return (EX_errSuccess);

   #define chSHEET 3

   if ((pWorkbook->version >= versionExcel5) && (pWorkbook->use == IsWorkbook)) {
      ctPathChars = *((byte __far *)(pRec + 0));
      flag        = *((byte __far *)(pRec + 1));

      if (flag == chSHEET) {
         pPath = ((byte __far *)(pRec + 2));
         memcpy (resultPath, pPath, ctPathChars);
         *(resultPath + ctPathChars) = EOS;
      }
      else {
         pPath = ((byte __far *)(pRec + 1));
         ExpandPathname (pWorkbook, pPath, ctPathChars, resultPath, &flags);
      }
   }
   else {
      ctPathChars = *((byte __far *)(pRec + 0));
      pPath       =  ((byte __far *)(pRec + 1));
      ExpandPathname (pWorkbook, pPath, ctPathChars, resultPath, &flags);
   }

   rc = pfunc(resultPath, flags);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_EXTERN_NAME
private int ProcessExternNameRecord
       (WBP pWorkbook, ExcelExternName __far *pfunc, byte __far *pRec, unsigned int cbRecord)
{
   char      __far *pName;
   byte      __far *pDefinition;
   char      name[EXCEL_MAX_NAME_LEN + 1];
   int       ctNameChars, cbDefinition;
   int       rc;
   EXA_GRBIT options;
   FORM      formula;

   // Works with workbook or worksheet

   memset (&formula, 0, sizeof(FORM));

   options = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 0)));

   if (pWorkbook->version >= versionExcel5) {
      ctNameChars = *((byte __far *)(pRec + 6));
      pName       =  ((char __far *)(pRec + 7));

      memcpy (name, pName, ctNameChars);
      name[ctNameChars] = EOS;

      if ((options & ~fENameBuiltin) == 0) {
         /*
         ** External Name
         */
         if ((cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 7 + ctNameChars)))) > 0) {
            pDefinition = (byte __far *)(pRec + 7 + ctNameChars + 2);

            rc = BreakoutFormulaParts
               ((WSP)pWorkbook, cbRecord - 7 - ctNameChars - 2, pDefinition, cbDefinition, &formula);

            if (rc != EX_errSuccess)
               return (rc);
         }
      }
   }

   else {
      ctNameChars = *((byte __far *)(pRec + 2));
      pName       =  ((char __far *)(pRec + 3));

      memcpy (name, pName, ctNameChars);
      name[ctNameChars] = EOS;

      /*
      ** Totally undocumented and very strange:
      **
      ** Assume a reference "Sheet1!A1"
      **
      ** This is an external reference to a cell.  My guess is that Excel
      ** wants to link to a name so that adjustments in sheet layout in
      ** the linked worksheet can be made to the name and not all the
      ** formulas that use that cell.
      **
      ** The difficulity with this is references in names are not absolute/relative
      ** in the same sense as worksheets - In names you have the absolute
      ** reference A1 and the relative reference R[-1]C[-1].
      **
      ** What excel does to encode the type of reference is to make up a name
      ** and use the first letter of that name to determine the reference
      ** type.
      **
      ** We know that this is one of those names by the first byte of the name
      ** being a 0x01.  The first character of the created name (the byte after
      ** the 0x01) is:
      **
      **    Letter   Reference type
      **    ------   --------------
      **    A        $A$1 : $B$1
      **    B        A$1  : $B$1
      **    C        $A1  : $B$1
      **    D        A1   : $B$1
      **    E        $A$1 : B$1
      **    F        A$1  : B$1
      **    G        $A1  : B$1
      **    H        A1   : B$1
      **    I        $A$1 : $B1
      **    J        A$1  : $B1
      **    K        $A1  : $B1
      **    L        A1   : $B1
      **    M        $A$1 : B1
      **    N        A$1  : B1
      **    O        $A1  : B1
      **    P        A1   : B1
      **
      ** Following the name in the record is the internal formula
      ** representation of the cell or area reference.
      **
      ** Note: This same thing is used for external self references, but
      ** in that case the magic name created is a local name.
      */
      if (((options & fENameBuiltin) == 0) && (name[0] == 0x01)) {
         cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 3 + ctNameChars)));
         pDefinition  = (byte __far *)(pRec + 3 + ctNameChars + 2);

         rc = BreakoutFormulaParts
             ((WSP)pWorkbook, cbRecord - 3 - ctNameChars - 2, pDefinition, cbDefinition, &formula);

         if (rc != EX_errSuccess)
            return (rc);
      }
   }

   rc = pfunc(name, options, &formula);
   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_NAME
private int ProcessNameRecord
       (void * pGlobals, WBP pWorkbook, ExcelRangeName __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int       rc;
   EXA_GRBIT flags;
   char      keyboardShortcut;
   int       cchName, cbDefinition, cbFixedPlusName;
   int       iExternSheet, iBoundSheet;
   char      __far *pName;
   byte      __far *pDefinition;
   FORM      formula;
   byte      tag;
   TCHAR     nameSpelling[EXCEL_MAX_NAME_LEN + 1];

   // Works with workbook or worksheet

   flags            = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 0)));
   keyboardShortcut = *((byte __far *)(pRec + 2));
   cchName          = *((byte __far *)(pRec + 3));
   cbDefinition     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));

   if (hdr.type == NAME_V5) {
      iExternSheet = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
      iBoundSheet  = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
      pName = ((char __far *)(pRec + 14));
      tag = *pName;

      if (pWorkbook->version >= versionExcel8)
         cbFixedPlusName = 15 + ((tag == V8_UNICODE_STRING_TAG) ? (cchName * sizeof(wchar_t)) : cchName);
      else
         cbFixedPlusName = 14 + cchName;
   }
   else {
      iExternSheet = 0;
      iBoundSheet  = 0;
      pName = ((char __far *)(pRec + 6));
      cbFixedPlusName = 6 + cchName;
   }

   ExcelExtractString (pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pName, cchName);

   if (((flags & fNameBuiltin) != 0) && (NameLocalizer != NULL))
      NameLocalizer (pGlobals, ExcelRecordTextBuffer, nameSpelling);
   else
      STRCPY (nameSpelling, ExcelRecordTextBuffer);

   if ((flags & fNameProc) == 0)
      keyboardShortcut = 0;

   if (cbDefinition > 0) {
      pDefinition = (char __far *)(pRec + cbFixedPlusName);

      rc = BreakoutFormulaParts
          (pGlobals, (WSP)pWorkbook, hdr.length - cbFixedPlusName, pDefinition, cbDefinition, &formula);

      if (rc != EX_errSuccess)
         return (rc);
   }
   else {
      memset (&formula, 0, sizeof(FORM));
   }

   rc = pfunc(pGlobals, flags, keyboardShortcut, nameSpelling, iBoundSheet, &formula);

   if (formula.arrayConstants != NULL)
      FreeArrayConstantList (pGlobals, formula.arrayConstants);

   return (rc);
}

public int ExcelResolveNameToRange
      (EXLHandle handle, FORM __far *nameDefinition, EXA_RANGE __far *range, int __far *iSheet)
{
   WBP   pWorkbook = (WBP)handle;
   byte  __far *pDef;
   short rowFirst, rowLast, colFirst, colLast;
   short sheetFirst, sheetLast;
   short iXTI;

   ASSERTION (pWorkbook->use == IsWorkbook);

   pDef = nameDefinition->postfix;

   if (ONE_SHEET_PER_FILE(pWorkbook->version)) {
      *iSheet = 0;

      if (nameDefinition->cbPostfix == pWorkbook->PTGSize[ptgAreaN] + 1) {
         if (*pDef != ptgAreaN)
            return (EX_errGeneralError);

         rowFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 1)));
         rowLast  = XSHORT(*((short __far UNALIGNED *)(pDef + 3)));
         colFirst = *(pDef + 5);
         colLast  = *(pDef + 6);

         if (((rowFirst & 0xc000) != 0) || ((rowLast & 0xc000) != 0))
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);
      }
      else if (nameDefinition->cbPostfix == pWorkbook->PTGSize[ptgRefN] + 1) {
         if (*pDef != ptgRefN)
            return (EX_errGeneralError);

         rowFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 1)));
         rowLast  = rowFirst;
         colFirst = *(pDef + 3);
         colLast  = colFirst;

         if ((rowFirst & 0xc000) != 0)
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);
      }
      else {
         return (EX_errGeneralError);
      }
   }
   else if (pWorkbook->version == versionExcel5) {
      if (nameDefinition->cbPostfix == (pWorkbook->PTGSize[ptgArea3D] + 1)) {
         if (*pDef != ptgArea3D)
            return (EX_errGeneralError);

         sheetFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 11)));
         sheetLast  = XSHORT(*((short __far UNALIGNED *)(pDef + 13)));
         rowFirst   = XSHORT(*((short __far UNALIGNED *)(pDef + 15)));
         rowLast    = XSHORT(*((short __far UNALIGNED *)(pDef + 17)));
         colFirst   = *(pDef + 19);
         colLast    = *(pDef + 20);

         if ((sheetFirst != sheetLast) || (sheetFirst == -1) || (sheetLast == -1))
            return (EX_errGeneralError);

         if (((rowFirst & 0xc000) != 0) || ((rowLast & 0xc000) != 0))
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);

         *iSheet = sheetFirst;
      }
      else if (nameDefinition->cbPostfix == (pWorkbook->PTGSize[ptgRef3D] + 1)) {
         if (*pDef != ptgRef3D)
            return (EX_errGeneralError);

         sheetFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 11)));
         sheetLast  = XSHORT(*((short __far UNALIGNED *)(pDef + 13)));
         rowFirst   = XSHORT(*((short __far UNALIGNED *)(pDef + 15)));
         rowLast    = rowFirst;
         colFirst   = *(pDef + 17);
         colLast    = colFirst;

         if (sheetFirst != sheetLast)
            return (EX_errGeneralError);

         if ((rowFirst & 0xc000) != 0)
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);

         *iSheet = sheetFirst;
      }
      else {
         return (EX_errGeneralError);
      }
   }
   else {
      // Version 8
      if (nameDefinition->cbPostfix == (pWorkbook->PTGSize[ptgArea3D] + 1)) {
         if (*pDef != ptgArea3D)
            return (EX_errGeneralError);

         iXTI     = XSHORT(*((short __far UNALIGNED *)(pDef + 1)));
         rowFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 3)));
         rowLast  = XSHORT(*((short __far UNALIGNED *)(pDef + 5)));
         colFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 7)));
         colLast  = XSHORT(*((short __far UNALIGNED *)(pDef + 9)));

         if ((iXTI >= pWorkbook->pXTITable->ctEntry) || (pWorkbook->pXTITable->entry[iXTI].iSupBook != pWorkbook->iSupBookLocal))
            return (EX_errGeneralError);

         sheetFirst = pWorkbook->pXTITable->entry[iXTI].iTabFirst;
         sheetLast  = pWorkbook->pXTITable->entry[iXTI].iTabFirst;

         if ((sheetFirst != sheetLast) || (sheetFirst < 0) || (sheetLast < 0))
            return (EX_errGeneralError);

         if (((colFirst & 0xc000) != 0) || ((colLast & 0xc000) != 0))
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);

         *iSheet = sheetFirst;
      }
      else if (nameDefinition->cbPostfix == (pWorkbook->PTGSize[ptgRef3D] + 1)) {
         if (*pDef != ptgRef3D)
            return (EX_errGeneralError);

         iXTI     = XSHORT(*((short __far UNALIGNED *)(pDef + 1)));
         rowFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 3)));
         rowLast  = rowFirst;
         colFirst = XSHORT(*((short __far UNALIGNED *)(pDef + 5)));
         colLast  = colFirst;

         if ((iXTI >= pWorkbook->pXTITable->ctEntry) || (pWorkbook->pXTITable->entry[iXTI].iSupBook != pWorkbook->iSupBookLocal))
            return (EX_errGeneralError);

         sheetFirst = pWorkbook->pXTITable->entry[iXTI].iTabFirst;
         sheetLast  = pWorkbook->pXTITable->entry[iXTI].iTabFirst;

         if ((sheetFirst != sheetLast) || (sheetFirst < 0) || (sheetLast < 0))
            return (EX_errGeneralError);

         if ((colFirst & 0xc000) != 0)
            return (EX_errGeneralError);

         range->firstRow = rowFirst;
         range->lastRow  = rowLast;
         range->firstCol = colFirst;
         range->lastCol  = colLast;

         if ((RANGE_ROW_COUNTP(range) == 0) || (RANGE_COL_COUNTP(range) == 0))
            return (EX_errGeneralError);

         *iSheet = sheetFirst;
      }
      else {
         return (EX_errGeneralError);
      }
   }

   return (EX_errSuccess);
}

#endif

#ifdef EXCEL_ENABLE_DIMENSION
private int ProcessDimensionsRecord
       (WBP pWorkbook, ExcelDimensions __far *pfunc, byte __far *pRec)
{
   int  rc;
   int  firstRow, lastRow, firstCol, lastCol;

   // Works with workbook or worksheet
   NEED_WORKBOOK (pWorkbook);

   if (pWorkbook->version < versionExcel8) {
      firstRow = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
      lastRow  = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
      firstCol = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
      lastCol  = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
   }
   else {
      firstRow = XLONG(*((long  __far UNALIGNED *)(pRec + 0)));
      lastRow  = XLONG(*((long  __far UNALIGNED *)(pRec + 4)));
      firstCol = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
      lastCol  = XSHORT(*((short __far UNALIGNED *)(pRec + 10)));
   }

   rc = pfunc(firstRow, lastRow, firstCol, lastCol);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_NUMBER_CELL
public void ExcelConvertRK
       (long rk, BOOL __far *isLong, double __far *doubleValue, long __far *longValue)
{
   double  value;

   if ((rk & 0x03) == 0x02) {
      *longValue = (rk >> 2);
      *isLong = TRUE;
      return;
   }

   if (rk & 0x02) {
      value = (double)(rk >> 2);
   }
   else {
      (*(long UNALIGNED *)&value) = 0;
      *(((long UNALIGNED *)&value)+1) = rk & 0xfffffffc;
   }

   if (rk & 0x01)
      value /= 100;

   *doubleValue = value;
   *isLong = FALSE;
}

private long ParseRKRecord
       (byte __far *pRec, EXA_CELL __far *cell, int __far *ixfe,
        BOOL __far *isLong, double __far *doubleValue, long __far *longValue)
{
   long  rk;

   cell->row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell->col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   *ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
   rk        = XLONG(*((long  __far UNALIGNED *)(pRec + 6)));

   ExcelConvertRK (rk, isLong, doubleValue, longValue);
   return (rk);
}

private int DispatchRKRecord (void * pGlobals, ExcelNumberCell __far *pfuncN, byte __far *pRec)
{
   int      rc;
   EXA_CELL cell;
   int      ixfe;
   double   doubleValue;
   long     longValue;
   BOOL     isLong;

   ParseRKRecord (pRec, &cell, &ixfe, &isLong, &doubleValue, &longValue);
   if (isLong == 0)
      rc = pfuncN(pGlobals, cell, ixfe, doubleValue);
   else
      rc = pfuncN(pGlobals, cell, ixfe, (double)longValue);

   return (rc);
}

private int DispatchMulRKRecord (void * pGlobals, ExcelNumberCell __far *pfuncN, byte __far *pRec, RECHDR hdr)
{
   int      rc = EX_errSuccess;
   int      ctRK, iRK;
   EXA_CELL cell;
   int      ixfe;
   long     rk;
   double   doubleValue;
   long     longValue;
   BOOL     isLong;

   cell.row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell.col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   ctRK     = (hdr.length - 6) / 6;

   for (iRK = 0; iRK < ctRK; iRK++) {
      ixfe = XSHORT(*((short __far UNALIGNED *)(pRec + 4 + (iRK * 6))));
      rk   = XLONG(*((long  __far UNALIGNED *)(pRec + 4 + (iRK * 6) + 2)));

      ExcelConvertRK (rk, &isLong, &doubleValue, &longValue);

      if (isLong == 0)
         rc = pfuncN(pGlobals, cell, ixfe, doubleValue);
      else
         rc = pfuncN(pGlobals, cell, ixfe, (double)longValue);

      if (rc != EX_errSuccess)
         return (rc);

      cell.col++;
   }
   return (EX_errSuccess);
}

private long ParseMulRKRecord
       (byte __far *pRec, EXA_CELL cell,
        BOOL __far *isLong, double __far *pDoubleValue, long __far *longValue, int __far *ixfe)
{
   short  firstCol;
   short  iRK;
   long   rk;

   firstCol  = *((short __far *)(pRec + 2));
   iRK = cell.col - firstCol;

   *ixfe = XSHORT(*((short __far UNALIGNED *)(pRec + 4 + (iRK * 6))));
   rk    = XLONG(*((long  __far UNALIGNED *)(pRec + 4 + (iRK * 6) + 2)));

   ExcelConvertRK (rk, isLong, pDoubleValue, longValue);
   return (rk);
}

private void ParseNumberRecord
       (byte __far *pRec, EXA_CELL __far *cell, int __far *ixfe, double __far *pValue)
{
   int resultExp, sign;

   cell->row = XSHORT(*((short  __far UNALIGNED *)(pRec + 0)));
   cell->col = XSHORT(*((short  __far UNALIGNED *)(pRec + 2)));
   *ixfe     = XSHORT(*((short  __far UNALIGNED *)(pRec + 4)));
   *pValue   = XDOUBLE(*((double __far UNALIGNED *)(pRec + 6)));

   _ecvt(*pValue, 4, &resultExp, &sign);
   
   // resultExp <= -299 causes problems on DEC alpha
   if(resultExp <= -299)
       *pValue = 0.0;
}

private int DispatchNumberRecord
       (void * pGlobals, ExcelNumberCell __far *pfunc, byte __far *pRec)
{
   int      rc;
   EXA_CELL cell;
   int      ixfe;
   double   value;

   ParseNumberRecord (pRec, &cell, &ixfe, &value);
   rc = pfunc(pGlobals, cell, ixfe, value);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_BLANK_CELL
private int DispatchBlankRecord
       (ExcelBlankCell __far *pfunc, byte __far *pRec)
{
   int      ixfe;
   EXA_CELL cell;

   cell.row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell.col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));

   return (pfunc(cell, ixfe));
}

private int DispatchMulBlankRecord
       (ExcelBlankCell __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int      rc;
   int      ixfe;
   EXA_CELL cell;
   int      ctBlank, iBlank;

   cell.row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell.col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   ctBlank  = (hdr.length - 6) / 2;

   for (iBlank = 0; iBlank < ctBlank; iBlank++) {
      ixfe = XSHORT(*((short __far UNALIGNED *)(pRec + 4 + (iBlank * 2))));

      rc = pfunc(cell, ixfe);
      if (rc != EX_errSuccess)
         return (rc);

      cell.col++;
   }
   return (EX_errSuccess);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_TEXT_CELL
private int ParseLabelRecord
       (void * pGlobals, WBP pWorkbook, int iRecType, byte __far *pRec, EXA_CELL __far *cell, int __far *ixfe, TEXT *result)
{
   int   rc;
   byte  *pData;
   TCHAR *pResult;
   BOOL  resultOnHeap = FALSE;
   int   iString;
   unsigned int cbData;

   // Works with workbook or worksheet
   NEED_WORKBOOK (pWorkbook);

   /*
   ** For the fields we want this also works for RSTRING cells
   */
   cell->row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell->col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   *ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));

   *result = NULLTEXT;

   if (iRecType == LABEL_V8) {
      if (pWorkbook->pV8StringIndex == NULL)
         return (EX_errSuccess);

      iString = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 6)));

      rc = GetStringPoolEntry(pGlobals, pWorkbook, iString, &pResult, &cbData, &resultOnHeap);
      if (rc != EX_errSuccess)
         return (rc);
   }
   else {
      cbData = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
      pData  = (char  __far *)(pRec + 8);

      if ((cbData == 0) || (*pData == EOS))
         return (EX_errSuccess);

      cbData  = ExcelExtractString(pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pData, cbData);
      pResult = ExcelRecordTextBuffer;
   }

   *result = TextStoragePut(pGlobals, pWorkbook->textStorage, (char *)pResult, cbData);
   if (resultOnHeap)
      MemFree (pGlobals, pResult);

   return (EX_errSuccess);
}

private int DispatchLabelRecord
       (void * pGlobals, WBP pWorkbook, int iRecType, ExcelTextCell __far *pfunc, byte __far *pRec)
{
   int      rc;
   int      ixfe, iString;
   char     *pData;
   TCHAR    *pResult;
   unsigned int cbData;
   BOOL     resultOnHeap = FALSE;
   EXA_CELL cell;

   // Works with workbook or worksheet
   NEED_WORKBOOK (pWorkbook);

   cell.row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell.col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));

   if (iRecType == LABEL_V8) {
      if (pWorkbook->pV8StringIndex != NULL) {
         iString = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));

         rc = GetStringPoolEntry(pGlobals, pWorkbook, iString, &pResult, &cbData, &resultOnHeap);
         if (rc != EX_errSuccess)
            return (rc);
      }
      else {
         return (EX_errSuccess);
      }
   }
   else {
      cbData = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
      pData  = ((char  __far *)(pRec + 8));
      if ((cbData == 0) || (*pData == EOS))
         return (EX_errSuccess);

      cbData = ExcelExtractString(pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pData, cbData);
      pResult  = ExcelRecordTextBuffer;
   }

   rc = pfunc(pGlobals, cell, ixfe, pResult, cbData);

   if (resultOnHeap)
      MemFree (pGlobals, pResult);

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_STRING_CELL
private int ProcessStringRecord
       (void * pGlobals, WBP pWorkbook, ExcelStringCell __far *pfunc, byte __far *pRec)
{
   int   rc;
   TCHAR __far *pResult;
   byte  __far *pString;
   int   cchString;

   // Works with workbook or worksheet

   cchString = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   pString   = pRec + 2;

   if (cchString == 0)
      return (EX_errSuccess);

   if ((rc = ExcelExtractBigString(pGlobals, pWorkbook, &pResult, pString, cchString)) < 0)
      return (rc);

   rc = pfunc(pGlobals, pResult);
   
   if (pResult != ExcelRecordTextBuffer)
      MemFree (pGlobals, pResult);

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_CHART_BIFF
private int ProcessSeriesTextRecord
       (void * pGlobals, WBP pWorkbook, ExcelSeriesText __far *pfunc, byte __far *pRec)
{
   int   rc;
   int   id;
   byte  *pText;
   int   cchText;

   // Works with workbook or worksheet

   id      = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cchText = *((byte  __far *)(pRec + 2));
   pText   =  ((char  __far *)(pRec + 3));

   if (cchText == 0)
      return (EX_errSuccess);

   ExcelExtractString (pWorkbook, ExcelRecordTextBuffer, CCH_RECORD_TEXT_BUFFER_MAX, pText, cchText);

   rc = pfunc(pGlobals, id, ExcelRecordTextBuffer);
   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#if (defined(EXCEL_ENABLE_ERROR_CELL) || defined(EXCEL_ENABLE_BOOLEAN_CELL))
private void ParseBoolerrRecord
       (byte __far *pRec,
        EXA_CELL __far *cell, int __far *ixfe, int __far *pValue, BOOL __far *isBoolean)
{
   byte  value, tag;

   #define CONTAINS_BOOLEAN 0
   #define CONTAINS_ERROR   1

   cell->row = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell->col = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   *ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
   value     = *((byte  __far *)(pRec + 6));
   tag       = *((byte  __far *)(pRec + 7));

   if (tag == CONTAINS_BOOLEAN) {
      *isBoolean = TRUE;
      *pValue = (value == 0) ? FALSE : TRUE;
   }
   else {
      *isBoolean = FALSE;
      *pValue = ExcelConvertToOurErrorCode(value);
   }
}

private int DispatchBooleanRecord
       (ExcelBooleanCell __far *pfunc, byte __far *pRec)
{
   int      ixfe;
   EXA_CELL cell;
   int      value;
   BOOL     isBoolean;

   ParseBoolerrRecord (pRec, &cell, &ixfe, &value, &isBoolean);
   return (pfunc(cell, ixfe, value));
}

private int DispatchErrorRecord
       (ExcelErrorCell __far *pfunc, byte __far *pRec)
{
   int      ixfe;
   EXA_CELL cell;
   int      value;
   BOOL     isBoolean;

   ParseBoolerrRecord (pRec, &cell, &ixfe, &value, &isBoolean);
   return (pfunc(cell, ixfe, value));
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_FORMULA_EXPAND

#define F_COUNT 24
#define C_COUNT 3

static const EXFUNC FunctionsThatWorkWithArrays[F_COUNT] =
              {
                 exfCOLUMN,
                 exfCOLUMNS,
                 exfDOCUMENTS,
                 exfFILES,
                 exfGET_DOCUMENT,
                 exfGET_WINDOW,
                 exfGROWTH,
                 exfHLOOKUP,
                 exfINDEX,
                 exfLINEST,
                 exfLOGEST,
                 exfLOOKUP,
                 exfMATCH,
                 exfMDETERM,
                 exfMINVERSE,
                 exfMMULT,
                 exfNAMES,
                 exfROW,
                 exfROWS,
                 exfSUMPRODUCT,
                 exfTRANSPOSE,
                 exfTREND,
                 exfLOOKUP,
                 exfWINDOWS
              };

static const EXFUNC CEsThatWorkWithArrays[C_COUNT] =
              {
                 excAPPLY_NAMES,
                 excCONSOLIDATE,
                 excWORKGROUP
              };

private BOOL IsNonExpandableFunction (WSP pWorksheet, int ptg, byte __far *pDef)
{
   unsigned int ifunction;
   int  ifunc;
   BOOL isCE;

   // Works with workbook or worksheet

   switch (ptg) {
      case ptgFunc:
         isCE = FALSE;
         if (pWorksheet->version >= versionExcel3)
            ifunction = *pDef;
         else
            ifunction = XSHORT(*((unsigned short __far UNALIGNED *)pDef));
         break;

      case ptgFuncVar:
         isCE = FALSE;
         if (pWorksheet->version >= versionExcel3)
            ifunction = *(pDef + 1);
         else
            ifunction = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 1)));

         if ((ifunction & 0x8000) != 0) {
            isCE = TRUE;
            ifunction &= 0x7fff;
         }
         break;

      case ptgFuncCE:
         isCE = TRUE;
         ifunction = *(pDef + 1);
         break;
   }

   if (isCE == FALSE) {
      for (ifunc = 0; ifunc < F_COUNT; ifunc++) {
         if (FunctionsThatWorkWithArrays[ifunc] == (EXFUNC)ifunction)
            return (TRUE);
      }
   }
   else {
      for (ifunc = 0; ifunc < C_COUNT; ifunc++) {
         if (CEsThatWorkWithArrays[ifunc] == (EXCE)ifunction)
            return (TRUE);
      }
   }
   return (FALSE);
}

private void ConstructRef
       (SFN pFormulaStore, byte __far *pPtgArea, int row, int col,
        unsigned short __far *ptgRef1, byte __far *ptgRef2)
{
   unsigned short firstRow;
   byte   firstCol;
   short  deltaRow, deltaCol;
   BOOL rowRelative = FALSE;
   BOOL colRelative = FALSE;

   /*
   ** Extract the pieces of the ptgArea
   */
   firstRow = XSHORT(*((unsigned short __far UNALIGNED *)(pPtgArea + 0)));
   firstCol = *((byte __far *)(pPtgArea + 4));

   if ((firstRow & 0x8000) != 0)
      rowRelative = TRUE;

   if ((firstRow & 0x4000) != 0)
      colRelative = TRUE;

   firstRow &= 0x3fff;

   deltaRow = row - pFormulaStore->range.firstRow;
   deltaCol = col - pFormulaStore->range.firstCol;

   firstRow = 0x3fff & ((short)firstRow + deltaRow);
   firstCol = firstCol + (byte)deltaCol;

   if (rowRelative == TRUE)
      firstRow |= 0x8000;

   if (colRelative == TRUE)
      firstRow |= 0x4000;

   *ptgRef1 = firstRow;
   *ptgRef2 = firstCol;
}


private int ExpandArrayFormula
       (WSP pWorksheet, int row, int col, SFN pFormulaStore,
        int __far *cbDefinition, int __far *cbExtra, byte __far * __far *pDefinition)
{
   int   iPass;
   byte  __far *pDef;
   byte  __far *pDefNew, __far *pNewDef;
   byte  __far *pLast;
   byte  attrOptions, cbString, tag, iExtend;
   unsigned int dataWord;
   int   ptg, ptgBase, cbPtg;
   unsigned short ptgRef1;
   byte  ptgRef2;
   int   cbNew;

   ASSERTION (pWorksheet->use == IsWorksheet);

   *cbDefinition = pFormulaStore->cbDefinition;
   *pDefinition  = pFormulaStore->definition;
   *cbExtra      = pFormulaStore->cbExtra;

   /*
   ** Expanding array formulas into a series of expressions is not, in
   ** general, possible without error.  Here is what we do:
   **
   ** Make a pass though the formula looking for functions that are
   ** array entered to capture the return value.  An example of this
   ** are the matrix functions (MDETERM, MINVERSE, ...).  For these
   ** functions we just make each cell contain the same expression.
   ** This is wrong but is the best we can do.
   **
   ** For expressions that don't use one of the listed functions
   ** we replace each Range with a Cell.  The cell is constructed to be at
   ** an equal offset from the upper left corner of the array entered
   ** formula block.
   **
   ** For example if the formula sqrt(b1:b5) is entered into A1:A5
   ** then our goal is to build five formulas of the form sqrt(b1),
   ** sqrt(b2), sqrt(b3), sqrt(b4), sqrt(b5).
   ** In general, this may be right in some cases, wrong in others
   ** but is also the best we can do.
   */
   for (iPass = 1; iPass <= 2; iPass++) {
      pDef  = pFormulaStore->definition;
      pLast = pFormulaStore->definition + pFormulaStore->cbDefinition - 1;

      while (pDef <= pLast) {
         ptg = *pDef++;
         ptgBase = PTGBASE(ptg);

         if (ptgBase > PTG_LAST)
            return (EX_errBIFFFormulaUnknownToken);

         if ((cbPtg = pWorksheet->PTGSize[ptgBase]) < 0)
            return (EX_errBIFFFormulaUnknownToken);

         switch (ptgBase) {
            case ptgAttr:
               attrOptions = *pDef;
               dataWord    = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 1)));
               cbPtg = 3;

               if ((attrOptions & bitFAttrChoose) != 0) {
                  cbPtg += ((dataWord + 1) * 2);
                  if ((pDef + cbPtg) > pLast + 1)
                     return (EX_errBIFFFormulaPostfixLength);
               }
               break;

            case ptgStr:
               cbString = *pDef;
               if (pWorksheet->version == versionExcel8) {
                  tag = *(pDef + 1);
                  if (tag == V8_UNICODE_STRING_TAG)
                     cbString *= 2;
                  cbString++;
               }
               cbPtg = cbString + 1;

               if ((pDef + cbPtg) > pLast + 1)
                  return (EX_errBIFFFormulaPostfixLength);
               break;

            case ptgArea:
               ConstructRef(pFormulaStore, pDef, row, col, &ptgRef1, &ptgRef2);
               break;

            case ptgFunc:
            case ptgFuncVar:
            case ptgFuncCE:
               if (IsNonExpandableFunction(pWorksheet, ptgBase, pDef)) {
                  return (EX_errSuccess);
               }
               break;

            case ptgV8Extended:
               iExtend = *((byte __far *)pDef);
               cbPtg = pWorksheet->ExtPTGSize[iExtend] + 1;
               break;
         }

         if (iPass == 2) {
            if (ptgBase == ptgArea) {
               *pDefNew++ = ptgRef;
               cbNew++;
               memcpy (pDefNew, &ptgRef1, sizeof(ptgRef1));
               memcpy (pDefNew + sizeof(ptgRef1), &ptgRef2, sizeof(ptgRef2));
               pDefNew += (sizeof(ptgRef1) + sizeof(ptgRef2));
               cbNew += sizeof(ptgRef1) + sizeof(ptgRef2);
            }
            else {
               *pDefNew++ = ptg;
               cbNew++;
               memcpy (pDefNew, pDef, cbPtg);
               pDefNew += cbPtg;
               cbNew += cbPtg;
            }
         }

         pDef += cbPtg;
      }

      if (iPass == 1) {
         /*
         ** Allocate space to hold the expanded formula.  The new formula
         ** will be equal to or smaller than the new formula as we replace
         ** ptgArea with ptgRef.
         */
         pNewDef = MemAllocate(pFormulaStore->cbDefinition + pFormulaStore->cbExtra);
         if (pNewDef == NULL)
            return (EX_errOutOfMemory);

         pDefNew = pNewDef;
         cbNew = 0;
      }
      else {
         /*
         ** Attach to the end of the formula definition any extra bytes
         */
         if (pFormulaStore->cbExtra > 0)
            memcpy (pDefNew, pFormulaStore->definition + pFormulaStore->cbDefinition, pFormulaStore->cbExtra);

         *cbDefinition = cbNew;
         *pDefinition  = pNewDef;
      }
   }
   return (EX_errSuccess);
}

private int ExpandSharedFormula
       (WSP pWorksheet, unsigned int row, unsigned int col, SFN pFormulaStore,
        int __far *cbDefinition, int __far *cbExtra, byte __far * __far *pDefinition)
{
   byte  __far *pNewFormula;
   byte  __far *pDef, __far *pLast;
   byte  attrOptions, iExtend, cbString, tag;
   int   ptg, ptgBase, cbPtg;
   unsigned int dataWord;
   unsigned int colFirst, colLast, rowFirst, rowLast;

   ASSERTION (pWorksheet->use == IsWorksheet);

   /*
   ** Allocate space to hold the expanded formula.  The new formula is
   ** the same size as the shared formula.
   */
   pNewFormula = MemAllocate(pFormulaStore->cbDefinition + pFormulaStore->cbExtra);
   if (pNewFormula == NULL)
      return (EX_errOutOfMemory);

   memcpy (pNewFormula, pFormulaStore->definition, pFormulaStore->cbDefinition);

   if (pFormulaStore->cbExtra > 0) {
      /*
      ** Attach to the end of the formula definition any extra bytes
      */
      memcpy (pNewFormula + pFormulaStore->cbDefinition,
              pFormulaStore->definition + pFormulaStore->cbDefinition,
              pFormulaStore->cbExtra);
   }

   *cbDefinition = pFormulaStore->cbDefinition;
   *pDefinition  = pNewFormula;
   *cbExtra      = pFormulaStore->cbExtra;

   pDef  = pNewFormula;
   pLast = pNewFormula + pFormulaStore->cbDefinition - 1;

   while (pDef <= pLast) {
      ptg = *pDef++;
      ptgBase = PTGBASE(ptg);

      if (ptgBase > PTG_LAST)
         return (EX_errBIFFFormulaUnknownToken);

      if ((cbPtg = pWorksheet->PTGSize[ptgBase]) < 0)
         return (EX_errBIFFFormulaUnknownToken);

      switch (ptgBase) {
         case ptgAttr:
            attrOptions = *pDef;
            dataWord    = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 1)));
            cbPtg       = 3;

            if ((attrOptions & bitFAttrChoose) != 0) {
               cbPtg += ((dataWord + 1) * 2);
               if ((pDef + cbPtg) > pLast + 1)
                  return (EX_errBIFFFormulaPostfixLength);
            }
            break;

         case ptgStr:
            cbString = *pDef;
            if (pWorksheet->version == versionExcel8) {
               tag = *(pDef + 1);
               if (tag == V8_UNICODE_STRING_TAG)
                  cbString *= 2;
               cbString++;
            }
            cbPtg = cbString + 1;

            if ((pDef + cbPtg) > pLast + 1)
               return (EX_errBIFFFormulaPostfixLength);
            break;

         case ptgArea:
            *(pDef - 1) -= 8;
            rowFirst = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 0)));
            rowLast  = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 2)));
            colFirst = *(pDef + 4);
            colLast  = *(pDef + 5);

            rowFirst = ((rowFirst & 0x3f00) + row) | (rowFirst & 0xc000);
            rowLast  = ((rowLast  & 0x3f00) + row) | (rowLast  & 0xc000);

            *((unsigned short __far UNALIGNED *)(pDef + 0)) = XSHORT(rowFirst);
            *((unsigned short __far UNALIGNED *)(pDef + 2)) = XSHORT(rowLast);
            *(pDef + 4) = colFirst + col;
            *(pDef + 5) = colLast + col;
            break;

         case ptgRef:
            *(pDef - 1) -= 8;
            rowFirst = XSHORT(*((unsigned short __far UNALIGNED *)(pDef + 0)));
            colFirst = *(pDef + 2);

            rowFirst = ((rowFirst & 0x3f00) + row) | (rowFirst & 0xc000);

            *((unsigned short __far UNALIGNED *)(pDef + 0)) = XSHORT(rowFirst);
            *(pDef + 2) = colFirst + col;
            break;

         case ptgV8Extended:
            iExtend = *((byte __far *)pDef);
            cbPtg = pWorksheet->ExtPTGSize[iExtend] + 1;
            break;
      }

      pDef += cbPtg;
   }

   return (EX_errSuccess);
}
#endif

#ifdef EXCEL_ENABLE_FORMULA_CELL

#define DISABLE_STRING_VALUE 0x0000
#define ENABLE_STRING_VALUE  0x0001
#define FREE_REC_BUFFER      0x0002

private int FormulaCurrentValue
       (void * pGlobals, WBP pWorkbook, byte __far *pRec, CV __far *pValue, unsigned int options)
{
   int     rc;
   int     valueTag;
   int     valueMark;
   RECHDR  hdr;
   int     cchString, cbResult;
   byte    __far *pString;
   TCHAR   __far *pResult;
   byte    __far *pNextRec;

   ASSERTION (pWorkbook->use == IsWorkbook);

   valueTag  = *((byte  __far *)(pRec + 6));
   valueMark = XSHORT(*((short __far UNALIGNED *)(pRec + 12)));

   if (valueMark != -1) {
      pValue->flags |= cellvalueNUM;
      pValue->value.IEEEdouble = XDOUBLE(*((double __far UNALIGNED *)(pRec + 6)));
   }

   else {
      switch (valueTag) {
         case vtBool:
            pValue->flags |= cellvalueBOOL;
            pValue->value.boolean = *((byte __far *)(pRec + 8));
            break;

         case vtErr:
            pValue->flags |= cellvalueERR;
            pValue->value.error = ExcelConvertToOurErrorCode(*((byte __far *)(pRec + 8)));
            break;

         case vtText:
            if ((options & ENABLE_STRING_VALUE) == 0)
               break;

            if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
               return (rc);

            if ((hdr.type == ARRAY) || (hdr.type == SHRFMLA)) {
               ExcelSkipRecord (pWorkbook, &hdr);

               if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
                  return (rc);
            }

            if (hdr.type == STRING) {
               pValue->flags |= cellvalueTEXT;

               FREE_RECORD_BUFFER(pRec);
               pRec = NULL;

               if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pNextRec)) != EX_errSuccess || !pNextRec)
                  return (rc);

               cchString = XSHORT(*((unsigned short __far UNALIGNED *)(pNextRec + 0)));
               pString   = ((byte __far *)(pNextRec + 2));

               if ((cbResult = ExcelExtractBigString(pGlobals, pWorkbook, &pResult, pString, cchString)) < 0)
                  return (cbResult);

               FREE_RECORD_BUFFER(pNextRec);

               pValue->value.text = TextStoragePut(pGlobals, pWorkbook->textStorage, (char *)pResult, cbResult);

               if (pResult != ExcelRecordTextBuffer)
                  MemFree (pGlobals, pResult);

               if (pValue->value.text == TEXT_ERROR)
                  return (EX_errOutOfMemory);
            }
            break;
      }
   }

   if (((options & FREE_REC_BUFFER) != 0) && (pRec != NULL))
      FREE_RECORD_BUFFER(pRec);

   return (EX_errSuccess);
}

private int ParseFormulaRecord
       (void * pGlobals, WSP pWorksheet, byte __far *pRec, RECHDR hdr,
        EXA_CELL __far *cell,
        int __far *ixfe, FORM __far *pFormula, CV __far *pValue, EXA_GRBIT __far *options)
{
   int   rc;
   int   cbDefinition, cbFixedPart;
   byte  __far *pDefinition;
   WBP   pWorkbook = (WBP)pWorksheet;

   // Works with workbook or worksheet BUT there are differences

   NEED_WORKBOOK (pWorkbook);

   cell->row = XSHORT(*((short     __far UNALIGNED *)(pRec + 0)));
   cell->col = XSHORT(*((short     __far UNALIGNED *)(pRec + 2)));
   *ixfe     = XSHORT(*((short     __far UNALIGNED *)(pRec + 4)));
   *options  = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 14)));

   if (pValue != NULL) {
      pValue->flags = 0;
      rc = FormulaCurrentValue(pGlobals, pWorkbook, pRec, pValue, DISABLE_STRING_VALUE);
      if (rc != EX_errSuccess)
         return (rc);
   }

   if (hdr.type == FORMULA_V5) {
      cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 20)));
      pDefinition  = ((char __far *)(pRec + 22));
      cbFixedPart  = 22;
   }
   else {
      cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 16)));
      pDefinition  = ((char __far *)(pRec + 18));
      cbFixedPart  = 18;
   }

   #ifdef EXCEL_ENABLE_FORMULA_EXPAND
   {
      short  __far *pDef;
      int    upperLeftRow, upperLeftCol;
      int    cbExtra;
      SFN    pFormulaStore;

      if (pWorksheet->use == IsWorksheet) {
         /*
         ** If this formula is part of an array entered or shared formula then
         ** substitute the definition from the array/shrfmla record
         */
         if (*pDefinition == ptgExp) {
            pDef = (short __far *)(pDefinition + 1);
            upperLeftRow = *pDef++;
            upperLeftCol = *pDef;

            pFormulaStore = pWorksheet->pPly->pSharedFormulaStore;
            while (pFormulaStore != NULL) {
               if ((pFormulaStore->range.firstRow == upperLeftRow) &&
                  (pFormulaStore->range.firstCol == upperLeftCol))
               {
                  if (pFormulaStore-> iType == typeARRAY_ENTERED) {
                     *options |= fArrayFormula;

                     rc = ExpandArrayFormula
                         (pWorksheet, cell->row, cell->col, pFormulaStore, &cbDefinition, &cbExtra, &pDefinition);
                  }
                  else {
                     rc = ExpandSharedFormula
                         (pWorksheet, cell->row, cell->col, pFormulaStore, &cbDefinition, &cbExtra, &pDefinition);
                  }

                  if (rc != EX_errSuccess)
                     return (rc);

                  hdr.length -= (pWorksheet->PTGSize[ptgExp] + 1);
                  hdr.length += (cbDefinition + cbExtra);
                  break;
               }
               pFormulaStore = pFormulaStore->next;
            }
         }
      }
   }
   #endif

   rc = BreakoutFormulaParts(pGlobals, pWorksheet, hdr.length - cbFixedPart, pDefinition, cbDefinition, pFormula);
   return (rc);
}

private int DispatchFormulaRecord
       (void * pGlobals, WBP pWorkbook, ExcelFormulaCell __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int       rc;
   int       ixfe;
   EXA_CELL  cell;
   FORM      formula;
   EXA_GRBIT options;
   CV        value;

   // Works with workbook or worksheet

   rc = ParseFormulaRecord(pGlobals, (WSP)pWorkbook, pRec, hdr, &cell, &ixfe, &formula, &value, &options);
   if (rc != EX_errSuccess)
      return (rc);

   rc = pfunc(pGlobals, cell, ixfe, options, &formula, &value);

   if (formula.arrayConstants != NULL)
      FreeArrayConstantList (pGlobals, formula.arrayConstants);

   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_FORMULA_EXPAND
private int SaveSharedFormula
       (WSP pWorksheet, int iType, EXA_RANGE __far *range,
        int cbDefinition, int cbExtra, byte __far *pDefinition)
{
   SFN  pSharedNode;
   SFN  pCurrentShared, pPrevShared;

   ASSERTION (pWorksheet->use == IsWorksheet);

   pSharedNode = MemAllocate(sizeof(SharedFormulaNode) + cbDefinition + cbExtra);
   if (pSharedNode == NULL)
      return (EX_errOutOfMemory);

   pCurrentShared = pWorksheet->pPly->pSharedFormulaStore;
   pPrevShared    = NULL;

   while (pCurrentShared != NULL) {
      if (pCurrentShared->range.firstCol > range->firstCol)
         break;

      if ((pCurrentShared->range.firstCol == range->firstCol) &&
         (pCurrentShared->range.firstRow >  range->firstRow))
         break;

      pPrevShared = pCurrentShared;
      pCurrentShared = pCurrentShared->next;
   }

   if (pPrevShared == NULL) {
      pSharedNode->next = pWorksheet->pPly->pSharedFormulaStore;
      pWorksheet->pPly->pSharedFormulaStore = pSharedNode;
   }
   else {
      pSharedNode->next = pCurrentShared;
      pPrevShared->next = pSharedNode;
   }

   pSharedNode->iType          = iType;
   pSharedNode->range.firstRow = range->firstRow;
   pSharedNode->range.lastRow  = range->lastRow;
   pSharedNode->range.firstCol = range->firstCol;
   pSharedNode->range.lastCol  = range->lastCol;
   pSharedNode->cbDefinition   = cbDefinition;
   pSharedNode->cbExtra        = cbExtra;

   memcpy (pSharedNode->definition, pDefinition, cbDefinition + cbExtra);
   return (EX_errSuccess);
}
#endif

#ifdef EXCEL_ENABLE_ARRAY_FORMULA_CELL
private int ParseArrayRecord
       (void * pGlobals, WBP pWorkbook, byte __far *pRec, RECHDR hdr,
        EXA_RANGE __far *range, FORM __far *pFormula, EXA_GRBIT __far *options)
{
   int   rc;
   int   cbDefinition, cbFixedPart;
   byte  __far *pDefinition;

   // Works with workbook or worksheet BUT there are differences

   range->firstRow = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   range->lastRow  = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   range->firstCol = *((byte  __far *)(pRec + 4));
   range->lastCol  = *((byte  __far *)(pRec + 5));
   *options        = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 6)));

   if (pWorkbook->version >= versionExcel5) {
      cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 12)));
      pDefinition  = ((byte  __far *)(pRec + 14));
      cbFixedPart  = 14;
   }
   else {
      cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
      pDefinition  = ((byte  __far *)(pRec + 10));
      cbFixedPart  = 10;
   }

   #ifdef EXCEL_ENABLE_FORMULA_EXPAND
   {
      int cbExtra = hdr.length - (cbDefinition + cbFixedPart);

      if (pWorkbook->use == IsWorksheet)
         rc = SaveSharedFormula((WSP)pWorkbook, typeARRAY_ENTERED, range, cbDefinition, cbExtra, pDefinition);
   }
   #endif

   rc = BreakoutFormulaParts
       (pGlobals, (WSP)pWorkbook, hdr.length - cbFixedPart, pDefinition, cbDefinition, pFormula);

   return (rc);
}

private int DispatchArrayRecord
       (void * pGlobals, WBP pWorkbook, ExcelArrayFormulaCell __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int       rc;
   EXA_RANGE range;
   FORM      formula;
   EXA_GRBIT options;

   // Works with workbook or worksheet

   rc = ParseArrayRecord(pGlobals, pWorkbook, pRec, hdr, &range, &formula, &options);
   if (rc != EX_errSuccess)
      return (rc);

   rc = pfunc(pGlobals, range, options, &formula);

   if (formula.arrayConstants != NULL)
      FreeArrayConstantList (pGlobals, formula.arrayConstants);

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_SHARED_FORMULA_CELL
private int ParseShrfmlaRecord
       (WSP pWorksheet, byte __far *pRec, RECHDR hdr, EXA_RANGE __far *range, FORM __far *pFormula)
{
   int   rc;
   int   cbDefinition, cbFixedPart;
   byte  __far *pDefinition;

   // Works with workbook or worksheet BUT there are differences

   range->firstRow = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   range->lastRow  = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   range->firstCol = *((byte  __far *)(pRec + 4));
   range->lastCol  = *((byte  __far *)(pRec + 5));

   cbDefinition = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
   pDefinition  = ((byte  __far *)(pRec + 10));
   cbFixedPart  = 10;

   #ifdef EXCEL_ENABLE_FORMULA_EXPAND
   {
      int cbExtra = hdr.length - (cbDefinition + cbFixedPart);

      if (pWorksheet->use == IsWorksheet)
         rc = SaveSharedFormula(pWorksheet, typeSHARED, range, cbDefinition, cbExtra, pDefinition);
   }
   #endif

   rc = BreakoutFormulaParts(pWorksheet, hdr.length - cbFixedPart, pDefinition, cbDefinition, pFormula);
   return (rc);
}

private int DispatchShrfmlaRecord
       (WSP pWorksheet, ExcelSharedFormulaCell __far *pfunc, byte __far *pRec, RECHDR hdr)
{
   int       rc;
   EXA_RANGE range;
   FORM      formula;

   // Works with workbook or worksheet

   rc = ParseShrfmlaRecord(pWorksheet, pRec, hdr, &range, &formula);
   if (rc != EX_errSuccess)
      return (rc);

   rc = pfunc(range, &formula);

   if (formula.arrayConstants != NULL)
      FreeArrayConstantList (formula.arrayConstants);

   return (rc);
}
#endif

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_NOTE
private int ProcessNoteRecord
       (void * pGlobals, int recType, WBP pWorkbook, ExcelCellNote __far *pfunc, byte __far *pRec)
{
   int      rc;
   EXA_CELL cell;
   TCHAR    __far *pResult;
   char     __far *pString;
   int      cchString, cbString;
   int      isSound, version;
   RECHDR   hdr;

   NEED_WORKBOOK(pWorkbook);

   if ((pWorkbook->version == versionExcel8) && (recType == NOTE))
      return (EX_errSuccess);

   cell.row  = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   cell.col  = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));

   cchString = pWorkbook->currentRecordLen - 6;
   //cchString = XSHORT(*((short __far UNALIGNED *)(pRec + 4))) + GetNoteExtra(pGlobals);
   
   pString   = ((char __far *)(pRec + 6));
   isSound   = FALSE;

   if (cchString == 0) {
      if ((rc = ExcelPeekRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
         return (rc);

      if (hdr.type == SOUND)
         isSound = TRUE;

      return (pfunc(pGlobals, cell, NULL, cchString, isSound));
   }

   if (recType == EXPORT_NOTE) {
      // EXPORT_NOTE text not marked with tag byte like other v8 records
      version = pWorkbook->version;
      pWorkbook->version = versionExcel4;
   }

   cbString = ExcelExtractBigString(pGlobals, pWorkbook, &pResult, pString, cchString);

   if (recType == EXPORT_NOTE)
      pWorkbook->version = version;

   if (cbString < 0)
      return (cbString);

   rc = pfunc(pGlobals, cell, pResult, cbString, isSound);

   if (pResult != ExcelRecordTextBuffer)
      MemFree (pGlobals, pResult);

   return (rc);
}
#endif


#ifdef EXCEL_ENABLE_SCENARIO
private int ProcessScenarioRecord
       (void * pGlobals, WBP pWorkbook, ExcelScenario __far *pfunc, byte __far *pRec)
{
   int       rc;
   int       ctCells, i;
   byte      locked, hidden;
   int       cchName, cchComment, cchUserName;
   int       cbName, cbComment, cbUserName;
   char      __far *pName;
   char      __far *pUserName;
   char      __far *pComment;
   byte      __far *pCellRefs;
   char      __far *pValues;
   EXA_CELL  __far *pRefs;
   EXA_CELL  __far *pRef;
   EXA_GRBIT grbit;
   TCHAR     name[EXCEL_MAX_TEXT_LEN + 1];
   TCHAR     userName[EXCEL_MAX_TEXT_LEN + 1];
   TCHAR     comment[EXCEL_MAX_TEXT_LEN + 1];

   // Works with workbook or worksheet

   ctCells     = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
   locked      = *((byte  __far *)(pRec + 2));
   hidden      = *((byte  __far *)(pRec + 3));
   cchName     = *((byte  __far *)(pRec + 4));
   cchComment  = *((byte  __far *)(pRec + 5));
   cchUserName = *((byte  __far *)(pRec + 6));

   grbit = 0;
   if (locked != 0)
      grbit |= scenarioLocked;
   if (hidden != 0)
      grbit |= scenarioHidden;

   pName = (char __far *)(pRec + 7);

   if (pWorkbook->version < versionExcel8) {
      cbName     = cchName;
      pUserName  = pName + cbName + 1;
      cbUserName = cchUserName + 1;
      pComment   = pUserName + cchUserName + 1;
      cbComment  = cchComment + 1;
   }
   else {
      cbName     = (*pName == V8_UNICODE_STRING_TAG) ? cchName * sizeof(wchar_t) : cchName;
      pUserName  = pName + (cbName + 1) + 2;
      cbUserName = (*pUserName == V8_UNICODE_STRING_TAG) ? cchUserName * sizeof(wchar_t) : cchUserName;
      pComment   = pUserName + (cbUserName + 1) + 2;
      cbComment  = (*pComment == V8_UNICODE_STRING_TAG) ? cchComment * sizeof(wchar_t) : cchComment;
   }

   ExcelExtractString (pWorkbook, name, sizeof(name) / sizeof(TCHAR), pName, cchName);
   ExcelExtractString (pWorkbook, userName, sizeof(userName) / sizeof(TCHAR), pUserName, cchUserName);
   ExcelExtractString (pWorkbook, comment, sizeof(comment) / sizeof(TCHAR), pComment, cchComment);

   pCellRefs = (byte __far *)(pRec + 7 + cbName + cbComment + cbUserName);
   pValues   = (char __far *)(pCellRefs + (ctCells * 4));

   if ((pRefs = MemAllocate(pGlobals, ctCells * sizeof(EXA_CELL))) == NULL)
      return (EX_errOutOfMemory);

   pRef = pRefs;
   for (i = 0; i < ctCells; i++) {
      pRef->row = XSHORT(*(unsigned short __far UNALIGNED *)(pCellRefs + 0));
      pRef->col = XSHORT(*(short __far UNALIGNED *)(pCellRefs + 2));
      pCellRefs += 4;
      pRef++;
   }

   rc = pfunc(pGlobals, name, comment, userName, grbit, ctCells, pRefs, pValues);
   MemFree (pGlobals, pRefs);

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_DOC_ROUTING
private int ProcessDocRouteRecord
       (WBP pWorkbook, ExcelDocRoute __far *pfunc, byte __far *pRec)
{
   int        ctRecipients, iDeliveryType;
   EXA_GRBIT  options;
   int        cbSubject, cbMessage, cbRouteId, cbCustType;
   int        cbTitle, cbOriginator;
   char __far *pData;
   char __far *pSubject;
   char __far *pMessage;
   char __far *pTitle;
   char __far *pOriginator;

   // Works with workbook or worksheet

   ctRecipients  = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
   iDeliveryType = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
   options       = XSHORT(*((short __far UNALIGNED *)(pRec + 6)););

   cbSubject     = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
   cbMessage     = XSHORT(*((short __far UNALIGNED *)(pRec + 10)));
   cbRouteId     = XSHORT(*((short __far UNALIGNED *)(pRec + 12)));
   cbCustType    = XSHORT(*((short __far UNALIGNED *)(pRec + 14)));
   cbTitle       = XSHORT(*((short __far UNALIGNED *)(pRec + 16)));
   cbOriginator  = XSHORT(*((short __far UNALIGNED *)(pRec + 18)));

   pData = pRec + 24;

   pSubject = pData;     /* Subject */
   pData += cbSubject;

   pMessage = pData;     /* Message */
   pData += cbMessage;

   pData += cbRouteId;   /* Route ID */

   pData += cbCustType;  /* Custom message type */

   pTitle = pData;       /* Book title */
   pData += cbTitle;

   pOriginator = pData;  /* Originators friendly name */

   return (pfunc(ctRecipients, iDeliveryType, options, pSubject, pMessage, pTitle, pOriginator));
}

private int ProcessRecipNameRecord
       (WBP pWorkbook, ExcelRecipientName __far *pfunc, byte __far *pRec)
{
   char __far *pName;

   // Works with workbook or worksheet

   pName = ((char __far *)(pRec + 6));
   return (pfunc(pName));
}
#endif

#ifdef EXCEL_ENABLE_OBJECT
private int GetFormula
       (void * pGlobals, WBP pWorkbook, byte __far *pRec, unsigned int infoOffset, unsigned int cbFormula, FRMP pFormula)
{
   int  rc;
   unsigned int cbExp;
   byte __far *pExp;

   // Works with workbook or worksheet

   if (cbFormula == 0)
      return (EX_errSuccess);

   cbExp = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
   pExp  = (byte __far *)(pRec + infoOffset + 6);

   rc = BreakoutFormulaParts(pGlobals, (WSP)pWorkbook, cbExp, pExp, cbExp, pFormula);
   return (rc);
}

typedef struct {
   short V5Offset;
   short V4Offset;
   short decode;
} OBJDECODE;

#define OBJ_HAS_TEXT        0x0100
#define OBJ_SIZE_FORMULA    0x0200
#define OBJ_SIZE_TEXT       0x0400
#define OBJ_CT_FORMULA_MASK 0x00FF

static const OBJDECODE ObjectDecode[] =
       {
        /* otGroup        */ {22, 22, 1},
        /* otLine         */ { 8,  8, 1},
        /* otRectangle    */ {10, 10, 1},
        /* otOval         */ {10, 10, 1},
        /* otArc          */ {10, 10, 1},
        /* otChart        */ {28, 28, 1},
        /* otText         */ {36, 32, OBJ_HAS_TEXT | 1},
        /* otButton       */ {36, 32, OBJ_HAS_TEXT | 1},
        /* otPicture      */ {26, 22, 1},
        /* otPolygon      */ {32, 32, 1},
        /* unused         */ { 0,  0, 0},
        /* otCheckbox     */ {42, 42, OBJ_HAS_TEXT | OBJ_SIZE_FORMULA | OBJ_SIZE_TEXT | 2},
        /* otOptionButton */ {54, 54, OBJ_HAS_TEXT | OBJ_SIZE_FORMULA | OBJ_SIZE_TEXT | 2},
        /* otEditBox      */ {36, 36, OBJ_HAS_TEXT | OBJ_SIZE_FORMULA | OBJ_SIZE_TEXT | 1},
        /* otLabel        */ {36, 32, OBJ_HAS_TEXT | 1},
        /* otDialogFrame  */ {36, 32, OBJ_HAS_TEXT | 1},
        /* otSpinner      */ {30, 30, OBJ_SIZE_FORMULA | 2},
        /* otScrollBar    */ {30, 30, OBJ_SIZE_FORMULA | 2},
        /* otListBox      */ {54, 54, OBJ_SIZE_FORMULA | 3},
        /* otGroupBox     */ {48, 48, OBJ_HAS_TEXT | OBJ_SIZE_FORMULA | OBJ_SIZE_TEXT | 1},
        /* otDropDown     */ {76, 76, OBJ_SIZE_FORMULA | 3}
       };

private int ProcessV8ObjectRecord
       (void * pGlobals, WBP pWorkbook, ExcelObject __far *pfunc, byte __far *pRec, unsigned int cbRecord)
{
   int     rc;
   long    currentPos;
   OBJINFO info;
   RECHDR  hdr;
   byte    __far *pText;
   byte    __far *pNextRec;
   unsigned short cchText;

   if (WORKBOOK_IN_MEMORY(pWorkbook))
      return (EX_errMemoryImageNotSupported);

   NEED_WORKBOOK (pWorkbook);

   memset (&info, 0, sizeof(OBJINFO));

   BFGetFilePosition (pWorkbook->hFile, &currentPos);

   hdr.type = 0;
   while ((hdr.type != OBJ) && (hdr.type != EOF)) {
      if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
         return (rc);

      if (hdr.type == TXO_V8) {
         if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pNextRec)) != EX_errSuccess || !pNextRec)
            return (rc);

         cchText = *((unsigned short __far UNALIGNED *)(pNextRec + 10));
         pText   = pNextRec + 18;

         rc = ExcelExtractBigString(pGlobals, pWorkbook, &(info.pText), pText, cchText);

         if (rc < 0)
            return (rc);

         FREE_RECORD_BUFFER(pNextRec);
         break;
      }
      else {
         if ((rc = ExcelSkipRecord(pWorkbook, &hdr)) != EX_errSuccess)
            return (rc);
      }
   }

   BFSetFilePosition (pWorkbook->hFile, FROM_START, currentPos);

   if (info.pText == NULL)
      return (EX_errSuccess);

   rc = pfunc(pGlobals, otText, 0, &info);

   if (info.pText != ExcelRecordTextBuffer)
        MemFree (pGlobals, info.pText);

   return (rc);
}

private int ProcessObjectRecord
       (void * pGlobals, WBP pWorkbook, ExcelObject __far *pfunc, byte __far *pRec, unsigned int cbRecord)
{
   int     rc;
   int     iType, id;
   unsigned int cbRef, cbFormula, cchText, cbName, cbExp;
   unsigned int cbRuns;
   unsigned int ctFormulas;
   unsigned int infoOffset, textOffset, typeStartOffset;
   unsigned int hasUserName;
   byte    __far *pExp;
   byte    __far *pRef;
   byte    __far *pPictureData;
   OBJINFO info;
   char    *pAnsi;
   char    temp[EXCEL_MAX_NAME_LEN + 1];

   #ifdef UNICODE
   TCHAR  *pUnicode = NULL;
   #endif

   #define WordAlign(x) (((((x) / 2) * 2) == (x)) ? (x) : (x) + 1)

   #define V4_SPECIFIC_START_OFFSET 30
   #define V5_SPECIFIC_START_OFFSET 34

   if (pWorkbook->version == versionExcel8)
      return (ProcessV8ObjectRecord(pGlobals, pWorkbook, pfunc, pRec, cbRecord));

   // Works with workbook or worksheet

   if (pWorkbook->version >= versionExcel5)
      typeStartOffset = V5_SPECIFIC_START_OFFSET;
   else
      typeStartOffset = V4_SPECIFIC_START_OFFSET;

   memset (&info, 0, sizeof(info));

   if (!pRec)
      return (EX_errSuccess);
   iType = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
   id    = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
   cbRef = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 26)));

   if (pWorkbook->version >= versionExcel5)
      hasUserName = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 30)));

   if ((iType < 0) || (iType >= otUnknown) || (iType == otUnused))
      return (EX_errSuccess);

   info.pos.boundingRectangle.firstCol = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 10)));
   info.pos.boundingRectangle.firstRow = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 14)));
   info.pos.boundingRectangle.lastCol  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 18)));
   info.pos.boundingRectangle.lastRow  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 22)));

   info.pos.upperLeftDeltaX  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 12)));
   info.pos.upperLeftDeltaY  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 16)));
   info.pos.lowerRightDeltaX = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 20)));
   info.pos.lowerRightDeltaY = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 24)));

   cchText = 0;

   if (pWorkbook->version >= versionExcel5)
      infoOffset = typeStartOffset + ObjectDecode[iType].V5Offset;
   else
      infoOffset = typeStartOffset + ObjectDecode[iType].V4Offset;

   switch (iType) {
      case otText:
      case otButton:
      case otLabel:
      case otDialogFrame:
         cchText = XSHORT(*((short __far UNALIGNED *)(pRec + typeStartOffset + 10)));
         break;

      case otPicture:
         pPictureData = pRec + typeStartOffset;
         info.picture.fillBackColor = *((byte __far *)(pPictureData + 0));
         info.picture.fillForeColor = *((byte __far *)(pPictureData + 1));
         info.picture.fillPattern   = *((byte __far *)(pPictureData + 2));
         info.picture.isFillAuto    = *((byte __far *)(pPictureData + 3));
         info.picture.lineColor     = *((byte __far *)(pPictureData + 4));
         info.picture.lineStyle     = *((byte __far *)(pPictureData + 5));
         info.picture.lineWeight    = *((byte __far *)(pPictureData + 6));
         info.picture.isLineAuto    = *((byte __far *)(pPictureData + 7));
         info.picture.hasShadow     = *((byte __far *)(pPictureData + 8));
         break;
   }

   /*
   ** Excel does a very strange thing with text box objects whose text is
   ** real long.  Rather then split the record into a series of continue
   ** records that once glued together look like the Object record, Excel
   ** stores all the object record fields in the OBJ record and some of
   ** the text.  The text is then continued in subsequent continue
   ** records.  The problem here is that the text contents are split
   ** because the list of TXORUNS structures is stored at the end of
   ** the OBJ record.  Code is added to remove the TOXRUNS structures
   ** and reassemble the text into one un-interrupted string.
   */
   if (pWorkbook->version == versionExcel3) {
      if ( (cbRef > 0) && 
           (cbRef <= EXCEL_MAX_NAME_LEN + 1) && 
           (infoOffset + cbRef <= cbRecord) ) {
         pRef = (byte __far *)(pRec + infoOffset);

         memcpy (temp, pRef + 1, cbRef - 1);
         temp[cbRef - 1] = EOS;

         #ifdef UNICODE
            info.v3MacroFormula = NULL;
         #else
            info.v3MacroFormula = temp;
         #endif
      }

      textOffset = infoOffset + cbRef;
      textOffset = WordAlign(textOffset);

      if ((cchText > 0) && (textOffset + cchText <= cbRecord)) {
         if ((iType == otText) && (cbRecord > (MAX_EXCEL_REC_LEN - 4))) {
            cbRuns = XSHORT(*((short __far UNALIGNED *)(pRec + typeStartOffset + 14)));

            if ( cbRuns >= (MAX_EXCEL_REC_LEN - 4) ) 
                return EX_errGeneralError;

            memmove (pRec + (MAX_EXCEL_REC_LEN - 4) - cbRuns,
                     pRec + (MAX_EXCEL_REC_LEN - 4),
                     cbRecord - (MAX_EXCEL_REC_LEN - 4));
         }
         pAnsi = (char __far *)(pRec + textOffset);
         *(pAnsi + cchText) = EOS;

         #ifdef UNICODE
            if ((pUnicode = MemAllocate(pGlobals, (cchText + 1) * sizeof(wchar_t))) == NULL)
               return (EX_errOutOfMemory);
            MultiByteToWideChar(CP_ACP, 0, pAnsi, strlen(pAnsi) + 1, pUnicode, cchText);
            info.pText = pUnicode;
         #else
            info.pText = pAnsi;
         #endif
      }
   }

   else if (pWorkbook->version == versionExcel4) {
      if ((cbRef > 0) && (infoOffset + cbRef <= cbRecord)) {
         cbExp = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
         pExp  = (byte __far *)(pRec + infoOffset + 6);

         rc = BreakoutFormulaParts(pGlobals, (WSP)pWorkbook, cbExp, pExp, cbExp, &info.macroFormula);
         if (rc != EX_errSuccess)
            return (rc);
      }

      textOffset = infoOffset + cbRef;

      if ((cchText > 0) && (textOffset + cchText <= cbRecord)) {
         if ((iType == otText) && (cbRecord > (MAX_EXCEL_REC_LEN - 4))) {
            cbRuns = XSHORT(*((short __far UNALIGNED *)(pRec + typeStartOffset + 14)));

            if ( cbRuns >= (MAX_EXCEL_REC_LEN - 4) ) 
                return EX_errGeneralError;

            memmove (pRec + (MAX_EXCEL_REC_LEN - 4) - cbRuns,
                     pRec + (MAX_EXCEL_REC_LEN - 4),
                     cbRecord - (MAX_EXCEL_REC_LEN - 4));
         }
         pAnsi = (char __far *)(pRec + textOffset);
         *(pAnsi + cchText) = EOS;

         #ifdef UNICODE
            if ((pUnicode = MemAllocate(pGlobals, (cchText + 1) * sizeof(wchar_t))) == NULL)
               return (EX_errOutOfMemory);
            MultiByteToWideChar(CP_ACP, 0, pAnsi, strlen(pAnsi) + 1, pUnicode, cchText);
            info.pText = pUnicode;
         #else
            info.pText = pAnsi;
         #endif
      }
   }
   else {
      if (hasUserName != 0) {
         if ((cbName = *((byte __far *)(pRec + infoOffset))) > 0) {
            memcpy (temp, (char __far *)(pRec + infoOffset + 1), cbName);
            *(temp + cbName) = EOS;

            #ifdef UNICODE
               info.pName = NULL;
            #else
               info.pName = temp;
            #endif
         }
         infoOffset += cbName + 1;
         infoOffset = WordAlign(infoOffset);
      }

      ctFormulas = ObjectDecode[iType].decode & OBJ_CT_FORMULA_MASK;

      if (infoOffset <= cbRecord) {
         if ((ObjectDecode[iType].decode & OBJ_SIZE_FORMULA) != 0) {
            cbFormula = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
            infoOffset += 2;
         }
         else {
            cbFormula = cbRef;
         }
      }

      if (infoOffset <= cbRecord) {
         rc = GetFormula(pGlobals, pWorkbook, pRec, infoOffset, cbFormula, &info.macroFormula);
         if (rc != EX_errSuccess)
            return (rc);

         infoOffset += cbFormula;
      }

      if ((ctFormulas > 1) && (infoOffset <= cbRecord)) {
         cbFormula  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
         infoOffset += 2;

         rc = GetFormula(pGlobals, pWorkbook, pRec, infoOffset, cbFormula, &info.cellLinkFormula);
         if (rc != EX_errSuccess)
            return (rc);

         infoOffset += cbFormula;
      }

      if ((ctFormulas > 2) && (infoOffset <= cbRecord)) {
         cbFormula  = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
         infoOffset += 2;

         rc = GetFormula(pGlobals, pWorkbook, pRec, infoOffset, cbFormula, &info.inputRangeFormula);
         if (rc != EX_errSuccess)
            return (rc);

         infoOffset += cbFormula;
      }

      if (infoOffset <= cbRecord) {
         if ((ObjectDecode[iType].decode & OBJ_SIZE_TEXT) != 0) {
            cchText = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + infoOffset)));
            infoOffset += 2;
         }
      }

      if (infoOffset <= cbRecord) {
         if ((ObjectDecode[iType].decode & OBJ_HAS_TEXT) != 0) {
            if ((iType == otText) && (cbRecord > (MAX_EXCEL_REC_LEN - 4))) {
               cbRuns = XSHORT(*((short __far UNALIGNED *)(pRec + typeStartOffset + 14)));

               if ( cbRuns >= (MAX_EXCEL_REC_LEN - 4) ) 
                   return EX_errGeneralError;

               memmove (pRec + (MAX_EXCEL_REC_LEN - 4) - cbRuns,
                        pRec + (MAX_EXCEL_REC_LEN - 4),
                        cbRecord - (MAX_EXCEL_REC_LEN - 4));
            }
            pAnsi = (char __far *)(pRec + infoOffset);
            *(pAnsi + cchText) = EOS;

            #ifdef UNICODE
               if ((pUnicode = MemAllocate(pGlobals, (cchText + 1) * sizeof(wchar_t))) == NULL)
                  return (EX_errOutOfMemory);
               MultiByteToWideChar(CP_ACP, 0, pAnsi, strlen(pAnsi) + 1, pUnicode, cchText);
               info.pText = pUnicode;
            #else
               info.pText = pAnsi;
            #endif
         }
      }
   }

   rc = pfunc(pGlobals, iType, id, &info);

   #ifdef UNICODE
      if (pUnicode != NULL)
         MemFree (pGlobals, pUnicode);
   #endif

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_IMAGE_DATA
private int ProcessImageDataRecord
       (ExcelImageData __far *pfunc, IMHDR __far *pHeader, byte __huge *pRec, HGLOBAL hRec)
{
   int   rc;
   byte  __far *pData;

   if (pRec != NULL)
      pData = ((byte __huge *)(pRec + 8));
   else
      pData = NULL;

   rc = pfunc(pHeader->format, pHeader->environment, pHeader->cbData, pData, hRec);
   return (rc);
}
#endif

private int ProcessEOFRecord
       (void * pGlobals, ExcelEOF __far *pfunc, byte __far *pRec)
{
   return (pfunc(pGlobals));
}

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_STRING_POOL_SCAN
private int ProcessStringPoolRecord
       (void * pGlobals, WBP pWorkbook, ExcelStringPool __far *pfunc, byte __far *pRec, unsigned int cbRecord)
{
   int rc;
   int iString = 0;
   int ctTotalStrings;
   unsigned int cbRemaining;
   unsigned int cbString;
   TCHAR     __far *pString;
   PoolInfo poolInfo;
   BOOL     stringOnHeap;

   ASSERTION (pWorkbook->use == IsWorkbook);

   ctTotalStrings = XLONG(*((long __far UNALIGNED *)(pRec + 4)));
   pRec += (sizeof(long) * 2);
   cbRemaining = cbRecord - (sizeof(long) * 2);

   poolInfo.pRec = pRec;
   poolInfo.cbRemaining = cbRemaining;

   while (iString < ctTotalStrings)
   {
      rc = ExcelStringPoolNextString(pGlobals, pWorkbook, &poolInfo, &pString, &cbString, &stringOnHeap);
      if (rc != EX_errSuccess)
         return (rc);

      rc = pfunc(pGlobals, ctTotalStrings, iString++, cbString, pString);
      if (rc != EX_errSuccess)
         return (rc);

      if (stringOnHeap)
         MemFree (pGlobals, pString);
   }
   return (EX_errSuccess);
}
#endif

/*---------------------------------------------------------------------------*/

private int LoadStringIndex (void * pGlobals, WBP pWorkbook, RECHDR __far *hdr)
{
   int  rc;
   byte    __far *pRec;
   SPIndex __far *pStringIndex;

   ASSERTION (pWorkbook->use == IsWorkbook);

   if ((pStringIndex = MemAllocate(pGlobals, sizeof(SPIndex))) == NULL)
      return (EX_errOutOfMemory);

   if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, hdr, &pRec)) != EX_errSuccess) {
      MemFree (pGlobals, pStringIndex);
      return (rc);
   }

   /*## Needed due to bug in Excel build 2407 (and maybe later) */
   hdr->length = min(hdr->length, sizeof(SPIndex));

   #ifndef MAC
   memcpy (pStringIndex, pRec, min(sizeof(SPIndex), hdr->length));
   #else
   {
      int i;

      pStringIndex->granularity = XSHORT(*((short __far UNALIGNED *)pRec));
      pRec += sizeof(short);

      for (i = 0; i < SP_INDEX_ENTRY; i++) {
         pStringIndex->entry[i].offset = XLONG(*((long __far UNALIGNED *)(pRec + 0)));
         pStringIndex->entry[i].blockOffset = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
         pRec += sizeof(SPIndexEntry);
      }
   }
   #endif

   pWorkbook->pV8StringIndex = pStringIndex;

   return (EX_errSuccess);
}

/*---------------------------------------------------------------------------*/

private int LoadCellIndex (void * pGlobals, WBP pWorkbook, WPP pPly, RECHDR __far *hdr)
{
   int       rc, i, j;
   int       ctRowBlocks;
   int       row, firstCol, lastCol;
   int       iRow;
   short     height, ixfe;
   long      currentPosition;
   long      cellRelOffset, cellAbsOffset;
   long      rowRecsPos;
   long      DBCellRecPos, rowRecPos, cellIndexRecPos;
   long      __far UNALIGNED *pFilePos;
   unsigned short __far *pRowCellOffsets;
   byte      __far *pRec;
   byte      __far *pDBCellRecord = NULL;
   byte      __far *pCellIndexRecord = NULL;
   RBP       pRowBlock;
   RECHDR    rowHdr, DBCellHdr;
   EXA_GRBIT grbit;

   ASSERTION (pWorkbook->use == IsWorkbook);

   if (WORKBOOK_IN_MEMORY(pWorkbook))
      return (EX_errMemoryImageNotSupported);

   BFGetFilePosition (pWorkbook->hFile, &cellIndexRecPos);
   cellIndexRecPos -= sizeof(RECHDR);

   if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, hdr, &pRec)) != EX_errSuccess)
      return (rc);

   BFGetFilePosition (pWorkbook->hFile, &currentPosition);

   if (pWorkbook->version < versionExcel8)
      ctRowBlocks = (hdr->length - 12) / 4;
   else
      ctRowBlocks = (hdr->length - 16) / 4;

   pPly->pCellIndex = MemAllocate(pGlobals, sizeof(CellIndex) + ((ctRowBlocks) * sizeof(RBP)));
   if (pPly->pCellIndex == NULL) {
      FREE_RECORD_BUFFER (pRec);
      return (EX_errOutOfMemory);
   }

   pPly->pCellIndex->ctRowBlocks = (short) ctRowBlocks;
   if (pWorkbook->version < versionExcel8) {
      pPly->pCellIndex->firstRow = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
      pPly->pCellIndex->lastRow  = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
   }
   else {
      pPly->pCellIndex->firstRow = (unsigned short)XLONG(*((long __far UNALIGNED *)(pRec + 4)));
      pPly->pCellIndex->lastRow  = (unsigned short)XLONG(*((long __far UNALIGNED *)(pRec + 8)));
   }
   pPly->pCellIndex->indexRecPos = cellIndexRecPos;
   pPly->pCellIndex->cbIndexRec  = hdr->length;

   pPly->cellIndexRecPos = cellIndexRecPos;


   if ((pCellIndexRecord = MemAllocate(pGlobals, hdr->length)) == NULL) {
      FREE_RECORD_BUFFER (pRec);
      rc = EX_errOutOfMemory;
      goto RejectIndex;
   }
   memcpy (pCellIndexRecord, pRec, hdr->length);
   FREE_RECORD_BUFFER (pRec);

   if (pWorkbook->version < versionExcel8)
      pFilePos = ((long __far UNALIGNED *)(pCellIndexRecord + 12));
   else
      pFilePos = ((long __far UNALIGNED *)(pCellIndexRecord + 16));

   for (i = 0; i < ctRowBlocks; i++) {
      if ((pRowBlock = MemAllocate(pGlobals, sizeof(RowBlock))) == NULL) {
         rc = EX_errOutOfMemory;
         goto RejectIndex;
      }

      pPly->pCellIndex->rowIndex[i] = pRowBlock;
      for (j = 0; j < ROWS_PER_BLOCK; j++)
         pRowBlock->row[j].cellRecsPos = NO_SUCH_ROW;

      if (pWorkbook->version >= versionExcel5) {
         /*
         ** From the index record array take the next dbCell file position
         */
         DBCellRecPos = XLONG(*pFilePos++);
         BFSetFilePosition (pWorkbook->hFile, FROM_START, DBCellRecPos);

         if (ExcelReadRecordHeader(pWorkbook, &DBCellHdr) != EX_errSuccess) {
            rc = NOT_EXPECTED_FORMAT;
            goto RejectIndex;
         }

         if (DBCellHdr.type != DBCELL) {
            rc = NOT_EXPECTED_FORMAT;
            goto RejectIndex;
         }

         rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &DBCellHdr, &pRec);
         if (rc != EX_errSuccess)
            goto RejectIndex;

         if ((pDBCellRecord = MemAllocate(pGlobals, DBCellHdr.length)) == NULL) {
            FREE_RECORD_BUFFER (pRec);
            rc = EX_errOutOfMemory;
            goto RejectIndex;
         }
         memcpy (pDBCellRecord, pRec, DBCellHdr.length);
         FREE_RECORD_BUFFER (pRec);

         pRowBlock->cbDBCellRec  = DBCellHdr.length;
         pRowBlock->DBCellRecPos = DBCellRecPos;

         rowRecsPos = DBCellRecPos - XLONG(*((long __far *)(pDBCellRecord + 0)));
         pRowCellOffsets = ((unsigned short __far *)(pDBCellRecord + 4));
      }

      else {
         rowRecsPos = XLONG(*pFilePos++);
      }

      BFSetFilePosition (pWorkbook->hFile, FROM_START, rowRecsPos + pWorkbook->fileStartOffset);

      cellAbsOffset = 0;
      forever {
         if (ExcelReadRecordHeader(pWorkbook, &rowHdr) != EX_errSuccess) {
            rc = NOT_EXPECTED_FORMAT;
            goto RejectIndex;
         }

         if ((cellAbsOffset == 0) && ((rowHdr.type != ROW) && (rowHdr.type != DBCELL))) {
            rc = NOT_EXPECTED_FORMAT;
            goto RejectIndex;
         }

         if (rowHdr.type != ROW)
            break;

         BFGetFilePosition (pWorkbook->hFile, &rowRecPos);
         rowRecPos -= sizeof(RECHDR);

         rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &rowHdr, &pRec);
         if (rc != EX_errSuccess)
            goto RejectIndex;

         row      = XSHORT(*((unsigned short __far UNALIGNED *)(pRec + 0)));
         firstCol = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
         lastCol  = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
         height   = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
         grbit    = XSHORT(*((EXA_GRBIT __far UNALIGNED *)(pRec + 12)));
         ixfe     = XSHORT(*((short __far UNALIGNED *)(pRec + 14)));

         if (((row - pPly->pCellIndex->firstRow) / ROWS_PER_BLOCK) != i) {
            MemFree (pGlobals, pRowBlock);
            pPly->pCellIndex->rowIndex[i] = NULL;
            break;
         }

         if (pWorkbook->version < versionExcel5)
            cellRelOffset = XSHORT(*((short __far UNALIGNED *)(pRec + 10)));
         else
            cellRelOffset = 0;

         FREE_RECORD_BUFFER(pRec);

         if (pWorkbook->version >= versionExcel5) {
            /*
            ** The cell offset stored in the first row record is the
            ** relative offset from the start of the second row record
            */
            if (cellAbsOffset == 0)
               cellAbsOffset = rowRecsPos + rowHdr.length + sizeof(RECHDR) + XLONG(*pRowCellOffsets++);
            else
               cellAbsOffset += XLONG(*pRowCellOffsets++);
         }
         else {
            /*
            ** The cell offset stored in the first row record is the
            ** relative offset from the start of the second row record
            */
            if (cellAbsOffset == 0)
               cellAbsOffset = rowRecsPos + rowHdr.length + sizeof(RECHDR);

            cellAbsOffset += cellRelOffset;
         }

         iRow = (row - pPly->pCellIndex->firstRow) % ROWS_PER_BLOCK;

         pRowBlock->row[iRow].firstCol    = (short) firstCol;
         pRowBlock->row[iRow].lastCol     = (short) lastCol;
         pRowBlock->row[iRow].height      = height;
         pRowBlock->row[iRow].ixfe        = ixfe;
         pRowBlock->row[iRow].grbit       = grbit;
         pRowBlock->row[iRow].rowRecPos   = rowRecPos;
         pRowBlock->row[iRow].cellRecsPos = cellAbsOffset;
      }

      MemFree (pGlobals, pDBCellRecord);
      pDBCellRecord = NULL;
   }

   MemFree (pGlobals, pCellIndexRecord);
   BFSetFilePosition (pWorkbook->hFile, FROM_START, currentPosition);
   return (EX_errSuccess);

RejectIndex:
   ExcelFreeCellIndex (pGlobals, pPly->pCellIndex);
   pPly->pCellIndex = NULL;

   if (pCellIndexRecord != NULL)
      MemFree (pGlobals, pCellIndexRecord);

   if (pDBCellRecord != NULL)
      MemFree (pGlobals, pDBCellRecord);

   return (rc);
}


private int OpenFilePlySetup (void * pGlobals, WBP pWorkbook, WPP pPly, int openOptions)
{
   int    rc;
   RECHDR hdr;
   byte   __far *pRec;
   int    firstRow, lastRowPlus1;
   int    firstCol, lastColPlus1;
   EXA_GRBIT grbit;

   ASSERTION (pWorkbook->use == IsWorkbook);

   if (pPly->iType != boundWorksheet)
      return (EX_errSuccess);

   /*
   ** Check for a valid sheet and version
   */
   BFSetFilePosition (pWorkbook->hFile, FROM_START, pPly->currentSheetPos);

   if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
      return (NOT_EXPECTED_FORMAT);

   if (!IS_BOF(hdr.type))
      return (EX_errBIFFVersion);

   ExcelSkipRecord (pWorkbook, &hdr);

   /*
   ** Handle index and dimensions
   */
   forever {
      BFGetFilePosition (pWorkbook->hFile, &(pWorkbook->currentRecordPos));

      if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
         break;

      if (hdr.type == FILEPASS) {
         rc = EX_errBIFFPasswordProtected;
         break;
      }

      else if (hdr.type == WSBOOL) {
         rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
         if (rc != EX_errSuccess || !pRec)
            break;

         // See if this is a dialog page ply - this is the only way to test for this

         grbit = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
         if ((grbit & 0x0010) != 0) {
            pPly->range.firstRow = 0;
            pPly->range.firstCol = 0;
            pPly->range.lastRow  = 0;
            pPly->range.lastCol  = 0;
            break;
         }
      }

      else if (hdr.type == INDEX) {
         rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
         if (rc != EX_errSuccess || !pRec)
            break;

         if (pWorkbook->version < versionExcel8) {
            firstRow     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
            lastRowPlus1 = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));
         }
         else {
            firstRow     = XLONG(*((long __far UNALIGNED *)(pRec + 4)));
            lastRowPlus1 = XLONG(*((long __far UNALIGNED *)(pRec + 8)));
         }

         pPly->range.firstCol = 0;
         pPly->range.lastCol  = 0;

         if (firstRow == lastRowPlus1) {
            pPly->range.firstRow = 0;
            pPly->range.lastRow  = 0;
         }
         else {
            pPly->range.firstRow = (short) firstRow;
            pPly->range.lastRow  = lastRowPlus1 - 1;

            // Handle the sheet with one cell case
            if (EMPTY_RANGE(pPly->range))
               pPly->range.lastRow++;
         }

         if ((firstRow != lastRowPlus1) && ((openOptions & EXCEL_LOAD_FILE) == 0))
            pPly->cellIndexRecPos = pWorkbook->currentRecordPos;
      }

      else if (hdr.type == DIMENSIONS) {
         rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
         if (rc != EX_errSuccess || !pRec)
            break;

         if (pWorkbook->version < versionExcel8) {
            firstRow     = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
            lastRowPlus1 = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
            firstCol     = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
            lastColPlus1 = XSHORT(*((short __far UNALIGNED *)(pRec + 6)));

            if (firstRow == lastRowPlus1) {
               pPly->range.firstRow = 0;
               pPly->range.firstCol = 0;
               pPly->range.lastRow  = 0;
               pPly->range.lastCol  = 0;
            }
            else {
               pPly->range.firstRow = (short) firstRow;
               pPly->range.firstCol = (short) firstCol;
               pPly->range.lastRow  = lastRowPlus1 - 1;
               pPly->range.lastCol  = lastColPlus1 - 1;

               // Handle the sheet with one cell case
               if (EMPTY_RANGE(pPly->range))
                  pPly->range.lastRow++;
            }
         }
         else {
                        if (!pRec)
                                break;

            firstCol     = XSHORT(*((short __far UNALIGNED *)(pRec + 8)));
            lastColPlus1 = XSHORT(*((short __far UNALIGNED *)(pRec + 10)));

            pPly->range.firstCol = (short) firstCol;
            pPly->range.lastCol  = (firstCol == lastColPlus1) ? 0 : lastColPlus1 - 1;
         }
      }

      else if ((hdr.type == EOF) || IsDataRecord(hdr.type))
         break;

      else
         ExcelSkipRecord (pWorkbook, &hdr);
   }

   return (rc);
}

/*---------------------------------------------------------------------------*/

public long ExcelWorksheetBOFPos (WSP pWorksheet)
{
   WBP     pWorkbook;
   long    BOFPos;
   RECHDR  hdr;

   ASSERTION (pWorksheet->use == IsWorksheet);
   pWorkbook = pWorksheet->pBook;

   if ((pWorkbook->version == versionExcel4) && (pWorkbook->fileStartOffset != 0)) {
      /*
      ** Bound sheet in a V4 workbook
      */
      if (WORKBOOK_IN_MEMORY(pWorkbook))
         return (EX_errMemoryImageNotSupported);

      BFSetFilePosition (pWorkbook->hFile, FROM_START, pWorkbook->fileStartOffset);

      ExcelReadRecordHeader(pWorkbook, &hdr);
      ASSERTION (hdr.type == BUNDLEHEADER);

      ExcelSkipRecord (pWorkbook, &hdr);

      BFGetFilePosition (pWorkbook->hFile, &BOFPos);
      return (BOFPos);
   }

   return (pWorksheet->pPly->currentSheetPos);
}

private int OpenSetup (void * pGlobals, WBP pWorkbook, int options, long offset)
{
   int     rc;
   int     fileType, buildId, buildYear;
   RECHDR  hdr;
   int     cchName;
   char    __far *pName;
   byte    __far *pRec;
   WPP     pPly, pNextPly, pLastPly = NULL;
   long    mark;
   int     iSupBook = 0;
   TCHAR   sheetName[EXCEL_MAX_SHEETNAME_LEN * 2 + 1];
   TCHAR   fileName[EXCEL_MAX_SHEETNAME_LEN + 1];
   TCHAR   fileExt[EXCEL_MAX_SHEETNAME_LEN + 1];

   #ifdef EXCEL_ENABLE_WRITE
   EXWorksheet *pMIWorksheet;
   #endif

   sheetName[0] = EOS;

   if (offset > 0) {
      if (WORKBOOK_IN_MEMORY(pWorkbook))
         return (EX_errMemoryImageNotSupported);

      /*
      ** If the offset supplied is non-zero then we are positioning to
      ** a bound document in a V4 workbook.  Stored in the index records
      ** are "absolute file positions".  In the workbook case they
      ** are actually based from the start of the BUNDLEHEADER record.
      **
      ** The position supplied to OpenSetup should be the location
      ** of that record.  At this point we need to skip that record
      ** to get the the BOF record.
      **
      ** In summary:
      **    fileStartOffset locates the BUNDLEHEADER
      **    record and is used by the index operations.
      */
      pWorkbook->fileStartOffset = offset;

      BFSetFilePosition (pWorkbook->hFile, FROM_START, pWorkbook->fileStartOffset);

      if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess) {
         rc = NOT_EXPECTED_FORMAT;
         goto OpenFail;
      }

      if (hdr.type != BUNDLEHEADER) {
         rc = EX_errGeneralError;
         goto OpenFail;
      }

      if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess || !pRec) {
         rc = NOT_EXPECTED_FORMAT;
         goto OpenFail;
      }

      cchName = *((byte __far *)(pRec + 4));
      pName   =  ((byte __far *)(pRec + 5));

      cchName = min(cchName, EXCEL_MAX_SHEETNAME_LEN);

      memcpy (sheetName, pName, cchName);
      sheetName[cchName] = EOS;
   }

   if ((pWorkbook->textStorage = TextStorageCreate(pGlobals)) == TextStorageNull) {
      rc = EX_errOutOfMemory;
      goto OpenFail;
   }

   /*
   ** Check for a valid file and version
   */
   if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess) {
      rc = NOT_EXPECTED_FORMAT;
      goto OpenFail;
   }

   if (!IS_BOF(hdr.type)) {
      rc = NOT_EXPECTED_FORMAT;
      goto OpenFail;
   }

   #ifdef EXCEL_ENABLE_V5
      if ((hdr.type != BOF_V3) && (hdr.type != BOF_V4) && (hdr.type != BOF_V5)) {
         rc = EX_errBIFFVersion;
         goto OpenFail;
      }
   #else
      if ((hdr.type != BOF_V3) && (hdr.type != BOF_V4)) {
         rc = EX_errBIFFVersion;
         goto OpenFail;
      }
   #endif

   if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess || !pRec)
      goto OpenFail;

   ParseBOFRecord (hdr.type, pRec, &(pWorkbook->version), &fileType, &buildId, &buildYear);

   //
   // Excel 96 files previous to build 2407 have a different dimensions and
   // cell index file.  No need to support obsolete beta versions
   // Office97.154779: formulas with zero length strings changed format in
   // build 3029.  We will not support earlier versions.
   //
   if ((pWorkbook->version == versionExcel8) && (buildId < 3029)) {
      rc = EX_errBIFFVersion;
      goto OpenFail;
   }

   /*
   ** File load not supported for version 3 and 4
   */
   if (pWorkbook->version < versionExcel5) {
      options &= ~EXCEL_LOAD_FILE;
      pWorkbook->openOptions = options;
   }

   #ifndef EXCEL_ENABLE_CHART_BIFF
      if (fileType == docTypeXLC) {
         rc = EX_errChartOrVBSheet;
         goto OpenFail;
      }
   #endif

   pWorkbook->PTGSize = ExcelPTGSize(pWorkbook->version);
   pWorkbook->ExtPTGSize = ExcelExtPTGSize(pWorkbook->version);

   /*
   ** Load the book state that I need
   */
   forever {
      BFGetFilePosition (pWorkbook->hFile, &(pWorkbook->currentRecordPos));

      if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
         break;

      if (hdr.type == FILEPASS) {
         rc = EX_errBIFFPasswordProtected;
         break;
      }

      else if ((hdr.type == STRING_POOL_INDEX) & ((options & EXCEL_BUILD_STRING_INDEX) != 0)) {
         if ((rc = LoadStringIndex(pGlobals, pWorkbook, &hdr)) != EX_errSuccess)
            break;
      }

      else if ((hdr.type == SUP_BOOK) & ((options & EXCEL_SETUP_FOR_NAME_DECODE) != 0)) {
         if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess || !pRec)
            break;

         mark = XLONG(*((long __far UNALIGNED *)pRec));

         if ((hdr.length == 4) && (mark == V8_LOCAL_BOOK_PATH))
            pWorkbook->iSupBookLocal = iSupBook;

         iSupBook++;
      }

      else if ((pWorkbook->version == versionExcel8) && (hdr.type == EXTERNSHEET) &&
               ((options & EXCEL_SETUP_FOR_NAME_DECODE) != 0))
      {
         if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess)
            break;

         if ((pWorkbook->pXTITable = MemAllocate(pGlobals, hdr.length)) == NULL) {
            rc = EX_errOutOfMemory;
            break;
         }

         #ifndef MAC
         memcpy (pWorkbook->pXTITable, pRec, hdr.length);
         #else
         {
            int i;
            pWorkbook->pXTITable->ctEntry = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
            pRec += sizeof(short);
            for (i = 0; i < pWorkbook->pXTITable->ctEntry; i++) {
               pWorkbook->pXTITable->entry[i].iSupBook  = XSHORT(*((short __far UNALIGNED *)(pRec + 0)));
               pWorkbook->pXTITable->entry[i].iTabFirst = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
               pWorkbook->pXTITable->entry[i].iTabLast  = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
               pRec += sizeof(XTIEntry);
            }
         }
         #endif
      }

      else if ((hdr.type == EOF) || (hdr.type == WINDESK) || IsDataRecord(hdr.type))
         break;

      else if ((pWorkbook->version >= versionExcel5) && (hdr.type == BOUNDSHEET_V5))
      {
         if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess || !pRec)
            break;

         cchName = *((byte __far *)(pRec + 6));

         if ((pPly = MemAllocate(pGlobals, sizeof(WorkbookPly) + ((cchName+1) * sizeof(TCHAR)))) == NULL) {
            rc = EX_errOutOfMemory;
            break;
         }

         pPly->originalSheetPos = XLONG(*((long __far UNALIGNED *)(pRec + 0)));
         pPly->currentSheetPos  = pPly->originalSheetPos;
         pPly->bundleRecPos     = pWorkbook->currentRecordPos;
         pPly->iType            = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));

         ExcelExtractString (pWorkbook, pPly->name, cchName+1, (char __far *)(pRec + 7), cchName);

         if (pLastPly == NULL)
            pWorkbook->pPlyList = pPly;
         else
            pLastPly->pNext = pPly;

         pLastPly = pPly;
      }

      else {
         ExcelSkipRecord (pWorkbook, &hdr);
      }
   }

   if (rc < EX_errSuccess)
      goto OpenFail;

   if (pWorkbook->version <= versionExcel4) {
      if (sheetName[0] == EOS)
         SplitPath (pWorkbook->path, NULL, 0, NULL, 0, fileName, EXCEL_MAX_SHEETNAME_LEN, fileExt, EXCEL_MAX_SHEETNAME_LEN);

      STRCPY (sheetName, fileName);
      //Removed for bug 551 on 14-feb-96
      //STRCAT (sheetName, fileExt);
      sheetName[EXCEL_MAX_SHEETNAME_LEN] = EOS;

      if ((pPly = MemAllocate(pGlobals, sizeof(WorkbookPly) + (STRLEN(sheetName) * sizeof(TCHAR)))) == NULL) {
         rc = EX_errOutOfMemory;
         goto OpenFail;
      }

      STRCPY (pPly->name, sheetName);
      pWorkbook->pPlyList = pPly;
   }

   pPly = pWorkbook->pPlyList;
   while (pPly != NULL) {
      if ((rc = OpenFilePlySetup(pGlobals, pWorkbook, pPly, options)) != EX_errSuccess)
         goto OpenFail;
      pPly = pPly->pNext;
   }

   #ifdef EXCEL_ENABLE_WRITE
   if ((options & EXCEL_LOAD_FILE) != 0) {
      if ((rc = ExcelMILoad(pWorkbook, &(pWorkbook->pMemoryImage))) != EX_errSuccess)
         goto OpenFail;

      pPly = pWorkbook->pPlyList;
      pMIWorksheet = pWorkbook->pMemoryImage->pSheets;

      while (pPly != NULL) {
         ASSERTION (pMIWorksheet != NULL);
         pPly->currentSheetPos = (long)(pMIWorksheet->pContents);
         pPly->pMemoryImage = pMIWorksheet;
         pPly = pPly->pNext;
         pMIWorksheet = pMIWorksheet->pNext;
      }
   }
   #endif

   return (EX_errSuccess);

OpenFail:
   BFCloseFile (pGlobals, pWorkbook->hFile);

   pPly = pWorkbook->pPlyList;
   while (pPly != NULL) {
      pNextPly = pPly->pNext;
      MemFree (pGlobals, pPly);
      pPly = pNextPly;
   }

   if (pWorkbook->textStorage != TextStorageNull)
      TextStorageDestroy (pGlobals, pWorkbook->textStorage);

   if (pWorkbook->pV8StringIndex != NULL)
      MemFree (pGlobals, pWorkbook->pV8StringIndex);

   if (pWorkbook->pXTITable != NULL)
      MemFree (pGlobals, pWorkbook->pXTITable);

   if (pGlobals != NULL)
      MemFree (pGlobals, pWorkbook);

   return (rc);
}

/*##*/
private int OpenWorkbookStream (WBP pWorkbook, int openOptions)
{
   int     rc;
   RECHDR  hdr;
   BOOL    hasExcel8WriterMark;

   if ((rc = BFOpenStream(pWorkbook->hFile, WORKBOOK_NAME, openOptions)) == BF_errSuccess) {
      //
      // May be double stream file
      //
      BFCloseStream (pWorkbook->hFile);

      rc = BFOpenStream(pWorkbook->hFile, BOOK_NAME, openOptions);
      if ((rc != BF_errSuccess) && (rc != BF_errOLEStreamNotFound))
         return (rc);

      if (rc == BF_errSuccess) {
         //
         // This is a dual stream file.  Determine if the version 5 stream is the most recent
         // We do this by looking for a record that Excel 8 wrote in this stream.  If this
         // stream was modified by Excel 5/7 then this record would not be present.
         //
         if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess) {
            BFCloseStream (pWorkbook->hFile);
            return (NOT_EXPECTED_FORMAT);
         }

         if (!IS_BOF(hdr.type)) {
            BFCloseStream (pWorkbook->hFile);
            return (NOT_EXPECTED_FORMAT);
         }

         ExcelSkipRecord (pWorkbook, &hdr);

         hasExcel8WriterMark = FALSE;

         forever {
            if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess) {
               BFCloseStream (pWorkbook->hFile);
               return (NOT_EXPECTED_FORMAT);
            }

            if (hdr.type == XL5_MODIFY_V8) {
               hasExcel8WriterMark = TRUE;
               break;
            }

            if ((hdr.type == EOF) || (hdr.type == CODEPAGE) || IsDataRecord(hdr.type))
               break;

            ExcelSkipRecord (pWorkbook, &hdr);
         }

         if (!hasExcel8WriterMark) {
            //
            // This file has both a v8 and a v5 stream but the v5 stream appears to have been
            // modified by a v5 user.  Treat this file as if it were a single v5 stream file
            //
            BFSetFilePosition (pWorkbook->hFile, FROM_START, 0);
            return (EX_errSuccess);
         }

         BFCloseStream (pWorkbook->hFile);

         //
         // We open dual stream files read only
         //
         openOptions &= ~EXCEL_LOAD_FILE;
         openOptions &= ~DOS_NOT_RDONLY;
         openOptions |= EXCEL_BUILD_STRING_INDEX;
      }

      rc = BFOpenStream(pWorkbook->hFile, WORKBOOK_NAME, openOptions);
   }
   else {
      if (rc != BF_errOLEStreamNotFound)
         return (rc);

      rc = BFOpenStream(pWorkbook->hFile, BOOK_NAME, openOptions);
   }

   return (rc);
}


public int ExcelOpenFile
      (void * pGlobals, TCHAR __far *pathname, char __far *password, int openOptions, long offset, EXLHandle __far *bookHandle)
{
   int   rc = BF_errFileNotFound;
   WBP   pWorkbook;

   if ((pWorkbook = MemAllocate(pGlobals, sizeof(Workbook))) == NULL)
      return (EX_errOutOfMemory);

   pWorkbook->use = IsWorkbook;
   pWorkbook->fileStartOffset = 0;
   pWorkbook->openOptions = openOptions;

   /*
   ** Open the XLS file
   */
   #ifdef WIN32
        #ifndef FILTER
      GetFullPathName (pathname, sizeof(pWorkbook->path), pWorkbook->path, NULL);
        #else
                    
        if ( wcslen(pathname) >= sizeof(Workbook)/sizeof(TCHAR) )
        {
            goto OpenFail;
        }

        // When compiling for FILTER, we're guaranteed that pathname is going
        // to be the full path, so we just need to copy it.
        wcscpy(pWorkbook->path, pathname);
   #endif
   #else
      _fullpath(pWorkbook->path, pathname, sizeof(pWorkbook->path));
      AnsiToOemBuff(pWorkbook->path, pWorkbook->path, strlen(pWorkbook->path));
   #endif

   if ((rc = BFOpenFile(pGlobals, pWorkbook->path, openOptions, &(pWorkbook->hFile))) < BF_errSuccess) {
      MemFree (pGlobals, pWorkbook);
      return (ExcelTranslateBFError(rc));
   }

   #ifdef EXCEL_ENABLE_V5
   if (openOptions & EXCEL_SHOULD_BE_DOCFILE)
   {
      #ifdef EXCEL_ENABLE_SUMMARY_INFO
         pWorkbook->OLESummaryStatus = FileSummaryInfo(pWorkbook, &(pWorkbook->OLESummaryInfo));
      #endif

      if ((rc = OpenWorkbookStream(pWorkbook, openOptions)) != BF_errSuccess)
         goto OpenFail;
        }
   #endif

   #ifdef EXCEL_ENABLE_DIRECT_CELL_READS
      ExcelClearReadCache (pWorkbook);
   #endif

   if ((rc = OpenSetup(pGlobals, pWorkbook, openOptions, offset)) != EX_errSuccess)
      return (rc);

   *bookHandle = (EXLHandle)pWorkbook;
   return (EX_errSuccess);

OpenFail:
   BFCloseFile (pGlobals, pWorkbook->hFile);
   MemFree (pGlobals, pWorkbook);
   return (ExcelTranslateBFError(rc));
}

#ifdef EXCEL_ENABLE_STORAGE_OPEN
public int ExcelOpenStorage
      (void * pGlobals, LPSTORAGE pStorage, char __far *password, int options, EXLHandle __far *bookHandle)
{
   int  rc;
   WBP  pWorkbook;

   if ((pWorkbook = MemAllocate(pGlobals, sizeof(Workbook))) == NULL)
      return (EX_errOutOfMemory);

   pWorkbook->use = IsWorkbook;
   pWorkbook->fileStartOffset = 0;
   pWorkbook->openOptions = options;

   if ((rc = BFPutStorage(pGlobals, pStorage, options, &(pWorkbook->hFile))) < BF_errSuccess) {
      MemFree (pGlobals, pWorkbook);
      return (ExcelTranslateBFError(rc));
   }

   #ifdef EXCEL_ENABLE_SUMMARY_INFO
      pWorkbook->OLESummaryStatus = FileSummaryInfo(pWorkbook, &(pWorkbook->OLESummaryInfo));
   #endif

   if ((rc = OpenWorkbookStream(pWorkbook, options)) != BF_errSuccess) {
      MemFree (pGlobals, pWorkbook);
      return (ExcelTranslateBFError(rc));
   }

   #ifdef EXCEL_ENABLE_DIRECT_CELL_READS
      ExcelClearReadCache (pWorkbook);
   #endif

   if ((rc = OpenSetup(pGlobals, pWorkbook, options, 0)) != EX_errSuccess) {
      // Office '96 bug 103737: MemFree (pWorkbook);
      return (rc);
   }

   *bookHandle = (EXLHandle)pWorkbook;
   return (EX_errSuccess);
}

public int ExcelCurrentStorage
      (EXLHandle bookHandle, LPSTORAGE __far *pStorage)
{
   int rc;
   WBP pWorkbook = (WBP)bookHandle;

   rc = BFGetStorage(pWorkbook->hFile, pStorage);
   return (ExcelTranslateBFError(rc));
}

#endif

public int ExcelCloseFile (void * pGlobals, EXLHandle bookHandle, BOOL retryAvailable)
{
   int rc = EX_errSuccess, rcClose;
   WBP pWorkbook = (WBP)bookHandle;
   WPP pPly, pPlyNext;

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifdef EXCEL_ENABLE_WRITE
      if (!WORKBOOK_IN_MEMORY(pWorkbook)) {
         pPly = pWorkbook->pPlyList;
         while (pPly != NULL) {
            if (pPly->currentSheetPos != pPly->originalSheetPos)
               ExcelWriteBundleSheetRecord (pWorkbook, pPly);
            pPly = pPly->pNext;
         }
         rc = EX_errSuccess;
      }
      else {
         rc = ExcelMISave(pWorkbook, pWorkbook->pMemoryImage, !retryAvailable);
         if (retryAvailable && ((rc == EX_errBIFFIOError) || (rc == EX_errBIFFDiskFull)))
            return (rc);
      }
   #endif

   /*## Side effect - watch out for optimizer */
   while (pWorkbook->pOpenSheetList != NULL) {
      ExcelCloseSheet (pGlobals, (EXLHandle)(pWorkbook->pOpenSheetList));
   }

   pPly = pWorkbook->pPlyList;
   while (pPly != NULL) {
      pPlyNext = pPly->pNext;
      MemFree (pGlobals, pPly);
      pPly = pPlyNext;
   }

   if ((rcClose = BFCloseFile(pGlobals, pWorkbook->hFile)) != BF_errSuccess)
      rcClose = ExcelTranslateBFError(rcClose);

   TextStorageDestroy (pGlobals, pWorkbook->textStorage);

   if (pWorkbook->pV8StringIndex != NULL)
      MemFree (pGlobals, pWorkbook->pV8StringIndex);

   if (pWorkbook->pXTITable != NULL)
      MemFree (pGlobals, pWorkbook->pXTITable);

   MemFree (pGlobals, pWorkbook);

   return ((rc == EX_errSuccess) ? rcClose : rc);
}

public int ExcelOpenSheet
      (void * pGlobals, EXLHandle bookHandle, TCHAR __far *sheetName, int openOptions, EXLHandle __far *sheetHandle)
{
   int  rc;
   int  sheetType, version, buildId, buildYear;
   WBP  pWorkbook = (WBP)bookHandle;
   WPP  pPly;
   WSP  pSheet;
   byte __far *pRec;
   RECHDR hdr;

   ASSERTION (pWorkbook->use == IsWorkbook);

   pPly = pWorkbook->pPlyList;
   while (pPly != NULL) {
      if (STRCMP(pPly->name, sheetName) == 0)
         break;
      pPly = pPly->pNext;
   }

   if (pPly == NULL)
      return (EX_errBIFFNoSuchSheet);

   if ((pSheet = MemAllocate(pGlobals, sizeof(Worksheet))) == NULL)
      return (EX_errOutOfMemory);

   pSheet->use         = IsWorksheet;
   pSheet->version     = pWorkbook->version;
   pSheet->PTGSize     = pWorkbook->PTGSize;
   pSheet->ExtPTGSize  = pWorkbook->ExtPTGSize;
   pSheet->textStorage = pWorkbook->textStorage;
   pSheet->hFile       = pWorkbook->hFile;

   pSheet->pNext       = pWorkbook->pOpenSheetList;
   pSheet->pBook       = pWorkbook;
   pSheet->pPly        = pPly;

   pWorkbook->pOpenSheetList = pSheet;

   if (pPly->useCount != 0) {
      pPly->useCount += 1;
      *sheetHandle = (EXLHandle)pSheet;
      return (EX_errSuccess);
   }

   pPly->useCount = 1;

   #ifdef EXCEL_ENABLE_DIRECT_CELL_READS
      ExcelClearReadCache (pWorkbook);
   #endif

   /*
   ** Check for a valid worksheet
   */
   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook))
      ExcelMISetPosition (pWorkbook, pPly->currentSheetPos);
   else
   #endif
      BFSetFilePosition (pWorkbook->hFile, FROM_START, pPly->currentSheetPos);

   if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess) {
      rc = NOT_EXPECTED_FORMAT;
      goto SheetOpenFail;
   }

   if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess || !pRec)
      return (rc);

   ParseBOFRecord (hdr.type, pRec, &version, &sheetType, &buildId, &buildYear);

   #ifdef EXCEL_ENABLE_CHART_BIFF
      if (sheetType == docTypeVB)
         return (EX_errChartOrVBSheet);
   #else
      if ((sheetType == docTypeXLC) || (sheetType == docTypeVB))
         return (EX_errChartOrVBSheet);
   #endif

   /*
   ** Handle various sheet state
   */
   forever {
      if ((rc = ExcelReadRecordHeader(pWorkbook, &hdr)) != EX_errSuccess)
         break;

      if (hdr.type == FILEPASS) {
         rc = EX_errBIFFPasswordProtected;
         break;
      }

      else if (hdr.type == UNCALCED) {
         pPly->hasUncalcedRec = TRUE;
         ExcelSkipRecord (pWorkbook, &hdr);
      }

      else if ((hdr.type == INDEX) & ((openOptions & EXCEL_BUILD_CELL_INDEX) != 0)) {
         if ((rc = LoadCellIndex(pGlobals, pWorkbook, pPly, &hdr)) != EX_errSuccess)
            break;
      }

      else if ((hdr.type == EOF) || IsDataRecord(hdr.type))
         break;

      else
         ExcelSkipRecord (pWorkbook, &hdr);
   }

   if (rc != EX_errSuccess)
      goto SheetOpenFail;

   #ifndef EXCEL_ENABLE_CHART_BIFF
      if (((openOptions & EXCEL_BUILD_CELL_INDEX) != 0) &&
           (pPly->pCellIndex == NULL) && !WORKBOOK_IN_MEMORY(pWorkbook))
      {
         rc = EX_errBIFFNoIndex;
         goto SheetOpenFail;
      }
   #endif

   *sheetHandle = (EXLHandle)pSheet;
   return (rc);

SheetOpenFail:
   pPly->useCount = 0;

   if (pPly->pCellIndex != NULL)
      ExcelFreeCellIndex (pGlobals, pPly->pCellIndex);

   pPly->pCellIndex = NULL;
   pPly->hasUncalcedRec = FALSE;

   pWorkbook->pOpenSheetList = pWorkbook->pOpenSheetList->pNext;
   MemFree (pGlobals, pSheet);

   return (rc);
}


public int ExcelSheetRange (EXLHandle bookHandle, TCHAR __far *sheetName, EXA_RANGE __far *range)
{
   WBP  pWorkbook = (WBP)bookHandle;
   WPP  pPly;

   ASSERTION (pWorkbook->use == IsWorkbook);

   pPly = pWorkbook->pPlyList;
   while (pPly != NULL) {
      if (STRCMP(pPly->name, sheetName) == 0)
         break;
      pPly = pPly->pNext;
   }

   if (pPly == NULL)
      return (EX_errBIFFNoSuchSheet);

   *range = pPly->range;
   return (EX_errSuccess);
}

public int ExcelIthSheet
      (EXLHandle bookHandle, int i, TCHAR __far *sheetName, int __far *iType)
{
   WBP  pWorkbook = (WBP)bookHandle;
   WPP  pPly;

   ASSERTION (pWorkbook->use == IsWorkbook);

   pPly = pWorkbook->pPlyList;
   while ((i > 0) && (pPly != NULL)) {
      i--;
      pPly = pPly->pNext;
   }

   if (pPly == NULL)
      return (EX_errBIFFNoSuchSheet);

   if (sheetName != NULL)
      STRCPY (sheetName, pPly->name);

   *iType = pPly->iType;

   return (EX_errSuccess);
}


public int ExcelCloseSheet (void * pGlobals, EXLHandle sheetHandle)
{
   WSP  pWorksheet = (WSP)sheetHandle;
   WPP  pPly;
   WBP  pWorkbook;
   SFN  pSharedFormula, pNext;
   WSP  pCurrentSheet, pPreviousSheet;

   ASSERTION (pWorksheet->use == IsWorksheet);

   pWorkbook = pWorksheet->pBook;

   pCurrentSheet = pWorkbook->pOpenSheetList;
   pPreviousSheet = NULL;

   while (pCurrentSheet != NULL) {
      if (pCurrentSheet == pWorksheet)
         break;
      pPreviousSheet = pCurrentSheet;
      pCurrentSheet = pCurrentSheet->pNext;
   }

   ASSERTION (pCurrentSheet != NULL);
   pPly = pWorksheet->pPly;

   if ( 0 != pCurrentSheet )
   {
       if (pPreviousSheet == NULL)
           pWorkbook->pOpenSheetList = pCurrentSheet->pNext;
       else
           pPreviousSheet->pNext = pCurrentSheet->pNext;
   }

   if (pPly->useCount == 1)
   {
      #ifdef EXCEL_ENABLE_WRITE
         if (pPly->modified)
            ExcelWriteCellIndex (pWorksheet);
      #endif

      pSharedFormula = pPly->pSharedFormulaStore;
      while (pSharedFormula != NULL) {
         pNext = pSharedFormula->next;
         MemFree (pGlobals, pSharedFormula);
         pSharedFormula = pNext;
      }
      pPly->pSharedFormulaStore = NULL;

      ExcelFreeCellIndex (pGlobals, pPly->pCellIndex);
      pPly->pCellIndex = NULL;

      pPly->modified = FALSE;
      pPly->hasUncalcedRec = FALSE;
   }
   pPly->useCount -= 1;

   MemFree (pGlobals, pWorksheet);
   return (EX_errSuccess);
}


public int ExcelSheetRowHeight
      (EXLHandle sheetHandle, int row, unsigned int __far *height)
{
   WSP  pSheet = (WSP)sheetHandle;
   WPP  pPly;
   int  iRowBlock, iRow;
   RBP  pRowBlock;
   RIP  pRow;

   ASSERTION (pSheet->use == IsWorksheet);

   pPly = pSheet->pPly;

   if (pPly->pCellIndex == NULL)
      return (EX_errBIFFNoIndex);

   if ((row < pPly->pCellIndex->firstRow) || (row > pPly->pCellIndex->lastRow))
      return (EX_wrnRowNotFound);

   iRowBlock = (row - pPly->pCellIndex->firstRow) / ROWS_PER_BLOCK;
   iRow = (row - pPly->pCellIndex->firstRow) % ROWS_PER_BLOCK;

   if ((pRowBlock = pPly->pCellIndex->rowIndex[iRowBlock]) == NULL)
      return (EX_wrnRowNotFound);

   pRow = &(pRowBlock->row[iRow]);
   if (pRow->cellRecsPos == NO_SUCH_ROW)
      return (EX_wrnRowNotFound);

   if (pRow->grbit & 0x0020)
      *height = 0;
   else
      *height = (unsigned int)(pRow->height & 0x7fff);

   return (EX_errSuccess);
}


public int ExcelFileVersion (EXLHandle handle)
{
   WBP pWorkbook = (WBP)handle;

   // Works with workbook or worksheet

   return (pWorkbook->version);
}

public int ExcelFileDateTime
          (EXLHandle bookHandle,
           int __far *year, int __far *month, int __far *day,
           int __far *hour, int __far *minute, int __far *second)
{
   int  rc;
   WBP  pWorkbook = (WBP)bookHandle;

   ASSERTION (pWorkbook->use == IsWorkbook);

   rc = BFFileDateTime(pWorkbook->hFile, year, month, day, hour, minute, second);
   return (ExcelTranslateBFError(rc));
}

#ifdef EXCEL_ENABLE_V5
#ifdef EXCEL_ENABLE_SUMMARY_INFO
private int FileSummaryInfo (WBP pWorkbook, ExcelOLESummaryInfo __far *pInfo)
{
   int            rc;
   long           cbSummaryStream;
   unsigned int   i;
   byte     __far *pSummaryBuffer = NULL;
   byte     __far *pSummaryInfo;
   byte     __far *pSection;
   byte     __far *pProperty;
   byte     __far *pValue;
   WORD           wByteOrder, wFormat;
   DWORD          ctSections, cbSection;
   DWORD          ctProperties, iProperty, offset, iType;
   DWORD          cbText;
   char     __far *pText;

   #define GUID_SIZE   16
   #define HEADER_SIZE 28

   #define PID_TITLE      0x00000002
   #define PID_SUBJECT    0x00000003
   #define PID_AUTHOR     0x00000004
   #define PID_KEYWORDS   0x00000005
   #define PID_COMMENTS   0x00000006
   #define VT_LPSTR       30

   #define SUMMARY_NAME "\x05SummaryInformation"

   memset (pInfo, 0, sizeof(ExcelOLESummaryInfo));

   if ((rc = BFOpenStream(pWorkbook->hFile, SUMMARY_NAME, DOS_RDONLY)) == BF_errOLEStreamNotFound)
      return (EX_errNoSummaryInfo);

   if (rc != BF_errSuccess)
      return (EX_errSummaryInfoError);

   /*
   ** Determine the size of the summary stream
   */
   rc = BFSetFilePosition(pWorkbook->hFile, FROM_END, 0);
   if (rc != BF_errSuccess)
      goto done;

   rc = BFGetFilePosition (pWorkbook->hFile, &cbSummaryStream);
   if (rc != BF_errSuccess)
      goto done;

   rc = BFSetFilePosition(pWorkbook->hFile, FROM_START, 0);
   if (rc != BF_errSuccess)
      goto done;

   /*
   ** Read the summary stream
   */
   if ((pSummaryBuffer = MemAllocate((unsigned int)cbSummaryStream)) == NULL) {
      rc = BF_errOutOfMemory;
      goto done;
   }

   rc = BFReadFile(pWorkbook->hFile, pSummaryBuffer, (unsigned int)cbSummaryStream);
   if (rc != BF_errSuccess)
      goto done;

   pSummaryInfo = pSummaryBuffer;

   wByteOrder = XSHORT(*((WORD  __far UNALIGNED *)(pSummaryInfo + 0)));
   wFormat    = XSHORT(*((WORD  __far UNALIGNED *)(pSummaryInfo + 2)));
   ctSections = XLONG(*((DWORD __far UNALIGNED *)(pSummaryInfo + 24)));

   if ((wByteOrder != 0xfffe) || (wFormat != 0) || (ctSections != 1)) {
      rc = BF_errIOError;
      goto done;
   }

   pSummaryInfo += HEADER_SIZE;

   offset = XLONG(*((DWORD __far *)(pSummaryInfo + GUID_SIZE)));
   pSection = pSummaryBuffer + offset;

   cbSection    = XLONG(*((DWORD __far *)(pSection + 0)));
   ctProperties = XLONG(*((DWORD __far *)(pSection + 4)));

   pProperty = pSection + 8;

   for (i = 0; i < ctProperties; i++) {
      iProperty = XLONG(*((DWORD __far *)(pProperty + 0)));
      offset    = XLONG(*((DWORD __far *)(pProperty + 4)));
      pProperty += 8;

      pValue = pSection + offset;
      iType = XLONG(*((DWORD __far *)(pValue + 0)));
      pValue += 4;

      /*
      ** Property "iProperty" of type "iType" located by "pValue"
      */
      if (iType == VT_LPSTR) {
         if ((cbText = XLONG(*((DWORD __far *)pValue))) > 1)
         {
            if ((pText = MemAllocate((uns)cbText)) == NULL) {
               rc = BF_errOutOfMemory;
               goto done;
            }

            memcpy (pText, pValue + 4, (uns)cbText);

            switch (iProperty) {
               case PID_TITLE:
                  pInfo->pTitle = pText;
                  break;
               case PID_SUBJECT:
                  pInfo->pSubject = pText;
                  break;
               case PID_AUTHOR:
                  pInfo->pAuthor = pText;
                  break;
               case PID_KEYWORDS:
                  pInfo->pKeywords = pText;
                  break;
               case PID_COMMENTS:
                  pInfo->pComments = pText;
                  break;
            }
         }
      }
   }

   rc = BF_errSuccess;

done:
   if (pSummaryBuffer != NULL)
      MemFree (pSummaryBuffer);

   BFCloseStream (pWorkbook->hFile);

   if (rc != BF_errSuccess)
      return (EX_errSummaryInfoError);
   else
      return (EX_errSuccess);
}
#endif

public int ExcelFileSummaryInfo (EXLHandle bookHandle, ExcelOLESummaryInfo __far *pInfo)
{
   WBP pWorkbook = (WBP)bookHandle;

   ASSERTION (pWorkbook->use == IsWorkbook);

   #ifndef EXCEL_ENABLE_V5
      return (EX_errNoSummaryInfo);
   #else
      memcpy (pInfo, &(pWorkbook->OLESummaryInfo), sizeof(ExcelOLESummaryInfo));
      return (pWorkbook->OLESummaryStatus);
   #endif
}
#endif

public int ExcelGetLastRecordInfo
       (WBP pWorkbook, long __far *mark, unsigned int __far *cbRecord)
{
   NEED_WORKBOOK (pWorkbook);

   if (mark != NULL)
      *mark = pWorkbook->currentRecordPos;

   if (cbRecord != NULL)
      *cbRecord = pWorkbook->currentRecordLen;

   return (EX_errSuccess);
}

public int ExcelGetBookmark
      (EXLHandle handle, int iType, ExcelBookmark __far *bookmark)
{
   WBP pWorkbook = (WBP)handle;

   NEED_WORKBOOK (pWorkbook);

   if (iType == START_OF_CURRENT_RECORD) {
      *bookmark = pWorkbook->currentRecordPos;
   }
   else {
      #ifdef EXCEL_ENABLE_WRITE
      if (WORKBOOK_IN_MEMORY(pWorkbook))
         ExcelMIGetPosition(pWorkbook, bookmark);
      else
      #endif
         *bookmark = pWorkbook->currentRecordPos + pWorkbook->currentRecordLen;
   }

   return (EX_errSuccess);
}

/*---------------------------------------------------------------------------*/

private int SkipEmbeddedRegion (WBP pWorkbook)
{
   RECHDR hdr;
   int    rc;

   forever {
      if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
         return (NOT_EXPECTED_FORMAT);

      if (IS_BOF(hdr.type)) {
         ExcelSkipRecord (pWorkbook, &hdr);
         if ((rc = SkipEmbeddedRegion(pWorkbook)) != EX_errSuccess)
            return (rc);
      }

      else if (hdr.type == EOF) {
         ExcelSkipRecord (pWorkbook, &hdr);
         break;
      }

      else {
         ExcelSkipRecord (pWorkbook, &hdr);
      }
   }

   return (EX_errSuccess);
}

private void NeedToReadRecords
       (WBP pWorkbook, byte __far *readEnable, int cbReadEnable, const EXCELDEF __far *dispatch)
{
   if (dispatch->pfnEveryRecord != NULL) {
      memset (readEnable, 1, cbReadEnable);
      return;
   }

   memset (readEnable, 0, cbReadEnable);

   /* BOF */
   readEnable[BOF_V2] = 1;

   /* BUNDLESHEET */
   if ((pWorkbook->version >= versionExcel5) && (dispatch->pfnWorkbookBoundSheet != NULL))
      readEnable[BUNDLESHEET] = 1;

   if ((pWorkbook->version < versionExcel5) && (dispatch->pfnWBBundleSheet != NULL))
      readEnable[BUNDLESHEET] = 1;

   /* BUNDLEHEADER */
   if (dispatch->pfnWBBundleSheet != NULL)
      readEnable[BUNDLEHEADER] = 1;

   /* PROJEXTSHT */
   if (dispatch->pfnWBExternSheet != NULL)
      readEnable[PROJEXTSHT] = 1;

   /* FILEPASS */
   readEnable[FILEPASS] = 1;

   /* TEMPLATE */
   if (dispatch->pfnIsTemplate != NULL)
      readEnable[TEMPLATE] = 1;

   /* ADDIN */
   if (dispatch->pfnIsAddin != NULL)
      readEnable[ADDIN] = 1;

   /* PROTECTION */
   if (dispatch->pfnProtection != NULL) {
      readEnable[WRITEPROT] = 1;
      readEnable[FILESHARING] = 1;
      readEnable[PROTECT] = 1;
      readEnable[WINDOW_PROTECT] = 1;
      readEnable[OBJPROTECT] = 1;
      readEnable[PASSWORD] = 1;
      readEnable[FILESHARING2 & 0xff] = 1;
   }

   /* DEFCOLWIDTH */
   if (dispatch->pfnDefColWidth != NULL)
      readEnable[DEFCOLWIDTH] = 1;

   /* COLINFO */
   if (dispatch->pfnColInfo != NULL)
      readEnable[COLINFO] = 1;

   /* STANDARD_WIDTH */
   if (dispatch->pfnStandardWidth != NULL)
      readEnable[STANDARD_WIDTH] = 1;

   /* GCW */
   if (dispatch->pfnGCW != NULL) {
      readEnable[GCW] = 1;
      readEnable[GCW_ALT & 0xff] = 1;
   }

   /* DEFAULT_ROW_HEIGHT */
   if (dispatch->pfnDefRowHeight != NULL)
      readEnable[DEFAULT_ROW_HEIGHT & 0xff] = 1;

   /* FONT */
   if (dispatch->pfnFont != NULL)
      readEnable[FONT & 0xff] = 1;

   /* FORMAT */
   if (dispatch->pfnFormat != NULL)
      readEnable[FORMAT_V3] = 1;

   /* XF */
   if (dispatch->pfnXF != NULL) {
      readEnable[XF_V3 & 0xff] = 1;
      readEnable[XF_V5] = 1;
   }

   /* INTL */
   if (dispatch->pfnIsInternationalSheet != NULL)
      readEnable[INTL] = 1;

   /* MMS */
   if (dispatch->pfnInterfaceChanges != NULL)
      readEnable[MMS] = 1;

   /* DELMENU */
   if (dispatch->pfnDeleteMenu != NULL)
      readEnable[DELMENU] = 1;

   /* ADDMENU */
   if (dispatch->pfnAddMenu != NULL)
      readEnable[ADDMENU] = 1;

   /* TOOLBARPOS */
   if (dispatch->pfnAddToolbar != NULL)
      readEnable[TOOLBARPOS] = 1;

   /* DATE_1904 */
   if (dispatch->pfnDateSystem != NULL)
      readEnable[DATE_1904] = 1;

   /* CODEPAGE */
   if (dispatch->pfnCodePage != NULL)
      readEnable[CODEPAGE] = 1;

   /* WRITEACCESS */
   if (dispatch->pfnWriterName != NULL)
      readEnable[WRITEACCESS] = 1;

   /* DOCROUTE */
   if (dispatch->pfnDocRoute != NULL)
      readEnable[DOCROUTE] = 1;

   /* RECIPNAME */
   if (dispatch->pfnRecipientName != NULL)
      readEnable[RECIPNAME] = 1;

   /* REFMODE */
   if (dispatch->pfnReferenceMode != NULL)
      readEnable[REFMODE] = 1;

   /* FNGROUP_COUNT */
   if (dispatch->pfnFNGroupCount != NULL)
      readEnable[FNGROUP_COUNT] = 1;

   /* FNGROUP_NAME */
   if (dispatch->pfnFNGroupName != NULL)
      readEnable[FNGROUP_NAME] = 1;

   /* EXTERNCOUNT */
   if (dispatch->pfnExternCount != NULL)
      readEnable[EXTERNCOUNT] = 1;

   /* EXTERNSHEET */
   if (dispatch->pfnExternSheet != NULL)
      readEnable[EXTERNSHEET] = 1;

   /* EXTERNNAME */
   if (dispatch->pfnExternName != NULL)
      readEnable[EXTERNNAME_V5] = 1;

   /* NAME */
   if (dispatch->pfnName != NULL)
      readEnable[NAME_V5] = 1;

   /* DIMENSIONS */
   if (dispatch->pfnDimensions != NULL)
      readEnable[DIMENSIONS & 0xff] = 1;

   /* RK */
   if (dispatch->pfnNumberCell != NULL)
      readEnable[RK & 0xff] = 1;

   /* MULRK */
   if (dispatch->pfnNumberCell != NULL)
      readEnable[MULRK & 0xff] = 1;

   /* NUMBER */
   if (dispatch->pfnNumberCell != NULL)
      readEnable[NUMBER & 0xff] = 1;

   /* BLANK */
   if (dispatch->pfnBlankCell != NULL)
      readEnable[BLANK & 0xff] = 1;

   /* MULBLANK */
   if (dispatch->pfnBlankCell != NULL)
      readEnable[MULBLANK & 0xff] = 1;

   /* LABEL - RSTRING */
   if (dispatch->pfnTextCell != NULL) {
      readEnable[LABEL & 0xff] = 1;
      readEnable[RSTRING] = 1;
      readEnable[LABEL_V8 & 0xff] = 1;
   }

   /* BOOLERR */
   if ((dispatch->pfnBooleanCell != NULL) || (dispatch->pfnErrorCell != NULL))
      readEnable[BOOLERR & 0xff] = 1;

   /* FORMULA */
   if (dispatch->pfnFormulaCell != NULL)
      readEnable[FORMULA_V5] = 1;

   /* ARRAY */
   if (dispatch->pfnArrayFormulaCell != NULL)
      readEnable[ARRAY & 0xff] = 1;

   /* SHRFMLA */
   if (dispatch->pfnSharedFormulaCell != NULL)
      readEnable[SHRFMLA] = 1;

   /* STRING */
   if (dispatch->pfnStringCell != NULL)
      readEnable[STRING & 0xff] = 1;

   /* NOTE */
   if (dispatch->pfnCellNote != NULL) {
      readEnable[NOTE] = 1;
      readEnable[EXPORT_NOTE] = 1;
   }

   /* OBJ */
   if (dispatch->pfnObject != NULL)
      readEnable[OBJ] = 1;

   /* IMDATA */
   if (dispatch->pfnImageData != NULL)
      readEnable[IMDATA] = 1;

   /* SCENARIO */
   if (dispatch->pfnScenario != NULL)
      readEnable[SCENARIO] = 1;

   /* STRING_POOL_TABLE */
   if (dispatch->pfnStringPool != NULL)
      readEnable[STRING_POOL_TABLE] = 1;

   /* EOF */
   if (dispatch->pfnEOF != NULL)
      readEnable[EOF] = 1;
}

public int ExcelScanFile
      (void * pGlobals, EXLHandle handle, const EXCELDEF __far *dispatch, ExcelBookmark bookmark)
{
   int      rc, nDbg;
   WBP      pScanObject = (WBP)handle;
   WBP      pWorkbook = (WBP)handle;
   byte     __far *pRec;
   RECHDR   hdr;
   int      version, docType, buildId, buildYear;
   byte     readEnable[256];

   if (dispatch->version != EXCEL_CALLBACK_VERSION)
      return (EX_errBIFFCallbackVersion);

   NEED_WORKBOOK (pWorkbook);

   NeedToReadRecords (pWorkbook, readEnable, sizeof(readEnable), dispatch);

   #ifdef AQTDEBUG
      #ifndef EXCEL_ENABLE_TEMPLATE
         if (dispatch->pfnIsTemplate != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_ADDIN
         if (dispatch->pfnIsAddin != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_INTL
         if (dispatch->pfnIsInternationalSheet != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_V5INTERFACE
         if ((dispatch->pfnInterfaceChanges != NULL) ||
             (dispatch->pfnDeleteMenu       != NULL) ||
             (dispatch->pfnAddMenu          != NULL) ||
             (dispatch->pfnAddToolbar       != NULL))
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_DATE_SYSTEM
         if (dispatch->pfnDateSystem != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_CODE_PAGE
         if (dispatch->pfnCodePage != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_PROTECTION
         if (dispatch->pfnProtection != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_COL_INFO
         if (dispatch->pfnColInfo != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_STD_WIDTH
         if (dispatch->pfnStandardWidth != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_DEF_COL_WIDTH
         if (dispatch->pfnDefColWidth != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_DEF_ROW_HEIGHT
         if (dispatch->pfnDefRowHeight != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_GCW
         if (dispatch->pfnGCW != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_FONT
         if (dispatch->pfnFont != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_FORMAT
         if (dispatch->pfnFormat != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_XF
         if (dispatch->pfnXF != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_WRITER_NAME
         if (dispatch->pfnWriterName != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_DOC_ROUTING
         if ((dispatch->pfnDocRoute != NULL) || (dispatch->pfnRecipientName != NULL))
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_REF_MODE
         if (dispatch->pfnReferenceMode != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_FN_GROUP_COUNT
         if (dispatch->pfnFNGroupCount != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_FN_GROUP_NAME
         if (dispatch->pfnFNGroupName != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_EXTERN_COUNT
         if (dispatch->pfnExternCount != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_EXTERN_SHEET
         if ((dispatch->pfnExternSheet != NULL) || (dispatch->pfnWBExternSheet != NULL))
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_EXTERN_NAME
         if (dispatch->pfnExternName != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_NAME
         if (dispatch->pfnName != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_DIMENSION
         if (dispatch->pfnDimensions != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_TEXT_CELL
         if (dispatch->pfnTextCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_NUMBER_CELL
         if (dispatch->pfnNumberCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_BLANK_CELL
         if (dispatch->pfnBlankCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_ERROR_CELL
         if (dispatch->pfnErrorCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_BOOLEAN_CELL
         if (dispatch->pfnBooleanCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_FORMULA_CELL
         if (dispatch->pfnFormulaCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_ARRAY_FORMULA_CELL
         if (dispatch->pfnArrayFormulaCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_SHARED_FORMULA_CELL
         if (dispatch->pfnSharedFormulaCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_STRING_CELL
         if (dispatch->pfnStringCell != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_NOTE
         if (dispatch->pfnCellNote != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_OBJECT
         if (dispatch->pfnObject != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_IMAGE_DATA
         if (dispatch->pfnImageData != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_SCENARIO
         if (dispatch->pfnScenario != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
      #ifndef EXCEL_ENABLE_STRING_POOL_SCAN
         if (dispatch->pfnStringPool != NULL)
            return (EX_errBIFFCallbackVersion);
      #endif
   #endif

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorkbook)) {
      if (bookmark == ExcelBookmarkStartOfFile) {
         if (pScanObject->use == IsWorkbook)
            ExcelMISetPosition (pWorkbook, MI_START_OF_WORKBOOK);
         else
            ExcelMISetPosition (pWorkbook, ExcelWorksheetBOFPos((WSP)pScanObject));

         pWorkbook->ctBOF = 0;
      }
      else {
         ExcelMISetPosition (pWorkbook, bookmark);
      }
   }
   else {
   #endif
      if (bookmark == ExcelBookmarkStartOfFile) {
         if (pScanObject->use == IsWorkbook)
            BFSetFilePosition (pWorkbook->hFile, FROM_START, 0);
         else
            BFSetFilePosition (pWorkbook->hFile, FROM_START, ExcelWorksheetBOFPos((WSP)pScanObject));

         pWorkbook->ctBOF = 0;
      }
      else {
         BFSetFilePosition (pWorkbook->hFile, FROM_START, bookmark);
      }
   #ifdef EXCEL_ENABLE_WRITE
   }
   #endif

   nDbg = 0;

   forever {

       nDbg++;

      #ifdef EXCEL_ENABLE_WRITE
      if (WORKBOOK_IN_MEMORY(pWorkbook))
         ExcelMIGetPosition (pWorkbook, &(pWorkbook->currentRecordPos));
      else
      #endif
         BFGetFilePosition (pWorkbook->hFile, &(pWorkbook->currentRecordPos));

      if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
         return (NOT_EXPECTED_FORMAT);

      rc = EX_errSuccess;
      pRec = NULL;

      #ifdef EXCEL_ENABLE_CHART_BIFF
      if (
          ((hdr.type == SERIESTEXT) && (dispatch->pfnSeriesText == NULL)) ||
          ((hdr.type != SERIESTEXT) && (hdr.type >= CHART_REC_START))     ||
          ((hdr.type != SERIESTEXT) && (pWorkbook->ctBOF > 1))            ||
          ((hdr.type <  CHART_REC_START) && !readEnable[hdr.type & 0xff])
         )
      #else
      if (!readEnable[hdr.type & 0xff])
      #endif
      {
         if ((hdr.type != HEADER) && (hdr.type != FOOTER) && 
             (hdr.type != EOF) && !IS_BOF(hdr.type)) {
            ExcelSkipRecord (pWorkbook, &hdr);
            continue;
         }
      }

      if (dispatch->pfnEveryRecord != NULL) {
         if ((rc = BFReadFile(pWorkbook->hFile, pExcelRecordBuffer, hdr.length)) != BF_errSuccess) {
            rc = ExcelTranslateBFError(rc);
            break;
         }

         rc = dispatch->pfnEveryRecord(pGlobals, hdr.type, hdr.length, pWorkbook->currentRecordPos, pExcelRecordBuffer);

         if ((rc != EX_errSuccess) || (hdr.type == EOF))
            break;

         continue;
      }

      /*
      ** Read the whole record, that is the record plus any continue
      ** records.
      **
      ** Note special processing for IMDATA records due to their size/format
      */
      if (hdr.type != IMDATA) {
         if ((rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec)) != EX_errSuccess) {
            if (pRec != NULL)
               FREE_RECORD_BUFFER(pRec);
            return (rc);
         }
      }


      switch (hdr.type) {
         case BOF_V2:
         case BOF_V3:
         case BOF_V4:
         case BOF_V5:
            ParseBOFRecord(hdr.type, pRec, &version, &docType, &buildId, &buildYear);
            if (pWorkbook->ctBOF > 0) {
               if ((pWorkbook->openOptions & EXCEL_ALLOW_EMBEDDED_SCAN) == 0) {
                  if ((docType == docTypeXLC) || (docType == docTypeXLW))
                     rc = SkipEmbeddedRegion(pWorkbook);
                   else
                     rc = NOT_EXPECTED_FORMAT;
               }
               else {
                  pWorkbook->ctBOF += 1;
               }
            }
            else {
               pWorkbook->ctBOF = 1;
               if (dispatch->pfnBOF != NULL)
                  rc = ProcessBOFRecord(pGlobals, dispatch->pfnBOF, hdr.type, pRec);
            }
            break;

         case BUNDLESHEET:
            // Version 5 same number as V3/4 BUT different structure
            if (pWorkbook->version >= versionExcel5){
               if (pRec)
                  rc = ProcessV5BoundSheetRecord(pGlobals, pScanObject, dispatch->pfnWorkbookBoundSheet, pRec);
            }
            else {
               if (pRec)
                  rc = ProcessBundleSheetRecord(pGlobals, dispatch->pfnWBBundleSheet, pRec);
            }
            break;

         case BUNDLEHEADER:
            if (dispatch->pfnWBBundleHeader == NULL)
               ExcelSkipRecord (pWorkbook, &hdr);
            else {
               rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
               if (rc == EX_errSuccess)
                  rc = ProcessBundleHeaderRecord(pGlobals, dispatch->pfnWBBundleHeader, pRec);
            }
            break;

         #ifdef EXCEL_ENABLE_EXTERN_SHEET
         case PROJEXTSHT:
            rc = ProcessProjExtSheetRecord(pScanObject, dispatch->pfnWBExternSheet, pRec);
            break;
         #endif

         case FILEPASS:
            rc = EX_errBIFFPasswordProtected;
            break;

         #ifdef EXCEL_ENABLE_TEMPLATE
         case TEMPLATE:
            rc = ProcessTemplateRecord(dispatch->pfnIsTemplate, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_ADDIN
         case ADDIN:
            rc = ProcessAddinRecord(dispatch->pfnIsAddin, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_V5INTERFACE
         case MMS:
            rc = ProcessMMSRecord(dispatch->pfnInterfaceChanges, pRec);
            break;

         case ADDMENU:
            rc = ProcessAddMenuRecord(dispatch->pfnAddMenu, pRec);
            break;

         case DELMENU:
            rc = ProcessDeleteMenuRecord(dispatch->pfnDeleteMenu, pRec);
            break;

         case TOOLBARPOS:
            rc = ProcessToolbarRecord(dispatch->pfnAddToolbar, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_PROTECTION
         case WRITEPROT:
         case FILESHARING:
         case FILESHARING2:
         case PROTECT:
         case WINDOW_PROTECT:
         case OBJPROTECT:
         case PASSWORD:
            rc = ProcessProtectionRecord(pGlobals, hdr.type, dispatch->pfnProtection, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_DEF_COL_WIDTH
         case DEFCOLWIDTH:
            rc = ProcessDefColWidthRecord(pGlobals, dispatch->pfnDefColWidth, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_COL_INFO
         case COLINFO:
            rc = ProcessColInfoRecord(pGlobals, dispatch->pfnColInfo, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_STD_WIDTH
         case STANDARD_WIDTH:
            rc = ProcessStandardWidthRecord(pGlobals, dispatch->pfnStandardWidth, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_GCW
         case GCW:
         case GCW_ALT:
            if (pRec)
               rc = ProcessGCWRecord(pGlobals, dispatch->pfnGCW, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_DEF_ROW_HEIGHT
         case DEFAULT_ROW_HEIGHT:
            rc = ProcessDefRowHeightRecord(dispatch->pfnDefRowHeight, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_FONT
         case FONT:
         case FONT_V5:
            rc = ProcessFontRecord(pScanObject, dispatch->pfnFont, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_FORMAT
         case FORMAT_V3:
         case FORMAT_V4:
            // Version 5 same number as V3/4 BUT different structure
            rc = ProcessFormatRecord(pGlobals, pScanObject, hdr.type, dispatch->pfnFormat, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_XF
         case XF_V3:
         case XF_V4:
         case XF_V5:
            rc = ProcessXFRecord(pGlobals, hdr.type, dispatch->pfnXF, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_INTL
         case INTL:
            rc = ProcessIntlRecord(dispatch->pfnIsInternationalSheet, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_DATE_SYSTEM
         case DATE_1904:
            rc = ProcessDateSystemRecord(pGlobals, dispatch->pfnDateSystem, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_CODE_PAGE
         case CODEPAGE:
            if (pRec)
               rc = ProcessCodePageRecord(pGlobals, dispatch->pfnCodePage, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_WRITER_NAME
         case WRITEACCESS:
            rc = ProcessWriteAccessRecord(pScanObject, dispatch->pfnWriterName, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_REF_MODE
         case REFMODE:
            rc = ProcessRefModeRecord(dispatch->pfnReferenceMode, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_FN_GROUP_COUNT
         case FNGROUP_COUNT:
            rc = ProcessFNGroupCountRecord(dispatch->pfnFNGroupCount, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_FN_GROUP_NAME
         case FNGROUP_NAME:
            rc = ProcessFNGroupNameRecord(dispatch->pfnFNGroupName, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_EXTERN_COUNT
         case EXTERNCOUNT:
            rc = ProcessExternCountRecord(dispatch->pfnExternCount, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_EXTERN_SHEET
         case EXTERNSHEET:
            // Version 5 same number as V3/4 BUT different structure
            rc = ProcessExternSheetRecord(pScanObject, dispatch->pfnExternSheet, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_EXTERN_NAME
         case EXTERNNAME:
         case EXTERNNAME_V5:
            rc = ProcessExternNameRecord(pScanObject, dispatch->pfnExternName, pRec, hdr.length);
            break;
         #endif

         #ifdef EXCEL_ENABLE_NAME
         case NAME:
         case NAME_V5:
            rc = ProcessNameRecord(pGlobals, pScanObject, dispatch->pfnName, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_DIMENSION
         case DIMENSIONS:
            rc = ProcessDimensionsRecord(pScanObject, dispatch->pfnDimensions, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_NUMBER_CELL
         case RK:
            rc = DispatchRKRecord(pGlobals, dispatch->pfnNumberCell, pRec);
            break;

         case NUMBER:
            rc = DispatchNumberRecord(pGlobals, dispatch->pfnNumberCell, pRec);
            break;

         case MULRK:
            rc = DispatchMulRKRecord(pGlobals, dispatch->pfnNumberCell, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_BLANK_CELL
         case BLANK:
            rc = DispatchBlankRecord(dispatch->pfnBlankCell, pRec);
            break;

         case MULBLANK:
            rc = DispatchMulBlankRecord(dispatch->pfnBlankCell, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_TEXT_CELL
         case LABEL:
         case RSTRING:
         case LABEL_V8:
            rc = DispatchLabelRecord(pGlobals, pScanObject, hdr.type, dispatch->pfnTextCell, pRec);
            break;
         #endif

         #if (defined(EXCEL_ENABLE_BOOLEAN_CELL) || defined(EXCEL_ENABLE_ERROR_CELL))
         case BOOLERR:
            {
            EXA_CELL cell;
            int      boolerrValue;
            BOOL     isBoolean;
            int      ixfe;

            ParseBoolerrRecord(pRec, &cell, &ixfe, &boolerrValue, &isBoolean);

            if ((isBoolean == TRUE) && (dispatch->pfnBooleanCell != NULL))
               rc = DispatchBooleanRecord(dispatch->pfnBooleanCell, pRec);

            else if ((isBoolean == FALSE) && (dispatch->pfnErrorCell != NULL))
               rc = DispatchErrorRecord(dispatch->pfnErrorCell, pRec);
            }
            break;
         #endif

         #ifdef EXCEL_ENABLE_FORMULA_CELL
         case FORMULA_V3:
         case FORMULA_V4:
         case FORMULA_V5:
            rc = DispatchFormulaRecord(pGlobals, pScanObject, dispatch->pfnFormulaCell, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_ARRAY_FORMULA_CELL
         case ARRAY:
            // Version 5 same number as V3/4 BUT different structure
            rc = DispatchArrayRecord(pGlobals, pScanObject, dispatch->pfnArrayFormulaCell, pRec, hdr);
            break;
         #endif

         #ifdef EXCEL_ENABLE_SHARED_FORMULA_CELL
         case SHRFMLA:
            rc = DispatchShrfmlaRecord((WSP)pScanObject, dispatch->pfnSharedFormulaCell, pRec, hdr);
            break;
         #endif

#if(1) 
         case HEADER:
         case FOOTER:
            if(pRec)
            {
                rc = AddStringToBuffer(pGlobals, pScanObject, pRec);

            }
            break;
#endif

         #ifdef EXCEL_ENABLE_STRING_CELL
          case STRING:
            rc = ProcessStringRecord(pGlobals, pScanObject, dispatch->pfnStringCell, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_NOTE
         case NOTE:
         case EXPORT_NOTE:
            rc = ProcessNoteRecord(pGlobals, hdr.type, pScanObject, dispatch->pfnCellNote, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_OBJECT
         case OBJ:
            // Version 5 same number as V3/4 BUT different structure
            rc = ProcessObjectRecord(pGlobals, pScanObject, dispatch->pfnObject, pRec, hdr.length);
            break;
         #endif

         #ifdef EXCEL_ENABLE_IMAGE_DATA
         case IMDATA:
            {
            byte     __huge *pPictureRec;
            HGLOBAL  hPictureRec;
            IMHDR    imageHdr;

            rc = Peek(pWorkbook, (byte __far *)(&imageHdr), sizeof(imageHdr));
            if (rc == EX_errSuccess)
            {
               if (((imageHdr.format == fmtMetafile) || (imageHdr.format == fmtBitmap)) &&
                     (imageHdr.environment == envWindows))
               {
                  rc = ReadIMDataRecord
                      (pWorkbook->hFile, hdr.length, imageHdr.cbData, &pPictureRec, &hPictureRec);

                  if (rc == EX_errSuccess) {
                     rc = ProcessImageDataRecord
                         (dispatch->pfnImageData, &imageHdr, pPictureRec, hPictureRec);
                  }
               }
               else {
                  rc = ProcessImageDataRecord(dispatch->pfnImageData, &imageHdr, NULL, HNULL);
                  ExcelSkipRecord (pWorkbook, &hdr);
               }
            }
            }
            break;
         #endif

         #ifdef EXCEL_ENABLE_SCENARIO
         case SCENARIO:
            rc = ProcessScenarioRecord(pGlobals, pScanObject, dispatch->pfnScenario, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_DOC_ROUTING
         case DOCROUTE:
            rc = ProcessDocRouteRecord(pScanObject, dispatch->pfnDocRoute, pRec);
            break;

         case RECIPNAME:
            rc = ProcessRecipNameRecord(pScanObject, dispatch->pfnRecipientName, pRec);
            break;
         #endif

         case EOF:
            if (((pWorkbook->ctBOF -= 1) == 0) && (dispatch->pfnEOF != NULL))
               rc = ProcessEOFRecord(pGlobals, dispatch->pfnEOF, pRec);
            break;

         #ifdef EXCEL_ENABLE_CHART_BIFF
         case SERIESTEXT:
            if (pRec)
               rc = ProcessSeriesTextRecord(pGlobals, pScanObject, dispatch->pfnSeriesText, pRec);
            break;
         #endif

         #ifdef EXCEL_ENABLE_STRING_POOL_SCAN
         case STRING_POOL_TABLE:
            rc = ProcessStringPoolRecord(pGlobals, pScanObject, dispatch->pfnStringPool, pRec, hdr.length);
            break;
         #endif

         default:
            break;
      }

      if (pRec != NULL)
      {
         FREE_RECORD_BUFFER (pRec);
         pRec = NULL;
      }

      if ((rc != EX_errSuccess) || ((hdr.type == EOF) && (pWorkbook->ctBOF <= 0)))
         break;
   }
   return (rc);
}

/*---------------------------------------------------------------------------*/

public int ExcelScanWorkbook (void * pGlobals, EXLHandle bookHandle, EXCELDEF __far *dispatch)
{
   int     rc;
   WBP     pWorkbook = (WBP)bookHandle;
   char    __far *pName;
   char    sheetName[EXCEL_MAX_SHEETNAME_LEN + 1];
   int     cbName;
   byte    __far *pRec;
   RECHDR  hdr;
   int     docType, version, buildId, buildYear;
   long    docLength, currentPosition, boundSheetsPos;
   long    bundleHdrPosition;

   ASSERTION (pWorkbook->use == IsWorkbook);

   if (dispatch->version != EXCEL_CALLBACK_VERSION)
      return (EX_errBIFFCallbackVersion);

   BFSetFilePosition (pWorkbook->hFile, FROM_START, 0);

   forever {
      BFGetFilePosition (pWorkbook->hFile, &(pWorkbook->currentRecordPos));

      if (ExcelReadRecordHeader(pWorkbook, &hdr) != EX_errSuccess)
         return (NOT_EXPECTED_FORMAT);

      rc = EX_errSuccess;
      pRec = NULL;

      switch (hdr.type) {
         case BOF_V3:
         case BOF_V4:
            rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
            if (rc == EX_errSuccess) {
               if (pRec)
               {
                  ParseBOFRecord (hdr.type, pRec, &version, &docType, &buildId, &buildYear);
                  if (docType != docTypeXLW)
                     return (EX_errNotAWorkbook);
               }
               else
                  return (EX_errNotAWorkbook);
            }
            break;

         case BUNDLESOFFSET:
            rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
            if (rc == EX_errSuccess) {
               if (pRec)
               {
                  boundSheetsPos = XLONG(*((long __far UNALIGNED *)(pRec + 0)));

                  if (boundSheetsPos == pWorkbook->currentRecordPos) {
                     /*
                     ** Workbook contains no bound sheets
                     */
                     hdr.type = EOF;
                     break;
                  }

                  BFSetFilePosition (pWorkbook->hFile, FROM_START, boundSheetsPos);
               }
               else
                  return EX_errBIFFCorrupted;
            }
            break;

         case BUNDLEHEADER:
            bundleHdrPosition = pWorkbook->currentRecordPos;

            rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
            if (rc == EX_errSuccess)
            {
               if (pRec)
               {
                  BFGetFilePosition (pWorkbook->hFile, &currentPosition);

                  docLength = XLONG(*((long __far UNALIGNED *)(pRec + 0)));
                  cbName    = *((byte __far *)(pRec + 4));
                  pName     =  ((byte __far *)(pRec + 5));

                  memcpy (sheetName, pName, cbName);
                  sheetName[cbName] = EOS;

                  rc = ExcelReadRecordHeader(pWorkbook, &hdr);
                  if (rc != EX_errSuccess)
                     break;

                  if (hdr.type != BOF_V4) {
                     rc = NOT_EXPECTED_FORMAT;
                     break;
                  }

                  rc = ExcelReadTotalRecord(pGlobals, pWorkbook, &hdr, &pRec);
                  if (rc != EX_errSuccess)
                     break;

                  docType = XSHORT(*((short __far UNALIGNED *)(pRec + 2)));
                  if (docType == docTypeXLS)
                     docType = sheetTypeXLS;
                  else if (docType == docTypeXLM)
                     docType = sheetTypeXLM;
                  else if (docType == docTypeXLC)
                     docType = sheetTypeXLC;
                  else
                     docType = 0;

                  if (dispatch->pfnWBBundleHeader != NULL)
                     rc = dispatch->pfnWBBundleHeader(pGlobals, sheetName, docType, bundleHdrPosition);

                  BFSetFilePosition
                     (pWorkbook->hFile, FROM_START, currentPosition + docLength);
               }
               else
                  return EX_errBIFFCorrupted;
            }
            break;

         case EOF:
            break;

         default:
            ExcelSkipRecord (pWorkbook, &hdr);
      }

      if (pRec != NULL)
         FREE_RECORD_BUFFER (pRec);

      if ((rc != EX_errSuccess) || (hdr.type == EOF))
         break;
   }

   return (rc);
}

/*---------------------------------------------------------------------------*/

#ifdef EXCEL_ENABLE_DIRECT_CELL_READS
public int ExcelNextNonBlankCellInColumn
      (EXLHandle sheetHandle, EXA_CELL fromLocation, EXA_CELL __far *nonBlankLocation)
{
   int      rc;
   int      iScanRow;
   int      iRowBlock, iRow;
   RBP      pRowBlock;
   RIP      pRow;
   EXA_CELL cell;
   RECHDR   hdr;
   WSP      pWorksheet = (WSP)sheetHandle;
   CIP      pIndex;

   struct {
      short row;
      short col;
      short ixfe;
      short cbData;
   } labelHeader;

   ASSERTION (pWorksheet->use == IsWorksheet);

   if (WORKBOOK_IN_MEMORY(pWorksheet->pBook))
      return (EX_errMemoryImageNotSupported);

   if ((pIndex = pWorksheet->pPly->pCellIndex) == NULL)
      return (EX_errBIFFNoIndex);

   if (fromLocation.row + 1 < pIndex->firstRow)
      return (EX_wrnCellNotFound);

   if (fromLocation.row + 1 >= pIndex->lastRow)
      return (EX_wrnCellNotFound);

   for (iScanRow = fromLocation.row + 1; iScanRow < pIndex->lastRow; iScanRow++)
   {
      iRowBlock = (iScanRow - pIndex->firstRow) / ROWS_PER_BLOCK;
      iRow = (iScanRow - pIndex->firstRow) % ROWS_PER_BLOCK;

      if ((pRowBlock = pIndex->rowIndex[iRowBlock]) == NULL)
         continue;

      pRow = &(pRowBlock->row[iRow]);
      if (pRow->cellRecsPos == NO_SUCH_ROW)
         continue;

      if ((fromLocation.col < pRow->firstCol) || (fromLocation.col >= pRow->lastCol))
         continue;

      BFSetFilePosition
         (pWorksheet->hFile, FROM_START, pRow->cellRecsPos + pWorksheet->pBook->fileStartOffset);

      forever {
         BFGetFilePosition (pWorksheet->hFile, &(pWorksheet->pBook->currentRecordPos));

         if (ExcelReadRecordHeader(pWorksheet->pBook, &hdr) != EX_errSuccess)
            return (NOT_EXPECTED_FORMAT);

         if (!IsDataRecord(hdr.type))
            break;

         if (!IsCellRecord(hdr.type)) {
            ExcelSkipRecord (pWorksheet->pBook, &hdr);
            continue;
         }

         rc = PeekAtRowCol(pWorksheet->pBook, &cell.row, &cell.col);
         if (rc != EX_errSuccess)
            return (rc);

         if ((cell.row != iScanRow) || (cell.col > fromLocation.col))
            break;

         if (cell.col == fromLocation.col) {
            if (hdr.type == LABEL) {
               rc = Peek(pWorksheet->pBook, (byte __far *)(&labelHeader), sizeof(labelHeader));
               if (rc != EX_errSuccess)
                  return (rc);

               if (labelHeader.cbData == 0)
                  hdr.type = BLANK;
            }

            if (hdr.type == BLANK)
               break;

            nonBlankLocation->col = cell.col;
            nonBlankLocation->row = cell.row;
            return (EX_errSuccess);
         }
         ExcelSkipRecord (pWorksheet->pBook, &hdr);
      }
   }
   return (EX_wrnCellNotFound);
}


public int ExcelUpperLeftMostCell (EXLHandle sheetHandle, EXA_CELL __far *cellLocation)
{
   int rc;
   int iRowBlock, iRow;
   WSP pWorksheet = (WSP)sheetHandle;
   CIP pIndex;
   RBP pRowBlock;
   RIP pRow;
   RECHDR  hdr;

   ASSERTION (pWorksheet->use == IsWorksheet);

   if (WORKBOOK_IN_MEMORY(pWorksheet->pBook))
      return (EX_errMemoryImageNotSupported);

   if ((pIndex = pWorksheet->pPly->pCellIndex) == NULL)
      return (EX_errBIFFNoIndex);

   /*
   ** To find the upperleft most cell is more than just
   ** looking in the index structure
   */
   for (iRowBlock = 0; iRowBlock < pIndex->ctRowBlocks; iRowBlock++)
   {
      if ((pRowBlock = pIndex->rowIndex[iRowBlock]) != NULL)
      {
         for (iRow = 0; iRow < ROWS_PER_BLOCK; iRow++)
         {
            pRow = &(pRowBlock->row[iRow]);

            if (pRow->cellRecsPos != NO_SUCH_ROW) {
               BFSetFilePosition
                  (pWorksheet->hFile, FROM_START, pRow->cellRecsPos + pWorksheet->pBook->fileStartOffset);

               if (ExcelReadRecordHeader(pWorksheet->pBook, &hdr) != EX_errSuccess)
                  return (NOT_EXPECTED_FORMAT);

               if (IsCellRecord(hdr.type))
               {
                  rc = PeekAtRowCol(pWorksheet->pBook, &(cellLocation->row), &(cellLocation->col));
                  return (rc);
               }
            }
         }
      }
   }

   return (EX_wrnCellNotFound);
}

/*---------------------------------------------------------------------------*/

private BOOL CheckReadCache (WSP pWorksheet, EXA_CELL location, long __far *pRecordPos)
{
   WBP pWorkbook;

   ASSERTION (pWorksheet->use == IsWorksheet);
   pWorkbook = pWorksheet->pBook;

   if (pWorkbook->readCellCache.pPly != pWorksheet->pPly)
      return (FALSE);

   if ((location.row == pWorkbook->readCellCache.cell.row) &&
       (location.col >= pWorkbook->readCellCache.cell.col))
   {
      *pRecordPos = pWorkbook->readCellCache.offset;
      return (TRUE);
   }
   return (FALSE);
}

private void UpdateReadCache (WSP pWorksheet, EXA_CELL location, long recordPos)
{
   WBP pWorkbook;

   ASSERTION (pWorksheet->use == IsWorksheet);
   pWorkbook = pWorksheet->pBook;

   pWorkbook->readCellCache.cell = location;
   pWorkbook->readCellCache.offset = recordPos;
   pWorkbook->readCellCache.pPly = pWorksheet->pPly;
}

public void ExcelClearReadCache (WBP pWorkbook)
{
   NEED_WORKBOOK (pWorkbook);

   pWorkbook->readCellCache.cell.row = EXCEL_LAST_ROW + 1;
   pWorkbook->readCellCache.pPly = NULL;
}

public int ExcelReadCell (EXLHandle sheetHandle, EXA_CELL location, CV __far *pValue)
{
   int       rc;
   WSP       pWorksheet = (WSP)sheetHandle;
   WPP       pPly;
   int       iRowBlock, iRow;
   int       colLast;
   int       ixfe;
   RBP       pRowBlock;
   RIP       pRow;
   EXA_CELL  cell;
   byte      __far *pRec;
   RECHDR    hdr;
   TEXT      cellText;
   byte      __far *pPostfix;
   EXA_GRBIT options;
   FORM      formula;
   long      recordPos;

   ASSERTION (pWorksheet->use == IsWorksheet);

   #ifdef EXCEL_ENABLE_WRITE
   if (WORKBOOK_IN_MEMORY(pWorksheet->pBook)) {
      rc = ExcelMIReadCell(pWorksheet->pBook, pWorksheet->pPly->pMemoryImage, location, pValue);
      return (rc);
   }
   #endif

   pPly = pWorksheet->pPly;
   pValue->flags = 0;

   if (pPly->pCellIndex == NULL)
      return (EX_errBIFFNoIndex);

   if (CheckReadCache(pWorksheet, location, &recordPos))
   {
      BFSetFilePosition(pWorksheet->hFile, FROM_START, recordPos);
   }
   else {
      if (location.row < pPly->pCellIndex->firstRow)
         return (EX_wrnCellNotFound);

      if (location.row >= pPly->pCellIndex->lastRow)
         return (EX_wrnCellNotFound);

      iRowBlock = (location.row - pPly->pCellIndex->firstRow) / ROWS_PER_BLOCK;
      iRow = (location.row - pPly->pCellIndex->firstRow) % ROWS_PER_BLOCK;

      if ((pRowBlock = pPly->pCellIndex->rowIndex[iRowBlock]) == NULL)
         return (EX_wrnCellNotFound);

      pRow = &(pRowBlock->row[iRow]);
      if (pRow->cellRecsPos == NO_SUCH_ROW)
         return (EX_wrnCellNotFound);

      if ((location.col < pRow->firstCol) || (location.col >= pRow->lastCol))
         return (EX_wrnCellNotFound);

      BFSetFilePosition
         (pWorksheet->hFile, FROM_START, pRow->cellRecsPos + pWorksheet->pBook->fileStartOffset);
   }

   forever {
      BFGetFilePosition (pWorksheet->hFile, &(pWorksheet->pBook->currentRecordPos));

      if (ExcelReadRecordHeader(pWorksheet->pBook, &hdr) != EX_errSuccess)
         return (NOT_EXPECTED_FORMAT);

      rc = EX_errSuccess;
      pRec = NULL;

      if (IsDataRecord(hdr.type))
         ;
      else
         break;

      if ((hdr.type == STRING) || (hdr.type == ARRAY) || (hdr.type == SHRFMLA)) {
         ExcelSkipRecord (pWorksheet->pBook, &hdr);
         continue;
      }

      rc = PeekAtRowCol(pWorksheet->pBook, &cell.row, &cell.col);
      if (rc != EX_errSuccess)
         return (rc);

      if ((cell.row > location.row) || ((cell.row == location.row) && (cell.col > location.col)))
         break;

      if ((hdr.type == MULRK) || (hdr.type == MULBLANK)) {
         rc = ExcelReadTotalRecord(pWorksheet->pBook, &hdr, &pRec);
         if (rc != EX_errSuccess)
            return (rc);

         colLast = XSHORT(*((short __far UNALIGNED *)(pRec + (hdr.length - 2))));

         if ((location.col < cell.col) || (location.col > colLast))
            continue;

         pValue->flags |= cellvalueMULREC;
      }
      else {
         if ((cell.col != location.col) || (cell.row != location.row)) {
            ExcelSkipRecord (pWorksheet->pBook, &hdr);
            continue;
         }

         rc = ExcelReadTotalRecord(pWorksheet->pBook, &hdr, &pRec);
         if (rc != EX_errSuccess)
            return (rc);

         pValue->iFmt = XSHORT(*((short __far UNALIGNED *)(pRec + 4)));
      }

      switch (hdr.type) {
         #ifdef EXCEL_ENABLE_NUMBER_CELL
         case RK:
            {
            BOOL   isLong;
            long   xLong;
            double xDouble;

            pValue->flags |= (cellvalueRK | cellvalueNUM);
            pValue->reserved = ParseRKRecord(pRec, &cell, &ixfe, &isLong, &xDouble, &xLong);

            if (isLong == 0)
               pValue->value.IEEEdouble = xDouble;
            else
               pValue->value.IEEEdouble = (double)xLong;
            }
            break;

         case MULRK:
            {
            BOOL   isLong;
            long   xLong;
            double xDouble;

            pValue->flags |= (cellvalueRK | cellvalueNUM);
            pValue->reserved = ParseMulRKRecord(pRec, location, &isLong, &xDouble, &xLong, &(pValue->iFmt));

            if (isLong == 0)
               pValue->value.IEEEdouble = xDouble;
            else
               pValue->value.IEEEdouble = (double)xLong;
            }
            break;

         case NUMBER:
            pValue->flags |= cellvalueNUM;
            ParseNumberRecord(pRec, &cell, &ixfe, &(pValue->value.IEEEdouble));
            break;
         #endif

         #ifdef EXCEL_ENABLE_BLANK_CELL
         case BLANK:
            pValue->flags |= cellvalueBLANK;
            break;

         case MULBLANK:
            pValue->flags |= cellvalueBLANK;
            pValue->iFmt = XSHORT(*((short __far UNALIGNED *)(pRec + 4 + ((location.col - cell.col) * 2))));
            break;
         #endif

         #ifdef EXCEL_ENABLE_TEXT_CELL
         case LABEL:
         case RSTRING:
         case LABEL_V8:
            ParseLabelRecord(pWorksheet->pBook, hdr.type, pRec, &cell, &ixfe, &cellText);
            if (cellText == NULLTEXT) {
               pValue->flags |= cellvalueBLANK;
            }
            else {
               pValue->flags |= cellvalueTEXT;
               pValue->value.text = cellText;
            }
            break;
         #endif

         #if (defined(EXCEL_ENABLE_ERROR_CELL) || defined(EXCEL_ENABLE_BOOLEAN_CELL))
         case BOOLERR:
         {
            int  boolerrValue;
            BOOL isBoolean;

            ParseBoolerrRecord(pRec, &cell, &ixfe, &boolerrValue, &isBoolean);
            if (isBoolean == TRUE) {
               pValue->flags |= cellvalueBOOL;
               pValue->value.boolean = boolerrValue;
            }
            else {
               pValue->flags |= cellvalueERR;
               pValue->value.error = boolerrValue;
            }
            break;
         }
         #endif

         #ifdef EXCEL_ENABLE_FORMULA_CELL
         case FORMULA_V3:
         case FORMULA_V4:
         case FORMULA_V5:
            pValue->flags |= cellvalueFORM;
            rc = ParseFormulaRecord(pWorksheet, pRec, hdr, &cell, &ixfe, &formula, NULL, &options);
            if (rc == EX_errSuccess) {
               /*
               ** The formula.postfix is a pointer into the record we read
               ** from the biff file.  It is necessary to make a copy of
               ** the postfix so that it can be returned since we are about
               ** to free the record.
               */
               if ((pPostfix = MemAllocate(formula.cbPostfix)) == NULL)
                  rc = EX_errOutOfMemory;
               else {
                  memcpy (pPostfix, formula.postfix, formula.cbPostfix);
                  formula.postfix = pPostfix;
                  formula.options = options;
                  pValue->formula = formula;

                  rc = FormulaCurrentValue(pWorksheet->pBook, pRec, pValue, ENABLE_STRING_VALUE | FREE_REC_BUFFER);
                  if (rc != EX_errSuccess) {
                     MemFree (pPostfix);
                     pValue->formula.cbPostfix = 0;
                     pValue->formula.postfix = NULL;
                  }
                  pRec = NULL;
               }
            }
            break;
         #endif
      }

      if (pRec != NULL)
         FREE_RECORD_BUFFER(pRec);

      UpdateReadCache (pWorksheet, location, pWorksheet->pBook->currentRecordPos);
      return (rc);
   }

   if (pRec != NULL)
      FREE_RECORD_BUFFER(pRec);

   return (EX_wrnCellNotFound);
}

#ifdef EXCEL_ENABLE_NUMBER_CELL
public int ExcelReadIntCell (EXLHandle sheetHandle, EXA_CELL location, long __far *value)
{
   int rc;
   CV  readValue;

   if ((rc = ExcelReadCell(sheetHandle, location, &readValue)) != EX_errSuccess)
      return (rc);

   if ((readValue.flags & cellvalueFORM) != 0)
      MemFree (readValue.formula.postfix);

   if ((readValue.flags & cellvalueNUM) != 0)
      *value = (long)readValue.value.IEEEdouble;

   else if ((readValue.flags & cellvalueBLANK) != 0)
      rc = EX_wrnCellIsBlank;

   else if ((readValue.flags & cellvalueFORM) != 0)
      rc = EX_wrnCellHasFormula;

   else
      rc = EX_wrnCellWrongType;

   return (rc);
}

public int ExcelReadNumberCell (EXLHandle sheetHandle, EXA_CELL location, double __far *value)
{
   int rc;
   CV  readValue;

   if ((rc = ExcelReadCell(sheetHandle, location, &readValue)) != EX_errSuccess)
      return (rc);

   if ((readValue.flags & cellvalueFORM) != 0)
      MemFree (readValue.formula.postfix);

   if ((readValue.flags & cellvalueNUM) != 0)
      *value = readValue.value.IEEEdouble;

   else if ((readValue.flags & cellvalueBLANK) != 0)
      rc = EX_wrnCellIsBlank;

   else if ((readValue.flags & cellvalueFORM) != 0)
      rc = EX_wrnCellHasFormula;

   else
      rc = EX_wrnCellWrongType;

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_TEXT_CELL
public int ExcelReadTextCell (EXLHandle sheetHandle, EXA_CELL location, TEXT __far *value)
{
   int rc;
   CV  readValue;

   *value = NULLTEXT;

   if ((rc = ExcelReadCell(sheetHandle, location, &readValue)) != EX_errSuccess)
      return (rc);

   if ((readValue.flags & cellvalueFORM) != 0)
      MemFree (readValue.formula.postfix);

   if ((readValue.flags & cellvalueTEXT) != 0)
      *value = readValue.value.text;

   else if ((readValue.flags & cellvalueBLANK) != 0)
      rc = EX_wrnCellIsBlank;

   else if ((readValue.flags & cellvalueFORM) != 0)
      rc = EX_wrnCellHasFormula;

   else
      rc = EX_wrnCellWrongType;

   return (rc);
}
#endif

#ifdef EXCEL_ENABLE_BOOLEAN_CELL
public int ExcelReadBooleanCell (EXLHandle sheetHandle, EXA_CELL location, int __far *value)
{
   int rc;
   CV  readValue;

   if ((rc = ExcelReadCell(sheetHandle, location, &readValue)) != EX_errSuccess)
      return (rc);

   if ((readValue.flags & cellvalueFORM) != 0)
      MemFree (readValue.formula.postfix);

   if ((readValue.flags & cellvalueBOOL) != 0)
      *value = readValue.value.boolean;

   else if ((readValue.flags & cellvalueBLANK) != 0)
      rc = EX_wrnCellIsBlank;

   else if ((readValue.flags & cellvalueFORM) != 0)
      rc = EX_wrnCellHasFormula;

   else
      rc = EX_wrnCellWrongType;

   return (rc);
}
#endif
#endif

#ifdef EXCEL_ENABLE_FORMULA_EXPAND
public SFN ExcelSharedFormulaAccess (EXLHandle sheetHandle)
{
   WSP pWorksheet = (WSP)sheetHandle;

   ASSERTION (pWorksheet->use == IsWorksheet);

   return (pWorksheet->pPly->pSharedFormulaStore);
}

public int ExcelSharedFormulaToFormula
      (EXLHandle sheetHandle, SFN sharedFormula, FORM __far *pFormula)
{
   int  rc;
   WSP  pWorksheet = (WSP)sheetHandle;

   ASSERTION (pWorksheet->use == IsWorksheet);

   rc = BreakoutFormulaParts
       (pWorksheet,
        sharedFormula->cbDefinition + sharedFormula->cbExtra,
        sharedFormula->definition,
        sharedFormula->cbDefinition, pFormula);

   return (rc);
}
#endif

public int ExcelStopOnBlankCell (EXA_CELL location, int ixfe)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnTextCell (EXA_CELL location, int ixfe, TCHAR __far *value, int cbValue)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnBooleanCell (EXA_CELL location, int ixfe, int value)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnNumberCell (EXA_CELL location, int ixfe, double value)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnErrorCell (EXA_CELL location, int ixfe, int errorType)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnFormulaCell
      (EXA_CELL location, int ixfe, EXA_GRBIT flags, FRMP definition, CV __far *pValue)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnArrayFormulaCell
      (EXA_RANGE location, EXA_GRBIT flags, FRMP definition)
{
   return (EX_wrnScanStopped);
}

public int ExcelStopOnSharedFormulaCell (EXA_RANGE location, FRMP definition)
{
   return (EX_wrnScanStopped);
}

#endif // !VIEWER

static void ChompAmpersand(WCHAR *wszString, int *pcchString)
{
    int iRead, iWriteMinusOne;
    int iWrite=0;

    for(iRead=0; iRead < *pcchString; iRead++)
    {
        if (wszString[iRead] == L'&')
        {
            iRead++;
            switch(wszString[iRead])
            {
            case L'&':
                wszString[iWrite]=L'&';
                iWrite++;
                break;

            case L'"':
                do
                {
                    iRead++;
                } 
                while(iRead < *pcchString ? wszString[iRead] != L'"' : 0);

                // Fall through and write a space only if one does not exist before it
            default:
                iWriteMinusOne = iWrite-1;
                if (iWriteMinusOne >= 0 ? (wszString[iWriteMinusOne] != L' ' &&
                                           wszString[iWriteMinusOne] != L'\t' &&
                                           wszString[iWriteMinusOne] != L'\r' &&
                                           wszString[iWriteMinusOne] != L'\n')
                                        : 1)
                {
                    wszString[iWrite] = L' ';
                    iWrite++;
                }
                break;
            }
        }
        else
        {
            wszString[iWrite] = wszString[iRead];
            iWrite++;
        }
    }
    *pcchString = iWrite;
}

private HRESULT AddStringToBuffer(void * pGlobals, WBP pWorkbook, byte __far *pRec)
{
    int   rc;
    TCHAR __far *pResult;
    byte  __far *pString;
    int   cchString;

    char * pHeader = pRec; 
    int cnt = *pHeader++;
    if(*pHeader == 0) *pRec += 1;

    while(*pHeader == 0 && cnt > 0)
    {
        *pHeader++ = 0x20; cnt--;
    }
    
    cchString = (int)*pRec;
    pString   = pRec + 1;

    if (cchString == 0)
        return (EX_errSuccess);

    if ((rc = ExcelExtractBigString(pGlobals, pWorkbook, &pResult, pString, cchString)) < 0)
        return (rc);

    ChompAmpersand(pResult, &cchString);

    rc = AddToBufferPublic(pGlobals, pResult, cchString * sizeof(TCHAR));

    if (pResult != ExcelRecordTextBuffer)
        MemFree (pGlobals, pResult);

    return rc;
}

/* end EXCELRD.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlp.h ===
/*
** File: EXCELP.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes: Private functions and types
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* INCLUDE TESTS */
#define EXCELP_H

/* DEFINITIONS */

/*
**-----------------------------------------------------------------------------
** Workbook memory image
**-----------------------------------------------------------------------------
*/
// General record
typedef struct EXRecord {
   struct EXRecord *pNext;
   RECHDR hdr;
   byte   raw[1];
} EXRecord;

typedef enum {
   cellVarEmpty,
   cellVarBlank,
   cellVarBoolErr,
   cellVarFormula,
   cellVarLabel,
   cellVarNumber,
   cellVarRK,
   cellVarRString,
   cellVarAnsiLabel,
   cellVarAnsiRString
} cellVar;

#pragma pack(1)
typedef struct {                       // 2
   byte  bBoolErr;
   byte  fError;
} EXVariantBool;

typedef struct {                       // 12+
   byte    currentValue[8];
   short   grbit;
   short   cbFormula;
   byte    formula[1];
} EXVariantFormula;

typedef struct {                       // 8
   TEXT  text;
   long  iText;
} EXVariantLabel;

typedef struct {                       // 11+
   TEXT  text;
   long  iText;
   short cbFormat;
   byte  formatData[1];
} EXVariantRString;

typedef struct {                       // 8
   double IEEEDouble;
} EXVariantNumber;

typedef struct {                       // 4
   long  rk;
} EXVariantRK;

typedef union {
   EXVariantBool     bool;
   EXVariantFormula  formula;
   EXVariantLabel    label;
   EXVariantNumber   number;
   EXVariantRK       rk;
   EXVariantRString  rstring;
} EXCellVariant;

typedef struct EXCellData {
   struct EXCellData *pNext;
   short         ixfe;
   byte          iColumn;
   byte          iType;
   EXCellVariant value;
} EXCellData;

typedef struct EXCellPartner {
   struct EXCellPartner *pNext;
   EXA_CELL  cell;                 // This record follows this cell
   RECHDR    hdr;
   byte      raw[1];
} EXCellPartner;

typedef struct {
   byte   firstCol;
   byte   lastCol;
   short  height;
   short  grbit;
   short  ixfe;
   EXCellPartner *pPartnerList;
   EXCellPartner *pLastPartner;
   EXCellData    *pCellList;
   EXCellData    *pLastCell;       // Last cell in the row
} EXRow;

#define ROWS_PER_BLOCK 32

typedef struct EXRowBlock {
   struct EXRowBlock *pNext;
   int    row;                    // Always a multiple of ROWS_PER_BLOCK
   EXRow  *pRow[ROWS_PER_BLOCK];
   unsigned long filePosition;    // File position of DBCELL record
} EXRowBlock;
#pragma pack()

typedef struct {
   EXA_CELL   cell;
   EXCellData *pCell;
} EXReadCache;

typedef struct EXWorksheet {
   struct EXWorksheet *pNext;
   EXRecord       *pContents;     // Data and index records removed
   short          iType;
   short          hasIndex;
   EXA_RANGE      dimensions;
   BOOL           empty;
   unsigned short ctBlocks;
   EXRowBlock     *pBlocks;
   EXRowBlock     *pLastBlock;    // Last block accessed
   unsigned long  filePosition;   // File position of BOF record
   EXReadCache    readCache;
} EXWorksheet;

#define MAX_STRINGS_PER_POOL_BLOCK 1024

typedef struct EXStringPoolTemp {
   struct EXStringPoolTemp *pNext;
   int    iFirstEntry;
   int    iLastEntry;
   TEXT   entry[1];
} EXStringPoolTemp;

typedef struct EXStringFormatTemp {
   struct EXStringFormatTemp *pNext;
   TEXT   text;
   int    cbFormat;
   byte   format[1];
} EXStringFormatTemp;

#define WritePassForSize  0
#define WritePassForWrite 1

#define EX_CELL_POOL_SIZE 8184

typedef struct EXCellPool {
   struct EXCellPool *pNext;
   unsigned int iNext;
   byte data[EX_CELL_POOL_SIZE];
} EXCellPool;

typedef EXCellPool *EXCPP;

typedef struct {
   EXWorksheet        *pSheets;
   EXRecord           *pContents;    // All records but StringTable and StringIndex HDR only
   EXRecord           *pCurrentRecord;
   EXStringPoolTemp   *pSPTemp;
   EXStringFormatTemp *pSPFormatTemp;
   unsigned long      currentWritePos;
   int                writePass;
   EXCellPool         *pCellStorage;
   EXCellPool         *pCurrentCellStorage;
} EXWorkbook;

typedef EXWorkbook *EXWBP;

/*
**-----------------------------------------------------------------------------
** Common macros
**-----------------------------------------------------------------------------
*/
#define IS_BOF(x) \
   (((x) == BOF_V2) || ((x) == BOF_V3) || ((x) == BOF_V4) || ((x) == BOF_V5))


#define IsDataRecord(x) \
   ((x == LABEL)      || (x == RK)         || (x == NUMBER)     || \
    (x == MULRK)      || (x == MULBLANK)   || (x == BLANK)      || \
    (x == BOOLERR)    || (x == RSTRING)    || (x == LABEL_V8)   || \
    (x == FORMULA_V3) || (x == FORMULA_V4) || (x == FORMULA_V5) || \
    (x == STRING)     || (x == ARRAY)      || (x == SHRFMLA))

#define IsCellRecord(x) \
   ((x == BLANK)      || (x == RK)         || (x == NUMBER)     || \
    (x == LABEL)      || (x == RSTRING)    || (x == BOOLERR)    || \
    (x == MULBLANK)   || (x == MULRK)      || (x == LABEL_V8)   || \
    (x == FORMULA_V3) || (x == FORMULA_V4) || (x == FORMULA_V5))


#define NOTPASSNUMBERS(dispatch) (dispatch->pfnNumberCell == NULL)

#define NOTPASSBOOLERR(dispatch) \
   ((dispatch->pfnBooleanCell == NULL) && (dispatch->pfnErrorCell == NULL))

#define PASSNUMBERS(dispatch) (dispatch->pfnNumberCell != NULL)

#define PASSBOOLERR(dispatch) \
   ((dispatch->pfnBooleanCell != NULL) || (dispatch->pfnErrorCell != NULL))

//
// Version 8 string tags
//
#define V8_CUNICODE_STRING_TAG 0
#define V8_UNICODE_STRING_TAG  1
#define V8_ANSI_DBCS_TAG       2
//Office96.107932 Changes for EXTRST.
#define V8_TAG_MASK            0xf3 // 0xf7
#define V8_RTF_MODIFIER        0x08
#define V8_EXTRST_MODIFIER	   0x04

//Office96.107932 Changes for EXTRST.
typedef struct _extrst {
	WORD terst  : 15,	//Type of EXTRST
		 fNext : 1;
	WORD cb;
	} EXTRST;

#define V8_OK_TAG(tag) \
   (((tag & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG) || \
    ((tag & V8_TAG_MASK) == V8_UNICODE_STRING_TAG)  || \
    ((tag & V8_TAG_MASK) == V8_ANSI_DBCS_TAG))

#define IS_STRING_UNICODE(tag)  (((tag) & V8_TAG_MASK) == V8_UNICODE_STRING_TAG)
#define IS_STRING_CUNICODE(tag) (((tag) & V8_TAG_MASK) == V8_CUNICODE_STRING_TAG)
#define IS_STRING_DBCS(tag)     (((tag) & V8_TAG_MASK) == V8_DBCS_STRING_TAG)

//
// Formula current value tags
//
#define vtText 0
#define vtBool 1
#define vtErr  2

//
// V8 special value for the SupBook record
//
#define V8_LOCAL_BOOK_PATH 0x04010003

/*
** ----------------------------------------------------------------------------
** Cell Index
** ----------------------------------------------------------------------------
*/
#define NO_SUCH_ROW  0xffffffff

typedef struct {
   short     firstCol;
   short     lastCol;           // lastCol + 1
   short     height;
   short     ixfe;
   EXA_GRBIT grbit;
   long      cellRecsPos;
   long      rowRecPos;
} RowInfo, RI;

typedef RowInfo __far *RIP;

#define ROWS_PER_BLOCK 32

typedef struct {
   short  cbDBCellRec;          // V5: original size when first read
   long   DBCellRecPos;         // V5: file pos to DBCell rec
   RI     row[ROWS_PER_BLOCK];
} RowBlock;

typedef RowBlock __far *RBP;

typedef struct {
   unsigned short firstRow;
   unsigned short lastRow;      // lastRow + 1
   short  ctRowBlocks;
   short  cbIndexRec;           // original size when first read
   long   indexRecPos;
   RBP    rowIndex[1];          // [ctRowBlocks]
} CellIndex, CI;

typedef CellIndex __far *CIP;


/*
** ----------------------------------------------------------------------------
** Version 8 string pool index
** ----------------------------------------------------------------------------
*/
#pragma pack(1)
typedef struct {
   unsigned long offset;
   unsigned short blockOffset;
   unsigned short filler;
} SPIndexEntry;

#define SP_INDEX_ENTRY 128

typedef struct {
   unsigned short granularity;
   SPIndexEntry  entry[SP_INDEX_ENTRY];
} SPIndex;
#pragma pack()

/*
** ----------------------------------------------------------------------------
** Version 8 XTI table
** ----------------------------------------------------------------------------
*/
#define XTI_ITAB_ERROR -1
#define XTI_ITAB_NAME  -2

#pragma pack(1)
typedef struct {
   short iSupBook;
   short iTabFirst;
   short iTabLast;
} XTIEntry;

typedef struct {
   short    ctEntry;
   XTIEntry entry[1];
} XTI;
#pragma pack()

/*
** ----------------------------------------------------------------------------
** Workbook and worksheet data
** ----------------------------------------------------------------------------
*/
struct Workbook;
struct Worksheet;

typedef struct Workbook  __far *WBP;
typedef struct Worksheet __far *WSP;

typedef struct WorkbookPly {
   struct WorkbookPly __far *pNext;

   long         currentSheetPos;
   long         originalSheetPos;

   long         bundleRecPos;
   long         cellIndexRecPos;

   EXWorksheet  *pMemoryImage;

   EXA_RANGE    range;

   int          iType;
   int          useCount;

   CIP          pCellIndex;
   BOOL         modified;
   BOOL         hasUncalcedRec;
   SFN          pSharedFormulaStore;

   TCHAR        name[1];
} WorkbookPly;

typedef WorkbookPly __far *WPP;


typedef struct Worksheet {
   int          use;

   int          version;
   const int    *PTGSize;
   const int    *ExtPTGSize;
   TextStorage  textStorage;
   BFile        hFile;

   WSP          pNext;
   WBP          pBook;
   WPP          pPly;
} Worksheet;


typedef struct {
   EXA_CELL  cell;
   long      offset;
   WPP       pPly;
} CELLPOS;

typedef struct Workbook {
   int          use;

   int          version;
   const int    *PTGSize;
   const int    *ExtPTGSize;
   TextStorage  textStorage;
   BFile        hFile;

   EXWorkbook   *pMemoryImage;

   BOOL         modified;

   int          openOptions;
   long         fileStartOffset;     // Only != 0 for V4 workbook bound sheets

   WPP          pPlyList;
   WSP          pOpenSheetList;

   SPIndex      *pV8StringIndex;

   int          iSupBookLocal;
   XTI          *pXTITable;

   int          ctBOF;
   long         currentRecordPos;
   unsigned int currentRecordLen;
   CELLPOS      readCellCache;

   ExcelOLESummaryInfo OLESummaryInfo;
   int                 OLESummaryStatus;

   TCHAR         path[MAXPATH + 1];
} Workbook;

#define IsWorkbook  0
#define IsWorksheet 1

#define NEED_WORKBOOK(p) if (p->use == IsWorksheet) p = ((WSP)p)->pBook;

#define WORKBOOK_IN_MEMORY(p) (p->pMemoryImage != NULL)

#if defined(UNICODE)
   #define BOOK_NAME L"Book"
	#define WORKBOOK_NAME L"Workbook"
#else
   #define BOOK_NAME "Book"
	#define WORKBOOK_NAME "Workbook"
#endif

/*
** ----------------------------------------------------------------------------
** Globals
** ----------------------------------------------------------------------------
*/
#define MAX_EXCEL_REC_LEN 8224
//extern byte __far *pExcelRecordBuffer;
extern byte __far * GetExcelRecBuffer(void * pGlobals);
#define pExcelRecordBuffer GetExcelRecBuffer(pGlobals)


#define FREE_RECORD_BUFFER(p) if (p != pExcelRecordBuffer) MemFree(pGlobals, p);

#define CCH_RECORD_TEXT_BUFFER_MAX 512
//extern TCHAR ExcelRecordTextBuffer[CCH_RECORD_TEXT_BUFFER_MAX];
extern TCHAR * GetExcelRecordTextBuffer(void * pGlobals);
#define ExcelRecordTextBuffer GetExcelRecordTextBuffer(pGlobals)


#define CCH_UNICODE_EXPANSION_BUFFER_MAX 512
//extern wchar_t UnicodeExpansionBuffer[CCH_UNICODE_EXPANSION_BUFFER_MAX];
extern wchar_t * GetUnicodeExpansionBuffer(void * pGlobals);
#define UnicodeExpansionBuffer GetUnicodeExpansionBuffer(pGlobals)


/*
**-----------------------------------------------------------------------------
** Private functions
**-----------------------------------------------------------------------------
*/
extern void ExcelFreeCellIndex (void * pGlobals, CIP pCellIndex);

extern int ExcelTranslateBFError (int rc);

extern int ExcelReadRecordHeader (WBP pWorkbook, RECHDR __far *hdr);

extern int ExcelPeekRecordHeader (WBP pWorkbook, RECHDR __far *hdr);

extern int ExcelSkipRecord (WBP pWorkbook, RECHDR __far *hdr);

extern int ExcelReadTotalRecord
      (void * pGlobals, WBP pWorkbook, RECHDR __far *hdr, byte __far * __far *pResult);

extern long ExcelWorksheetBOFPos (WSP pWorksheet);

extern int ExcelGetLastRecordInfo
      (WBP pWorkbook, long __far *mark, unsigned int __far *cbRecord);

extern void ExcelClearReadCache (WBP pWorkbook);

#ifdef EXCEL_ENABLE_WRITE
   extern int ExcelWriteCellIndex (WSP pWorksheet);
   extern int ExcelWriteBundleSheetRecord (WBP pWorkbook, WPP pPly);
#endif

extern int ExcelExtractString
      (WBP pWorkbook, TCHAR __far *pDest, int cchDestMax, byte __far *pSource, int cchSource);

extern int ExcelExtractBigString
      (void * pGlobals, WBP pWorkbook, TCHAR __far **pDest, byte __far *pSource, int cchSource);

extern void ExcelConvertRK
      (long rk, BOOL __far *isLong, double __far *doubleValue, long __far *longValue);

typedef struct {
   byte __far *pRec;
   unsigned int  cbRemaining;
} PoolInfo;

extern int ExcelStringPoolNextString
   (void * pGlobals, WBP pWorkbook, PoolInfo *pPoolInfo, TCHAR **pResult, unsigned int *cbResult, BOOL *resultOnHeap);

extern int ExcelConvertToOurErrorCode (int excelEncoding);
extern int ExcelConvertFromOurErrorCode (int ourEncoding);

/*
**-----------------------------------------------------------------------------
** Private functions - memory image
**-----------------------------------------------------------------------------
*/
extern int ExcelMILoad (WBP pBook, EXWorkbook **pMIWorkbook);
extern int ExcelMISave (WBP pBook, EXWorkbook *pMIWorkbook, BOOL release);

extern int ExcelMIReadCell
      (WBP pWorkbook, EXWorksheet *pMIWorksheet, EXA_CELL location, CV __far *pValue);


extern int ExcelMICreateWorkbook (WBP pBook, EXWorkbook **pMIWorkbook);
extern int ExcelMIAppendPly (WBP pBook, EXWorkbook *pMIWorkbook, EXWorksheet **pMIWorksheet);

typedef enum {
   placeAtStreamStart,
   placeAtStreamEnd,
   placeAfterRecord,
   placeBeforeRecord
} MIRecPlacement;

extern int ExcelMIAddWorkbookRecord
      (WBP pBook, EXWorkbook *pMIWorkbook,
       long recordPos, MIRecPlacement place, RECHDR *hdr, byte *pData);

extern int ExcelMIAddWorksheetRecord
      (WBP pBook, EXWorksheet *pMIWorksheet,
       long recordPos, MIRecPlacement place, RECHDR *hdr, byte *pData);

extern int ExcelMIRecordUpdate (long recordPos, RECHDR *hdr, byte *pData);

extern int ExcelMIRemoveWorksheetRecord
       (EXWorksheet *pMIWorksheet, long recordPos, int recType);

extern int ExcelMIWriteCellList
      (WBP pBook, EXWorksheet *pMIWorksheet, int row, CVLP pCellList);


//
// Facilites for scanning through contents streams
//
#define MI_START_OF_WORKBOOK  0
#define MI_START_OF_WORKSHEET 0

extern int ExcelMISetPosition (WBP pWorkbook, long recordPos);
extern int ExcelMIGetPosition (WBP pWorkbook, long *recordPos);

extern int ExcelMIReadRecordHeader (WBP pWorkbook, RECHDR *pHdr);

extern int ExcelMIPeekRecordData (WBP pWorkbook, byte *pData, int cbData);

// Reads current record and positions to the next
extern int ExcelMIReadRecord (WBP pWorkbook, RECHDR *hdr, byte **pResult);

// Skips current record and positions to the next
extern int ExcelMISkipRecord (WBP pWorkbook, RECHDR *hdr);


#define findFIRST           0x0001
#define findLAST            0x0000
#define findSTART_OF_RECORD 0x0001
#define findEND_OF_RECORD   0x0002

extern int ExcelMIFindRecord
       (WBP pWorkbook, EXRecord *pContents,
        int recordType, unsigned int count, int options, long __far *pos);

/*
** ----------------------------------------------------------------------------
** MAC enabling
** ----------------------------------------------------------------------------
*/
#ifndef MAC
   #define XSHORT(x) x
   #define XLONG(x) x
   #define XDOUBLE(x) x
#endif

/*
** ----------------------------------------------------------------------------
** Error handling
** ----------------------------------------------------------------------------
*/
#ifdef AQTDEBUG
   extern int ExcelNotExpectedFormat (void);
   #define NOT_EXPECTED_FORMAT ExcelNotExpectedFormat()
#else
   #define NOT_EXPECTED_FORMAT EX_errBIFFCorrupted
#endif

/* end EXCELP.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlrec.h ===
/*
** File: EXRECTYP.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* INCLUDE TESTS */
#define EXRECTYP_H


/* DEFINITIONS */

/*
** ----------------------------------------------------------------------------
** Excel Record types
** ----------------------------------------------------------------------------
*/
#pragma pack(1)

typedef struct {
   short  type;
   short  length;
} RECHDR;

/*
** Header in the IMDATA record that precedes the picture data
*/

typedef struct {
   short format;
   short environment;
   unsigned long cbData;
} IMHDR;

#pragma pack()

#define DIMENSIONS            (0x200 + 0x00)
#define BLANK                 (0x200 + 0x01)
#define NUMBER                (0x200 + 0x03)
#define LABEL                 (0x200 + 0x04)
#define BOOLERR               (0x200 + 0x05)
#define FORMULA_V3            (0x200 + 0x06)
#define FORMULA_V4            (0x400 + 0x06)
#define FORMULA_V5             0x06
#define STRING                (0x200 + 0x07)
#define ROW                   (0x200 + 0x08)
#define BOF_V2                (0x09)
#define BOF_V3                (0x200 + 0x09)
#define BOF_V4                (0x400 + 0x09)
#define BOF_V5                (0x800 + 0x09)
#define EOF                    0x0a
#define INDEX                 (0x200 + 0x0b)
#define CALCCOUNT              0x0c
#define CALCMODE               0x0d
#define PRECISION              0x0e
#define REFMODE                0x0f
#define DELTA                  0x10
#define ITERATION              0x11
#define PROTECT                0x12
#define PASSWORD               0x13
#define HEADER                 0x14
#define FOOTER                 0x15
#define EXTERNCOUNT            0x16
#define EXTERNSHEET            0x17
#define NAME                  (0x200 + 0x18)
#define NAME_V5                0x18
#define WINDOW_PROTECT         0x19
#define VERTICAL_PAGE_BREAKS   0x1a
#define HORIZONTAL_PAGE_BREAKS 0x1b
#define NOTE                   0x1c
#define SELECTION              0x1d
#define FORMAT_V3              0x1e
#define FORMAT_V4             (0x400 + 0x1e)
#define ARRAY                 (0x200 + 0x21)
#define DATE_1904              0x22
#define EXTERNNAME            (0x200 + 0x23)
#define EXTERNNAME_V5          0x23
#define DEFAULT_ROW_HEIGHT    (0x200 + 0x25)
#define LEFT_MARGIN            0x26
#define RIGHT_MARGIN           0x27
#define TOP_MARGIN             0x28
#define BOTTOM_MARGIN          0x29
#define PRINT_HEADERS          0x2a
#define PRINT_GRIDLINES        0x2b
#define FILEPASS               0x2f
#define FONT                  (0x200 + 0x31)
#define FONT_V5                0x31
#define TABLE                 (0x200 + 0x36)
#define WINDESK                0x38
#define CONTINUE               0x3c
#define WINDOW1                0x3d
#define WINDOW2               (0x200 + 0x3e)
#define BACKUP                 0x40
#define PANE                   0x41
#define CODEPAGE               0x42
#define XF_V3                 (0x200 + 0x43) 
#define XF_V4                 (0x400 + 0x43) 
#define XF_V5                  0xe0
#define PLS                    0x4d
#define DCON                   0x50
#define DCONREF                0x51
#define DCONNAME               0x52
#define DEFCOLWIDTH            0x55
#define BUILTINFMTCOUNT        0x56
#define XCT                    0x59
#define CRN                    0x5a
#define FILESHARING            0x5b
#define WRITEACCESS            0x5c
#define OBJ                    0x5d
#define UNCALCED               0x5e
#define SAVERECALC             0x5f
#define TEMPLATE               0x60
#define INTL                   0x61
#define OBJPROTECT             0x63
#define COLINFO                0x7d
#define RK                    (0x200 + 0x7e)
#define IMDATA                 0x7f
#define GUTS                   0x80
#define WSBOOL                 0x81
#define GRIDSET                0x82
#define HCENTER                0x83
#define VCENTER                0x84
#define BUNDLESHEET            0x85
#define BOUNDSHEET_V5          0x85
#define WRITEPROT              0x86
#define ADDIN                  0x87
#define EDG                    0x88
#define PUB                    0x89
#define LH                     0x8b
#define COUNTRY                0x8c
#define HIDEOBJ                0x8d
#define BUNDLESOFFSET          0x8e
#define BUNDLEHEADER           0x8f
#define SORT                   0x90
#define SUB                    0x91
#define PALETTE                0x92
#define STYLE                 (0x200 + 0x93)
#define LHRECORD               0x94
#define LHNGRAPH               0x95
#define SOUND                  0x96
#define SYNC                   0x97
#define LPR                    0x98
#define STANDARD_WIDTH         0x99
#define FNGROUP_NAME           0x9a
#define FILTER_MODE            0x9b
#define FNGROUP_COUNT          0x9c
#define AUTOFILTERINFO         0x9d
#define AUTOFILTER             0x9e
#define SCL                    0xa0
#define SETUP                  0xa1
#define FNPROTO                0xa2
#define PROJEXTSHT             0xa3
#define TOOLBARVER             0xa4
#define FILESHARING2          (0x100 + 0xa5)
#define TOOLBARPOS             0xa6
#define TOOLBARDEF             0xa7
#define COORDLIST              0xa9
#define GCW                    0xab
#define GCW_ALT               (0x200 + 0x9a)
#define SCENMAN                0xae
#define SUP_BOOK              (0x100 + 0xae)
#define SCENARIO               0xaf
#define SXVIEW                 0xb0
#define SXVD                   0xb1
#define SXVI                   0xb2
#define SXSI                   0xb3
#define SXIVD                  0xb4
#define SXLI                   0xb5
#define SXPI                   0xb6
#define DOCROUTE               0xb8
#define RECIPNAME              0xb9
#define SHRFMLA               (0x400 + 0xbc)
#define MULRK                  0xbd
#define MULBLANK               0xbe
#define TOOLBARHDR             0xbf
#define TOOLBAREND             0xc0
#define MMS                    0xc1
#define ADDMENU                0xc2
#define DELMENU                0xc3
#define SXDI                   0xc5
#define SXDB                   0xc6
#define SXFDB                  0xc7
#define SXDBB                  0xc8
#define SXNUM                  0xc9
#define SXBOOL                 0xca
#define SXERR                  0xcb
#define SXINT                  0xcc
#define SXSTRING               0xcd
#define SXDTR                  0xce
#define SXNIL                  0xcf
#define SXTBL                  0xd0
#define SXTBRGIITM             0xd1
#define SXTBPG                 0xd2
#define OBJPROJ                0xd3
#define SXIDSTM                0xd5
#define RSTRING                0xd6
#define DBCELL                 0xd7
#define SXRNG                  0xd8
#define SXISXOPER              0xd9
#define BOOKBOOL               0xda
#define SXEXT                  0xdc
#define SCENPROTECT            0xdd
#define OLESIZE                0xde
#define UDDESC                 0xdf
#define INTERFACEHDR           0xe1
#define INTERFACEEND           0xe2
#define SXVS                   0xe3
#define BOOK_OFFICE_DATA       0xeb
#define SHEET_OFFICE_DATA      0xec
#define STRING_POOL_TABLE      0xfc
#define LABEL_V8               0xfd
#define STRING_POOL_INDEX      0xff

#define EXRECORD_LAST          0xff

#define TABID_V8               0x13d
#define SCL_V8                 0x160
#define XL5_MODIFY_V8          0x162
#define TXO_V8                 0x1b6


//
// This record type has been defined for use by Access Export.
// Here is what it is used for.
//
// When Access does an export it does it in two phases:
//  1. Create the table and add all the columns then close the table
//  2. Open the table and add the data.
//
// Between step 1 and step 2 the iisam must keep track of the
// column types.  This was done in version 3 and 4 files by
// storing a cell note in the upper left most cell of the export
// range.  This note contained the column types in an encoded form.
//
// When version 8 files were introduced the cell note features were
// made much more complex then they had been in previous versions.
// So complex in fact that it is beyond the capabilities of this code
// to create.  In order still use the same mechanism of a cell note
// to capture the types, the cell note for V5 and V8 files is written
// in the old format but using this new record type.  The record
// number if not used in Excel files any more so it will not conflict
// with anything that Excel writes.
//
// When the workbook is written from the memory image these cell
// notes are dropped.  That is, they exist only while the workbook 
// is in memory and not on the disk.
//
#define EXPORT_NOTE            0x34

/*
** NOTE: The following records have the same number in V5 and V4 but
** have a different structure
**
**   ARRAY
**   BOUNDSHEET
**   EXTERNSHEET
**   FORMAT
**   INDEX
**   OBJ
**   ROW
**   SETUP
**   STYLE
**   WINDOW1
**   WINDOW2
**   WSBOOL
*/

/*
** Chart records
*/
#define CHART_REC_START        0x1000

#define UNITS                  0x1001
#define CHART                  0x1002
#define SERIES                 0x1003
#define DATALINK               0x1004
#define DATAFORMAT             0x1006
#define LINEFORMAT             0x1007
#define MARKERFORMAT           0x1009
#define AREAFORMAT             0x100a
#define PIEFORMAT              0x100b
#define ATTACHEDLABEL          0x100c
#define SERIESTEXT             0x100d
#define CHARTFORMAT            0x1014
#define LEGEND                 0x1015
#define SERIESLIST             0x1016
#define BAR                    0x1017
#define LINE                   0x1018
#define PIE                    0x1019 
#define AREA                   0x101a
#define SCATTER                0x101b
#define CHARTLINE              0x101c
#define AXES                   0x101d
#define TICK                   0x101e
#define VALUERANGE             0x101f
#define CATEGORYRANGE          0x1020
#define AXISLINEFORMAT         0x1021
#define CHARTFORMATLINK        0x1022
#define DEFAULTTEXT            0x1024
#define CHARTTEXT              0x1025
#define FONTX                  0x1026
#define OBJECTLINK             0x1027
#define ARROW                  0x102d
#define ARROWHEAD              0x102f
#define FRAME                  0x1032
#define BEGIN                  0x1033
#define END                    0x1034
#define PLOTAREA               0x1035
#define CHARTSIZE              0x1036
#define RELATIVEPOSITION       0x1037
#define ARROWRELATIVEPOSITION  0x1038
#define CHART3D                0x103a
#define REFST                  0x103b
#define PICF                   0x103c
#define DROPBAR                0x103d
#define RADAR                  0x103e
#define SURFACE                0x103f
#define RADARAREA              0x1040
#define AXISPARENT             0x1041
#define LEGENDXN               0x1043
#define SHTPROPS               0x1044
#define SERTOCRT               0x1045
#define AXESUSED               0x1046
#define SBASEREF               0x1048
#define SERPARENT              0x104a
#define SERAUXTREND            0x104b
#define IFMT                   0x104e
#define POS                    0x104f
#define ALRUNS                 0x1050
#define AI                     0x1051
#define SERAUXERRBAR           0x105b
#define SERFMT                 0x105d

/* end EXRECTYP.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlstm.hpp ===
#ifndef XLSTM_HPP
#define XLSTM_HPP

#if !VIEWER

#ifdef FILTER
   #include "dmifstrm.hpp"
   #include "dmixlst2.h"
#else
   #include "ifstrm.hpp"
   #include "xlstream.h"
#endif

class CExcelStream : public IFilterStream
	{
    public:
       CExcelStream::CExcelStream()
       {
          hFile = 0; 
          pGlobals = 0; 
          pExcStreamBuff = NULL;
          m_fGlobalsInitialized = FALSE;
       }
      
      ULONG   AddRef();
      HRESULT Load(LPWSTR lpszFileName);
      HRESULT LoadStg(IStorage *pstg);
      HRESULT ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead);
      HRESULT GetNextEmbedding(IStorage ** ppstg);
      HRESULT Unload();
      ULONG   Release();
      HRESULT GetChunk(STAT_CHUNK * pStat);


    private:
      LCID GetDocLanguage(void);

      XLSHandle hFile;
      void * pGlobals;
      byte * pExcStreamBuff;
      int nExcStreamSize;
      int nExcStreamOffset;
      BOOL fLastText;
      BOOL fFirstChunk;
      BOOL m_fGlobalsInitialized;
	};

#endif // !VIEWER

#endif // XLSTM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixltyp.h ===
/*
** File: EXTYPES.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* INCLUDE TESTS */
#define EXTYPES_H


/* DEFINITIONS */

/*
** Basic cell and range types
*/
#pragma pack(1)

typedef struct {
   unsigned short row;
   unsigned short col;
} EXA_CELL;

#pragma pack()

typedef struct {
   unsigned short firstRow;
   unsigned short firstCol;
   unsigned short lastRow;
   unsigned short lastCol;
} EXA_RANGE;

typedef unsigned short EXA_GRBIT;

#define CELLS_SAME(x,y) \
       ((x.col == y.col) && (x.row == y.row))

#define RANGES_SAME(x,y) \
       ((x.firstRow == y.firstRow) && (x.firstCol == y.firstCol) && \
        (x.lastRow == y.lastRow)   && (x.lastCol == y.lastCol))

#define IS_WHOLE_ROW(x) \
       ((x.firstCol == EXCEL_FIRST_COL) && (x.lastCol == EXCEL_LAST_COL) && \
        (x.firstRow == x.lastRow))

#define IS_WHOLE_COL(x) \
       ((x.firstRow == EXCEL_FIRST_ROW) && (x.lastRow == EXCEL_LAST_ROW) && \
        (x.firstCol == x.lastCol))

#define CELL_IN_RANGE(r,c) \
       ((c.col >= r.firstCol) && (c.col <= r.lastCol) && \
        (c.row >= r.firstRow) && (c.row <= r.lastRow))

#define EMPTY_RANGE(r) \
       ((r.firstRow == 0) && (r.lastRow == 0) && (r.firstCol == 0) && (r.lastCol == 0))

#define RANGE_ROW_COUNT(x) (x.lastRow - x.firstRow + 1)
#define RANGE_COL_COUNT(x) (x.lastCol - x.firstCol + 1)

#define RANGE_ROW_COUNTP(x) (x->lastRow - x->firstRow + 1)
#define RANGE_COL_COUNTP(x) (x->lastCol - x->firstCol + 1)

/* end EXTYPES.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlstm.cpp ===
#include <windows.h>
#include <assert.h> 

#if !VIEWER

#ifdef FILTER
   #include "dmixlstm.hpp"
   #include "filterr.h"
#else
   #include "xlstm.hpp"
   #include "filterr.h"
#endif

//
//  Added so as to support DRM errors
//
#include "drm.h"


ULONG CExcelStream::AddRef()
{
   /* What do I do about errors from Initialize? */
   // They are handled in Load and LoadStg.

   fLastText = FALSE;
   m_fGlobalsInitialized = FALSE;

   if (SUCCEEDED(XLSAllocateGlobals (&pGlobals)) && SUCCEEDED(XLSInitialize(pGlobals)))
      {
      m_fGlobalsInitialized = TRUE;
      }
   return (1);
}

HRESULT CExcelStream::Load(TCHAR *lpszFileName)
{
   HRESULT rc;

   if (!m_fGlobalsInitialized)
       return E_OUTOFMEMORY;

   rc = XLSCheckInitialization(pGlobals);
   if (FAILED(rc))
           return (rc);

   rc = XLSFileOpen(pGlobals, lpszFileName, &hFile);
   fFirstChunk = TRUE;
   return (rc);
}

HRESULT CExcelStream::LoadStg(IStorage *pstg)
{
   if (!m_fGlobalsInitialized)
       return E_OUTOFMEMORY;

   HRESULT rc = CheckIfDRM( pstg );

   if ( FAILED( rc ) )
       return rc;

   rc = XLSCheckInitialization(pGlobals);
   if (FAILED(rc))
           return (rc);

   rc = XLSStorageOpen(pGlobals, pstg, &hFile);
   fFirstChunk = TRUE;
   return (rc);
}

int AlignBlock2( int x )
{
    return ( x + ( 8 - 1 ) ) & ~( 8 - 1 );
}

#define SIZE_INCREMENT_EXCSTREAMBUFF 256
#define MAXIMUM_BUFFER_SIZE 0xFFFF

HRESULT CExcelStream::ReadContent (VOID *pv, ULONG cb, ULONG *pcbRead)
{
   HRESULT rc;

   if(pExcStreamBuff == NULL)
   {
      rc = XLSFileRead(pGlobals, hFile, (byte *)pv, cb, pcbRead);
   }
   else
   {
      int nCnt = min((int)cb, nExcStreamSize - nExcStreamOffset);
      memcpy((byte *)pv, pExcStreamBuff + nExcStreamOffset, nCnt);
      *pcbRead = nCnt;
      nExcStreamOffset += nCnt;
      rc = 0;
      if(nExcStreamOffset >= nExcStreamSize)
      {
            LPMALLOC pIMalloc;                    
            if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc))
            {
               pIMalloc->Free(pExcStreamBuff);  
               pExcStreamBuff = NULL;
               pIMalloc->Release();  
               if(fLastText)
               {
                  rc = FILTER_S_LAST_TEXT;
               }
            }
            else
               rc = E_FAIL;
            
      }
      return rc;
   }
   
   if(rc == STG_E_INSUFFICIENTMEMORY)
   {
      // try to increase buffer size
      LPMALLOC pIMalloc;
      ULONG nBufSize = AlignBlock2(*pcbRead);

LIncreaseBuff:
      if (S_OK != CoGetMalloc (MEMCTX_TASK, &pIMalloc))
         return E_FAIL;
      if (pExcStreamBuff)
      {
         pIMalloc->Free(pExcStreamBuff);
         pExcStreamBuff = NULL;
      }

      nBufSize += SIZE_INCREMENT_EXCSTREAMBUFF;
      if (nBufSize > MAXIMUM_BUFFER_SIZE)
      {
         pIMalloc->Release();
         return E_OUTOFMEMORY;
      }

      pExcStreamBuff = (byte*)pIMalloc->Alloc(nBufSize);  
      pIMalloc->Release();  
      if(pExcStreamBuff == NULL)
      {
         return E_OUTOFMEMORY;
      }

      rc = XLSFileRead(pGlobals, hFile, (byte *)pExcStreamBuff, nBufSize, pcbRead);
      if (rc == STG_E_INSUFFICIENTMEMORY)
      {
         nBufSize = AlignBlock2(max(*pcbRead, nBufSize));
         goto LIncreaseBuff;
      }
      if(rc == FILTER_S_LAST_TEXT)
      {
         fLastText = TRUE;
         rc = 0;
      }
      if(rc == 0)
      { 
         if(*pcbRead <= cb)
         {
            memcpy((byte *)pv, pExcStreamBuff, *pcbRead);
            LPMALLOC pIMalloc;                    
            if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc))
            {
               pIMalloc->Free(pExcStreamBuff);  
               pExcStreamBuff = NULL;
               pIMalloc->Release();
               if (fLastText)
                  rc = FILTER_S_LAST_TEXT;
            }
            else
               rc = E_FAIL;
         }
         else
         {
            memcpy((byte *)pv, pExcStreamBuff, cb);
            nExcStreamSize = *pcbRead;
            nExcStreamOffset = cb;
            *pcbRead = cb;
         }
      }
      else
      {
         LPMALLOC pIMalloc;                    
         if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc))
         {
            pIMalloc->Free(pExcStreamBuff);  
            pExcStreamBuff = NULL;
            pIMalloc->Release();
         }
         *pcbRead = 0; // We tried to allocate more memory and re-read, but failed
      }
   }

   if (rc == 0 && *pcbRead == 0)
      return (FILTER_E_NO_MORE_TEXT);

   return (rc);
}

HRESULT CExcelStream::GetNextEmbedding(IStorage ** ppstg)
{
   HRESULT rc;

   rc = XLSNextStorage(pGlobals, hFile, ppstg);
   return (rc);
}

HRESULT CExcelStream::Unload()
{
   HRESULT rc = S_OK;

   if(hFile)
   {
      rc = XLSFileClose(pGlobals, hFile);
      hFile = 0;
   }

   return (rc);
}

ULONG CExcelStream::Release()
{
   HRESULT rc;

   /* What do I do about errors from terminate? */
   // O10 Bug 335051:  Better question...what do you do if pGlobals is NULL?  Crash of course!
   if (m_fGlobalsInitialized && pGlobals != NULL)
      {
      rc = XLSTerminate(pGlobals);
      XLSDeleteGlobals (&pGlobals);
      m_fGlobalsInitialized = FALSE;
      }
   
   if(pExcStreamBuff)
   {
      LPMALLOC pIMalloc;                    
      if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc))
      {
         pIMalloc->Free(pExcStreamBuff);  
         pExcStreamBuff = NULL;
         pIMalloc->Release();  
      }
   }
   return (0);
}

HRESULT CExcelStream::GetChunk(STAT_CHUNK * pStat)
{
    if(fFirstChunk)
    {
        pStat->locale = GetDocLanguage();
        fFirstChunk = FALSE;
        return S_OK;
    }
    else
    {
        return FILTER_E_NO_MORE_TEXT;
    }
}

LCID CExcelStream::GetDocLanguage(void)
{
    return XLSGetLCID(pGlobals);
}

#endif // !VIEWER

/* end XLSTM.CPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlst2.h ===
/*
** XLSTREAM.H
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Excel XLS file filter.
**
** Edit History:
**  06/15/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define XLSTREAM_H


/* DEFINITIONS */

#ifdef  __cplusplus
extern "C" {
#endif

#ifdef WIN32
   #define __far
#endif

typedef byte *XLSHandle;

// Connects to AddRef
extern HRESULT XLSInitialize (void * pGlobals);

// Connects to Release
extern HRESULT XLSTerminate  (void * pGlobals);

extern HRESULT XLSCheckInitialization  (void * pGlobals);

// Connects to Load
extern HRESULT XLSFileOpen (void * pGlobals, TCHAR *pathname, XLSHandle *hXLSFile);

// Connects to LoadStg
extern HRESULT XLSStorageOpen (void * pGlobals, LPSTORAGE pStorage, XLSHandle *hXLSFile);

// Connects to GetNextEmbedding
extern HRESULT XLSNextStorage (void * pGlobals, XLSHandle hXLSFile, LPSTORAGE *pStorage);

// Connects to Unload
extern HRESULT XLSFileClose (void * pGlobals, XLSHandle hXLSFile);

// Connects to ReadContent
extern HRESULT XLSFileRead
      (void * pGlobals, XLSHandle hXLSFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed);

extern HRESULT XLSAllocateGlobals (void ** ppGlobals);
extern void XLSDeleteGlobals (void ** ppGlobals);
extern LCID XLSGetLCID(void * pGlobals);

#ifdef  __cplusplus
}
#endif

#endif // !VIEWER
/* end XLSTREAM.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmixlst2.c ===
/*
** XLSTREAM.C
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Excel XLS file filter.
**
** Edit History:
**  06/15/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifndef INC_OLE2
   #define INC_OLE2
#endif

#include <string.h>
#include <windows.h>

#ifndef WIN32
   #include <ole2.h>
#endif

#ifdef FILTER
  #ifndef FILTER_LIB
        #include "msostr.h"
  #endif
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmitext.h"
   #include "dmixltyp.h"
   #include "dmiexcel.h"
   #include "dmiexfmt.h"
   #include "dmifmtcp.h"
   #include "dmscp.h"
   #include "dmixlst2.h"
   #include "filterr.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "extypes.h"
   #include "extext.h"
   #include "excel.h"
   #include "exformat.h"
   #include "fmtcp.h"
   #include "scp.h"
   #include "xlstream.h"
   #include "filterr.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */

extern UINT CodePageFromLid(UINT wLid);

public void InitNoteExtra(void * pGlobals);
public void AddNoteExtra(void * pGlobals, short cdData);
public int GetNoteExtra(void * pGlobals);
public TCHAR * GetExcelRecordTextBuffer(void * pGlobals);
public wchar_t * GetUnicodeExpansionBuffer(void * pGlobals);
public byte __far * GetExcelRecBuffer(void * pGlobals);
public void SetExcelRecordBuffer(void * pGlobals, byte __far * pBuff);
public void SetCustomFormatDatabase(void * pGlobals, void *);
public void * GetCustomFormatDatabase(void * pGlobals);

void SetSeenAMPM(void * pGlobals, BOOL);
BOOL GetSeenAMPM(void * pGlobals);

void SetOrDateFormatNeeds(void * pGlobals, byte);
void SetDateFormatNeeds(void * pGlobals, byte);
byte GetDateFormatNeeds(void * pGlobals);

void * GetMemFreeList(void * pGlobals);
void SetMemFreeList(void * pGlobals, void * pList);

void *  GetMemPageList(void * pGlobals);
void SetMemPageList(void * pGlobals, void * pList);
double GetNumSmallExp(void * pGlobals);
void   SetNumericSmallExponential(void * pGlobals, double d);
BOOL SHOULD_USE_EXP_FORMAT(void * pGlobals, double x);


/* DAVID's change size_t __cdecl wcslenU ( const wchar_t UNALIGNED * wcs )
{
    const wchar_t UNALIGNED *eos = wcs;

    while( *eos++ ) ;

    return( (size_t)(eos - wcs - 1) );
}

#undef STRLEN
#define STRLEN wcslenU*/


/* MODULE DATA, TYPES AND MACROS  */

typedef struct {
   BOOL isStandardWidth;
   BOOL isUserSet;
   unsigned int width;
} COLINFO;

typedef struct SheetData {
   struct    SheetData *next;
   EXA_RANGE range;
   byte      usable;
   TCHAR     name[EXCEL_MAX_SHEETNAME_LEN + 1];
} SheetData;

typedef SheetData *SHDP;

typedef struct XFRecordData {
   struct XFRecordData *next;
   int       ifont;
   int       ifmt;
   EXA_GRBIT grbit;
} XFRecordData;

typedef XFRecordData *XFRP;

typedef struct FmtRecordData {
   struct FmtRecordData *next;
   int       ifmt;
   FMTHANDLE hFormat;
} FmtRecordData;

typedef FmtRecordData *FMRP;

typedef struct {
   int            version;
   const int      *PTGSize;
   const int      *PTGExtSize;

   CPID           codePage;
   unsigned short dateSystem;

   BOOL           macTranslation;
   CPID           macToWinCodePage;

   EXLHandle      hBook;
   EXLHandle      hSheet;

   XFRP           pXFRecords;
   XFRP           pLastXF;

   FMRP           pFmtRecords;
   FMRP           pLastFmt;

   SHDP           pSheetList;
   SHDP           pCurrentSheet;
   ExcelBookmark  currentMark;
   ExcelBookmark  lastMark;
   unsigned long  lastcbBuffer;

   BOOL           tabNamesPassed;
   BOOL           bookScanned;
   BOOL           protectedSheet;
   BOOL           pswdProtectedSheet;
   int            stringPoolStart;

   COLINFO        colSize[EXCEL_MAX_COLS];
   unsigned int   standardColWidth;

   EXA_CELL       lastFormulaLocation;

   byte           *pBufferData;
   unsigned long  cbBufferSize;
   unsigned long  cbBufferUsed;

   LPSTORAGE      pRootStorage;
   LPSTORAGE      pEnumStorage;
   LPENUMSTATSTG  pEnum;
   unsigned long  cbBufReqSize;
}  FileData;

typedef FileData *FDP;

//static FDP pCurrentFile;

#define EX_errBufferFull          (EX_errLAST - 1)
#define EX_errBufferTooSmall      (EX_errLAST - 2)
#define EX_errUnsupportedCodePage (EX_errLAST - 3)
#define EX_errSheetPswdProtected  (EX_errLAST - 4)


#define DEFAULT_COL_WIDTH   0x8e3   /* in 256'ths of a character */

//static CP_INFO   ControlPanelSettings;
//static FMTHANDLE hCurrencyFormat;
//static FMTHANDLE hNumericFormat;
//static FMTHANDLE hExpNumericFormat;
//static FMTHANDLE hDateTimeFormat;
//static FMTHANDLE hDateFormat;
//static FMTHANDLE hTimeFormat;

#define INIT_DATA (MEM_TEMP_PAGE_ID + 1)

static const double ExpTable[] = {1, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9};
//static double NumericSmallExponential, CurrencySmallExponential;

#define USE_EXP_FORMAT_BIG 1.0E11

//#define SHOULD_USE_EXP_FORMAT(x) \
//        (   ((x) != 0) && ( ((x) < GetNumSmallExp(pGlobals)))   ||    ((x) > USE_EXP_FORMAT_BIG)   )

#define ABS(x) (((x) < 0) ? -(x) : (x))


#define CT_OK_CODEPAGES 14
static const CPID OKCodePages[CT_OK_CODEPAGES] =
    {cpidEE,
     cpidCyril,
     cpidANSI,
     cpidGreek,
     cpidTurk,
     cpidMac,
     cpidMGreek,
     cpidMCyril,
     cpidMSlavic,
     cpidMIce,
     cpidMTurk,
     0x8000,       /* V3 for Mac */
     0x8001,       /* V3 for Windows */
     1200                       /* Unicode */
    };

#define CT_OK_MAC_CODEPAGES 7
static const CPID MacToWinCodePage[CT_OK_MAC_CODEPAGES][2] =
    {{cpidMac,     cpidANSI},
     {cpidMGreek,  cpidGreek},
     {cpidMCyril,  cpidCyril},
     {cpidMSlavic, cpidMSlavic},
     {cpidMIce,    cpidANSI},
     {cpidMTurk,   cpidTurk},
     {0x8000,      cpidANSI}
    };

#define CPIDToLCID_CODEPAGES 36
static const CPID CPIDToLCID[CPIDToLCID_CODEPAGES][2] =
    {
        {cpid437,    0x0409},                   /* DOS, US English */
        {cpid737,    0x0408},                   /* DOS, Greek 437G */
        {cpid850,    0},                            /* DOS, Multilingual */
        {cpid851,        0x0408},          /* DOS, Greek */
        {cpid852,    0x0809},                   /* DOS, Latin-2 */
        {cpid855,    0x0419},               /* DOS, Russian */
        {cpid857,    0x041f},                   /* DOS, Turkish */
        {cpid860,    0x0816},                   /* DOS, Portugal */
        {cpid863,    0x0c0c},                   /* DOS, French Canada */
        {cpid865,    0x0414},                   /* DOS, Norway */
        {cpid866,    0x0419},                   /* DOS, Russian */
        {cpid869,    0x0408},                   /* DOS, Greek */

        /* Windows code page numbers */
        {cpidEE,     0x0809},                           /* Windows, Latin-2 (East European) */
        {cpidCyril,  0x0419},                   /* Windows, Cyrillic */
        {cpidANSI,   0x0409},                   /* Windows, Multilingual (ANSI) */
        {cpidGreek,  0x0408},                   /* Windows, Greek */
        {cpidTurk,   0x041f},                   /* Windows, Turkish */
        {cpidHebr,   0x040d},                   /* Windows, Hebrew */
        {cpidArab,   0x0401},                   /* Windows, Arabic */

        /* East Asia Windows code page numbers (sanctioned by IBM/Japan) */
        {cpidSJIS,   0x0411},                   /* Japanese Shift-JIS */
        {cpidPRC,    0x0404},                   /* Chinese GB 2312 (Mainland China) */
        {cpidKSC,    0x0412},                   /* Korean KSC 5601 */
        {cpidBIG5,   0x0404},                   /* Chinese Big-5 (Taiwan) */

        /* Mac code pages (10000+script ids) */
        {cpidMac,    0x0409},                           /* Mac, smRoman */
        {cpidMacSJIS, 0x0411},          /* Mac, smJapanese */
        {cpidMacBIG5, 0x0404},          /* Mac, smTradChinese */
        {cpidMacKSC, 0x0412},           /* Mac, smKorean */
        {cpidMArab,  0x0401},               /* Mac, smArabic */
        {cpidMHebr,  0x040d},               /* Mac, smHebrew */
        {cpidMGreek, 0x0408},                   /* Mac, smGreek */
        {cpidMCyril, 0x0419},                   /* Mac, smCyrillic */
        {cpidMacPRC, 0x0404},       /* Mac, smSimpChinese */
        {cpidMSlavic, 0x0405},                  /* Mac, smEastEurRoman */
        {cpidMIce,   0x040f},               /* Mac, smRoman,langIcelandic */
        {cpidMTurk,  0x041f},               /* Mac, smRoman,langTurkish */
        {cpidUnicode, 0} 
    };

typedef int EBAPI FTRANSLATESCP(CPID, CPID, unsigned char FAR *, unsigned);

//static FTRANSLATESCP *pfnFTranslateScp = NULL;
//static HINSTANCE     hSCPLib = HNULL;

static const HRESULT ErrorMap[] =
       {
       /* EX_errSuccess                  */ ((HRESULT)0),
       /* EX_errGeneralError             */ E_FAIL,
       /* EX_errOutOfMemory              */ E_OUTOFMEMORY,
       /* EX_errBIFFFileNotFound         */ FILTER_E_ACCESS,
       /* EX_errBIFFPathNotFound         */ FILTER_E_ACCESS,
       /* EX_errBIFFCreateFailed         */ E_FAIL,
       /* EX_errBIFFFileAccessDenied     */ FILTER_E_ACCESS,
       /* EX_errBIFFOutOfFileHandles     */ E_FAIL,
       /* EX_errBIFFIOError              */ E_FAIL,
       /* EX_errBIFFDiskFull             */ E_FAIL,
       /* EX_errBIFFCorrupted            */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBIFFNoIndex              */ E_FAIL,
       /* EX_errBIFFPasswordProtected    */ FILTER_E_PASSWORD,
       /* EX_errBIFFVersion              */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBIFFCallbackVersion      */ E_FAIL,
       /* EX_errBIFFFormulaPostfixLength */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBIFFFormulaExtraLength   */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBIFFFormulaUnknownToken  */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBIFFUnknownArrayType     */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errOLEInitializeFailure     */ E_FAIL,
       /* EX_errOLENotCompoundFile       */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errOLEFailure               */ E_FAIL,
       /* EX_errBIFFNoSuchSheet          */ E_FAIL,
       /* EX_errNotAWorkbook             */ E_FAIL,
       /* EX_errChartOrVBSheet           */ E_FAIL,
       /* EX_NoSummaryInfo               */ E_FAIL,
       /* EX_SummaryInfoError            */ E_FAIL,
       /* EX_errRecordTooBig             */ STG_E_INSUFFICIENTMEMORY,
       /* EX_errMemoryImageNotSupported  */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errDiskImageNotSupported    */ FILTER_E_UNKNOWNFORMAT,
       /* EX_errBufferFull               */ ((HRESULT)0),
       /* EX_errBufferTooSmall           */ STG_E_INSUFFICIENTMEMORY,
       /* EX_errUnsupportedCodePage      */ E_FAIL,
       /* EX_errSheetPswdProtected       */ FILTER_E_PASSWORD,
       };

#define maxError        (sizeof(ErrorMap)/sizeof(HRESULT))



#define CCH_UNICODE_TEMP 256
#define CCH_ANSI_TEMP 256
#define CCH_EXPANSION_TEMP 256


#define CCH_RECORD_TEXT_BUFFER_MAX 512
#define CCH_UNICODE_EXPANSION_BUFFER_MAX 512

typedef struct
{
   FDP pCurrentFile;
   CP_INFO   ControlPanelSettings;
   
   double NumericSmallExponential;
   double CurrencySmallExponential;
   
   FMTHANDLE hCurrencyFormat;
   FMTHANDLE hNumericFormat;
   FMTHANDLE hExpNumericFormat;
   FMTHANDLE hDateTimeFormat;
   FMTHANDLE hDateFormat;
   FMTHANDLE hTimeFormat;
   
   FTRANSLATESCP *pfnFTranslateScp;
   HINSTANCE     hSCPLib;

   int NoteExtra;
   TCHAR   ExcelRecordTextBuffer[CCH_RECORD_TEXT_BUFFER_MAX];
   wchar_t UnicodeExpansionBuffer[CCH_UNICODE_EXPANSION_BUFFER_MAX];
   byte __far *pExcelRecordBuffer;
   void * pCustomFormatDatabase;
   byte DateFormatNeeds;
   BOOL   SeenAMPM;
   void *       MemFreeList;
   void *       MemPageList;

} XLS_GLOBALS;

#define pCurrentFile ((XLS_GLOBALS*)pGlobals)->pCurrentFile
#define ControlPanelSettings ((XLS_GLOBALS*)pGlobals)->ControlPanelSettings

//#define NumericSmallExponential ((XLS_GLOBALS*)pGlobals)->NumericSmallExponential
//#define NumericSmallExponential GetNumSmallExp(pGlobals)

#define CurrencySmallExponential ((XLS_GLOBALS*)pGlobals)->CurrencySmallExponential

#define hCurrencyFormat ((XLS_GLOBALS*)pGlobals)->hCurrencyFormat
#define hNumericFormat ((XLS_GLOBALS*)pGlobals)->hNumericFormat
#define hExpNumericFormat ((XLS_GLOBALS*)pGlobals)->hExpNumericFormat
#define hDateTimeFormat ((XLS_GLOBALS*)pGlobals)->hDateTimeFormat
#define hDateFormat ((XLS_GLOBALS*)pGlobals)->hDateFormat
#define hTimeFormat ((XLS_GLOBALS*)pGlobals)->hTimeFormat

#define pfnFTranslateScp ((XLS_GLOBALS*)pGlobals)->pfnFTranslateScp
#define hSCPLib ((XLS_GLOBALS*)pGlobals)->hSCPLib

/* IMPLEMENTATION */

private HRESULT TranslateToHResult (int rc)
{
   return (ErrorMap[-rc]);
}

private BOOL SetupSCPLibrary (void * pGlobals)
{
   #define SCP_LIBRARY "SCP32.DLL"

   if (hSCPLib != HNULL)
      return (TRUE);

   #ifdef WIN32
      if ((hSCPLib = LoadLibraryA(SCP_LIBRARY)) == NULL)
             return (FALSE);
   #else
      if ((hSCPLib = LoadLibraryA(SCP_LIBRARY)) < 32)
         return (FALSE);
   #endif

   pfnFTranslateScp = (FTRANSLATESCP *)GetProcAddress(hSCPLib, "FTranslateScp");

   if (pfnFTranslateScp == NULL)
      return (FALSE);
   else
      return (TRUE);
}

private BOOL IsSupportedCodePage (void * pGlobals, CPID codePage)
{
   int  i;

   for (i = 0; i < CT_OK_CODEPAGES; i++) {
      if (codePage == OKCodePages[i])
         return (TRUE);
   }
   return (FALSE);
}

private CPID TranslateMacToWindowsCodePage (CPID codePageMac)
{
   int  i;

   for (i = 0; i < CT_OK_MAC_CODEPAGES; i++) {
      if (MacToWinCodePage[i][0] == codePageMac)
         return (MacToWinCodePage[i][1]);
   }
   return (cpidANSI);
}

void SetGlobalWideFlag();

public HRESULT XLSInitialize (void * pGlobals)
{
   int     rc;
   CP_FMTS StandardFormats;

#if (defined FILTER_LIB || !defined FILTER)
        SetGlobalWideFlag();
#endif

        if ((rc = ExcelInitialize(pGlobals)) != EX_errSuccess)
      return (TranslateToHResult(rc));

   FMTControlPanelGetSettings (pGlobals, &ControlPanelSettings);

   /*
   ** Don't use the thousands separator regardless of the control panel
   */
   ControlPanelSettings.numberThousandSeparator = EOS;

   ControlPanelBuildFormats (&ControlPanelSettings, &StandardFormats);

   FMTStoreFormat (pGlobals, StandardFormats.currency,     &ControlPanelSettings, &hCurrencyFormat);
   FMTStoreFormat (pGlobals, StandardFormats.numericSmall, &ControlPanelSettings, &hNumericFormat);
   FMTStoreFormat (pGlobals, StandardFormats.numericBig,   &ControlPanelSettings, &hExpNumericFormat);
   FMTStoreFormat (pGlobals, StandardFormats.dateTime,     &ControlPanelSettings, &hDateTimeFormat);
   FMTStoreFormat (pGlobals, StandardFormats.date,         &ControlPanelSettings, &hDateFormat);
   FMTStoreFormat (pGlobals, StandardFormats.time,         &ControlPanelSettings, &hTimeFormat);

   /*
   ** Determine when to use exponential display format
   */
   SetNumericSmallExponential(pGlobals, ExpTable[ControlPanelSettings.numberDigits]);  
   CurrencySmallExponential = ExpTable[ControlPanelSettings.currencyDigits];

   return ((HRESULT)0);
}

public HRESULT XLSCheckInitialization  (void * pGlobals)
{
   if (!pGlobals)
       return (TranslateToHResult(EX_errOutOfMemory));

   if (GetExcelRecBuffer(pGlobals) == NULL)
           return (TranslateToHResult(EX_errOutOfMemory));

   return ((HRESULT)0);
}

public HRESULT XLSTerminate (void * pGlobals)
{
   ExcelTerminate(pGlobals);
   FMTControlPanelFreeSettings (pGlobals, &ControlPanelSettings);

   if (pGlobals) {
      FMTDeleteFormat (pGlobals, hCurrencyFormat);
      FMTDeleteFormat (pGlobals, hNumericFormat);
      FMTDeleteFormat (pGlobals, hExpNumericFormat);
      FMTDeleteFormat (pGlobals, hDateTimeFormat);
      FMTDeleteFormat (pGlobals, hDateFormat);
      FMTDeleteFormat (pGlobals, hTimeFormat);
   }

   if (hSCPLib != HNULL) {
      FreeLibrary (hSCPLib);
      hSCPLib = HNULL;
   }

   // this call makes it not thread safe
   // move it to Class Factory destructor

   MemFreeAllPages(pGlobals);
   
   return ((HRESULT)0);
}

private int OpenV5BoundSheet (void * pGlobals, TCHAR *sheetName, byte sheetType, byte sheetState)
{
   SHDP         pSheet;
   int          nlen;

   if ((pSheet = MemAllocate(pGlobals, sizeof(SheetData))) == NULL)
      return (EX_errOutOfMemory);

   nlen = STRLEN(sheetName);
   if(nlen >= EXCEL_MAX_SHEETNAME_LEN)
           sheetName[EXCEL_MAX_SHEETNAME_LEN] = 0;

   STRCPY (pSheet->name, sheetName);

   if ((sheetType == boundWorksheet) || (sheetType == boundChart))
      pSheet->usable = TRUE;
   else
      pSheet->usable = FALSE;

   pSheet->next = pCurrentFile->pSheetList;
   pCurrentFile->pSheetList = pSheet;
   return (EX_errSuccess);
}

private int OpenCodePage (void * pGlobals, int codePage)
{
#ifdef WIN32
      codePage = codePage & 0x0000ffff;
#endif

          // Office96.107932 If Unicode, this member is not referenced.
#ifndef UNICODE
   if (IsSupportedCodePage((CPID)codePage) == FALSE)
      return (EX_errUnsupportedCodePage);
#endif

   if (FMacCp(codePage)) {
      /*
      ** In order to be able to use Mac codepages I need to use the translation
      ** DLL.  If it is unavailable then the mac codepages are unsupported
      */

      if (SetupSCPLibrary(pGlobals) == FALSE)
         return (EX_errUnsupportedCodePage);

      pCurrentFile->macTranslation   = TRUE;
      pCurrentFile->macToWinCodePage = TranslateMacToWindowsCodePage((CPID)codePage);
  }

   pCurrentFile->codePage = (CPID)codePage;
   return (EX_errSuccess);
}

private int OpenDateSystem (void * pGlobals, int system)
{
   pCurrentFile->dateSystem = (short) system;
   return (EX_errSuccess);
}

private int StopOnEOF (void * pGlobals)
{
   return (EX_wrnScanStopped);
}

static const EXCELDEF V5BookScan =
               {EXCEL_CALLBACK_VERSION,
                /* EveryRecord      */ NULL,
                /* BOF              */ NULL,
                /* WB_BundleHeader  */ NULL,
                /* WB_BundleSheet   */ NULL,
                /* WB_ExternSheet   */ NULL,
                /* V5_BoundSheet    */ OpenV5BoundSheet,
                /* IsTemplate       */ NULL,
                /* IsAddin          */ NULL,
                /* IsIntlSheet      */ NULL,
                /* InterfaceChanges */ NULL,
                /* DeleteMenu       */ NULL,
                /* AddMenu          */ NULL,
                /* AddToolbar       */ NULL,
                /* DateSystem       */ OpenDateSystem,
                /* CodePage         */ OpenCodePage,
                /* Protect          */ NULL,
                /* ColInfo          */ NULL,
                /* StdWidth         */ NULL,
                /* DefColWidth      */ NULL,
                /* DefRowHeight     */ NULL,
                /* GCW              */ NULL,
                /* Font             */ NULL,
                /* Format           */ NULL,
                /* XF               */ NULL,
                /* WriterName       */ NULL,
                /* DocRoute         */ NULL,
                /* RecipientName    */ NULL,
                /* RefMode          */ NULL,
                /* FNGroupCount     */ NULL,
                /* FNGroupName      */ NULL,
                /* ExternCount      */ NULL,
                /* ExternSheet      */ NULL,
                /* ExternName       */ NULL,
                /* Name             */ NULL,
                /* Dimensions       */ NULL,
                /* TextCell         */ NULL,
                /* NumberCell       */ NULL,
                /* BlankCell        */ NULL,
                /* ErrorCell        */ NULL,
                /* BoolCell         */ NULL,
                /* FormulaCell      */ NULL,
                /* ArrayFormulaCell */ NULL,
                /* SharedFormulaCell*/ NULL,
                /* StringCell       */ NULL,
                /* Note             */ NULL,
                /* Object           */ NULL,
                /* ImageData        */ NULL,
                /* Scenario         */ NULL,
                /* StringPool       */ NULL,
                /* EOF              */ StopOnEOF,
                /* SeriesText       */ NULL
               };

public HRESULT XLSFileOpen (void * pGlobals, TCHAR *pathname, XLSHandle *hXLSFile)
{
   int   rc;
   FDP   pFileData;
   int   options;

   if ((pFileData = MemAllocate(pGlobals, sizeof(FileData))) == NULL)
      return (TranslateToHResult(EX_errOutOfMemory));

   *hXLSFile = NULL;
   pCurrentFile = pFileData;

   /*
   ** Attempt to open the file as if it were a V5 file.  If that fails
   ** then try as a V3/4 file.
   */
   options = DOS_RDONLY | DOS_SH_DENYWR |
             EXCEL_SHOULD_BE_DOCFILE | EXCEL_ALLOW_EMBEDDED_SCAN;

   rc = ExcelOpenFile(pGlobals, pathname, "", options, 0, &(pFileData->hBook));
   if (rc != EX_errSuccess) {
      int err = EX_errOLENotCompoundFile; // compiler error???
      if (rc != err) 
      {
         MemFree (pGlobals, pFileData);
         return (TranslateToHResult(rc));
      }

      options &= ~EXCEL_SHOULD_BE_DOCFILE;
      rc = ExcelOpenFile(pGlobals, pathname, "", options, 0, &(pFileData->hBook));
      if (rc != EX_errSuccess) {
         MemFree (pGlobals, pFileData);
         return (TranslateToHResult(rc));
      }
   }

   pFileData->version    = ExcelFileVersion(pFileData->hBook);
   pFileData->PTGSize    = ExcelPTGSize(pFileData->version);
   pFileData->PTGExtSize = ExcelExtPTGSize(pFileData->version);
   pFileData->lastMark   = ExcelBookmarkNil;
   pFileData->stringPoolStart = 0;

   if (pFileData->version < versionExcel5) {
      *hXLSFile = (XLSHandle)pFileData;
      return ((HRESULT)0);
   }

   /*
   ** Load book level stuff - list of the sheets
   */
   rc = ExcelScanFile(pGlobals, pFileData->hBook, &V5BookScan, 0);
   if (rc < EX_errSuccess) {
          XLSFileClose(pGlobals, (XLSHandle)pFileData);
      //MemFree (pGlobals, pFileData);
      return (TranslateToHResult(rc));
   }

   *hXLSFile = (XLSHandle)pFileData;
   return ((HRESULT)0);
}

public HRESULT XLSStorageOpen (void * pGlobals, LPSTORAGE pStorage, XLSHandle *hXLSFile)
{
   int   rc;
   FDP   pFileData;
   int   options;

   if ((pFileData = MemAllocate(pGlobals, sizeof(FileData))) == NULL)
      return (TranslateToHResult(EX_errOutOfMemory));

   *hXLSFile = NULL;
   pCurrentFile = pFileData;

   options = EXCEL_ALLOW_EMBEDDED_SCAN;

   rc = ExcelOpenStorage(pGlobals, pStorage, "", options, &(pFileData->hBook));
   if (rc != EX_errSuccess) {
      MemFree (pGlobals, pFileData);
      return (TranslateToHResult(rc));
   }

   pFileData->version    = ExcelFileVersion(pFileData->hBook);
   pFileData->PTGSize    = ExcelPTGSize(pFileData->version);
   pFileData->PTGExtSize = ExcelExtPTGSize(pFileData->version);
   pFileData->lastMark   = ExcelBookmarkNil;
   pFileData->stringPoolStart = 0;

   if (pFileData->version < versionExcel5) {
      *hXLSFile = (XLSHandle)pFileData;
      return ((HRESULT)0);
   }

   /*
   ** Load book level stuff - list of the sheets
   */
   rc = ExcelScanFile(pGlobals, pFileData->hBook, &V5BookScan, 0);
   if (rc < EX_errSuccess) {
      MemFree (pGlobals, pFileData);
      return (TranslateToHResult(rc));
   }

   *hXLSFile = (XLSHandle)pFileData; 
   return ((HRESULT)0);
}

public HRESULT XLSFileClose (void * pGlobals, XLSHandle hXLSFile)
{
   int   rc = EX_errSuccess;
   FDP   pFileData = (FDP)hXLSFile;
   XFRP  pXF, pNextXF;
   FMRP  pFmt, pNextFmt;
   SHDP  pSheet, pNextSheet;

   if (pFileData != NULL) {
      rc = ExcelCloseFile(pGlobals, pFileData->hBook, FALSE);

      pXF = pFileData->pXFRecords;
      while (pXF != NULL) {
         pNextXF = pXF->next;
         if (pGlobals)
            MemFree (pGlobals, pXF);
         pXF = pNextXF;
      }

      pFmt = pFileData->pFmtRecords;
      while (pFmt != NULL) {
         pNextFmt = pFmt->next;
         if (pGlobals) {
            FMTDeleteFormat (pGlobals, pFmt->hFormat);
            MemFree (pGlobals, pFmt);
         }
         pFmt = pNextFmt;
      }

      pSheet = pFileData->pSheetList;
      while (pSheet != NULL) {
         pNextSheet = pSheet->next;
         if (pGlobals)
            MemFree (pGlobals, pSheet);
         pSheet = pNextSheet;
      }

      if (pGlobals)
         MemFree (pGlobals, pFileData);
   }
   return (TranslateToHResult(rc));
}

/*---------------------------------------------------------------------------*/

static const TCHAR PutSeparator[] = {0x0d, 0x0a, 0x00};
#define PUT_OVERHEAD (sizeof(PutSeparator) - sizeof(TCHAR))

#define BufferWillOverflow(cbText) \
       ((pFile->cbBufferSize - pFile->cbBufferUsed) < ((cbText) + PUT_OVERHEAD))

#define BufferWillOverflow2(cbText) \
       ((pFile->cbBufferSize - pFile->cbBufferUsed) < ((cbText) + (PUT_OVERHEAD * 2)))


private BOOL AddToBuffer2 (FDP pFile, TCHAR *pText, unsigned int cbText)
{
   if (BufferWillOverflow(cbText))
   {
      pFile->cbBufReqSize = cbText;
      return (FALSE);
   }

   #ifndef UNICODE
   if (pFile->macTranslation)
      pfnFTranslateScp(pFile->codePage, pFile->macToWinCodePage, pText, cbText);
   #endif

   memcpy (pFile->pBufferData + pFile->cbBufferUsed, pText, cbText);
   pFile->cbBufferUsed += cbText;

   memcpy (pFile->pBufferData + pFile->cbBufferUsed, PutSeparator, PUT_OVERHEAD);
   pFile->cbBufferUsed += PUT_OVERHEAD;
   return (TRUE);
}

private BOOL AddAnsiToBuffer (void * pGlobals, FDP pFile, char *pText, unsigned int cchText)
{
   #ifdef UNICODE
      int     cbUnicode;
      wchar_t *pTemp;
      BOOL    rc;
          wchar_t UnicodeTemp[CCH_UNICODE_TEMP];

      if ((cchText * 2) > CCH_UNICODE_TEMP) {
         cbUnicode = MultiByteToWideChar(CP_ACP, 0, pText, cchText, NULL, 0);

         pTemp = calloc(1, cbUnicode * 2);
         if (pTemp) {
            MultiByteToWideChar(CP_ACP, 0, pText, cchText, pTemp, cbUnicode);

            rc = AddToBuffer2(pFile, pTemp, cbUnicode * 2);
            free (pTemp);
            return (rc);
         }
         else
            return FALSE;
      }
      else {
         cbUnicode = MultiByteToWideChar(CP_ACP, 0, pText, cchText, UnicodeTemp, CCH_UNICODE_TEMP);
         return (AddToBuffer2(pFile, UnicodeTemp, cbUnicode * 2));
      }
   #else
      return (AddToBuffer2(pFile, pText, cchText));
   #endif
}

private BOOL AddUnicodeToBuffer (void * pGlobals, FDP pFile, wchar_t *pText, unsigned int cchText)
{
   #ifdef UNICODE
      return (AddToBuffer2(pFile, pText, cchText * 2));
   #else
      int  cbAnsi;
      char *pTemp;
      BOOL rc;
      char AnsiTemp[CCH_ANSI_TEMP];

      if ((cchText * 2) > CCH_ANSI_TEMP) {
         cbAnsi = WideCharToMultiByte(CP_ACP, 0, pText, cchText, NULL, 0, NULL, NULL);

         if ((pTemp = calloc(1, cbAnsi * 2)) == NULL)
            return (TRUE);

         WideCharToMultiByte(CP_ACP, 0, pText, cchText, pTemp, cbAnsi, NULL, NULL);

         rc = AddToBuffer2(pFile, pTemp, cbAnsi);
         free (pTemp);
         return (rc);
      }
      else {
         cbAnsi = WideCharToMultiByte(CP_ACP, 0, pText, cchText, AnsiTemp, CCH_ANSI_TEMP, NULL, NULL);
         return (AddToBuffer2(pFile, AnsiTemp, cbAnsi));
      }
   #endif
}

private BOOL AddCompressedUnicodeToBuffer (void * pGlobals, FDP pFile, char *pText, int cchText)
{
   wchar_t  *pTemp = NULL;
   int      i;
   BOOL     rc;
   wchar_t ExpansionTemp[CCH_EXPANSION_TEMP];

   if (cchText <= CCH_EXPANSION_TEMP) {
      for (i = 0; i < cchText; i++) {
         ExpansionTemp[i] = (wchar_t)(*pText++);
      }
      rc = AddUnicodeToBuffer(pGlobals, pFile, ExpansionTemp, cchText);
   }
   else {
      if ((pTemp = calloc(1, cchText * sizeof(wchar_t))) == NULL)
         return (TRUE);

      for (i = 0; i < cchText; i++) {
         pTemp[i] = (wchar_t)(*pText++);
      }
      rc = AddUnicodeToBuffer(pGlobals, pFile, pTemp, cchText);
      free (pTemp);
   }
   return (rc);
}

/*---------------------------------------------------------------------------*/

private int AddNumericLiteralToBuffer (void * pGlobals, FDP pFileData, double value)
{
   char    result[MAX_FORMAT_IMAGE + 1];
   double  absValue;

   absValue = ABS(value);

   if (SHOULD_USE_EXP_FORMAT(pGlobals, absValue))
      FMTDisplay (&value, FALSE, &ControlPanelSettings, hExpNumericFormat, 0, result);
   else
      FMTDisplay (&value, FALSE, &ControlPanelSettings, hNumericFormat, 0, result);

   if (result[0] == EOS)
      return (TRUE);

   return (AddAnsiToBuffer(pGlobals, pFileData, result, strlen(result)));
}

private int ScanFormula (void * pGlobals, FDP pFile, FRMP pFormula, unsigned int cbExtra)
{
   int      i;
   unsigned int cbFormulaText;
   byte     *pDef;
   byte     *pLast;
   byte     iExtend, tag;
   int      ptg, ptgBase;
   uns      dataWord;
   byte     options, cbString;
   char     *pString;
   ACP      pConstant;
   unsigned long saveUsed;
   int      intValue;
   double   doubleValue;
   BOOL     rc;

   #define V8_CUNICODE_STRING_TAG 0
   #define V8_UNICODE_STRING_TAG  1

   if (pFormula->cbPostfix == 0)
      return (TRUE);

   saveUsed = pFile->cbBufferUsed;

   cbFormulaText = 0;

   if ((pConstant = pFormula->arrayConstants) != NULL)
   {
      while (pConstant != NULL) {
         for (i = 0; i < pConstant->colCount * pConstant->rowCount; i++)
         {
            if (pConstant->values[i].tag == tagISSTRING) {
               pString = ExcelTextGet(pCurrentFile->hBook, pConstant->values[i].AIS.value);

               rc = AddToBuffer2(pFile, (TCHAR *)pString, STRLEN((TCHAR *)pString) * sizeof(TCHAR));
               if (rc == FALSE)
                  goto BufferFull;
            }
         }
         pConstant = pConstant->next;
      }
   }

   pDef  = pFormula->postfix;
   pLast = pDef + pFormula->cbPostfix - 1;

   while (pDef <= pLast) {
      ptg = *pDef++;
      ptgBase = PTGBASE(ptg);

      switch (ptgBase) {
         case ptgStr:
            cbString = *pDef++;
                        if (pCurrentFile->version == versionExcel8)
                                tag = *pDef++;
            if (cbString > 0)
            {
               if (pCurrentFile->version == versionExcel8) {
                  if (tag & V8_UNICODE_STRING_TAG) {
                     if (AddUnicodeToBuffer(pGlobals, pFile, (wchar_t *)pDef, cbString) == FALSE)
                        goto BufferFull;
                                                        cbString *= sizeof(WCHAR);
                  }
                  else {
                     if (AddCompressedUnicodeToBuffer(pGlobals, pFile, pDef, cbString) == FALSE)
                        goto BufferFull;
                  }
               }
               else {
                  if (AddAnsiToBuffer(pGlobals, pFile, pDef, cbString) == FALSE)
                     goto BufferFull;
               }
               pDef += cbString;
            }
            break;

         case ptgAttr:
            options  = *pDef++;
            dataWord = *((unsigned short UNALIGNED *)pDef);
            pDef += 2;
            if ((options & bitFAttrChoose) != 0) {
               pDef += ((dataWord + 1) * 2);
            }
            break;

         case ptgInt:
            intValue = *((unsigned short UNALIGNED *)pDef);
            pDef += 2;

            if (AddNumericLiteralToBuffer(pGlobals, pFile, (double)intValue) == FALSE)
               goto BufferFull;
            break;

         case ptgNum:
            doubleValue = *((double UNALIGNED *)pDef);
            pDef += 8;

            if (AddNumericLiteralToBuffer(pGlobals, pFile, doubleValue) == FALSE)
               goto BufferFull;
            break;

         case ptgV8Extended:
            iExtend = *((byte *)pDef);
            pDef += (pCurrentFile->PTGExtSize[iExtend] + 1);
            break;

         case ptgNameX:
            pDef += 2;          // in Excel Code: fmf.pce += sizeof(IXTIPTG);

         default:
            pDef += pCurrentFile->PTGSize[ptgBase];
            break;
      }
   }

   if (BufferWillOverflow(cbExtra))
      goto BufferFull;

   return (TRUE);

BufferFull:
   pFile->cbBufReqSize += pFile->cbBufferUsed - saveUsed; // this way, cbBufferUsed + cbBufferRequired will be correct
   pFile->cbBufferUsed = saveUsed;
   return (FALSE);
}

private BOOL IsRowOrColumnHidden (void * pGlobals, EXA_CELL cell)
{
   // If ExcelSheetRowHeight fails below, it's safe to say that
   // the row or column is hidden because we don't process hidden rows and columns.
   unsigned int rowHeight = 0;

   if (pCurrentFile->colSize[cell.col].width == 0)
      return (TRUE);

   ExcelSheetRowHeight (pCurrentFile->hSheet, cell.row, &rowHeight);
   if (rowHeight == 0)
      return (TRUE);

   return (FALSE);
}

/* Return Ith element in a list (1st = 0, 2nd = 1, ...) */
private void *Ith (void *pList, int i)
{
   typedef struct ListNode {
      struct ListNode *next;
   } ListNode;

   typedef ListNode *LNP;

   LNP pCurrent = pList;
   int iNode  = 0;

   while (pCurrent != NULL) {
      if (iNode == i)
         return (pCurrent);

      pCurrent = pCurrent->next;
      iNode++;
   }
   return (NULL);
}

private BOOL IsHiddenCell (void * pGlobals, int ixfe)
{
   XFRP  pXF;

   if ((pXF = Ith(pCurrentFile->pXFRecords, ixfe)) != NULL) {
      if ((pXF->grbit & fCellHidden) != 0)
         return (TRUE);
   }

   return (FALSE);
}

/*---------------------------------------------------------------------------*/

private int ScanName
       (void * pGlobals, EXA_GRBIT flags, BYTE keyboardShortcut,
        TCHAR *nameSpelling, int iBoundSheet, FORM *nameDefinition)
{
   BOOL rc;
        unsigned int cbSpelling;

   /*
   ** Ignore builtin names and link names
   */
   if (((flags & fNameBuiltin) != 0) || (nameSpelling[0] == 0x01))
      return (EX_errSuccess);

   // Office97.151440: If we can't add the nameDefinition to the buffer, we
        // filter the nameSpelling the next time, too.  So don't include it in the
        // buffer that we're going to return.  AddToBuffer2() adds the cb that is
        // sent to it, plus PUT_OVERHEAD.  This is why we subtract both below.
        cbSpelling = STRLEN(nameSpelling) * sizeof(TCHAR);
        rc = AddToBuffer2(pCurrentFile, nameSpelling, cbSpelling);
   if (rc == FALSE)
      goto BufferFull;

   if (ScanFormula(pGlobals, pCurrentFile, nameDefinition, PUT_OVERHEAD) == FALSE) {
                pCurrentFile->cbBufferUsed -= cbSpelling + PUT_OVERHEAD;
      goto BufferFull;
        }

   return (EX_errSuccess);

BufferFull:
   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private FMTType FormatType (void * pGlobals, int ixfe, FMTValueType vType, FMRP *pFmt)
{
   XFRP    pXF;
   FMRP    pCurrentFmt;
   FMTType fmtType;

   FDP pCurFile = pCurrentFile;

   *pFmt = NULL;

   if ((pXF = Ith(pCurrentFile->pXFRecords, ixfe)) == NULL)
      return (FMTNone);

   if (pCurrentFile->version >= versionExcel5) {
      if ((fmtType = FMTV5FormatType(pXF->ifmt)) != FMTNone)
         return (fmtType);

      pCurrentFmt = pCurrentFile->pFmtRecords;
      while (pCurrentFmt != NULL) {
         if (pCurrentFmt->ifmt == pXF->ifmt) {
            *pFmt = pCurrentFmt;
            return (FMTFormatType(pCurrentFmt->hFormat, vType));
         }

         pCurrentFmt = pCurrentFmt->next;
      }
      return (FMTNone);
   }

   if ((pCurrentFmt = Ith(pCurrentFile->pFmtRecords, pXF->ifmt)) == NULL)
      return (FMTNone);

   *pFmt = pCurrentFmt;
   return (FMTFormatType(pCurrentFmt->hFormat, vType));
}


private int ScanNumberCell (void * pGlobals, EXA_CELL location, int ixfe, double value)
{
   FMTValueType  valueType;
   long          datePart;
   char          result[MAX_FORMAT_IMAGE + 1];
   double        absValue;
   FMRP          pFmt;

   if ((pCurrentFile->pswdProtectedSheet == TRUE) && IsRowOrColumnHidden(pGlobals, location))
      return (EX_errSuccess);

   result[0] = EOS;

   if (value == 0)
      valueType = FMTValueZero;
   else if (value > 0)
      valueType = FMTValuePos;
   else
      valueType = FMTValueNeg;

   switch (FormatType(pGlobals, ixfe, valueType, &pFmt)) {
      case FMTDateTime:
      case FMTDate:
      case FMTTime:
         if (valueType == FMTValueNeg)
            return (EX_errSuccess);

         if (pCurrentFile->dateSystem == dateSystem1904)
            value += EXCEL_DATE_1904_CORRECTION;

         datePart = (long)value;

         if (value < 1)
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hTimeFormat, 0, result);
         else if (value == (double)datePart)
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hDateFormat, 0, result);
         else
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hDateTimeFormat, 0, result);
         break;

      case FMTNumeric:
      case FMTGeneral:
         absValue = ABS(value);

         if (SHOULD_USE_EXP_FORMAT(pGlobals, absValue))
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hExpNumericFormat, 0, result);
         else
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hNumericFormat, 0, result);
         break;

      case FMTCurrency:
         absValue = ABS(value);

         if (absValue < CurrencySmallExponential)
            value = 0;

         if (absValue > USE_EXP_FORMAT_BIG)
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hExpNumericFormat, 0, result);
         else
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hCurrencyFormat, 0, result);
         break;

      default:
         /*
         ** An odd format.  Try to run the format but also format the value as a number
         */
         if (pFmt != NULL) {
            FMTDisplay(&value, FALSE, &ControlPanelSettings, pFmt->hFormat, 0, result);
            if (result[0] != EOS)
               AddAnsiToBuffer(pGlobals, pCurrentFile, result, strlen(result));
         }

         absValue = ABS(value);

         if (SHOULD_USE_EXP_FORMAT(pGlobals , absValue))
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hExpNumericFormat, 0, result);
         else
            FMTDisplay (&value, FALSE, &ControlPanelSettings, hNumericFormat, 0, result);
         break;
   }

   if (result[0] == EOS)
      return (EX_errSuccess);

   if (AddAnsiToBuffer(pGlobals, pCurrentFile, result, strlen(result)) == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanTextCell (void * pGlobals, EXA_CELL location, int ixfe, TCHAR *value, int cbValue)
{
   BOOL  rc;

   if ((pCurrentFile->pswdProtectedSheet == TRUE) && IsRowOrColumnHidden(pGlobals, location))
      return (EX_errSuccess);

   rc = AddToBuffer2(pCurrentFile, value, cbValue);
   if (rc == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanFormulaCell
       (void * pGlobals, EXA_CELL location, int ixfe, EXA_GRBIT flags, FRMP definition, CV *pValue)
{
   pCurrentFile->lastFormulaLocation = location;

   if (pCurrentFile->pswdProtectedSheet == TRUE) {
      if (IsRowOrColumnHidden(pGlobals, location) || (IsHiddenCell(pGlobals, ixfe)))
         return (EX_errSuccess);
   }

   if ((pValue->flags & cellvalueNUM) != 0) {
      if (ScanNumberCell(pGlobals, location, ixfe, pValue->value.IEEEdouble) != EX_errSuccess)
         goto full;
   }

   if (ScanFormula(pGlobals, pCurrentFile, definition, 0) == TRUE)
      return (EX_errSuccess);

full:
   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanArrayFormulaCell
       (void * pGlobals, EXA_RANGE location, EXA_GRBIT flags, FRMP definition)
{
   EXA_CELL upperLeft;

   upperLeft.row = location.firstRow;
   upperLeft.col = location.firstCol;

   pCurrentFile->lastFormulaLocation = upperLeft;

   if (pCurrentFile->pswdProtectedSheet == TRUE) {
      if (IsRowOrColumnHidden(pGlobals, upperLeft))
         return (EX_errSuccess);
   }

   if (ScanFormula(pGlobals, pCurrentFile, definition, 0) == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanStringCell (void * pGlobals, TCHAR *pString)
{
   int  cchString;
   BOOL rc;

   if ((cchString = STRLEN(pString)) == 0)
      return (EX_errSuccess);

   if ((pCurrentFile->pswdProtectedSheet == TRUE) && IsRowOrColumnHidden(pGlobals, pCurrentFile->lastFormulaLocation))
      return (EX_errSuccess);

   rc = AddToBuffer2(pCurrentFile, pString, cchString * sizeof(TCHAR));
   if (rc == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanCellNote
       (void * pGlobals, EXA_CELL location, TCHAR *pText, int cbText, int soundNote)
{
   BOOL  rc;

   if ((soundNote == TRUE) || (cbText == 0))
      return (EX_errSuccess);

   if ((pCurrentFile->pswdProtectedSheet == TRUE) && IsRowOrColumnHidden(pGlobals, location))
      return (EX_errSuccess);

   rc = AddToBuffer2(pCurrentFile, pText, cbText);
   if (rc == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}


private int ScanObject (void * pGlobals, int iType, int id, OBJINFO *pInfo)
{
   unsigned int cchName, cchText;
   BOOL rc1 = TRUE;
   BOOL rc2 = TRUE;

   if (pInfo->pName != NULL) {
      cchName = STRLEN(pInfo->pName);
      rc1 = AddToBuffer2(pCurrentFile, pInfo->pName, cchName * sizeof(TCHAR));
   }

   if (pInfo->pText != NULL) {
      cchText = STRLEN(pInfo->pText);
      rc2 = AddToBuffer2(pCurrentFile, pInfo->pText, cchText * sizeof(TCHAR));
   }

   if ((rc1 == FALSE) || (rc2 == FALSE)) {
      ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
      return (EX_errBufferFull);
   }

   return (EX_errSuccess);
}


private int ScanSeriesText (void * pGlobals, int id, TCHAR *pText)
{
   int cchText, i;

   #ifdef UNICODE
   static wchar_t *ErrorLiterals[7] =
         {L"#NULL!", L"#DIV/0!", L"#VALUE!", L"#REF!", L"#NAME?", L"#NUM!", L"#N/A"};
   #else
   static char *ErrorLiterals[7] =
         {"#NULL!", "#DIV/0!", "#VALUE!", "#REF!", "#NAME?", "#NUM!", "#N/A"};
   #endif

   if ((cchText = STRLEN(pText)) == 0)
      return (EX_errSuccess);

   /*
   ** In some cases that I have not been able to explain, Excel has stored
   ** #REF! for the text.  If I can detect one of the error literals I don't
   ** pass it through.  Why Excel does this I can't be sure.
   */
   if (*pText == '#') {
      for (i = 0; i < 7; i++) {
         if (STRCMP(pText, ErrorLiterals[i]) == 0)
            return (EX_errSuccess);
      }
   }

   if (AddToBuffer2(pCurrentFile, pText, cchText * sizeof(TCHAR)) == TRUE)
      return (EX_errSuccess);

   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}

private int ScanScenario
       (void * pGlobals, TCHAR *scenarioName, TCHAR *comments, TCHAR *userName,
        EXA_GRBIT options,
        int ctChangingCells, EXA_CELL *changingCells, char *values)
{
   unsigned int cchName;
   unsigned int cchComments;

   cchName = STRLEN(scenarioName);
   cchComments = STRLEN(comments);

   if (AddToBuffer2(pCurrentFile, scenarioName, cchName * sizeof(TCHAR)) == FALSE)
      goto full;

   if (AddToBuffer2(pCurrentFile, comments, cchComments * sizeof(TCHAR)) == FALSE)
      goto full;

   return (EX_errSuccess);

full:
   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errBufferFull);
}

private int ScanStringPool
       (void * pGlobals, int ctTotalStrings, int iString, unsigned int cbText, TCHAR *pText)
{
   if (iString < pCurrentFile->stringPoolStart)
      return (EX_errSuccess);

   if (AddToBuffer2(pCurrentFile, pText, cbText) == FALSE) {
      // QFE 2178: Actually pCurrentFile->stringPoolStart has info about what strings in the
      //           string pool have been read. So here we can skip updating pCurrentFile->currentMark.
      //           This way we can avoid the problem of QFE 2178: The attached xls has a very big
      //           string pool, linked by rtContinue. If here pCurrentFile->currentMark is updated,
      //           next time in ExcelScanFile() the record of rtContinue will be skipped.
      //ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
      pCurrentFile->stringPoolStart = iString;
      return (EX_errBufferFull);
   }
   else {
      // We do want to update pCurrentFile->currentMark when we start a new string pool, in case
      // the string pool is too big and several IFilter::GetText calls have to be made. This way, across
      // several IFilter::GetText calls it is ensured that we always do ExcelScanFile() from the same
      // file location for the same string pool.
      if (0 == pCurrentFile->stringPoolStart)
         ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   }
           

   // iString can only be increased to (ctTotalStrings - 1). From the function
   // ProcessStringPoolRecord in dmixlrd.c, you can easily get this result.
   if (iString == ctTotalStrings - 1)
      pCurrentFile->stringPoolStart = 0;

   return (EX_errSuccess);
}

private int ScanEOF (void * pGlobals)
{
   ExcelGetBookmark (pCurrentFile->hSheet, START_OF_CURRENT_RECORD, &(pCurrentFile->currentMark));
   return (EX_errSuccess);
}

/*---------------------------------------------------------------------------*/

private int ScanProtect (void * pGlobals, int iType, BOOL enabled)
{
   if ((pCurrentFile->version < versionExcel5) || (pCurrentFile->pswdProtectedSheet == TRUE))
      return (EX_errSuccess);

   if ((iType == protectCELLS) && (enabled != FALSE))
      pCurrentFile->protectedSheet = TRUE;

   else if ((iType == protectPASSWORD) && (enabled != FALSE) && (pCurrentFile->protectedSheet == TRUE))
      return (EX_errSheetPswdProtected);

   return (EX_errSuccess);
}

private int ScanColInfo
       (void * pGlobals, unsigned int colFirst, unsigned int colLast, unsigned int width, EXA_GRBIT options)
{
   unsigned int iCol;

   /*
   ** Note: The colFirst and ColLast are zero based column numbers, but
   ** I have seen sheets where colLast == 256
   */
   colLast = min(colLast, EXCEL_LAST_COL);

   for (iCol = colFirst; iCol <= colLast; iCol++) {
      pCurrentFile->colSize[iCol].width = width;
      pCurrentFile->colSize[iCol].isUserSet = TRUE;
   }
   return (EX_errSuccess);
}

private int ScanStandardWidth (void * pGlobals, unsigned int width)
{
   pCurrentFile->standardColWidth = width;
   return (EX_errSuccess);
}

private int ScanGCW (void * pGlobals, unsigned int cbBitArray, byte *pByteArray)
{
   unsigned int  iWord, iBit;
   unsigned int  iCol;
   unsigned int  UNALIGNED *pBitArray;

   static const unsigned int Masks[16] =
        {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
         0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000};

   iCol = 0;
   pBitArray = (unsigned int *)pByteArray;

   for (iWord = 0; iWord < (cbBitArray / 2); iWord++) {
      for (iBit = 0; iBit < 16; iBit++) {
         if ((*pBitArray & Masks[iBit]) != 0)
            pCurrentFile->colSize[iCol].isStandardWidth = TRUE;
         iCol++;
      }
      pBitArray++;
   }

   return (EX_errSuccess);
}


private int ScanXF (void * pGlobals, int iFont, int iFormat, EXA_GRBIT options)
{
   XFRP pXF;

   if ((pXF = MemAllocate(pGlobals, sizeof(XFRecordData))) == NULL)
      return (EX_errOutOfMemory);

   pXF->ifont = iFont;
   pXF->ifmt  = iFormat;
   pXF->grbit = options;

   if (pCurrentFile->pXFRecords == NULL)
      pCurrentFile->pXFRecords = pXF;
   else
      pCurrentFile->pLastXF->next = pXF;

   pCurrentFile->pLastXF = pXF;
   return (EX_errSuccess);
}

private int ScanFormat (void * pGlobals, TCHAR *formatString, int indexCode)
{
   int       rc;
   FMRP      pFmt;
   FMTHANDLE hFormat;
   char AnsiTemp[CCH_ANSI_TEMP];

   #ifdef UNICODE
      WideCharToMultiByte(CP_ACP, 0, formatString, wcslen(formatString) + 1, AnsiTemp, sizeof(AnsiTemp), NULL, NULL);
      rc = FMTStoreFormat(pGlobals, AnsiTemp, &ControlPanelSettings, &hFormat);
   #else
      rc = FMTStoreFormat(pGlobals, formatString, &ControlPanelSettings, &hFormat);
   #endif

   if (rc != FMT_errSuccess)
      return (EX_errSuccess);

   if ((pFmt = MemAllocate(pGlobals, sizeof(FmtRecordData))) == NULL)
      return (EX_errOutOfMemory);

   pFmt->hFormat = hFormat;

   if (pCurrentFile->version >= versionExcel5)
      pFmt->ifmt = indexCode;
   else {
      if (pCurrentFile->pFmtRecords == NULL)
         pFmt->ifmt = 0;
      else
         pFmt->ifmt = pCurrentFile->pLastFmt->ifmt + 1;
   }

   if (pCurrentFile->pFmtRecords == NULL)
      pCurrentFile->pFmtRecords = pFmt;
   else
      pCurrentFile->pLastFmt->next = pFmt;

   pCurrentFile->pLastFmt = pFmt;

   return (EX_errSuccess);
}

/*---------------------------------------------------------------------------*/

static const EXCELDEF SheetScanColInfo =
               {EXCEL_CALLBACK_VERSION,
                /* EveryRecord      */ NULL,
                /* BOF              */ NULL,
                /* WB_BundleHeader  */ NULL,
                /* WB_BundleSheet   */ NULL,
                /* WB_ExternSheet   */ NULL,
                /* V5_BoundSheet    */ NULL,
                /* IsTemplate       */ NULL,
                /* IsAddin          */ NULL,
                /* IsIntlSheet      */ NULL,
                /* InterfaceChanges */ NULL,
                /* DeleteMenu       */ NULL,
                /* AddMenu          */ NULL,
                /* AddToolbar       */ NULL,
                /* DateSystem       */ NULL,
                /* CodePage         */ NULL,
                /* Protect          */ NULL,
                /* ColInfo          */ ScanColInfo,
                /* StdWidth         */ ScanStandardWidth,
                /* DefColWidth      */ NULL,
                /* DefRowHeight     */ NULL,
                /* GCW              */ ScanGCW,
                /* Font             */ NULL,
                /* Format           */ NULL,
                /* XF               */ NULL,
                /* WriterName       */ NULL,
                /* DocRoute         */ NULL,
                /* RecipientName    */ NULL,
                /* RefMode          */ NULL,
                /* FNGroupCount     */ NULL,
                /* FNGroupName      */ NULL,
                /* ExternCount      */ NULL,
                /* ExternSheet      */ NULL,
                /* ExternName       */ NULL,
                /* Name             */ NULL,
                /* Dimensions       */ NULL,
                /* TextCell         */ NULL,
                /* NumberCell       */ NULL,
                /* BlankCell        */ NULL,
                /* ErrorCell        */ NULL,
                /* BoolCell         */ NULL,
                /* FormulaCell      */ NULL,
                /* ArrayFormulaCell */ NULL,
                /* SharedFormulaCell*/ NULL,
                /* StringCell       */ NULL,
                /* Note             */ NULL,
                /* Object           */ NULL,
                /* ImageData        */ NULL,
                /* Scenario         */ NULL,
                /* StringPool       */ NULL,
                /* EOF              */ NULL,
                /* SeriesText       */ NULL
               };

static const EXCELDEF SheetScanContents =
               {EXCEL_CALLBACK_VERSION,
                /* EveryRecord      */ NULL,
                /* BOF              */ NULL,
                /* WB_BundleHeader  */ NULL,
                /* WB_BundleSheet   */ NULL,
                /* WB_ExternSheet   */ NULL,
                /* V5_BoundSheet    */ NULL,
                /* IsTemplate       */ NULL,
                /* IsAddin          */ NULL,
                /* IsIntlSheet      */ NULL,
                /* InterfaceChanges */ NULL,
                /* DeleteMenu       */ NULL,
                /* AddMenu          */ NULL,
                /* AddToolbar       */ NULL,
                /* DateSystem       */ OpenDateSystem,
                /* CodePage         */ OpenCodePage,
                /* Protect          */ ScanProtect,
                /* ColInfo          */ NULL,
                /* StdWidth         */ NULL,
                /* DefColWidth      */ NULL,
                /* DefRowHeight     */ NULL,
                /* GCW              */ NULL,
                /* Font             */ NULL,
                /* Format           */ ScanFormat,
                /* XF               */ ScanXF,
                /* WriterName       */ NULL,
                /* DocRoute         */ NULL,
                /* RecipientName    */ NULL,
                /* RefMode          */ NULL,
                /* FNGroupCount     */ NULL,
                /* FNGroupName      */ NULL,
                /* ExternCount      */ NULL,
                /* ExternSheet      */ NULL,
                /* ExternName       */ NULL,
                /* Name             */ ScanName,
                /* Dimensions       */ NULL,
                /* TextCell         */ ScanTextCell,
                /* NumberCell       */ ScanNumberCell,
                /* BlankCell        */ NULL,
                /* ErrorCell        */ NULL,
                /* BoolCell         */ NULL,
                /* FormulaCell      */ ScanFormulaCell,
                /* ArrayFormulaCell */ ScanArrayFormulaCell,
                /* SharedFormulaCell*/ NULL,
                /* StringCell       */ ScanStringCell,
                /* Note             */ ScanCellNote,
                /* Object           */ ScanObject,
                /* ImageData        */ NULL,
                /* Scenario         */ ScanScenario,
                /* StringPool       */ ScanStringPool,
                /* EOF              */ ScanEOF,
                /* SeriesText       */ ScanSeriesText
               };

public HRESULT XLSFileRead
      (void * pGlobals, XLSHandle hXLSFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed)
{
   int   rc;
   FDP   pFile = (FDP)hXLSFile;
   SHDP  pSheet;
   int   iCol;
   unsigned int    cbText;
   // Do something to the following case, improving the fix for Office QFE 1412 where an infinite loop occurred:
   //   If before reading the current sheet any content has been put into buffer, we don't return
   //   (TranslateToHResult(EX_errBufferTooSmall)), which is STG_E_INSUFFICIENTMEMORY, even though the condition
   //   ((rc == EX_errBufferFull) && ((pFile->lastMark == pFile->currentMark) && (pFile->stringPoolStart == 0)))
   //   is true. This way we don't discard any content which have been got.
   //   For this purpose, I add fValidLastMark, which will be true if we always stay in the same sheet since
   //   last time lastMark was updated. For performance I also set fValidLastMark to true even though we are not
   //   in the same sheet but nothing has been put into buffer. fValidLastMark will be false if any content has
   //   been put into buffer before reading the current sheet.
   BOOL  fValidLastMark = TRUE;

   *cbUsed = 0;
   if(!pFile)
           return EX_errSuccess;

   if ((pFile->lastMark == pFile->currentMark) && (pFile->lastcbBuffer >= cbBuffer))
   {
      if (pFile->stringPoolStart == 0)
      {
         *cbUsed = cbBuffer;
         return (TranslateToHResult(EX_errBufferTooSmall));
      }
   }

   pFile->lastMark = pFile->currentMark;
   pFile->lastcbBuffer = cbBuffer;

   pFile->pBufferData  = pBuffer;
   pFile->cbBufferSize = cbBuffer;
   pFile->cbBufferUsed = 0;

   pCurrentFile = pFile;

   if (pFile->version < versionExcel5) {
      pFile->hSheet = pFile->hBook;

      rc = ExcelScanFile(pGlobals, pFile->hBook, &SheetScanContents, pFile->currentMark);
      if ((rc != EX_errSuccess) && (rc != EX_errBufferFull))
         return (TranslateToHResult(rc));

      *cbUsed = pFile->cbBufferUsed;
      if ((rc == EX_errBufferFull) && ((pFile->cbBufferUsed == 0) ||
           ((pFile->lastMark == pFile->currentMark) && (pFile->stringPoolStart == 0))))
      {
         *cbUsed = pFile->cbBufferUsed + pFile->cbBufReqSize;
         return (TranslateToHResult(EX_errBufferTooSmall));
      }

      goto done;
   }

   if (pFile->tabNamesPassed == FALSE) {
      /*
      ** We make the assumption here that all the tab names will fit
      ** in the buffer
      */
      cbText = 0;
      pSheet = pFile->pSheetList;
      while (pSheet != NULL) {
         cbText += (STRLEN(pSheet->name) * sizeof(TCHAR)) + PUT_OVERHEAD;
         pSheet = pSheet->next;
      }

      if (BufferWillOverflow(cbText))
      {
         *cbUsed = cbText;
         return (TranslateToHResult(EX_errBufferTooSmall));
      }

      pSheet = pFile->pSheetList;
      while (pSheet != NULL) {
         AddToBuffer2 (pFile, pSheet->name, STRLEN(pSheet->name) * sizeof(TCHAR));
         pSheet = pSheet->next;
      }
      pFile->tabNamesPassed = TRUE;
      
      if (pFile->cbBufferUsed)
          fValidLastMark = FALSE;
   }

   if (pFile->bookScanned == FALSE) {
      pFile->hSheet = pFile->hBook;

      rc = ExcelScanFile(pGlobals, pFile->hBook, &SheetScanContents, pFile->currentMark);
      *cbUsed = pFile->cbBufferUsed;

      if (rc != EX_errSuccess) {
         if ((rc == EX_errBufferFull) && ((pFile->cbBufferUsed == 0) ||
              (fValidLastMark && (pFile->lastMark == pFile->currentMark) && (pFile->stringPoolStart == 0))))
         {
            *cbUsed = pFile->cbBufferUsed + pFile->cbBufReqSize;
            return (TranslateToHResult(EX_errBufferTooSmall));
         }

         goto done;
      }

      pFile->bookScanned = TRUE;
      pFile->hSheet = NULL;

      if (pFile->cbBufferUsed)
          fValidLastMark = FALSE;

      /*
      ** Find the first usable sheet
      */
      pSheet = pFile->pSheetList;
      while (pSheet != NULL) {
         if (pSheet->usable == TRUE) {
            pFile->pCurrentSheet = pSheet;
            break;
         }
         pSheet = pSheet->next;
      }
   }

   while (pFile->pCurrentSheet != NULL)
   {
      if (pFile->hSheet == NULL) {
         rc = ExcelOpenSheet
             (pGlobals, pFile->hBook, pFile->pCurrentSheet->name, EXCEL_ALLOW_EMBEDDED_SCAN, &(pFile->hSheet));

         if (rc != EX_errSuccess)
            return (TranslateToHResult(rc));

         pFile->currentMark = ExcelBookmarkStartOfPly;
      }

      rc = ExcelScanFile(pGlobals, pFile->hSheet, &SheetScanContents, pFile->currentMark);

      if (rc == EX_errSheetPswdProtected) {
         pFile->pswdProtectedSheet = TRUE;
         ExcelCloseSheet (pGlobals, pFile->hSheet);

         for (iCol = 0; iCol < EXCEL_MAX_COLS; iCol++) {
            pFile->colSize[iCol].isStandardWidth = FALSE;
            pFile->colSize[iCol].isUserSet = FALSE;
            pFile->colSize[iCol].width = DEFAULT_COL_WIDTH;
         }
         pFile->standardColWidth = DEFAULT_COL_WIDTH;

         /*
         ** We build the index since the row heights are stored in the ROW records
         */
         rc = ExcelOpenSheet
             (pGlobals, pFile->hBook, pFile->pCurrentSheet->name,
              EXCEL_BUILD_CELL_INDEX | EXCEL_ALLOW_EMBEDDED_SCAN, &(pFile->hSheet));

         if (rc != EX_errSuccess)
            return (TranslateToHResult(rc));

         /*
         ** Load the column width stuff.  Unfortunatly the GCW record
         ** is stored just prior to the EOF record.  We need the GCW record
         ** since the standard width of the sheet may be zero with
         ** only selected columns have non-zero width.
         */
         rc = ExcelScanFile(pGlobals, pFile->hSheet, &SheetScanColInfo, 0);
         if (rc != EX_errSuccess)
            return (TranslateToHResult(rc));

         for (iCol = 0; iCol < EXCEL_MAX_COLS; iCol++) {
            if ((pFile->colSize[iCol].isStandardWidth == TRUE) &&
                (pFile->colSize[iCol].isUserSet == FALSE))
               pFile->colSize[iCol].width = pFile->standardColWidth;
         }

         /*
         ** Rescan the file to obtain the text
         */
         rc = ExcelScanFile(pGlobals, pFile->hSheet, &SheetScanContents, 0);
      }

      *cbUsed = pFile->cbBufferUsed;

      if (rc != EX_errSuccess) {
         if ((rc == EX_errBufferFull) && ((pFile->cbBufferUsed == 0) ||
              (fValidLastMark && (pFile->lastMark == pFile->currentMark) && (pFile->stringPoolStart == 0))))
         {
            *cbUsed = pFile->cbBufferUsed + pFile->cbBufReqSize;
            return STG_E_INSUFFICIENTMEMORY;
         }

         goto done;
      }

      ExcelCloseSheet (pGlobals, pFile->hSheet);
      pFile->hSheet = NULL;
      pFile->pswdProtectedSheet = FALSE;

      if (pFile->cbBufferUsed)
          fValidLastMark = FALSE;

      /*
      ** Find the next usable sheet
      */
      pSheet = pFile->pCurrentSheet->next;
      while (pSheet != NULL) {
         if (pSheet->usable == TRUE)
            break;
         pSheet = pSheet->next;
      }

      pFile->pCurrentSheet = pSheet;

      if (pSheet != NULL)
         pFile->currentMark = ExcelBookmarkStartOfPly;
   }
   rc = EX_errSuccess;

done:
   if (rc == EX_errBufferFull)
      return ((HRESULT)0);
   else if (rc != EX_errSuccess)
      return (TranslateToHResult(rc));
   else
      return (FILTER_S_LAST_TEXT);
}

public HRESULT XLSNextStorage (void * pGlobals, XLSHandle hXLSFile, LPSTORAGE *pStorage)
{
   HRESULT  olerc;
   int      rc;
   SCODE    sc;
   FDP      pFile = (FDP)hXLSFile;
   STATSTG  ss;
   ULONG    ulCount;

   #define STORAGE_ACCESS (STGM_DIRECT | STGM_SHARE_DENY_WRITE | STGM_READ)

   #define FreeString(s)                         \
        {                                        \
           LPMALLOC pIMalloc;                    \
           if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc)) \
               {                                     \
               pIMalloc->lpVtbl->Free(pIMalloc, s);  \
               pIMalloc->lpVtbl->Release(pIMalloc);  \
               }                                     \
        }

   if (pFile == NULL)
      return (OLEOBJ_E_LAST);

   /*
   ** First time called?
   */
   if (pFile->pEnum == NULL) {
      rc = ExcelCurrentStorage(pFile->hBook, &(pFile->pRootStorage));
      if ((rc != EX_errSuccess) || (pFile->pRootStorage == NULL))
         return (OLEOBJ_E_LAST);

      olerc = pFile->pRootStorage->lpVtbl->EnumElements(pFile->pRootStorage, 0, NULL, 0, &(pFile->pEnum));
      if (GetScode(olerc) != S_OK)
         return (olerc);

      pFile->pEnumStorage = NULL;
   }

   /*
   ** Close storage opened on last call
   */
   if (pFile->pEnumStorage != NULL) {
      
      // VK: storage has been released already in the IFilter wrapper
      //pFile->pEnumStorage->lpVtbl->Release(pFile->pEnumStorage);
      pFile->pEnumStorage = NULL;
   }

   /*
   ** Locate and open next storage
   */
   forever {
      olerc = pFile->pEnum->lpVtbl->Next(pFile->pEnum, 1, &ss, &ulCount);
      if ((sc = GetScode(olerc)) != S_OK) {
         pFile->pEnum->lpVtbl->Release(pFile->pEnum);
         pFile->pEnum = NULL;

         if (sc == S_FALSE)
            return (OLEOBJ_E_LAST);
         else
            return (olerc);
      }

      if (ss.type == STGTY_STORAGE) {
         olerc = pFile->pRootStorage->lpVtbl->OpenStorage
            (pFile->pRootStorage, ss.pwcsName, NULL, (STGM_READ | STGM_SHARE_EXCLUSIVE), NULL, 0, &(pFile->pEnumStorage));

         FreeString (ss.pwcsName);

         if (GetScode(olerc) != S_OK)
            return (olerc);

         *pStorage = pFile->pEnumStorage;
         return ((HRESULT)0);
      }
      FreeString (ss.pwcsName);
   }
}

//////////////////////////////////////////////////////////////////////////////

public HRESULT XLSAllocateGlobals (void ** ppG)
{
        XLS_GLOBALS * p;

        LPMALLOC pIMalloc;                    
        HRESULT hr = CoGetMalloc (MEMCTX_TASK, &pIMalloc); 
        if (!SUCCEEDED( hr ) )
        {
                *ppG = NULL;
                return hr;
        }

        if ((p = pIMalloc->lpVtbl->Alloc(pIMalloc, sizeof(XLS_GLOBALS))) == NULL)
        {
                pIMalloc->lpVtbl->Release(pIMalloc);  
                *ppG = NULL;
                return (TranslateToHResult(EX_errOutOfMemory));
        }

        memset(p, 0, sizeof(XLS_GLOBALS));
        *ppG = (void *)p;
        pIMalloc->lpVtbl->Release(pIMalloc); 

        return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

public void XLSDeleteGlobals (void ** ppG)
{
        if(*ppG) 
        {
                LPMALLOC pIMalloc;                    
                if (S_OK == CoGetMalloc (MEMCTX_TASK, &pIMalloc))
                {
                        pIMalloc->lpVtbl->Free(pIMalloc, *ppG);  
                        pIMalloc->lpVtbl->Release(pIMalloc);  
                        *ppG = NULL;
                }
        }
}

#endif // !VIEWER

public void InitNoteExtra(void * pGlobals)
{
        XLS_GLOBALS* pG = (XLS_GLOBALS*)pGlobals;
   
        ((XLS_GLOBALS*)pGlobals)->NoteExtra = 0;
}

public void AddNoteExtra(void * pGlobals, short cdData)
{
   ((XLS_GLOBALS*)pGlobals)->NoteExtra += cdData;
}

public int GetNoteExtra(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->NoteExtra;
}

public TCHAR * GetExcelRecordTextBuffer(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->ExcelRecordTextBuffer;
}
 

public wchar_t * GetUnicodeExpansionBuffer(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->UnicodeExpansionBuffer;
}


public byte __far * GetExcelRecBuffer(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->pExcelRecordBuffer;
}

public void SetExcelRecordBuffer(void * pGlobals, byte __far * pBuff)
{
   ((XLS_GLOBALS*)pGlobals)->pExcelRecordBuffer = pBuff;
}

void SetCustomFormatDatabase(void * pGlobals, void *pFormat)
{
   ((XLS_GLOBALS*)pGlobals)->pCustomFormatDatabase = pFormat;
}

void * GetCustomFormatDatabase(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->pCustomFormatDatabase;
}

void SetOrDateFormatNeeds(void * pGlobals, byte nData)
{
   ((XLS_GLOBALS*)pGlobals)->DateFormatNeeds |= nData;
}

void SetDateFormatNeeds(void * pGlobals, byte nData)
{
   ((XLS_GLOBALS*)pGlobals)->DateFormatNeeds = nData;
}

byte GetDateFormatNeeds(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->DateFormatNeeds;
}

void SetSeenAMPM(void * pGlobals, BOOL fFlag)
{
   ((XLS_GLOBALS*)pGlobals)->SeenAMPM = fFlag;
}

BOOL GetSeenAMPM(void * pGlobals)
{
   return ((XLS_GLOBALS*)pGlobals)->SeenAMPM;
}

void * GetMemFreeList(void * pGlobals)
{
        return ((XLS_GLOBALS*)pGlobals)->MemFreeList;
}

void SetMemFreeList(void * pGlobals, void * pList)
{
        ((XLS_GLOBALS*)pGlobals)->MemFreeList = pList;
}

void *  GetMemPageList(void * pGlobals)
{
        return ((XLS_GLOBALS*)pGlobals)->MemPageList;
}

void SetMemPageList(void * pGlobals, void * pList)
{
        ((XLS_GLOBALS*)pGlobals)->MemPageList = pList;
}


double GetNumSmallExp(void * pGlobals)
{
        XLS_GLOBALS * pG = (XLS_GLOBALS*)pGlobals;

        double d = pG->NumericSmallExponential;
        return d;
}

void   SetNumericSmallExponential(void * pGlobals, double d)
{
        XLS_GLOBALS * pG = (XLS_GLOBALS*)pGlobals;

        pG->NumericSmallExponential = d;
}


BOOL SHOULD_USE_EXP_FORMAT(void * pGlobals, double x)
{
        double d;
    int  sign, resultExp;


        __try
        {
                if(x == 0)
                        return FALSE;
        
                d = GetNumSmallExp(pGlobals);

                _ecvt(x, 4, &resultExp, &sign);
        
        if(resultExp < - 10 || resultExp > 11)
            return TRUE;

        if(x < d)
                        return TRUE;
                
                if((x) > USE_EXP_FORMAT_BIG)
                        return TRUE;
                else
                        return FALSE;
        }
        __except(1)
        {
                return TRUE;
        }

}

public HRESULT AddToBufferPublic(void * pGlobals, TCHAR *pText, unsigned int cbText)
{
    HRESULT rc = AddToBuffer2(pCurrentFile, pText, cbText);
    if (rc == TRUE)
        rc = EX_errSuccess;
    else
        rc = EX_errBufferFull;
    return rc;
}

public LCID XLSGetLCID(void * pGlobals)
{
   int  i;
   LCID lid = 0;

   for (i = 0; i < CPIDToLCID_CODEPAGES; i++) 
   {
      if (CPIDToLCID[i][0] == pCurrentFile->codePage)
      {
         lid = CPIDToLCID[i][1];
         break;
      }
   }
   if(lid)
   {
        return MAKELCID(lid, SORT_DEFAULT);
   }
   else
   {
        return GetSystemDefaultLCID();
   }
}

#define LCIDToCPID_CODEPAGES 48
static const UINT LCIDToCPID[LCIDToCPID_CODEPAGES][2] =
    {
        {0x0409, cpidANSI},     //U.S. English  
        {0x0809, cpidANSI},     //U.K. English  
        {0x0c09, cpidANSI},     //Australian English    
        {0x0407, cpidANSI},     //German        
        {0x040c, cpidANSI},     //French        
        {0x0410, cpidANSI},     //Italian       
        {0x0400, cpidANSI},     //No Proofing   
        {0x0401, cpidArab},     //Arabic        
        {0x0402, cpidCyril},    //Bulgarian     
        {0x0403, cpidANSI},     //Catalan       
        {0x0404, cpidPRC},      //Traditional Chinese   
        {0x0804, cpidBIG5},     //Simplified Chinese    
        {0x0405, cpidANSI},     //Czech 
        {0x0406, cpidANSI},     //Danish        
        {0x0807, cpidANSI},     //Swiss German  
        {0x0408, cpidGreek},    //Greek 
        {0x040a, cpidANSI},     //Castilian Spanish     
        {0x080a, cpidANSI},     //Mexican Spanish       
        {0x040b, cpidANSI},     //Finnish       
        {0x080c, cpidANSI},     //Belgian French        
        {0x0c0c, cpidANSI},     //Canadian French       
        {0x100c, cpidANSI},     //Swiss French  
        {0x040d, cpidHebr},     //Hebrew        
        {0x040e, cpidANSI},     //Hungarian     
        {0x040f, cpidANSI},     //Icelandic     
        {0x0810, cpidANSI},     //Swiss Italian 
        {0x0411, cpidSJIS},     //Japanese      
        {0x0412, cpidKSC},      //Korean        
        {0x0413, cpidANSI},     //Dutch 
        {0x0813, cpidANSI},     //Belgian Dutch 
        {0x0414, cpidANSI},     //Norwegian - Bokmal    
        {0x0814, cpidANSI},     //Norwegian - Nynorsk   
        {0x0415, cpidANSI},     //Polish        
        {0x0416, cpidANSI},     //Portuguese (Brazil)
        {0x0816, cpidANSI},     //Portuguese    
        {0x0417, cpidANSI},     //Rhaeto-Romanic        
        {0x0418, cpidANSI},     //Romanian      
        {0x0419, cpidCyril},    //Russian       
        {0x041a, cpidANSI},     //Croato-Serbian (Latin)        
        {0x081a, cpidCyril},    //Serbo-Croatian (Cyrillic)     
        {0x041b, cpidCyril},    //Slovak        
        {0x041d, cpidANSI},     //Swedish       
        {0x0422, cpidCyril},    //Ukrainian     
        {0x0423, cpidCyril},    //Byelorussian  
        {0x0424, cpidCyril},    //Slovenian     
        {0x0425, cpidANSI},     //Estonian      
        {0x0426, cpidANSI},     //Latvian       
        {0x0427, cpidANSI}     //Lithuanian     
        //{0x041c, Albanian     
        //{0x041e, Thai         
        //{0x041f, Turkish      
        //{0x0420, Urdu         
        //{0x0421, Bahasa       
        //{0x0429, Farsi        
        //{0x042D, Basque       
        //{0x042F, FYRO Macedonian   
        //{0x0436, Afrikaans    
        //{0x043E, Malaysian    

    };

UINT CodePageFromLid(UINT wLid)
{
    UINT CodePage = CP_ACP;   // default
    char szCodePage[64];
    int result = GetLocaleInfoA(wLid,                   // locale identifier 
                    LOCALE_IDEFAULTANSICODEPAGE,                // type of information 
                    szCodePage,                         // address of buffer for information
                    64);                                                        // size 

    if(result)
        CodePage = atoi(szCodePage);

    return CodePage;
}

/* end XLSTREAM.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubfcfg.h ===
/*
** File: BFILECFG.H
**
** Copyright (C) Advanced Quonset Technology, 1994.  All rights reserved.
**
** Notes:
**    This module is intended to be modified for each project that uses
**    the BFILE (Buffered File) package.
**
** Edit History:
**  04/01/94  kmh  First Release.
*/


/* INCLUDE TESTS */
#define BFILECFG_H

/* DEFINITIONS */

// Will the write functions be called?
#undef  BFILE_ENABLE_WRITE

// Will docfiles be accessed?
#define BFILE_ENABLE_OLE

// Prior to docfiles being accessed should OLEInitialize be called?
#undef  BFILE_INITIALIZE_OLE

// Allow the establishment of a buffer file by passing an open STORAGE?
#define BFILE_ENABLE_PUT_STORAGE

/* end BFILECFG.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubdrst.hpp ===
#ifndef BDRSTM_HPP
#define BDRSTM_HPP

#if !VIEWER

#ifdef FILTER
   #include "dmifstrm.hpp"
   #include "dmubdst2.h"
#else
   #include "ifstrm.hpp"
   #include "bdstream.h"
#endif

class CBinderStream : public IFilterStream
 {
    public:
      ULONG   AddRef();
      HRESULT Load(TCHAR *lpszFileName);
      HRESULT LoadStg(IStorage * pstg);
      HRESULT ReadContent(VOID *pv, ULONG cb, ULONG *pcbRead);
      HRESULT GetNextEmbedding(IStorage ** ppstg);
      HRESULT Unload();
      ULONG   Release();

    private:
      BDRHandle hFile;
 };

#endif // !VIEWER

#endif // BDRSTM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubdrst.cpp ===
#include <windows.h>

#if !VIEWER

#ifdef FILTER
   #include "dmubdrst.hpp"
   #include "filterr.h"
#else
   #include "bdrstm.hpp"
   #include "filterr.h"
#endif

ULONG CBinderStream::AddRef()
{
   HRESULT rc;

   /* What do I do about errors from Initialize? */

   rc = BDRInitialize();
   return (1);
}

HRESULT CBinderStream::Load(TCHAR *lpszFileName)
{
   HRESULT rc;

   rc = BDRFileOpen(lpszFileName, &hFile);
   return (rc);
}

HRESULT CBinderStream::LoadStg(IStorage *pstg)
{
   HRESULT rc;

   rc = BDRStorageOpen(pstg, &hFile);
   return (rc);
}

HRESULT CBinderStream::ReadContent (VOID *pv, ULONG cb, ULONG *pcbRead)
{
   HRESULT rc;

   rc = BDRFileRead(hFile, (byte *)pv, cb, pcbRead);
   if (*pcbRead == 0)
	   return FILTER_E_NO_MORE_TEXT;
   return (rc);
}

HRESULT CBinderStream::GetNextEmbedding(IStorage ** ppstg)
{
   HRESULT rc;

   rc = BDRNextStorage(hFile, ppstg);
   return (rc);
}

HRESULT CBinderStream::Unload()
{
   HRESULT rc;

   rc = BDRFileClose(hFile);
   return (rc);
}

ULONG CBinderStream::Release()
{
   HRESULT rc;

   /* What do I do about errors from terminate? */

   rc = BDRTerminate();
   return (0);
}

#endif // !VIEWER

/* end BDRTSTM.CPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmscp.h ===
/* scp.h
 *  
 *   Header file for using the Super Code Page Manager.  Gives code page
 * ID (CPID) numbers for code pages selected in the scp.cp file, as
 * well as prototypes for functions defined in the Scp Manager.
 */
#ifndef SCP_H_INCLUDED
#define SCP_H_INCLUDED

#if OE_WIN32			/* defines for VBA */
#ifndef WIN32
#define WIN32
#endif
#endif
#if OE_MAC
#ifndef MAC
#define MAC
#endif
#endif

typedef unsigned CPID;				/* Code page ID */

/* cpid's requested by scp.cp: */
#define cpidLics ((CPID) 32767)

/* DOS code pages */
#define cpid437  ((CPID)   437)				/* DOS, US English */
#define cpid737  ((CPID)   737)				/* DOS, Greek 437G */
#define cpid850  ((CPID)   850)				/* DOS, Multilingual */
#define cpid851  ((CPID)   851)				/* DOS, Greek */
#define cpid852  ((CPID)   852)				/* DOS, Latin-2 */
#define cpid855  ((CPID)   855)				/* DOS, Russian */
#define cpid857  ((CPID)   857)				/* DOS, Turkish */
#define cpid860  ((CPID)   860)				/* DOS, Portugal */
#define cpid863  ((CPID)   863)				/* DOS, French Canada */
#define cpid865  ((CPID)   865)				/* DOS, Norway */
#define cpid866  ((CPID)   866)				/* DOS, Russian */
#define cpid869  ((CPID)   869)				/* DOS, Greek */

/* Windows code page numbers */
#define cpidEE    ((CPID)  1250)			/* Windows, Latin-2 (East European) */
#define cpidCyril ((CPID)  1251)			/* Windows, Cyrillic */
#define cpidANSI  ((CPID)  1252)			/* Windows, Multilingual (ANSI) */
#define cpidGreek ((CPID)  1253)			/* Windows, Greek */
#define cpidTurk  ((CPID)  1254)			/* Windows, Turkish */
#define cpidHebr  ((CPID)  1255)			/* Windows, Hebrew */
#define cpidArab  ((CPID)  1256)			/* Windows, Arabic */

/* East Asia Windows code page numbers (sanctioned by IBM/Japan) */
#define cpidSJIS ((CPID)   932)				/* Japanese Shift-JIS */
#define cpidPRC  ((CPID)   936)				/* Chinese GB 2312 (Mainland China) */
#define cpidKSC  ((CPID)   949)				/* Korean KSC 5601 */
#define cpidBIG5 ((CPID)   950)				/* Chinese Big-5 (Taiwan) */

/* Mac code pages (10000+script ids) */
#define cpidMac		((CPID) 10000)			/* Mac, smRoman */
#define cpidMacSJIS ((CPID) (10000+1))		/* Mac, smJapanese */
#define cpidMacBIG5 ((CPID) (10000+2))		/* Mac, smTradChinese */
#define cpidMacKSC  ((CPID) (10000+3))		/* Mac, smKorean */
#define cpidMArab	((CPID) (10000+4))		/* Mac, smArabic */
#define cpidMHebr	((CPID) (10000+5))		/* Mac, smHebrew */
#define cpidMGreek	((CPID) (10000+6))		/* Mac, smGreek */
#define cpidMCyril	((CPID) (10000+7))		/* Mac, smCyrillic */
#define cpidMacPRC  ((CPID) (10000+25))		/* Mac, smSimpChinese */
#define cpidMSlavic	((CPID) (10000+29))		/* Mac, smEastEurRoman */
#define cpidMIce    ((CPID) (10000+64+15))	/* Mac, smRoman,langIcelandic */
#define cpidMTurk   ((CPID) (10000+64+17))	/* Mac, smRoman,langTurkish */

#define cpidMacLast	((CPID) (10000+64+256))	/* highest Mac cpid (just a guess) */


#define cpidUnicode ((CPID) 1200)			/* for future use */


/* Useful macros */

#define FMacCp(cp) ((cp) >= cpidMac && (cp) <= cpidMacLast)

#define FDbcsCpWin(cp) ((cp) == cpidSJIS || (cp) == cpidKSC || (cp) == cpidBIG5 || (cp) == cpidPRC)
#define FDbcsCpMac(cp) ((cp) == cpidMacSJIS || (cp) == cpidMacKSC || (cp) == cpidMacBIG5 || (cp) == cpidMacPRC)
#define FDbcsCp(cp) (FDbcsCpWin(cp) || FDbcsCpMac(cp))


/* Typedefs */

typedef unsigned char SCP;			/* Code point */

typedef struct _xlat {			/* Translation table. */
	CPID	cpidFrom;				/* Code page being mapped from. */
	CPID	cpidTo;					/* Code page being mapped to. */
	SCP		mpCpCp[256];			/* Mapping of code points from cpidFrom */
	} XLAT;							/*   to cpidTo.  */

#ifndef EB_H_INCLUDED
#ifndef EBAPI		/* assume correct definition in place */
#ifdef MAC
#define EBAPI _cdecl
#else
#ifdef WIN32
#define EBAPI __stdcall
#else
#define EBAPI _far _pascal
#endif
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Functions provided by the SCP manager. */
#ifdef MAC
void EBAPI InitScpMgr (void FAR *(EBAPI *)(unsigned));
void EBAPI TermScpMgr (void (EBAPI *)(void FAR *));
#endif
int EBAPI FTranslateScp(CPID, CPID, unsigned char FAR *, unsigned);

#ifdef __cplusplus
}
#endif

#endif // !SCP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubfile.c ===
/*
** File: BFILE.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

/* INCLUDES */

#if !VIEWER

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifndef INC_OLE2
   #define INC_OLE2
#endif

#include <string.h>
#include <windows.h>

#ifdef FILTER
   #include "dmubfcfg.h"
#else
   #include "bfilecfg.h"
#endif

#ifndef WIN32
   #ifdef BFILE_ENABLE_OLE
      #include <ole2.h>
   #endif
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmubfile.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "bfile.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */

/* MODULE DATA, TYPES AND MACROS  */

#define BLOCK_STATE_READING  0
#define BLOCK_STATE_WRITING  1

typedef struct {
   int  year, month, day;
   int  hour, minute, second;
} FileDateTime;

typedef struct {
   uns  blockSize;
   byte __far *pBuffer;
   byte __far *pBufferNext;

   BOOL useOLE;
   int  openAccess;

   FILE_CHANNEL c;
   BOOL didWrite;

   #ifdef BFILE_ENABLE_OLE
      LPSTORAGE    pRootStorage;
      LPSTREAM     pCurrentStream;
      BOOL         releaseStorageOnClose;
   #endif

   FileDateTime lastWriteTime;

   #ifdef AQTDEBUG
      long totalRead;
      long totalWrite;
   #endif

   uns  bufferSize;

   byte __far *pMaxWrite;
   BOOL maxWriteEnable;
   BOOL maxWriteOn;

   long currentFilePosition;
   long blockFilePosition;
   long EOFPos;

   BOOL blockDirty;
} BufferedFile;

typedef BufferedFile __far *BFP;

#define BYTES_PER_BLOCK  65000U

#define MAX_WRITE_MARK \
        {                                             \
           if (pFile->pMaxWrite < pFile->pBufferNext) \
              pFile->pMaxWrite = pFile->pBufferNext;  \
        }

#define MAX_WRITE_ENABLE \
        pFile->maxWriteEnable = TRUE;

#define MAX_WRITE_DISABLE \
        pFile->maxWriteEnable = FALSE;

#define MAX_WRITE_ON \
        {                                             \
           pFile->maxWriteOn = TRUE;                  \
           pFile->pMaxWrite = pFile->pBuffer;         \
        }

#define MAX_WRITE_OFF \
        pFile->maxWriteOn = FALSE;


#ifdef WIN32
   #define PTR_DIFF(p1,p2) (p1-p2)
#else
   #define PTR_DIFF(p1,p2) (((unsigned long)(p1-p2)) & 0x0000ffff)
#endif


/* IMPLEMENTATION */

#ifdef WIN32
private wchar_t *AnsiToUnicode (void * pGlobals, char *pAnsi)
{
   wchar_t *pUnicode;
   int     cbAnsi, cbUnicode;

   cbAnsi = strlen(pAnsi);
   cbUnicode = (cbAnsi + 1) * 2;

   if ((pUnicode = MemAllocate(pGlobals, cbUnicode)) == NULL)
      return (NULL);

   MultiByteToWideChar(CP_ACP, 0, pAnsi, cbAnsi, pUnicode, cbUnicode/sizeof(wchar_t));
   pUnicode[cbUnicode/sizeof(wchar_t)-1] = 0;
   return (pUnicode);
}
#endif

private uns OSReadFile (BFP pFile, byte __far *buffer, uns bytesToRead)
{
#ifdef BFILE_ENABLE_OLE
   HRESULT rc;
   SCODE   sc;
   ULONG   cbRead;

   if (pFile->useOLE == FALSE)
      return (DOSReadFile(pFile->c, buffer, bytesToRead));

   rc = pFile->pCurrentStream->lpVtbl->Read
       (pFile->pCurrentStream, buffer, bytesToRead, &cbRead);

   if ((sc = GetScode(rc)) == S_OK)
      return ((uns)cbRead);
   else
      return (RW_ERROR);
#else
   return (DOSReadFile(pFile->c, buffer, bytesToRead));
#endif
}

#ifdef BFILE_ENABLE_WRITE
private uns OSWriteFile (BFP pFile, byte __far *buffer, uns bytesToWrite)
{
#ifdef BFILE_ENABLE_OLE
   HRESULT rc;
   SCODE   sc;
   ULONG   cbWrite;
   ULARGE_INTEGER currentPos;
   LARGE_INTEGER  zero;

   pFile->didWrite = TRUE;

   if (pFile->useOLE == FALSE)
      return (DOSWriteFile(pFile->c, buffer, bytesToWrite));

   if (bytesToWrite == 0) {
       LISet32(zero, 0);
       pFile->pCurrentStream->lpVtbl->Seek
          (pFile->pCurrentStream, zero, STREAM_SEEK_CUR, &currentPos);

      rc = pFile->pCurrentStream->lpVtbl->SetSize
          (pFile->pCurrentStream, currentPos);
   }
   else {
      rc = pFile->pCurrentStream->lpVtbl->Write
          (pFile->pCurrentStream, buffer, bytesToWrite, &cbWrite);
   }

   if ((sc = GetScode(rc)) == S_OK)
      return ((uns)cbWrite);
   else
      return (RW_ERROR);
#else
   uns rc;

   rc = DOSWriteFile(pFile->c, buffer, bytesToWrite);

   #ifdef WIN32
      if ((rc == 0xffff) && (GetLastError() == ERROR_DISK_FULL))
         rc = 0;
   #endif

   return (rc);
#endif
}
#endif

private int OSSetFilePosition (BFP pFile, int fromWhere, long fileOffset)
{
#ifdef BFILE_ENABLE_OLE
   HRESULT rc;
   SCODE   sc;
   LARGE_INTEGER  movement;

   if (pFile->useOLE == FALSE)
      return (DOSSetFilePosition(pFile->c, fromWhere, fileOffset));

   LISet32(movement, fileOffset);
   rc = pFile->pCurrentStream->lpVtbl->Seek
       (pFile->pCurrentStream, movement, fromWhere, NULL);

   if ((sc = GetScode(rc)) == S_OK)
      return (0);
   else
      return (-1);
#else
   return (DOSSetFilePosition(pFile->c, fromWhere, fileOffset));
#endif
}

private int OSGetFilePosition (BFP pFile, long __far *fileOffset)
{
#ifdef BFILE_ENABLE_OLE
   HRESULT rc;
   SCODE   sc;
   ULARGE_INTEGER currentPos;
   LARGE_INTEGER  zero;

   if (pFile->useOLE == FALSE)
      return (DOSGetFilePosition(pFile->c, fileOffset));

   LISet32(zero, 0);
   rc = pFile->pCurrentStream->lpVtbl->Seek
       (pFile->pCurrentStream, zero, STREAM_SEEK_CUR, &currentPos);

   if ((sc = GetScode(rc)) != S_OK)
      return (-1);

   *fileOffset = currentPos.LowPart;
   return (0);
#else
   return (DOSGetFilePosition(pFile->c, fileOffset));
#endif
}

#ifdef BFILE_ENABLE_OLE
#ifdef BFILE_INITIALIZE_OLE
static int OLEInitialized = 0;
#endif

private int OLEInit (void)
{
   #ifdef BFILE_INITIALIZE_OLE
      SCODE  sc;

      if (OLEInitialized == 0) {
         sc = GetScode(OleInitialize(NULL));
         if ((sc != S_OK) && (sc != S_FALSE))
            return (BF_errOLEInitializeFailure);
      }
      OLEInitialized++;
   #endif
   return (BF_errSuccess);
}

private void OLETerm (void)
{
   #ifdef BFILE_INITIALIZE_OLE
      OLEInitialized--;

      if (OLEInitialized == 0)
         OleUninitialize();
   #endif
}
#endif

private int OSCloseFile (BFP pFile)
{
#ifdef BFILE_ENABLE_OLE
   if (pFile->useOLE == FALSE)
      return (DOSCloseFile(pFile->c));

   if (pFile->pRootStorage != NULL) {
      if (((pFile->openAccess & DOS_RDWR) != 0) && (pFile->didWrite == TRUE))
         pFile->pRootStorage->lpVtbl->Commit(pFile->pRootStorage, STGC_OVERWRITE);

      if (pFile->pCurrentStream != NULL)
         pFile->pCurrentStream->lpVtbl->Release(pFile->pCurrentStream);

      if (pFile->releaseStorageOnClose == TRUE)
         pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);
   }

   OLETerm();
   return (BF_errSuccess);
#else
   return (DOSCloseFile(pFile->c));
#endif
}

private int OSOpenFile (TCHAR __far *pathname, int access, BFP pFile)
{
   int     rc;
#ifdef BFILE_ENABLE_OLE
   HRESULT olerc;
   SCODE   sc;
   long    storageAccess;
#endif

   pFile->openAccess = access;

   if (pFile->useOLE == FALSE) {
      if ((rc = DOSOpenFile(pathname, access, &(pFile->c))) == 0)
         return (BF_errSuccess);

      if (rc == DOS_ERROR_TOO_MANY_OPEN_FILES)
         rc = BF_errOutOfFileHandles;
      else if (rc == DOS_ERROR_FILE_NOT_FOUND)
         rc = BF_errFileNotFound;
      else if (rc == DOS_ERROR_PATH_NOT_FOUND)
         rc = BF_errPathNotFound;
      else
         rc = BF_errFileAccessDenied;

      return (rc);
   }

#ifdef BFILE_ENABLE_OLE
   if ((rc = OLEInit()) != BF_errSuccess)
      return (rc);

   storageAccess = (unsigned int)access | STGM_DIRECT;

   #if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      wchar_t *pPathInUnicode = AnsiToUnicode(pGlobals, pathname);

      olerc = StgOpenStorage(pPathInUnicode, NULL, storageAccess, NULL, 0, &(pFile->pRootStorage));
      MemFree (pPathInUnicode);
   }
   #else
   olerc = StgOpenStorage(pathname, NULL, storageAccess, NULL, 0, &(pFile->pRootStorage));
   #endif

   if ((sc = GetScode(olerc)) != S_OK) {
      if (sc == STG_E_FILENOTFOUND)
         rc = BF_errFileNotFound;
      else if (sc == STG_E_PATHNOTFOUND)
         rc = BF_errFileNotFound;
      else if (sc == STG_E_TOOMANYOPENFILES)
         rc = BF_errOutOfFileHandles;
      else if ((sc == STG_E_ACCESSDENIED) || (sc == STG_E_SHAREVIOLATION))
         rc = BF_errFileAccessDenied;
      else if (sc == STG_E_LOCKVIOLATION) 
         rc = STG_E_LOCKVIOLATION;
      else if (sc == STG_E_FILEALREADYEXISTS)
         rc = BF_errOLENotCompoundFile;
      else
         rc = BF_errFileAccessDenied;

      OLETerm();
      return (rc);
   }

   pFile->useOLE = TRUE;
   pFile->releaseStorageOnClose = TRUE;

   return (BF_errSuccess);
#else
   return (BF_errFileNotFound);
#endif
}

#ifdef BFILE_ENABLE_WRITE
private int OSCreateFile (TCHAR __far *pathname, BFP pFile)
{
   int     rc;
#ifdef BFILE_ENABLE_OLE
   HRESULT olerc;
   SCODE   sc;
#endif

   pFile->openAccess = DOS_RDWR;

   if (pFile->useOLE == FALSE) {
      if ((rc = DOSCreateFile(pathname, &(pFile->c))) == 0)
         return (BF_errSuccess);

      if (rc == DOS_ERROR_TOO_MANY_OPEN_FILES)
         rc = BF_errOutOfFileHandles;
      else if (rc == DOS_ERROR_ACCESS_DENIED)
         rc = BF_errFileAccessDenied;
      else if (rc == DOS_ERROR_PATH_NOT_FOUND)
         rc = BF_errPathNotFound;
      else
         rc = BF_errCreateFailed;

      return (rc);
   }

#ifdef BFILE_ENABLE_OLE
   if ((rc = OLEInit()) != BF_errSuccess)
      return (rc);

   #if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      wchar_t *pPathInUnicode = AnsiToUnicode(pGlobals, pathname);

      olerc = StgCreateDocfile
            (pPathInUnicode, STGM_WRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE | STGM_TRANSACTED,
             0, &(pFile->pRootStorage));

      MemFree (pPathInUnicode);
   }
   #else
   olerc = StgCreateDocfile
          (pathname, STGM_WRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE | STGM_TRANSACTED,
           0, &(pFile->pRootStorage));
   #endif

   if ((sc = GetScode(olerc)) != S_OK) {
      if (sc == STG_E_PATHNOTFOUND)
         rc = BF_errPathNotFound;
      else if (sc == STG_E_TOOMANYOPENFILES)
         rc = BF_errOutOfFileHandles;
      else if (sc == STG_E_ACCESSDENIED)
         rc = BF_errFileAccessDenied;
      else if (sc == STG_E_LOCKVIOLATION)
         rc = STG_E_LOCKVIOLATION;
      else
         rc = BF_errCreateFailed;

      OLETerm();
      return (rc);
   }

   pFile->useOLE = TRUE;
   pFile->releaseStorageOnClose = TRUE;

   return (BF_errSuccess);
#endif
}

#endif

/*--------------------------------------------------------------------------*/

private int ReadFileBlock (BFP pFile)
{
   uns cbRead;

   pFile->blockFilePosition = pFile->currentFilePosition;
   if ((cbRead = OSReadFile(pFile, pFile->pBuffer, pFile->bufferSize)) == RW_ERROR)
      return (BF_errIOError);

   if (pFile->currentFilePosition + (long)((unsigned long)pFile->bufferSize) > pFile->EOFPos)
      cbRead = (uns)(pFile->EOFPos - pFile->currentFilePosition);

   pFile->currentFilePosition += cbRead;
   pFile->blockSize = cbRead;
   pFile->pBufferNext = pFile->pBuffer;

   #ifdef AQTDEBUG
      pFile->totalRead += cbRead;
   #endif

   MAX_WRITE_ON;
   return (BF_errSuccess);
}

#ifdef BFILE_ENABLE_WRITE
private int WriteFileBlock (BFP pFile)
{
   uns cbWrite;
   uns cbBlock;

   OSSetFilePosition (pFile, FROM_START, pFile->blockFilePosition);

   if ((pFile->maxWriteEnable == TRUE) && (pFile->maxWriteOn == TRUE))
      cbBlock = (uns)PTR_DIFF(pFile->pMaxWrite, pFile->pBuffer);
   else
      cbBlock = pFile->blockSize;

   pFile->currentFilePosition = pFile->blockFilePosition + cbBlock;
   pFile->blockFilePosition = pFile->currentFilePosition;

   if ((cbWrite = OSWriteFile(pFile, pFile->pBuffer, cbBlock)) == 0xffff)
      return (BF_errIOError);

   if (cbWrite != cbBlock)
      return (BF_errDiskFull);

   pFile->blockSize   = 0;
   pFile->pBufferNext = pFile->pBuffer;
   pFile->blockDirty  = FALSE;

   #ifdef AQTDEBUG
      pFile->totalWrite += cbBlock;
   #endif

   MAX_WRITE_ON;
   return (BF_errSuccess);
}
#endif

private void InitializeBufferBlock (BFP pFile)
{
   pFile->bufferSize = BYTES_PER_BLOCK;
   pFile->blockFilePosition = 0;
   pFile->currentFilePosition = 0;
   pFile->blockSize = 0;
   pFile->pBufferNext = pFile->pBuffer;
}

/*
** ----------------------------------------------------------------------------
** File Open and Read Support
** ----------------------------------------------------------------------------
*/
public int BFOpenFile (void * pGlobals, TCHAR __far *pathname, int options, BFile __far *handle)
{
   int  rc;
   BFP  pFile;
   byte __far *pBuffer;

   if ((pFile = MemAllocate(pGlobals, sizeof(BufferedFile))) == NULL)
      return (BF_errOutOfMemory);

   DOSFileDateTime 
      (pathname, DOS_LAST_WRITE_TIME, 
       &(pFile->lastWriteTime.year), &(pFile->lastWriteTime.month), &(pFile->lastWriteTime.day),
       &(pFile->lastWriteTime.hour), &(pFile->lastWriteTime.minute), &(pFile->lastWriteTime.second));

   if ((options & BFILE_IS_DOCFILE) != 0)
      pFile->useOLE = TRUE;

   if ((rc = OSOpenFile(pathname, (options & 0x00ff), pFile)) != 0) {
      MemFree (pGlobals, pFile);
      return (rc);
   }

   if ((pBuffer = MemAllocate(pGlobals, BYTES_PER_BLOCK)) == NULL) {
      OSCloseFile (pFile);
      MemFree (pGlobals, pFile);
      return (BF_errOutOfMemory);
   }
   pFile->pBuffer = pBuffer;

   InitializeBufferBlock (pFile);

   if (pFile->useOLE == FALSE) {
      OSSetFilePosition (pFile, FROM_END, 0);
      OSGetFilePosition (pFile, &(pFile->EOFPos));
      OSSetFilePosition (pFile, FROM_START, 0);
   }

   *handle = (BFile)pFile;
   return (BF_errSuccess);
}

public int BFCloseFile (void * pGlobals, BFile handle)
{
   int rcWrite = BF_errSuccess;
   int rcClose;
   BFP pFile = (BFP)handle;

   #ifdef BFILE_ENABLE_WRITE
      if (pFile->blockDirty == TRUE)
         rcWrite = WriteFileBlock(pFile);
      else
         rcWrite = BF_errSuccess;

      if (pFile->didWrite == TRUE) {
         OSSetFilePosition (pFile, FROM_START, pFile->EOFPos);
         OSWriteFile (pFile, pFile->pBuffer, 0);
      }
   #endif

   rcClose = OSCloseFile(pFile);

   if (pGlobals) {
           MemFree (pGlobals, pFile->pBuffer);
           MemFree (pGlobals, pFile);
   }

   if (rcWrite != BF_errSuccess)
      return (rcWrite);

   return (rcClose);
}

public int BFReadFile (BFile handle, byte __far *buffer, uns bytesToRead)
{
   int  rc;
   uns  cbRead, cbRemaining;
   BFP  pFile = (BFP)handle;
   long newPos;

   if (bytesToRead == 0)
      return (BF_errSuccess);

   cbRemaining = pFile->blockSize - (uns)PTR_DIFF(pFile->pBufferNext, pFile->pBuffer);

   if (bytesToRead <= cbRemaining) {
      if (bytesToRead == 1) {
         *buffer = *pFile->pBufferNext++;
      }
      else {
         memcpy (buffer, pFile->pBufferNext, bytesToRead);
         pFile->pBufferNext += bytesToRead;
      }
      return (BF_errSuccess);
   }

   newPos = (long) ( pFile->blockFilePosition + PTR_DIFF(pFile->pBufferNext, pFile->pBuffer) );

   #ifdef BFILE_ENABLE_WRITE
   if (pFile->blockDirty == TRUE) {
      if ((rc = WriteFileBlock(pFile)) < 0)
         return (rc);
   }
   #endif

   pFile->currentFilePosition = newPos;
   OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

   if ((rc = ReadFileBlock(pFile)) < 0)
      return (rc);

   cbRead = min(bytesToRead, pFile->blockSize);

   memcpy (buffer, pFile->pBufferNext, cbRead);
   pFile->pBufferNext += cbRead;

   if (cbRead != bytesToRead)
      return (BF_errEndOfFile);
   else
      return (BF_errSuccess);
}

public int BFGetFilePosition (BFile handle, long __far *fileOffset)
{
   BFP pFile = (BFP)handle;

   *fileOffset = (long) ( pFile->blockFilePosition + PTR_DIFF(pFile->pBufferNext, pFile->pBuffer) );
   return (BF_errSuccess);
}

public int BFSetFilePosition (BFile handle, int fromWhere, long fileOffset)
{
   BFP  pFile = (BFP)handle;
   int  rc = BF_errSuccess;
   long newPosition, currentPosition;
   long movement;

   currentPosition = (long) ( pFile->blockFilePosition + PTR_DIFF(pFile->pBufferNext, pFile->pBuffer) );

   if (fromWhere == FROM_START)
      newPosition = fileOffset;
   else if (fromWhere == FROM_END)
      newPosition = pFile->EOFPos + fileOffset;
   else
      newPosition = currentPosition + fileOffset;

   if (newPosition == currentPosition)
      return (BF_errSuccess);

   /*
   ** New position within the currently loaded block?
   */
   if ((newPosition >= pFile->blockFilePosition) && 
       (newPosition <= (pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) - 1)))
   {
      movement = newPosition - currentPosition;
      pFile->pBufferNext += movement;
   }

   /*
   ** Is this the last block in the file and is the new position within the buffer?
   */
   else if ((pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) == pFile->EOFPos) &&
            ((newPosition >= pFile->blockFilePosition) && 
             (newPosition <= (pFile->blockFilePosition + (long)((unsigned long)pFile->bufferSize) - 1))))
   {
      movement = newPosition - currentPosition;
      pFile->pBufferNext += movement;

      pFile->EOFPos = (long) ( pFile->blockFilePosition + PTR_DIFF(pFile->pBufferNext, pFile->pBuffer) );
      pFile->blockSize = (uns)PTR_DIFF(pFile->pBufferNext, pFile->pBuffer);
   }

   else {
      #ifdef BFILE_ENABLE_WRITE
      if (pFile->blockDirty == TRUE) {
         if ((rc = WriteFileBlock(pFile)) < 0)
            return (rc);
      }
      #endif

      pFile->currentFilePosition = newPosition;
      OSSetFilePosition (pFile, FROM_START, newPosition);

      if ((rc = ReadFileBlock(pFile)) < 0)
         return (rc);
   }
   return (BF_errSuccess);
}

public int BFFileDateTime
          (BFile handle,
           int __far *year, int __far *month, int __far *day,
           int __far *hour, int __far *minute, int __far *second)
{
   BFP pFile = (BFP)handle;

   *year   = pFile->lastWriteTime.year;
   *month  = pFile->lastWriteTime.month;
   *day    = pFile->lastWriteTime.day;

   *hour   = pFile->lastWriteTime.hour;
   *minute = pFile->lastWriteTime.minute;
   *second = pFile->lastWriteTime.second;

   return (BF_errSuccess);
}


/*
** ----------------------------------------------------------------------------
** Stream Support
** ----------------------------------------------------------------------------
*/
#ifdef BFILE_ENABLE_OLE

public int BFOpenStream  (BFile handle, TCHAR __far *streamName, int access)
{
   BFP     pFile = (BFP)handle;
   HRESULT olerc;
   SCODE   sc;
   long    streamAccess;

   if (pFile->pRootStorage == NULL)
      return (BF_errNoOpenStorage);

   if (pFile->pCurrentStream != NULL)
      return (BF_errOLEStreamAlreadyOpen);

   if ((access & DOS_RDWR) != 0)
      streamAccess = STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
   else
      streamAccess = STGM_READ | STGM_SHARE_EXCLUSIVE | STGM_DIRECT;

   #if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      wchar_t *pStreamNameInUnicode = AnsiToUnicode(pGlobals, streamName);

      olerc = pFile->pRootStorage->lpVtbl->OpenStream
             (pFile->pRootStorage, pStreamNameInUnicode, NULL, streamAccess, 0, &pFile->pCurrentStream);

      MemFree (pStreamNameInUnicode);
   }
   #else
   olerc = pFile->pRootStorage->lpVtbl->OpenStream
          (pFile->pRootStorage, streamName, NULL, streamAccess, 0, &pFile->pCurrentStream);
   #endif

   if ((sc = GetScode(olerc)) != S_OK)
      return (BF_errOLEStreamNotFound);

   InitializeBufferBlock (pFile);

   OSSetFilePosition (pFile, FROM_END, 0);
   OSGetFilePosition (pFile, &(pFile->EOFPos));
   OSSetFilePosition (pFile, FROM_START, 0);

   return (BF_errSuccess);
}

public int BFCloseStream (BFile handle)
{
   int  rc = BF_errSuccess;
   BFP  pFile = (BFP)handle;

   if (pFile->pCurrentStream == NULL)
      return (BF_errSuccess);

   #ifdef BFILE_ENABLE_WRITE
      if (pFile->blockDirty == TRUE)
         rc = WriteFileBlock(pFile);

      if (pFile->didWrite == TRUE) {
         OSSetFilePosition (pFile, FROM_START, pFile->EOFPos);
         OSWriteFile (pFile, pFile->pBuffer, 0);
      }
   #endif

   pFile->pCurrentStream->lpVtbl->Release(pFile->pCurrentStream);
   pFile->pCurrentStream = NULL;

   return (rc);
}

#ifdef BFILE_ENABLE_PUT_STORAGE

public int BFPutStorage (void * pGlobals, LPSTORAGE pStorage, int access, BFile __far *handle)
{
   int   rc;
   BFP   pFile;
   byte  __far *pBuffer;

   if ((pFile = MemAllocate(pGlobals, sizeof(BufferedFile))) == NULL)
      return (BF_errOutOfMemory);

   if ((rc = OLEInit()) != BF_errSuccess) {
      MemFree (pGlobals, pFile);
      return (rc);
   }

   pFile->pRootStorage = pStorage;
   pFile->useOLE = TRUE;
   pFile->releaseStorageOnClose = FALSE;

   if ((pBuffer = MemAllocate(pGlobals, BYTES_PER_BLOCK)) == NULL) {
      OLETerm();
      MemFree (pGlobals, pFile);
      return (BF_errOutOfMemory);
   }
   pFile->pBuffer = pBuffer;

   InitializeBufferBlock (pFile);

   *handle = (BFile)pFile;
   return (BF_errSuccess);
}

public int BFGetStorage (BFile handle, LPSTORAGE __far *pStorage)
{
   BFP pFile = (BFP)handle;

   if (pFile->useOLE == FALSE)
      *pStorage = NULL;
   else
      *pStorage = pFile->pRootStorage;

   return (BF_errSuccess);
}

#endif

#ifdef BFILE_ENABLE_WRITE

public int BFCreateStream  (BFile handle, TCHAR __far *streamName)
{
   BFP     pFile = (BFP)handle;
   HRESULT olerc;
   SCODE   sc;

   if (pFile->pRootStorage == NULL)
      return (BF_errNoOpenStorage);

   if (pFile->pCurrentStream != NULL)
      return (BF_errOLEStreamAlreadyOpen);

   #if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      wchar_t *pStreamNameInUnicode = AnsiToUnicode(pGlobals, streamName);

      olerc = pFile->pRootStorage->lpVtbl->CreateStream
             (pFile->pRootStorage, pStreamNameInUnicode,
              STGM_WRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
              0, 0, &pFile->pCurrentStream);

      MemFree (pStreamNameInUnicode);
   }
   #else
   olerc = pFile->pRootStorage->lpVtbl->CreateStream
          (pFile->pRootStorage, streamName,
           STGM_WRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
           0, 0, &pFile->pCurrentStream);
   #endif

   if ((sc = GetScode(olerc)) != S_OK)
      return (BF_errCreateFailed);

   InitializeBufferBlock (pFile);
   return (BF_errSuccess);
}

#endif

#endif

/*
** ----------------------------------------------------------------------------
** File Write Support
** ----------------------------------------------------------------------------
*/
#ifdef BFILE_ENABLE_WRITE

public int BFCreateFile (TCHAR __far *pathname, int options, BFile __far *handle)
{
   int  rc;
   BFP  pFile;
   byte __far *pBuffer;

   if ((pFile = MemAllocate(sizeof(BufferedFile))) == NULL)
      return (BF_errOutOfMemory);

   if ((options & BFILE_IS_DOCFILE) != 0)
      pFile->useOLE = TRUE;

   if ((rc = OSCreateFile(pathname, pFile)) != 0) {
      MemFree (pFile);
      return (rc);
   }

   if ((pBuffer = MemAllocate(BYTES_PER_BLOCK)) == NULL) {
      OSCloseFile (pFile);
      MemFree (pFile);
      return (BF_errOutOfMemory);
   }
   pFile->pBuffer = pBuffer;

   InitializeBufferBlock (pFile);

   *handle = (BFile)pFile;
   return (BF_errSuccess);
}

public int BFOpenFileSpace (BFile handle, long insertOffset, long cbSpace)
{
   int  rc;
   BFP  pFile = (BFP)handle;
   long readPos;
   byte __far *pSource;
   byte __far *pDest;
   uns  x;

   ASSERTION (cbSpace < (long)pFile->bufferSize);

   /*
   ** Is the insertion offset within the current block?
   */
   if ((insertOffset >= pFile->blockFilePosition) && 
       (insertOffset <= (pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) - 1)))
   {
      /*
      ** Is this the last block in the file?
      */
      if (pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) == pFile->EOFPos)
      {
         /*
         ** Can it hold the expansion?
         */
         if ((long)((unsigned long)pFile->blockSize) + cbSpace <= (long)((unsigned long)pFile->bufferSize))
         {
            pSource = pFile->pBuffer + (insertOffset - pFile->blockFilePosition);
            pDest = pSource + cbSpace;

            memmove(pDest, pSource, (uns)(pFile->EOFPos - insertOffset));
            pFile->blockDirty = TRUE;
            MAX_WRITE_OFF;

            pFile->EOFPos += cbSpace;
            pFile->blockSize += (uns)cbSpace;
            pFile->pBufferNext = pSource;
            return (BF_errSuccess);
         }
      }
   }

   /*
   ** Expanding at the end of file?
   */
   if (pFile->EOFPos == insertOffset) {
      pFile->currentFilePosition = pFile->EOFPos;
      pFile->blockFilePosition = pFile->currentFilePosition;
      pFile->blockSize = 0;
      pFile->EOFPos += cbSpace;

      MAX_WRITE_OFF;
      return (BF_errSuccess);
    }

   if (pFile->blockDirty == TRUE) {
      if ((rc = WriteFileBlock(pFile)) < 0)
         return (rc);
   }

   MAX_WRITE_DISABLE;

   /*
   ** Is the insertion point within one block width of the end of file? Also, if
   ** we read from the insertion point can the block also hold the expansion?
   */
   if ((pFile->EOFPos - insertOffset + cbSpace) <= (long)((unsigned long)pFile->bufferSize))
   {
      pFile->currentFilePosition = insertOffset;
      OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

      if ((rc = ReadFileBlock(pFile)) < 0)
         return (rc);

      memmove(pFile->pBuffer + cbSpace, pFile->pBuffer, pFile->blockSize);
      pFile->blockDirty = TRUE;

      pFile->blockSize +=(uns)cbSpace;
      ASSERTION (pFile->blockSize <= pFile->bufferSize);
   }

   /*
   ** Is the insertion point within one block width of the end of file? In
   ** this case we can't also hold the expansion.
   */
   else if ((pFile->EOFPos - insertOffset) <= (long)((unsigned long)pFile->bufferSize))
   {
      pFile->currentFilePosition = insertOffset;
      OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

      if ((rc = ReadFileBlock(pFile)) < 0)
         return (rc);

      pFile->blockFilePosition = insertOffset + cbSpace;
      if ((rc = WriteFileBlock(pFile)) < 0)
         return (rc);

      memmove(pFile->pBuffer + cbSpace, pFile->pBuffer, pFile->bufferSize - (uns)cbSpace);
      pFile->blockDirty = TRUE;

      pFile->blockFilePosition = insertOffset;
      pFile->blockSize = pFile->bufferSize;
   }

   else
   {
      /*
      ** Read and write blocks to open a space.
      */
      readPos = pFile->EOFPos - pFile->bufferSize;
      while (readPos >= insertOffset) {
         pFile->currentFilePosition = readPos;
         OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

         if ((rc = ReadFileBlock(pFile)) < 0)
            return (rc);

         pFile->blockFilePosition = readPos + cbSpace;
         if ((rc = WriteFileBlock(pFile)) < 0)
            return (rc);

         readPos -= pFile->bufferSize;
      }
      readPos += pFile->bufferSize;

      if ((uns)((readPos - insertOffset) + cbSpace) > pFile->bufferSize) {
         x = pFile->bufferSize;
         pFile->bufferSize = (uns)(((readPos - insertOffset) + cbSpace) - pFile->bufferSize);

         readPos = readPos - pFile->bufferSize;

         pFile->currentFilePosition = readPos;
         OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

         if ((rc = ReadFileBlock(pFile)) < 0)
            return (rc);

         pFile->blockFilePosition = readPos + cbSpace;
         if ((rc = WriteFileBlock(pFile)) < 0)
            return (rc);

         pFile->bufferSize = x;
      }

      pFile->currentFilePosition = insertOffset;
      OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

      x = pFile->bufferSize;
      pFile->bufferSize = (uns)(readPos - insertOffset);

      if ((rc = ReadFileBlock(pFile)) < 0)
         return (rc);

      memmove(pFile->pBuffer + cbSpace, pFile->pBuffer, (uns)(readPos - insertOffset));
      pFile->blockDirty = TRUE;

      pFile->blockFilePosition = insertOffset;
      pFile->blockSize = pFile->bufferSize + (uns)cbSpace;

      pFile->bufferSize = x;
   }

   pFile->EOFPos += cbSpace;

   MAX_WRITE_ENABLE;
   MAX_WRITE_OFF;

   return (BF_errSuccess);
}

public int BFRemoveFileSpace (BFile handle, long atOffset, long cbSpace)
{
   int  rc;
   BFP  pFile = (BFP)handle;
   long readPos;
   byte __far *pSource;
   byte __far *pDest;

   ASSERTION (cbSpace < (long)pFile->bufferSize);

   /*
   ** Is the offset within the current block?
   */
   if ((atOffset >= pFile->blockFilePosition) && 
       (atOffset <= (pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) - 1)))
   {
      /*
      ** Is this the last block in the file?
      */
      if (pFile->blockFilePosition + (long)((unsigned long)pFile->blockSize) == pFile->EOFPos)
      {
         pDest = pFile->pBuffer + (atOffset - pFile->blockFilePosition);
         pSource = pDest + cbSpace;

         memmove(pDest, pSource, (uns)(pFile->EOFPos - (atOffset + cbSpace)));
         pFile->blockDirty = TRUE;
         MAX_WRITE_OFF;

         pFile->EOFPos -= cbSpace;
         pFile->blockSize -= (uns)cbSpace;
         return (BF_errSuccess);
      }
   }

   /*
   ** Removing at the end of file?
   */
   if (pFile->EOFPos == atOffset) {
      pFile->EOFPos -= cbSpace;
      pFile->currentFilePosition = pFile->EOFPos;
      pFile->blockFilePosition = pFile->currentFilePosition;
      pFile->blockSize = 0;

      MAX_WRITE_OFF;
      return (BF_errSuccess);
   }

   if (pFile->blockDirty == TRUE) {
      if ((rc = WriteFileBlock(pFile)) < 0)
       return (rc);
   }

   MAX_WRITE_DISABLE;

   readPos = atOffset + cbSpace;
   forever {
      pFile->currentFilePosition = readPos;
      OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

      if ((rc = ReadFileBlock(pFile)) < 0)
         return (rc);

      pFile->blockFilePosition = readPos - cbSpace;
      if ((rc = WriteFileBlock(pFile)) < 0)
         return (rc);

      readPos += pFile->bufferSize;

      if (readPos >= pFile->EOFPos)
         break;
   }

   pFile->currentFilePosition = atOffset;
   OSSetFilePosition (pFile, FROM_START, pFile->currentFilePosition);

   if ((rc = ReadFileBlock(pFile)) < 0)
      return (rc);

   pFile->EOFPos -= cbSpace;

   MAX_WRITE_ENABLE;
   MAX_WRITE_OFF;

   return (BF_errSuccess);
}
#endif

#endif // !VIEWER

/* end BFILE.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubfile.h ===
/*
** File: BFILE.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/01/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define BFFILE_H

/* DEFINITIONS */

#ifdef FILTER
   #include "dmubfcfg.h"
#else
   #include "bfilecfg.h"
#endif

typedef byte __far *BFile;

/*
** ----------------------------------------------------------------------------
** File Open and Read Support
**
** Pathnames supplied in the OEM character set
** ----------------------------------------------------------------------------
*/

// Open options
#define BFILE_IS_DOCFILE  0x0100

// Open a file or docfile using the path to the file
extern int BFOpenFile (void * pGlobals, TCHAR __far *pathname, int options, BFile __far *handle);

// Close a file
extern int BFCloseFile (void * pGlobals, BFile handle);

// Read from a file - returns BF_errEndOfFile if can't do full read
extern int BFReadFile (BFile handle, byte __far *buffer, uns bytesToRead);

// Return the file pointer
extern int BFGetFilePosition (BFile handle, long __far *fileOffset);

// Set the file pointer
extern int BFSetFilePosition (BFile handle, int fromWhere, long fileOffset);

// File creation datetime
extern int BFFileDateTime
          (BFile handle,
           int __far *year, int __far *month, int __far *day,
           int __far *hour, int __far *minute, int __far *second);

/*
** ----------------------------------------------------------------------------
** Stream Support
**
** Stream names supplied in the ANSI character set
** ----------------------------------------------------------------------------
*/
#ifdef BFILE_ENABLE_OLE

// Open a stream in a docfile
extern int BFOpenStream  (BFile handle, TCHAR __far *streamName, int access);

// Close a stream in a docfile
extern int BFCloseStream (BFile handle);

#ifdef BFILE_ENABLE_PUT_STORAGE

// Provide an already open storage to BFILE
extern int BFPutStorage (void * pGlobals, LPSTORAGE pStorage, int access, BFile __far *handle);

// Return the root storage (if there is one) of the given file
extern int BFGetStorage (BFile handle, LPSTORAGE __far *pStorage);

#endif

#ifdef BFILE_ENABLE_WRITE

// Add a new stream to a docfile
extern int BFCreateStream  (BFile handle, TCHAR __far *streamName);

#endif

#endif

/*
** ----------------------------------------------------------------------------
** File Write Support
**
** Pathnames supplied in the OEM character set
** ----------------------------------------------------------------------------
*/
#ifdef BFILE_ENABLE_WRITE

// Create a file or docfile
extern int BFCreateFile (TCHAR __far *pathname, int options, BFile __far *handle);

// Write to a file - return an error if can't do full write
extern int BFWriteFile (BFile handle, void __far *buffer, uns bytesToWrite);

// Open a hole in the file
extern int BFOpenFileSpace (BFile handle, long insertOffset, long cbSpace);

// Remove a section from the file
extern int BFRemoveFileSpace (BFile handle, long removeOffset, long cbSpace);

#endif

#define BF_errSuccess               0
#define BF_errOutOfFileHandles     -1
#define BF_errFileAccessDenied     -2
#define BF_errPathNotFound         -3
#define BF_errFileNotFound         -4
#define BF_errIOError              -5
#define BF_errOutOfMemory          -6
#define BF_errOLEInitializeFailure -7
#define BF_errOLENotCompoundFile   -8
#define BF_errOLEStreamNotFound    -9
#define BF_errOLEStreamAlreadyOpen -10
#define BF_errCreateFailed         -11
#define BF_errDiskFull             -12
#define BF_errNoOpenStorage        -13
#define BF_errEndOfFile            -14
#define BF_errLast                 BF_errEndOfFile

#endif // !VIEWER
/* end BFFILE.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubdst2.h ===
/*
** BDSTREAM.H
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Windows Binder filter.
**
** Edit History:
**  12/30/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDE TESTS */
#define BDSTREAM_H


/* DEFINITIONS */

#ifdef  __cplusplus
extern "C" {
#endif

#ifdef WIN32
   #define __far
#endif

typedef byte *BDRHandle;

// Connects to AddRef
extern HRESULT BDRInitialize (void);

// Connects to Release
extern HRESULT BDRTerminate  (void);

// Connects to Load
extern HRESULT BDRFileOpen (TCHAR *pathname, BDRHandle *hBDRFile);

// Connects to LoadStg
extern HRESULT BDRStorageOpen (LPSTORAGE pStorage, BDRHandle *hBDRFile);

// Connects to GetNextEmbedding
extern HRESULT BDRNextStorage (BDRHandle hBDRFile, LPSTORAGE *pStorage);

// Connects to Unload
extern HRESULT BDRFileClose (BDRHandle hBDRFile);

// Connects to ReadContent
extern HRESULT BDRFileRead
      (BDRHandle hBDRFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed);

#ifdef  __cplusplus
}
#endif

#endif // !VIEWER
/* end BDSTREAM.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmubdst2.c ===
/*
** BDSTREAM.C
**
** (c) 1992-1994 Microsoft Corporation.  All rights reserved.
**
** Notes: Implements the "C" side of the Windows binder file filter.
**
** Edit History:
**  12/30/94  kmh  First Release.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#ifndef INC_OLE2
   #define INC_OLE2
#endif

#include <string.h>
#include <windows.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
   #include "dmwindos.h"
   #include "dmubdst2.h"
   #include "filterr.h"
#else
   #include "qstd.h"
   #include "winutil.h"
   #include "windos.h"
   #include "bdstream.h"
   #include "filterr.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

typedef struct {
   LPSTORAGE      pRootStorage;
   LPSTREAM       pBinderStream;
   LPSTORAGE      pEnumStorage;
   LPENUMSTATSTG  pEnum;
   BOOL           releaseStorageOnClose;

   ULARGE_INTEGER sectionPos;
   DWORD          ctSections;
   DWORD          iSection;

   unsigned long  cbBufferSize;
   byte           *pBufferData;
   unsigned long  cbBufferUsed;
} FileData;

typedef FileData *FDP;

#define STORAGE_ACCESS (STGM_DIRECT | STGM_SHARE_DENY_WRITE | STGM_READ)
#define STREAM_ACCESS  (STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ)

#if (defined(WIN32) && !defined(OLE2ANSI))
   #define BINDER_NAME    L"Binder"
#else
   #define BINDER_NAME    "Binder"
#endif


#define FreeString(s)                            \
        {                                        \
           LPMALLOC pIMalloc;                    \
           CoGetMalloc (MEMCTX_TASK, &pIMalloc); \
           pIMalloc->lpVtbl->Free(pIMalloc, s);  \
           pIMalloc->lpVtbl->Release(pIMalloc);  \
        }


// Format of Binder stream.
//
//   1)DOCHEADER
//   2)SECTION_RECORD
//   3)History list for that section
//   .
//   .
//   ... for as many Sections as are present, repeat 2 and 3 for all sections
//   and all deleted sections.

// Maximum size of a string within Binder.
#define MAX_STR_SIZE       256

#define APPMAJORVERSIONNO  5

typedef struct tagDOCHEADER {
    DWORD       m_dwLength;             // Length (in bytes) of the structure
    LONG        m_narrAppVersionNo[2];
    LONG        m_narrMinAppVersionNo[2];
    GUID        m_guidBinderId;         // The unique ID of the binder
    DWORD       m_cSections;
    DWORD       m_cDeletedSections;
    LONG        m_nActiveSection;
    LONG        m_nFirstVisibleTab;     // in the tabbar
    FILETIME    m_TotalEditTime;        // amount of time file is open for edit
    FILETIME    m_CreateTime;           // Time Created
    FILETIME    m_LastPrint;            // When last printed
    FILETIME    m_LastSave;             // When last saved
    DWORD       m_dwState;              // remember state info like tabbars viaibility
    DWORD       m_reserved[3];          // space reserved for future use
} DOCHEADER;

typedef struct tagSECTIONRECORD
{
    DWORD       m_dwLength;             // Length (in bytes) of all the
                                        // data that make up a section.
                                        // It includes the size of the
                                        // SECTIONNAMERECORD and of the
                                        // history list.
    GUID        m_guidSectionId;        // The unique ID of the section
    DWORD       m_dwState;              // state of this section
    DWORD       m_dwStgNumber;          // Unique stg number for this section
    DWORD       m_reserved1;            // space reserved for future use
    DWORD       m_reserved2;            // space reserved for future use
    DWORD       m_reserved3;            // space reserved for future use
    DWORD       m_reserved4;            // space reserved for future use
    DWORD       m_dwDisplayNameOffset;  // Offset to the SECTIONNAMERECORD
                                        // from the beggining of this struct.
    DWORD       m_dwHistoryListOffset;  // Offset to the history list
    // Display name
    // History list
} SECTIONRECORD;

typedef struct tagSECTIONNAMERECORD
{
    DWORD       m_dwNameSize;           // Size of variable len
    // Display name of size m_dwNameSize
} SECTIONNAMERECORD;

#ifdef MAC
   // These two functions are defined in docfil.cpp
   WORD  SwapWord  (WORD theWord);
   DWORD SwapDWord (DWORD theDWord);
#else
   #define SwapWord(theWord) theWord
   #define SwapDWord(theDWord) theDWord
#endif 


/* IMPLEMENTATION */

public HRESULT BDRInitialize (void)
{
   return ((HRESULT)0);
}

public HRESULT BDRTerminate (void)
{
   return ((HRESULT)0);
}

public HRESULT BDRFileOpen (TCHAR *pathname, BDRHandle *hBDRFile)
{
   HRESULT olerc;
   FDP     pFile;

   *hBDRFile = NULL;

   if ((pFile = calloc(1, sizeof(FileData))) == NULL)
      return (E_OUTOFMEMORY);

   #if (defined(WIN32) && !defined(OLE2ANSI) && !defined(UNICODE))
   {
      short *pPathInUnicode;
      int   cbPath, cbPathInUnicode;

      cbPath = strlen(pathname);
      cbPathInUnicode = (cbPath + 1) * 2;

      if ((pPathInUnicode = MemAllocate(cbPathInUnicode)) == NULL) {
         MemFree (pFile);
         return (FILTER_E_FF_OUT_OF_MEMORY);
      }

      MsoMultiByteToWideChar(CP_ACP, 0, pathname, cbPath, pPathInUnicode, cbPathInUnicode);
      olerc = StgOpenStorage(pPathInUnicode, NULL, STORAGE_ACCESS, NULL, 0, &(pFile->pRootStorage));

      MemFree (pPathInUnicode);
   }

   #else
   olerc = StgOpenStorage(pathname, NULL, STORAGE_ACCESS, NULL, 0, &(pFile->pRootStorage));
   #endif

   if (GetScode(olerc) != S_OK) {
      free (pFile);
      return (olerc);
   }

   olerc = pFile->pRootStorage->lpVtbl->OpenStream
          (pFile->pRootStorage, BINDER_NAME, NULL, STREAM_ACCESS, 0, &pFile->pBinderStream);

   if (GetScode(olerc) != S_OK) {
      pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);
      free (pFile);
      return (olerc);
   }

   pFile->releaseStorageOnClose = TRUE;
   *hBDRFile = (BDRHandle)pFile;

   return ((HRESULT)0);
}

public HRESULT BDRStorageOpen (LPSTORAGE pStorage, BDRHandle *hBDRFile)
{
   FDP      pFile;
   LPSTREAM pBinderStream;
   HRESULT  olerc;

   *hBDRFile = NULL;

   olerc = pStorage->lpVtbl->OpenStream
          (pStorage, BINDER_NAME, NULL, STREAM_ACCESS, 0, &pBinderStream);

   if (GetScode(olerc) != S_OK)
      return (olerc);

   if ((pFile = calloc(1, sizeof(FileData))) == NULL) {
      pBinderStream->lpVtbl->Release(pBinderStream);
      return (E_OUTOFMEMORY);
   }

   pFile->pRootStorage  = pStorage;
   pFile->pBinderStream = pBinderStream;
   pFile->releaseStorageOnClose = FALSE;

   *hBDRFile = (BDRHandle)pFile;
   return ((HRESULT)0);
}

public HRESULT BDRFileClose (BDRHandle hBDRFile)
{
   FDP pFile = (FDP)hBDRFile;

   if (pFile == NULL)
      return ((HRESULT)0);

   if (pFile->pEnumStorage != NULL)
      pFile->pEnumStorage->lpVtbl->Release(pFile->pEnumStorage);

   if (pFile->pEnum != NULL)
      pFile->pEnum->lpVtbl->Release(pFile->pEnum);

   pFile->pBinderStream->lpVtbl->Release(pFile->pBinderStream);

   if (pFile->releaseStorageOnClose == TRUE)
      pFile->pRootStorage->lpVtbl->Release(pFile->pRootStorage);

   free (pFile);
   return ((HRESULT)0);
}

public HRESULT BDRNextStorage (BDRHandle hBDRFile, LPSTORAGE *pStorage)
{
   HRESULT  olerc;
   SCODE    sc;
   FDP      pFile = (FDP)hBDRFile;
   STATSTG  ss;
   ULONG    ulCount;

   if (pFile == NULL)
      return (OLEOBJ_E_LAST);

   /*
   ** First time called?
   */
   if (pFile->pEnum == NULL) {
      olerc = pFile->pRootStorage->lpVtbl->EnumElements(pFile->pRootStorage, 0, NULL, 0, &(pFile->pEnum));
      if (GetScode(olerc) != S_OK)
         return (olerc);

      pFile->pEnumStorage = NULL;
   }

   /*
   ** Close storage opened on last call
   */
   if (pFile->pEnumStorage != NULL) {
      pFile->pEnumStorage->lpVtbl->Release(pFile->pEnumStorage);
      pFile->pEnumStorage = NULL;
   }

   /*
   ** Locate and open next storage
   */
   forever {
      olerc = pFile->pEnum->lpVtbl->Next(pFile->pEnum, 1, &ss, &ulCount);
      if ((sc = GetScode(olerc)) != S_OK) {
         pFile->pEnum->lpVtbl->Release(pFile->pEnum);
         pFile->pEnum = NULL;

         if (sc == S_FALSE)
            return (OLEOBJ_E_LAST);
         else
            return (olerc);
      }

      if (ss.type == STGTY_STORAGE) {
         olerc = pFile->pRootStorage->lpVtbl->OpenStorage
            (pFile->pRootStorage, ss.pwcsName, NULL, (STGM_READ | STGM_SHARE_EXCLUSIVE), NULL, 0, &(pFile->pEnumStorage));

         FreeString (ss.pwcsName);

         if (GetScode(olerc) != S_OK)
            return (olerc);

         *pStorage = pFile->pEnumStorage;
         return ((HRESULT)0);
      }
      FreeString (ss.pwcsName);
   }
}

/*---------------------------------------------------------------------------*/

static TCHAR PutSeparator[] = {0x0d, 0x0a, 0x00};
#define PUT_OVERHEAD (sizeof(PutSeparator) - sizeof(TCHAR))


private BOOL AddToBuffer (FDP pFile, TCHAR *pText, unsigned int cbText)
{
   if ((pFile->cbBufferSize - pFile->cbBufferUsed) < (cbText + PUT_OVERHEAD))
      return (FALSE);

   memcpy (pFile->pBufferData + pFile->cbBufferUsed, pText, cbText);
   pFile->cbBufferUsed += cbText;

   memcpy (pFile->pBufferData + pFile->cbBufferUsed, PutSeparator, PUT_OVERHEAD);
   pFile->cbBufferUsed += PUT_OVERHEAD;
   return (TRUE);
}

#ifndef UNICODE
private char *UnicodeToAnsi (wchar_t *pUnicode, int cbUnicode)
{
   int  cbAnsi = cbUnicode;
   int  cbString;
   char *pAnsi;

   pAnsi = (char *)MemAllocate(cbAnsi + 1);
   cbString = MsoWideCharToMultiByte(CP_ACP, 0, pUnicode, cbUnicode, pAnsi, cbAnsi, NULL, NULL);
   *(pAnsi + cbString) = EOS;
   return (pAnsi);
}
#endif

private HRESULT LoadSectionName (FDP pFile, BOOL *addedToBuffer)
{
   HRESULT        rc;
   SCODE          sc;
   ULONG          cbRead;
   SECTIONRECORD  section;
   LARGE_INTEGER  zero, newPos;
   DWORD          cbName;
   wchar_t        name[MAX_STR_SIZE + 1];

   *addedToBuffer = TRUE;

   // Get the starting location of the section
   LISet32(zero, 0);
   rc = pFile->pBinderStream->lpVtbl->Seek
       (pFile->pBinderStream, zero, STREAM_SEEK_CUR, &(pFile->sectionPos));

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   // Load the section record fixed part
   rc = pFile->pBinderStream->lpVtbl->Read
       (pFile->pBinderStream, &section, sizeof(section), &cbRead);

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   if (cbRead != sizeof(section))
      return (FILTER_E_UNKNOWNFORMAT);

   // Position to the section name record
   LISet32(newPos, (LONG) (pFile->sectionPos.LowPart + SwapDWord(section.m_dwDisplayNameOffset) ));

   rc = pFile->pBinderStream->lpVtbl->Seek
       (pFile->pBinderStream, newPos, STREAM_SEEK_SET, NULL);

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   // Read the length of the section name
   rc = pFile->pBinderStream->lpVtbl->Read
       (pFile->pBinderStream, &cbName, sizeof(cbName), &cbRead);

   cbName = SwapDWord(cbName);

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   if (cbRead != sizeof(cbName))
      return (FILTER_E_UNKNOWNFORMAT);

   // Read the section name
   rc = pFile->pBinderStream->lpVtbl->Read
       (pFile->pBinderStream, name, cbName, &cbRead);

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   if (cbRead != cbName)
      return (FILTER_E_UNKNOWNFORMAT);

   // Save the section name in the buffer
   #ifdef UNICODE
      *addedToBuffer = AddToBuffer(pFile, name, cbRead);
   #else
      {
      char *pString = UnicodeToAnsi(name, (int)cbRead);
      *addedToBuffer = AddToBuffer(pFile, pString, strlen(pString));
      MemFree (pString);
      }
   #endif

   LISet32(newPos, (LONG) ( pFile->sectionPos.LowPart + SwapDWord(section.m_dwLength) ));

   rc = pFile->pBinderStream->lpVtbl->Seek
       (pFile->pBinderStream, newPos, STREAM_SEEK_SET, NULL);

   if ((sc = GetScode(rc)) != S_OK)
      return (rc);

   return ((HRESULT)0);
}

public HRESULT BDRFileRead
      (BDRHandle hBDRFile, byte *pBuffer, unsigned long cbBuffer, unsigned long *cbUsed)
{
   HRESULT       rc;
   SCODE         sc;
   FDP           pFile = (FDP)hBDRFile;
   DOCHEADER     header;
   DWORD         iSection;
   ULONG         cbRead;
   BOOL          addedToBuffer;
   LARGE_INTEGER filePos;

   *cbUsed = 0;

   pFile->cbBufferSize = cbBuffer;
   pFile->pBufferData  = pBuffer;
   pFile->cbBufferUsed = 0;

   if (pFile->ctSections == 0) {
      rc = pFile->pBinderStream->lpVtbl->Read
          (pFile->pBinderStream, &header, sizeof(header), &cbRead);

      if ((sc = GetScode(rc)) != S_OK)
         return (rc);

	  //Office97.132180 Version # has changed to 8
      if (SwapDWord(header.m_narrAppVersionNo[0]) < APPMAJORVERSIONNO)
         return (FILTER_E_UNKNOWNFORMAT);

      // Seek past stuff we don't need
      LISet32(filePos, (LONG) (SwapDWord(header.m_dwLength) - sizeof(DOCHEADER) ));
      rc = pFile->pBinderStream->lpVtbl->Seek
          (pFile->pBinderStream, filePos, STREAM_SEEK_CUR, NULL);

      if ((sc = GetScode(rc)) != S_OK)
         return (rc);

      pFile->ctSections = SwapDWord(header.m_cSections);
      pFile->iSection = 0;
   }
   else {
      LISet32(filePos, (LONG) pFile->sectionPos.LowPart);

      rc = pFile->pBinderStream->lpVtbl->Seek
          (pFile->pBinderStream, filePos, STREAM_SEEK_SET, NULL);

      if ((sc = GetScode(rc)) != S_OK)
         return (rc);
   }

   addedToBuffer = TRUE;
   for (iSection = pFile->iSection; iSection < pFile->ctSections; iSection++)
   {
      rc = LoadSectionName(pFile, &addedToBuffer);
      if ((sc = GetScode(rc)) != S_OK)
         return (rc);

      if (addedToBuffer == FALSE)
         break;
   }

   *cbUsed = pFile->cbBufferUsed;
   pFile->iSection = iSection;

   if (addedToBuffer == FALSE)
      return ((HRESULT)0);
   else
      return (FILTER_S_LAST_TEXT);
}

#endif // !VIEWER

/* end BDSTREAM.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmuqstd.h ===
/*
** File: QSTD.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:  This header file defines a standard "C" environment of types
**         and macros.
**
** Edit History:
**  07/13/91  kmh  General cleanup
**  05/15/91  kmh  First Release
*/


/* INCLUDE TESTS */
#define QSTD_H
#ifdef _WIN64
#include <windows.h>
#include <strAlign.h>
#endif


/* DEFINITIONS */

#if (_MSC_VER >= 700) && !defined MS_NO_CRT
#define stricmp      _stricmp
#define strnicmp     _strnicmp
#define itoa         _itoa
#define ltoa         _ltoa
#define intdos       _intdos
#define intdosx      _intdosx
#define fcvt         _fcvt
#define ecvt         _ecvt
#define REGS         _REGS
#define SREGS        _SREGS
#define dieeetomsbin _dieeetomsbin
#define dmsbintoieee _dmsbintoieee
#define fieeetomsbin _fieeetomsbin
#define fmsbintoieee _fmsbintoieee
#endif

typedef unsigned char byte;

#define uns    unsigned
#define HNULL  0

#define TRUE   1
#define FALSE  0

#ifdef WIN32
   #define MAXPATH     260
   #define MAXDRIVE      8
   #define MAXDIR      255
   #define MAXFILE     255
   #define MAXEXT      255
   #define MAXFILE_EXT 255
#else
   #define MAXPATH      64
   #define MAXDRIVE      2
   #define MAXDIR       64
   #define MAXFILE       8
   #define MAXEXT        4
   #define MAXFILE_EXT  12
   #define ULONG  unsigned long
#endif

#define DOS_MAXFILE      8
#define DOS_MAXEXT       3

#define EOS '\0'


/* Used to comment-out sections of code (no nested comments) */
#define COMMENTOUT 0


/* Preprocessor convieniences
** Use BEGDEF and ENDDEF to bracket macro expansions which must be
** usable as statements.
*/
#define BEGDEF do{
#define ENDDEF }while(0)


/* Extensions to "C" */

#define forever   for(;;)
#define forward   extern

#if !defined(max)
#define max(a,b)  (((a) > (b)) ? (a) : (b))
#endif

#if !defined(min)
#define min(a,b)  (((a) < (b)) ? (a) : (b))
#endif

//KYLEP
//#if !defined(abs)
//#define abs(x) (((x) < 0) ? -(x) : (x))
//#endif

/*
** public
** Use "public" for procedures and data which are public, i.e. defined
** in a .h file.  For public data it's required (as a comment); for
** procedures it's optional.
**
** private
** Use "private" for procedures or data which are local to a module.
** Private is equivalent to static, but static is used only for static
** variables within a procedure.
*/

#ifndef __cplusplus

   #define private
   #define public

#else

   #define private
   #define modulePrivate static
   #define modulePublic

#endif

#ifdef AQTDEBUG
   #include <assert.h>
   #define ASSERTION(x) assert(x)
#else
   #define ASSERTION(x)
#endif

#ifdef WIN32
   #define __far
   #define __huge
#endif

#ifdef DBCS
   #define IncCharPtr(p) (p += (IsDBCSLeadByte(*p) + 1))
#else
   #define IncCharPtr(p)  p++;
#endif

#ifdef DBCS
   #define CopyChar(pDest,pSource)  \
      if (IsDBCSLeadByte(*pSource)) \
      {                             \
         *pDest++ = *pSource;       \
         *pDest++ = *(pSource + 1); \
      }                             \
      else {                        \
         *pDest++ = *pSource;       \
      }
#else
   #define CopyChar(pDest,pSource)  \
      *pDest++ = *pSource;
#endif

#ifdef UNICODE
#ifdef _WIN64
   #define STRLEN     ua_wcslen
#else
   #define STRLEN     wcslen
#endif // !WIN64
   #define STRCPY     wcscpy
   #define STRCMP     wcscmp
#else
   #define STRLEN     strlen
   #define STRCPY     strcpy
   #define STRCMP     strcmp
#endif

/* end QSTD.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmwinutl.h ===
/*
** File: WINUTIL.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  05/15/91  kmh  First Release
*/

#if !VIEWER

/* INCLUDE TESTS */
#define WINUTIL_H


/* DEFINITIONS */

#ifndef WIN32
#define NOSOUND
#define NOCOMM
#define NODRIVERS
#define NOMINMAX
#define NOLOGERROR
#define NOPROFILER
#define NOLFILEIO
#define NOOPENFILE
#define NORESOURCE
#define NOATOM
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#define NODRAWTEXT
#define NOSCALABLEFONT
#define NORASTEROPS
#define NOSYSTEMPARAMSINFO
#define NOMSG
#define NOWINSTYLES
#define NOWINOFFSETS
#define NOSHOWWINDOW
#define NODEFERWINDOWPOS
#define NOVIRTUALKEYCODES
#define NOKEYSTATES
#define NOWH
#define NOMENUS
#define NOSCROLL
#define NOICONS
#define NOMB
#define NOSYSCOMMANDS
#define NOMDI
#define NOCTLMGR
#define NOWINMESSAGES
#define NOHELP
#else
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef __cplusplus
   extern "C" {
#endif

/*
**-----------------------------------------------------------------------------
** WINUTIL.C
**
** Various utility functions
**-----------------------------------------------------------------------------
*/

#ifdef UNUSED

// Setup for reading from a resouce string table
extern void ReadyStringTable (HINSTANCE hInstance);

// Read a string from the resource string table
extern int ReadStringTableEntry (int id, TCHAR __far *buffer, int cbBuffer);

// Read a string from the [appName] section in the named ini file 
extern int ReadProfileParameter
      (TCHAR __far *iniFilename, TCHAR __far *appName, TCHAR __far *keyname,
       TCHAR __far *value, int nSize);

// Return the task handle of the current task
extern DWORD CurrentTaskHandle (void);

// Create character set translation tables
extern char __far *MakeCharacterTranslateTable (int tableType);

#define OEM_TO_ANSI  0
#define ANSI_TO_OEM  1

// Pass to strcpyn the true length of the dest buffer.  At most (count-1)
// characters are copied from the source to the dest.  This allows
// the dest to allways be terminated with an EOS.  If less than the
// full length of source was copied to dest FALSE is returned - TRUE
// otherwise.
extern BOOL strcpyn (char __far *pDest, char __far *pSource, int count);

#endif	// UNUSED

/*
**-----------------------------------------------------------------------------
** WINALLOC.C
**
** Heap management
**-----------------------------------------------------------------------------
*/
// Allocate some space on the OS global heap
extern void __far *AllocateSpace (unsigned int byteCount, HGLOBAL __far *loc);

// Resize a memory block on the OS global heap
extern void __far *ReAllocateSpace
      (unsigned int byteCount, HGLOBAL __far *loc, BOOL __far *status);

// Reclaim the space for a node on the OS Windows heap
extern void FreeSpace (HGLOBAL loc);

// Allocate some space on the Windows global heap
extern void __huge *AllocateHugeSpace
      (unsigned long byteCount, HGLOBAL __far *loc);

// Resize a huge memory block on the OS global heap
extern void __huge *ReAllocateHugeSpace
      (unsigned long byteCount, HGLOBAL __far *loc, BOOL __far *status);

#ifndef HEAP_CHECK

   extern void __far *MemAllocate (void * pGlobals, int cbData);

#else

#error Hey who defines HEAP_CHECK?

   extern void __far *DebugMemAllocate (int cbData, char __far *file, int line);
   #define MemAllocate(x) DebugMemAllocate(x,__FILE__,__LINE__)

   extern BOOL MemVerifyFreeList (void);

#endif

// Change the space of a node in the heap
extern void __far *MemReAllocate (void * pGlobals, void __far *pExistingData, int cbNewSize);

// Allocate some space on the suballocator heap
extern void MemFree (void * pGlobals, void __far *pDataToFree);

// Free all pages allocated for the suballocator heap
extern void MemFreeAllPages (void * pGlobals);

// Mark all unmarked pages with the supplied id.  Set free list to NULL
extern void MemMarkPages (void * pGlobals, int id);

// Free all pages marked with the given id.  Set free list to NULL
extern void MemFreePages (void * pGlobals, int id);

#define MEM_TEMP_PAGE_ID  0

/*
**-----------------------------------------------------------------------------
** WINXLATE.C
**
** ANSI <-> OEM translation services
**-----------------------------------------------------------------------------
*/

#ifdef UNUSED

// OEM -> ANSI
extern void strOEMtoANSI (char __far *source, char __far *dest, unsigned int ctBytes);
extern void szOEMtoANSI  (char __far *buffer);
extern void ctOEMtoANSI  (char __far *buffer, unsigned int ctBytes);

// ANSI -> OEM
extern void strANSItoOEM (char __far *source, char __far *dest, unsigned int ctBytes);
extern void szANSItoOEM  (char __far *buffer);
extern void ctANSItoOEM  (char __far *buffer, unsigned int ctBytes);

// Construct the OEM-to-ANSI and ANSI-to-OEM translation tables
extern void BuildCharacterTranslateTables (int dataCodePage);
extern void FreeCharacterTranslateTables (void);

#define DATA_OEM  0
#define DATA_ANSI 1

#endif	// UNUSED

#ifdef __cplusplus
   }
#endif

#endif // !VIEWER
/* end WINUTIL.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmwindos.h ===
/*
** File: WINDOS.H
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:  OS services
**
** Edit History:
**  05/15/91  kmh  First release
*/

#if !VIEWER

/* INCLUDE TESTS */
#define WINDOS_H


/* DEFINITIONS */

#ifdef WIN32
   typedef HANDLE FILE_CHANNEL;
#else
   typedef int FILE_CHANNEL;
#endif

#define DOS_CREATION_TIME    0
#define DOS_LAST_ACCESS_TIME 1
#define DOS_LAST_WRITE_TIME  2

/* Return the date and time of a file as recorded in the DOS directory */
extern BOOL DOSFileDateTime
               (TCHAR __far *szFileName, int iType,
                int __far *year, int __far *month, int __far *day,
                int __far *hour, int __far *minute, int __far *second);

/* Return the date and time of a file as recorded in the DOS directory */
extern BOOL DOSChannelDateTime
               (FILE_CHANNEL channel, int iType,
                int __far *year, int __far *month, int __far *day,
                int __far *hour, int __far *minute, int __far *second);

/* See if a pathname locates a file */
extern int DOSFileExists (TCHAR __far *pathname);

/* Create a file */
extern int DOSCreateFile (TCHAR __far *pathname, FILE_CHANNEL __far *channel);

/* Open a file */
extern int DOSOpenFile (TCHAR __far *pathname, int access, FILE_CHANNEL __far *channel);

#define DOS_RDONLY      0x0000
#define DOS_WRONLY      0x0001
#define DOS_RDWR        0x0002
#define DOS_NOT_RDONLY  (DOS_WRONLY | DOS_RDWR)

#define DOS_SH_COMPAT   0x0000
#define DOS_SH_DENYRW   0x0010
#define DOS_SH_DENYWR   0x0020
#define DOS_SH_DENYRD   0x0030
#define DOS_SH_DENYNONE 0x0040


/* Close a file */
extern int DOSCloseFile (FILE_CHANNEL handle);

/* Read from a file */
extern uns DOSReadFile (FILE_CHANNEL handle, byte __far *buffer, uns bytesToRead);

/* Write to a file */
extern uns DOSWriteFile (FILE_CHANNEL handle, byte __far *buffer, uns bytesToWrite);

#define RW_ERROR 0xffff

/* Return the file pointer */
extern int DOSGetFilePosition (FILE_CHANNEL handle, long __far *fileOffset);

/* Set the file pointer */
extern int DOSSetFilePosition (FILE_CHANNEL handle, int fromWhere, long fileOffset);

#define FROM_START   0
#define FROM_CURRENT 1
#define FROM_END     2

/*
** DOSOpenFile and DOSCreateFile error status
*/
#define DOS_ERROR_FILE_NOT_FOUND      -2
#define DOS_ERROR_PATH_NOT_FOUND      -3
#define DOS_ERROR_TOO_MANY_OPEN_FILES -4
#define DOS_ERROR_ACCESS_DENIED       -5
#define DOS_ERROR_INVALID_ACCESS      -12

/*
** Split a pathname into its component parts
*/
extern void SplitPath
       (TCHAR __far *path,
        TCHAR __far *drive, unsigned int cchDriveMax,
        TCHAR __far *dir,   unsigned int cchDirMax,
        TCHAR __far *file,  unsigned int cchFileMax,
        TCHAR __far *ext,   unsigned int cchExtMax);

#endif // !VIEWER
/* end WINDOS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmwindos.c ===
/*
** File: WINDOS.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:  OS services
**
** Edit History:
**  05/15/91  kmh  First release
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <direct.h>

#ifndef WIN32
   #include <dos.h>
#endif

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwindos.h"
#else
   #include "qstd.h"
   #include "windos.h"
#endif

#ifdef UNICODE
// Windows 95 is essentially broken when it comes to Unicode.  We need to work
// around this.
#if (defined FILTER_LIB || !defined FILTER)
BOOL g_fUseWideAPIs;

void SetGlobalWideFlag()
        {
        // NT or Windows 95?
        OSVERSIONINFOA  osv; //force Ansi for Win 95
        GetVersionExA(&osv);

        // Can only use Wide APIs on Win NT
        g_fUseWideAPIs = (osv.dwPlatformId == VER_PLATFORM_WIN32_NT);
        }
#else
extern BOOL g_fUseWideAPIs;
#endif

static HANDLE CreateFileWrapper(
        LPCWSTR  lpFileName,
        DWORD  dwDesiredAccess,
        DWORD  dwShareMode,
        LPSECURITY_ATTRIBUTES  lpSecurityAttributes,
        DWORD  dwCreationDistribution,
        DWORD  dwFlagsAndAttributes,
        HANDLE  hTemplateFile)
        {
        if (!g_fUseWideAPIs)
                {
                char szAnsiName[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, lpFileName, wcslen(lpFileName)+1,
                        szAnsiName, MAX_PATH, NULL, NULL);
                return CreateFileA(szAnsiName, dwDesiredAccess, dwShareMode,
                                        lpSecurityAttributes, dwCreationDistribution,
                                        dwFlagsAndAttributes, hTemplateFile);
                }
        else
                {
                return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode,
                                        lpSecurityAttributes, dwCreationDistribution,
                                        dwFlagsAndAttributes, hTemplateFile);
                }
        }

#else
#define CreateFileWrapper CreateFile
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */

/* MODULE DATA, TYPES AND MACROS  */

#ifndef WIN32
static union  REGS  inregs, outregs;
static struct SREGS segregs;

#define DOS_GET_DEFAULT_DRIVE    0x19
#define DOS_SET_DTA              0x1a
#define DOS_GET_TIME             0x2c
#define DOS_GET_DTA              0x2f
#define DOS_CREATE_DIR           0x39
#define DOS_CHANGE_DIR           0x3b
#define DOS_CREATE_FILE          0x3c
#define DOS_FILE_OPEN            0x3d
#define DOS_FILE_CLOSE           0x3e
#define DOS_FILE_READ            0x3f
#define DOS_FILE_WRITE           0x40
#define DOS_FILE_DELETE          0x41
#define DOS_MOVE_FILE_POINTER    0x42
#define DOS_FILE_ATTRIBUTES      0x43
#define DOS_GET_CURRENT_DIR      0x47
#define DOS_FIND_FIRST           0x4e
#define DOS_FIND_NEXT            0x4f
#define DOS_FILE_RENAME          0x56
#define DOS_FILE_DATE_TIME       0x57
#define DOS_LOCK_FILE            0x5c

#define OPEN_SHARE_COMPATIBILITY 0x40
#define ATTR_NORMAL              0x00

#define GET_DATE_TIME            0x00  /* DOS_FILE_DATE_TIME sub-functions */
#define SET_DATE_TIME            0x01

#define LOCK_IT                  0x00  /* DOS_LOCK_FILE sub-functions */
#define UNLOCK_IT                0x01
#endif

/* IMPLEMENTATION */

/* Return the date and time of a file as recorded in the directory */
public BOOL DOSChannelDateTime
               (FILE_CHANNEL channel, int iType,
                int __far *year, int __far *month, int __far *day,
                int __far *hour, int __far *minute, int __far *second)
{
   WORD time, date;

#ifdef WIN32
   FILETIME theTime;
   BOOL rc;

   if (iType == DOS_CREATION_TIME)
      rc = GetFileTime(channel, &theTime, NULL, NULL);
   else if (iType == DOS_LAST_ACCESS_TIME)
      rc = GetFileTime(channel, NULL, &theTime, NULL);
   else
      rc = GetFileTime(channel, NULL, NULL, &theTime);

   if (rc == FALSE)
      return (FALSE);

   FileTimeToLocalFileTime (&theTime, &theTime);

   if (FileTimeToDosDateTime(&theTime, &date, &time) == FALSE)
      return (FALSE);

#else
   memset (&inregs, 0, sizeof(inregs));

   inregs.h.ah = DOS_FILE_DATE_TIME;
   inregs.h.al = GET_DATE_TIME;
   inregs.x.bx = channel;

   intdos(&inregs, &outregs);
   if (outregs.x.cflag == 1)
      return (FALSE);

   time = outregs.x.cx;
   date = outregs.x.dx;
#endif

   *year  = date / 512 + 1980;   date = date % 512;
   *month = date / 32;
   *day   = date % 32;

   *hour   = time / 2048;        time = time % 2048;
   *minute = time / 32;
   *second = time % 32;

   return (TRUE);
}


/* Return the date and time of a file as recorded in the DOS directory */
public BOOL DOSFileDateTime
               (TCHAR __far *szFileName, int iType,
                int __far *year, int __far *month, int __far *day,
                int __far *hour, int __far *minute, int __far *second)
{
   BOOL  rc;
   FILE_CHANNEL channel;

   if (DOSOpenFile(szFileName, DOS_RDONLY | DOS_SH_DENYNONE, &channel) != 0)
      return (FALSE);

   rc = DOSChannelDateTime(channel, iType, year, month, day, hour, minute, second);

   DOSCloseFile (channel);
   return (rc);
}

/* See if a pathname locates a file */
public int DOSFileExists (TCHAR __far *pathname)
{
#ifdef WIN32
   if (GetFileAttributes(pathname) != 0xFFFFFFFF)
      return (0);

   return (-((int)GetLastError() & 0x0000FFFF));

#else
   memset (&inregs, 0, sizeof(inregs));
   memset (&segregs, 0, sizeof(segregs));

   inregs.h.ah = DOS_FILE_ATTRIBUTES;
   inregs.h.al = ATTR_NORMAL;
   inregs.x.dx = FP_OFF(pathname);
   segregs.ds  = FP_SEG(pathname);

   intdosx(&inregs, &outregs, &segregs);
   if (outregs.x.cflag == 1)
      return (-(int)outregs.x.ax);
   else
      return (0);
#endif
}


/* Return the pathname to the current directory */
public void DOSGetCurrentDirectory (TCHAR __far *dirPath, int drive)
{
#ifdef WIN32
   GetCurrentDirectory (MAXPATH, dirPath);
#else
   _getdcwd(drive, dirPath, MAXPATH);
#endif
}


/* Create a file */
public int DOSCreateFile (TCHAR __far *pathname, FILE_CHANNEL __far *channel)
{
#ifdef WIN32
   *channel = CreateFileWrapper
      (pathname, (GENERIC_READ | GENERIC_WRITE), 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, HNULL);

   if (*channel != INVALID_HANDLE_VALUE)
      return (0);

   return (-((int)GetLastError() & 0x0000FFFF));

#else
   memset (&inregs, 0, sizeof(inregs));
   memset (&segregs, 0, sizeof(segregs));

   inregs.h.ah = DOS_CREATE_FILE;
   inregs.x.cx = ATTR_NORMAL;
   inregs.x.dx = FP_OFF(pathname);
   segregs.ds  = FP_SEG(pathname);

   intdosx(&inregs, &outregs, &segregs);
   if (outregs.x.cflag == 1)
      return (-(int)outregs.x.ax);

   *channel = outregs.x.ax;
   return (0);
#endif
}

/* Open a file */
public int DOSOpenFile (TCHAR __far *pathname, int access, FILE_CHANNEL __far *channel)
{
#ifdef WIN32
   DWORD fileAccess, fileShare;

   if (access & DOS_RDWR)
      fileAccess = GENERIC_READ | GENERIC_WRITE;
   else if (access & DOS_WRONLY)
      fileAccess = GENERIC_WRITE;
   else
      fileAccess = GENERIC_READ;

   if (access & DOS_SH_DENYRW)
      fileShare = 0;
   else if (access & DOS_SH_DENYWR)
      fileShare = FILE_SHARE_READ;
   else if (access & DOS_SH_DENYRD)
      fileShare = FILE_SHARE_WRITE;
   else
      fileShare = FILE_SHARE_READ | FILE_SHARE_WRITE;

   *channel = CreateFileWrapper
      (pathname, fileAccess, fileShare, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, HNULL);

   if (*channel != INVALID_HANDLE_VALUE)
      return (0);

   return (-((int)GetLastError() & 0x0000FFFF));

#else
   memset (&inregs, 0, sizeof(inregs));
   memset (&segregs, 0, sizeof(segregs));

   inregs.h.ah = DOS_FILE_OPEN;
   inregs.h.al = (unsigned char)access;
   inregs.x.dx = FP_OFF(pathname);
   segregs.ds  = FP_SEG(pathname);

   intdosx(&inregs, &outregs, &segregs);
   if (outregs.x.cflag == 1)
      return (-(int)outregs.x.ax);

   *channel = outregs.x.ax;
   return (0);
#endif
}

/* Close a file */
public int DOSCloseFile (FILE_CHANNEL handle)
{
#ifdef WIN32
   if (CloseHandle(handle) == TRUE)
      return (0);
   else
      return (-1);
#else
   memset (&inregs, 0, sizeof(inregs));

   inregs.h.ah = DOS_FILE_CLOSE;
   inregs.x.bx = handle;

   intdos(&inregs, &outregs);
   if (outregs.x.cflag == 1)
      return (-1);
   else
      return (0);
#endif
}

/* Read from a file */
public uns DOSReadFile (FILE_CHANNEL handle, byte __far *buffer, uns bytesToRead)
{
#ifdef WIN32
   DWORD bytesRead;

   if (ReadFile(handle, buffer, bytesToRead, &bytesRead, NULL) == FALSE)
      return (RW_ERROR);
   else
      return ((uns)bytesRead);
#else
   memset (&inregs, 0, sizeof(inregs));
   memset (&segregs, 0, sizeof(segregs));

   inregs.h.ah = DOS_FILE_READ;
   inregs.x.bx = handle;
   inregs.x.cx = bytesToRead;
   segregs.ds  = FP_SEG(buffer);
   inregs.x.dx = FP_OFF(buffer);

   intdosx(&inregs, &outregs, &segregs);
   if (outregs.x.cflag == 1)
      return (RW_ERROR);
   else
      return (outregs.x.ax);
#endif
}

/* Write to a file */
public uns DOSWriteFile (FILE_CHANNEL handle, byte __far *buffer, uns bytesToWrite)
{
#ifdef WIN32
   uns  bytesWritten;

   if (WriteFile(handle, buffer, bytesToWrite, &bytesWritten, NULL) == FALSE)
      return (RW_ERROR);
   else
      return (bytesWritten);
#else
   memset (&inregs, 0, sizeof(inregs));
   memset (&segregs, 0, sizeof(segregs));

   inregs.h.ah = DOS_FILE_WRITE;
   inregs.x.bx = handle;
   inregs.x.cx = bytesToWrite;
   segregs.ds  = FP_SEG(buffer);
   inregs.x.dx = FP_OFF(buffer);

   intdosx(&inregs, &outregs, &segregs);
   if (outregs.x.cflag == 1)
      return (RW_ERROR);
   else
      return (outregs.x.ax);
#endif
}


/* Return the file pointer */
public int DOSGetFilePosition (FILE_CHANNEL handle, long __far *fileOffset)
{
#ifdef WIN32
   DWORD pos;

   if ((pos = SetFilePointer(handle, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
      return (-1);

   *fileOffset = pos;
   return (0);
#else
   memset (&inregs, 0, sizeof(inregs));

   inregs.h.ah = DOS_MOVE_FILE_POINTER;
   inregs.h.al = FROM_CURRENT;
   inregs.x.bx = handle;
   inregs.x.cx = 0;
   inregs.x.dx = 0;

   intdos(&inregs, &outregs);

   if (outregs.x.cflag == 1)
      return (-1);

   *fileOffset = (long)(((unsigned long)(outregs.x.dx) << 16) +
                         (unsigned long)(outregs.x.ax));
   return (0);
#endif
}

/* Set the file pointer */
public int DOSSetFilePosition (FILE_CHANNEL handle, int fromWhere, long fileOffset)
{
#ifdef WIN32
   if (SetFilePointer(handle, fileOffset, NULL, fromWhere) == 0xFFFFFFFF)
      return (-1);

   return (0);
#else
   memset (&inregs, 0, sizeof(inregs));

   inregs.h.ah = DOS_MOVE_FILE_POINTER;
   inregs.h.al = (unsigned char)fromWhere;
   inregs.x.bx = handle;
   inregs.x.cx = (unsigned int)(fileOffset >> 16);
   inregs.x.dx = (unsigned int)(fileOffset & 0x0000ffff);

   intdos(&inregs, &outregs);

   if (outregs.x.cflag == 1)
      return (-1);
   else
      return (0);
#endif
}

#endif // !VIEWER

/* end WINDOS.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\drm.h ===
/*
** File: DRM.H
**
** Copyright (C) Microsoft Corporation, 1994.  All rights reserved.
**
** Notes:
**
** Edit History:
**  04/08/02  sundara   created
*/

#define DRMSTREAMNAME      L"DRMDATA"

inline HRESULT CheckIfDRM( IStorage * pStg )
{
    IStream * pStm = 0;
    HRESULT hr = pStg->OpenStream( DRMSTREAMNAME,
                                   0,
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pStm );

    // If we found the stream, assume the file is DRM protected

    if ( SUCCEEDED( hr ) )
    {
        pStm->Release();

        return FILTER_E_UNKNOWNFORMAT;
    }

    // If some failure other than that we couldn't find the stream occurred,
    // return that error code.

    if ( STG_E_FILENOTFOUND != hr )
        return hr;

    return S_OK;
} //CheckIfDRM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmwinutl.c ===
/*
** File: WINUTIL.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:
**
** Edit History:
**  05/15/91  kmh  First Release
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
#else
   #include "qstd.h"
   #include "winutil.h"
#endif

#ifdef DBCS
   #include "dbcs.h"
#endif


/* FORWARD DECLARATIONS OF PROCEDURES */


#ifdef UNUSED

/* MODULE DATA, TYPES AND MACROS  */

static HINSTANCE StringTableInstance;


/* IMPLEMENTATION */

/* Setup for reading from a resouce string table */
public void ReadyStringTable (HINSTANCE hInstance)
{
   StringTableInstance = hInstance;
}

/* Read a string from the resource string table */
public int ReadStringTableEntry (int id, TCHAR __far *buffer, int cbBuffer)
{
   int  rc;

   rc = LoadString(StringTableInstance, id, buffer, cbBuffer);
   return (rc);
}

/* Read a string from the [appName] section in the named ini file */
public int ReadProfileParameter
          (TCHAR __far *iniFilename, TCHAR __far *appName, TCHAR __far *keyname,
           TCHAR __far *value, int nSize)
{
   TCHAR defaultValue[1];
   int  rc;

   defaultValue[0] = EOS;
   *value = EOS;

   if (iniFilename == NULL)
      rc = GetProfileString(appName, keyname, defaultValue, value, nSize);
   else
      rc = GetPrivateProfileString(appName, keyname, defaultValue, value, nSize, iniFilename);

   return (rc);
}

/* Return the task handle of the current task */
public DWORD CurrentTaskHandle (void)
{
   #ifdef WIN32
      return (GetCurrentProcessId());
   #else
      return ((DWORD)GetCurrentTask());
   #endif
}

/* Create character set translation tables */
public char __far *MakeCharacterTranslateTable (int tableType)
{
   int  i;
   byte __far *p;
   byte __far *pSourceTable;
   byte __far *pResultTable;

   pSourceTable = MemAllocate(256);
   pResultTable = MemAllocate(256);

   for (p = pSourceTable, i = 1; i < 256; i++)
      *p++ = (byte)i;

   *p = EOS;

   if (tableType == OEM_TO_ANSI)
      OemToAnsi (pSourceTable, pResultTable + 1);
   else
      AnsiToOem (pSourceTable, pResultTable + 1);

   MemFree (pSourceTable);
   return (pResultTable);
}

#endif	// UNUSED

#ifdef HEAP_CHECK
#error Hey who defines HEAP_CHECK?
// strcpyn is only called by MemAddToAllocateList (dmwnaloc.c)
//   it's under HEAP_CHECK, which is never turned on.
public BOOL strcpyn (char __far *pDest, char __far *pSource, int count)
{
   byte __far *pd, __far *ps;
   int  i;

   pd = (byte __far *)pDest;
   ps = (byte __far *)pSource;

   for (i = 0; i < (count - 1); i++) {
      #ifdef DBCS
         if (IsDBCSLeadByte(*ps)) {
            if (i == count - 2)
               break;
            *pd++ = *ps++;
            *pd++ = *ps++;
            i++;
         }
         else {
            if ((*pd++ = *ps++) == EOS)
               return (TRUE);
         }
      #else
         if ((*pd++ = *ps++) == EOS)
            return (TRUE);
      #endif
   }
   *pd = EOS;
   return ((*ps == EOS) ? TRUE : FALSE);
}
#endif

public void SplitPath
       (TCHAR __far *path,
        TCHAR __far *drive, unsigned int cchDriveMax, TCHAR __far *dir, unsigned int cchDirMax,
        TCHAR __far *file,  unsigned int cchFileMax,  TCHAR __far *ext, unsigned int cchExtMax)
{
   TCHAR __far *pPath;
   TCHAR __far *pFile;
   TCHAR __far *pFileStart;
   TCHAR        firstSep;
   TCHAR __far *pDriveBuffer = drive;
   TCHAR __far *pDirBuffer   = dir;
   TCHAR __far *pFileBuffer  = file;
   TCHAR __far *pExtBuffer   = ext;

   #define COLON     ':'
   #define BACKSLASH '\\'
   #define DOT       '.'

   #define CopyToDest(dest, source, cchDestRemain) \
      if (cchDestRemain > 0) {                     \
         *dest++ = *source;                        \
         cchDestRemain--;                          \
      }

   if (drive != NULL) *drive = EOS;
   if (dir   != NULL) *dir   = EOS;
   if (file  != NULL) *file  = EOS;
   if (ext   != NULL) *ext   = EOS;

   if ((path == NULL) || (*path == EOS))
     return;

   /*
   ** Locate filename - starts after the last seperator character.
   ** Also remember the first seperator encountered.  That tells if
   ** there is a drive specifier.
   */
   pPath = path;
   pFile = NULL;
   firstSep = EOS;
   while (*pPath != EOS) {
      if ((*pPath == BACKSLASH) || (*pPath == COLON)) {
         if (firstSep == EOS)
            firstSep = *pPath;
         pFile = pPath + 1;
      }
      IncCharPtr (pPath);
   }

   // No seperators in the path?  Then it is just a filename
   if (pFile == NULL)
      pFile = path;

   pFileStart = pFile;

   // Copy filename
   while ((*pFile != EOS) && (*pFile != DOT)) {
      CopyToDest (file, pFile, cchFileMax);
      #ifdef DBCS
         if (IsDBCSLeadByte(*pFile)) {
            pFile++;
            CopyToDest (file, pFile, cchFileMax);
         }
      #endif
      pFile++;
   }
   if (file != NULL) {
      #ifdef DBCS
         if (!FIsAlignLsz(pFileBuffer,file))
            file--;
      #endif
      *file = EOS;
   }

   // Copy Extension
   while ((*pFile != EOS)) {
      CopyToDest (ext, pFile, cchExtMax);
      #ifdef DBCS
         if (IsDBCSLeadByte(*pFile)) {
            pFile++;
            CopyToDest (ext, pFile, cchExtMax);
         }
      #endif
      pFile++;
   }
   if (ext != NULL) {
      #ifdef DBCS
         if (!FIsAlignLsz(pExtBuffer,ext))
            ext--;
      #endif
      *ext = EOS;
   }

   /*
   ** Copy drive if one is present
   */
   pPath = path;
   if (firstSep == COLON) {
      while (*pPath != COLON) {
         CopyToDest (drive, pPath, cchDriveMax);
         #ifdef DBCS
            if (IsDBCSLeadByte(*pPath)) {
               pPath++;
               CopyToDest (drive, pPath, cchDriveMax);
            }
         #endif
         pPath++;
      }
      if (drive != NULL) {
         #ifdef DBCS
            if (!FIsAlignLsz(pDriveBuffer,drive))
               drive--;
         #endif

         if (cchDriveMax > 0)
            *drive++ = *pPath;  // Copy COLON

         pPath++;
         *drive = EOS;
      }
   }

   /*
   ** Directory goes from pPath .. pFileStart - 1
   */
   while (pPath < pFileStart) {
      CopyToDest (dir, pPath, cchDirMax);
      #ifdef DBCS
         if (IsDBCSLeadByte(*pPath)) {
            pPath++;
            CopyToDest (dir, pPath, cchDirMax);
         }
      #endif
      pPath++;
   }
   if (dir != NULL) {
      #ifdef DBCS
         if (!FIsAlignLsz(pDirBuffer,dir))
            dir--;
      #endif
      *dir = EOS;
   }
}

#endif // !VIEWER

/* end WINUTIL.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\dmwnaloc.c ===
/*
** File: WINALLOC.C
**
** Copyright (C) Advanced Quonset Technology, 1993-1995.  All rights reserved.
**
** Notes:  Heap management
**
** Edit History:
**  09/20/91  kmh  Created.
*/

#if !VIEWER

/* INCLUDES */

#ifdef MS_NO_CRT
#include "nocrt.h"
#endif

#include <string.h>
#include <windows.h>

#ifdef FILTER
   #include "dmuqstd.h"
   #include "dmwinutl.h"
#else
   #include "qstd.h"
   #include "winutil.h"
#endif

#ifdef HEAP_CHECK
#error Hey who defines HEAP_CHECK?
#include "trace.h"
#endif

/* FORWARD DECLARATIONS OF PROCEDURES */


/* MODULE DATA, TYPES AND MACROS  */

#ifdef HEAP_CHECK
   #define FILL_VALUE       0
   #define EMPTY_VALUE      0xBB

   #define IN_USE_SIGNATURE 0x0a0a
   #define FREE_SIGNATURE   0x0707

   /*
   ** At each allocation and release the free list can be examined for integrity.
   ** This can be a very time expensive operation and is not enabled by
   ** HEAP_CHECK
   */
   //#define VERIFY_FREE_LIST

   public int MemHeapCheck = 1;
   public int MemReleasedPagesCount = 0;
   public int MemMarkedPagesCount = 0;
   public int MemCTAllocate = 0;

   #define DEBUG_INFO_LEN 32
   typedef struct FreeNode {
      int     size;
      int     signature;
      char    file[DEBUG_INFO_LEN];
      int     line;
      struct  FreeNode __far *MLnext;
      HGLOBAL filler;
      struct  FreeNode __far *next;
   } FreeNode;

   typedef FreeNode __far *FNP;

   static FNP MemAllocateList = NULL;

   typedef struct {
      int     size;
      int     signature;
      char    file[DEBUG_INFO_LEN];
      int     line;
      struct  FreeNode __far *MLnext;
      HGLOBAL location;
   } GlobalHeapNode;

   typedef GlobalHeapNode __far *GHP;

#else

   #define FILL_VALUE  0

   typedef struct FreeNode {
      int     size;
      struct  FreeNode __far *next;
   } FreeNode;

   typedef FreeNode __far *FNP;

   typedef struct {
      HGLOBAL location;
      int     size;
   } GlobalHeapNode;

   typedef GlobalHeapNode __far *GHP;

#endif


typedef struct PageNode {
   HGLOBAL  location;
   int      id;
   struct   PageNode __far *next;
   struct   PageNode __far *prev;
} PageNode;

typedef PageNode __far *PNP;


typedef struct {
   PageNode  PN;
   FreeNode  FN;
} PageHeader;

typedef PageHeader __far *PHP;


//static FNP MemFreeList = NULL;
void * GetMemFreeList(void * pGlobals);
void SetMemFreeList(void * pGlobals, void * pList);

//static PNP MemPageList = NULL;
void *  GetMemPageList(void * pGlobals);
void SetMemPageList(void * pGlobals, void * pList);


#define MEM_PAGE_SIZE       8192
#define MEM_ALLOC_EXTRA     (sizeof(FreeNode) - sizeof(FNP))
#define MEM_MIN_ALLOC       sizeof(FreeNode)
#define MEM_MAX_ALLOC       (MEM_PAGE_SIZE - (sizeof(PageNode) + MEM_ALLOC_EXTRA))
#define MEM_EMPTY_PAGE_SIZE (MEM_PAGE_SIZE - sizeof(PageNode))

#define USE_GLOBAL_ALLOC(cbData) (cbData > MEM_MAX_ALLOC)

#define FREE_EMPTY_PAGES


/* IMPLEMENTATION */

/*
**-----------------------------------------------------------------------------
** Heap checking for debugging
**-----------------------------------------------------------------------------
*/
#ifdef HEAP_CHECK
public BOOL MemVerifyFreeList (void)
{
   FNP  pFree;
   byte __far *pData;
   int  i;

   pFree = (FNP)GetMemFreeList(pGlobals);
   while (pFree != NULL) {
      if ((pFree->signature != FREE_SIGNATURE) || (pFree->size <= 0))
         ASSERTION(FALSE);

      pData = (byte __far *)pFree + sizeof(FreeNode);
      for (i = 0; i < (int)(pFree->size - sizeof(FreeNode)); i++) {
         if (*pData++ != EMPTY_VALUE) {
            ASSERTION(FALSE);
            return (FALSE);
         }
      }
      pFree = pFree->next;
   }
   return (TRUE);
}

private void MemAddToAllocateList (FNP pNewNode, char __far *file, int line)
{
   strcpyn(pNewNode->file, file, DEBUG_INFO_LEN);
   pNewNode->line = line;
   pNewNode->MLnext = MemAllocateList;
   MemAllocateList = pNewNode;
}

private void MemRemoveFromAllocateList (FNP pNode)
{
   FNP pCurrentNode, pPreviousNode;

   pCurrentNode = MemAllocateList;
   pPreviousNode = NULL;

   while (pCurrentNode != NULL) {
      if (pCurrentNode == pNode)
         break;
      pPreviousNode = pCurrentNode;
      pCurrentNode = pCurrentNode->MLnext;
   }

   if (pCurrentNode != NULL) {
      if (pPreviousNode == NULL)
         MemAllocateList = pCurrentNode->MLnext;
      else
         pPreviousNode->MLnext = pCurrentNode->MLnext;
   }
}

private void DisplayAllocateList (void)
{
   FNP   pCurrentNode;
   char  s[128];

   pCurrentNode = MemAllocateList;
   while (pCurrentNode != NULL) {
      if (!USE_GLOBAL_ALLOC(pCurrentNode->size))
         wsprintfA (s, "Size = %d  From %s.%d", pCurrentNode->size, pCurrentNode->file, pCurrentNode->line);
      else {
         GHP pGlobalNode = (GHP)pCurrentNode;
         wsprintfA (s, "Global Alloc Size = %d  From %s.%d", pGlobalNode->size, pGlobalNode->file, pGlobalNode->line);
      }

      if (MessageBoxA(HNULL, s, "Unallocated memory", MB_OKCANCEL | MB_ICONEXCLAMATION) != IDOK)
         break;
      pCurrentNode = pCurrentNode->MLnext;
   }
}
#endif


/*
**-----------------------------------------------------------------------------
** OS heap services
**-----------------------------------------------------------------------------
*/

/* Allocate some space on the OS heap */
public void __far *AllocateSpace (unsigned int byteCount, HGLOBAL __far *loc)
{
   #define HEAP_ALLOC_FLAGS  (GMEM_MOVEABLE | GMEM_SHARE)

   if ((*loc = GlobalAlloc(HEAP_ALLOC_FLAGS, byteCount)) == HNULL)
      return (NULL);

   return (GlobalLock(*loc));
}

/* Expand a memory block on the heap */
public void __far *ReAllocateSpace
      (unsigned int byteCount, HGLOBAL __far *loc, BOOL __far *status)
{
   HGLOBAL  hExistingNode;

   #define HEAP_REALLOC_FLAGS  GMEM_MOVEABLE

   hExistingNode = *loc;
   GlobalUnlock (hExistingNode);

   if ((*loc = GlobalReAlloc(hExistingNode, byteCount, HEAP_REALLOC_FLAGS)) == HNULL) {
      *loc = hExistingNode;
      *status = FALSE;
      return (GlobalLock(hExistingNode));
   }

   *status = TRUE;
   return (GlobalLock(*loc));
}

/* Reclaim the space for a node on the heap */
public void FreeSpace (HGLOBAL loc)
{
   if (loc != HNULL) {
      GlobalUnlock (loc);
      GlobalFree (loc);
   }
}

/* Allocate some space on the heap */
public void __huge *AllocateHugeSpace (unsigned long byteCount, HGLOBAL __far *loc)
{
   #define HUGE_HEAP_ALLOC_FLAGS  (GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT)

   if ((*loc = GlobalAlloc(HUGE_HEAP_ALLOC_FLAGS, byteCount)) == HNULL)
      return (NULL);

   return (GlobalLock(*loc));
}

/* Expand a memory block on the heap */
public void __huge *ReAllocateHugeSpace
      (unsigned long byteCount, HGLOBAL __far *loc, BOOL __far *status)
{
   HGLOBAL  hExistingNode;

   hExistingNode = *loc;
   GlobalUnlock (hExistingNode);

   if ((*loc = GlobalReAlloc(hExistingNode, byteCount, HEAP_REALLOC_FLAGS)) == HNULL) {
      *loc = hExistingNode;
      *status = FALSE;
      return (GlobalLock(hExistingNode));
   }

   *status = TRUE;
   return (GlobalLock(*loc));
}

/*
**-----------------------------------------------------------------------------
** Allocations too large for the suballocator
**-----------------------------------------------------------------------------
*/
#ifndef HEAP_CHECK
private void __far *AllocateFromGlobalHeap (int cbData)
#else
private void __far *AllocateFromGlobalHeap (int cbData, char __far *file, int line)
#endif
{
   GHP     pNode;
   byte    __far *pResult;
   HGLOBAL hPage;

   if ((pNode = AllocateSpace(cbData + sizeof(GlobalHeapNode), &hPage)) == NULL)
      return (NULL);

   pNode->size = cbData + sizeof(GlobalHeapNode);
   pNode->location = hPage;

   pResult = (byte __far *)pNode + sizeof(GlobalHeapNode);
   memset (pResult, FILL_VALUE, cbData);

   #ifdef HEAP_CHECK
      pNode->signature = IN_USE_SIGNATURE;
      MemAddToAllocateList ((FNP)pNode, file, line);
   #endif

   return (pResult);
}

private void FreeFromGlobalHeap (void __far *pDataToFree)
{
   GHP  pData;

   pData = (GHP)((byte __far *)pDataToFree - sizeof(GlobalHeapNode));
   #ifdef HEAP_CHECK
      MemRemoveFromAllocateList ((FNP)pData);
   #endif

   FreeSpace(pData->location);
}

const int cbMemAlignment = 8;

int memAlignBlock( int x )
{
    return ( x + ( cbMemAlignment - 1 ) ) & ~( cbMemAlignment - 1 );
}

/*
**-----------------------------------------------------------------------------
** Suballocator 
**-----------------------------------------------------------------------------
*/
#ifndef HEAP_CHECK
public void __far *MemAllocate (void * pGlobals, int cbData)
#else
public void __far *DebugMemAllocate (int cbData, char __far *file, int line)
#endif
{
   PHP     pPage;
   FNP     pCurrentFree, pPreviousFree, pNewFree;
   FNP     pFirstLarger, pPrevFirstLarger;
   byte    __far *pResult;
   HGLOBAL hPage;
   int     cbRemaining;
   int x = sizeof(FreeNode);
   int y = sizeof(GlobalHeapNode);

   #ifdef HEAP_CHECK
     MemCTAllocate++;
   #endif

   #ifdef HEAP_CHECK
      #ifdef VERIFY_FREE_LIST
         MemVerifyFreeList();
      #endif
   #endif

   if (cbData == 0)
      return (NULL);

    /*
    * O10 Bug 335360:  We are passed in a cbData and we make sure it's small enough that we can handle it here
    * but we then immediately go ahead and change the size of it to make it bigger.  That leaves a magical range
    * where the cbData would pass the test before we make it bigger, but not after, and then we'd go on to crash.
    * The fix was to include the "- MEM_ALLOC_EXTRA" because that will correctly do the check.  As of 3/1/2001,
    * MEM_MAX_ALLOC was 8172 and MEM_ALLOC_EXTRA was 4.  memAlignBlock aligns to an 8 byte block.  Given that, if
    * you had the value 8161, it will, when all is said and done, round up to 8172, which is cool.  However, if
    * you had the value 8169, it will round up to 8180, which is bad.  8168 is the magical limit where good allocations
    * go bad, so we need to take off an extra 4 bytes to make sure we're comparing against THAT limit.
    *
    * This all assumes (MEM_MAX_ALLOC - MEM_ALLOC_EXTRA) % cbMemAlignment == 0 is always true (otherwise the
    * math changes), so we assert that.  To turn on Asserts, you have to "#define AQTDEBUG"
    */

   ASSERTION((MEM_MAX_ALLOC - MEM_ALLOC_EXTRA) % cbMemAlignment == 0);
   if (cbData > MEM_MAX_ALLOC - MEM_ALLOC_EXTRA) {
      #ifndef HEAP_CHECK
         return (AllocateFromGlobalHeap(cbData));
      #else
         return (AllocateFromGlobalHeap(cbData, file, line));
      #endif
   }

   cbData = memAlignBlock( cbData );

   cbData += MEM_ALLOC_EXTRA;
   cbData = max(cbData, MEM_MIN_ALLOC);

   /*
   ** Since most of the objects we allocate are one of a few different
   ** sizes, we walk the free list looking for an exact fit.  If we find
   ** it then use that node.  Otherwise a second pass is used to 
   ** find and split the first block that has sufficient space in it
   */
   pCurrentFree = (FNP)GetMemFreeList(pGlobals);
   pPreviousFree = NULL;
   pFirstLarger = NULL;

   while (pCurrentFree != NULL) {
      if (pCurrentFree->size == cbData) {
         if (pPreviousFree == NULL)
		 {
			SetMemFreeList(pGlobals, pCurrentFree->next);
		 }
         else
            pPreviousFree->next = pCurrentFree->next;

         pResult = (byte __far *)pCurrentFree + MEM_ALLOC_EXTRA;
         memset (pResult, FILL_VALUE, cbData - MEM_ALLOC_EXTRA);

         #ifdef HEAP_CHECK
            pCurrentFree->signature = IN_USE_SIGNATURE;
            MemAddToAllocateList (pCurrentFree, file, line);
            #ifdef VERIFY_FREE_LIST
               MemVerifyFreeList();
            #endif
         #endif

         return (pResult);
      }

      if ((pCurrentFree->size > cbData) && (pFirstLarger == NULL)) {
         pFirstLarger = pCurrentFree;
         pPrevFirstLarger = pPreviousFree;
      }

      pPreviousFree = pCurrentFree;
      pCurrentFree = pCurrentFree->next;
   }

   /*
   ** Second pass through the free list.  Take any node with sufficient
   ** space and split it to allocate the data we want
   */
passTwo:
   if (pFirstLarger != NULL) {
      /*
      ** If this node would be left with less than MEM_MIN_ALLOC
      ** bytes after the needed space is removed then return
      ** the complete node
      */
      if (pFirstLarger->size - cbData < MEM_MIN_ALLOC) {
         if (pPrevFirstLarger == NULL)
		 {
			SetMemFreeList(pGlobals, pFirstLarger->next);
		 }
         else
            pPrevFirstLarger->next = pFirstLarger->next;

         pResult = (byte __far *)pFirstLarger + MEM_ALLOC_EXTRA;
         memset (pResult, FILL_VALUE, cbData - MEM_ALLOC_EXTRA);

         #ifdef HEAP_CHECK
            pFirstLarger->signature = IN_USE_SIGNATURE;
            MemAddToAllocateList (pFirstLarger, file, line);
            #ifdef VERIFY_FREE_LIST
               MemVerifyFreeList();
            #endif
         #endif

         return (pResult);
      }

      cbRemaining = pFirstLarger->size - cbData;
      pNewFree = (FNP)((byte __far *)pFirstLarger + cbData);
      pNewFree->size = cbRemaining;
      pNewFree->next = pFirstLarger->next;

      if (pPrevFirstLarger == NULL)
	  {
		 SetMemFreeList(pGlobals, pNewFree);
	  }
      else
         pPrevFirstLarger->next = pNewFree;

      pResult = (byte __far *)pFirstLarger + MEM_ALLOC_EXTRA;
      pFirstLarger->size = cbData;

      memset (pResult, FILL_VALUE, pFirstLarger->size - MEM_ALLOC_EXTRA);

      #ifdef HEAP_CHECK
         pFirstLarger->signature = IN_USE_SIGNATURE;
         MemAddToAllocateList (pFirstLarger, file, line);
         pNewFree->signature = FREE_SIGNATURE;
         #ifdef VERIFY_FREE_LIST
            MemVerifyFreeList();
         #endif
      #endif

      return (pResult);
   }

   /*
   ** Still didn't find a node with enough space.  Allocate a whole
   ** new page, link it into the free list and repeat the last
   ** search process
   */
   if ((pPage = AllocateSpace(MEM_PAGE_SIZE, &hPage)) == NULL)
      return (NULL);

   pPage->PN.location = hPage;
   pPage->PN.id   = 0;
   pPage->PN.next = (PNP)GetMemPageList(pGlobals);
   pPage->PN.prev = NULL;

   if (GetMemPageList(pGlobals) != NULL)
      ((PNP)GetMemPageList(pGlobals))->prev = &(pPage->PN);

   SetMemPageList(pGlobals, &(pPage->PN)); 

   /*
   ** Add this new free node we just created to the end of the free list.
   ** If we added it to the start of the free list, the first fit loop
   ** would tend to make the heap contain many unused small nodes over
   ** time.
   */
   pPage->FN.size = MEM_EMPTY_PAGE_SIZE;
   pPage->FN.next = NULL;

   pFirstLarger = &(pPage->FN);
   pPrevFirstLarger = NULL;

   #ifdef HEAP_CHECK
      pPage->FN.signature = FREE_SIGNATURE;
      pResult = (byte __far *)pFirstLarger + sizeof(FreeNode);
      memset (pResult, EMPTY_VALUE, pPage->FN.size - sizeof(FreeNode));
   #endif

   if (pPreviousFree == NULL)
   {
	  SetMemFreeList(pGlobals, pFirstLarger);
	}
   else {
      pPreviousFree->next = pFirstLarger;
      pPrevFirstLarger = pPreviousFree;
   }
      
   /*
   ** Now that the free list is guarenteed to have a node big enough
   ** for our needs return to the first fit loop to do the actual
   ** allocation
   */
   goto passTwo;
}


/* Change the space of a node in the heap */
public void __far *MemReAllocate (void * pGlobals, void __far *pExistingData, int cbNewSize)
{
   FNP  pData;
   byte __far *pNewData;
   int  cbExisting;

   if ((pExistingData == NULL) || (cbNewSize == 0))
      return (NULL);

   pData = (FNP)((byte __far *)pExistingData - MEM_ALLOC_EXTRA);
   if (USE_GLOBAL_ALLOC(pData->size))
      cbExisting = pData->size - sizeof(GlobalHeapNode);
   else
      cbExisting = pData->size - MEM_ALLOC_EXTRA;

   #ifdef HEAP_CHECK
      ASSERTION (pData->signature == IN_USE_SIGNATURE);
   #endif

   ASSERTION ( cbNewSize > cbExisting );

   if ((pNewData = MemAllocate(pGlobals, cbNewSize)) == NULL)
      return (NULL);

   memcpy (pNewData, pExistingData, cbExisting);
   MemFree (pGlobals, pExistingData);

   return (pNewData);
}


#ifdef FREE_EMPTY_PAGES
private BOOL AttemptToFreePage (void * pGlobals, FNP pNode)
{
   PNP  pPage, pNextPage, pPrevPage;
   FNP  pCurrentNode, pPreviousNode;

   if (pNode->size == MEM_EMPTY_PAGE_SIZE)
   {
      pPreviousNode = NULL;
      pCurrentNode = (FNP)GetMemFreeList(pGlobals);
      while (pCurrentNode != NULL) {
         if (pCurrentNode == pNode)
            break;
         pPreviousNode = pCurrentNode;
         pCurrentNode = pCurrentNode->next;
      }

      if (pPreviousNode == NULL)
	  {
		 SetMemFreeList(pGlobals, pNode->next);
	  }
      else
         pPreviousNode->next = pNode->next;

      pPage = (PNP)((byte __far *)pNode - sizeof(PageNode));

      if ((pPrevPage = pPage->prev) != NULL)
         pPrevPage->next = pPage->next;
      else
         SetMemPageList(pGlobals, pPage->next); 

      if ((pNextPage = pPage->next) != NULL)
         pNextPage->prev = pPage->prev;

      FreeSpace(pPage->location);
      return (TRUE);
   }
   return (FALSE);
}
#endif

private void AttemptToMerge (void * pGlobals, FNP pNode, FNP pPreviousNode)
{
   FNP  pCurrentFree, pPreviousFree;
   FNP  pMergeTest, pExpandTest;
   #ifdef HEAP_CHECK
      byte __far *p;
   #endif
 
   /*
   ** Go through the free list seeing if any node could be expanded
   ** to merge with this node.  Also see if pNode can be expanded to
   ** include another node on the free list
   */
   pExpandTest = (FNP)((byte __far *)pNode + pNode->size);

   pCurrentFree = (FNP)GetMemFreeList(pGlobals);
   pPreviousFree = NULL;

   while (pCurrentFree != NULL) {
      pMergeTest = (FNP)((byte __far *)pCurrentFree + pCurrentFree->size);

	  // Noticed this in the debugger, not sure how it happens, but it
	  // causes a hang.
	  if (pNode->next == pNode)
		break;

      if (pNode == pMergeTest) {
         /*
         ** We have located a node (pCurrentFree) on the free list that
         ** could be expanded to include pNode.  Since pNode is about
         ** to become part of pCurrentFree remove pNode from the free
         ** list
         */
         if (pPreviousNode == NULL)
		 {
			SetMemFreeList(pGlobals, pNode->next);
		 }
         else
            pPreviousNode->next = pNode->next;

         pCurrentFree->size += pNode->size;

         #ifdef HEAP_CHECK
            p = (byte __far *)pCurrentFree + sizeof(FreeNode);
            memset (p, EMPTY_VALUE, pCurrentFree->size - sizeof(FreeNode));
         #endif

         #ifdef FREE_EMPTY_PAGES
            AttemptToFreePage (pGlobals, pCurrentFree);
         #endif
         break;
      }

      if (pExpandTest == pCurrentFree) {
         /*
         ** We have located a node (pCurrentFree) on the free list that
         ** pNode could be expanded to include.  Since pNode is being
         ** expanded pCurrentFree must be cut out of the list
         */
         if (pPreviousFree == NULL)
		 {
			SetMemFreeList(pGlobals, pCurrentFree->next);
		 }
         else
            pPreviousFree->next = pCurrentFree->next;

         pNode->size += pCurrentFree->size;

         #ifdef HEAP_CHECK
            p = (byte __far *)pNode + sizeof(FreeNode);
            memset (p, EMPTY_VALUE, pNode->size - sizeof(FreeNode));
         #endif

         #ifdef FREE_EMPTY_PAGES
            AttemptToFreePage (pGlobals, pNode);
         #endif
         break;
      }

      pPreviousFree = pCurrentFree;
      pCurrentFree = pCurrentFree->next;
   }
}

public void MemFree (void * pGlobals, void __far *pDataToFree)
{
   FNP  pData;
   FNP  pCurrentFree, pPreviousFree;
   FNP  pMergeTest, pExpandTest;
   FNP  pCheckAgain, pPreviousCheckAgain;
   BOOL merged;
   #ifdef HEAP_CHECK
      byte __far *p;
   #endif

   #ifdef HEAP_CHECK
     MemCTAllocate--;
   #endif

   #ifdef HEAP_CHECK
      #ifdef VERIFY_FREE_LIST
         MemVerifyFreeList();
      #endif
   #endif

   if (pDataToFree == NULL)
      return;

   pData = (FNP)((byte __far *)pDataToFree - MEM_ALLOC_EXTRA);
   #ifdef HEAP_CHECK
      ASSERTION (pData->signature == IN_USE_SIGNATURE);
   #endif

   if (USE_GLOBAL_ALLOC(pData->size)) {
      FreeFromGlobalHeap(pDataToFree);
      return;
   }

   #ifdef HEAP_CHECK
      pData->signature = FREE_SIGNATURE;
      MemRemoveFromAllocateList (pData);
   #endif

   /*
   ** Go through the free list seeing if any node could be expanded
   ** to merge with the pData node.  Also see if pData can be expanded
   ** to include another node on the free list
   */
   merged = FALSE;

   pCurrentFree = (FNP)GetMemFreeList(pGlobals);
   pPreviousFree = NULL;

   pExpandTest = (FNP)((byte __far *)pData + pData->size);

   while (pCurrentFree != NULL) {
      pMergeTest = (FNP)((byte __far *)pCurrentFree + pCurrentFree->size);

      if (pData == pMergeTest) {
         /*
         ** We have located a node (pCurrentFree) on the free list that
         ** could be expanded to include the node we are releasing (pData)
         */
         pCurrentFree->size += pData->size;

         #ifdef HEAP_CHECK
            p = (byte __far *)pCurrentFree + sizeof(FreeNode);
            memset (p, EMPTY_VALUE, pCurrentFree->size - sizeof(FreeNode));
         #endif

         pCheckAgain = pCurrentFree;
         pPreviousCheckAgain = pPreviousFree;
         merged = TRUE;
         break;
      }

      if (pExpandTest == pCurrentFree) {
         /*
         ** We have located a node (pCurrentFree) on the free list that
         ** pNode could be expanded to include.  Since pNode is being
         ** expanded, pCurrentFree must be cut out of the list.  Also
         ** pData must be added to the free list
         */
         if (pPreviousFree == NULL)
		 {
			SetMemFreeList(pGlobals, pData);
		 }
         else
            pPreviousFree->next = pData;

         pData->next = pCurrentFree->next;
         pData->size += pCurrentFree->size;

         #ifdef HEAP_CHECK
            p = (byte __far *)pData + sizeof(FreeNode);
            memset (p, EMPTY_VALUE, pData->size - sizeof(FreeNode));
         #endif

         pCheckAgain = pData;
         pPreviousCheckAgain = pPreviousFree;
         merged = TRUE;
         break;
      }

      pPreviousFree = pCurrentFree;
      pCurrentFree = pCurrentFree->next;
   }

   if (merged == FALSE) {
      /*
      ** The node being released can't be merged into any of the
      ** existing nodes on the free list.  Add it to the free list
      ** as it is
      */
      pData->next = (FNP)GetMemFreeList(pGlobals);
	  SetMemFreeList(pGlobals, pData);
      #ifdef HEAP_CHECK
         p = (byte __far *)pData + sizeof(FreeNode);
         memset (p, EMPTY_VALUE, pData->size - sizeof(FreeNode));
      #endif
      return;
   }

   /*
   ** Now that we have merged in the newly released node, see if the
   ** resultant node can be merged again.
   */
   #ifdef FREE_EMPTY_PAGES
      if (AttemptToFreePage(pGlobals, pCheckAgain) == TRUE)
         return;
   #endif

   AttemptToMerge (pGlobals, pCheckAgain, pPreviousCheckAgain);
}

/*
**-----------------------------------------------------------------------------
** Heap bulk cleanup
**-----------------------------------------------------------------------------
*/
/* Free all pages allocated for the suballocator heap */
public void MemFreeAllPages (void * pGlobals)
{
   PNP  pPage, pNextPage;
   
   #ifdef HEAP_CHECK
      DisplayAllocateList();
      #ifdef VERIFY_FREE_LIST
         MemVerifyFreeList();
      #endif
      MemReleasedPagesCount = 0;
   #endif

   pPage = (PNP)GetMemPageList(pGlobals);
   while (pPage != NULL) {
      pNextPage = pPage->next;
      FreeSpace (pPage->location);
      pPage = pNextPage;

      #ifdef HEAP_CHECK
         MemReleasedPagesCount++;
      #endif
   }

   SetMemPageList(pGlobals, NULL);
   SetMemFreeList(pGlobals, NULL);
}

/*
**-----------------------------------------------------------------------------
** Page marking facilities - used to create subheaps
**-----------------------------------------------------------------------------
*/
/* Mark all unmarked pages with the supplied id.  Set free list to NULL */
public void MemMarkPages (void * pGlobals, int id)
{
   PNP  pPage;
   
   #ifdef HEAP_CHECK
      #ifdef VERIFY_FREE_LIST
         MemVerifyFreeList();
      #endif
      MemMarkedPagesCount = 0;
   #endif

   pPage = (PNP)GetMemPageList(pGlobals);
   while (pPage != NULL) {
      if (pPage->id == 0) {
         pPage->id = id;

         #ifdef HEAP_CHECK
            MemMarkedPagesCount++;
         #endif
      }
      pPage = pPage->next;
   }

   SetMemFreeList(pGlobals, NULL);
}

/* Free all pages marked with the given id.  Set free list to NULL */
public void MemFreePages (void * pGlobals, int id)
{
   PNP  pPage, pNextPage, pPrevPage;

   #ifdef HEAP_CHECK
      #ifdef VERIFY_FREE_LIST
         MemVerifyFreeList();
      #endif
      MemReleasedPagesCount = 0;
   #endif

   pPage = (PNP)GetMemPageList(pGlobals);
   pPrevPage = NULL;

   while (pPage != NULL) {
      pNextPage = pPage->next;

      if (pPage->id == id) {
         #ifdef HEAP_CHECK
            MemReleasedPagesCount++;
         #endif
         FreeSpace (pPage->location);

         if (pPrevPage == NULL)
            SetMemPageList(pGlobals, pNextPage); 
         else
            pPrevPage->next = pNextPage;
      }
      else {
         pPrevPage = pPage;
      }

      pPage = pNextPage;
   }

   SetMemFreeList(pGlobals, NULL);
}

#endif // !VIEWER

/* end WINALLOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\filescan.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       FileScan.cxx
//
//  Contents:   CFileScanTracker Implementation
//
//  Classes:    CFileScanTracker
//
//  History:    01-Jul-2002   HemanthM Created
//
//----------------------------------------------------------------------

#include <windef.h>
#include <winerror.h>
#include "filescan.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CFileScanTracker::Add
//
//  Synopsis:   Adds the particular area that has been scanned, and returns
//              whether that area has already been scanned.
//
//  Arguments:  [uStart]   - starting position of the scan
//              [uLen]     - number of bytes to scan
//
//  Returns:    eNotScanned    - if the area has not been scanned
//              ePartlyScanned - if the area might been partially scanned
//              eFullyScanned  - if the area has been completely scanned
//
//  History:    01-Jul-2002     HemanthM    Created
//
//--------------------------------------------------------------------------

CFileScanTracker::StatusCode CFileScanTracker::Add(unsigned uStart, unsigned uLen)
{
    ScanNode **ppNode= &m_pHead;

    // Find a node that ends after uStart
    while(*ppNode ? uStart > (*ppNode)->m_uScanStart + (*ppNode)->m_uScanLen : false)
        ppNode = &((*ppNode)->m_pNext);

    if (*ppNode ? uStart + uLen < (*ppNode)->m_uScanStart : true)
    {
        // If the node cannot be found, or if the node found 
        // starts after end of current block
        // create a new node and exit

        ScanNode *pNewNode = new ScanNode;
        if (0 == pNewNode)
        {
            m_hr = E_OUTOFMEMORY;
            return eError;
        }

        pNewNode->m_uScanStart = uStart;
        pNewNode->m_uScanLen = uLen;
        pNewNode->m_pNext = *ppNode;
        *ppNode = pNewNode;

        return eNotScanned;
    }

    // A node exists, whose end is on or after start of current block
    // and its start is on or before end of current block
    StatusCode sc = eFullyScanned;
    unsigned uNodeEndPlusOne = (*ppNode)->m_uScanStart + (*ppNode)->m_uScanLen;
    if (uStart < (*ppNode)->m_uScanStart)
    {
        // Extend the start of the node
        sc = ePartlyScanned;
        uNodeEndPlusOne += (*ppNode)->m_uScanStart - uStart;
        (*ppNode)->m_uScanStart = uStart;
    }
    if (uStart + uLen > uNodeEndPlusOne)
    {
        // Extend the end of the node
        sc = ePartlyScanned;

        uNodeEndPlusOne = uStart + uLen;

        // Now merge the following nodes, if required;
        ScanNode *pNextNode = (*ppNode)->m_pNext;
        while(pNextNode ? pNextNode->m_uScanStart <= uNodeEndPlusOne : false)
        {
            uNodeEndPlusOne = pNextNode->m_uScanStart + pNextNode->m_uScanLen;
            ScanNode *pAfterNode = pNextNode->m_pNext;
            delete pNextNode;
            pNextNode = pAfterNode;
        }
        (*ppNode)->m_pNext = pNextNode;
    }
    (*ppNode)->m_uScanLen = uNodeEndPlusOne - (*ppNode)->m_uScanStart;

    return sc; // returns eFullyScanned if a node completely covers current block
               // ePartlyScanned if any extension is required
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\oleobjit.h ===
#ifndef _OLEOBJECTITERATOR_
#define _OLEOBJECTITERATOR_

#include <ole2.h>
#include <stdio.h>
#include <time.h>


const int    PST_CurrentUserAtom     = 4086;
const int    PST_ExOleObjStg         = 4113;     // Storage for ole object


//--------------------------------------------------------------------------
//     PPT8Ref
//--------------------------------------------------------------------------
class PPT8Ref
{
public:
    PPT8Ref(unsigned long refNum, unsigned long offset):m_refNum(refNum),m_offset(offset){}
    ~PPT8Ref(){};
    unsigned long GetRefNum(){return(m_refNum);}
    unsigned long GetOffset(){return(m_offset);}
protected:
    unsigned long m_refNum;
    unsigned long m_offset;
};

//--------------------------------------------------------------------------
//     PPT8RefList
//--------------------------------------------------------------------------
class PPT8RefList
{
public:
    PPT8RefList(PPT8Ref* ref):m_ref(ref), m_nextRef(0){}
    ~PPT8RefList();
    void AddToBack(PPT8RefList* refList);
    PPT8RefList* GetNext() const {return(m_nextRef);}
    void SetNext(PPT8RefList* refList)  {m_nextRef = refList;}
    PPT8Ref* GetRef() const {return(m_ref);}
    BOOL    IsNewReference(unsigned long ref);    // Returns TRUE if a new reference.
    BOOL    GetOffset(unsigned long ref, unsigned long& offset);    // Returns the offset for a given reference.
protected:
    PPT8Ref* m_ref;
    PPT8RefList* m_nextRef;
};


class    OleObjectIterator
{
public:
    
    OleObjectIterator(IStorage* iStore);
    ~OleObjectIterator();
    HRESULT GetNextEmbedding(IStorage ** ppstg);
    
private:
    
    BOOL    Initialize(void);
    HRESULT ReadOLEData(IStorage ** ppstg, RecordHeader rh);
    IStream*            m_pDocStream;
    PPT8RefList*        m_pRefList;   // Linked List of the persist dir entries - ref and offsets. 
    PPT8RefList*        m_pRefListHead;   // Linked List of the persist dir entries - ref and offsets. 
    IStorage*            m_iStore;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\pp97rdr.cpp ===
#include <crtdbg.h>

#include "pp97rdr.h"
//KYLEP
#include "OleObjIt.h"
#include "filterr.h"
#include "filtrace.hxx"
#include "filescan.hxx"

int AssertionFailed( const char* file, int line, const char* expr )
/*=================*/
{// AR: Message box the assert
   return( TRUE );
} /* AssertionFailed */


class PPSDirEntry
{
   PPSDirEntry()
    : m_pNext( NULL ), m_pOffsets( NULL ), m_tableSize( 0 ){}

   PPSDirEntry* m_pNext;
   DWord*       m_pOffsets;
   DWord        m_tableSize;
public:
   ~PPSDirEntry(){ delete m_pOffsets; m_pOffsets = NULL; }

friend class PPSPersistDirectory;
}; // class PPSDirEntry
 
class PPSPersistDirectory
{
public:
   PPSPersistDirectory();

   ~PPSPersistDirectory();

   void  AddEntry( DWord cOffsets, DWord* pOffsets );
   DWord GetPersistObjStreamPos( DWord ref );
   DWord MaxSavedPersists();

private:
   PPSDirEntry* m_pFirstDirEntry;
}; 


PPSPersistDirectory::PPSPersistDirectory() : m_pFirstDirEntry( NULL ){}

PPSPersistDirectory::~PPSPersistDirectory()
{
   while( m_pFirstDirEntry )
   {
      PPSDirEntry* pDirEntry = m_pFirstDirEntry;
      m_pFirstDirEntry = m_pFirstDirEntry->m_pNext;
      delete pDirEntry;
   }
}

void PPSPersistDirectory::AddEntry( DWord cOffsets, DWord* pOffsets )
{
   if (!pOffsets)
       return;

   PPSDirEntry* pDirEntry = new PPSDirEntry();
   if (!pDirEntry)
       return;

   pDirEntry->m_tableSize = cOffsets;
   pDirEntry->m_pOffsets = new DWord[cOffsets];
   if (pDirEntry->m_pOffsets == NULL)
   {
       delete pDirEntry;
       return;
   }
   memcpy( pDirEntry->m_pOffsets, pOffsets, cOffsets * sizeof( DWord ) );

   // append to the end of the entry list
   PPSDirEntry** ppDirEntry = &m_pFirstDirEntry;
   while( NULL != *ppDirEntry )
      ppDirEntry = &(*ppDirEntry)->m_pNext;
   *ppDirEntry = pDirEntry;
}
   
DWord PPSPersistDirectory::GetPersistObjStreamPos( DWord ref )
{
   PPSDirEntry* pEntry = m_pFirstDirEntry;
   while( pEntry )
   {
      DWord* pOffsets = pEntry->m_pOffsets;
      while( (DWord)( (char*)pOffsets - (char*)pEntry->m_pOffsets ) < pEntry->m_tableSize * sizeof( DWord ) )
      {
         DWord nRefs = pOffsets[0] >> 20;
         DWord base = pOffsets[0] & 0xFFFFF; // 1-based
         if( ( base <= ref )&&( ref < base + nRefs ) ) 
            return pOffsets[ 1 + ref - base ];
         pOffsets += nRefs + 1;
      }
      pEntry = pEntry->m_pNext;
   }
   return (DWord) -1;
} 
 
DWord PPSPersistDirectory::MaxSavedPersists()
{
   DWord dwMaxRef = 0;
   PPSDirEntry* pEntry = m_pFirstDirEntry;
   while( pEntry )
   {
      DWord* pOffsets = pEntry->m_pOffsets;
      while( (DWord)( pOffsets - pEntry->m_pOffsets ) < pEntry->m_tableSize )
      {
         DWord nRefs = pOffsets[0] >> 20;
         DWord dwBase= pOffsets[0] & 0xFFFFF;
         dwMaxRef = dwBase + nRefs - 1;
         pOffsets += nRefs + 1;
      }
      pEntry = pEntry->m_pNext;
   }
   return dwMaxRef;
}

FileReader::FileReader(IStorage *pStg) :
   m_pPowerPointStg(pStg), 
   m_isPP(FALSE),
   m_pParseContexts(NULL),
   m_curTextPos(0),
   m_pLastUserEdit( NULL ),
   m_pPersistDirectory( NULL ),
   m_pDocStream( NULL ),
   m_pFirstChunk( NULL ),
   m_curSlideNum(0),
   m_pCurText( NULL ),
   m_pClientBuf( NULL ),
   m_clientBufSize( 0 ),
   m_clientBufPos( 0 ), 
   m_LCID(0), 
   m_LCIDAlt(0), 
   m_nTextCount(0), 
   m_bHaveText(FALSE),
   m_bFEDoc(0), 
   m_hr(S_OK), 
   m_pLangRuns(NULL),
   m_pCurrentRun(NULL),
   m_pstmTempFile(0)
{
   IStream *pStm = NULL;
   HRESULT hr = pStg->OpenStream( CURRENT_USER_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &pStm );
   if( SUCCEEDED(hr) && ReadCurrentUser(pStm) )
      m_isPP = TRUE;
   
   if(pStm)
   {
        pStm->Release();
   }

   m_bEndOfEmbeddings = FALSE;
   m_oleObjectIterator = NULL;

    //initialize the ignore text flag
    m_fIgnoreText = FALSE;

    // Open temp text file
    OpenTextFile();
}

FileReader::~FileReader()
{
   if(m_pDocStream)
    {
        m_pDocStream->Release();
        m_pDocStream = NULL;
    }
    
    if(m_oleObjectIterator)
    {
        delete m_oleObjectIterator;
        m_oleObjectIterator = NULL;
    }
    
    
    if(m_pCurText)
    {
        delete [] m_pCurText;
        m_pCurText = 0;
    }

    if(m_pFirstChunk)
    {
        delete m_pFirstChunk;
        m_pFirstChunk = 0;
    }

    if(m_pPersistDirectory)
    {
        delete m_pPersistDirectory;
        m_pPersistDirectory = 0;
    }
    
    if(m_pLastUserEdit)
    {
        delete m_pLastUserEdit;
        m_pLastUserEdit = 0;
    }

    
    if(m_pParseContexts)
    {
        delete m_pParseContexts;
        m_pParseContexts = 0;
    }

    FTrace("Releasing TempFile");
    // release temp text stream
    if(0 != m_pstmTempFile)
    {
        m_pstmTempFile->Release();
        m_pstmTempFile = 0;
    }

    if(m_pLangRuns)
    {
        DeleteAll6(m_pLangRuns);
        m_pLangRuns = NULL;
    }
}

BOOL FileReader::FillBufferWithText()
{
   if(!m_pCurText)
       return FALSE;

    if (!m_pstmTempFile)
        return TRUE;    // strange but TRUE

    LARGE_INTEGER liOffset={0,0};
    ULARGE_INTEGER uliNewPosition;
    HRESULT hr = m_pstmTempFile->Seek(liOffset, STREAM_SEEK_CUR, &uliNewPosition);
    if (FAILED(hr) || uliNewPosition.HighPart > 0)
    {
        Assert(uliNewPosition.HighPart==0 || !"Temp buffer larger than 4GB");
        m_pstmTempFile->Release();
        m_pstmTempFile = 0;
        return TRUE;
    }

    FTrace("TempFile positioned at %u", uliNewPosition.LowPart);
    m_fcStart = uliNewPosition.LowPart;
    m_fcEnd = m_fcStart + m_curTextLength * sizeof(WCHAR);

    
    if(m_bFEDoc)
    {
        ScanTextBuffer();
    }

    hr = m_pstmTempFile->Write(m_pCurText, m_curTextLength * sizeof(WCHAR), NULL);
    delete [] m_pCurText; m_pCurText = 0;

    FTrace("Wrote TempFile with %u bytes", m_curTextLength * sizeof(WCHAR));
    m_bHaveText = TRUE;

    if( FAILED(hr) )
    {
        m_pstmTempFile->Release();
        m_pstmTempFile = 0;
        return TRUE;
    }

    return FALSE;
}

void FileReader::AddSlideToList( psrReference refToAdd )
{
   if( m_pFirstChunk == NULL ) 
      m_pFirstChunk = new SlideListChunk(NULL, refToAdd);
   else
   {
      if( m_pFirstChunk->numInChunk+1 > SLIDELISTCHUNKSIZE )
         m_pFirstChunk = new SlideListChunk(m_pFirstChunk, refToAdd);
      else
      {
         m_pFirstChunk->refs[m_pFirstChunk->numInChunk] = refToAdd;
         m_pFirstChunk->numInChunk++;
      }
   }
}

HRESULT FileReader::GetNextEmbedding(IStorage ** ppstg)
{
    if(m_bEndOfEmbeddings)
    {
        return OLEOBJ_E_LAST;
    }

    if( m_pDocStream )
    {
        m_pDocStream->Release();
        m_pDocStream = NULL;
    }

    if( m_oleObjectIterator == NULL)
    {
       m_oleObjectIterator = new OleObjectIterator(m_pPowerPointStg);
    }

    if(m_oleObjectIterator)
    {
        HRESULT rc = m_oleObjectIterator->GetNextEmbedding(ppstg);
        if(rc != S_OK || *ppstg == NULL)
        {
            delete m_oleObjectIterator;
            m_oleObjectIterator = NULL;
            m_bEndOfEmbeddings = TRUE;
            rc = OLEOBJ_E_LAST;
        }
        return rc;
    }
    else
        return OLEOBJ_E_LAST;
}

IStream *FileReader::GetDocStream()
{
   if( m_pDocStream == NULL )
   {
      if( !m_isPP )
         return NULL;
      HRESULT hr = m_pPowerPointStg->OpenStream( DOCUMENT_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &m_pDocStream );
       if (FAILED(hr))
      {
           //fprintf(stderr,"Error (%d) opening PowerPoint Document Stream.\n",(int)hr);
         return NULL;
       }
   }
   return m_pDocStream;

}

BOOL FileReader::ReadCurrentUser(IStream *pStm)
{
   ULONG nRd=0;
   RecordHeader rh;
   BOOL isPP = FALSE;
   if( SUCCEEDED( pStm->Read(&rh, sizeof(rh), &nRd) ) )
   {
      if( SUCCEEDED( pStm->Read(&m_currentUser, sizeof(PSR_CurrentUserAtom), &nRd) ) )
      {
         if( nRd != sizeof(PSR_CurrentUserAtom) )
            return FALSE;
      }
      isPP = ( m_currentUser.size == sizeof( m_currentUser )      )&&
             ( m_currentUser.magic == HEADER_MAGIC_NUM )&&
             ( m_currentUser.lenUserName <= 255        );
   }

   return isPP;
}


BOOL FileReader::PPSReadUserEditAtom( DWord offset, PSR_UserEditAtom& userEdit )
{
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return FALSE;
   LARGE_INTEGER li;
   li.LowPart = offset;
   li.HighPart = 0;
   if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
      return FALSE;
   RecordHeader rh;
   DWord nRd = 0;
   if ( FAILED(pStm->Read(&rh, sizeof(rh), &nRd)) || nRd != sizeof(rh) )
      return FALSE;
   //Assert( rh.recType == PST_UserEditAtom );
   if ( rh.recType != PST_UserEditAtom )
      return FALSE;
   
   //Assert( rh.recLen == sizeof( PSR_UserEditAtom ) );
   if ( rh.recLen != sizeof( PSR_UserEditAtom ) )
      return FALSE;

   li.LowPart = offset;
   if (FAILED(pStm->Read(&userEdit, sizeof(userEdit), NULL)))
      return FALSE;
   return TRUE;
}


void *FileReader::ReadRecord( RecordHeader& rh )
// Return values:
// NULL and rh.recVer == PSFLAG_CONTAINER: no record was read in.
//    record header indicated start of container.
// NULL and rh.recVer != PSFLAG_CONTAINER: client must read in record.
{
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return NULL;
   // read record header, verify
   DWord nRd = 0;
   if ( FAILED(pStm->Read(&rh, sizeof(rh), &nRd)) || nRd != sizeof(rh) )
      return NULL;

   // if client will read, do not read in record
   if( DoesClientRead( rh.recType ) )
      return NULL;

   // If container, return NULL
   if(rh.recVer == PSFLAG_CONTAINER)
      return NULL;


   // Allocate buffer for disk record. Client must call ReleaseRecord() or
   // pass the atom up to CObject::ConstructContents() which will
   // then release it.   
   void* buffer = new char[rh.recLen];
   if (!buffer)
       return NULL;

   // read in record
   if (FAILED(pStm->Read(buffer, rh.recLen, NULL)))
      return NULL;

   // NOTE: ByteSwapping & versioning not done by this simple reader.
   return (buffer);
}

void FileReader::ReleaseRecord( RecordHeader& rh, void* diskRecBuf )
{
   if(rh.recType && rh.recVer!=PSFLAG_CONTAINER)
      delete [] (char*)diskRecBuf;
   rh.recType = 0;         // consume the record so that record doesn't
                           // get processed again.
}

HRESULT FileReader::ReadPersistDirectory()
{
   HRESULT rc = S_OK;
   if( NULL != m_pLastUserEdit )
      return rc; // already read

   PSR_UserEditAtom userEdit;
   DWord offsetToEdit = m_currentUser.offsetToCurrentEdit;
   LARGE_INTEGER liLast;
   BOOL fFirstLoop = TRUE; 

   while( 0 < offsetToEdit )
   {
      if (!PPSReadUserEditAtom( offsetToEdit, userEdit ))
         return STG_E_DOCFILECORRUPT;

      if( NULL == m_pLastUserEdit )
      {
         if ((m_pPersistDirectory = new PPSPersistDirectory()) == NULL)
            return E_OUTOFMEMORY;
         m_pLastUserEdit     = new PSR_UserEditAtom;
         if (!m_pLastUserEdit)
         {
            delete m_pPersistDirectory;
            m_pPersistDirectory = NULL;
            return E_OUTOFMEMORY;
         }
         *m_pLastUserEdit = userEdit;
      }
      LARGE_INTEGER li;
      li.LowPart = userEdit.offsetPersistDirectory;
      li.HighPart = 0;
      if (!fFirstLoop && li.LowPart == liLast.LowPart && li.HighPart == liLast.HighPart)
      {
         rc = STG_E_DOCFILECORRUPT;
         break;
      }
      IStream *pStm = GetDocStream();
      if (0 == pStm)
         return E_FAIL;
      if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
         return E_FAIL;
      RecordHeader rh;
      DWord *pDiskRecord = (DWord*) ReadRecord(rh);
      //Assert( PST_PersistPtrIncrementalBlock == rh.recType );
      if ( PST_PersistPtrIncrementalBlock != rh.recType )
      {
         return STG_E_DOCFILECORRUPT;
      }
      m_pPersistDirectory->AddEntry( rh.recLen / sizeof( DWord ), pDiskRecord );
      ReleaseRecord( rh, pDiskRecord );
      offsetToEdit = userEdit.offsetLastEdit;
      liLast = li;
      if(fFirstLoop)
         fFirstLoop = FALSE;
   }

   return rc;
} // PPStorage::ReadPersistDirectory 

void FileReader::ReadSlideList()
{
    if ( !m_pLastUserEdit || !m_pPersistDirectory )
        return;

    DWORD offsetToDoc = m_pPersistDirectory->GetPersistObjStreamPos( m_pLastUserEdit->documentRef );
    LARGE_INTEGER li;
    li.LowPart = offsetToDoc;
    li.HighPart = 0;
    DWord dwMaxOffsets = m_pPersistDirectory->MaxSavedPersists();
   
    IStream *pStm = GetDocStream();
    if (0 == pStm)
       return;      // BUGBUG - there is no error status return.
    if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
        return;     // BUGBUG - there is not error status return.
    ParseForLCID();
   
    m_pLangRuns = new CLidRun(0, 0x7fffffff, (unsigned short)m_LCID, NULL, NULL);
    if (!m_pLangRuns)
        return;

    if (FAILED(ScanLidsForFE()))
        return;

    CFileScanTracker scanTracker;
    for(DWORD dwOffsets=1; dwOffsets<=dwMaxOffsets; dwOffsets++)
    {
        //WE WANT THE DOCUMENT CONTAINER AND THE HANDOUT CONTAINER
        li.LowPart = m_pPersistDirectory->GetPersistObjStreamPos(dwOffsets);
        if (li.LowPart == (DWORD)-1)
            continue;   // There can be gaps in indices

         // if any of the below fail, we've got a corrupt document.  Safe to bail.
        if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
           break;   // BUGBUG - no error status return
        DWord nRd = 0;
        RecordHeader rh;
        if (FAILED(pStm->Read((void *)&rh, sizeof(rh), &nRd)))
           break;   // BUGBUG - no error status return
        if (nRd != sizeof(rh))
           break;   // BUGBUG - no error status return
        if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
           break;

        CFileScanTracker::StatusCode sc = scanTracker.Add(li.LowPart, rh.recLen);
        if (CFileScanTracker::eError == sc)
            break;   // BUGBUG - no error status return
        
        if (CFileScanTracker::eFullyScanned != sc)
        {
            switch(rh.recType)
            {
            case PST_Document:

                ParseForSlideLists();

                ScanText();
                break;

            case PST_Slide:
                break; // Don't parse slides - it has already been done

            default: //including HANDOUT
                StartParse(li.LowPart);
                break;
            }
        }
    }

    LARGE_INTEGER liOffset={0,0};
    HRESULT hr = m_pstmTempFile->Seek(liOffset, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        return; // BUGBUG - no error return
    FTrace("Seeked TempFile to position %u", liOffset);

    m_pCurrentRun = m_pLangRuns;
}

DWord FileReader::ParseForSlideLists()
{
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return 0;
   RecordHeader rh;
   DWord nRd=0;
   // Stack based parsing for SlideLists
   if (FAILED(pStm->Read(&rh, sizeof(rh), &nRd)) || nRd != sizeof(rh))
      return 0;
   if( ( rh.recVer != PSFLAG_CONTAINER ) && ( (rh.recVer & 0x0F)!=0x0F ) )
   {
      if( rh.recType == PST_SlidePersistAtom )
      {
         PSR_SlidePersistAtom spa;
         Assert( sizeof(spa) == rh.recLen );
         if (FAILED(pStm->Read(&spa, sizeof(spa), &nRd)) || nRd != sizeof(spa))
            return 0;
         AddSlideToList( spa.psrReference );
      }
      else
      {
         LARGE_INTEGER li;
         li.LowPart = rh.recLen;
         li.HighPart = 0;
         if (FAILED(pStm->Seek(li,STREAM_SEEK_CUR, NULL)))
            return 0;
      }
      nRd += rh.recLen;
   }
   else
   {
      DWord nCur = 0;
      while( nCur < rh.recLen )
      {
         DWord nNew = ParseForSlideLists();
         if (nNew == 0)
            break; // We returned 0 from above...this is an error case and we can avoid an infinte loop here
         else
            nCur += nNew;
      }
      nRd += nCur;
   }
   return nRd;

}

DWord FileReader::ParseForLCID()
{
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return 0;

   RecordHeader rh;
   DWord nRd=0;

   if (FAILED(pStm->Read(&rh, sizeof(rh), &nRd)) || nRd != sizeof(rh))
   {
        m_nTextCount = END_OF_SEARCH_FOR_LID;
        return nRd;
   }
   if( ( rh.recVer != PSFLAG_CONTAINER ) && ( (rh.recVer & 0x0F)!=0x0F ) )
   {
      if( rh.recType == PST_TxSpecialInfoAtom /*&& !m_LCID*/)
      {
         void* buffer = new char[rh.recLen];
         if (!buffer)
            {
            m_nTextCount = END_OF_SEARCH_FOR_LID;
            return 0;
            }
         
        if (FAILED(pStm->Read(buffer, rh.recLen, &nRd)) || nRd != rh.recLen)
            {
            m_nTextCount = END_OF_SEARCH_FOR_LID;
            delete buffer;
            return 0;
            }
         long lMask = *((long UNALIGNED *)buffer);
         short UNALIGNED * pLCID = (short*)((char*)buffer + 4);
         
         if(lMask & 0x1)
             pLCID++;
         
         if(lMask & 0x2)
         {
            m_LCID = MAKELCID(*pLCID, SORT_DEFAULT);
            pLCID++;
         }
         else
            m_LCID = GetSystemDefaultLCID();

         // stop search
         m_nTextCount = END_OF_SEARCH_FOR_LID;
         
         if(lMask & 0x4)
            m_LCIDAlt = MAKELCID(*pLCID, SORT_DEFAULT);
         
         if(m_LCIDAlt == 0)
         {
             // non-FE doc
             m_bFEDoc = FALSE;
             m_bFE = FALSE;
         }
         else
         {
             m_bFEDoc = TRUE;
             m_bFE = TRUE;
         }

         delete buffer;
      }
      else if( rh.recType == PST_TextSpecInfo)
      {
         void* buffer = new char[rh.recLen];
         if (!buffer)
            return 0;
         char* pData = (char*)buffer;
         
         if (FAILED(pStm->Read(buffer, rh.recLen, &nRd)) || nRd != rh.recLen)
            nRd = 0; // This will cause the for loop to short circuit and us to bail.

         for(DWord i = 0; i < nRd;)
         {
             i += 4; // skip run length
             if(i >= nRd)
                 break;

             long lMask = *((long UNALIGNED *)(pData + i)); i += sizeof(long);
             if(i >= nRd)
                 break;
             
             if(lMask & 0x1) i += sizeof(short);
             if(i >= nRd)
                 break;

             if(lMask & 0x2)
             {
                m_LCID = MAKELCID(*((short UNALIGNED *)(pData + i)), SORT_DEFAULT);
                break;
             }
 
             if(lMask & 0x4)
             {
                m_LCIDAlt = MAKELCID(*((short UNALIGNED *)(pData + i)), SORT_DEFAULT);
                i += sizeof(short);
             }
         }
         
         delete buffer;
      }
      else if( rh.recType == PST_TextCharsAtom || rh.recType == PST_TextBytesAtom)
      {
        m_nTextCount++;
        LARGE_INTEGER li;
        li.LowPart = rh.recLen;
        li.HighPart = 0;
        if (FAILED(pStm->Seek(li,STREAM_SEEK_CUR, NULL)))
            return FALSE;
      }
      else
      {
         LARGE_INTEGER li;
         li.LowPart = rh.recLen;
         li.HighPart = 0;
         if (FAILED(pStm->Seek(li,STREAM_SEEK_CUR, NULL)))
            return FALSE;
      }
      nRd += rh.recLen;
   }
   else
   {
      DWord nCur = 0;
      while( nCur < rh.recLen && m_nTextCount < END_OF_SEARCH_FOR_LID)
      {
         nCur += ParseForLCID();
      }
      nRd += nCur;
   }
   return nRd;
}

HRESULT FileReader::ScanText()
{
   // this scans the file and writes extracted 
   // text to the temporary file

   DWord offset;
   if(0 == m_pstmTempFile)
   {
      return  STG_E_MEDIUMFULL; 
                      // We really don't know what the problem was
                      // since error codes are often ignored
                      // But it is better to return this, because
                      // something might be relying on it
   }

   for( ;; )
   {
      if( ( m_pParseContexts == NULL ) )
      {
         if( FindNextSlide(offset) )
         {
            if( StartParse( offset ) )
                return TRUE;
         }
         else
         {
            return FALSE; // DONE parsing, no more slides
         }
      }
      else
      {
        if( FillBufferWithText() ) // Use existing text first.
            return TRUE;

        if( Parse() ) // restart parse where we left off.
            return TRUE;
      }
   }
}

BOOL FileReader::StartParse( DWord offset )
{
   LARGE_INTEGER li;
   DWord nRd = 0;
   li.LowPart = offset;
   li.HighPart = 0;
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return FALSE;
   if (FAILED(pStm->Seek(li,STREAM_SEEK_SET, NULL)))
      return FALSE;
   m_pParseContexts = new ParseContext( NULL );
   if ( !m_pParseContexts )
      return FALSE;
   if ((FAILED(pStm->Read(&m_pParseContexts->m_rh, sizeof(RecordHeader), &nRd))) || nRd != sizeof(RecordHeader))
      return FALSE;
   return Parse();
}

BOOL FileReader::ContainsSubRecords(const RecordHeader &rh)
{
    if (( rh.recVer == PSFLAG_CONTAINER ) || ( (rh.recVer & 0x0F)==0x0F ))
        return TRUE;
    if (rh.recType == PST_BinaryTagData)
        return TRUE;
    return FALSE;
}

BOOL FileReader::Parse()
{
   IStream *pStm = GetDocStream();
   if (0 == pStm)
      return FALSE;
   RecordHeader rh;
   DWord nRd=0;
   if ( !m_pParseContexts )
      return FALSE;

   // Restarting a parse might complete a container so we test this initially.
   while( m_pParseContexts && m_pParseContexts->m_nCur >= m_pParseContexts->m_rh.recLen )
   {
      Assert(  m_pParseContexts->m_nCur == m_pParseContexts->m_rh.recLen );
      ParseContext* pParseContext = m_pParseContexts;
      m_pParseContexts = m_pParseContexts->m_pNext;
      pParseContext->m_pNext = 0;
      delete pParseContext;
   }

   if(!m_pParseContexts)
      return FALSE;

   do
   {
      ULONG nRead;

      pStm->Read(&rh, sizeof(RecordHeader), &nRead);
      if(nRead < sizeof(RecordHeader))
      {
         if(m_pParseContexts) 
            delete m_pParseContexts;

         m_pParseContexts = 0;

         if( FillBufferWithText() ) 
            return TRUE;
         else
            return FALSE;
      }

      m_pParseContexts->m_nCur += rh.recLen;
      m_pParseContexts->m_nCur += sizeof( RecordHeader ); // Atom rh's add towards containing container's size.

      //wprintf( L"Record type-%d-\n", rh.recType );
      //_RPTF2(_CRT_WARN, "\n Record type: %d, rec length: %d\n", rh.recType, rh.recLen);

      if( ! ContainsSubRecords(rh) )
      {
         if( rh.recType == PST_OEPlaceholderAtom )
         {
            LPBYTE lpData;
            HRESULT hr;
            // If size of record is 0, ignore it
            if (rh.recLen == 0)
               continue;
            if ((lpData = new (BYTE [rh.recLen])) == NULL)
               //stop parsing if no mem left
               return TRUE;

            hr = pStm->Read (lpData, rh.recLen, &nRead);
            if (FAILED(hr))
            {
               //stop parsing if read error
               delete lpData;
               return TRUE;
            }

            LPOEPLACEHOLDERATOM pstructOEPA = (LPOEPLACEHOLDERATOM)lpData;

            //setup to ignore text if item is master related
            if(pstructOEPA->placeholderId < D_GENERICTEXTOBJECT)
            {
               switch(pstructOEPA->placeholderId)
               {
               case D_MASTERHEADER:
               case D_MASTERFOOTER:
                   // If it is the master header or footer, don't ignore
                   break;

               default:
                   m_fIgnoreText = TRUE;
               }
            }

            delete lpData;
         }
         else if(rh.recType == PST_CString && 
                 (m_bHeaderFooter || 
                 (m_pParseContexts->m_rh.recType == PST_Comment10 && rh.recInstance == 1)))
         {
            m_curTextPos = 0;
            m_curTextLength = rh.recLen/2 + 1;
            Assert( m_pCurText == NULL );
            if(m_pCurText)
            {
               delete [] m_pCurText;
               m_pCurText = 0;
            }
            m_pCurText = new WCHAR[rh.recLen/2 + 1];
            if (!m_pCurText)
               return TRUE;
            if (FAILED(pStm->Read(m_pCurText, rh.recLen, &nRd)) || nRd != rh.recLen)
               return TRUE;
            m_pCurText[rh.recLen/2] = L' ';

            if(m_fIgnoreText == FALSE)
            {
               if( FillBufferWithText() )
               return TRUE;   // Stop parsing if buffer is full, and return control to client
            }

            m_fIgnoreText = FALSE;
         }
         else if( rh.recType == PST_TextSpecInfo )
         {
             void* buffer = new char[rh.recLen];
             if (!buffer)
                 return TRUE;
             if (FAILED(pStm->Read(buffer, rh.recLen, &nRd)) || nRd != rh.recLen)
                {
                delete buffer;
                return TRUE;
                }

             ScanTextSpecInfo((char*)buffer, nRd);
             
             delete buffer;
         }
         else if( rh.recType == PST_TextCharsAtom)
         {
            m_curTextPos = 0;
            m_curTextLength = rh.recLen/2 + 1;
            Assert( m_pCurText == NULL );

            if(m_pCurText)
            {
               delete [] m_pCurText;
               m_pCurText = 0;
            }

            m_pCurText = new WCHAR[m_curTextLength];
            if (!m_pCurText)
               return TRUE;

            if (FAILED(pStm->Read(m_pCurText, rh.recLen, &nRd)) || nRd != rh.recLen)
               return TRUE;
            
            // add extra space in the end
            m_pCurText[m_curTextLength - 1] = 0x20;
            //wprintf( L"PST_TextCharsAtom: -%s-\n", m_pCurText );

            if(m_fIgnoreText == FALSE)
            {
               if( FillBufferWithText() )
               return TRUE;   // Stop parsing if buffer is full, and return control to client
            }

            m_fIgnoreText = FALSE;
         }
         else if( rh.recType == PST_TextBytesAtom)
         {
            Assert( m_pCurText == NULL );
            m_curTextPos = 0;
            m_curTextLength = rh.recLen + 1;

            if(m_pCurText)
            {
               delete [] m_pCurText;
               m_pCurText = 0;
            }

            m_pCurText = new WCHAR[m_curTextLength];
            if (!m_pCurText)
               return TRUE;

            if (FAILED(pStm->Read(m_pCurText, rh.recLen, &nRd)) || nRd != rh.recLen)
               return TRUE;

            //wprintf( L"PST_TextBytesAtom: -%s-\n", m_pCurText );
            char *pHack = (char *) m_pCurText;
            unsigned int back2 = rh.recLen*2-1;
            unsigned int back1 = rh.recLen-1;

            // add extra space at the end of the text
            pHack[back2+1] = ' ';
            pHack[back2+2] = 0;

            for(unsigned int i=0;i<rh.recLen;i++)
            {
               pHack[back2-1] = pHack[back1];
               pHack[back2] = 0;
               back2 -=2;
               back1--;
            }

            if(m_fIgnoreText == FALSE)
            {
               if( FillBufferWithText() )
                  return TRUE;   // Stop parsing if buffer is full, and return control to client
            }

            m_fIgnoreText = FALSE;
         }
         else
         {
         LARGE_INTEGER li;
         ULARGE_INTEGER ul;
         li.LowPart = rh.recLen;
         li.HighPart = 0;
         if (FAILED(pStm->Seek(li,STREAM_SEEK_CUR,&ul)))
            return FALSE;
         }
      }
      else
      {
         if(rh.recType == 4057)
         {
            m_bHeaderFooter = TRUE;
         }
         else
         {
            m_bHeaderFooter = FALSE;
         }
         m_pParseContexts = new ParseContext( m_pParseContexts );
         if (!m_pParseContexts)
            return TRUE;
         m_pParseContexts->m_rh = rh;
      }

      while( m_pParseContexts && m_pParseContexts->m_nCur >= m_pParseContexts->m_rh.recLen )
      {
         Assert(  m_pParseContexts->m_nCur == m_pParseContexts->m_rh.recLen );
         ParseContext* pParseContext = m_pParseContexts;
         m_pParseContexts = m_pParseContexts->m_pNext;
         pParseContext->m_pNext = 0;
         delete pParseContext;
      }

   }
   while( m_pParseContexts && ( m_pParseContexts->m_nCur < m_pParseContexts->m_rh.recLen ) );

   return FALSE;
}


BOOL FileReader::FindNextSlide( DWord& offset )
{
   if( m_curSlideNum == 0 )
   {
      Assert( m_pLastUserEdit != NULL );
      offset = m_pPersistDirectory->GetPersistObjStreamPos( m_pLastUserEdit->documentRef );
      m_curSlideNum++;
      return TRUE;
   }
   else
   {
      uint4 curSlideNum = m_curSlideNum++; 
      SlideListChunk *pCur = m_pFirstChunk;
      while( pCur && ( curSlideNum > pCur->numInChunk ) )
      {
         curSlideNum -= pCur->numInChunk;
         pCur = pCur->pNext;
      }
      if( pCur == NULL )
         return FALSE;
      offset = m_pPersistDirectory->GetPersistObjStreamPos( pCur->refs[curSlideNum-1] );
      return TRUE;
   }
}

HRESULT FileReader::OpenTextFile( void )
{
   
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pstmTempFile);

    if( FAILED(hr) )
    {
        m_hr = hr;
        return STG_E_MEDIUMFULL;    // Leaving this alone - could break something 
    }
    else
    {
        FTrace("Created TempFile");
        m_hr = S_OK;
        return S_OK;
    }
}

HRESULT FileReader::ScanTextSpecInfo(char * pData, DWord nRd)
{
   HRESULT hr = S_OK;
    long lRunLength, lMask; 
    LCID lid, lidalt;

    long nStart = m_fcStart;

     for(DWord i = 0; i < nRd;)
     {
         lRunLength = *((long UNALIGNED *)(pData + i)); i += sizeof(long);
         lRunLength *= sizeof(WCHAR);
         if(i >= nRd)
             break;

         lMask = *((long UNALIGNED *)(pData + i)); i += sizeof(long);
         if(i >= nRd)
             break;
         
         if(lMask & 0x1) i += sizeof(short);
         if(i >= nRd)
             break;

         if(lMask & 0x2)
         {
            lid = MAKELCID(*((short UNALIGNED *)(pData + i)), SORT_DEFAULT);
            i += sizeof(short);
            //if(lRunLength > 2 && m_bHaveText)
            if(m_bHaveText)
            {
                hr = m_pLangRuns->Add((unsigned short)lid, nStart, nStart + lRunLength);
            }
         }

         if(lMask & 0x4)
         {
            lidalt = MAKELCID(*((short UNALIGNED *)(pData + i)), SORT_DEFAULT);
            i += sizeof(short);
         }

         nStart += lRunLength;
     }
     
     m_bHaveText = FALSE;
     return hr;
}

HRESULT FileReader::GetChunk(STAT_CHUNK * pStat)
{
   HRESULT hr = S_OK;
    if(m_pCurrentRun)
    {
        pStat->locale = m_pCurrentRun->m_lid;
        m_fcStart = m_pCurrentRun->m_fcStart;
        m_fcEnd = m_pCurrentRun->m_fcEnd;
        m_pCurrentRun = m_pCurrentRun->m_pNext;

        if ( 0 != m_pstmTempFile )
        {
            LARGE_INTEGER liOffset={m_fcStart, 0};
            hr = m_pstmTempFile->Seek(liOffset, STREAM_SEEK_SET, NULL);
            FTrace("Seeked TempFile to %u from beginning", liOffset);
        }
    }
    else
    {
        hr = FILTER_E_NO_MORE_TEXT;
    }
    return hr;
}

BOOL FileReader::ReadText( WCHAR *pBuff, ULONG size, ULONG *pSizeRet )
{
   ULONG ulReadCnt = min((long)size, m_fcEnd - m_fcStart);

    ULONG ulActualCnt;

    HRESULT hr = m_pstmTempFile->Read(pBuff, ulReadCnt, &ulActualCnt);
    FTrace("Read %u bytes from TempFile", ulActualCnt);
    if( FAILED(hr) )
    {
        *pSizeRet = 0;
        FTrace("Failed to read: 0x%08X", hr);
        if(0 != m_pstmTempFile)
        {
            FTrace("Closing TempFile");
            m_pstmTempFile->Release();
            m_pstmTempFile = 0;
        }
        return FALSE;
    }
    else if(ulActualCnt < ulReadCnt || ulActualCnt == 0)
    {

        FTrace("Should have read %u bytes", ulReadCnt);
        *pSizeRet = ulActualCnt/sizeof(WCHAR);
        m_fcStart += ulActualCnt;

        return TRUE;
    }
    else
    {
        *pSizeRet = ulActualCnt/sizeof(WCHAR);
        m_fcStart += ulActualCnt;
        return TRUE;
    }
}

HRESULT FileReader::ScanTextBuffer(void)
{
   HRESULT hr = S_OK;
    long lStart, lEnd;
    
    lStart = m_fcStart;
    lEnd = m_fcStart;

    for(DWORD i = 0; i < m_curTextLength; i++)
    {
        if(m_pCurText[i] >= 0x3000 && m_pCurText[i] < 0xFFEF)
        {
            // FE text
            if(m_bFE == FALSE)
            {
                // this is a start of FE text, flash non-FE text run
                if(lEnd - lStart > 2)
                {
                    hr = m_pLangRuns->Add((WORD)m_LCIDAlt, lStart, lEnd);
                    if(hr!= S_OK)
                        return hr;
                }
                lStart = m_fcStart + (i * sizeof(WCHAR));
                lEnd = lStart;
                m_bFE = TRUE;
            }
        }
        else
        {
            // non-FE text
            if(m_bFE == TRUE)
            {
                lStart = m_fcStart + (i * sizeof(WCHAR));
                lEnd = lStart;
                m_bFE = FALSE;
            }
        }
        
        lEnd += sizeof(WCHAR);
    }
    
    // flash what's left
    if(!m_bFE && (lEnd - lStart > 2))
        hr = m_pLangRuns->Add((WORD)m_LCIDAlt, lStart, lEnd);
    
    return hr;
}

HRESULT FileReader::ScanLidsForFE(void)
{
   CLidRun * pLangRun = m_pLangRuns;

    while(1)
    {
        if(pLangRun->m_lid == 0x411)
        {
            // J document
            if(m_pLangRuns)
            {
                DeleteAll6(m_pLangRuns);
                m_pLangRuns = new CLidRun(0, 0x7fffffff, 0x411, NULL, NULL);
            if (!m_pLangRuns)
               return E_OUTOFMEMORY;
            }

            break;
        }
        else if(pLangRun->m_lid == 0x412)
        {
            // Korean document
            if(m_pLangRuns)
            {
                DeleteAll6(m_pLangRuns);
                m_pLangRuns = new CLidRun(0, 0x7fffffff, 0x412, NULL, NULL);
            if (!m_pLangRuns)
               return E_OUTOFMEMORY;
            }
            break;
        }
        else if(pLangRun->m_lid == 0x404)
        {
            // Chinese document
            if(m_pLangRuns)
            {
                DeleteAll6(m_pLangRuns);
                m_pLangRuns = new CLidRun(0, 0x7fffffff, 0x404, NULL, NULL);
            if (!m_pLangRuns)
               return E_OUTOFMEMORY;
            }
            break;
        }
        else if(pLangRun->m_lid == 0x804)
        {
            // Chinese document
            if(m_pLangRuns)
            {
                DeleteAll6(m_pLangRuns);
                m_pLangRuns = new CLidRun(0, 0x7fffffff, 0x804, NULL, NULL);
            if (!m_pLangRuns)
               return E_OUTOFMEMORY;
            }
            break;
        }

        pLangRun = pLangRun->m_pNext;
        if(pLangRun == NULL)
        {
            break;
        }
    };
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\pp97rdr.h ===
#include <ole2.h>
#include <stdio.h>
#include <time.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>

#include "clidrun.h"

// Stolen from app\sertypes.h
// system dependent sizes
// system dependent sizes
typedef signed long     sint4;            // signed 4-byte integral value
typedef signed short    sint2;            // signed 4-byte integral value
typedef unsigned long   uint4;            // unsigned 4-byte integral value
typedef unsigned short  uint2;            //          2-byte
typedef char            bool1;            // 1-byte boolean
typedef unsigned char   ubyte1;           // unsigned byte value
typedef uint2           psrType;
typedef uint4           psrSize;          // each record is preceeded by 
                                          // pssTypeType and pssSizeType.
typedef uint2          psrInstance;
typedef uint2          psrVersion;
typedef uint4          psrReference;     // Saved object reference


#define PSFLAG_CONTAINER 0xFF             // If the version field of a record
                                          //  header takes on this value, the
                                          //  record header marks the start of
                                          //  a container.
// PowerPoint97 Record Header
typedef unsigned long DWord;

static BOOL ReadText( WCHAR* buffer, unsigned long bufferSize, unsigned long* pSizeRet );
// Returns TRUE if more text exists.  Fills buffer upto bufferSize.  Actual size used is
// pSizeRet.


struct RecordHeader
{
   psrVersion     recVer      : 4;                  // may be PSFLAG_CONTAINER
   psrInstance    recInstance : 12; 
   psrType        recType;
   psrSize        recLen;
};


struct PSR_CurrentUserAtom
{
   uint4  size;
   uint4  magic;  // Magic number to ensure this is a PowerPoint file.
   uint4  offsetToCurrentEdit;  // Offset in main stream to current edit field.
   uint2     lenUserName;
   uint2  docFileVersion;
   ubyte1 majorVersion;
   ubyte1 minorVersion;
};

struct PSR_UserEditAtom
{
   sint4  lastSlideID;    // slideID
   uint4  version;        // This is major/minor/build which did the edit
   uint4  offsetLastEdit; // File offset of last edit
   uint4  offsetPersistDirectory; // Offset to PersistPtrs for 
                                  // this file version.
   uint4  documentRef;
   uint4  maxPersistWritten;      // Addr of last persist ref written to the file (max seen so far).
   sint2  lastViewType;   // enum view type
};

struct PSR_SlidePersistAtom
{
   uint4  psrReference;
   uint4  flags;
   sint4  numberTexts;
   sint4  slideId;
   uint4  reserved;
};


typedef struct tagOEPlaceholderAtom
{
    uint4 placementId;
    ubyte1 placeholderId;
    ubyte1 size;
    ubyte1 pad1;
    ubyte1 pad2;
} OEPLACEHOLDERATOM, *LPOEPLACEHOLDERATOM;

#define CURRENT_USER_STREAM      L"Current User"
#define DOCUMENT_STREAM          L"PowerPoint Document"
#define HEADER_MAGIC_NUM         -476987297

const int PST_Document            = 1000;  // Document container
const int PST_Slide               = 1006;
const int PST_SlidePersistAtom    = 1011;
const int PST_OEPlaceholderAtom   = 3011;
const int PST_TextCharsAtom       = 4000;  // Unicode in text
const int PST_TextBytesAtom       = 4008;  // non-unicode text
const int PST_TextSpecInfo        = 4010;  // text special info atom
const int PST_TxSpecialInfoAtom   = 4009;  // text special info atom (In Environment)
const int PST_CString             = 4026;
const int PST_UserEditAtom        = 4085;
const int PST_BinaryTagData       = 5003;
const int PST_PersistPtrIncrementalBlock = 6002; // Incremental diffs on persists
const int PST_Comment10           = 12000;

// These numbers are taken from examining the PowerPoint file
#define D_MASTERDATEAREA 7
#define D_MASTERNUMBERAREA 8
#define D_MASTERFOOTER 9
#define D_MASTERHEADER 10
#define D_GENERICTEXTOBJECT 11
#define END_OF_SEARCH_FOR_LID 5


class PPSPersistDirectory;

struct ParseContext
{
   ParseContext(ParseContext *pNext) : m_pNext(pNext), m_nCur(0) {}
   ~ParseContext()
   {
        if(m_pNext)
            delete m_pNext;
   }

   RecordHeader  m_rh;
   uint4         m_nCur;
   ParseContext *m_pNext;
};

const int SLIDELISTCHUNKSIZE=32;

struct SlideListChunk
{
   SlideListChunk( SlideListChunk* next, psrReference newOne ) :
      pNext( next ), numInChunk(1) { refs[0] = newOne; }
   
   ~SlideListChunk()
   {
        if(pNext)
            delete pNext;
   }

   SlideListChunk *pNext;
   DWord numInChunk;
   psrReference refs[SLIDELISTCHUNKSIZE];
};

class OleObjectIterator;

class FileReader
{
public:
   FileReader(IStorage *pStg);
   ~FileReader();

   BOOL ReadText( WCHAR *pBuff, ULONG size, ULONG *pSizeRet );
   // Reads next size chars from file.  Returns TRUE if there is more
   // text to read.

   BOOL IsPowerPoint() { return m_isPP; } // Returns true if this is a PowerPoint '97 file.

   HRESULT ReadPersistDirectory();
   BOOL PPSReadUserEditAtom( DWord offset, PSR_UserEditAtom& userEdit );
   void ReadSlideList();
   HRESULT GetNextEmbedding(IStorage ** ppstg);
   LCID GetLCD(){return m_LCID;}
   HRESULT ScanText(void);
   HRESULT GetChunk(STAT_CHUNK * pStat);
   HRESULT ScanLidsForFE(void);
   HRESULT GetErr(){return m_hr;}



protected:
   BOOL ReadCurrentUser(IStream *pStm);
   void *ReadRecord( RecordHeader& rh );

   BOOL Parse();
   BOOL ContainsSubRecords(const RecordHeader &rh);
   IStream *GetDocStream();
   BOOL DoesClientRead( psrType type ) { return FALSE; }
   void ReleaseRecord( RecordHeader& rh, void* diskRecBuf );
   DWord ParseForSlideLists();
   void AddSlideToList( psrReference refToAdd );
   BOOL StartParse( DWord offset );
   BOOL FillBufferWithText();
   BOOL FindNextSlide( DWord& offset );
   DWord ParseForLCID();
   HRESULT OpenTextFile( void );
   HRESULT ScanTextSpecInfo(char * pData, DWord nRd);
   HRESULT ScanTextBuffer(void);


private:
   PSR_CurrentUserAtom  m_currentUser;
   IStream *            m_pDocStream;
   IStorage *           m_pPowerPointStg;
   BOOL                 m_isPP;
   ParseContext*        m_pParseContexts;

   WCHAR*               m_pCurText;
   unsigned long        m_curTextPos;
   unsigned long        m_curTextLength;

   PSR_UserEditAtom*    m_pLastUserEdit;
   PPSPersistDirectory* m_pPersistDirectory;
   SlideListChunk*      m_pFirstChunk;
   int                  m_curSlideNum;

   WCHAR*               m_pClientBuf;
   unsigned long        m_clientBufSize;
   unsigned long        m_clientBufPos;
   ULONG*               m_pSizeRet;

   OleObjectIterator*   m_oleObjectIterator;
   BOOL                 m_bEndOfEmbeddings;
   BOOL                 m_bHaveText;
   BOOL                 m_bFEDoc;
   BOOL                 m_bFE;
   LCID                 m_LCID;
   LCID                 m_LCIDAlt;
   IStream *            m_pstmTempFile;
   BOOL                 m_fIgnoreText;
   BOOL                 m_bHeaderFooter;
   int                  m_nTextCount;
   long                 m_fcStart;
   long                 m_fcEnd;
   CLidRun *            m_pLangRuns;
   CLidRun *            m_pCurrentRun;
   HRESULT              m_hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\offfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1993.
//
//  File:       COfficeFLT.CXX
//
//  Contents:   C and Cxx Filter
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include <assert.h>
#include <crtdbg.h>

#include "OffFilt.hxx"
#include "filtrace.hxx"

//KYLEP
#include <ntquery.h>
#include <filterr.h>

#define INDEX_EMBEDDINGS

#if defined FOR_MSOFFICE
# include "shtole32.hxx"

#endif

#ifdef _DEBUG 
static _CrtMemState state;
#endif


extern "C" GUID CLSID_COfficeIFilter;

GUID const guidStorage = PSGUID_STORAGE;

GUID guidWord6 = { 0x00020900,
                   0x0000,
                   0x0000,
                   0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidWord8 = { 0x00020906,
                   0x0000,
                   0x0000,
                   0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidExcel5 = { 0x00020810,
                    0x0000,
                    0x0000,
                    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidExcel8 = { 0x00020820,
                    0x0000,
                    0x0000,
                    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidExcel5Chart = { 0x00020811,
                         0x0000,
                         0x0000,
                         0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidExcel8Chart = { 0x00020821,
                         0x0000,
                         0x0000,
                         0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidPowerPoint4 = { 0x00044851,
                         0x0000,
                         0x0000,
                         0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

GUID guidPowerPoint7Template = { 0xEA7BAE71,
                                 0xFB3B,
                                 0x11CD,
                                 0xA9, 0x03, 0x00, 0xAA, 0x00, 0x51, 0x0E, 0xA3 };

GUID guidPowerPoint8Template = { 0x64818D11,
                                 0x4F9B,
                                 0x11CF,
                                 0x86, 0xEA, 0x00, 0xAA, 0x00, 0xB9, 0x29, 0xE8 };

GUID guidPowerPoint7Show = { 0xEA7BAE70,
                             0xFB3B,
                             0x11CD,
                             0xA9, 0x03, 0x00, 0xAA, 0x00, 0x51, 0x0E, 0xA3 };

GUID guidPowerPoint8Show = { 0x64818D10,
                             0x4F9B,
                             0x11CF,
                             0x86, 0xEA, 0x00, 0xAA, 0x00, 0xB9, 0x29, 0xE8 };

GUID guidOfficeBinder = { 0x59850400,
                          0x6664,
                          0x101B,
                          0xB2, 0x1C, 0x00, 0xAA, 0x00, 0x4B, 0xA9, 0x0B };

#ifdef FILTRACE
FNOUTPUT *g_fnpOutput = 0;
#endif

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::COfficeIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

COfficeIFilter::COfficeIFilter()
        : _ulChunkID(0),
          _pOfficeFilter(0),
          _pwszFileName( 0 ),
          _pStg( 0 ),
          _fFirstInit( TRUE ),
          _pFilterEmbed( 0 ),
          _pStorageEmbed( 0 ),
          _fBinder( FALSE ),
          _fContents(FALSE),
          _fLastText(FALSE),
          _pAttrib( 0 ),
          _cAttrib( 0 ),
          _fLastChunk( FALSE )
{
    //
    // Since the Office IFilterStream doesn't provide the language specifier, just use the
    // default locale.
    //

#ifdef _DEBUG
   
    //_CrtMemState state;
   
   int tmpDbgFlag = 0;

//   tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
   
   tmpDbgFlag |= _CRTDBG_ALLOC_MEM_DF;      /* Turn on debug allocation */
   //tmpDbgFlag |= _CRTDBG_CHECK_ALWAYS_DF;   /* Check heap every alloc/dealloc */
   //tmpDbgFlag |= _CRTDBG_CHECK_CRT_DF;      /* Leak check/diff CRT blocks */
   tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;     /* Leak check at program exit */

   //_CrtSetDbgFlag(tmpDbgFlag);

   //_CrtMemCheckpoint(&state );

#endif

   _locale = GetSystemDefaultLCID();
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::~COfficeIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

COfficeIFilter::~COfficeIFilter()
{
    if ( 0 != _pwszFileName )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }
    
    if ( 0 != _pStorageEmbed )
    {
        _pStorageEmbed->Release();
        _pStorageEmbed = 0;
    }

    if ( 0 != _pFilterEmbed )
    {
        _pFilterEmbed->Release();
        _pFilterEmbed = 0;
    }

#if defined FOR_MSOFFICE
    if(_pAttrib)
    {
        for ( unsigned i = 0; i < _cAttrib; i++ )
        {
            if ( _pAttrib[i].psProperty.ulKind == PRSPEC_LPWSTR )
                delete [] _pAttrib[i].psProperty.lpwstr;
        }
        delete [] _pAttrib;
    }
#else
    if(_pAttrib) delete [] _pAttrib;
#endif

    _pAttrib = NULL;

    if (0 != _pStg )
    {
        _pStg->Release();
        _pStg = 0;
    }

    if ( 0 != _pOfficeFilter )
    {
        _pOfficeFilter->Unload();
        _pOfficeFilter->Release();
        delete _pOfficeFilter;
        _pOfficeFilter = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array aAttributes
//              [aAttributes] -- array of attributes
//              [pfBulkyObject] -- indicates whether this object is a
//                                 bulky object
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Init( ULONG grfFlags,
                                              ULONG cAttributes,
                                              FULLPROPSPEC const * aAttributes,
                                              ULONG * pFlags )
{
    if ( 0 == _pOfficeFilter) 
        {
                return E_FAIL;
        }

    if( cAttributes > 0 && 0 == aAttributes)
    {
        return E_INVALIDARG;
    }

    _fLastText = FALSE;
    _fLastChunk = FALSE;

    //
    // On first call to ::Init, filter will already be loaded.
    //

    SCODE sc = S_OK;

    if ( _fFirstInit )
        _fFirstInit = FALSE;
    else
    {
        sc = _pOfficeFilter->Unload();

        if ( FAILED(sc) )
            return sc;

        if ( 0 != _pStg )
            sc = _pOfficeFilter->LoadStg( _pStg );
        else if ( 0 != _pwszFileName )
                {
                        int nAttemps = 0;
                        do{
                                sc = _pOfficeFilter->Load( (WCHAR *)_pwszFileName );
                        }while(++nAttemps < 1000 && sc == STG_E_LOCKVIOLATION);
                }
        else
                {
            //assert(0);
                        sc = E_FAIL;
                }

        if ( FAILED(sc) )
            return sc;
    }

    _ulChunkID = 1;
    _ulFlags = grfFlags;

    if ( 0 != _pFilterEmbed )
    {
        _pFilterEmbed->Release();
                _pFilterEmbed = 0;
        if(_pStorageEmbed) _pStorageEmbed->Release();
        _pStorageEmbed = 0;
    }

    if( cAttributes > 0 )
    {
        //
        // Error checking
        //

        if ( 0 == aAttributes )
            return E_INVALIDARG;

        _fContents = FALSE;

        //
        // Don't use CFullPropSpec to keep query.dll from being pulled in.
        //

        if(_pAttrib)
        {
            for ( unsigned i = 0; i < _cAttrib; i++ )
            {
                if ( _pAttrib[i].psProperty.ulKind == PRSPEC_LPWSTR )
                    delete [] _pAttrib[i].psProperty.lpwstr;
            }
            delete [] _pAttrib;
        }

        _pAttrib = new FULLPROPSPEC [cAttributes];

        if ( 0 == _pAttrib )
            sc = E_OUTOFMEMORY;
        else
        {
            _cAttrib = cAttributes;

            for ( unsigned i = 0; SUCCEEDED(sc) && i < cAttributes; i++ )
            {
                if ( aAttributes[i].psProperty.ulKind == PRSPEC_PROPID &&
                     aAttributes[i].psProperty.propid == PID_STG_CONTENTS &&
                     aAttributes[i].guidPropSet == guidStorage )
                {
                    _fContents = TRUE;
                }

                _pAttrib[i] = aAttributes[i];

                if ( _pAttrib[i].psProperty.ulKind == PRSPEC_LPWSTR )
                {
                    unsigned cc = wcslen( aAttributes[i].psProperty.lpwstr ) + 1;
                    _pAttrib[i].psProperty.lpwstr = new WCHAR [cc];

                    if ( 0 == _pAttrib[i].psProperty.lpwstr )
                        sc = E_OUTOFMEMORY;
                    else
                        memcpy( _pAttrib[i].psProperty.lpwstr,
                                aAttributes[i].psProperty.lpwstr,
                                cc * sizeof(WCHAR) );
                }
            }
        }
    }
    else 
    {
#ifdef FILTRACE
        g_fnpOutput = (FNOUTPUT *)aAttributes; // We are sneaking in the trace function
#endif
        if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
        {
            _fContents = TRUE;
        }
        else
            _fContents = FALSE;
    }

    *pFlags = IFILTER_FLAGS_OLE_PROPERTIES;
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- for chunk information
//
//  History:    08-Jan-97  KyleP        Created
//                              20-July-97 VKrasnov             Updated for embeddings support
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::GetChunk( STAT_CHUNK * pStat )
{
    if ( 0 == _pOfficeFilter ) 
        return FILTER_E_ACCESS;

    SCODE sc = S_OK;

    if(_fLastChunk)
    {
      return FILTER_E_END_OF_CHUNKS;
    }

    pStat->breakType = CHUNK_EOW;

        if (_fContents && _pOfficeFilter->GetChunk(pStat) == S_OK)
    {
        //
        // Text of current level:
        //

        pStat->idChunk = _ulChunkID;
        pStat->flags   = CHUNK_TEXT;
        //pStat->locale  = _locale; // is set in _pOfficeFilter->GetChunk
        pStat->attribute.guidPropSet = guidStorage;
        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
        
        // we need to set breakType to something other then CHUNK_NO_BREAK
        // because we change the language, otherwise locale will be taken from
        // the previous chunk

        //pStat->breakType = CHUNK_EOW;
        pStat->idChunkSource = _ulChunkID;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;
    }
    else
    {
        //
        // Text from embedding.
        //

        if ( 0 != _pFilterEmbed )
        {
            //
            // Continue with current embedding.
            //

            sc = _pFilterEmbed->GetChunk( pStat );
            pStat->idChunk = _ulChunkID;
            pStat->idChunkSource = _ulChunkID;

            // QFE 5747: The embedding's GetChunk can also return FILTER_E_ACCESS
            // without being recoverable.  We should give up and release it here.
            // REVIEW:

            if ( sc == FILTER_E_END_OF_CHUNKS || sc == FILTER_E_ACCESS)
            {
                if(_pFilterEmbed) _pFilterEmbed->Release();
                _pFilterEmbed = 0;

                if(_pStorageEmbed) _pStorageEmbed->Release(); 
                _pStorageEmbed = 0;
            }
        }

        if ( 0 == _pFilterEmbed )
        {
            //
            // Loop over get next embedding but only if the embedding is unavailable.  (QFE nnnn)
            //

            do // while (sc == FILTER_E_EMBEDDING_UNAVAILABLE)
            {
                //
                // Get next embedding
                //

                sc = _pOfficeFilter->GetNextEmbedding( &_pStorageEmbed );

                if ( sc == OLEOBJ_E_LAST || sc == STG_E_FILENOTFOUND || sc == STG_E_DOCFILECORRUPT)
                {
                    sc = FILTER_E_END_OF_CHUNKS;
                    _fLastChunk = TRUE;
                }
                else if ( SUCCEEDED(sc) )
                {
                    try
                    {
                        sc = BindIFilterFromStorage( _pStorageEmbed, 0, (void **) &_pFilterEmbed );
                    }
                    catch( ... )
                    {
                        sc = E_FAIL;
                    }

                    if ( FAILED(sc) )
                    {
                        if(_pStorageEmbed) _pStorageEmbed->Release();
                        _pStorageEmbed = 0;

                        if ( sc == STG_E_DOCFILECORRUPT)
                        {
                            sc = FILTER_E_END_OF_CHUNKS;
                            _fLastChunk = TRUE;
                        }
                        else
                        {
                            sc = FILTER_E_EMBEDDING_UNAVAILABLE;
                        }
                    }
                    else
                    {
                        ULONG ulReserved;

                        sc = _pFilterEmbed->Init( _ulFlags,
                                                  _cAttrib,
                                                  (FULLPROPSPEC const *)_pAttrib,
                                                  &ulReserved );

                        if ( FAILED(sc) )
                        {
                            if(_pFilterEmbed) _pFilterEmbed->Release();
                            _pFilterEmbed = 0;

                            if(_pStorageEmbed) _pStorageEmbed->Release();
                            _pStorageEmbed = 0;
                        }
                        else
                        {
                            sc = _pFilterEmbed->GetChunk( pStat );
                            pStat->idChunk = _ulChunkID;
                                                        pStat->idChunkSource = _ulChunkID;
                            pStat->breakType = CHUNK_EOP;

                            if ( FAILED(sc) && sc != FILTER_E_EMBEDDING_UNAVAILABLE )
                            {
                                if(_pFilterEmbed) _pFilterEmbed->Release();
                                _pFilterEmbed = 0;

                                if(_pStorageEmbed) _pStorageEmbed->Release();
                                _pStorageEmbed = 0;
                            }
                        }
                    }
                }
                else
                {
                    _fLastChunk = TRUE;
                    // Return whatever error is returned by GetNextEmbedding
                }
            } while (sc == FILTER_E_EMBEDDING_UNAVAILABLE);
        }

        if ( FAILED(sc) && sc != FILTER_E_END_OF_CHUNKS )
        {
            sc = FILTER_E_EMBEDDING_UNAVAILABLE;
        }
    }

    _ulChunkID++;

    if ( SUCCEEDED(sc) )
    {
        _fLastText = FALSE;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of characters in buffer
//              [awcBuffer] -- buffer for text
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::GetText( ULONG * pcwcBuffer,
                                                 WCHAR * awcBuffer )
{
    if ( 0 != _pFilterEmbed )
        return _pFilterEmbed->GetText( pcwcBuffer, awcBuffer );

    if ( !_fContents || !_pOfficeFilter ) // We can set _pOfficeFilter to NULL.  Look for it
    {
        *pcwcBuffer = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( _fLastText )
        return FILTER_E_NO_MORE_TEXT;

    ULONG cwcBufferSav = *pcwcBuffer;
    *pcwcBuffer *= sizeof(WCHAR);

    SCODE sc;

    try
    {
        sc = _pOfficeFilter->ReadContent( (void *)awcBuffer,
                                                *pcwcBuffer,
                                                pcwcBuffer );

        *pcwcBuffer /= sizeof(WCHAR);
        if (*pcwcBuffer > cwcBufferSav) // Something has gone wrong
        {
            *pcwcBuffer = 0;
            _pOfficeFilter->Unload();
            delete _pOfficeFilter;
            _pOfficeFilter = NULL;
            return E_FAIL;
        }

        // post-mortem

        for(ULONG i = 0; i < *pcwcBuffer; i++)
        {
            switch(awcBuffer[i])
            {
            case 0x0007:
                awcBuffer[i] = 0x002c;
                break;
            case 0x000d:
                if ( (i+1) < *pcwcBuffer)
                {
                   if(awcBuffer[i + 1] != 0x000a)
                   {
                       awcBuffer[i] = 0x0020;
                   }
                }
                else
                {
                   awcBuffer[i] = 0x0020;
                }
                break;
            case 0xf0d4: // Trademark; symbol font (QFE 5173)
                awcBuffer[i] = 0x2122;
                break;
            case 0xf0d2: // Registered symbol: symbol font (QFE 5173)
                awcBuffer[i] = 0x00ae;
                break;
            case 0xf0d3: // Copyright symbol: symbol font (QFE 5173)
                awcBuffer[i] = 0x00a9;
                break;
            default:
                break;
            }
        }

        switch ( sc )
        {
        case S_OK:
            break;

        case FILTER_S_LAST_TEXT:
            _fLastText = TRUE;
            break;


        default:
        {
            _fLastText = TRUE;
            sc = FILTER_S_LAST_TEXT;
        }
            break;
        }

        return sc;
    }
    catch(...)
    {
        // something very wrong happend inside the filter
        // just delete the filter and quit (even don't upload and release 
        // - it may cause AV)
        delete _pOfficeFilter;
        _pOfficeFilter = NULL;
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::GetValue, public
//
//  Synopsis:   Not implemented for the text filter
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker for text indicated
//
//  Arguments:  [origPos] -- location of text
//              [riid]    -- IID of interfaace
//              [ppunk]   -- Pointer returned here
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::BindRegion( FILTERREGION origPos,
                                                    REFIID riid,
                                                    void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_COfficeIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pwszFileName] -- the file name
//              [dwMode]      -- the mode to load the file in
//
//  History:    08-Jan-97  KyleP        Created
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Load(LPCWSTR pwszFileName, DWORD dwMode)
{
    if ( 0 == pwszFileName )
        return E_INVALIDARG;

    if ( 0 != _pwszFileName )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    if ( 0 != _pStorageEmbed )
    {
        _pStorageEmbed->Release();
        _pStorageEmbed = 0;
    }

    if ( 0 != _pFilterEmbed )
    {
        _pFilterEmbed->Release();
        _pFilterEmbed = 0;
    }

    if ( 0 != _pStg )
    {
        _pStg->Release();
        _pStg = 0;
    }

    _stream.Free();

    SCODE sc = S_OK;
    unsigned cc = 0;

    try
    {
        //
        // Squirrel away filename.
        //

        cc = wcslen( pwszFileName ) + 1;
        _pwszFileName = new TCHAR [cc];

        if ( 0 == _pwszFileName )
            sc = E_OUTOFMEMORY;
        else
        {
            wcscpy( _pwszFileName, pwszFileName );

            //_RPTF1(_CRT_WARN, "\n Filtering: %S\n", pwszFileName);

            //
            // Figure out what filter to load.
            //

            GUID classid;

                        IStorage *pStgFromT;
                        STATSTG statstg;
                        int nAttemps = 0;
                        do{
                                sc = StgOpenStorage(_pwszFileName, NULL, STGM_READ | STGM_DIRECT | 
                                           STGM_SHARE_DENY_WRITE, NULL, 0, &pStgFromT);
                
                if(sc == STG_E_LOCKVIOLATION || sc == STG_E_SHAREVIOLATION)
                {
                    // some delay probably can help
                    // wait a second or so...
                    for (int i = 0; i<10000; i++)
                        for(int j = 0; j<1000; j++) {};
                }
                        
            }while(++nAttemps < 10 && (sc == STG_E_LOCKVIOLATION || sc == STG_E_SHAREVIOLATION));

                        if(SUCCEEDED(sc) && pStgFromT)
                        {
                                sc = pStgFromT->Stat( &statstg, STATFLAG_NONAME );
                                classid = statstg.clsid;
                if(SUCCEEDED(sc) && classid.Data1 == 0)
                {
                    sc = GetClassFile ( _pwszFileName, &classid );
                }
                        }
                        else
                        {
                                /*
                                        This value of sc can get returned...MK_E_CANTOPENFILE isn't a valid answer
                                        Map the sc value to a returnable value
                                */
                                switch(sc)
                                {
                                case STG_E_ACCESSDENIED:
                                        sc = FILTER_E_PASSWORD;
                                        break;
                                case STG_E_INSUFFICIENTMEMORY:
                                        sc = E_OUTOFMEMORY;
                                        break;
                                /* Office Bug 132396:  Don't bother with GetClassFile unless it's actually a Structured
                                   file (it was returning a GUID based on the extension, not the content.
                                case STG_E_FILEALREADYEXISTS:
                                        sc = GetClassFile( _pwszFileName, &classid );
                                        if(FAILED(sc))
                                                sc = FILTER_E_ACCESS;
                                        break;
                                */
                                /*
                                case STG_E_FILENOTFOUND:
                                case STG_E_LOCKVIOLATION:
                                case STG_E_SHAREVIOLATION:
                                case STG_E_TOOMANYOPENFILES:
                                case STG_E_INVALIDNAME:
                                case STG_E_INVALIDPOINTER:
                                case STG_E_INVALIDFLAG:
                                case STG_E_INVALIDFUNCTION:
                                case STG_E_OLDFORMAT:
                                case STG_E_NOTSIMPLEFORMAT:
                                case STG_E_OLDDLL:
                                case STG_E_PATHNOTFOUND:
                                */
                                default:
                                        sc = FILTER_E_ACCESS;
                                        break;
                                }
//                sc = GetClassFile ( _pwszFileName, &classid );
                        }

                        if(pStgFromT)
                        {
                                pStgFromT->Release();
                                pStgFromT= 0;
                        }

                        _fDidInit = FALSE;

            if ( SUCCEEDED(sc) )
            {
                sc = LoadOfficeFilter( classid );

                if ( 0 == _pOfficeFilter )
                {
                    if ( SUCCEEDED(sc) )
                        sc = E_OUTOFMEMORY;
                    else
                                        {
                                                sc = FILTER_E_UNKNOWNFORMAT;
                                        }
                }
                else if ( !_fDidInit )
                {
                    _pOfficeFilter->AddRef();
                                        int nAttemps = 0;
                                        do{
                                                sc = _pOfficeFilter->Load( (WCHAR *)_pwszFileName );
                                        }while(++nAttemps < 1000 && sc == STG_E_LOCKVIOLATION);
                }
            }
        }
    }
    catch( ... )
    {
                sc = E_FAIL;
    }

    if(FAILED(sc) && _pOfficeFilter)
    {
        _pOfficeFilter->Release();
        delete _pOfficeFilter;
        _pOfficeFilter = NULL;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Save(LPCWSTR pwszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::SaveCompleted(LPCWSTR pwszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppwszFileName] -- where the copied string is returned.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::GetCurFile(LPWSTR * ppwszFileName)
{
    if ( _pwszFileName == 0 )
        {
                assert(0);
                return E_FAIL;
        }

    SCODE sc = S_OK;

    unsigned cc = wcslen( _pwszFileName ) + 1;
    *ppwszFileName = (WCHAR *)CoTaskMemAlloc(cc*sizeof(WCHAR));

    if ( *ppwszFileName )
        wcscpy( *ppwszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::InitNew, public
//
//  Returns:    Fail, since IFilter cannot be used to create new objects.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::InitNew( IStorage *pStg )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Load, public
//
//  Arguments:  [pStg] -- IStorage containing object.
//
//  Returns:    Status of load
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Load( IStorage *pStg )
{
    if ( 0 == pStg )
        return E_INVALIDARG;

    if ( 0 != _pwszFileName )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    if ( 0 != _pStorageEmbed )
    {
        _pStorageEmbed->Release();
        _pStorageEmbed = 0;
    }

    if ( 0 != _pFilterEmbed )
    {
        _pFilterEmbed->Release();
        _pFilterEmbed = 0;
    }

    if ( 0 != _pStg )
    {
        _pStg->Release();
        _pStg = 0;
    }

    SCODE sc = S_OK;

    try
    {
        //
        // Figure out what filter to load.
        //
        STATSTG statstg;
        sc = pStg->Stat( &statstg, STATFLAG_NONAME );

        if ( SUCCEEDED(sc) )
        {
            sc = LoadOfficeFilter( statstg.clsid );

            if ( 0 == _pOfficeFilter )
            {
                if ( SUCCEEDED(sc) )
                    sc = E_OUTOFMEMORY;
                else
                    sc = FILTER_E_UNKNOWNFORMAT;
            }
            else
            {
                _pOfficeFilter->AddRef();
                sc = _pOfficeFilter->LoadStg( pStg );

                if ( FAILED( sc ) )
                {
                    _pOfficeFilter->Unload();
                    _pOfficeFilter->Release();
                    delete _pOfficeFilter;
                    _pOfficeFilter = 0;
                }
            }
        }
    }
    catch( ... )
    {
        sc = E_FAIL;
    }

    if ( SUCCEEDED(sc) )
    {
        _pStg = pStg;
        _pStg->AddRef();
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Load, public
//
//  Arguments:  [pStream] -- IStream containing object.
//
//  Returns:    Status of load
//
//  History:    28-Oct-01  dlee        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Load( IStream *pStream )
{
    if ( 0 == pStream )
        return E_INVALIDARG;

    if ( 0 != _pwszFileName )
    {
        delete _pwszFileName;
        _pwszFileName = 0;
    }

    if ( 0 != _pFilterEmbed )
    {
        _pFilterEmbed->Release();
        _pFilterEmbed = 0;
    }

    if ( 0 != _pStorageEmbed )
    {
        _pStorageEmbed->Release();
        _pStorageEmbed = 0;
    }

    if ( 0 != _pStg )
    {
        _pStg->Release();
        _pStg = 0;
    }

    _stream.Set( pStream );

    IStorage * pStg;
    SCODE sc = StgOpenStorageOnILockBytes( &_stream,
                                           0,
                                           STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE,
                                           0,
                                           0,
                                           &pStg );

    if ( FAILED( sc ) )
    {
        _stream.Free();
        return sc;
    }

    sc = Load( pStg );

    pStg->Release();

    if ( FAILED( sc ) )
        _stream.Free();

    return sc;
} //Load

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::Save, public
//
//  Returns:    Fail, since IFilter cannot be used to write/save objects.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::Save( IStorage *pStgSave,BOOL fSameAsLoad )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::SaveCompleted, public
//
//  Returns:    Fail, since IFilter cannot be used to write/save objects.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::SaveCompleted( IStorage *pStgNew )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::HandsOffStorage, public
//
//  Returns:    Fail. We can't take our hands off storage.
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilter::HandsOffStorage()
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfficeIFilter::LoadOfficeFilter, private
//
//  Synopsis:   Helper routine to load office filter.
//
//  Arguments:  [classid] -- Class of object
//
//  History:    08-Jan-97  KyleP        Created
//
//----------------------------------------------------------------------------

HRESULT COfficeIFilter::LoadOfficeFilter( GUID const & classid )
{
    HRESULT sc = S_OK;

    if ( 0 != _pOfficeFilter )
    {
        _pOfficeFilter->Unload();
        _pOfficeFilter->Release();
        delete _pOfficeFilter;
        _pOfficeFilter = 0;
    }

    switch ( classid.Data1)
    {
    case 0x00020900:
    #if 0
        //
        // This code appears to be obsolete in the final product.
        //
        //         KyleP -- 8 Jan, 1997
        //

        if ( classid == guidWord6 )
        {
            //
            // Have to use ::Load to distinguish W6 from W97
            //

            _pOfficeFilter = new CWord8Stream();

            if ( 0 != _pOfficeFilter )
            {
                _pOfficeFilter->AddRef();
                
                                int nAttemps = 0;
                                do{
                                        sc = _pOfficeFilter->Load( (WCHAR *)_pwszFileName );
                                }while(++nAttemps < 1000 && sc == STG_E_LOCKVIOLATION);


                if ( FAILED(sc) )
                {
                    if ( sc == FILTER_E_FF_INCORRECT_FORMAT )
                    {
                        _pOfficeFilter->Release();
                        delete _pOfficeFilter;

                        _pOfficeFilter = new CWord6Stream();
                        sc = S_OK;
                    }
                    else
                    {
                        _pOfficeFilter->Release();
                        delete _pOfficeFilter;
                        _pOfficeFilter = 0;
                    }
                }
                else
                    fDidInit = TRUE;
            }
        }
    #else
        if ( classid == guidWord6 )
            _pOfficeFilter = new CWord6Stream();
    #endif
        break;

    case 0x00020906:
        if ( classid == guidWord8 )
            _pOfficeFilter = new CWord8Stream();
        break;

    case 0x00020810:
        if ( classid == guidExcel5 )
            _pOfficeFilter = new CExcelStream();
        break;

    case 0x00020811:
        if ( classid == guidExcel5Chart )
            _pOfficeFilter = new CExcelStream();
        break;

    case 0x00020820:
        if ( classid == guidExcel8 )
            _pOfficeFilter = new CExcelStream();
        break;

    case 0x00020821:
        if ( classid == guidExcel8Chart )
            _pOfficeFilter = new CExcelStream(); 
        break;

    case 0x00044851:
        if ( classid == guidPowerPoint4 )
            _pOfficeFilter = new CPowerPointStream();
        break;

    case 0x64818D10:
        if ( classid == guidPowerPoint8Show )
                {
            _pOfficeFilter = new CPowerPoint8Stream();
                        
#if (0)
                        _pOfficeFilter->AddRef();
                        
                        if(0 != _pStg)
                        {
                                sc = _pOfficeFilter->LoadStg( _pStg );
                        }
                        else if(0 != _pwszFileName)
                        {
                                int nAttemps = 0;
                                do{
                                        sc = _pOfficeFilter->Load( (WCHAR *)_pwszFileName );
                                }while(++nAttemps < 1000 && sc == STG_E_LOCKVIOLATION);
                        }
                        else
                                sc = E_FAIL;

                        if ( FAILED(sc) )
                        {
                                if ( sc == FILTER_E_FF_INCORRECT_FORMAT )
                                {
                                        _pOfficeFilter->Release();
                                        delete _pOfficeFilter;

                                        _pOfficeFilter = new CPowerPointStream();
                                        sc = S_OK;
                                }
                                else
                                {
                                        _pOfficeFilter->Release();
                                        delete _pOfficeFilter;
                                        _pOfficeFilter = 0;
                                }
                        }
                        else
                                _fDidInit = TRUE;

#endif

                }
        break;

    case 0x64818D11:
        if ( classid == guidPowerPoint8Template )
            _pOfficeFilter = new CPowerPoint8Stream();
        break;

    case 0xEA7BAE71:
        if ( classid == guidPowerPoint7Template )
            _pOfficeFilter = new CPowerPointStream();
        break;

    case 0xEA7BAE70:
        if ( classid == guidPowerPoint7Show )
            _pOfficeFilter = new CPowerPointStream();
        break;

    #if 0
        //
        // Binder seems flaky, and we don't need it.
        //
        //         KyleP -- 8-Jan-1997
        //
    case 0x59850400:
        if ( classid == guidOfficeBinder )
        {
            _fBinder = TRUE;
            _pOfficeFilter = new CBinderStream();
        }
        break;
    #endif

    default:
        _pOfficeFilter = 0;
        sc = FILTER_E_UNKNOWNFORMAT;
        break;
    }
    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\findfast\oleobjit.cpp ===
/******************************************************************************

   OleObjectIterator 

*****************************************************************************/
#include "pp97rdr.h"
//KYLEP
#include "OleObjIt.h"
#include "zlib.h"
#include <winnls.h>
#include <assert.h>

//      OleObjectIterator Class

OleObjectIterator::OleObjectIterator(IStorage* iStore):m_iStore(iStore)
{
        m_pRefListHead = NULL;

        if(!Initialize())
                m_iStore = NULL;
        else
                m_iStore->AddRef();
}

OleObjectIterator::~OleObjectIterator()
{ 
        if(m_iStore)
                m_iStore->Release();
        delete m_pRefListHead;
}

// Make a list of all containers in the Powerpoint Document Stream.

BOOL OleObjectIterator::Initialize(void)
{
        // Find the offset to last edit.

        IStream *pStm = NULL;
        PSR_CurrentUserAtom currentUser;
        PSR_UserEditAtom        userEdit;
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        HRESULT hr;
        RecordHeader rh;
        unsigned long   rd;

        PPT8Ref *pRef = NULL;

        unsigned long   Reference;  //  top 12 bits is the number of following, sequential offsets.
                                                //      lower 20 bits is the starting reference number
        unsigned long   numOfSeqOffsets;
        unsigned long   startRefNum;
        unsigned long   offset;
        LARGE_INTEGER liLast;
        BOOL fFirstLoop = TRUE;
        
        hr = m_iStore->OpenStream( CURRENT_USER_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &pStm );
        if( !SUCCEEDED(hr))
                return  FALSE;

        hr = pStm->Read(&rh, sizeof(rh), &rd);  // Read in the 8 bytes of the record header.
        if( !SUCCEEDED(hr) || rh.recType != PST_CurrentUserAtom)
        {
                pStm->Release();
                return  FALSE;
        }       
        hr = pStm->Read(&currentUser, sizeof(currentUser), &rd);
        pStm->Release();
        if( !SUCCEEDED(hr))
        {
                return  FALSE;
        }       

        // Open the Document Stream
        
        hr = m_iStore->OpenStream( DOCUMENT_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &m_pDocStream );
        if( !SUCCEEDED(hr))
                return  FALSE;

        li.LowPart = currentUser.offsetToCurrentEdit;
        li.HighPart = 0;
        hr = m_pDocStream->Seek(li,STREAM_SEEK_SET,&ul);        // Absolute seek to start of data.
        if(!SUCCEEDED(hr))
                goto LWrong;
        
        hr=m_pDocStream->Read(&rh, sizeof(rh), &rd);
        if(!SUCCEEDED(hr))
                goto LWrong;
        //assert( rh.recType == PST_UserEditAtom );
        if (rh.recType != PST_UserEditAtom)
                goto LWrong;
        //assert( rh.recLen == sizeof(PSR_UserEditAtom));
        if (rh.recLen != sizeof(PSR_UserEditAtom))
                goto LWrong;
        hr = m_pDocStream->Read(&userEdit, sizeof(userEdit), &rd);
        if( !SUCCEEDED(hr))
            goto LWrong;
        
        //Loop through all User Edits to gather all the Persist Directory Entries.
        pRef = new PPT8Ref(0,0);
        if (!pRef)
                goto LWrong;

        m_pRefListHead = new PPT8RefList(pRef);
        if (!m_pRefListHead)
        {
                delete pRef;
                goto LWrong;
        }
                
        while(1)  // Read and save all persist directory entries.
        {
                
                li.LowPart = userEdit.offsetPersistDirectory;
                li.HighPart = 0;
                if (!fFirstLoop && li.LowPart == liLast.LowPart && li.HighPart == liLast.HighPart)
                  break;
                liLast = li;
                if(fFirstLoop)
                        fFirstLoop = FALSE;
                hr = m_pDocStream->Seek(li,STREAM_SEEK_SET,&ul);        // Absolute seek to start of data.
        
                if( !SUCCEEDED(hr))
                        goto LWrong;
                                
                hr = m_pDocStream->Read(&rh, sizeof(rh), &rd);
                if(!SUCCEEDED(hr))
                        goto LWrong;
                //assert( rh.recType == PST_PersistPtrIncrementalBlock );                       
                if (rh.recType != PST_PersistPtrIncrementalBlock)
                        break;
                        
                for (unsigned long j=0; j<rh.recLen; )  // Read all the data in the Directory.
                {
                        hr = m_pDocStream->Read(&Reference, sizeof(Reference), &rd); // Read a reference.
                        if (!SUCCEEDED(hr))
                            goto LWrong;    // Exiting two blocks - destruction might be required at a later date
                        j+=  sizeof(Reference);
                        numOfSeqOffsets = Reference >> 20;
                        startRefNum = Reference & 0x000FFFFF;
                                                
                        for(unsigned long k=startRefNum; k<numOfSeqOffsets+startRefNum; k++) // Pick up the offsets.
                        {
                                if(m_pRefListHead->IsNewReference(k))          // If this is a new reference, get it.
                                {
                                        PPT8RefList *pRefListTemp;

                                        hr = m_pDocStream->Read(&offset, sizeof(offset), &rd);       // Read an offset.
                                        if(!SUCCEEDED(hr))
                                                goto LWrong;
                                        j+=  sizeof(offset);
                                        pRef = new PPT8Ref(k, offset);
                                        if (!pRef)
                                                break;
                                        pRefListTemp = new PPT8RefList(pRef);
                                        if (pRefListTemp)
                                                m_pRefListHead->AddToBack(pRefListTemp);                
                                        else
                                        {
                                                delete pRef;
                                                break;
                                        }
                                }
                                else
                                {
                                        hr = m_pDocStream->Read(&offset, sizeof(offset), &rd);       // Swallow duplicate entry.
                                        if (!SUCCEEDED(hr))
                                                goto LWrong;    // Exiting four blocks - destruction might be required at a later date

                                        j+=  sizeof(offset);
                                } // End if     
                                        
                        }// End for
                              
                } // End for
                
                if(!userEdit.offsetLastEdit) break;             // If no more User Edit Atoms, break.
                li.LowPart = userEdit.offsetLastEdit;
                li.HighPart = 0;
                hr = m_pDocStream->Seek(li,STREAM_SEEK_SET,&ul);        // Absolute seek to start of data.
                if( !SUCCEEDED(hr))
                {
                        m_pDocStream->Release();
                        return  FALSE;
                }
                                
                hr = m_pDocStream->Read(&rh, sizeof(rh), &rd);
                if(!SUCCEEDED(hr))
                        goto LWrong;    // Exiting a block - destruction might be required at a later date
                
                //assert( rh.recType == PST_UserEditAtom );
                if (rh.recType != PST_UserEditAtom)
                        break;
                //assert( rh.recLen == sizeof(PSR_UserEditAtom));
                if (rh.recLen != sizeof(PSR_UserEditAtom))
                        break;
                hr = m_pDocStream->Read(&userEdit, sizeof(userEdit), &rd);
                if( !SUCCEEDED(hr))
                        goto LWrong;    // Exiting a block
        } // End while
        
        m_pRefList = m_pRefListHead; 
        m_pDocStream->Release();
        m_pDocStream = 0;
        return TRUE;
LWrong:
        m_pDocStream->Release();
        m_pDocStream = 0;
        return FALSE;
}

// Starting from the last container read, look for an OLE object.
  
HRESULT OleObjectIterator::GetNextEmbedding(IStorage ** ppstg)
{
//              Get the next object 
        HRESULT hr = STG_E_UNKNOWN;
        unsigned long   myRef;
        unsigned long   myOffset;
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        unsigned long rd; 
        RecordHeader rh;

        *ppstg = NULL;
        if(!m_iStore)   // If storage pointer is null, return error
                return hr;

        hr = m_iStore->OpenStream( DOCUMENT_STREAM, NULL, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, NULL, &m_pDocStream );
        if( !SUCCEEDED(hr))
                return  hr;

        while(1)
        {
                m_pRefList = m_pRefList->GetNext();
                if(!m_pRefList) // No more containers to seek.
                {
                        m_pDocStream->Release();
                        m_pDocStream=0;
                        return hr;
                }
                myRef = m_pRefList->GetRef()->GetRefNum();
                myOffset = m_pRefList->GetRef()->GetOffset();

                // For each reference see if there is an OLE container

                if(myRef)
                {
                        li.LowPart = myOffset;
                        li.HighPart = 0;
                        hr = m_pDocStream->Seek(li,STREAM_SEEK_SET,&ul);        // Absolute seek to start of data.
                        if( !SUCCEEDED(hr))
                        {
                                m_pDocStream->Release();
                                m_pDocStream = 0;
                                return  hr;
                        }

                        hr = m_pDocStream->Read(&rh, sizeof(rh), &rd);  // Read the header
                        if( !SUCCEEDED(hr))
                        {
                                m_pDocStream->Release();
                                m_pDocStream = 0;
                                return  hr;
                        }

                        if(PST_ExOleObjStg==rh.recType)   // OLE Object?
                        {
                                // Get the OLE data and return an IStorage
                                hr = ReadOLEData(ppstg, rh);
                                m_pDocStream->Release();
                                m_pDocStream = 0;
                                return hr;
                        }
                } // End if (myRef)
        }       // End while
}

// Read the data from the container, uncompress if necessary, and save to an ILockByte buffer.

// Maximum embedded limit - arbitrary 1 GB
#define MAX_EMBEDDED_DATA 0x40000000Lu

HRESULT OleObjectIterator::ReadOLEData(IStorage ** ppstg, RecordHeader rh)
{
        HRESULT hr = STG_E_UNKNOWN;
        unsigned long expandedSize;
        HGLOBAL   hOleData=0;
        void* oleCompData;
        unsigned long rd;
        int result = 0;

        *ppstg = NULL;
        STATSTG sDocStat;
        HRESULT h = m_pDocStream->Stat(&sDocStat, STATFLAG_NONAME);

        if ( FAILED( h ) )
            return h;

        ULONGLONG uliMaxDocSize = (sDocStat.cbSize.QuadPart < MAX_EMBEDDED_DATA ? sDocStat.cbSize.QuadPart : MAX_EMBEDDED_DATA);

        if (rh.recLen > uliMaxDocSize)
            return E_INVALIDARG;

        if(rh.recInstance == 0) // No compression of OLE data
        {
                expandedSize = rh.recLen;
                hOleData = GlobalAlloc(GMEM_MOVEABLE, expandedSize);

                if(hOleData)
                {
                        void *pOleData = GlobalLock(hOleData);
                        if (0 == pOleData)
                        {
                            GlobalFree(hOleData);
                            return HRESULT_FROM_WIN32(GetLastError());
                        }
                        hr = m_pDocStream->Read(pOleData, expandedSize, &rd );  // Read the OLE data.
                        GlobalUnlock(hOleData);
                        if (!SUCCEEDED(hr))
                        {
                            GlobalFree(hOleData);
                            return hr; // Not cleaning up - this is not the initializer
                        }
                }
                else
                        return E_OUTOFMEMORY;
        }       

        else if(rh.recInstance == 1)    // Data is compressed
        {
                hr = m_pDocStream->Read(&expandedSize, sizeof(expandedSize), &rd);  // Read the decompressed size.
                if (!SUCCEEDED(hr))
                    return hr;

                if ( expandedSize >= MAX_EMBEDDED_DATA )
                    return E_INVALIDARG;
                
                // If the above read fails, we could do something very bad here...
                oleCompData = new BYTE[rh.recLen - sizeof(expandedSize)];
                hOleData = GlobalAlloc(GMEM_MOVEABLE, expandedSize);
                // Remember to clean up the above, on failure
                
                if(oleCompData && hOleData)
                {
                    void *pOleData = GlobalLock(hOleData);
                    if (0 == pOleData)
                    {
                        GlobalFree(hOleData);
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                    hr = m_pDocStream->Read(oleCompData, rh.recLen - sizeof(expandedSize), &rd);  // Read the compressed OLE data.
                    if (!SUCCEEDED(hr))
                    {
                        delete [] oleCompData;
                        GlobalFree(hOleData);
                        return hr;
                    }
                    result = uncompress( (BYTE *)pOleData, &expandedSize, (BYTE*)oleCompData, rh.recLen - sizeof(expandedSize) );
                    GlobalUnlock(hOleData);
                }
                else
                {
                        if (hOleData)
                                GlobalFree(hOleData);
                        if (oleCompData)
                                delete [] oleCompData;
                        return E_OUTOFMEMORY;
                }
                delete [] oleCompData;
        }
        else
                return hr;

        //assert(result ==0);   
        if(result != 0)
        {
                GlobalFree(hOleData);
                return hr;
        }

        ILockBytes *pLockBytes;
        hr=CreateILockBytesOnHGlobal(hOleData, TRUE, &pLockBytes);
        if (FAILED(hr))
        {
            GlobalFree(hOleData);
            return hr;
        }
        // From here on, hOleData is owned by pLockBytes

        hr = StgOpenStorageOnILockBytes(pLockBytes, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, ppstg);
        pLockBytes->Release();  // The IStorage holds a refcount, so Release()ing it,
                                // triggers a Release() on pLockBytes, which cleans up the hOleData
        pLockBytes = 0;
        if (FAILED(hr))
        {
                *ppstg = NULL;
        }
        return hr;
}

// Utility classes

PPT8RefList::~PPT8RefList()
{
        delete  m_ref;
        m_ref = 0;
        delete  m_nextRef;
        m_nextRef = 0;
} 

void PPT8RefList::AddToBack(PPT8RefList* refList)
{
        if(!m_nextRef)
                m_nextRef = refList;    // If first added Ref, point to it.
        else
        {
                PPT8RefList     *m_pRefList=this;
                while(m_pRefList->GetNext())
                        m_pRefList = m_pRefList->GetNext();     // Find end of the line.
                refList->SetNext(0);
                m_pRefList->SetNext(refList);
        }
}


//      When there are more than one User Edit, there may be duplicated references.
//      Check here for these duplicates. Return FALSE if found.

BOOL    PPT8RefList::IsNewReference(unsigned long ref)
{
        PPT8RefList     *m_pRefList=this;
        while(m_pRefList = m_pRefList->GetNext()) // Loop until we get top the end of the list.
                if(m_pRefList->m_ref->GetRefNum() == ref) return(FALSE);
        
        return(TRUE);
}

BOOL    PPT8RefList::GetOffset(unsigned long ref, unsigned long& offset)        // Returns the offset for a given reference. 
{
        PPT8RefList     *m_pRefList=this;
        while(m_pRefList = m_pRefList->GetNext()) // Loop until we get top the end of the list.
                if(m_pRefList->m_ref->GetRefNum() == ref)
                {
                        offset = m_pRefList->m_ref->GetOffset();
                        return(TRUE);
                }
        return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\offifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       cxxifilt.cxx
//
//  Contents:   C++ filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//  Notes:      Machine generated.  Hand modified.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#include <crtdbg.h>
#include <assert.h>

#pragma hdrstop

#include "offifilt.hxx"
#include "offfilt.hxx"

extern "C" void MemFreeAllPages (void);

#ifdef _DEBUG 
static _CrtMemState state;
static BOOL bMemCheck = TRUE;
#endif

IFilterStream::~IFilterStream()
{
}

long gulcInstances = 0;

extern "C" GUID TYPID_COfficeIFilter = {
    0xedbd4080,
    0x7b8c,
    0x11cf,
    { 0x9b, 0xe8, 0x00, 0xaa, 0x00, 0x4b, 0x99, 0x86 }
};

extern "C" GUID CLSID_COfficeIFilter = {
    0xf07f3920,
    0x7b8c,
    0x11cf,
    { 0x9b, 0xe8, 0x00, 0xaa, 0x00, 0x4b, 0x99, 0x86 }
};

extern "C" GUID CLSID_COfficeClass = {
    0x4e8ea5c0,
    0x7b8d,
    0x11cf,
    { 0x9b, 0xe8, 0x00, 0xaa, 0x00, 0x4b, 0x99, 0x86 }
};

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterBase::COfficeIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

COfficeIFilterBase::COfficeIFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterBase::~COfficeIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

COfficeIFilterBase::~COfficeIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilterBase::QueryInterface( REFIID riid,
                                                            void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IPersistStorage == riid )
        *ppvObject = (IUnknown *)(IPersistStorage *)this;
    else if ( IID_IPersistStream == riid )
        *ppvObject = (IUnknown *)(IPersistStream *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE COfficeIFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE COfficeIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::COfficeIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//

COfficeIFilterCF::COfficeIFilterCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );

#ifdef _DEBUG
   
    //_CrtMemState state;
   
   int tmpDbgFlag = 0;

   if(bMemCheck)
   {
//    tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
      tmpDbgFlag |= _CRTDBG_CHECK_ALWAYS_DF;
      //tmpDbgFlag |= _CRTDBG_CHECK_CRT_DF;
      tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;

      //_CrtSetDbgFlag(tmpDbgFlag);

      //_CrtMemCheckpoint(&state );
      bMemCheck = FALSE;
   }
#endif

}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::~COfficeIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

COfficeIFilterCF::~COfficeIFilterCF()
{
    InterlockedDecrement( &gulcInstances );
    if(!gulcInstances)
    {
      //MemFreeAllPages();
    
#ifdef _DEBUG
           //_CrtMemDumpAllObjectsSince(&state);
#endif
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;
    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE COfficeIFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE COfficeIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    COfficeIFilter *  pIUnk = 0;
    SCODE sc = S_OK;


#ifdef _DEBUG
         //_CrtMemDumpAllObjectsSince(&state);
#endif

    try
    {
        pIUnk = new COfficeIFilter();

        if ( 0 == pIUnk )
            sc = E_OUTOFMEMORY;
        else
            sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    catch( ... )
    {
        //Win4Assert( 0 == pIUnk );

        assert(0);
                sc = E_FAIL;
    }


       return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     COfficeIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE COfficeIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    try
    {
        if ( cid == CLSID_COfficeIFilter || cid == CLSID_COfficeClass )
            pResult = (IUnknown *)new COfficeIFilterCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
        else
            sc = E_OUTOFMEMORY;
    }
    catch( ... )
    {
        if ( pResult )
            pResult->Release();

        assert(0);
                sc = E_FAIL;
    }


    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    08-Jan-97  KyleP        Created
//
//--------------------------------------------------------------------------

//#define FOR_MSOFFICE 1

#include <windows.h>

#include <filter.h>
#include <filterr.h>
#include <stgprop.h>

//
// Office-specific files.
//

#include "..\FindFast\dmfltinc.h"
#include "..\FindFast\dmifstrm.hpp"
#include "..\FindFast\dmippstm.hpp"
#include "..\FindFast\dmipp8st.hpp"
#include "..\FindFast\dmiwd6st.hpp"
#include "..\FindFast\dmiwd8st.hpp"
#include "..\FindFast\dmixlstm.hpp"
#include "..\FindFast\dmubdrst.hpp"

// stolen from fltintrn.h, in previous version of VC this has been defined
// in excpt.h, VC sp3 for some reasons moved this definition to the private
// header fltintrn.h

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#define _CRTAPI1
#endif  /* _MSC_VER >= 800 && _M_IX86 >= 300 */
#endif  /* _CRTAPI1 */

#if (1)
inline void * _CRTAPI1 operator new ( size_t size )
{
    return (void *)LocalAlloc( LMEM_FIXED, size );
}

inline void _CRTAPI1 operator delete ( void * p )
{
    LocalFree( (HLOCAL)p );
}
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\regacc32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       RegAcc.hxx
//
//  Contents:   'Simple' registry access
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "regacc32.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CRegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.  See ntrtl.h for constants.
//              [pwcsRegPath] -- Path to node.
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CRegAccess::CRegAccess( HKEY keyRelative, WCHAR const * pwcsRegPath )
        : _hKey( 0 ),
          _wcsPath( 0 )
{
    if ( ERROR_SUCCESS != RegOpenKey( keyRelative, pwcsRegPath, &_hKey ) ||
         _hKey == 0 )
    {
        //
        // Try the ACSII version.  It may work on Win95.
        //

        int cc = wcslen( pwcsRegPath ) + 1;

        char * pszPath = new char [cc];

        if ( 0 != pszPath )
        {
            wcstombs( pszPath, pwcsRegPath, cc );

            RegOpenKeyA( keyRelative, pszPath, &_hKey );
        }

        delete [] pszPath;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::~CRegAccess, public
//
//  Synopsis:   Destructor
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CRegAccess::~CRegAccess()
{
    RegCloseKey( _hKey );
    delete [] _wcsPath;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CRegAccess::Get( WCHAR const * pwcsKey, WCHAR * wcsVal, unsigned cc )
{
    if ( _hKey == 0 )
        return FALSE;

    DWORD dwType;
    DWORD cb = cc * sizeof(WCHAR);
    wcsVal[0] = 0;

    BOOL fOk = ( ERROR_SUCCESS == RegQueryValueEx( _hKey,
                                                   pwcsKey,
                                                   0,
                                                   &dwType,
                                                   (BYTE *)wcsVal,
                                                   &cb ) ) &&
               ( wcsVal[0] != 0 );

    //
    // Try the ASCII version.  It may work on Win95.
    //

    if ( !fOk )
    {
        int cc2 = wcslen( pwcsKey ) + 1;

        char * pszKey = new char [cc2];
        char * pszVal = new char [cc];
        cb = cc;

        if ( 0 != pszKey && 0 != pszVal )
        {
            wcstombs( pszKey, pwcsKey, cc );

            fOk = (ERROR_SUCCESS == RegQueryValueExA( _hKey, pszKey, 0, &dwType, (BYTE *)pszVal, &cb ));

            mbstowcs( wcsVal, pszVal, cb );
        }

        if (pszKey)
            delete [] pszKey;

        if (pszVal)
            delete [] pszVal;
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by offfilt.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1996, Microsoft Corporation. 
//
// File:        Register.cxx
//
// Contents:    Self-registration for CI MMC control.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     03-Jan-97       KyleP       Created from (CiAdmin version)
//
//----------------------------------------------------------------------------

#include "pch.cxx" 
#pragma hdrstop

//KYLEP
#include <filtreg.hxx>

SClassEntry const aOfficeClasses[] = { { L".doc", L"Word.Document.8",
                                         L"Microsoft Word Document",
                                         L"{00020906-0000-0000-C000-000000000046}",
                                         L"Microsoft Word Document" },

                                       { L".dot", L"Word.Template.8",
                                         L"Microsoft Word Template",
                                         L"{00020906-0000-0000-C000-000000000046}",
                                         L"Microsoft Word Document" },

                                       { L".pot", L"PowerPoint.Template.8",
                                         L"Microsoft PowerPoint Template",
                                         L"{64818D11-4F9B-11CF-86EA-00AA00B929E8}",
                                         L"Microsoft PowerPoint Slide" },

                                       { L".ppt", L"PowerPoint.Show.8",
                                         L"Microsoft PowerPoint Presentation",
                                         L"{64818D10-4F9B-11CF-86EA-00AA00B929E8}",
                                         L"Microsoft PowerPoint Presentation" },

                                       { L".pps", L"PowerPoint.SlideShow.8",
                                         L"Microsoft PowerPoint Slide Show",
                                         L"{64818D10-4F9B-11CF-86EA-00AA00B929E8}",
                                         L"Microsoft PowerPoint Slide Show" },

                                       { L".xlb", L"Excel.Sheet.8",
                                         L"Microsoft Excel Worksheet",
                                         L"{00020820-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Worksheet" },

                                       { L".xlc", L"Excel.Chart.8",
                                         L"Microsoft Excel Chart",
                                         L"{00020821-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Chart" },

                                       { L".xls", L"Excel.Sheet.8",
                                         L"Microsoft Excel Worksheet",
                                         L"{00020820-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Worksheet" },

                                       { L".xlt", L"Excel.Template.8",
                                         L"Microsoft Excel Template",
                                         L"{00020820-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Worksheet" },

                                       { 0, L"Word.Document.6",
                                         L"Microsoft Word 6.0 - 7.0 Document",
                                         L"{00020900-0000-0000-C000-000000000046}",
                                         L"Microsoft Word 6.0 - 7.0 Document" },

                                       { 0, L"Word.Template",
                                         L"Microsoft Word Template",
                                         L"{00020900-0000-0000-C000-000000000046}",
                                         L"Microsoft Word 6.0 - 7.0 Document" },

                                       { 0, L"PowerPoint.Show.7",
                                         L"Microsoft PowerPoint Presentation",
                                         L"{EA7BAE70-FB3B-11CD-A903-00AA00510EA3}",
                                         L"Microsoft PowerPoint Presentation" },

                                       { 0, L"PowerPoint.Template",
                                         L"Microsoft PowerPoint Template",
                                         L"{EA7BAE71-FB3B-11CD-A903-00AA00510EA3}",
                                         L"Microsoft PowerPoint Template" },

                                       { 0, L"Excel.Chart.5",
                                         L"Microsoft Excel Chart",
                                         L"{00020811-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Chart" },

                                       { 0, L"Excel.Sheet.5",
                                         L"Microsoft Excel Worksheet",
                                         L"{00020810-0000-0000-C000-000000000046}",
                                         L"Microsoft Excel Worksheet" },
                                     };

SHandlerEntry const OfficeHandler = { L"{98de59a0-d175-11cd-a7bd-00006b827d94}",
                                      L"Microsoft Office Persistent Handler",
                                      L"{f07f3920-7b8c-11cf-9be8-00aa004b9986}" };

SFilterEntry const OfficeFilter = { L"{f07f3920-7b8c-11cf-9be8-00aa004b9986}",
                                    L"Microsoft Office Filter",
                                    L"OffFilt.dll",
                                    L"Both" };

//DEFINE_DLLREGISTERFILTER( OfficeHandler, OfficeFilter, aOfficeClasses )
DEFINE_DLLREGISTERFILTER2( OfficeHandler, OfficeFilter, aOfficeClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\defprop.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        defprop.cxx
//
// Contents:    Deferred property retriever for filesystems
//
// Classes:     CCiCDeferredPropRetriever
//
// History:     12-Jan-97       SitaramR    Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fsciexps.hxx>
#include <defprop.hxx>
#include <seccache.hxx>
#include <oleprop.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDeferredPropRetriever::CCiCDeferredPropRetriever
//
//  Synopsis:   Constructor
//
//  Arguments:  [cat]             -- Catalog
//              [secCache]        -- Cache of AccessCheck() results
//              [fUsePathAlias] -- TRUE if client is going through rdr/svr
//
//  History:    12-Jan-97       SitaramR       Created
//
//----------------------------------------------------------------------------

CCiCDeferredPropRetriever::CCiCDeferredPropRetriever( PCatalog & cat,
                                                      CSecurityCache & secCache,
                                                      BOOL fUsePathAlias )
        : _cat( cat ),
          _secCache( secCache ),
          _remoteAccess( cat.GetImpersonationTokenCache() ),
          _fUsePathAlias( fUsePathAlias ),
          _cRefs( 1 )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDeferredPropRetriever::~CCiCDeferredPropRetriever
//
//  Synopsis:   Destructor
//
//  History:    12-Jan-97    SitaramR     Created
//
//----------------------------------------------------------------------------

CCiCDeferredPropRetriever::~CCiCDeferredPropRetriever()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCDeferredPropRetriever::RetrieveDeferredValueByPropSpec
//
//  Effects:    Fetch value from the property cache and/or from docfile
//
//  Arguments:  [wid]       -- Workid
//              [pPropSpec] -- Property to fetch
//              [pPropVar]  -- Value returned here
//
//  Notes:      It's the responsibility of the caller to free the variant
//              by calling VariantClear on pVar
//
//  History:    12-Jan-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiCDeferredPropRetriever::RetrieveDeferredValueByPropSpec(
    WORKID               wid,
    const FULLPROPSPEC * pPropSpec,
    PROPVARIANT *        pVar )
{
    //
    // Set up the failure case
    //

    pVar->vt = VT_EMPTY;

    if ( widInvalid == wid )
        return CI_E_WORKID_NOTVALID;

    SCODE sc = S_OK;

    TRY
    {
        //
        // First check the security access
        //

        // 8-byte align this memory

        XArray<BYTE> xBuf( sizeof_CCompositePropRecord );
        XCompositeRecord rec( _cat, wid, xBuf.Get() );

        SDID sdid = _cat.FetchSDID( rec.Get(), wid );
        BOOL fGranted = _secCache.IsGranted( sdid, FILE_READ_DATA );

        if ( fGranted )
        {
            CFullPropSpec *pPS = (CFullPropSpec *) pPropSpec;

            PROPID pid = _cat.PropertyToPropId( *pPS, TRUE );

            if ( ! _cat.FetchValue( rec.Get(), pid, *pVar ) )
            {
                //
                // Try fetching the value from the docfile
                //

                rec.Free();

                CFunnyPath funnyPath;
                SIZE_T cwc = _cat.WorkIdToPath( wid, funnyPath );

                if ( cwc > 0 )
                {
                    XGrowable<WCHAR> xVPath;
                    cwc = _cat.WorkIdToVirtualPath( wid, 0, xVPath );

                    if ( CImpersonateRemoteAccess::IsNetPath( funnyPath.GetActualPath() ) )
                        _remoteAccess.ImpersonateIf( funnyPath.GetActualPath(),
                                                     cwc != 0 ? xVPath.Get() : 0 );
                    else if ( _remoteAccess.IsImpersonated() )
                        _remoteAccess.Release();

                    COLEPropManager propMgr;
                    propMgr.Open( funnyPath );
                    propMgr.ReadProperty( *pPS, *pVar );
                }
            }
         }
         else
         {
             vqDebugOut(( DEB_ERROR,
                          "CCiCDeferredPropRetriever::RetrieveDeferredValueByPropSpec, security check failed\n" ));
         }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CCiCDeferredPropRetriever::RetrieveDeferredValueByPropSpec - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
} //RetrieveDeferredValueByPropSpec

//+-------------------------------------------------------------------------
//
//  Method:     CCiCDeferredPropRetriever::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Jan-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiCDeferredPropRetriever::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiCDeferredPropRetriever::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Jan-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiCDeferredPropRetriever::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiCDeferredPropRetriever::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiCDeferredPropRetriever::QueryInterface(
    REFIID   riid,
    void  ** ppvObject)
{
    IUnknown *pUnkTemp = 0;
    SCODE sc = S_OK;

    if ( IID_ICiCDeferredPropRetriever == riid )
        pUnkTemp = (IUnknown *)(ICiCDeferredPropRetriever *) this;
    else if ( IID_IUnknown == riid )
        pUnkTemp = (IUnknown *) this;
    else
        sc = E_NOINTERFACE;

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
    {
       *ppvObject = 0;
    }

    return sc;
} //QueryInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\filters\office\src\wrapper\shtole32.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1996, Microsoft Corporation.
//
// File:        ShtOle.cxx
//
// Contents:    Minimal implementation of OLE persistent handlers
//
// Classes:     CShtOle
//
// History:     30-Jan-96       KyleP       Added header
//              30-Jan-96       KyleP       Add support for embeddings.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#if defined(CI_SHTOLE)

#include <wchar.h>

#include <regacc32.hxx>
#include <shtole32.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::~CShtOle, public
//
//  Synopsis:   Clean up.  Close any open dlls.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

CShtOle::~CShtOle()
{
    while ( _pserverList )
    {
        CServerNode * ptmp = _pserverList;
        _pserverList = ptmp->Next();
        delete ptmp;
    }
    while ( _pclassList )
    {
        CClassNode * ptmp = _pclassList;
        _pclassList = ptmp->Next();
        delete ptmp;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.
//
//  Arguments:  [pwszPath]  -- Path of file to load.
//              [riid]      -- Interface to bind to.
//              [ppvObject] -- Object returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     REFIID riid,
                     void  ** ppvObject )
{
    SCODE sc = S_OK;

    //
    // Get the extension
    //

    WCHAR * pExt = wcsrchr( pwszPath, '.' );

    //
    // Allow filter decisions on the null extension.
    //

    if ( 0 == pExt )
    {
        static WCHAR pSmallExt[] = L".";

        pExt = pSmallExt;
    }

    if ( wcslen(pExt) > CClassNode::ccExtLen )
	{
		return( E_FAIL );
	}

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;

    for ( CClassNode * pnode = _pclassList;
          pnode != 0 && !pnode->IsMatch( pExt );
          pprev = pnode, pnode = pnode->Next() )
        continue;       // NULL body

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        _pclassList = new CClassNode( pExt, _pclassList );
        if (!_pclassList)
            return E_OUTOFMEMORY;
        pnode = _pclassList;

        //
        // Find class in registry
        //

        WCHAR wcsKey[200];
        WCHAR wcsValue[150];
        GUID classid;
        BOOL fOk = TRUE;

        if ( fOk )
        {
            //
            // Look up class of file by extension
            //

            swprintf( wcsKey,
                      L"%s",
                      pExt );

            CRegAccess regFilter( HKEY_CLASSES_ROOT, wcsKey );
            fOk = regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
        }

        if ( fOk )
        {
            //
            // Look up classid of file class
            //

            swprintf( wcsKey,
                      L"%s\\CLSID",
                      wcsValue );

            CRegAccess regFilter( HKEY_CLASSES_ROOT, wcsKey );
            fOk = regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

            StringToGuid( wcsValue, classid );
            _pclassList->SetClassId( classid );
        }

        if ( fOk )
        {
            CServerNode * pserver = FindServer( classid, riid );
            pnode->SetServer( pserver );
        }
    }
    else
    {
        //
        // Move found node to front of list.
        //

        if ( 0 != pprev )
        {
            pprev->Link( pnode->Next() );
            pnode->Link( _pclassList );
            _pclassList = pnode;
        }
    }

    if ( pnode && pnode->GetCF() )
    {
        //
        // Bind to the requested interface
        //

        IPersistFile * pf;

        sc = pnode->GetCF()->CreateInstance( 0, IID_IPersistFile, (void **)&pf );

        if ( SUCCEEDED(sc) )
        {
            sc = pf->Load( pwszPath, 0 );

            if ( SUCCEEDED(sc) )
                sc = pf->QueryInterface( riid, ppvObject );

            pf->Release();
        }
    }
    else
	{
		sc = E_FAIL;
	}

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.  Assumes class
//              of object has been pre-determined in some way (e.g. the
//              docfile was already opened for property enumeration)
//
//  Arguments:  [pwszPath]  -- Path of file to load.
//              [classid]   -- Pre-determined class id of object
//              [riid]      -- Interface to bind to.
//              [ppvObject] -- Object returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     GUID const & classid,
                     REFIID riid,
                     void  ** ppvObject )
{
    SCODE sc = E_FAIL;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;

    for ( CClassNode * pnode = _pclassList;
          pnode != 0 && !pnode->IsMatch( classid );
          pprev = pnode, pnode = pnode->Next() )
        continue;       // NULL body

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        _pclassList = new CClassNode( classid, _pclassList );
        pnode = _pclassList;

        //
        // Find class in registry
        //

        CServerNode * pserver = FindServer( classid, riid );
        pnode->SetServer( pserver );
    }
    else
    {
        //
        // Move found node to front of list.
        //

        if ( 0 != pprev )
        {
            pprev->Link( pnode->Next() );
            pnode->Link( _pclassList );
            _pclassList = pnode;
        }
    }

    if ( pnode && pnode->GetCF() )
    {
        //
        // Bind to the requested interface
        //

        IPersistFile * pf;

        sc = pnode->GetCF()->CreateInstance( 0, IID_IPersistFile, (void **)&pf );

        if ( SUCCEEDED(sc) )
        {
            sc = pf->Load( pwszPath, 0 );

            if ( SUCCEEDED(sc) )
                sc = pf->QueryInterface( riid, ppvObject );

            pf->Release();
        }
    }

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Bind embedding to specific interface.
//
//  Arguments:  [pStg]      -- IStorage of embedding.
//              [riid]      -- Interface to bind to.
//              [ppvObject] -- Object returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( IStorage * pStg,
                     REFIID riid,
                     void  ** ppvObject )
{
    //
    // Get the class id.
    //

    STATSTG statstg;

    SCODE sc = pStg->Stat( &statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
        return sc;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;

    for ( CClassNode * pnode = _pclassList;
          pnode != 0 && !pnode->IsMatch( statstg.clsid );
          pprev = pnode, pnode = pnode->Next() )
        continue;       // NULL body

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        _pclassList = new CClassNode( statstg.clsid, _pclassList );
        pnode = _pclassList;

        //
        // Find class in registry
        //

        CServerNode * pserver = FindServer( statstg.clsid, riid );
        pnode->SetServer( pserver );
    }
    else
    {
        //
        // Move found node to front of list.
        //

        if ( 0 != pprev )
        {
            pprev->Link( pnode->Next() );
            pnode->Link( _pclassList );
            _pclassList = pnode;
        }
    }

    if ( pnode && pnode->GetCF() )
    {
        //
        // Bind to the requested interface
        //

        IPersistStorage * pPersStore;

        sc = pnode->GetCF()->CreateInstance( 0, IID_IPersistStorage, (void **)&pPersStore );

        if ( SUCCEEDED(sc) )
        {
            sc = pPersStore->Load( pStg );

            if ( SUCCEEDED(sc) )
                sc = pPersStore->QueryInterface( riid, ppvObject );

            pPersStore->Release();
        }
    }
    else
	{
		sc = E_FAIL;
	}

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::StringToGuid, private
//
//  Synopsis:   Helper function to convert string-ized guid to guid.
//
//  Arguments:  [wcsValue] -- String-ized guid.
//              [guid]     -- Guid returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::StringToGuid( WCHAR * wcsValue, GUID & guid )
{
    //
    // Convert classid string to guid
    // (since wcsValue may be used again below, no permanent modification to
    //  it may be made)
    //

    WCHAR wc = wcsValue[9];
    wcsValue[9] = 0;
    guid.Data1 = wcstoul( &wcsValue[1], 0, 16 );
    wcsValue[9] = wc;
    wc = wcsValue[14];
    wcsValue[14] = 0;
    guid.Data2 = (USHORT)wcstoul( &wcsValue[10], 0, 16 );
    wcsValue[14] = wc;
    wc = wcsValue[19];
    wcsValue[19] = 0;
    guid.Data3 = (USHORT)wcstoul( &wcsValue[15], 0, 16 );
    wcsValue[19] = wc;

    wc = wcsValue[22];
    wcsValue[22] = 0;
    guid.Data4[0] = (unsigned char)wcstoul( &wcsValue[20], 0, 16 );
    wcsValue[22] = wc;
    wc = wcsValue[24];
    wcsValue[24] = 0;
    guid.Data4[1] = (unsigned char)wcstoul( &wcsValue[22], 0, 16 );
    wcsValue[24] = wc;

    for ( int i = 0; i < 6; i++ )
    {
        wc = wcsValue[27+i*2];
        wcsValue[27+i*2] = 0;
        guid.Data4[2+i] = (unsigned char)wcstoul( &wcsValue[25+i*2], 0, 16 );
        wcsValue[27+i*2] = wc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::GuidToString, private
//
//  Synopsis:   Helper function to convert guid to string-ized guid.
//
//  Arguments:  [guid]     -- Guid to convert.
//              [wcsValue] -- String-ized guid.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::GuidToString( GUID const & guid, WCHAR * wcsValue )
{
    swprintf( wcsValue,
              L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1],
              guid.Data4[2], guid.Data4[3],
              guid.Data4[4], guid.Data4[5],
              guid.Data4[6], guid.Data4[7] );
}

#endif // CI_SHTOLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\ciprop.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ciprop.cxx
//
//  Contents:   Content index property retriever
//
//  History:    12-Dec-96      SitaramR     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciprop.hxx>
#include <catalog.hxx>
#include <smatch.hxx>
#include <prcstob.hxx>
#include <notifmgr.hxx>
#include <scopetbl.hxx>

#define SET_UNICODE_STR( str, buffer, size, maxSize )   \
        str.Buffer = buffer;                            \
        str.Length = (USHORT)size;                      \
        str.MaximumLength = (USHORT)maxSize;

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::CCiPropRetriever, public
//
//  Synopsis:   Constructor
//              Adds info for *all* scopes to the hashtable.  Hereafter, only
//              hashtable is checked to see if a file is in scope.
//
//  Requires:   All directories in a catalog must have a wid.
//              Hashtable must be allowed to grow to hold all specified scopes.
//
//  Arguments:  [cat]              -- Catalog
//              [pQueryPropMapper] -- Pid Remapper associated with the query
//              [secCache]         -- Cache of AccessCheck() results
//              [fUsePathAlias]  -- TRUE if client is going through rdr/svr
//              [scope]            -- Root scope.
//
//  History:    19-Aug-93  KyleP    Created
//              25-Aug-97  EmilyB   Add wids for all scopes to the hashtable.
//
//--------------------------------------------------------------------------

CCiPropRetriever::CCiPropRetriever( PCatalog & cat,
                                    ICiQueryPropertyMapper *pQueryPropMapper,
                                    CSecurityCache & secCache,
                                    BOOL fUsePathAlias,
                                    CRestriction * pScope )
        : CGenericPropRetriever( cat, pQueryPropMapper, secCache, fUsePathAlias ? pScope : 0 ),
          _fFindLoaded( FALSE ),
          _fFastFindLoaded( FALSE ),
          _fFastStatLoaded( 0 ),
          _fFastStatNeverLoad( 0 ),
          _pScope( pScope ),
          _hTable(MAX_HASHED_DIRECTORIES),
          _fAllScopesShallow(TRUE),
          _fAllInScope(FALSE),
          _fNoneInScope(FALSE)

{
    if ( !ValidateScopeRestriction( _pScope ) )
        THROW( CException( STATUS_NO_MEMORY ) );

    //
    // add scopes to hash table
    //

    if ( RTScope == _pScope->Type() )
    {
        const CScopeRestriction & scp = * (CScopeRestriction *) _pScope;
        Win4Assert( scp.IsValid() );

        if (scp.IsVirtual())
            AddVirtualScopeRestriction(scp);
        else
            AddScopeRestriction(scp.GetFunnyPath(), scp.IsDeep() );

    }
    else if ( RTOr == _pScope->Type() )
    {
        CNodeRestriction const & node = * _pScope->CastToNode();

        for ( ULONG x = 0; x < node.Count() && !_fAllInScope; x++ )
        {
            Win4Assert( RTScope == node.GetChild( x )->Type() );

            const CScopeRestriction & scp = * (CScopeRestriction *)
                                            node.GetChild( x );
            Win4Assert( scp.IsValid() );

            if (scp.IsVirtual())
                AddVirtualScopeRestriction(scp);
            else
                AddScopeRestriction(scp.GetFunnyPath(), scp.IsDeep() );
        }
    }


    if (!_fAllInScope && 0 == _hTable.Count())
        _fNoneInScope = TRUE;

    SET_UNICODE_STR( _Path, _xwcPath.Get(), flagNoValueYet, _xwcPath.SizeOf() );

    SET_UNICODE_STR( _VPath, _xwcVPath.Get(), flagNoValueYet, _xwcVPath.SizeOf() );

    _Name.Length = flagNoValueYet;
} //CCiPropRetriever

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::AddVirtualScopeRestriction, public
//
//  Synopsis:   Adds info to hashtable for all virtual directories which fall
//              within the virtual scope specified.  Hashtable entries for
//              exclude directories have fInScope = FALSE.
//
//  Requires:   All directories in a catalog must have a wid.
//              Hashtable must be allowed to grow to hold all specified scopes.
//
//  Arguments:  [scp] - specified scope
//
//  History:    25-Aug-97  EmilyB   Created
//
//--------------------------------------------------------------------------

void CCiPropRetriever::AddVirtualScopeRestriction(
    CScopeRestriction const & scp)
{
    unsigned iBmk = 0;
    ULONG ulType = 0;

    XGrowable<WCHAR> xwcVPath;
    CLowerFunnyPath lcaseFunnyPPath;

    unsigned ccVPath = 0;
    unsigned ccPPath = 0;

    //
    // enumerate through all virtual roots (both include and exclude) falling
    // under specified virtual scope
    //
    while ( _cat.VirtualToAllPhysicalRoots( scp.GetPath(),     // Virtual scope (prefix)
                                            scp.PathLength(),  //   + length
                                            xwcVPath,          // Full virtual root
                                            ccVPath,           //   + return length
                                            lcaseFunnyPPath,   // Full physical root
                                            ccPPath,           //   + return length
                                            ulType,            // root type
                                            iBmk ) )           // Bookmark
    {
        //
        // Special-case shallow queries at '/', so we don't end up with hits
        // in the roots of all virtual roots
        //

        if ( ( 0 != (lcaseFunnyPPath.GetActualPath())[0] ) &&
             ( ( scp.IsDeep() ) ||
               ( 0 != scp.PathLength() ) ||
               ( 1 == ccVPath ) ) )

        {
            // if virtual scope was invalid, VirtualToPhysicalRoot will return
            // path to general root + \invalid scope name, which will not have
            // a wid. So this is where we catch invalid virtual scopes.
            WORKID wid = _cat.PathToWorkId( lcaseFunnyPPath, FALSE );

            if (widInvalid != wid )
            {
                //
                // add info for vroot to hashtable
                //
                CDirWidHashEntry DirInfo(wid,
                        scp.IsDeep(),
                        (ulType & PCatalog::UsedRoot) ? TRUE : FALSE ); // include or exclude scope?
                _hTable.AddEntry(DirInfo);
            }
            else
            {
                //
                // This can happen.  We may have hit an exclude scope that
                // is not below an include scope.
                //

                continue;
            }
        }

        ccVPath = ccPPath = 0;
    }

    if ( scp.IsDeep() )
        _fAllScopesShallow = FALSE;
} //AddVirtualScopeRestriction

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::AddScopeRestriction, public
//
//  Synopsis:   Adds info to hashtable for all physical scope specified.
//              Exclude physical scopes are not indexed, so no need to
//              check for exclude scopes.  If physical scope is
//              above all physical roots, then adds those roots which fall
//              under scope to the hashtable.
//              Sets _fAllInScope to TRUE if physical scope was '\' or
//              if it was a directory above all physical roots.  There is no
//              other way _fAllInScope can be TRUE.
//
//  Requires:   All directories in a catalog must have a wid.
//              Hashtable must be allowed to grow to hold all specified scopes.
//
//  Arguments:  [lcaseFunnyPhysPath] - specified physical scope
//              [fIsDeep]            - is scope deep?
//
//  History:    25-Aug-97  EmilyB   Created
//
//--------------------------------------------------------------------------

void CCiPropRetriever::AddScopeRestriction(
    const CLowerFunnyPath & lcaseFunnyPhysPath,
    BOOL fIsDeep )
{
    WORKID wid;

    if (fIsDeep)
        _fAllScopesShallow = FALSE;

    if ( 0 == lcaseFunnyPhysPath.GetActualLength() )
    {
        //
        // A physical scope of '\' that is shallow makes no sense.
        //

        if ( fIsDeep )
            _fAllInScope = TRUE;

        return;
    }

    CLowerFunnyPath lcaseFunnyFixedPath = lcaseFunnyPhysPath;
    BOOL fImpersonated = FALSE;

    //
    // if scope is unc, use fixed up version
    //

    if ( lcaseFunnyFixedPath.IsRemote() )
    {
        // unc -- try to unfixup the scope.  if there is no unfixup,
        // it'll just use the original path.

        _cat.InverseFixupPath( lcaseFunnyFixedPath );

        // need to impersonate for remote access here?

        if ( lcaseFunnyFixedPath.IsRemote() &&
             ! _remoteAccess.IsImpersonated() )
        {
            // ignore any error return
            if ( _remoteAccess.ImpersonateIfNoThrow(
                         lcaseFunnyFixedPath.GetActualPath(),
                         0 ) )
                fImpersonated = TRUE;
        }

    }

    //
    // Check to see if the input path name contains an 8.3 short name
    //
    if ( lcaseFunnyFixedPath.IsShortPath() )
    {
        vqDebugOut(( DEB_WARN,
                     "CCiPropRetriever::AddScopeRestriction: possible shortname path\n\t%ws ==>\n",
                     lcaseFunnyFixedPath.GetActualPath() ));

        if ( lcaseFunnyFixedPath.ConvertToLongName() )
        {
            vqDebugOut(( DEB_WARN|DEB_NOCOMPNAME,
                         "\t%ws\n",
                         lcaseFunnyFixedPath.GetActualPath() ));
        }
        else
        {
            vqDebugOut(( DEB_ERROR, "longname path conversion failed!\n" ));
        }
    }

    if ( fImpersonated )
    {
        _remoteAccess.Release();
    }

    wid = _cat.PathToWorkId( lcaseFunnyFixedPath, FALSE );
    if (widInvalid != wid )
    {
        // straightforward case - scope has a wid - which we add to _hTable

        CDirWidHashEntry DirInfo(wid, fIsDeep, TRUE);
        _hTable.AddEntry(DirInfo);
        return;
    }

    // got here because scope was not global and it didn't have a wid.
    // Might be physical directory (not cataloged) above one that is
    // in catalog.  If scope is shallow, then nothing is in it.
    // If scope is deep, enumerate through scopes and see if any
    // are subdirectories of scope specified

    if (fIsDeep)
    {
        CScopeMatch Match( lcaseFunnyFixedPath.GetActualPath(),
                           lcaseFunnyFixedPath.GetActualLength() );

        _fAllInScope = TRUE;

        CCiScopeTable *pScopes = _cat.GetScopeTable();
        if ( 0 != pScopes )
        {
            unsigned iBmk = 0;
            WCHAR awc[MAX_PATH];
            while ( pScopes->Enumerate( awc,
                                        (sizeof awc / sizeof WCHAR),
                                        iBmk ) )
            {
                unsigned ccawc = wcslen(awc);
                if ( Match.IsInScope( awc, ccawc ) )
                {
                    CLowerFunnyPath lcaseFunnyAwc( awc, ccawc );
                    wid = _cat.PathToWorkId( lcaseFunnyAwc, FALSE );

                    // wid may be widInvalid if it's a scope that hasn't been
                    // scanned yet.

                    if (widInvalid != wid )
                    {
                        CDirWidHashEntry DirInfo( wid,
                                                  fIsDeep,
                                                  TRUE );
                        _hTable.AddEntry(DirInfo);
                    }
                }
                else  // found a root not included in scope
                    _fAllInScope = FALSE;
            }
        }
    }
} //AddScopeRestriction

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::GetPath, public
//
//  Synopsis:   Returns the path for the file
//
//  Returns:    A path to file
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CCiPropRetriever::GetPath()
{
    if ( _Path.Length == flagNoValueYet )
    {
        unsigned cwc = _xwcPath.Count();
        FetchPath( _Path.Buffer, cwc );

        if ( cwc > _xwcPath.Count() )
        {
            // Need more space
            _xwcPath.SetSize( cwc );
            SET_UNICODE_STR( _Path, _xwcPath.Get(), _Path.Length, _xwcPath.SizeOf() );

            FetchPath( _Path.Buffer, cwc );

            // Can't go on asking for more space forever !
            Win4Assert( cwc <= _xwcPath.Count() );
        }

        if ( 0 == cwc )
            _Path.Length = 0;

        _Name.Length = 0;

        if ( _Path.Length == 0 )
            return 0;
        else
        {
            _Path.Length = (USHORT)(cwc * sizeof( WCHAR ));
            _Name.Buffer = _Path.Buffer + _Path.Length/(sizeof WCHAR) - 1;

            // _Path can be path of root (e.g. c:) if indexing directories and
            // root is a match.  Watch that we don't walk off end.

            while ( *_Name.Buffer != L'\\' && _Name.Buffer != _Path.Buffer)
            {
                Win4Assert( _Name.Length < _Path.Length );

                _Name.Length += sizeof(WCHAR);
                _Name.Buffer--;
            }
            if (_Name.Buffer == _Path.Buffer)
            {
                _Name.Buffer = _Path.Buffer + _Path.Length/(sizeof WCHAR);  // point it to /0
                _Name.Length=0;
            }
            else
            {
                _Name.Buffer++;
                _Path.Length -= _Name.Length + sizeof WCHAR;
            }
        }
    }

    return &_Path;
} //GetPath

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::FetchVPathInVScope, private
//
//  Synopsis:   Returns a virtual path for the file that is in the given
//              virtual scope
//
//  Arguments:  [xwcVPath] -- The resulting virtual path
//              [pwcVScope] -- The virtual scope
//              [cwcVScope] -- # of characters in pwcVScope
//              [fVScopeDeep] -- TRUE if the scope is deep
//
//  Returns:    Length of vpath, if a vpath was found and the vpath is in the vscope
//              0 if no vpath exists in the vscope
//
//  History:    02-Feb-98   dlee      Created
//
//----------------------------------------------------------------------------

unsigned CCiPropRetriever::FetchVPathInVScope( XGrowable<WCHAR> & xwcVPath,
                                               WCHAR const * pwcVScope,
                                               const unsigned cwcVScope,
                                               const BOOL fVScopeDeep )
{
    vqDebugOut(( DEB_ITRACE, "FetchVPathInVScope, vscope '%ws', cwc %d\n",
                 pwcVScope, cwcVScope ));

    CScopeMatch Match( pwcVScope, cwcVScope );
    unsigned cSkip = 0;
    unsigned cwcVPath = 0;

    while ( TRUE )
    {
        cwcVPath = _cat.WorkIdToVirtualPath( GetPropertyRecord(),
                                             cSkip,
                                             xwcVPath );

        if ( 0 == cwcVPath )
            return 0;

        //
        // In scope?
        //

        vqDebugOut(( DEB_ITRACE, "  comparing to cwc %d, '%ws'\n",
                     cwcVPath, xwcVPath.Get() ));

        if ( !Match.IsInScope( xwcVPath.Get(), cwcVPath ) )
        {
            cSkip++;
            continue;
        }

        Win4Assert( 0 == xwcVPath[cwcVPath] );

        //
        // If the scope is shallow, check that it's still in scope
        //

        if ( !fVScopeDeep )
        {
            unsigned cwcName = 0;
            WCHAR * pwcName = xwcVPath.Get() + cwcVPath - 1;

            while ( L'\\' != *pwcName )
            {
                Win4Assert( cwcName < cwcVPath );
                cwcName++;
                pwcName--;
            }

            unsigned cwcJustPath = cwcVPath - cwcName;
            vqDebugOut(( DEB_ITRACE, "cwcJustPath: %d\n", cwcJustPath ));

            BOOL fTooDeep = cwcJustPath > ( cwcVScope + 1 );

            if ( fTooDeep )
            {
                cSkip++;
                continue;
            }
            else
                break;
        }
        else
            break;
    }
    vqDebugOut(( DEB_ITRACE,"  InVScope: match!\n" ));
    return cwcVPath;
} //FetchVPathInVScope

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::FetchVirtualPath, private
//
//  Synopsis:   Returns the virtual path for the file
//
//  Arguments:  [xwcVPath] -- The resulting virtual path
//
//  Returns:    If found, length of vpath ELSE 0
//
//  History:    02-Feb-98   dlee      Created
//
//----------------------------------------------------------------------------

unsigned CCiPropRetriever::FetchVirtualPath( XGrowable<WCHAR> & xwcVPath )
{
    BOOL fUseAnyVPath = FALSE;
    unsigned cwc = 0;

    if ( RTScope == _pScope->Type() )
    {
        CScopeRestriction const & scp = * (CScopeRestriction *) _pScope;

        if ( scp.IsVirtual() )
        {
            cwc = FetchVPathInVScope( xwcVPath,
                                      scp.GetPath(),
                                      scp.PathLength(),
                                      scp.IsDeep() );
        }
        else
            fUseAnyVPath = TRUE;
    }
    else if ( RTOr == _pScope->Type() )
    {
        CNodeRestriction const & node = * _pScope->CastToNode();

        fUseAnyVPath = TRUE;

        for ( ULONG x = 0; x < node.Count(); x++ )
        {
            Win4Assert( RTScope == node.GetChild( x )->Type() );

            CScopeRestriction const & scp = * (CScopeRestriction *)
                                            node.GetChild( x );

            if ( scp.IsVirtual() )
            {
                cwc = FetchVPathInVScope( xwcVPath,
                                          scp.GetPath(),
                                          scp.PathLength(),
                                          scp.IsDeep() );
                if ( cwc > 0 )
                {
                    fUseAnyVPath = FALSE;
                    break;
                }
            }
        }
    }

    //
    // If no virtual scope works for the file, grab any virtual path
    //

    if ( fUseAnyVPath )
        cwc = _cat.WorkIdToVirtualPath( GetPropertyRecord(),
                                        0,
                                        xwcVPath );
    return cwc;
} //FetchVirtualPath

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::GetVirtualPath, public
//
//  Synopsis:   Returns the virtual path for the file
//
//  Returns:    A virtual path to file, or 0 if none exists.
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CCiPropRetriever::GetVirtualPath()
{
    if ( flagNoValueYet == _VPath.Length )
    {
        unsigned cwc = FetchVirtualPath( _xwcVPath );

        if ( 0 == cwc )
        {
            SET_UNICODE_STR( _VPath, _xwcVPath.Get(), flagNoValue, _xwcVPath.SizeOf() );
        }
        else
        {
            Win4Assert( 0 == _xwcVPath[cwc] );
            SET_UNICODE_STR( _VPath, _xwcVPath.Get(), cwc * sizeof WCHAR, _xwcVPath.SizeOf() );

            _Name.Length = 0;
            _Name.Buffer = _VPath.Buffer + cwc - 1;

            while ( L'\\' != *_Name.Buffer )
            {
                Win4Assert( _Name.Length < _VPath.Length );

                _Name.Length += sizeof WCHAR;
                _Name.Buffer--;
            }

            Win4Assert ( L'\\' == *_Name.Buffer );

            _Name.Buffer++;
            _VPath.Length -= _Name.Length + sizeof WCHAR;
        }
    }

    if ( flagNoValue == _VPath.Length )
        return 0;
    else
        return &_VPath;
} //GetVirtualPath

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::GetShortName, public
//
//  Returns:    A short name to file
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CCiPropRetriever::GetShortName()
{
    if ( !_fFindLoaded )
        Refresh( FALSE );

    _ShortName.Length = wcslen( _finddata.cAlternateFileName ) * sizeof(WCHAR);

    //
    // If we don'th have a short name and it's not just because we were unable
    // to load it, return the real file name.
    //

    if ( ( 0 == _ShortName.Length ) && ( 0xffffffff != _finddata.dwReserved0 ) )
        return &_Name;

    _ShortName.MaximumLength = _ShortName.Length;
    _ShortName.Buffer = &_finddata.cAlternateFileName[0];

    return &_ShortName;
} //GetShortName

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::CreateTime, public
//
//  Returns:    Create time for file, or 0xFFFFFFFFFFFFFFFF if unknown
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

LONGLONG CCiPropRetriever::CreateTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsCreate) )
        FetchI8StatProp( fsCreate, pidCreateTime, (LONGLONG *)&_finddata.ftCreationTime );

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftCreationTime.dwLowDateTime;
    li.HighPart = _finddata.ftCreationTime.dwHighDateTime;

    return li.QuadPart;
} //CreateTime

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::ModifyTime, public
//
//  Returns:    Last write time for file, or 0xFFFFFFFFFFFFFFFF if unknown
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

LONGLONG CCiPropRetriever::ModifyTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsModify) )
        FetchI8StatProp( fsModify, pidWriteTime, (LONGLONG *)&_finddata.ftLastWriteTime );

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftLastWriteTime.dwLowDateTime;
    li.HighPart = _finddata.ftLastWriteTime.dwHighDateTime;

    return li.QuadPart;
} //ModifyTime

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::AccessTime, public
//
//  Returns:    Last access time for file, or 0xFFFFFFFFFFFFFFFF if unknown
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

LONGLONG CCiPropRetriever::AccessTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsAccess) )
        FetchI8StatProp( fsAccess, pidAccessTime, (LONGLONG *)&_finddata.ftLastAccessTime );

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftLastAccessTime.dwLowDateTime;
    li.HighPart = _finddata.ftLastAccessTime.dwHighDateTime;

    return li.QuadPart;
} //AccessTime

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::ObjectSize public
//
//  Returns:    Size of file, or 0xFFFFFFFFFFFFFFFF if unknown
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

LONGLONG CCiPropRetriever::ObjectSize()
{
    //
    // First, should we try a fast path?
    //

    LARGE_INTEGER li;
    if ( 0 == (_fFastStatLoaded & fsSize) )
    {
        //
        // If this fails, the FindData will have been initialized.
        //

        if ( FetchI8StatProp( fsSize, pidSize, (LONGLONG *)&li ) )
        {
            _finddata.nFileSizeLow  = li.LowPart;
            _finddata.nFileSizeHigh = li.HighPart;
        }
    }

    li.LowPart = _finddata.nFileSizeLow;
    li.HighPart = _finddata.nFileSizeHigh;

    return li.QuadPart;
} //ObjectSize

//+---------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::Attributes, public
//
//  Returns:    Attributes for file, or 0xFFFFFFFF if unknown
//
//  History:    17-Apr-96   KyleP       Added header
//
//----------------------------------------------------------------------------

ULONG CCiPropRetriever::Attributes()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsAttrib) )
    {
        //
        // Try property store?
        //

        if ( 0 == (_fFastStatNeverLoad & fsAttrib) )
        {
            PROPVARIANT var;
            unsigned cb = sizeof(var);

            if ( FetchValue( pidAttrib, &var, &cb ) )
            {
                if ( var.vt == VT_EMPTY )
                    Refresh( TRUE );
                else
                {
                    Win4Assert( var.vt == VT_UI4 );
                    _finddata.dwFileAttributes = var.ulVal;
                    _fFastStatLoaded |= fsAttrib;
                }
            }
            else
            {
                _fFastStatNeverLoad |= fsAttrib;
                Refresh( TRUE );
            }
        }
        else
        {
            Win4Assert( !_fFastFindLoaded );
            Refresh( TRUE );
        }
    }

    return _finddata.dwFileAttributes;
} //Attributes

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::IsInScope
//
//  Synopsis:   Test if workid in scope.
//
//  History:    19-Aug-93 KyleP     Created
//              30-Oct-96 dlee      Added loop, moved guts to isInScope
//              26-Jun-96 emilyb    optimized scope checking.  No longer
//                                  loads stat properties.
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiPropRetriever::IsInScope( BOOL *pfInScope )
{
    if ( widInvalid == _widPrimedForPropRetrieval )
        return CI_E_WORKID_NOTVALID;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        *pfInScope = IsInScope( _widPrimedForPropRetrieval );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CCiPropRetriever::IsInScope - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
} //IsInScope

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::IsInScope, private
//
//  Synopsis:   Test if workid is in scope.
//
//  Algorithm:  looks for an ancestor of the current file (wid parameter) in
//              the hashtable.  If it finds one, it uses it to determine if
//              current file is in scope.  If it doesn't, the current file\
//              is not in scope.  It also adds an
//              entry for the topmost unmatched ancestor to the hashtable.
//
//  Requires:   All scopes must be in hashtable. For virtual scopes, this
//              requirement includes both exclude and include roots
//              within the scope.
//
//  Returns:    TRUE if object is in scope.
//
//  History:    27-Jun-97  emilyb   created
//
//  Notes:      The only time widInvalid is valid as a parent is if the
//              parent is the root of a drive.
//
//
//--------------------------------------------------------------------------

BOOL CCiPropRetriever::IsInScope( WORKID wid )
{
    Win4Assert( wid == _widPrimedForPropRetrieval );

    if (_fAllInScope)
    {
        //
        // Still need to check matching attributes.
        //

        return ( 0 == _ulAttribFilter ) ||
               ( (Attributes() & _ulAttribFilter) == 0 );
    }

    if (_fNoneInScope)
        return FALSE;

    //
    // is wid an inscope directory?
    //
    //
    CDirWidHashEntry DirInfo(wid, 0); // entry to find in hash table
    if (_hTable.LookUpWorkId (DirInfo) )
    {
       if (DirInfo.fInScope())
       {
          return ( 0 == _ulAttribFilter ) ||
                 ( (Attributes() & _ulAttribFilter) == 0 );
       }
       else
          return FALSE;
    }

    //
    // find wid of parent
    //

    WORKID widParent = widInvalid; // parent of wid
    WORKID widAncestor = widInvalid; // used to walk up ancestor chain

    PROPVARIANT var;
    BOOL fFound;
    unsigned cb = sizeof(var);
    fFound = FetchValue(pidParentWorkId, &var, &cb);
    Win4Assert( !fFound || VT_UI4 == var.vt || VT_EMPTY == var.vt );

    if ( !fFound || VT_EMPTY == var.vt )
    {
       // file could have been deleted - not in scope
       return FALSE;
    }

    widParent = var.ulVal;
    if (widParent == widInvalid)
       return FALSE;

    //
    // look for parent in hash table
    //
    DirInfo.SetWorkId(widParent); // entry to find in hash table
    if (_hTable.LookUpWorkId (DirInfo) )
    {
       if (DirInfo.fInScope())
       {
          return ( 0 == _ulAttribFilter ) ||
                 ( (Attributes() & _ulAttribFilter) == 0 );
       }
       else
          return FALSE;
    }
    if (_fAllScopesShallow)  // should have found it above if it was in scope
    {
       return FALSE;
    }

    //
    // we've looked for parent without success -- now look for ancestors
    //
    cb = sizeof(var);

    Quiesce();  // Can only read 1 property record at a time.
    fFound = _cat.FetchValue(widParent, pidParentWorkId, &var, &cb);
    Win4Assert( !fFound || VT_UI4 == var.vt || VT_EMPTY == var.vt );
    widAncestor = var.ulVal;
    DirInfo.SetWorkId(widAncestor);

    while ( fFound && VT_UI4 == var.vt  &&
            widAncestor != widInvalid && //  not root
            ( !_hTable.LookUpWorkId ( DirInfo) || // not in table already
              !DirInfo.fDeep() ) )  // shallow  - so it doesn't apply to grandchild
    {
        // save topmost valid ancestor
        widParent = widAncestor;

        // get the previous ancestor
        Quiesce();  // Can only read 1 property record at a time.

        cb = sizeof(var);
        fFound = _cat.FetchValue(widAncestor, pidParentWorkId, &var, &cb);
        Win4Assert( !fFound || VT_UI4 == var.vt || VT_EMPTY == var.vt );
        widAncestor = var.ulVal;
        DirInfo.SetWorkId(widAncestor);
    }

    if ( !fFound || VT_UI4 != var.vt )
    {
       // file could have been deleted -- not in scope
       return FALSE;
    }

    BOOL fInScope = FALSE; // not in scope unless match found
    BOOL fDeep = TRUE;  // must be deep, or else wouldn't apply to grandchild

    if (widInvalid != widAncestor) // found match
    {
        Win4Assert( DirInfo.fDeep() );
        fInScope = DirInfo.fInScope();
    }

    Win4Assert( widInvalid != widParent );

    // add top ancestor to hashtable
    //
    // Once hash table reaches max size, stop adding entries to it.
    // Because it was seeded with scopes, the data is there to answer
    // if something is in scope.
    if(_hTable.Count() < MAX_HASHED_DIRECTORIES)
    {
       CDirWidHashEntry DirAnc( widParent, fDeep, fInScope );
       if (!_hTable.LookUpWorkId (DirAnc) ) // be careful not to replace ancestral shallow scopes
       {
           _hTable.AddEntry(DirAnc);
#if CIDBG == 1
           // how often do we max out the hash table
           if(_hTable.Count() == MAX_HASHED_DIRECTORIES)
               vqDebugOut(( DEB_WARN,
                         "IsInScope maxed out wid hash table with %d entries\n",
                         _hTable.Count()) );
#endif
       }
    }

    //
    // Still need to check matching attributes.
    //

    return fInScope && (( 0 == _ulAttribFilter ) ||
                        ( (Attributes() & _ulAttribFilter) == 0 ));
} //IsInScope

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::Refresh, private
//
//  Synopsis:   Load stat properties for current object
//
//  Arguments:  [fFast] -- If TRUE, make fast call and don't load alternate
//                         file name.
//
//  Returns:    TRUE if load successful
//
//  History:    19-Aug-93 KyleP     Created
//              29-Feb-96 KyleP     Added GetFileAttributesEx support
//
//--------------------------------------------------------------------------

BOOL CCiPropRetriever::Refresh( BOOL fFast )
{
    //
    // Physical path may not be loaded.
    //

    if ( _Path.Length == flagNoValueYet )
    {
        if ( 0 == GetPath() )
        {
            RtlFillMemory( &_finddata, sizeof(WIN32_FILE_ATTRIBUTE_DATA), 0xFF );
            _finddata.cAlternateFileName[0] = 0;
            return FALSE;
        }
    }

    if ( _Path.Length == 0 )
    {
        //
        //  Previously failed to load path, so no way to get attributes
        //

        RtlFillMemory( &_finddata, sizeof(WIN32_FILE_ATTRIBUTE_DATA), 0xFF );
        _finddata.cAlternateFileName[0] = 0;
        return FALSE;
    }

    if ( CImpersonateRemoteAccess::IsNetPath(_Path.Buffer) )
    {
        WCHAR const * pwszVPath = (_VPath.Length == flagNoValueYet) ? 0 : _VPath.Buffer;

        //
        // Just blow off the file if this fails.
        //

        if ( !_remoteAccess.ImpersonateIfNoThrow( _Path.Buffer,
                                                  pwszVPath ) )
        {
            RtlFillMemory( &_finddata, sizeof WIN32_FILE_ATTRIBUTE_DATA, 0xFF );
            _finddata.cAlternateFileName[0] = 0;
            _Path.Length = 0;
            return FALSE;
        }
    }
    else if ( _remoteAccess.IsImpersonated() )
    {
        _remoteAccess.Release();
    }

    if ( fFast )
    {
        BOOL fResult;
        unsigned ccPath  = (_Path.Length + _Name.Length) / sizeof(WCHAR);

        // handle long paths here
        // we do this here instead of keeping a funnypath object all thru,
        // because we get the path from the property store(in GetPath), which
        // does not recognize funny paths, so we would have to do an extra
        // copy operation. This we do here, but only for paths > MAX_PATH
        if ( ccPath >= MAX_PATH )
        {
            CFunnyPath funnyPath( _Path.Buffer, ccPath );
            fResult = GetFileAttributesEx( funnyPath.GetPath(), GetFileExInfoStandard, &_finddata );
        }
        else
        {
            fResult = GetFileAttributesEx( _Path.Buffer, GetFileExInfoStandard, &_finddata );
        }

        if ( !fResult )
        {
            vqDebugOut(( DEB_ERROR, "Can't retrieve fast findfirst data for %ws.  Error = %d\n",
                         _Path.Buffer, GetLastError() ));
            RtlFillMemory( &_finddata, sizeof(WIN32_FILE_ATTRIBUTE_DATA), 0xFF );
            _finddata.cAlternateFileName[0] = 0;
            return FALSE;
        }

        _fFastFindLoaded = TRUE;
        _fFastStatLoaded = fsCreate | fsModify | fsAccess | fsSize | fsAttrib;

    }
    else
    {
        unsigned ccPath = (_Path.Length + _Name.Length) / sizeof(WCHAR);
        HANDLE h;

        //
        // handle long paths here
        // we do this here instead of keeping a funnypath object all thru,
        // because we get the path from the property store(in GetPath), which
        // does not recognize funny paths, so we would have to do an extra
        // copy operation. This we do here, but only for paths > MAX_PATH
        //

        if ( ccPath >= MAX_PATH )
        {
            CFunnyPath funnyPath( _Path.Buffer, ccPath );
            h = FindFirstFile( funnyPath.GetPath(), &_finddata );
        }
        else
        {
            h = FindFirstFile( _Path.Buffer, &_finddata );
        }

        if ( INVALID_HANDLE_VALUE == h )
        {
            vqDebugOut(( DEB_ERROR, "Can't retrieve findfirst data for %ws\n",
                         _Path.Buffer ));
            RtlFillMemory( &_finddata, sizeof(WIN32_FILE_ATTRIBUTE_DATA), 0xFF );
            _finddata.cAlternateFileName[0] = 0;
            return FALSE;
        }
        else
        {
            FindClose( h );
            _fFindLoaded = TRUE;
            _fFastFindLoaded = TRUE;
            _fFastStatLoaded = fsCreate | fsModify | fsAccess | fsSize | fsAttrib;
        }
    }

    return TRUE;
} //Refresh

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::FetchI8StatProp, private
//
//  Synopsis:   Load stat property.  Try property store before hitting file.
//
//  Arguments:  [fsProp]       -- Fast stat bit to check.
//              [pid]          -- Pid of property
//              [pDestination] -- resulting LONGLONG stored here.
//
//  Returns:    TRUE if property fetch successful *and* value in
//              pDestination is valid.
//
//  History:    17-Apr-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CCiPropRetriever::FetchI8StatProp( CCiPropRetriever::FastStat fsProp,
                                        PROPID pid,
                                        LONGLONG * pDestination )
{
    Win4Assert( 0 == (_fFastStatLoaded & fsProp) );

    //
    // Try property store?
    //

    if ( 0 == (_fFastStatNeverLoad & fsProp) )
    {
        PROPVARIANT var;
        unsigned cb = sizeof(var);

        if ( FetchValue( pid, &var, &cb ) )
        {
            if ( var.vt == VT_EMPTY )
                Refresh( TRUE );
            else
            {
                Win4Assert( var.vt == VT_I8 || var.vt == VT_UI8 || var.vt == VT_FILETIME );
                *(UNALIGNED LONGLONG *)pDestination = var.hVal.QuadPart;
                return TRUE;
            }
        }
        else
        {
            _fFastStatNeverLoad |= fsProp;
            Refresh( TRUE );
        }
    }
    else
    {
        Win4Assert( !_fFastFindLoaded );
        Refresh( TRUE );
    }

    return FALSE;
} //FetchI8StatProp

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::BeginPropertyRetrieval
//
//  Synopsis:   Prime wid for property retrieval
//
//  Arguments:  [wid]    -- Wid to prime
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiPropRetriever::BeginPropertyRetrieval( WORKID wid )
{
    //
    // Check that we are not in the midst of a property retrieval
    //

    Win4Assert( _fFindLoaded == FALSE );
    Win4Assert( _fFastFindLoaded == FALSE );
    Win4Assert( _fFastStatLoaded == 0 );
    Win4Assert( _fFastStatNeverLoad == 0 );
    Win4Assert( _Path.Length == flagNoValueYet );
    Win4Assert( _VPath.Length == flagNoValueYet );
    Win4Assert( _Name.Length == flagNoValueYet );
    Win4Assert( !_remoteAccess.IsImpersonated() );
    Win4Assert( _widPrimedForPropRetrieval == widInvalid );

    //
    // wid should be valid
    //
    Win4Assert( wid != widInvalid );

    _widPrimedForPropRetrieval = wid;

    return S_OK;
} //BeginPropertyRetrieval

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::EndPropertyRetrieval
//
//  Synopsis:   Reset wid for property retrieval
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiPropRetriever::EndPropertyRetrieval( )
{
    PurgeCachedInfo();

    return CGenericPropRetriever::EndPropertyRetrieval();
}

//+-------------------------------------------------------------------------
//
//  Member:     CCiPropRetriever::GetName
//
//  Synopsis:   Return file name
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

UNICODE_STRING const * CCiPropRetriever::GetName()
{
    //
    // Retrieving Path or VPath will retrieve Name
    //

    if ( _Name.Length == flagNoValueYet )
        GetPath();

    return &_Name;
} //GetName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\dirstk.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       DIRSTK.CXX
//
//  Contents:   Directory entry stack
//
//  History:    07-Aug-92 KyleP     Added header
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dirstk.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CDirStackEntry::CDirStackEntry
//
//  Synopsis:   CDirStackEntry constructor
//
//  Arguments:  [str]          -- Unicode string (null terminated) for path
//              [ccStr[        -- Size in chars of [str]
//              [numHighValue] -- numerator's high watermark
//              [numLowValue]  -- numerator's low watermark
//              [fDeep]        -- TRUE for additional dir recursion
//              [pwcsVRoot]    -- Virtual root (or zero if none)
//              [ccVRoot]      -- Size in chars of [pwcsVRoot]
//              [ccReplaceVRoot] -- Number of chars in phys root to replace
//
//  History:    20-Jun-95    SitaramR     Created
//              11-Feb-96    KyleP        Add support for virtual roots
//
//--------------------------------------------------------------------------

CDirStackEntry::CDirStackEntry ( const CFunnyPath & funnyPath,
                                 ULONG numHighValue,
                                 ULONG numLowValue,
                                 BOOL fDeep,
                                 WCHAR const * pwcsVRoot,
                                 unsigned ccVRoot,
                                 unsigned ccReplacePRoot )
      : _numHighValue( numHighValue ),
        _numLowValue( numLowValue ),
        _fDeep( fDeep ),
        _xwcsVirtualRoot( 0 )
{
    _funnyPath = funnyPath;

    if ( 0 != pwcsVRoot )
    {
        _ccVirtualRoot = ccVRoot;
        _ccReplacePhysRoot = ccReplacePRoot;
        _xwcsVirtualRoot.Set( new WCHAR[_ccVirtualRoot] );
        RtlCopyMemory( _xwcsVirtualRoot.GetPointer(), pwcsVRoot, 
                       _ccVirtualRoot * sizeof(WCHAR) );
    }
}


CDirStackEntry::CDirStackEntry ( const WCHAR * pwcPath,
                                 unsigned ccStr,
                                 ULONG numHighValue,
                                 ULONG numLowValue,
                                 BOOL fDeep,
                                 WCHAR const * pwcsVRoot,
                                 unsigned ccVRoot,
                                 unsigned ccReplacePRoot )
      : _numHighValue( numHighValue ),
        _numLowValue( numLowValue ),
        _fDeep( fDeep ),
        _xwcsVirtualRoot( 0 )
{
    _funnyPath.SetPath( pwcPath, ccStr );

    if ( 0 != pwcsVRoot )
    {
        _ccVirtualRoot = ccVRoot;
        _ccReplacePhysRoot = ccReplacePRoot;
        _xwcsVirtualRoot.Set( new WCHAR[_ccVirtualRoot] );
        RtlCopyMemory( _xwcsVirtualRoot.GetPointer(), pwcsVRoot, 
                       _ccVirtualRoot * sizeof(WCHAR) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirStackEntry::CDirStackEntry
//
//  Synopsis:   CDirStackEntry constructor
//
//  Arguments:  [path]         -- Nt string of path sans final directory name
//              [name]         -- Nt string of final directory name
//              [numHighValue] -- numerator's high watermark
//              [numLowValue]  -- numerator's low watermark
//              [fDeep]        -- TRUE for additional dir recursion
//              [pParent]      -- Parent of this scope (for virtual root copy)
//
//  History:    20-Jun-95    SitaramR    Created
//
//--------------------------------------------------------------------------

CDirStackEntry::CDirStackEntry ( UNICODE_STRING const * path,
                                 UNICODE_STRING const * name,
                                 ULONG numHighValue,
                                 ULONG numLowValue,
                                 BOOL fDeep,
                                 CDirStackEntry * pParent )
      : _numHighValue( numHighValue ),
        _numLowValue( numLowValue ),
        _fDeep( fDeep ),
        _xwcsVirtualRoot( 0 )
{
    //
    // Copy physical path
    //
    WCHAR* pwcsActualFileName;

    _funnyPath.SetPath( path->Buffer, path->Length/sizeof(WCHAR) );
    _funnyPath.AppendBackSlash();
    _funnyPath.AppendPath( name->Buffer, name->Length/sizeof(WCHAR) );


    if ( 0 != pParent && 0 != pParent->GetVirtualRoot() )
    {
        _ccVirtualRoot = pParent->VirtualRootLength();
        _ccReplacePhysRoot = pParent->ReplaceLength();

        _xwcsVirtualRoot.Set( new WCHAR[_ccVirtualRoot] );
        RtlCopyMemory( _xwcsVirtualRoot.GetPointer(), 
                       pParent->GetVirtualRoot(), _ccVirtualRoot * sizeof(WCHAR) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\dllreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       dllreg.cxx
//
//  Contents:   Null and Plain Text filter registration
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>

//
// Extra entries for CI Filesystem Client.  They happen to have the same form
// as the filter entries.
//

SFilterEntry const ClientFilterObject =
{
    L"{AA205A4D-681F-11D0-A243-08002B36FCA4}",
    L"File System Client Filter Object",
    L"query.dll",
    L"Both"
};

SFilterEntry const ClientDocstoreLocator =
{
    L"{2A488070-6FD9-11D0-A808-00A0C906241A}",
    L"File System Client DocStore Locator Object",
    L"query.dll",
    L"Both"
};

extern "C" STDAPI FsciDllRegisterServer(void)
{
    long dwErr = RegisterAFilter( ClientFilterObject );

    if ( ERROR_SUCCESS == dwErr )
        dwErr = RegisterAFilter( ClientDocstoreLocator );

    return ERROR_SUCCESS == dwErr ? S_OK : SELFREG_E_CLASS;
} //FsciDllRegisterServer

extern "C" STDAPI FsciDllUnregisterServer(void)
{
    long dw1 = UnRegisterAFilter( ClientDocstoreLocator );
    long dw2 = UnRegisterAFilter( ClientFilterObject );

    if ( ERROR_SUCCESS == dw1 && ERROR_SUCCESS == dw2 )
        return S_OK;

    return S_FALSE;
} //FsciDllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       exports.cxx
//
//  Contents:   Code to export filter and word breaker class factories
//
//  History:    15-Aug-1994     SitaramR   Created
//
//  Notes:      Copied from txtifilt.hxx and then modified
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classf.hxx>
#include <vquery.hxx>
#include <ciintf.h>
#include <opendoc.hxx>
#include <ilangres.hxx>

static const GUID clsidISearchCreator = CLSID_ISearchCreator;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter or a word breaker class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE FsciDllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown * pResult;
    SCODE sc = S_OK;

    TRY
    {
        if ( guidStorageFilterObject == cid)
            pResult = (IUnknown *) new CStorageFilterObjectCF;
        else if ( guidStorageDocStoreLocatorObject == cid)
            pResult = (IUnknown *) new CStorageDocStoreLocatorObjectCF;
        else
        {
            ciDebugOut(( DEB_ITRACE, "DllGetClassObject: no such interface found\n" ));
            pResult = 0;
            sc = E_NOINTERFACE;
        }
    }
    CATCH(CException, e)
    {
        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    if (0 != pResult)
    {
        sc = pResult->QueryInterface( iid, ppvObj );
        pResult->Release();
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeISearch
//
//  Synopsis:   Creates an ISearch interface for highlighting the given
//              document.
//
//  Arguments:  [ppSearch] - [out] Will have the ISearch interface pointer.
//              [pRst]     - [in]  The restriction to apply
//              [pwszPath] - [in]  The path of the document
//
//  History:    2-26-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE MakeISearch(
    ISearchQueryHits **       ppSearch,
    CDbRestriction * pRst,
    WCHAR const *    pwszPath )
{
    // intentional access violation on bogus params

    *ppSearch = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        //
        // Create the language resources.
        //

        XInterface<CLanguageResourceInterface> xLangRes( new CLanguageResourceInterface );

        XInterface<ICiCLangRes> xICiCLangRes;
        SCODE sc = xLangRes->QueryInterface( IID_ICiCLangRes,
                                             xICiCLangRes.GetQIPointer() );
        if ( FAILED(sc) )
             THROW(CException(sc));

        //
        // Create the OpenDocument.
        //

        XInterface<ICiCOpenedDoc> xOpenDoc;

        if ( 0 != pwszPath )
        {
            xOpenDoc.Set( new CCiCOpenedDoc( 0, 0, FALSE, FALSE ) );
            sc = xOpenDoc->Open( (BYTE *) pwszPath,
                                 ( 1 + wcslen(pwszPath) ) * sizeof WCHAR );

            if ( FAILED(sc) )
                THROW( CException( sc ) );
        }
              
        XInterface<ICiISearchCreator> xSearchCreator;
    
        sc = CoCreateInstance( clsidISearchCreator,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_ICiISearchCreator,
                               xSearchCreator.GetQIPointer() );

        if ( FAILED(sc) )
            THROW( CException(sc) );

        sc = xSearchCreator->CreateISearch( pRst->CastToStruct(),
                                            xICiCLangRes.GetPointer(),
                                            xOpenDoc.GetPointer(),
                                            ppSearch );

        if ( FAILED(sc) )
            THROW( CException(sc) );                                           
    }
    CATCH ( CException, e )
    {
        //
        // MakeISearch clients must be smart and able to handle real
        // errors that actually happen.  It's not OLE DB.
        //

        sc = GetScodeError( e );

        vqDebugOut(( DEB_ERROR,
                     "MakeISearch error 0x%x => 0x%x\n",
                     e.GetErrorCode(),
                     sc ));

    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //MakeISearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\fatnot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       FatNot.cxx
//
//  Contents:   Downlevel notification.
//
//  Classes:    CGenericNotify
//
//  History:    2-23-96   KyleP      Lifed from DLNotify.?xx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fatnot.hxx>
#include <pathpars.hxx>
#include <imprsnat.hxx>
#include <catalog.hxx>
#include <cicat.hxx>

#include <ciregkey.hxx>
#include <cievtmsg.h>
#include <eventlog.hxx>
#include <lm.h>


//+---------------------------------------------------------------------------
//
//  Class:      CRemoteNotifications
//
//  Purpose:    A class to impersonate and enable notifications for remote
//              shares.
//
//  History:    7-15-96   srikants   Created
//
//  Notes:      When there are multiple alternatives possible for a remote
//              share, we have to use the one that allows access to remote
//              share (if there is one). There may be some which don't allow
//              the required access and we should skip those.
//
//----------------------------------------------------------------------------

class CRemoteNotifications : public PImpersonatedWorkItem
{

public:

    CRemoteNotifications( WCHAR const * pwszPath,
                          CGenericNotify & notify,
                          OBJECT_ATTRIBUTES & objAttr )
    : PImpersonatedWorkItem( pwszPath ),
      _notify(notify),
      _objAttr(objAttr),
      _status(STATUS_SUCCESS)
    {

    }

    NTSTATUS OpenAndStart( CImpersonateRemoteAccess & remoteAccess );

    virtual BOOL DoIt();

private:

    CGenericNotify &        _notify;
    OBJECT_ATTRIBUTES &     _objAttr;

    NTSTATUS                _status;
};

//+---------------------------------------------------------------------------
//
//  Member:     CRemoteNotifications::DoIt
//
//  Synopsis:   The virtual method that does the work under an impersonated
//              context.
//
//  Returns:    TRUE if successful;
//              FALSE o/w
//
//  History:    7-15-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CRemoteNotifications::DoIt()
{
    _status = _notify.OpenDirectory( _objAttr );

    if ( IsRetryableError( _status ) )
    {
        //
        // We should attempt the open under a different impersonation
        // if possible.
        //
        return FALSE;
    }

    if ( NT_ERROR(_status) )
        THROW( CException( _status ) );

    //
    // Now, enable the notifications.
    //
    _notify.StartNotification( &_status );    // already impersonated
    if ( NT_ERROR(_status) )
    {
        _notify.CloseDirectory();
        if ( IsRetryableError(_status) )
            return FALSE;

        THROW( CException( _status ) );
    }

    //
    // Successfully enabled notifications.
    //
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRemoteNotifications::OpenAndStart
//
//  Synopsis:   Opens and start notifications for the remote root by trying
//              various impersonation contexts if necessary.
//
//  Arguments:  [remoteAccess] - The object to use for remote access.
//
//  Returns:    NTSTATUS of the whole operation.
//
//  History:    7-15-96   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS
CRemoteNotifications::OpenAndStart( CImpersonateRemoteAccess & remoteAccess )
{
    TRY
    {
        ImpersonateAndDoWork( remoteAccess );
    }
    CATCH( CException,e )
    {
        vqDebugOut(( DEB_ERROR, "OpenAndStart failed with error (0x%X)\n",
                     e.GetErrorCode() ));
        _status = e.GetErrorCode();
    }
    END_CATCH

    return _status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::CGenericNotify
//
//  Synopsis:   Constructor of the single scope notification object CGenericNotify.
//
//  Arguments:  [wcsScope] -- Scope to watch
//              [cwcScope] -- Size in chars of [wcsScope]
//              [fDeep]    --  Set to TRUE if deep notifications are enabled.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

CGenericNotify::CGenericNotify( PCatalog *pCat,
                                WCHAR const * wcsScope,
                                unsigned cwcScope,
                                BOOL fDeep,
                                BOOL fLogEvents )
: _refCount(1),
  _pCat( pCat ),
  _fNotifyActive(FALSE),
  _fRemoteDrive(FALSE),
  _cwcScope(cwcScope),
  _fDeep(fDeep),
  _fLogEvents(fLogEvents),
  _fAbort(FALSE),
  _hNotify(0),
  _pbBuffer(0)
{
    if ( cwcScope >= MAX_PATH )
    {
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    RtlCopyMemory( _wcsScope, wcsScope, cwcScope * sizeof(WCHAR) );
    _wcsScope[cwcScope] = 0;

    CDoubleLink::Close();

    //
    // Bigger buffer for local scopes.
    //

    _fRemoteDrive = !IsFixedDrive( _wcsScope, _cwcScope );

    if ( _fRemoteDrive )
        _cbBuffer = CB_REMOTENOTIFYBUFFER;
    else
        _cbBuffer = CB_NOTIFYBUFFER;

    //
    // Client should call EnableNotification() in ctor.  Delay allocating
    // the buffer in case this is a USN volume and no buffer is needed.
    //
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::~CGenericNotify
//
//  Synopsis:   ~dtor . Disables further notifications and frees up
//              memory.
//
//  History:    1-17-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CGenericNotify::~CGenericNotify()
{
    Win4Assert( 0 == _refCount );
    Win4Assert( IsSingle() );
    Win4Assert( 0 == _hNotify );
    delete [] _pbBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::OpenDirectory
//
//  Synopsis:   Opens a remote directory and uses the given object attributes.
//
//  Arguments:  [ObjectAttr] -
//
//  Returns:    STATUS of the operation.
//
//  History:    7-15-96   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS
CGenericNotify::OpenDirectory( OBJECT_ATTRIBUTES & ObjectAttr )
{
    BOOL fSuccess = TRUE;

    ULONG cSkip = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatus;

    Status = NtOpenFile( &_hNotify,                   // Handle
                         FILE_LIST_DIRECTORY | SYNCHRONIZE, // Access
                         &ObjectAttr,                 // Object Attributes
                         &IoStatus,                   // I/O Status block
                         FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE ); // Flags

    if ( NT_ERROR(Status) )
        _hNotify = 0;

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::CloseDirectory
//
//  Synopsis:   Closes the directory handle if open and sets it to 0.
//
//  History:    7-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericNotify::CloseDirectory()
{
    if ( 0 != _hNotify )
    {
        NtClose( _hNotify );
        _hNotify = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::EnableNotification
//
//  Synopsis:   Enables notifications for the current scope.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericNotify::EnableNotification()
{
    vqDebugOut(( DEB_ITRACE, "Enable notification for scope %ws this=0x%x\n", _wcsScope, this ));

    if ( 0 == _pbBuffer )
        _pbBuffer = new BYTE [_cbBuffer];

    //
    // Open file
    //

    NTSTATUS Status;
    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( _wcsScope,
                                        &uScope,
                                        0,
                                        0 ) )
    {
        vqDebugOut(( DEB_ERROR, "Error converting %ws to Nt path\n", _wcsScope ));
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XRtlHeapMem xScopeBuf( uScope.Buffer );

    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    CImpersonateRemoteAccess remoteAccess( GetCatalog()->GetImpersonationTokenCache() );

    CRemoteNotifications  remoteNotify( _wcsScope, *this, ObjectAttr );
    if ( _fRemoteDrive )
    {
        //
        // Check if remote notifications are disabled.
        //
        if ( (GetCatalog()->GetRegParams())->GetCiCatalogFlags() &
              CI_FLAGS_NO_REMOTE_NOTIFY )
        {
            vqDebugOut(( DEB_WARN,
            "Not enabling remote notifications because it is disabled in registry\n" ));
            return;
        }

        //
        // Check if the remote drive is a DFS share. If so, don't try
        // to enabled notifications on the share. We have to just periodically
        // scan for changed documents.
        //
        if ( IsDfsShare( _wcsScope, _cwcScope ) )
        {
            vqDebugOut(( DEB_WARN, "Not enabling notifications for DFS Share (%ws) \n",
                         _wcsScope ));

            LogDfsShare();
            return;
        }

        Status = remoteNotify.OpenAndStart( remoteAccess );
    }
    else
    {
        //
        // Check if local notifications are disabled.
        //
        if ( (GetCatalog()->GetRegParams())->GetCiCatalogFlags() &
              CI_FLAGS_NO_LOCAL_NOTIFY )
        {
            vqDebugOut(( DEB_WARN,
            "Not enabling local notifications because it is disabled in registry\n" ));
            return;
        }

        Status = OpenDirectory( ObjectAttr );

        if ( NT_ERROR( Status ) )
        {
            vqDebugOut(( DEB_ERROR,
                         "Notification disabled. NtOpenFile( %ws ) returned 0x%lx\n",
                         _wcsScope, Status ));
            _hNotify = 0;
            if ( _fLogEvents )
                LogNoNotifications( Status );

            return;
        }

        StartNotification( &Status );
    }

    if ( !_fNotifyActive && _fLogEvents )
    {
        LogNoNotifications( Status );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::DisableNotification
//
//  Synopsis:   Disables further notifications for this scope.
//
//  History:    1-17-96   srikants   Created
//
//  Notes:      This must be called from within the lock of the notify manager.
//
//----------------------------------------------------------------------------

void CGenericNotify::DisableNotification()
{
    vqDebugOut(( DEB_ITRACE, "Disable notification for scope %ws this=0x%x\n", _wcsScope, this ));

    if ( 0 != _hNotify )
    {
        NtClose( _hNotify );
        _hNotify = 0;
    }

    Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::StartNotification
//
//  Synopsis:   Starts notifications by setting the APC for receiving
//              notifications. If successful, the object will be refcounted
//              and the status set to indicate that the operation is
//              successful.
//
//  History:    1-17-96   srikants   Created
//
//  Notes:      This must be called from within the lock of the notify manager.
//              If successful, the notify manager will also be
//              refcounted. This is because the APC depends upon the mutex
//              in the notify manager to be around when it is invoked.
//
//----------------------------------------------------------------------------

void CGenericNotify::StartNotification( NTSTATUS * pStatus )
{
    //
    // Set up query directory file.
    //

    if ( 0 == _hNotify ) 
    {
        *pStatus =  STATUS_TOO_LATE;
        return;
    }

    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwFlags = GetNotifyFlags();

    Status = NtNotifyChangeDirectoryFile( _hNotify,
                                          0,
                                          APC,
                                          this,
                                          &_iosNotify,
                                          _pbBuffer,
                                          _cbBuffer,
                                          dwFlags,
                                          (BYTE)_fDeep );

    if ( NT_ERROR(Status) )
    {
        vqDebugOut(( DEB_ERROR,
                     "NtNotifyChangeDirectoryFile( %ws ) returned 0x%lx\n",
                     _wcsScope, Status ));

    }
    else
    {
        _fNotifyActive = TRUE;
        AddRef();
    }

    if ( pStatus )
        *pStatus = Status;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::AddRef
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericNotify::AddRef()
{
    InterlockedIncrement(&_refCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::Release
//
//  Synopsis:   If the refcount goes to 0, the object will be deleted.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericNotify::Release()
{
    Win4Assert( _refCount > 0 );
    if ( InterlockedDecrement(&_refCount) <= 0 )
        delete this;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::AdjustForOverflow
//
//  Synopsis:   Increases the size of the notification buffer if it is not
//              a remote drive and if the current size is < the maximum.
//
//  History:    2-27-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CGenericNotify::AdjustForOverflow()
{
    if ( !_fRemoteDrive && CB_MAXSIZE > _cbBuffer )
    {
        unsigned cbNew = min( _cbBuffer + CB_DELTAINCR, CB_MAXSIZE );

        vqDebugOut(( DEB_ITRACE,
                     "Resizing notification buffer from 0x%X to 0x%X bytes\n",
                     _cbBuffer, cbNew ));

        BYTE * pbNew = new BYTE [cbNew];

        delete [] _pbBuffer;
        _pbBuffer = pbNew;
        _cbBuffer = cbNew;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::APC
//
//  Synopsis:   Asynchronous Procedure Call invoked by the system when there
//              is a change notification (or related error).
//
//  Arguments:  [ApcContext]    -  Pointer to "this"
//              [IoStatusBlock] -
//              [Reserved]      -
//
//  History:    1-17-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CGenericNotify::APC( void * ApcContext,
                          IO_STATUS_BLOCK * IoStatusBlock,
                          ULONG Reserved )
{
    Win4Assert( 0 != ApcContext );

    CGenericNotify * pthis = (CGenericNotify *)ApcContext;

    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        pthis->_fOverflow = FALSE;

        Win4Assert( &pthis->_iosNotify == IoStatusBlock );

//        DbgPrint( "notifications...\n" );

        if ( NT_ERROR( IoStatusBlock->Status ) )
        {
            if ( !pthis->_fAbort )
            {
//                DbgPrint( "Async notification for scope %ws received error 0x%x\n",
//                          pthis->_wcsScope,
//                          IoStatusBlock->Status );
                vqDebugOut(( DEB_ERROR,
                             "Async notification for scope %ws received error 0x%x\n",
                             pthis->_wcsScope,
                             IoStatusBlock->Status ));
                vqDebugOut(( DEB_ITRACE, "CiNotification APC: ERROR 0x%x\n", pthis ));
                status = IoStatusBlock->Status;

                //
                // The I/O failed and it may be due to STATUS_DELETE_PENDING.
                // In any case, just close the handle so the directory is
                // freed for other apps.
                //

                pthis->CloseDirectory();
            }
        }
        else if ( IoStatusBlock->Status == STATUS_NOTIFY_CLEANUP )
        {
            vqDebugOut(( DEB_ITRACE, "CiNotification APC: CLOSE 0x%x\n", pthis ));
        }
        else
        {
            if ( IoStatusBlock->Status == STATUS_NOTIFY_ENUM_DIR )
            {
//                DbgPrint( "***** CiNotification LOST UPDATES for scope %ws *****\n",
//                          pthis->_wcsScope );
                vqDebugOut(( DEB_WARN,
                             "***** CiNotification LOST UPDATES for scope %ws *****\n",
                             pthis->_wcsScope ));
                pthis->_fOverflow = TRUE;

                //
                // Let us adjust the size of the buffer if possible.
                //
                pthis->AdjustForOverflow();

                //
                // But call anyway.  Client is responsible for checking ::BufferOverflow.
                //

                pthis->DoIt();
            }
            else
            {
                // .Information is the # of bytes written to the buffer.
                // This may be 0 even when .Status is STATUS_NOTIFY_ENUM_DIR,
                // and with certain builds of rdr2, STATUS_SUCCESS.


                if ( 0 == IoStatusBlock->Information &&
                     0 == IoStatusBlock->Status )
                {
                    // BrianAn says NTFS won't do this, but rdr2 might

                    vqDebugOut(( DEB_WARN,
                                 "CGenericNotify: invalid notification apc\n" ));

//                    DbgPrint( "0 info and status block\n" );
                }

#if 0
                if ( 0 != IoStatusBlock->Information )
#endif
                {
                    if ( !pthis->_fRemoteDrive )
                    {
                        pthis->DoIt();
                    }
                    else
                    {
                        //
                        // Get sufficient impersonation context to get attributes on
                        // the remote share. Then process the notifications.
                        //
                        CImpersonateRemoteAccess  remote( pthis->GetCatalog()->GetImpersonationTokenCache() );
                        CImpersonatedGetAttr    getAttr( pthis->_wcsScope );
                        getAttr.DoWork( remote );

                        pthis->DoIt();
                    }
                }
            }
        }
    }
    CATCH(CException, e)
    {
//DbgPrint( "caught exception in notifications\n" );
        vqDebugOut(( DEB_ERROR,
                     "CiNotification APC: CATCH 0x%x, iostatus: 0x%x, info: 0x%x\n",
                     e.GetErrorCode(),
                     IoStatusBlock->Status,
                     IoStatusBlock->Information ));


        status = e.GetErrorCode();
    }
    END_CATCH;

    if ( STATUS_SUCCESS != status )
    {
//DbgPrint( "clearing notify enabled\n" );
        pthis->ClearNotifyEnabled();
        if ( pthis->_fLogEvents )
            pthis->LogNotificationsFailed( status );
    }

    pthis->Release();
} //APC

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::IsFixedDrive, private
//
//  Arguments:  [wcsScope] -- Scope to check
//              [len]      -- Length in chars of [wcsScope]
//
//  Returns:    TRUE if scope is for a fixed drive.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CGenericNotify::IsFixedDrive( WCHAR const * wcsScope, ULONG len )
{
    CPathParser pathParser( wcsScope, len );
    if ( pathParser.IsUNCName() )
        return FALSE;

    WCHAR wDrive[MAX_PATH];
    ULONG cc=sizeof(wDrive)/sizeof(WCHAR);
    pathParser.GetFileName( wDrive, cc );

    UINT uType = GetDriveType( wDrive );

    return DRIVE_FIXED == uType;
}

//+---------------------------------------------------------------------------
//
//  Function:   CiNetShareGetInfo
//
//  Synopsis:   Calls NetShareGetInfo.  Loads the library so we don't
//              link to netapi32.dll for the odd case of indexing remote
//              volumes.  Also, don't cache the function pointer since
//              it's called so rarely.
//
//  Arguments:  Same as NetShareGetInfo
//
//  Returns:    Win32 / NetStatus error code
//
//  History:    2-18-98   dlee   Created
//
//----------------------------------------------------------------------------

typedef NET_API_STATUS (NET_API_FUNCTION * NET_SHARE_GET_INFO_FUNC)(
    LPTSTR  servername,
    LPTSTR  netname,
    DWORD   level,
    BYTE ** bufptr );


NET_API_STATUS NET_API_FUNCTION CiNetShareGetInfo(
    LPTSTR  servername,
    LPTSTR  netname,
    DWORD   level,
    BYTE ** bufptr )
{
    HINSTANCE hLib = LoadLibrary( L"netapi32.dll" );
    if ( 0 == hLib )
        return GetLastError();

    NET_SHARE_GET_INFO_FUNC pfn = (NET_SHARE_GET_INFO_FUNC)
                                  GetProcAddress( hLib, "NetShareGetInfo" );

    if ( 0 == pfn )
    {
        FreeLibrary( hLib );
        return GetLastError();
    }

    NET_API_STATUS status = (*pfn)( servername, netname, level, bufptr );
    FreeLibrary( hLib );
    return status;
} //CiNetShareGetInfo

//+---------------------------------------------------------------------------
//
//  Function:   IsDfsShare
//
//  Synopsis:   Determines if the given UNC share is a DFS share.
//
//  Arguments:  [wcsScope] - scope
//              [len]      - Length
//
//  Returns:    TRUE if it is a DFS share. FALSE o/w
//
//  History:    6-23-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CGenericNotify::IsDfsShare( WCHAR const * wcsScope, ULONG len )
{
    CPathParser pathParser( wcsScope, len );
    if ( !pathParser.IsUNCName() )
        return FALSE;

    WCHAR wDrive[MAX_PATH];
    ULONG cc=sizeof(wDrive)/sizeof(WCHAR);
    pathParser.GetFileName( wDrive, cc );

    WCHAR * pwszServerName = wDrive;
    WCHAR * pwszShareName = 0;

    //
    // Locate the third backslash and replace it with a NULL char.
    //
    for ( unsigned i = 2; i < cc; i++ )
    {
        if ( wDrive[i] == L'\\' )
        {
            wDrive[i] = 0;
            pwszShareName = wDrive+i+1;
            break;
        }
    }

    Win4Assert( 0 != pwszShareName );
    //
    // Remove any trailing backslash in the share name.
    //
    i = wcslen( pwszShareName );
    if ( L'\\' == pwszShareName[i-1] )
    {
        pwszShareName[i-1] = 0;
    }

    BOOL fIsDfs = FALSE;
    PSHARE_INFO_1005 shi1005;

    NET_API_STATUS err = CiNetShareGetInfo( pwszServerName,
                                            pwszShareName,
                                            1005,
                                            (PBYTE *) &shi1005 );

    if (err == ERROR_SUCCESS)
    {
        fIsDfs = ((shi1005->shi1005_flags & SHI1005_FLAGS_DFS) != 0);

        //
        // Netapi32.dll midl_user_allocate calls LocalAlloc, so use
        // LocalFree to free up the stuff the stub allocated.
        //

        LocalFree( shi1005 );
    }

    return fIsDfs;
}

void CGenericNotify::LogNotificationsFailed( DWORD dwError ) const
{
    Win4Assert( 0 != dwError );

    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_ERROR_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_NOTIFICATIONS_TURNED_OFF,
                         2 );

        item.AddArg( _wcsScope );

        //
        // When a logon fails, all the other eventlog messages have the
        // WIN32 error code in them. Just to keep it consistent, use the
        // WIN32 error code here also.
        //
        if ( STATUS_LOGON_FAILURE == dwError )
            dwError = ERROR_LOGON_FAILURE;

        item.AddError( dwError );
        eventLog.ReportEvent( item );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
}

void CGenericNotify::LogNoNotifications( DWORD dwError ) const
{
    Win4Assert( 0 != dwError );

    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_INFORMATION_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_NOTIFICATIONS_NOT_STARTED,
                         2 );

        item.AddArg( _wcsScope );

        //
        // When a logon fails, all the other eventlog messages have the
        // WIN32 error code in them. Just to keep it consistent, use the
        // WIN32 error code here also.
        //
        if ( STATUS_LOGON_FAILURE == dwError )
            dwError = ERROR_LOGON_FAILURE;

        item.AddError( dwError );
        eventLog.ReportEvent( item );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericNotify::LogDfsShare
//
//  Synopsis:   Logs the the current share is a DFS aware share.
//
//  History:    6-27-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericNotify::LogDfsShare() const
{
    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_INFORMATION_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_DFS_SHARE_DETECTED,
                         1 );

        item.AddArg( _wcsScope );
        eventLog.ReportEvent( item );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\fnreg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       FNReg.c
//
//  Contents:   Registration routines for IFilterNotify proxy.  Built
//              from macros in RPCProxy.h (expressed in dlldata.c).
//
//  History:    24-Mar-1999  KyleP        Created
//
//----------------------------------------------------------------------------

#include <wtypes.h>
#include <fnreg.h>

#define ENTRY_PREFIX FNPrx
#define PROXY_CLSID FNPrx_CLSID
#define REGISTER_PROXY_DLL 1

CLSID FNPrx_CLSID = { 0xc04efa90,
                      0xe221, 0x11d2,
                      { 0x98, 0x5e, 0x00, 0xc0, 0x4f, 0x57, 0x51, 0x53 } };

#include "filtntfy_dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\filtntfy_p.c: $(PROJECT_ROOT)\published\query\$(O)\filtntfy_p.c
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\scopeenm.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       scopeenm.cxx
//
//  Contents:   File system scope enumerator
//
//  History:    12-Dec-96     SitaramR     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <scopeenm.hxx>
#include <catalog.hxx>
#include <prcstob.hxx>
#include <notifmgr.hxx>
#include <scanmgr.hxx>
#include <scopetbl.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::CScopeEnum, public
//
//  Synopsis:   Initialize scope enumerator
//
//  Arguments:  [cat]              -- Catalog
//              [pQueryPropMapper] -- Pid Remapper associated with the query
//              [fUsePathAlias]  -- TRUE if client is going through rdr/svr
//              [scope]            -- Root of scope
//
//  Requires:   [cbBuf] is at least some minimum size of about 1K.
//
//  History:    17-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

CScopeEnum::CScopeEnum( PCatalog & cat,
                        ICiQueryPropertyMapper *pQueryPropMapper,
                        CSecurityCache & secCache,
                        BOOL fUsePathAlias,
                        CRestriction const & scope )
        : CGenericPropRetriever( cat,
                                 pQueryPropMapper,
                                 secCache,
                                 fUsePathAlias ? &scope : 0,
                                 FILE_READ_ATTRIBUTES ),
          _scope( scope ),
          _xbBuf( FINDFIRST_BUFFER ),
          _hDir( INVALID_HANDLE_VALUE ),
          _pCurEntry( 0 ),
          _iFirstSubDir( 2 ),
          _num( 0 ),
          _numHighValue( 10000 ),   // Numerator ranges from 0 to 10,000 and the denominator is always 10,000
          _numLowValue( 0 ),
          _fNullCatalog( cat.IsNullCatalog() )
{
    _VPath.Buffer = _awcVPath;

    //
    // Allocate buffer.
    //

    Win4Assert( _xbBuf.SizeOf() >= MAX_PATH * sizeof(WCHAR) +
                sizeof(FILE_DIRECTORY_INFORMATION) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::~CScopeEnum, public
//
//  Synopsis:   Close file store scope enumerator
//
//  History:    17-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

CScopeEnum::~CScopeEnum()
{
    _xDirStackEntry.Free();

    if ( INVALID_HANDLE_VALUE != _hDir )
        NtClose( _hDir );
}



//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::PushScope
//
//  Synopsis:   Adds scope
//
//  History:    12-Dec-96     SitaramR     Added header
//
//--------------------------------------------------------------------------


void CScopeEnum::PushScope( CScopeRestriction const & scp )
{
    //
    // Push initial directories
    //

    if ( scp.IsVirtual() )
    {
        unsigned iBmk = 0;
        XGrowable<WCHAR> xwcsVPath;
        CLowerFunnyPath lcaseFunnyPPath;

        unsigned ccVPath = xwcsVPath.Count();
        unsigned ccPPath = lcaseFunnyPPath.Count();

        while ( _cat.VirtualToPhysicalRoot( scp.GetPath(),     // Virtual scope (prefix)
                                            scp.PathLength(),  //   + length
                                            xwcsVPath,         // Full virtual root
                                            ccVPath,           //   + max length / return length
                                            lcaseFunnyPPath,   // Full physical root
                                            ccPPath,           //   + max length / return length
                                            iBmk ) )           // Bookmark
        {
            vqDebugOut(( DEB_ITRACE, "VPath %.*ws --> PPath %ws\n",
                         ccVPath, xwcsVPath.Get(),
                         lcaseFunnyPPath.GetActualPath() ));

            //
            // Use the directory if it is eligible, and is either
            //    a deep scope
            //    not the root "/", which by this point is an empty string
            //    is the root, is shallow, and this is the 1 and only "/"
            //

            if ( ( _cat.IsEligibleForFiltering( lcaseFunnyPPath.GetActualPath() ) ) &&
                 ( ( scp.IsDeep() ) ||
                   ( 0 != scp.PathLength() ) ||
                   ( 1 == ccVPath ) ) )
            {
                XPtr<CDirStackEntry> xDirStackEntry(
                    new CDirStackEntry(
                            lcaseFunnyPPath,
                            10000, 0,               // For scope progress
                            scp.IsDeep(),
                            xwcsVPath.Get(),
                            ccVPath,                // Virtual root
                            lcaseFunnyPPath.GetActualLength()));
                                            // Amount of proot to replace.  Do
                                            // not count \\?\ as replace chars


                _stack.Push( xDirStackEntry.GetPointer() );
                xDirStackEntry.Acquire();
            }
            else
            {
                vqDebugOut(( DEB_IWARN, "Skipped scope: file %ws\n",
                             lcaseFunnyPPath.GetActualPath() ));
            }
            ccVPath = xwcsVPath.Count();
            ccPPath = lcaseFunnyPPath.Count();
        }
    }
    else
    {
        WCHAR const *pwcScope = scp.GetPath();
        Win4Assert( 0 != pwcScope );

        if ( 0 == *pwcScope )
        {
            //
            // Add all physical scopes if scope is root, but not for shallow
            // traversal.
            //

            if ( scp.IsDeep() )
            {
                CCiScopeTable *pScopes = _cat.GetScopeTable();
                if ( 0 != pScopes )
                {
                    unsigned iBmk = 0;
                    WCHAR awc[MAX_PATH];
                    while ( pScopes->Enumerate( awc,
                                                sizeof awc / sizeof WCHAR,
                                                iBmk ) )
                    {
                        if ( _cat.IsEligibleForFiltering( awc ) )
                        {
                            XPtr<CDirStackEntry> xDirStackEntry(
                                new CDirStackEntry( awc,
                                                    wcslen(awc),
                                                    10000,
                                                    0,
                                                    scp.IsDeep() ) );
                            _stack.Push( xDirStackEntry.GetPointer() );
                            xDirStackEntry.Acquire();
                            vqDebugOut(( DEB_ITRACE, "adding enum scope '%ws'\n", awc ));
                        }
                    }
                }
            }
        }
        else
        {

            CLowerFunnyPath lcaseFunnyFixedPath = scp.GetFunnyPath();
        
            //
            // if scope is unc, use fixed up version
            //

            if ( lcaseFunnyFixedPath.IsRemote() )
            {
                // unc -- try to unfixup the scope.  if there is no unfixup,
                // it'll just use the original path.

                _cat.InverseFixupPath( lcaseFunnyFixedPath );
            }

            //
            // Check to see if the input path name contains an 8.3 short name
            //
            if ( lcaseFunnyFixedPath.IsShortPath() )
            {
                vqDebugOut(( DEB_WARN,
                             "CScopeEnum::PushScope: possible shortname path\n\t%ws ==>\n",
                             lcaseFunnyFixedPath.GetActualPath() ));

                if ( lcaseFunnyFixedPath.ConvertToLongName() )
                {
                    vqDebugOut(( DEB_WARN|DEB_NOCOMPNAME,
                                 "\t%ws\n",
                                 lcaseFunnyFixedPath.GetActualPath() ));
                }
                else
                {
                    vqDebugOut(( DEB_ERROR, "longname path conversion failed!\n" ));
                }
            }

            if ( _cat.IsEligibleForFiltering( lcaseFunnyFixedPath.GetActualPath() ) )
            {
                XPtr<CDirStackEntry> xDirStackEntry(
                        new CDirStackEntry( lcaseFunnyFixedPath.GetActualPath(),
                                            lcaseFunnyFixedPath.GetActualLength(),
                                            10000,
                                            0,
                                            scp.IsDeep() ) );
                _stack.Push( xDirStackEntry.GetPointer() );
                xDirStackEntry.Acquire();
            }
            else
            {
                vqDebugOut(( DEB_IWARN, "Unfiltered scope: %ws\n", scp.GetPath() ));
            }
        }
    }
} //PushScope

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::NextObject, public
//
//  Synopsis:   Move to next object.
//
//  Returns:    WORKID of object.  widInvalid if no more objects to iterate.
//
//  History:    17-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

WORKID CScopeEnum::NextObject()
{
    _VPath.Length = flagNoValueYet;
    WORKID wid = widInvalid;

    while ( TRUE )
    {
        //
        // Move to next entry in current buffer.
        //

        if ( _pCurEntry )
            _pCurEntry = _pCurEntry->Next();

        //
        // Out of entries in buffer? Try to reload buffer.
        //

        if ( _pCurEntry == 0 )
        {
            if ( Refresh() )
                _pCurEntry = (CDirEntry *)_xbBuf.GetPointer();
            else
                break;
        }

        //
        // Get rid of . and ..
        //

        WCHAR const * pwcsFilename = _pCurEntry->Filename();
        USHORT  cbFilename = _pCurEntry->FilenameSize();

        if ( pwcsFilename[0] == L'.' )
        {
            if ( cbFilename == sizeof(WCHAR) )
                continue;
            else if ( pwcsFilename[1] == L'.' )
            {
                if ( cbFilename == sizeof(WCHAR)*2 )
                    continue;
            }
        }

        // normalize the filename

        ULONG cwcInOut = _pCurEntry->FilenameSize() / sizeof WCHAR;

        ULONG cwc = LCMapStringW( LOCALE_NEUTRAL,
                                  LCMAP_LOWERCASE,
                                  (WCHAR *) _pCurEntry->Filename(),
                                  cwcInOut,
                                  (WCHAR *) _pCurEntry->Filename(),
                                  cwcInOut );

        if ( 0 == cwc )
        {
            ciDebugOut(( DEB_WARN, "unable to lowcase filename\n" ));
        }

        _Name.Length = _Name.MaximumLength = (USHORT) cwc * sizeof WCHAR;

        //
        // If it's a directory and not a reparse point, push on stack.  We
        // don't fully handle reparse points so we must deny their existence.
        //

        if ( ( _xDirStackEntry->isDeep() ) &&
             ( _pCurEntry->Attributes() & FILE_ATTRIBUTE_DIRECTORY ) &&
             ( 0 == ( _pCurEntry->Attributes() & FILE_ATTRIBUTE_REPARSE_POINT ) ) )
        {
            XPtr<CDirStackEntry> xDirStackEntry(
                    new CDirStackEntry( GetPath(),
                                        GetName(),
                                        0,
                                        0,
                                        _xDirStackEntry->isDeep(),
                                        _xDirStackEntry.GetPointer() ) );

            if (_cat.IsEligibleForFiltering( xDirStackEntry->GetFileName().GetActualPath() ))
            {
                _stack.Push( xDirStackEntry.GetPointer() );
                xDirStackEntry.Acquire();
            }
            else
            {
               vqDebugOut(( DEB_IWARN, "Unfiltered directory: %ws\n",
                            xDirStackEntry->GetFileName() ));
               continue;
            }
        }

        //
        // Filter based upon file attributes
        //

        if ( 0 == _ulAttribFilter || ( _ulAttribFilter & _pCurEntry->Attributes() ) == 0 )
        {
            Win4Assert( 0 != _pCurEntry );

            vqDebugOut(( DEB_FINDFIRST, "Found %.*ws\n",
                         _pCurEntry->FilenameSize() / sizeof(WCHAR),
                         _pCurEntry->Filename() ));

            if ( _xDirStackEntry->isDeep() )
            {
                //
                //  It's a deep query, so we allocate 30% to traversing the current dir
                //  (remaining 70% is allocated to the sub-directories). However, if _numHighValue
                //  is 0 then it means that the quota allocated to this directory is too small to
                //  impact RatioFinished, so we stay put at the current value of RatioFinished
                //

                if ( _numHighValue != 0 )
                {
                    if ( (_num + 100) <  ( (100 - DIRECTORY_QUOTA) * _numLowValue) / 100 + (DIRECTORY_QUOTA * _numHighValue) / 100 )
                        _num += 100;
                }
            }
            else
            {
                //
                // It's a shallow query, so we go upto 90% and then we stay put until we are done
                //

                if ( _num < _xDirStackEntry->GetHighValue() * SHALLOW_DIR_LIMIT / 100 )
                    _num += 100;
            }

            // this is just a file index -- not of much value, since it isn't
            // the same as the workid in the CCI (if one exists)
            //return( _pCurEntry->WorkId() );

            // If a catalog exists, look up the path or add the path and get
            // a workid back.  This can be really expensive if every path is
            // added to the catalog, but there is no alternative for multi-cursor
            // queries.


            PCatalog & cat = _cat;

            CLowerFunnyPath lcaseFunnyBuf;
            if (!_fNullCatalog)
            {
                UNICODE_STRING const * pFilename = GetName();
                UNICODE_STRING const * pPath = GetPath();

                lcaseFunnyBuf.SetPath( pPath->Buffer, pPath->Length/sizeof(WCHAR) );
                lcaseFunnyBuf.AppendBackSlash();
                lcaseFunnyBuf.AppendPath( pFilename->Buffer, pFilename->Length/sizeof(WCHAR) );

                Win4Assert( IsPropRecReleased() );

                wid = cat.PathToWorkId( lcaseFunnyBuf, TRUE );
            }
            else
            {
                lcaseFunnyBuf.InitBlank();
                wid = cat.PathToWorkId(lcaseFunnyBuf, TRUE);
            }

            //
            // If we got widInvalid back here, then the file is not eligible for search
            // and we need to go to the next one.
            //

            if ( widInvalid != wid )
                break;
        }
    }

    return wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::RatioFinished, public
//
//  Synopsis:   Returns query progress estimate
//
//  Arguments:  [denom] -- Denominator returned here.
//              [num]   -- Numerator returned here.
//
//  History:    19-Jul-95   KyleP       Added header
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::RatioFinished (ULONG *pDenom, ULONG *pNum)
{
    *pDenom = 10000;
    *pNum = _num;

    Win4Assert( *pNum <= *pDenom );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::GetVirtualPath, public
//
//  Returns:    A virtual path to file, or 0 if none exists.
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CScopeEnum::GetVirtualPath()
{
    if ( _VPath.Length == flagNoValueYet )
    {
        //
        // Fast path: Iterating by virtual scope.
        //

        Win4Assert( !_xDirStackEntry.IsNull() );

        if ( _xDirStackEntry->GetVirtualRoot() )
        {
            RtlCopyMemory( _VPath.Buffer,
                           _xDirStackEntry->GetVirtualRoot(),
                           _xDirStackEntry->VirtualRootLength() * sizeof(WCHAR) );

            if ( _Path.Length >= _xDirStackEntry->ReplaceLength() * sizeof(WCHAR) )
            {
                if ( ( _xDirStackEntry->VirtualRootLength() +
                       ( _Path.Length - _xDirStackEntry->ReplaceLength() ) ) >= MAX_PATH )
                    THROW( CException( E_INVALIDARG ) );

                RtlCopyMemory( _VPath.Buffer + _xDirStackEntry->VirtualRootLength(),
                               _Path.Buffer + _xDirStackEntry->ReplaceLength(),
                               _Path.Length - _xDirStackEntry->ReplaceLength() * sizeof(WCHAR) );

                _VPath.Length = (USHORT)(_xDirStackEntry->VirtualRootLength() * sizeof(WCHAR) +
                                _Path.Length - _xDirStackEntry->ReplaceLength() * sizeof(WCHAR));
            }
            else
            {
                Win4Assert( _Path.Length == (_xDirStackEntry->ReplaceLength() - 1) * sizeof(WCHAR) );

                _VPath.Length = (USHORT)((_xDirStackEntry->VirtualRootLength() - 1) * sizeof(WCHAR));
            }

            _VPath.Buffer[_VPath.Length / sizeof(WCHAR)] = 0;
        }
        else
        {
            //
            // Get a virtual path from catalog.
            //

            PCatalog & cat = _cat;

            //
            // It's slow to Quiesce here, but after all this is an
            // enumeration query and this can't affect the run time
            // substantially.  We can re-address this if some important
            // customer scenario is hit.
            //

            Quiesce();

            unsigned cwc = sizeof( _awcVPath ) / sizeof( WCHAR );

            XGrowable<WCHAR> xTemp;
            cwc = cat.WorkIdToVirtualPath ( _widPrimedForPropRetrieval, 0, xTemp );
            RtlCopyMemory( _VPath.Buffer, xTemp.Get(), __min( cwc * sizeof(WCHAR), sizeof( _awcVPath ) ) );

            if ( cwc == 0 )
                _VPath.Length = flagNoValue;
            else
                _VPath.Length = (USHORT)(cwc * sizeof(WCHAR) - _pCurEntry->FilenameSize() - sizeof(WCHAR));
        }
    }

    if ( flagNoValue == _VPath.Length )
        return 0;

    return &_VPath;
} //GetVirtualPath

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::Refresh, private
//
//  Synopsis:   Load stat properties
//
//  Returns:    TRUE if load succeeds.
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CScopeEnum::Refresh()
{
    BOOL fRetVal = FALSE;
    CImpersonateClient impClient( GetClientToken() );

    IO_STATUS_BLOCK IoStatus;

    //
    // Continue existing search if possible
    //

    if ( _hDir != INVALID_HANDLE_VALUE )
    {
        if ( SUCCEEDED( NtQueryDirectoryFile( _hDir,                  // File
                                              0,                      // Event
                                              0,                      // APC routine
                                              0,                      // APC context
                                              &IoStatus,              // I/O Status
                                              _xbBuf.GetPointer(),    // Buffer
                                              _xbBuf.SizeOf(),        // Buffer Length
                                              FileBothDirectoryInformation,
                                              0,                      // Multiple entry
                                              0,                      // Filename
                                              0 ) ) )                 // Continue scan
        {
            return( TRUE );
        }
        else
        {
            NtClose( _hDir );
            _hDir = INVALID_HANDLE_VALUE;
        }
    }

    //
    // Is there another directory?
    //

    _xDirStackEntry.Free();

    //
    // If _numHighValue is 0, then it means that the quota allocated to this directory
    // is too small to impact RatioFinished, so we stay put at current value of RatioFinished
    //

    if ( _numHighValue != 0 )
    {
        Win4Assert( _iFirstSubDir >= 0 );

        if ( _stack.Count() > (unsigned) _iFirstSubDir )     // Are there any sub-directories ?
        {
            //
            // We divide up the remaining 70% of our quota among our sub-directories
            //

            ULONG cSubDir = _stack.Count() - _iFirstSubDir;
            ULONG numIncrement = ( _numHighValue - _num ) / cSubDir;

            if ( numIncrement > 0 )
            {
                ULONG num = _num;

                for ( int i = _stack.Count()-1; i>_iFirstSubDir; i-- )
                {
                    CDirStackEntry *pDirStackEntry = _stack.Get( i );
                    Win4Assert( pDirStackEntry );

                    pDirStackEntry->SetLowValue( num );
                    num += numIncrement;
                    pDirStackEntry->SetHighValue( num );
                    Win4Assert( pDirStackEntry->IsRangeOK() );
                }

                //
                // Allocate all remaining quota to the last sub-directory
                //

                CDirStackEntry *pDirStackEntry = _stack.Get( _iFirstSubDir );
                Win4Assert( pDirStackEntry );

                pDirStackEntry->SetLowValue( num );
                pDirStackEntry->SetHighValue( _numHighValue );
                Win4Assert( pDirStackEntry->IsRangeOK() );
            }
            else
            {
                //
                // Since numIncrement is too small, we allocate all quota to just the last sub-directory
                //

                CDirStackEntry *pDirStackEntry = _stack.Get( _iFirstSubDir );
                Win4Assert( pDirStackEntry );

                pDirStackEntry->SetLowValue( _num );
                pDirStackEntry->SetHighValue( _numHighValue );
                Win4Assert( pDirStackEntry->IsRangeOK() );
            }
        }
    }

    while ( _stack.Count() > 0 )
    {
        Win4Assert( _xDirStackEntry.IsNull() );
        _xDirStackEntry.Set( _stack.Pop() );
        _VPath.Length = flagNoValueYet;

        _Path.Buffer = (WCHAR*)_xDirStackEntry->GetFileName().GetActualPath();
        _numHighValue = _xDirStackEntry->GetHighValue();
        _numLowValue = _xDirStackEntry->GetLowValue();


#if CIDBG == 1
        if ( _numHighValue != 0 )
        {
            Win4Assert( _numLowValue >= _num );
            Win4Assert( _numHighValue >= _numLowValue );
        }
#endif CIDBG


        _iFirstSubDir = _stack.Count();    // This will be the stack index of the first subdirectory (if any)

        unsigned cc = _xDirStackEntry->GetFileName().GetActualLength();

        //
        // Remove trailing '\' from root.
        //
        if ( _Path.Buffer[cc-1] == L'\\' )
            cc--;

        if ( cc >= 32768 )
            THROW( CException( E_INVALIDARG ) );

        _Path.Length = _Path.MaximumLength = (USHORT)(cc * sizeof(WCHAR));


        if ( CImpersonateRemoteAccess::IsNetPath( _Path.Buffer ) )
        {
            WCHAR const * pwszVPath = 0;
            if ( _xDirStackEntry->isVirtual() )
            {
                UNICODE_STRING const * vPath = GetVirtualPath();
                if ( vPath )
                    pwszVPath = vPath->Buffer;
            }

            if ( !_remoteAccess.ImpersonateIfNoThrow( _Path.Buffer, pwszVPath ) )
            {
                vqDebugOut(( DEB_WARN,
                             "CScopeEnum::Refresh -- Skipping unavailable remote path %ws\n", _Path.Buffer ));

                _num = _numHighValue;

               _xDirStackEntry.Free();

                continue;
            }
        }
        else if ( _remoteAccess.IsImpersonated() )
        {
            _remoteAccess.Release();
        }

        UNICODE_STRING uScope;

        if ( !RtlDosPathNameToNtPathName_U( _xDirStackEntry->GetFileName().GetPath(),
                                            &uScope,
                                            0,
                                            0 ) )
        {
            _xDirStackEntry.Free();
            break; // fRetVal = FALSE;
        }

        // Set the state of the funnypath in _xDirStackEntry to ActualPath
        // as the above call would have changed it to the funny state
        _xDirStackEntry->GetFileName().SetState( CFunnyPath::ACTUAL_PATH_STATE );

        //
        // Open scope.
        //

        OBJECT_ATTRIBUTES ObjectAttr;

        InitializeObjectAttributes( &ObjectAttr,          // Structure
                                    &uScope,              // Name
                                    OBJ_CASE_INSENSITIVE, // Attributes
                                    0,                    // Root
                                    0 );                  // Security

        NTSTATUS Status = NtOpenFile( &_hDir,             // Handle
                                      FILE_LIST_DIRECTORY |
                                          SYNCHRONIZE,    // Access
                                      &ObjectAttr,        // Object Attributes
                                      &IoStatus,          // I/O Status block
                                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                      FILE_DIRECTORY_FILE |
                                      FILE_OPEN_FOR_BACKUP_INTENT |
                                      FILE_SYNCHRONOUS_IO_NONALERT ); // Flags

        RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

        UNICODE_STRING uFilename;
        uFilename.Buffer = L"*";
        uFilename.Length = uFilename.MaximumLength = sizeof(WCHAR);

        if ( SUCCEEDED( Status ) )
        {
            Status =  NtQueryDirectoryFile( _hDir,                  // File
                                            0,                      // Event
                                            0,                      // APC routine
                                            0,                      // APC context
                                            &IoStatus,              // I/O Status
                                            _xbBuf.GetPointer(),    // Buffer
                                            _xbBuf.SizeOf(),        // Buffer Length
                                            FileBothDirectoryInformation,
                                            0,                      // Multiple entry
                                            &uFilename,             // Filename
                                            1 );                    // Restart scan
        }

        if ( SUCCEEDED( Status ) )
        {
            fRetVal = TRUE;
            break;
        }

        _xDirStackEntry.Free();
    }

    if ( _remoteAccess.IsImpersonated() )
    {
        _remoteAccess.Release();
    }

    return fRetVal;
}





//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::BeginPropertyRetrieval
//
//  Synopsis:   Prime wid for property retrieval
//
//  Arguments:  [wid]    -- Wid to prime
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::BeginPropertyRetrieval( WORKID wid )
{
    //
    // Check that we are retrieving the property for the wid on
    // which we are currently positioned. In the case of the null catalog,
    // we always have _widCurrent as 1, so allow for that special case.
    //


    Win4Assert( wid == _widCurrent || 1 == _widCurrent);
    Win4Assert( _widPrimedForPropRetrieval == widInvalid );

    if ( wid == _widCurrent || 1 == _widCurrent)
    {
        _widPrimedForPropRetrieval = wid;
        return S_OK;
    }
    else
        return E_FAIL;
}



//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::IsInScope
//
//  Synopsis:   Checks if current wid is in scope
//
//  Arguments:  [pfInScope]   -- Scope check result returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::IsInScope( BOOL *pfInScope )
{
    if ( widInvalid == _widPrimedForPropRetrieval )
        return CI_E_WORKID_NOTVALID;

    *pfInScope = TRUE;

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::Begin
//
//  Synopsis:   Begins an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::Begin()
{
    SCODE sc = S_OK;

    TRY
    {
        Win4Assert( _stack.Count() == 0 );
        Win4Assert( _hDir == INVALID_HANDLE_VALUE );
        Win4Assert( _xDirStackEntry.IsNull() );
        Win4Assert( _pCurEntry == 0 );

        _VPath.Length = flagNoValueYet;
        _Path.Buffer = 0;

        if ( RTScope == _scope.Type() )
        {
            PushScope( (CScopeRestriction const &) _scope );
        }
        else if ( RTOr == _scope.Type() )
        {
            CNodeRestriction const & node = * _scope.CastToNode();

            for ( ULONG x = 0; x < node.Count(); x++ )
            {
                Win4Assert( RTScope == node.GetChild( x )->Type() );

                PushScope( * (CScopeRestriction *) node.GetChild( x ) );
            }
        }

        //
        // Adjust 'percent-done' counters.
        //

        if ( _stack.Count() > 1 )
        {
            ULONG cPerDir = 10000 / _stack.Count();
            ULONG cLow = 0;

            for ( unsigned i = 1; i <= _stack.Count(); i++ )
            {
                CDirStackEntry * pEntry = _stack.Get( _stack.Count() - i );

                pEntry->SetLowValue( cLow );
                cLow += cPerDir;
                pEntry->SetHighValue( cLow );
                Win4Assert( pEntry->IsRangeOK() );
                cLow++;
            }

            _stack.Get( 0 )->SetHighValue( 10000 );
            Win4Assert( _stack.Get( 0 )->IsRangeOK() );
            _iFirstSubDir = _stack.Count() + 1;
        }

        //
        // Get first object
        //

        _widCurrent = NextObject();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "CScopeEnum::Begin - Exception caught 0x%x\n", sc ));
    }
    END_CATCH;

    return sc;
}






//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::CurrentDocument
//
//  Synopsis:   Returns current document
//
//  Arguments:  [pWorkId]  -- Wid of current doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::CurrentDocument( WORKID *pWorkId )
{
    *pWorkId = _widCurrent;
    if ( _widCurrent == widInvalid )
        return CI_S_END_OF_ENUMERATION;
    else
        return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::NextDocument
//
//  Synopsis:   Returns next document
//
//  Arguments:  [pWorkId]  -- Wid of next doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::NextDocument( WORKID *pWorkId )
{
    SCODE sc = S_OK;

    TRY
    {
        _widCurrent = NextObject();

        sc = CurrentDocument( pWorkId );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CScopeEnum::NextDocument - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEnum::End
//
//  Synopsis:   Ends an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::End()
{
    SCODE sc = S_OK;

    TRY
    {
        _stack.Clear();
        if ( INVALID_HANDLE_VALUE != _hDir )
        {
            NtClose( _hDir );
            _hDir = INVALID_HANDLE_VALUE;
        }

        _xDirStackEntry.Free();
        _pCurEntry = 0;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CScopeEnum::End - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
} //End

//+-------------------------------------------------------------------------
//
//  Method:     CScopeEnum::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Dec-1996      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CScopeEnum::AddRef()
{
    return CGenericPropRetriever::AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CScopeEnum::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Dec-1996     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CScopeEnum::Release()
{
    return CGenericPropRetriever::Release();
}



//+-------------------------------------------------------------------------
//
//  Method:     CScopeEnum::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Dec-1996     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CScopeEnum::QueryInterface(
    REFIID riid,
    void  ** ppvObject)
{
    if ( IID_ICiCScopeEnumerator == riid )
        *ppvObject = (ICiCScopeEnumerator *)this;
    else if ( IID_ICiCPropRetriever == riid )
        *ppvObject = (ICiCPropRetriever *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(ICiCScopeEnumerator *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\metapenm.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       metapenm.cxx
//
//  Contents:   Meta property enumerator
//
//  History:    12-Dec-96     SitaramR     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <metapenm.hxx>
#include <catalog.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::CMetaPropEnum, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cat]              -- Catalog
//              [pQueryPropMapper] -- Pid Remapper associated with the query
//              [secCache]         -- Cache of AccessCheck() results
//              [fUsePathAlias]  -- TRUE if client is going through rdr/svr
//
//  History:    19-Aug-93  KyleP    Created
//
//--------------------------------------------------------------------------

CMetaPropEnum::CMetaPropEnum( PCatalog & cat,
                              ICiQueryPropertyMapper *pQueryPropMapper,
                              CSecurityCache & secCache,
                              BOOL fUsePathAlias )
        : CGenericPropRetriever( cat,
                                 pQueryPropMapper,
                                 secCache,
                                 0 ),       // Never fixup 'path'
          _iBmk( 0 )
{
    _Path.Buffer = _awcGuid;
    _Path.Length = ccStringizedGuid * sizeof(WCHAR);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::~CMetaPropEnum, public
//
//  Synopsis:   Destructor
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

CMetaPropEnum::~CMetaPropEnum()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::NextObject, public
//
//  Synopsis:   Move to next object
//
//  Returns:    Work id of next valid object, or widInvalid if end of
//              iteration.
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

WORKID CMetaPropEnum::NextObject()
{
    if ( !_cat.EnumerateProperty( _psCurrent, _cbCurrent, _typeCurrent,
                                  _storeLevelCurrent, _fModifiableCurrent,
                                  _iBmk ) )
        return widInvalid;

    //
    // String-ify the guid
    //

    swprintf( _awcGuid,
              L"%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
              _psCurrent.GetPropSet().Data1,
              _psCurrent.GetPropSet().Data2,
              _psCurrent.GetPropSet().Data3,
              _psCurrent.GetPropSet().Data4[0], _psCurrent.GetPropSet().Data4[1],
              _psCurrent.GetPropSet().Data4[2], _psCurrent.GetPropSet().Data4[3],
              _psCurrent.GetPropSet().Data4[4], _psCurrent.GetPropSet().Data4[5],
              _psCurrent.GetPropSet().Data4[6], _psCurrent.GetPropSet().Data4[7] );

    //
    // String-ify the PropId, if appropriate.
    //

    if ( _psCurrent.IsPropertyPropid() )
    {
        _Name.Length = (USHORT)(sizeof(WCHAR) * swprintf( _awcPropId, L"%u", _psCurrent.GetPropertyPropid() ));
        _Name.Buffer = _awcPropId;
    }
    else
    {
        _Name.Buffer = (WCHAR *)_psCurrent.GetPropertyName();
        _Name.Length = sizeof(WCHAR) * wcslen( _Name.Buffer );
    }

    return _iBmk;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::GetPropGuid
//
//  Synopsis:   Returns guid property
//
//  History:    12-Dec-96    SitaramR     Added header
//
//--------------------------------------------------------------------------

BOOL CMetaPropEnum::GetPropGuid( GUID & guid )
{
    RtlCopyMemory( &guid, &(_psCurrent.GetPropSet()), sizeof(guid) );
    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::GetPropPid
//
//  Synopsis:   Returns propid property
//
//  History:    12-Dec-96    SitaramR     Added header
//
//--------------------------------------------------------------------------

PROPID CMetaPropEnum::GetPropPropid()
{
    if ( _psCurrent.IsPropertyPropid() )
        return _psCurrent.GetPropertyPropid();
    else
        return pidInvalid;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::GetPropName
//
//  Synopsis:   Returns propname property
//
//  History:    12-Dec-96    SitaramR     Added header
//
//--------------------------------------------------------------------------

UNICODE_STRING const * CMetaPropEnum::GetPropName()
{
    if ( _psCurrent.IsPropertyName() )
        return &_Name;
    else
        return 0;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::BeginPropertyRetrieval
//
//  Synopsis:   Prime wid for property retrieval
//
//  Arguments:  [wid]    -- Wid to prime
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::BeginPropertyRetrieval( WORKID wid )
{
    //
    // Check that we are retrieving the property for the wid on
    // which we are currently positioned
    //
    Win4Assert( wid == _widCurrent );
    Win4Assert( _widPrimedForPropRetrieval == widInvalid );

    if ( wid == _widCurrent )
    {
        _widPrimedForPropRetrieval = _widCurrent;
        return S_OK;
    }
    else
        return E_FAIL;
}




//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::IsInScope
//
//  Synopsis:   Checks if current wid is in scope
//
//  Arguments:  [pfInScope]   -- Scope check result returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::IsInScope( BOOL *pfInScope )
{
    if ( widInvalid == _widPrimedForPropRetrieval )
        return CI_E_WORKID_NOTVALID;

    *pfInScope = TRUE;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::CheckSecurity
//
//  Synopsis:   Test wid for security access
//
//  Arguments:  [am]        -- Access Mask
//              [pfGranted] -- Result of security check returned here
//
//  History:    12-Dec-96     SitaramR     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::CheckSecurity( ACCESS_MASK am,
                                                      BOOL *pfGranted)
{
    if ( _widPrimedForPropRetrieval == widInvalid )
        return CI_E_WORKID_NOTVALID;

    *pfGranted = TRUE;

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::Begin
//
//  Synopsis:   Begins an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::Begin()
{
    SCODE sc = S_OK;

    TRY
    {
        _iBmk = 0;

        _widCurrent = NextObject();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CMetaPropEnum::Begin - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::CurrentDocument
//
//  Synopsis:   Returns current document
//
//  Arguments:  [pWorkId]  -- Wid of current doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::CurrentDocument( WORKID *pWorkId )
{
    *pWorkId = _widCurrent;
    if ( _widCurrent == widInvalid )
        return CI_S_END_OF_ENUMERATION;
    else
        return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::NextDocument
//
//  Synopsis:   Returns next document
//
//  Arguments:  [pWorkId]  -- Wid of next doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::NextDocument( WORKID *pWorkId )
{
    SCODE sc = S_OK;

    TRY
    {
        _widCurrent = NextObject();

        sc = CurrentDocument( pWorkId );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CMetaPropEnum::NextDocument - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::End
//
//  Synopsis:   Ends an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::End()
{
    _widCurrent = widInvalid;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMetaPropEnum::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Dec-1996      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMetaPropEnum::AddRef()
{
    return CGenericPropRetriever::AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMetaPropEnum::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Dec-1996     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMetaPropEnum::Release()
{
    return CGenericPropRetriever::Release();
}



//+-------------------------------------------------------------------------
//
//  Method:     CMetaPropEnum::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Dec-1996     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::QueryInterface(
    REFIID riid,
    void  ** ppvObject)
{
    if ( IID_ICiCScopeEnumerator == riid )
        *ppvObject = (ICiCScopeEnumerator *)this;
    else if ( IID_ICiCPropRetriever == riid )
        *ppvObject = (ICiCPropRetriever *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(ICiCScopeEnumerator *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMetaPropEnum::RatioFinished, public
//
//  Synopsis:   Returns query progress estimate
//
//  Arguments:  [denom] -- Denominator returned here
//              [num]   -- Numerator returned here
//
//  History:    12-Dec-96   SitaramR      Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaPropEnum::RatioFinished (ULONG *pDenom, ULONG *pNum)
{
    *pNum = 50;
    *pDenom = 100;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\service.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       service.cxx
//
//  Contents:   CI service
//
//  History:    17-Sep-96   dlee   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dbt.h>
#include <initguid.h>   // so we know the value of GUIDs
#include <ioevent.h>
#include <cievtmsg.h>
#include <cisvcex.hxx>
#include <eventlog.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <drvnotif.hxx>
#include <notifary.hxx>

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULT_CODE(hr)     ((hr) & 0xFFFF)
#define HRESULTTOWIN32(hres) ((HRESULT_FACILITY(hres) == FACILITY_WIN32) ? HRESULT_CODE(hres) : (hres))

static const DWORD dwServiceWaitHint = 60000;   // 60 seconds

SERVICE_STATUS_HANDLE g_hTheCiSvc = 0;
static DWORD dwCiSvcStatus = SERVICE_START_PENDING;

#define DEB_CI_MOUNT DEB_ITRACE

// 1: 324666 is fixed
// 0: 324666 is not fixed and we need an extra thread to work around it

#define SYNC_REGISTER 1

BOOL g_fSCMThreadIsGone = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:   UpdateServiceStatus
//
//  Synopsis:   Does a SetServiceStatus() to the service manager.
//
//  History:    06-Jun-94   DwightKr    Created
//
//-----------------------------------------------------------------------------

void UpdateServiceStatus( DWORD dwWin32ExitCode )
{
    // note to accept power events, "OR" SERVICE_ACCEPT_POWER_EVENTS here
    static SERVICE_STATUS CiSvcStatus =
    {
        SERVICE_WIN32_OWN_PROCESS |         // dwServiceType
          SERVICE_INTERACTIVE_PROCESS,      // add this line for interactive
        0,                                  // dwCurrentState
        SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE |
        SERVICE_ACCEPT_SHUTDOWN,
        NO_ERROR,                           // dwWin32ExitCode
        0,                                  // dwServiceSpecificExitCode
        0,                                  // dwCheckPoint
        0                                   // dwWaitHint
    };

    CiSvcStatus.dwCurrentState  = dwCiSvcStatus;

    CiSvcStatus.dwWin32ExitCode = dwWin32ExitCode;

    if ( dwCiSvcStatus == SERVICE_START_PENDING ||
         dwCiSvcStatus == SERVICE_STOP_PENDING )
    {
        CiSvcStatus.dwCheckPoint++;
        CiSvcStatus.dwWaitHint = dwServiceWaitHint;
    }
    else // SERVICE_RUNNING, SERVICE_STOPPED, SERVICE_PAUSED, ...
    {
        CiSvcStatus.dwCheckPoint = 0;
        CiSvcStatus.dwWaitHint   = 0;
    }

    ciDebugOut(( DEB_ITRACE, "service status: %d\n", dwCiSvcStatus ));

    BOOL fOK = SetServiceStatus(g_hTheCiSvc, &CiSvcStatus);

#if CIDBG == 1
    if ( !fOK )
        ciDebugOut(( DEB_ITRACE, "Ci Service: Error from SetServiceStatus = 0x%x\n", GetLastError() ));
#endif
} //UpdateServerStatus

//+-------------------------------------------------------------------------
//
//  Function:   ProcessCustomEvent
//
//  Synopsis:   This is a helper for HandleDevNotification. It processes
//              the device custom events
//
//  Arguments:  [pEventData] -- a PDEV_BROADCAST_HDR object
//              [pContext]   -- a CDrvNotifArray * object.
//
//  Return:     error code from the StartCatalogOnVol/StopCatalogsOnVol
//              proceudres
//
//  History:    18-May-98       kitmanh        Created
//              12-Aug-98       kitmanh        Added return value
//
//--------------------------------------------------------------------------

SCODE ProcessCustomEvent( PVOID pEventData, PVOID pContext )
{
    SCODE sc = S_OK;
    DEV_BROADCAST_HDR UNALIGNED *pBroadcastHdr = (PDEV_BROADCAST_HDR) pEventData;

    ciDebugOut(( DEB_CI_MOUNT, "What is the device type? (%#x)\n", 
                 pBroadcastHdr->dbch_devicetype ));

    // is this a handled event?
    if ( DBT_DEVTYP_HANDLE != pBroadcastHdr->dbch_devicetype)
        return ERROR_CALL_NOT_IMPLEMENTED;

    DEV_BROADCAST_HANDLE UNALIGNED *pDevBroadcastHandle = (PDEV_BROADCAST_HANDLE) pBroadcastHdr;

    ciDebugOut(( DEB_CI_MOUNT, "It is a handled type, handle %#x\n",
                 pDevBroadcastHandle->dbch_hdevnotify ));

    CDrvNotifArray * pDrvNotifArray = (CDrvNotifArray *)pContext;

    CDrvNotificationInfo * pDriveInfo = pDrvNotifArray->FindDriveNotificationByHandle(
                                        (HDEVNOTIFY) pDevBroadcastHandle->dbch_hdevnotify);

    if ( 0 != pDriveInfo )
    {
        if ( GUID_IO_VOLUME_LOCK == pDevBroadcastHandle->dbch_eventguid ) 
        {
            // a volume lock occurred
            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_LOCK for volume %wc\n", 
                         pDriveInfo->GetDrvLetter() ));
                        
            if ( eVolReady == pDriveInfo->GetVolState() ) 
            {
                ciDebugOut(( DEB_CI_MOUNT, "About to stop catalogs on Vol\n" ));
                sc = StopCiSvcWork( eLockVol, pDriveInfo->GetDrvLetter() );   //stop catalog on volume
                ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done stopping the catalogs\n" ));

                pDriveInfo->SetVolState( eVolLocked ); 
            }
                        
            ciDebugOut(( DEB_CI_MOUNT, "Increment Lock Attempts\n" ));
            pDriveInfo->IncLockAttempts();
            ciDebugOut(( DEB_CI_MOUNT, "_cLockAttempts is %d\n", pDriveInfo->GetLockAttempts() ));
        }
        else if ( GUID_IO_MEDIA_REMOVAL == pDevBroadcastHandle->dbch_eventguid ) 
        {
            // CD-ROMs aren't giving dismount/unlock notifies,
            // so key off of this instead.  This is "by design" apparently.
            // A media removal occurred.  If we have a CD-ROM catalog
            // open, close it.

            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_MEDIA_REMOVAL for volume %wc\n", 
                         pDriveInfo->GetDrvLetter() ));

            WCHAR awc[4];
            wcscpy( awc, L"C:\\" );
            awc[0] = pDriveInfo->GetDrvLetter();

            if ( DRIVE_CDROM == GetDriveType( awc ) )
            {
                if ( eVolReady == pDriveInfo->GetVolState() ) 
                {
                    ciDebugOut(( DEB_CI_MOUNT, "About to stop catalogs on Vol\n" ));
                    sc = StopCiSvcWork( eLockVol, pDriveInfo->GetDrvLetter() );   //stop catalog on volume
                    ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done stopping the catalogs\n" ));
                }
            }
        }
        else if ( GUID_IO_VOLUME_UNLOCK == pDevBroadcastHandle->dbch_eventguid )
        {
            // This assert is not always true for CD-ROMs.  I don't know why

            //Win4Assert( eVolLocked == pDriveInfo->GetVolState() );

            if ( eVolLocked == pDriveInfo->GetVolState() )
            {
                // a volume was unlocked

                ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_UNLOCK for volume %wc, removable %s, automount %s\n", 
                             pDriveInfo->GetDrvLetter(),
                             pDriveInfo->IsRemovable() ? "yes" : "no",
                             pDriveInfo->IsAutoMount() ? "yes" : "no" ));
    
                pDriveInfo->ResetLockAttempts();
                
                // Unregister since the _hVol is obsolete
    
                pDriveInfo->UnregisterNotification();
    
                //
                // We can open catalogs on fixed volumes on the unlock, but not on
                // removable volumes, since we get an unlock once the volume is
                // ejected.  For removable volumes, open the catalog on the mount,
                // except for the case of chkdsk where the volume will be mountable
                // immediately and we won't get the mount notification
                // For Fixed volumes, don't wait for the mount since it may be a
                // long time until the mount happens.
                //
    
                if ( pDriveInfo->Touch() )
                {
                    ciDebugOut(( DEB_CI_MOUNT, "About to start catalogs on Vol %wc\n",
                                 pDriveInfo->GetDrvLetter() ));
                    sc = StopCiSvcWork( eUnLockVol, pDriveInfo->GetDrvLetter() );
                    ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done starting the catalogs\n" ));
                }
    
                //
                // Asynchronously redo RegisterDeviceNotification with a new
                //  volume handle.
                // If we don't unregister/reregister on Jaz volumes we never get a
                // mount notify.  But on fixed volumes if we unregister/reregister
                // we miss the mount since it happens before the register succeeds
                // on an operation like chkdsk.
                //
    
#if SYNC_REGISTER
                pDriveInfo->RegisterNotification();
#else
                pDrvNotifArray->RegisterDormantEntries();
#endif
    
                pDriveInfo->SetVolState( eVolReady );
            }
        }
        else if ( GUID_IO_VOLUME_LOCK_FAILED == pDevBroadcastHandle->dbch_eventguid )
        {
            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_LOCK_FAILED for volume %wc\n",
                         pDriveInfo->GetDrvLetter() ));

            if ( pDriveInfo->GetLockAttempts() > 0 )
            { 
                ciDebugOut(( DEB_CI_MOUNT, "Decrement _cLockAttempts\n" ));
                pDriveInfo->DecLockAttempts();
            }
            else
            {
                Win4Assert( eVolReady == pDriveInfo->GetVolState() );
            }

            ciDebugOut(( DEB_CI_MOUNT, "_cLockAttempts is %d\n", pDriveInfo->GetLockAttempts() ));
                                
            if ( ( 0 == pDriveInfo->GetLockAttempts() ) && 
                 ( eVolLocked == pDriveInfo->GetVolState() ) ) 
            {
                // unlock the volume, since all attemps to lock the volume have failed.

                pDriveInfo->UnregisterNotification();

                ciDebugOut(( DEB_CI_MOUNT, "About to start(lock_failed) catalogs on Vol %wc\n", pDriveInfo->GetDrvLetter() ));
                sc = StopCiSvcWork( eUnLockVol, pDriveInfo->GetDrvLetter() );
                ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done starting the catalogs\n" ));

                // redo RegisterDeviceNotification with a new volume handle
#if SYNC_REGISTER
                pDriveInfo->RegisterNotification();
#else
                pDrvNotifArray->RegisterDormantEntries();
#endif
                pDriveInfo->SetVolState( eVolReady );   
                ciDebugOut(( DEB_CI_MOUNT, "Done Unlocking for lock_failed\n" ));
            }
        }
        else if ( GUID_IO_VOLUME_DISMOUNT == pDevBroadcastHandle->dbch_eventguid &&
                  eVolReady == pDriveInfo->GetVolState() )
        {
            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_DISMOUNT for volume %wc, removable %s, automount %s\n",
                         pDriveInfo->GetDrvLetter(),
                         pDriveInfo->IsRemovable() ? "yes" : "no",
                         pDriveInfo->IsAutoMount() ? "yes" : "no" ));

            ciDebugOut(( DEB_CI_MOUNT, "About to stop catalogs on Vol %wc\n", pDriveInfo->GetDrvLetter() ));
            sc = StopCiSvcWork( eLockVol, pDriveInfo->GetDrvLetter() );   //stop catalog on volume
            ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done stopping the catalogs on Vol %wc\n", pDriveInfo->GetDrvLetter() ));

            pDriveInfo->SetVolState( eVolLocked );
        }
        else if ( GUID_IO_VOLUME_DISMOUNT_FAILED == pDevBroadcastHandle->dbch_eventguid &&
                  eVolReady != pDriveInfo->GetVolState() )
        {
            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_DISMOUNT_FAILED for volume %wc\n",
                         pDriveInfo->GetDrvLetter() ));
            
            pDriveInfo->UnregisterNotification();

            ciDebugOut(( DEB_CI_MOUNT, "About to start(dimount_failed) catalogs on Vol %wc\n", pDriveInfo->GetDrvLetter() ));
            sc = StopCiSvcWork( eUnLockVol, pDriveInfo->GetDrvLetter() );
            ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done starting the catalogs\n" ));

            // redo RegisterDeviceNotification with a new volume handle
#if SYNC_REGISTER
            pDriveInfo->RegisterNotification();
#else
            pDrvNotifArray->RegisterDormantEntries();
#endif
            pDriveInfo->SetVolState( eVolReady );
        }
        else if ( GUID_IO_VOLUME_MOUNT == pDevBroadcastHandle->dbch_eventguid )
        {
            ciDebugOut(( DEB_CI_MOUNT, "GUID_IO_VOLUME_MOUNT for volume %wc, removable %s, automount %s\n",
                         pDriveInfo->GetDrvLetter(),
                         pDriveInfo->IsRemovable() ? "yes" : "no",
                         pDriveInfo->IsAutoMount() ? "yes" : "no" ));

            //
            // Mount notifications come at the oddest times -- even after an
            // eject of a removable volume!  Make sure the volume really is
            // valid by touching it before trying to open a catalog on the
            // volume.  Only start catalogs on mount for removable drives.
            // Start catalogs for fixed drives on Unlock.  This is because
            // we have to asynchronously re-register for notifications after
            // an unlock, and by the time we register we've missed the mount.
            // Lovely piece of design work by the pnp guys.  Note: this is
            // partially fixed in current builds.  If we don't re-register
            // we get everything but mount notifications on removable
            // drives.
            //

            BOOL fOK = pDriveInfo->Touch();

            ciDebugOut(( DEB_CI_MOUNT, "drive %wc appears healthy? %d\n",
                         pDriveInfo->GetDrvLetter(),
                         fOK ));

            if ( fOK && pDriveInfo->IsRemovable() )
            {
                ciDebugOut(( DEB_CI_MOUNT, "About to start catalogs on Vol\n" ));
                sc = StopCiSvcWork( eUnLockVol, pDriveInfo->GetDrvLetter() );
                ciDebugOut(( DEB_CI_MOUNT, "Ci Service: Done starting the catalogs\n" ));
            }
        }
        else
        {
            ciDebugOut(( DEB_CI_MOUNT, "UNHANDLED but device object was recognized\n" ));

            if ( GUID_IO_VOLUME_LOCK_FAILED   == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_LOCK_FAILED\n" ));
            else if ( GUID_IO_VOLUME_DISMOUNT_FAILED == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_DISMOUNT_FAILED\n" ));
            else if ( GUID_IO_VOLUME_LOCK     == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_LOCK\n" ));
            else if ( GUID_IO_VOLUME_UNLOCK   == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_UNLOCK\n" ));
            else if ( GUID_IO_VOLUME_DISMOUNT == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_DISMOUNT\n" ));
            else if ( GUID_IO_VOLUME_MOUNT    == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_VOLUME_MOUNT\n" ));
            else if ( GUID_IO_MEDIA_ARRIVAL   == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_MEDIA_ARRIVAL\n" ));
            else if ( GUID_IO_MEDIA_REMOVAL   == pDevBroadcastHandle->dbch_eventguid )
                ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_MEDIA_REMOVAL\n" ));
            else
                ciDebugOut(( DEB_CI_MOUNT, "   eventguid: {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                             pDevBroadcastHandle->dbch_eventguid.Data1,
                             pDevBroadcastHandle->dbch_eventguid.Data2,
                             pDevBroadcastHandle->dbch_eventguid.Data3,
                             pDevBroadcastHandle->dbch_eventguid.Data4[0], pDevBroadcastHandle->dbch_eventguid.Data4[1],
                             pDevBroadcastHandle->dbch_eventguid.Data4[2], pDevBroadcastHandle->dbch_eventguid.Data4[3],
                             pDevBroadcastHandle->dbch_eventguid.Data4[4], pDevBroadcastHandle->dbch_eventguid.Data4[5],
                             pDevBroadcastHandle->dbch_eventguid.Data4[6], pDevBroadcastHandle->dbch_eventguid.Data4[7] ));
        }
    }
    else
    {
        ciDebugOut(( DEB_CI_MOUNT, "   handle: %#x\n", pDevBroadcastHandle->dbch_handle ));
        ciDebugOut(( DEB_CI_MOUNT, "   hdev_notify: %#x\n", pDevBroadcastHandle->dbch_hdevnotify ));
        ciDebugOut(( DEB_CI_MOUNT, "   nameoffset: %#x\n", pDevBroadcastHandle->dbch_nameoffset ));

        if ( GUID_IO_VOLUME_LOCK_FAILED == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_LOCK_FAILED\n" ));
        else if ( GUID_IO_VOLUME_DISMOUNT_FAILED == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_DISMOUNT_FAILED\n" ));
        else if ( GUID_IO_VOLUME_LOCK == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_LOCK\n" ));
        else if ( GUID_IO_VOLUME_UNLOCK == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_UNLOCK\n" ));
        else if ( GUID_IO_VOLUME_DISMOUNT == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_DISMOUNT\n" ));
        else if ( GUID_IO_VOLUME_MOUNT == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "    GUID_IO_VOLUME_MOUNT\n" ));
        else if ( GUID_IO_MEDIA_ARRIVAL == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_MEDIA_ARRIVAL\n" ));
        else if ( GUID_IO_MEDIA_REMOVAL == pDevBroadcastHandle->dbch_eventguid )
            ciDebugOut(( DEB_CI_MOUNT, "   GUID_IO_MEDIA_REMOVAL\n" ));
        else
            ciDebugOut(( DEB_CI_MOUNT, "   eventguid: {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                         pDevBroadcastHandle->dbch_eventguid.Data1,
                         pDevBroadcastHandle->dbch_eventguid.Data2,
                         pDevBroadcastHandle->dbch_eventguid.Data3,
                         pDevBroadcastHandle->dbch_eventguid.Data4[0], pDevBroadcastHandle->dbch_eventguid.Data4[1],
                         pDevBroadcastHandle->dbch_eventguid.Data4[2], pDevBroadcastHandle->dbch_eventguid.Data4[3],
                         pDevBroadcastHandle->dbch_eventguid.Data4[4], pDevBroadcastHandle->dbch_eventguid.Data4[5],
                         pDevBroadcastHandle->dbch_eventguid.Data4[6], pDevBroadcastHandle->dbch_eventguid.Data4[7] ));
    }

    return sc;
} //ProcessCustomEvent

//+----------------------------------------------------------------------------
//
//  Function:   CiSvcMsgProc
//
//  Synopsis:   Message handler for Ci service
//
//  Arguments:  [dwControl] - the message.
//
//  Returns:    Nothing
//
//  History:    06-Jun-94   DwightKr    Created
//              06-23-98    KitmanH     Updated for RegisterServiceCtrlHandlerEx
//              07-30-98    KitmanH     Return appropriate errors
//
//  Notes:      We need to keep the status between calls to this routine
//              since the service control manager may query the current
//              status at any time.
//
//-----------------------------------------------------------------------------

DWORD WINAPI CiSvcMsgProc( DWORD dwControl, 
                           DWORD dwEventType, 
                           PVOID pEventData, 
                           PVOID pContext )
{
    ciDebugOut(( DEB_ITRACE,
                 "Ci 0Service: Executing service control command 0x%x\n",
                 dwControl ));
    
    Win4Assert( pContext );

    BOOL fShutdown = FALSE;
    DWORD dwError = NO_ERROR;
    
    TRY
    {
        switch (dwControl)
        {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            UpdateServiceStatus( NO_ERROR );

            if ( SERVICE_STOP_PENDING != dwCiSvcStatus )
            {
                ciDebugOut(( DEB_ITRACE, "About to stop\n" ));
                dwCiSvcStatus = SERVICE_STOP_PENDING;

                if ( ! g_fSCMThreadIsGone )
                    StopCiSvcWork( eNetStop );
            }
            ciDebugOut( (DEB_ITRACE, "Ci Service: Done shutting down service\n" ));

            //
            // Calling UpdateServiceStatus() after doing the shutdown is
            // causing the service to hang. Not calling solved the problem
            // and so I am preventing it from being called.
            //
            fShutdown = TRUE;
            break;

        case SERVICE_CONTROL_PAUSE:
            if ( SERVICE_PAUSED != dwCiSvcStatus &&
                 SERVICE_STOP_PENDING != dwCiSvcStatus )
            {
                ciDebugOut(( DEB_ITRACE, "About to pause\n" ));
                if ( ! g_fSCMThreadIsGone )
                    StopCiSvcWork( eNetPause );
                dwCiSvcStatus = SERVICE_PAUSED;
                ciDebugOut(( DEB_ITRACE, "Ci Service: Done pausing the service\n" ));
            }
            break;

        case SERVICE_CONTROL_CONTINUE:
            if ( SERVICE_PAUSED == dwCiSvcStatus &&
                 SERVICE_STOP_PENDING != dwCiSvcStatus )
            {
                ciDebugOut(( DEB_ITRACE, "About to continue\n" ));
                if ( ! g_fSCMThreadIsGone )
                    StopCiSvcWork( eNetContinue );
                dwCiSvcStatus = SERVICE_RUNNING;
            }
            ciDebugOut(( DEB_ITRACE, "Ci Service: Done continuing the service\n" ));
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
            // a dismount or remount may have occurred

            ciDebugOut(( DEB_ITRACE, "SERVICE_CONTROL_DEVICEEVENT received, event = %#x\n",
                         dwEventType ));

            {
                SCODE sc = S_OK;

                if ( DBT_CUSTOMEVENT == dwEventType )
                {
                    ciDebugOut(( DEB_ITRACE, "It is a custom event\n" ));
                    if ( ! g_fSCMThreadIsGone )
                        sc = ProcessCustomEvent( pEventData, pContext );
                    ciDebugOut(( DEB_ITRACE, "Done processing custom event\n" ));
                }

                // convert sc into a WIN32 error and return it
                ciDebugOut(( DEB_ITRACE, "Process Custom Event returned sc = %#x\n", sc ));
                    
                dwError = HRESULTTOWIN32(sc);
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:
            ciDebugOut(( DEB_CI_MOUNT, "service control not implemented %d\n", dwControl ));
            dwError = ERROR_CALL_NOT_IMPLEMENTED;
            break;
        }

        UpdateServiceStatus( NO_ERROR );
    }
    CATCH (CException, e)
    {
        ciDebugOut(( DEB_ITRACE, "Ci Service: Error from callback = 0x%x\n", e.GetErrorCode() ));
    }
    END_CATCH

    ciDebugOut(( DEB_ITRACE, "Getting out of CiSvcMsgProc\n" ));
   
    return dwError;
} //CiSvcMsgProc

//+-------------------------------------------------------------------------
//
//  Function:   CiServiceMain, public
//
//  Purpose:    Service entry point
//
//  Arguments:  [dwNumServiceArgs] - number of arguments passed
//              [awcsServiceArgs]  - arguments
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

extern CEventSem * g_pevtPauseContinue;

void CiSvcMain(
    DWORD    dwNumServiceArgs,
    LPWSTR * awcsServiceArgs )
{
    // The service control manager crofted up this thread, so we have to
    // establish the exception state, etc.

    CTranslateSystemExceptions translate;
    TRY
    {
        CDrvNotifArray DrvNotifArray;

        ciDebugOut( (DEB_ITRACE, "Ci Service: Attempting to register service\n" ));

        // Register service handler with service controller

        g_hTheCiSvc = RegisterServiceCtrlHandlerEx( wcsCiSvcName,
                                                    CiSvcMsgProc,
                                                    &DrvNotifArray );
        if (0 == g_hTheCiSvc)
        {
            ciDebugOut(( DEB_ERROR, "Unable to register ci service\n" ));
            THROW( CException( E_FAIL ) );
        }

        CEventSem evtPauseContinue;
        g_pevtPauseContinue = &evtPauseContinue;

        UpdateServiceStatus( NO_ERROR );

        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

        if ( 1 != reg.Read( wcsPreventCisvcParam, (ULONG) 0 ) )
        {
            dwCiSvcStatus = SERVICE_RUNNING;
            UpdateServiceStatus( NO_ERROR );

            #if CIDBG == 1
                BOOL fRun = TRUE;   // FALSE --> Stop

                TRY
                {
                    ULONG ulVal = reg.Read( L"StopCiSvcOnStartup", (ULONG)0 );

                    if ( 1 == ulVal )
                        fRun = FALSE;
                }
                CATCH( CException, e )
                {
                }
                END_CATCH;

                unsigned long OldWin4AssertLevel = SetWin4AssertLevel(ASSRT_MESSAGE | ASSRT_POPUP);

                Win4Assert( fRun );

                SetWin4AssertLevel( OldWin4AssertLevel );
            #endif // CIDBG

            // Register for pnp notifications on drives used by catalogs

            DrvNotifArray.RegisterCatForNotifInRegistry();

            //
            // Register for pnp notifications on removable drives not yet
            // registered if the registry flag says it's appropriate.
            //

            if ( 0 != reg.Read( wcsMountRemovableCatalogs,
                                CI_AUTO_MOUNT_CATALOGS_DEFAULT ) )
                DrvNotifArray.RegisterRemovableDrives();

            StartCiSvcWork( DrvNotifArray );

            DrvNotifArray.UnregisterDeviceNotifications();

            ciDebugOut(( DEB_ITRACE, "service_stopped from CiSvcMain\n" ));
        }
        else
        {
            CEventLog eventLog( NULL, wcsCiEventSource );
            CEventItem item( EVENTLOG_INFORMATION_TYPE,
                             CI_SERVICE_CATEGORY,
                             MSG_CI_SERVICE_SUPPRESSED,
                             0 );
            eventLog.ReportEvent( item );
        }

        dwCiSvcStatus = SERVICE_STOPPED;
        UpdateServiceStatus( NO_ERROR );
        ciDebugOut(( DEB_ITRACE, "Shutdown is done\n" ));

        CoFreeUnusedLibraries();

        ciDebugOut( (DEB_ITRACE, "Ci Service: Leaving CiSvcMain()\n" ));
    }
    CATCH (CException, e)
    {
        ciDebugOut( (DEB_ITRACE, "Ci Service: Detected error 0x%x\n", e.GetErrorCode() ));
    }
    END_CATCH

    g_pevtPauseContinue = 0;
    g_fSCMThreadIsGone = TRUE;
} //CiSvcMain

//+----------------------------------------------------------------------------
//
//  Function:   SvcEntry_CiSvc
//
//  Synopsis:   Entry from services.exe
//
//              This is currently broken since services doesn't unload
//              query.dll when the service is stopped, and our global
//              variables don't expect to be used again when the service
//              is restarted.  It's probably a week of work to fix this!
//              We don't do this anyway so it doesn't matter.
//
//  History:    05-Jan-97   dlee    Created
//
//-----------------------------------------------------------------------------

void SvcEntry_CiSvc(
    DWORD    NumArgs,
    LPWSTR * ArgsArray,
    void *   pSvcsGlobalData,
    HANDLE   SvcRefHandle )
{
    CiSvcMain( NumArgs, ArgsArray );
} //SvcEntry_CiSvc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\main.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1996-1997, Microsoft Corporation.
//
// File:        main.cxx
//
// Contents:    DLL entry point for query.dll
//
// History:     28-Feb-96       KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntverp.h>

#define _DECL_DLLMAIN 1
#include <process.h>

DECLARE_INFOLEVEL(ci);
DECLARE_INFOLEVEL(tb);
DECLARE_INFOLEVEL(vq);

char g_ciBuild[ 120 ] = "none";

//
// Needed because of using a common pch
//
CCoTaskAllocator CoTaskAllocator; // exported data definition

void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return(CoTaskMemAlloc(cbSize));
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

// I couldn't come up with a better way to do this than to have 2 macros

#define MAKELITERALSTRING( s, lit ) s #lit
#define MAKELITERAL( s, lit ) MAKELITERALSTRING( s, lit )

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  -- Module handle
//              [dwReason]   -- Reason for being called
//              [lpReserved] -- 
//
//  History:    28-Feb-96   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason, void * lpReserved )
{

    BOOL fOk = TRUE;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
    
        if ( fOk )
        {
            switch ( dwReason )
            {
            case DLL_PROCESS_ATTACH:
            {
                sprintf( g_ciBuild,
                         "query (IS 3/NT 5) %s %s with %d headers on %s at %s.",
#if CIDBG == 1
                         "chk",
#else // CIDBG == 1
                         "fre",
#endif // CIDBG == 1
                         MAKELITERAL( "built by ", BUILD_USERNAME ),
                         VER_PRODUCTBUILD,
                         __DATE__,
                         __TIME__ );

                DisableThreadLibraryCalls( (HINSTANCE)hInstance );
    
                //
                //  Initialize unicode callouts
                //
    
                static UNICODECALLOUTS UnicodeCallouts = { WIN32_UNICODECALLOUTS };
                RtlSetUnicodeCallouts(&UnicodeCallouts);
    
                break;
            }
    
            case DLL_PROCESS_DETACH:
                // No need to call Shutdown here.  It must already have
                // been called by this point since otherwise all of
                // our threads but this one will be terminated by now
                // by the system.
                break;
            }
        }
    }
    CATCH( CException, e )
    {
        // ignore
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\propret.cxx ===
//+------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-2000.
//
// File:        propret.cxx
//
// Contents:    Generic property retriever filesystems
//
// Classes:     CGenericPropRetriever
//
// History:     12-Dec-96       SitaramR    Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propret.hxx>
#include <seccache.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::CGenericPropRetriever
//
//  Synopsis:   Extracts property and object tables from the catalog.
//
//  Arguments:  [cat]                    -- Catalog
//              [pQueryPropMapper]       -- Pid Remapper associated with the query
//              [secCache]               -- Cache of AccessCheck() results
//              [pScope]                 -- Scope (for fixup match) if client is going
//                                          through rdr/svr, else 0.
//              [amAlreadyAccessChecked] -- Don't need to re-check for this
//                                          access mask.
//
//  History:    21-Aug-91   KyleP       Created
//
//----------------------------------------------------------------------------

CGenericPropRetriever::CGenericPropRetriever( PCatalog & cat,
                                              ICiQueryPropertyMapper *pQueryPropMapper,
                                              CSecurityCache & secCache,
                                              CRestriction const * pScope,
                                              ACCESS_MASK amAlreadyAccessChecked )
        : _cat( cat ),
          _pQueryPropMapper( pQueryPropMapper ),
          _secCache( secCache ),
          _widPrimedForPropRetrieval( widInvalid ),
          _remoteAccess( cat.GetImpersonationTokenCache() ),
          _pScope( pScope ),
          _ulAttribFilter( cat.GetRegParams()->FilterDirectories() ?
                                               FILE_ATTRIBUTE_NOT_CONTENT_INDEXED :
                                               FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_DIRECTORY ),
          _pPropRec( 0 ),
          _cRefs( 1 ),
          _amAlreadyAccessChecked( amAlreadyAccessChecked )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::~CGenericPropRetriever, public
//
//  Synopsis:   Closes catalog tables associated with this instance.
//
//  History:    21-Aug-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CGenericPropRetriever::~CGenericPropRetriever()
{
    Quiesce();
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::Quiesce, public
//
//  Synopsis:   Close any open resources.
//
//  History:    3-May-1994  KyleP      Created
//
//--------------------------------------------------------------------------

void CGenericPropRetriever::Quiesce()
{
    _propMgr.Close();
    _cat.CloseValueRecord( _pPropRec );
    _pPropRec = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::RetrieveValueByPid
//
//  Effects:    Fetch value from the property cache.
//
//  Arguments:  [pid]      -- Property to fetch
//              [pbData]   -- Place to return the value
//              [pcb]      -- On input, the maximum number of bytes to
//                            write at pbData.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    12-Dec-96     SitaramR       Created
//
//----------------------------------------------------------------------------


inline BYTE * PastHeader( PROPVARIANT * ppv )
{
    return( (BYTE *)ppv + sizeof( PROPVARIANT ) );
}


SCODE STDMETHODCALLTYPE CGenericPropRetriever::RetrieveValueByPid( PROPID pid,
                                                                   PROPVARIANT *pbData,
                                                                   ULONG *pcb )
{
    static const UNICODE_STRING EmptyUnicodeString = { 0, 0, 0 };

    if ( widInvalid == _widPrimedForPropRetrieval )
        return CI_E_WORKID_NOTVALID;

    SCODE sc = S_OK;

    TRY
    {
        unsigned cb = sizeof( PROPVARIANT );

        //
        // System properties are retrieved directly from FindFirst buffer.
        // User properties must be retrieved through the standard retrieval
        // mechanism.
        //

        switch ( pid )
        {
        case pidDirectory:
        {
            pbData->vt = VT_LPWSTR;
            pbData->pwszVal = (WCHAR *)PastHeader(pbData);

            unsigned cbExtra = 0;

            // If the client is remote, apply the fixup to the path

            if ( IsClientRemote() )
            {
                XGrowable<WCHAR> xwcBuf;

                cbExtra = BuildPath( GetPath(),
                                     & EmptyUnicodeString,
                                     xwcBuf );
                if ( 0 != cbExtra )
                {
                    unsigned cwcBuf = ( *pcb - sizeof PROPVARIANT ) / sizeof WCHAR;
                    unsigned cwc = FixupPath( xwcBuf.Get(),
                                              pbData->pwszVal,
                                              cwcBuf );
                    cbExtra = (1 + cwc) * sizeof WCHAR;
                }
            }
            else
            {
                cbExtra = BuildPath( GetPath(),
                                     & EmptyUnicodeString,
                                     pbData->pwszVal,
                                     *pcb - sizeof PROPVARIANT );
            }

            if ( 0 == cbExtra )
                pbData->vt = VT_EMPTY;
            else
                cb += cbExtra;

            break;
        }

        case pidClassId:
        {
            //
            //  If it's a Docfile, retrieve the class ID from the Docfile,
            //  otherwise, just return a default file or directory class id.
            //

            pbData->vt = VT_CLSID;
            cb += sizeof( GUID );

            if ( cb <= *pcb )
            {
                pbData->puuid = (GUID *)PastHeader(pbData);
                SCODE sc = E_FAIL;


                CFunnyPath funnyBuf;
                if ( 0 == BuildPath( GetPath(), GetName(), funnyBuf ) )
                {
                    pbData->vt = VT_EMPTY;
                    cb -= sizeof(GUID);
                }
                else
                {
                    //
                    // Try to retrieve the class id
                    //

                    sc = GetClassFile ( funnyBuf.GetPath(), pbData->puuid );

                    if ( FAILED(sc) )
                    {
                        // OLE was unable to obtain or infer the class id

                        cb -= sizeof( GUID );
                        pbData->vt = VT_EMPTY;
                    }
                }
            }
            break;
        }

        case pidPath:
        {
            pbData->vt = VT_LPWSTR;
            pbData->pwszVal = (WCHAR *)PastHeader(pbData);

            unsigned cbExtra = 0;

            // If the client is remote, apply the fixup to the path

            if ( IsClientRemote() )
            {
                XGrowable<WCHAR> xwcBuf;

                cbExtra = BuildPath( GetPath(),
                                     GetName(),
                                     xwcBuf );
                if ( 0 != cbExtra )
                {
                    unsigned cwcBuf = ( *pcb - sizeof PROPVARIANT ) / sizeof WCHAR;
                    unsigned cwc = FixupPath( xwcBuf.Get(),
                                              pbData->pwszVal,
                                              cwcBuf );
                    cbExtra = (1 + cwc) * sizeof WCHAR;
                }
            }
            else
            {
                cbExtra = BuildPath( GetPath(),
                                     GetName(),
                                     pbData->pwszVal,
                                     *pcb - sizeof PROPVARIANT );
            }

            if ( 0 == cbExtra )
                pbData->vt = VT_EMPTY;
            else
                cb += cbExtra;

            break;
        }

        case pidVirtualPath:
        {
            UNICODE_STRING const * pPath = GetVirtualPath();

            if ( 0 == pPath )
                pbData->vt = VT_EMPTY;
            else
            {
                pbData->vt = VT_LPWSTR;
                pbData->pwszVal = (WCHAR *)PastHeader(pbData);

                cb += BuildPath( pPath, GetName(), pbData->pwszVal, *pcb - sizeof(PROPVARIANT) );
            }
            break;
        }

        case pidName:
            cb = *pcb;
            StringToVariant( GetName(), pbData, &cb );
            break;

        case pidShortName:
            cb = *pcb;
            StringToVariant( GetShortName(), pbData, &cb );
            break;

        case pidLastChangeUsn:
            pbData->vt = VT_I8;
            pbData->hVal.QuadPart = 1;      // First legal USN
            break;

        case pidSize:
            pbData->vt = VT_I8;
            pbData->hVal.QuadPart = ObjectSize();

            if ( pbData->hVal.QuadPart == 0xFFFFFFFFFFFFFFFF )
                pbData->vt = VT_EMPTY;

            #if CIDBG == 1
                if ( VT_I8 == pbData->vt )
                    Win4Assert( 0xdddddddddddddddd != pbData->hVal.QuadPart );
            #endif // CIDBG == 1

            break;

        case pidAttrib:
            pbData->vt = VT_UI4;
            pbData->ulVal = Attributes();

            if ( pbData->ulVal == 0xFFFFFFFF )
                pbData->vt = VT_EMPTY;

            #if CIDBG == 1
                if ( VT_UI4 == pbData->vt )
                    Win4Assert( 0xdddddddd != pbData->ulVal );
            #endif // CIDBG == 1

            break;

        case pidWriteTime:
            pbData->vt = VT_FILETIME;
            pbData->hVal.QuadPart = ModifyTime();

            if ( pbData->hVal.QuadPart == 0xFFFFFFFFFFFFFFFF )
                pbData->vt = VT_EMPTY;

            break;

        case pidCreateTime:
            pbData->vt = VT_FILETIME;
            pbData->hVal.QuadPart = CreateTime();

            if ( pbData->hVal.QuadPart == 0xFFFFFFFFFFFFFFFF )
                pbData->vt = VT_EMPTY;

            break;

        case pidAccessTime:
            pbData->vt = VT_FILETIME;
            pbData->hVal.QuadPart = AccessTime();

            if ( pbData->hVal.QuadPart == 0xFFFFFFFFFFFFFFFF )
                pbData->vt = VT_EMPTY;

            break;

        case pidStorageType:
            pbData->vt = VT_UI4;
            pbData->ulVal = StorageType();

            if ( 0xFFFFFFFF == pbData->ulVal )
            {
                //
                // Try VRootType
                //

                if ( GetVRootType( pbData->ulVal ) )
                {
                    if ( pbData->ulVal & PCatalog::NNTPRoot )
                        pbData->ulVal = 1;
                    else
                        pbData->ulVal = 0;
                }
                else
                    pbData->vt = VT_EMPTY;
            }
            break;

        case pidPropertyStoreLevel:
            pbData->vt = VT_UI4;
            pbData->ulVal = StorageLevel();
            break;

        case pidPropDataModifiable:
            pbData->vt = VT_BOOL;
            pbData->boolVal = IsModifiable() ? VARIANT_TRUE : VARIANT_FALSE;
            break;

        case pidVRootUsed:
        {
            if ( GetVRootType( pbData->ulVal ) )
            {
                pbData->vt = VT_BOOL;

                if ( pbData->ulVal & PCatalog::UsedRoot )
                    pbData->boolVal = VARIANT_TRUE;
                else
                    pbData->boolVal = VARIANT_FALSE;
            }
            else
                pbData->vt = VT_EMPTY;

            break;
        }

        case pidVRootAutomatic:
        {
            if ( GetVRootType( pbData->ulVal ) )
            {
                pbData->vt = VT_BOOL;

                if ( pbData->ulVal & PCatalog::AutomaticRoot )
                    pbData->boolVal = VARIANT_TRUE;
                else
                    pbData->boolVal = VARIANT_FALSE;
            }
            else
                pbData->vt = VT_EMPTY;

            break;
        }

        case pidVRootManual:
        {
            if ( GetVRootType( pbData->ulVal ) )
            {
                pbData->vt = VT_BOOL;

                if ( pbData->ulVal & PCatalog::ManualRoot )
                    pbData->boolVal = VARIANT_TRUE;
                else
                    pbData->boolVal = VARIANT_FALSE;
            }
            else
                pbData->vt = VT_EMPTY;

            break;
        }

        case pidPropertyGuid:
            cb += sizeof( GUID );

            if ( cb <= *pcb )
            {
                pbData->puuid = (GUID *)PastHeader(pbData);

                if ( GetPropGuid( *pbData->puuid ) )
                    pbData->vt = VT_CLSID;
                else
                {
                    cb -= sizeof(GUID);
                    pbData->vt = VT_EMPTY;
                }
            }
            break;

        case pidPropertyDispId:
            pbData->ulVal = GetPropPropid();

            if ( pbData->ulVal == pidInvalid )
                pbData->vt = VT_EMPTY;
            else
                pbData->vt = VT_UI4;
            break;

        case pidPropertyName:
            cb = *pcb;
            StringToVariant( GetPropName(), pbData, &cb );
            break;

        default:
        {
            //
            // First, try the property cache.
            //

            cb = *pcb;

            BOOL fTryOLE = TRUE;

            if ( FetchValue( pid, pbData, &cb ) )
            {
                fTryOLE = FALSE;

                if ( ( cb <= *pcb ) &&
                     ( IsNullPointerVariant( pbData ) ) )
                {
                    pbData->vt = VT_EMPTY;
                    cb = sizeof( PROPVARIANT );
                }

                // If we got back VT_EMPTY, it may be because the file has
                // been scanned and not filtered.  If there is no write time,
                // the file hasn't been filtered yet, so trying OLE to load
                // the value is worth it.

                if ( VT_EMPTY == pbData->vt )
                {
                    PROPVARIANT vWrite;
                    vWrite.vt = VT_EMPTY;
                    unsigned cbWrite = sizeof vWrite;
                    FetchValue( pidWriteTime, &vWrite, &cbWrite );

                    if ( VT_EMPTY == vWrite.vt )
                        fTryOLE = TRUE;
                }
            }

            if ( fTryOLE )
            {
                CImpersonateClient impClient( GetClientToken() );

                if ( !_propMgr.isOpen() )
                {
                    //
                    // Get a full, null-terminated, path.
                    //

                    CFunnyPath funnyBuf;
                    if ( 0 != BuildPath( GetPath(),
                                         GetName(),
                                         funnyBuf ) )
                    {
                        // Open property manager.

                        if ( CImpersonateRemoteAccess::IsNetPath( funnyBuf.GetActualPath() ) )
                        {
                            UNICODE_STRING const * pVPath = GetVirtualPath();

                            WCHAR const * pwszVPath = 0 != pVPath ? pVPath->Buffer : 0;

                            if ( !_remoteAccess.ImpersonateIfNoThrow( funnyBuf.GetActualPath(),
                                                                      pwszVPath ) )
                            {
                                return CI_E_LOGON_FAILURE;
                            }
                        }
                        else if ( _remoteAccess.IsImpersonated() )
                        {
                            _remoteAccess.Release();
                        }

                        BOOL fSharingViolation = _propMgr.Open( funnyBuf );
                        if ( fSharingViolation )
                            return CI_E_SHARING_VIOLATION;
                    }
                }

                FULLPROPSPEC const *pPropSpec;
                SCODE sc = _pQueryPropMapper->PropidToProperty( pid, &pPropSpec );
                if ( FAILED( sc ) )
                {
                    Win4Assert( !"PropidToProperty failed" );

                    THROW ( CException( sc ) );
                }
                CFullPropSpec const * ps = (CFullPropSpec const *) pPropSpec;

                cb = *pcb;
                _propMgr.FetchProperty( ps->GetPropSet(),
                                        ps->GetPropSpec(),
                                        pbData,
                                        &cb );
            }

            break;
        }

        } // case

        if ( cb <= *pcb )
        {
            *pcb = cb;
#if CIDBG == 1
            CStorageVariant var( *pbData );

            vqDebugOut(( DEB_PROPTIME, "Fetched value (pid = 0x%x): ", pid ));
            var.DisplayVariant( DEB_PROPTIME | DEB_NOCOMPNAME, 0 );
            vqDebugOut(( DEB_PROPTIME | DEB_NOCOMPNAME, "\n" ));
#endif
        }
        else
        {
            *pcb = cb;
            vqDebugOut(( DEB_PROPTIME, "Failed to fetch value (pid = 0x%x)\n", pid ));
            sc = CI_E_BUFFERTOOSMALL ;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CGenericPropRetriever::RetrieveValueByPid - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::StringToVariant, private
//
//  Arguments:  [pString] -- String to copy.
//              [pbData]  -- String stored here.
//              [pcb]     -- On input: max length in bytes of [pbData].
//                           On output: size required by [pString].  If
//                           less-than-or-equal-to input size, then string
//                           was copied.
//
//  History:    17-Jul-95   KyleP       Created header.
//
//----------------------------------------------------------------------------

void CGenericPropRetriever::StringToVariant( UNICODE_STRING const * pString,
                                             PROPVARIANT * pbData,
                                             unsigned * pcb )
{
    unsigned cb = sizeof(PROPVARIANT);

    if ( 0 == pString || 0 == pString->Length )
    {
        pbData->vt = VT_EMPTY;
    }
    else
    {
        pbData->vt = VT_LPWSTR;
        cb += pString->Length + sizeof( WCHAR ); // For L'\0' at end.

        if ( cb <= *pcb )
        {
            WCHAR * pwcName = (WCHAR *)PastHeader(pbData);
            pbData->pwszVal = pwcName;
            RtlCopyMemory( pwcName,
                           pString->Buffer,
                           pString->Length );
            pwcName[pString->Length/sizeof(WCHAR)] = L'\0';
        }
    }

    *pcb = cb;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::BuildPath, private
//
//  Synopsis:   Gloms path + filename together
//
//  Arguments:  [pPath]       -- Path, sans filename
//              [pFilename]   -- Filename
//              [funnyBuf]    -- Full path copied here.
//
//  Returns:    Size in **bytes** of full path. 0 --> No path
//
//  History:    04-Jun-98   VikasMan       Created
//
//----------------------------------------------------------------------------

unsigned CGenericPropRetriever::BuildPath( UNICODE_STRING const * pPath,
                                           UNICODE_STRING const * pFilename,
                                           CFunnyPath & funnyBuf)
{
    if ( 0 == pPath || 0 == pPath->Length || 0 == pFilename )
        return 0;

    funnyBuf.SetPath( pPath->Buffer, pPath->Length/sizeof(WCHAR) );
    if ( pFilename->Length > 0 )
    {
        funnyBuf.AppendBackSlash();

        funnyBuf.AppendPath( pFilename->Buffer, pFilename->Length/sizeof(WCHAR) );
    }
    return funnyBuf.GetLength() * sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::BuildPath, private
//
//  Synopsis:   Gloms path + filename together
//
//  Arguments:  [pPath]     -- Path, sans filename
//              [pFilename] -- Filename
//              [xwcBuf]    -- Full path copied here.
//
//  Returns:    Size in **bytes** of full path. 0 --> No path
//
//  History:    04-Jun-98   VikasMan       Created
//
//----------------------------------------------------------------------------

unsigned CGenericPropRetriever::BuildPath( UNICODE_STRING const * pPath,
                                           UNICODE_STRING const * pFilename,
                                           XGrowable<WCHAR> & xwcBuf)
{
    if ( 0 == pPath || 0 == pFilename )
        return 0;

    unsigned cb = pPath->Length +
                  pFilename->Length +
                  sizeof WCHAR;      // L'\0' at end

    if ( pFilename->Length > 0 )
        cb += sizeof WCHAR;            // L'\\' between path and filename

    xwcBuf.SetSizeInBytes( cb );
    return BuildPath( pPath, pFilename, xwcBuf.Get(), cb );
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::BuildPath, private
//
//  Synopsis:   Gloms path + filename together
//
//  Arguments:  [pPath]     -- Path, sans filename
//              [pFilename] -- Filename
//              [pwcBuf]    -- Full path copied here.
//              [cbBuf]     -- Size in **bytes** of pwcBuf.
//
//  Returns:    Size in **bytes** of full path.  Path only built if return
//              value is <= [cbBuf].  0 --> No path
//
//  History:    07-Feb-96   KyleP       Created header.
//
//----------------------------------------------------------------------------

unsigned CGenericPropRetriever::BuildPath( UNICODE_STRING const * pPath,
                                           UNICODE_STRING const * pFilename,
                                           WCHAR * pwcBuf,
                                           unsigned cbBuf )
{
    if ( 0 == pPath || 0 == pFilename )
        return 0;

    unsigned cb = pPath->Length +
                  pFilename->Length +
                  sizeof WCHAR;      // L'\0' at end

    if ( pFilename->Length > 0 )
        cb += sizeof WCHAR;            // L'\\' between path and filename

    if ( cb <= cbBuf )
    {
        RtlCopyMemory( pwcBuf, pPath->Buffer, pPath->Length );
        pwcBuf += pPath->Length/sizeof(WCHAR);

        if ( pFilename->Length > 0 )
        {
            *pwcBuf++ = L'\\';
            RtlCopyMemory( pwcBuf,
                           pFilename->Buffer,
                           pFilename->Length );
            pwcBuf += pFilename->Length / sizeof WCHAR;
        }

        *pwcBuf = 0;
    }

    return cb;
}




//+---------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::FetchValue, protected
//
//  Effects:    Fetch value from the property cache.
//
//  Arguments:  [pid] -- Property to fetch
//              [pbData]   -- Place to return the value
//              [pcb]      -- On input, the maximum number of bytes to
//                            write at pbData.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  Returns:    TRUE if property was fetched
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CGenericPropRetriever::FetchValue( PROPID pid, PROPVARIANT * pbData, unsigned * pcb )
{
    OpenPropertyRecord();

    return _cat.FetchValue( _pPropRec, pid, pbData, pcb );
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::CheckSecurity
//
//  Synopsis:   Test wid for security access
//
//  Arguments:  [am]        -- Access Mask
//              [pfGranted] -- Result of security check returned here
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CGenericPropRetriever::CheckSecurity( ACCESS_MASK am,
                                                              BOOL *pfGranted)
{
    //
    // No need to impersonate the client because the Win32 AccessCheck API
    // takes a client token as a parameter
    //
    SCODE sc = S_OK;

    TRY
    {
        if ( _widPrimedForPropRetrieval == widInvalid )
            sc = CI_E_WORKID_NOTVALID;
        else
        {
            OpenPropertyRecord();

            if ( am != _amAlreadyAccessChecked  )
            {
                SDID sdid = _cat.FetchSDID( _pPropRec,
                                            _widPrimedForPropRetrieval );
                *pfGranted = _secCache.IsGranted( sdid, am );
            }
            else
                *pfGranted = TRUE;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CGenericPropRetriever::CheckSecurity - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenericPropRetriever::EndPropertyRetrieval
//
//  Synopsis:   Reset wid for property retrieval
//
//  History:    12-Dec-96    SitaramR     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CGenericPropRetriever::EndPropertyRetrieval()
{
    Win4Assert( _widPrimedForPropRetrieval != widInvalid );

    SCODE sc = S_OK;

    TRY
    {
        Quiesce();
        if ( _remoteAccess.IsImpersonated() )
            _remoteAccess.Release();

        _widPrimedForPropRetrieval = widInvalid;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CGenericPropRetriever::EndPropertyRetrieval - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Dec-1996      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CGenericPropRetriever::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Dec-1996     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CGenericPropRetriever::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Dec-1996     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CGenericPropRetriever::QueryInterface(
    REFIID riid,
    void  ** ppvObject)
{
    *ppvObject = 0;

    if ( IID_ICiCPropRetriever == riid )
        *ppvObject = (IUnknown *)(ICiCPropRetriever *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::FetchPath, protected
//
//  Synopsis:   Reads the path from the open property record
//
//  Arguments:  [pwcPath] -- where to put the path
//              [cwc]     -- size of the buffer in/out in characters
//
//  History:    15-Jan-1998     dlee   Created
//
//--------------------------------------------------------------------------

void CGenericPropRetriever::FetchPath(
    WCHAR *    pwcPath,
    unsigned & cwc )
{
    PROPVARIANT var;
    unsigned cb = cwc * sizeof WCHAR;

    if ( _cat.FetchValue( GetPropertyRecord(),
                          pidPath,
                          &var,
                          (BYTE *) pwcPath,
                          &cb ) )
        cwc = cb / sizeof WCHAR;
    else
        cwc = 0;
} //FetchPath

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::FixupPath, private
//
//  Synopsis:   Fixes up path (e.g. converts E:\Foo --> \\KyleP-1\RootE\Foo)
//
//  Arguments:  [pwcsPath]  -- Source (local) path
//              [pwcsFixup] -- Aliased result
//              [cwcFixup]  -- Count of characters in [pwcsFixup].
//
//  Returns:    Count of characters that are in [pwcsFixup].  If return
//              value is larger than [cwcFixup] then nothing was copied.
//
//  History:    01-Oct-1998   KyleP    Created (from ciprop.cxx vroot equivalent)
//
//--------------------------------------------------------------------------

unsigned CGenericPropRetriever::FixupPath( WCHAR const * pwcsPath,
                                           WCHAR * pwcsFixup,
                                           unsigned cwcFixup )
{
    BOOL fUseAnyPath = FALSE;
    unsigned cwc = 0;

    if ( RTScope == _pScope->Type() )
    {
        CScopeRestriction const & scp = * (CScopeRestriction *) _pScope;

        if ( scp.IsPhysical() )
        {
            BOOL fUnchanged;
            cwc = FetchFixupInScope( pwcsPath,
                                     pwcsFixup,
                                     cwcFixup,
                                     scp.GetPath(),
                                     scp.PathLength(),
                                     scp.IsDeep(),
                                     fUnchanged );
            Win4Assert( cwc > 0 );
        }
        else
            fUseAnyPath = TRUE;
    }
    else if ( RTOr == _pScope->Type() )
    {
        CNodeRestriction const & node = * _pScope->CastToNode();

        fUseAnyPath = TRUE;

        for ( ULONG x = 0; x < node.Count(); x++ )
        {
            Win4Assert( RTScope == node.GetChild( x )->Type() );

            CScopeRestriction const & scp = * (CScopeRestriction *)
                                            node.GetChild( x );

            if ( scp.IsPhysical() )
            {
                BOOL fUnchanged;
                cwc = FetchFixupInScope( pwcsPath,
                                         pwcsFixup,
                                         cwcFixup,
                                         scp.GetPath(),
                                         scp.PathLength(),
                                         scp.IsDeep(),
                                         fUnchanged );
                if ( cwc > 0 && !fUnchanged )
                {
                    fUseAnyPath = FALSE;
                    break;
                }
            }
        }
    }

    //
    // If no fixup works for the file, use the first match to physical scope.
    //

    if ( fUseAnyPath )
        cwc = _cat.FixupPath( pwcsPath,
                              pwcsFixup,
                              cwcFixup,
                              0 );

    return cwc;
} //FixupPath

//+-------------------------------------------------------------------------
//
//  Method:     CGenericPropRetriever::FetchFixupInScope, private
//
//  Synopsis:   Worker subroutine for FixupPath
//
//  Arguments:  [pwcsPath]  -- Source (local) path
//              [pwcsFixup] -- Aliased result
//              [cwcFixup]  -- Count of characters in [pwcsFixup].
//              [pwcRoot]   -- Root scope (must match alias)
//              [cwcRoot]   -- Size (in chars) of [pwcRoot]
//              [fDeep]     -- True if [pwcRoot] is a deep scope.
//
//  Returns:    Count of characters that are in [pwcsFixup].  If return
//              value is larger than [cwcFixup] then nothing was copied.
//
//  History:    01-Oct-1998   KyleP    Created (from ciprop.cxx vroot equivalent)
//
//--------------------------------------------------------------------------

unsigned CGenericPropRetriever::FetchFixupInScope( WCHAR const * pwcsPath,
                                                   WCHAR *       pwcsFixup,
                                                   unsigned      cwcFixup,
                                                   WCHAR const * pwcRoot,
                                                   unsigned      cwcRoot,
                                                   BOOL          fDeep,
                                                   BOOL &        fUnchanged )
{
    fUnchanged = FALSE;
    CScopeMatch Match( pwcRoot, cwcRoot );
    unsigned cSkip = 0;
    unsigned cwcPath = 0;
    unsigned cwcMaxPath = 0;   // Used to hold longest path (when cwcFixup == 0)

    unsigned cwcOriginalPath = wcslen( pwcsPath );

    while ( TRUE )
    {
        cwcPath = _cat.FixupPath( pwcsPath,
                                  pwcsFixup,
                                  cwcFixup,
                                  cSkip );

        if ( 0 == cwcPath )
            return cwcMaxPath;

        //
        // If no fixups matched, return the original path
        //

        if ( cwcPath == cwcOriginalPath &&
             RtlEqualMemory( pwcsPath, pwcsFixup, cwcPath * sizeof WCHAR ) )
        {
            fUnchanged = TRUE;
            return cwcPath;
        }

        //
        // In scope?
        //

        if ( cwcPath > cwcFixup || !Match.IsInScope( pwcsFixup, cwcFixup ) )
        {
            cSkip++;

            //
            // Update max fixup size if we're polling for space requirements.
            //

            if ( cwcPath > cwcFixup && cwcPath > cwcMaxPath )
                cwcMaxPath = cwcPath;

            continue;
        }

        Win4Assert( 0 == pwcsFixup[cwcPath] );

        //
        // If the scope is shallow, check that it's still in scope
        //

        if ( !fDeep )
        {
            unsigned cwcName = 0;
            WCHAR * pwcName = pwcsFixup + cwcPath - 1;

            while ( L'\\' != *pwcName )
            {
                Win4Assert( cwcName < cwcPath );
                cwcName++;
                pwcName--;
            }

            unsigned cwcJustPath = cwcPath - cwcName - 1;

            BOOL fTooDeep = cwcJustPath > cwcRoot;

            if ( fTooDeep )
            {
                cSkip++;
                continue;
            }
            else
                break;
        }
        else
            break;
    }

    if (0 == cwcMaxPath)
        return cwcPath;
    else
        return cwcMaxPath;
} //FetchFixupInScope
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\qsession.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998.
//
// File:        qsession.cxx
//
// Contents:    Query Session. Implements ICiCQuerySession interface.
//
// Classes:     CQuerySession
//
// History:     12-Dec-96       SitaramR        Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qsession.hxx>
#include <catalog.hxx>
#include <ciprop.hxx>
#include <vrtenum.hxx>
#include <metapenm.hxx>
#include <scopeenm.hxx>
#include <defprop.hxx>
#include <dbprputl.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::CQuerySession
//
//  Synopsis:   Constructor
//
//  Arguments:  [cat]              -- Catalog
//              [xSecCache]        -- Cache of access check results
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

CQuerySession::CQuerySession( PCatalog & cat )
        : _cat(cat),
          _secCache( cat ),
          _fUsePathAlias( FALSE ),
          _cRefs(1)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::~CQuerySession
//
//  Synopsis:   Destructor
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

CQuerySession::~CQuerySession()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CQuerySession::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Dec-1996      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CQuerySession::AddRef()
{
    return InterlockedIncrement( (long *)&_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CQuerySession::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Dec-1996     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CQuerySession::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *)&_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}



//+-------------------------------------------------------------------------
//
//  Method:     CQuerySession::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Dec-1996     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::QueryInterface(
    REFIID riid,
    void  ** ppvObject)
{
    *ppvObject = 0;

    if ( IID_ICiCQuerySession == riid )
        *ppvObject = (IUnknown *)(ICiCQuerySession *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::Init
//
//  Synopsis:   Initializes a query session
//
//  Arguments:  [nProps]           -- # of props in apPropSpec
//              [apPropSpec]       -- Properties that may be retrieved by the query
//              [pDBProperties]    -- Properties such as scope
//              [pQueryPropMapper] -- Propspec <-> pid mapper
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::Init( ULONG nProps,
                                             const FULLPROPSPEC *const *apPropSpec,
                                             IDBProperties *pDBProperties,
                                             ICiQueryPropertyMapper *pQueryPropertyMapper)
{
    SCODE sc = S_OK;

    pQueryPropertyMapper->AddRef();
    _xQueryPropMapper.Set( pQueryPropertyMapper );

    TRY
    {
        //
        // Form the scope, _eType and _fUsePathAlias
        //

        CGetDbProps dbProps;

        dbProps.GetProperties( pDBProperties,
                               CGetDbProps::eMachine         |
                               CGetDbProps::eScopesAndDepths |
                               CGetDbProps::eCatalog         |
                               CGetDbProps::eQueryType );

        WCHAR const * pwszMachine = dbProps.GetMachine();

        if ( 0 == pwszMachine )
            THROW( CException( E_INVALIDARG ) );

        _fUsePathAlias = (L'.' != pwszMachine[0]);

        //
        // The registry can override a local client so paths are returned
        // with the alias taken into account.
        //

        CCiRegParams * pRegParams = _cat.GetRegParams();
        if ( 0 != pRegParams && pRegParams->GetForcePathAlias() )
            _fUsePathAlias = TRUE;

        _eType = dbProps.GetQueryType();

        if ( CiNormal == _eType )
        {
            const ULONG allScp = ( QUERY_SHALLOW | QUERY_DEEP |
                                   QUERY_PHYSICAL_PATH | QUERY_VIRTUAL_PATH );

            WCHAR const * const * aScopes = dbProps.GetScopes();
            DWORD const * aDepths = dbProps.GetDepths();

            if ( 0 == aScopes || 0 == aDepths )
                THROW( CException( E_INVALIDARG ) );

            ULONG cScopes   = dbProps.GetScopeCount();
            ULONG cCatalogs = dbProps.GetCatalogCount();

            Win4Assert( cCatalogs == 1 );
            Win4Assert( cScopes > 0 );

            //
            // Get clean array of scopes. 
            //

            CDynArray<WCHAR> aNormalizedScopes( cScopes );

            GetNormalizedScopes(aScopes, aDepths, cScopes, cCatalogs, aNormalizedScopes);

            if ( cScopes == 1 )
            {
                _xScope.Set( new CScopeRestriction( aNormalizedScopes.Get(0),
                                                    0 != ( aDepths[0] & QUERY_DEEP ),
                                                    0 != ( aDepths[0] & QUERY_VIRTUAL_PATH ) ) );
            }
            else
            {
                CNodeRestriction * pNodeRst = new CNodeRestriction( RTOr, cScopes );
                _xScope.Set( pNodeRst );

                for ( ULONG i = 0; i < cScopes; i++ )
                {
                    if ( ( 0 != ( aDepths[i] & (~allScp) ) ) ||
                         ( 0 == aNormalizedScopes.Get(i) ) )
                        THROW( CException( E_INVALIDARG ) );

                    XPtr<CScopeRestriction> xScope( new CScopeRestriction(
                                                    aNormalizedScopes.Get(i),
                                                    0 != ( aDepths[i] & QUERY_DEEP ),
                                                    0 != ( aDepths[i] & QUERY_VIRTUAL_PATH ) ) );
                    pNodeRst->AddChild( xScope.GetPointer() );
                    xScope.Acquire();
                }
            }

            if ( !ValidateScopeRestriction( _xScope.GetPointer() ) )
                THROW( CException( STATUS_NO_MEMORY ) );
        }
        else
        {
            // Any type of query except enumerating properties requires admin
            // level access.

            if ( CiProperties != _eType )
                VerifyThreadHasAdminPrivilege();

            // If the query type isn't known, fail the query.

            if ( ( CiProperties != _eType ) &&
                 ( CiVirtualRoots != _eType ) &&
                 ( CiPhysicalRoots != _eType ) &&
                 ( CiAdminOp != _eType ) )
                THROW( CException( E_INVALIDARG ) );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CQuerySession::Init - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::GetNormalizedScopes
//
//  Synopsis:   Validates/Normalizes scopes format  
//
//  Arguments:  [aScopes]      - pointer to array of scopes
//              [aDepths]      - pointer to array of depths
//              [cScopes]      - count of scopes
//              [cCatalogs]    - count of catalogs
//              [aNormalizedScopes] - array of clean scopes to be returned.
//
//  History:    14-May-97   mohamedn   moved/merged from CQuerySpec
//
//--------------------------------------------------------------------------

void CQuerySession::GetNormalizedScopes(WCHAR const * const *aScopes, 
                                        ULONG const * aDepths,
                                        ULONG   cScopes,
                                        ULONG   cCatalogs,
                                        CDynArray<WCHAR> & aNormalizedScopes)
{
    //
    // Don't allow 'current directory' opens like 'd:'.  Must be 'd:\'
    //

    BOOL fAnyVirtual = FALSE;

    for ( ULONG iScope = 0; iScope < cScopes; iScope++ )
    {
        unsigned len = wcslen( aScopes[ iScope ] );

        // empty scopes mean "\", and they come from v5 clients

        if ( 0 != len )
        {
            if ( ( len < 3 ) &&
                 ( !IsVScope( aDepths[ iScope ] ) ) &&
                 ( wcscmp( aScopes[ iScope ], L"\\" ) ) )
                    THROW ( CException(E_INVALIDARG) );
    
             if ( IsVScope( aDepths[ iScope ] ) )
                fAnyVirtual = TRUE;
        }
    }

    // A catalog must be specified with virtual paths (since a virtual path
    // tells you nothing about catalog location.

    if ( 0 == cCatalogs && fAnyVirtual )
        THROW ( CException(E_INVALIDARG) );

    //
    // Generate clean scopes 
    //

    for ( ULONG i = 0; i < cScopes; i++ )
    {
        XArray<WCHAR> xScope;
        CleanupScope( xScope,
                      aDepths[i],
                      aScopes[i] );
        aNormalizedScopes.Add( xScope.Get(), i );
        xScope.Acquire();
    }
} //GetNormalizedScopes

//+-------------------------------------------------------------------------
//
//  Function:   CQuerySession::CleanupScope, public
//
//  Synopsis:   Makes sure a scope is well-formed
//
//  Arguments:  [xScope]      -- Returns a cleaned-up scope
//              [dwDepth]     -- Scope flags: deep/virtual
//              [pwcScope]    -- Scope as specified by the user
//
//  History:    1-Nov-96  dlee    Moved Kyle's code from EvalQuery
//
//--------------------------------------------------------------------------

void CQuerySession::CleanupScope( XArray<WCHAR> & xScope,
                                  DWORD           dwDepth,
                                  WCHAR const   * pwcScope )
{
    // A non-slash terminated path to root is illegal.  A slash
    // terminated path to a directory other than the root is
    // illegal.  Sigh.

    Win4Assert( 0 != pwcScope );
    XGrowable<WCHAR> xTempScope;
    WCHAR const * pwcFinalScope = 0;

    if ( ( 0 == *pwcScope ) ||
         ( !_wcsicmp( L"catalog", pwcScope ) ) ||
         ( !wcscmp( L"\\", pwcScope ) ) )
    {
        pwcFinalScope = L"";
    }
    else if ( IsVScope( dwDepth ) )
    {
        pwcFinalScope = pwcScope;
    }
    else
    {
        int len = wcslen( pwcScope );

        BOOL fEndsInSlash = (pwcScope[len-1] == L'\\');
        BOOL fIsRoot;

        if ( len == 3 )
            fIsRoot = TRUE;
        else if ( pwcScope[0] == L'\\' && pwcScope[1] == L'\\' )
        {
            unsigned cSlash = 2;

            for ( unsigned i = 2; pwcScope[i] != 0; i++ )
            {
                if ( pwcScope[i] == L'\\' )
                {
                    cSlash++;

                    if ( cSlash > 4 )
                        break;
                }
            }

            if ( cSlash > 4 )
                fIsRoot = FALSE;
            else if ( cSlash == 4 && !fEndsInSlash )
                fIsRoot = FALSE;
            else
                fIsRoot = TRUE;
        }
        else
            fIsRoot = FALSE;

        if ( fIsRoot )
        {
            if ( !fEndsInSlash )
            {
                xTempScope.SetSize( len + 1 + 1 );
                memcpy( xTempScope.Get(), pwcScope, len * sizeof WCHAR );
                xTempScope[len] = L'\\';
                len++;
                xTempScope[len] = 0;
                pwcFinalScope = xTempScope.Get(); 
            }
            else
                pwcFinalScope = pwcScope;
        }
        else
        {
            if ( fEndsInSlash )
            {
                xTempScope.SetSize( len );
                memcpy( xTempScope.Get(), pwcScope, (len-1)*sizeof(WCHAR) );
                xTempScope[len - 1] = 0;
                pwcFinalScope = xTempScope.Get();
            }
            else
                pwcFinalScope = pwcScope;
        }
    }

    Win4Assert( 0 != pwcFinalScope );
    int len = wcslen( pwcFinalScope );
    xScope.Init( 1 + len );
    RtlCopyMemory( xScope.GetPointer(), pwcFinalScope, xScope.SizeOf() );
} //CleanupScope

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::GetEnumOption
//
//  Synopsis:   Specify the enumeration type
//
//  Arguments:  [pEnumOption]  -- Enumeration option returned here
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::GetEnumOption( CI_ENUM_OPTIONS *pEnumOption)
{
    SCODE sc = S_OK;

    TRY
    {
        Win4Assert( pEnumOption != 0 );

        switch ( _eType )
        {
        case CiProperties:       // Fall thru
        case CiVirtualRoots:
            *pEnumOption = CI_ENUM_MUST_NEVER_DEFER;

            break;

        case CiPhysicalRoots:
            Win4Assert( !"Not implemented");
            vqDebugOut(( DEB_ERROR,
                         "CQuerySession::GetEnumOption - CiPhysicalRoots not implemented\n" ));

            sc = E_NOTIMPL;
            break;

        case CiNormal:
            if ( IsAnyScopeDeep() )
                *pEnumOption = CI_ENUM_BIG;
            else
                *pEnumOption = CI_ENUM_SMALL;

            break;

        default:
            Win4Assert( !"Unknown value of case selector");
            vqDebugOut(( DEB_ERROR,
                         "CQuerySession::GetEnumOption - Unknown case selector: %d\n",
                         _eType ));

            sc = E_FAIL;
            break;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CQuerySession::GetEnumOption - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
} //GetEnumOption

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::CreatePropRetriever
//
//  Synopsis:   Creates property retriever object for the given scope
//
//  Arguments:  [ppICiCPropRetreiver]  -- Property retriever returned here
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::CreatePropRetriever( ICiCPropRetriever **ppICiCPropRetriever)
{
    SCODE sc = S_OK;

    TRY
    {
        CCiPropRetriever *pPropRetriever = new CCiPropRetriever( _cat,
                                                                 _xQueryPropMapper.GetPointer(),
                                                                 _secCache,
                                                                 _fUsePathAlias,
                                                                 _xScope.GetPointer() );
        SCODE sc = pPropRetriever->QueryInterface( IID_ICiCPropRetriever,
                                                   (void **) ppICiCPropRetriever );

        //
        // Either QI does an AddRef, or if failed free pPropRetriever
        //
        pPropRetriever->Release();

#if CIDBG == 1
        if ( FAILED(sc) )
            vqDebugOut(( DEB_ERROR,
                         "CQuerySession::CreatePropRetriever : QI failed 0x%x\n",
                         sc ));
#endif
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CQuerySession::CreatePropRetriever - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::CreateDeferredPropRetriever
//
//  Synopsis:   Creates a deferred property retriever object for the given scope
//
//  Arguments:  [ppICiCDefPropRetreiver]  -- Deferred property retriever returned here
//
//  History:    12-Jan-97      SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::CreateDeferredPropRetriever(
                                          ICiCDeferredPropRetriever **ppICiCDefPropRetriever)
{
    SCODE sc = S_OK;

    TRY
    {
        CCiCDeferredPropRetriever *pDefPropRetriever = new CCiCDeferredPropRetriever(
                                                                 _cat,
                                                                 _secCache,
                                                                 _fUsePathAlias );
        SCODE sc = pDefPropRetriever->QueryInterface( IID_ICiCDeferredPropRetriever,
                                                      (void **) ppICiCDefPropRetriever );

        //
        // Either QI does an AddRef, or if failed free pDefPropRetriever
        //
        pDefPropRetriever->Release();

#if CIDBG == 1
        if ( FAILED(sc) )
            vqDebugOut(( DEB_ERROR,
                         "CQuerySession::CreateDeferredPropRetriever : QI failed 0x%x\n",
                         sc ));
#endif
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CQuerySession::CreateDeferredPropRetriever - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::CreateEnumerator
//
//  Synopsis:   Creates scope retriever object for the given scope
//
//  Arguments:  [ppICiCScopeEnumerator]  -- Enumerator object returned here
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySession::CreateEnumerator( ICiCScopeEnumerator **ppICiCScopeEnumerator)
{
    SCODE sc = S_OK;

    TRY
    {
        switch ( _eType )
        {
        case CiNormal:
        {
            CScopeEnum *pScopeEnum = new CScopeEnum( _cat,
                                                     _xQueryPropMapper.GetPointer(),
                                                     _secCache,
                                                     _fUsePathAlias,
                                                     _xScope.GetReference() );
            SCODE sc = pScopeEnum->QueryInterface( IID_ICiCScopeEnumerator,
                                                   (void **) ppICiCScopeEnumerator );
            //
            // Either QI does an AddRef, or if failed free pScopeEnum
            //
            pScopeEnum->Release();

            break;
        }

        case CiVirtualRoots:
        {
            CVRootEnum *pVRootEnum = new CVRootEnum( _cat,
                                                     _xQueryPropMapper.GetPointer(),
                                                     _secCache,
                                                     _fUsePathAlias );
            SCODE sc = pVRootEnum->QueryInterface( IID_ICiCScopeEnumerator,
                                                   (void **) ppICiCScopeEnumerator );
            //
            // Either QI does an AddRef, or if failed free pVRootEnum
            //
            pVRootEnum->Release();

            break;
        }

        case CiProperties:
        {
            CMetaPropEnum *pMetaPropEnum = new CMetaPropEnum( _cat,
                                                              _xQueryPropMapper.GetPointer(),
                                                              _secCache,
                                                              _fUsePathAlias );
            SCODE sc = pMetaPropEnum->QueryInterface( IID_ICiCScopeEnumerator,
                                                      (void **) ppICiCScopeEnumerator );
            //
            // Either QI does an AddRef, or if failed free pMetaPropEnum
            //
            pMetaPropEnum->Release();

            break;
        }

        default:
            *ppICiCScopeEnumerator = 0;

            Win4Assert( !"Unknown value of case selector");
            vqDebugOut(( DEB_ERROR,
                         "CQuerySession::CreateEnumerator - Unknown case selector: %d\n",
                         _eType ));

            sc = E_FAIL;
            break;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "CQuerySession::CreateEnumerator - Exception caught 0x%x\n", sc ));

    }
    END_CATCH;

#if CIDBG == 1
    if ( FAILED(sc) )
        vqDebugOut(( DEB_ERROR, "CQuerySession::CreateEnumerator : QI failed 0x%x\n", sc ));
#endif

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CQuerySession::IsAnyScopeDeep
//
//  Synopsis:   Returns is any of the scopes is deep
//
//  History:    12-Dec-96     DLee        Created
//
//--------------------------------------------------------------------------

BOOL CQuerySession::IsAnyScopeDeep() const
{
    if ( 0 == &(_xScope.GetReference()) )
        return FALSE;

    if ( RTScope == _xScope->Type() )
    {
        CScopeRestriction const & scp = (CScopeRestriction const &) _xScope.GetReference();
        return scp.IsDeep();
    }
    else if ( RTOr == _xScope->Type() )
    {
        CNodeRestriction const & node = * _xScope->CastToNode();

        for ( ULONG x = 0; x < node.Count(); x++ )
        {
            Win4Assert( RTScope == node.GetChild( x )->Type() );

            CScopeRestriction & scp = * (CScopeRestriction *) node.GetChild( x );
            if ( scp.IsDeep() )
                return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\seccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1998.
//
//  File:        seccache.cxx
//
//  Contents:    Security descriptor cache that maps SDIDs to granted/denied
//
//  Class:       CSecurityCache
//
//  History:     25-Sep-95       dlee    Created
//               22 Jan 96       Alanw   Modified for use in user mode
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


// Local includes:
#include <seccache.hxx>

#include <catalog.hxx>


//+---------------------------------------------------------------------------
//
//  Method:      CSecurityCache::CSecurityCache, public
//
//  Synopsis:    Creates a CSecurityCache.  In user mode, an
//               impersonation token to use with the AccessCheck call is
//               obtained.
//
//  History:     22 Jan 96       Alanw   Created
//
//----------------------------------------------------------------------------

CSecurityCache::CSecurityCache( PCatalog & rCat ) :
        _aEntries( cDefaultSecurityDescriptorEntries ),
        _hToken( INVALID_HANDLE_VALUE ),
        _Cat( rCat )
{
    InitToken();
}


//+---------------------------------------------------------------------------
//
//  Method:      CSecurityCache::InitToken, public
//
//  Synopsis:    Captures an impersonation token to use with the AccessCheck
//               call.
//
//  History:     15 Feb 96       Alanw   Created
//
//----------------------------------------------------------------------------

void CSecurityCache::InitToken( )
{
    DWORD   ReturnLength;
    NTSTATUS   status;

    TOKEN_STATISTICS    TokenInformation;

    status = NtOpenThreadToken( GetCurrentThread(),
                                TOKEN_QUERY | TOKEN_DUPLICATE |
                                     TOKEN_IMPERSONATE,    // Desired Access
                                TRUE,           // OpenAsSelf
                                &_hToken);

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_NO_TOKEN)
        {
            status = NtOpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_DUPLICATE |
                                    TOKEN_IMPERSONATE,    // Desired Access
                               &_hToken);
        }

        if (!NT_SUCCESS(status))
        {
            vqDebugOut(( DEB_ERROR,
                         "CSecurityCache: failed to get token handle, %x\n",
                         status ));
            THROW(CException( status ));
        }
    }

    status = NtQueryInformationToken ( _hToken,
                                       TokenStatistics,
                                       (LPVOID)&TokenInformation,
                                       sizeof TokenInformation,
                                       &ReturnLength);

    if (!NT_SUCCESS(status))
    {
        NtClose( _hToken );
        _hToken = INVALID_HANDLE_VALUE;

        vqDebugOut(( DEB_ERROR,
                     "CSecurityCache: failed to get token info, %x\n",
                     status ));
        THROW(CException( status ));
    }

    if ( TokenInformation.TokenType != TokenImpersonation )
    {
        HANDLE hNewToken = INVALID_HANDLE_VALUE;
        OBJECT_ATTRIBUTES ObjA;
        SECURITY_QUALITY_OF_SERVICE SecurityQOS;

        SecurityQOS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
        SecurityQOS.ImpersonationLevel = SecurityIdentification;
        SecurityQOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQOS.EffectiveOnly = FALSE;

        InitializeObjectAttributes( &ObjA,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
        ObjA.SecurityQualityOfService = &SecurityQOS;

        status = NtDuplicateToken( _hToken,
                                   TOKEN_IMPERSONATE | TOKEN_QUERY,
                                   &ObjA,
                                   FALSE,
                                   TokenImpersonation,
                                   &hNewToken );

        if (! NT_SUCCESS( status ) )
        {
            NtClose( _hToken );
            _hToken = INVALID_HANDLE_VALUE;

            vqDebugOut(( DEB_ERROR,
                         "CSecurityCache: failed to duplicate token, %x\n",
                         status ));
            THROW(CException( status ));
        }

        NtClose( _hToken );
        _hToken = hNewToken;
    }
}

CSecurityCache::~CSecurityCache()
{
    if ( INVALID_HANDLE_VALUE != _hToken )
        NtClose( _hToken );
}

//+---------------------------------------------------------------------------
//
//  Method:      CSecurityCache::_IsCached, private
//
//  Synopsis:    Determines whether a sdid is granted access given the
//               cache's security context.
//
//  Arguments:   [sdidOrd]   -- security descriptor ordinal to test
//               [am]        -- access mask of the request
//               [fGranted]  -- if return value is TRUE, this is either
//                              TRUE (if access is granted) or FALSE.
//
//  Returns:     TRUE if sdid was in the cache and fGranted is set
//               FALSE if sdid is not cached and fGranted should be ignored
//
//  History:     25-Sep-95       dlee    Created
//
//----------------------------------------------------------------------------

inline BOOL CSecurityCache::_IsCached(
    ULONG       sdidOrd,
    ACCESS_MASK am,
    BOOL &      fGranted ) const
{
    // Look for the sdid in the cache

    for ( unsigned i = 0; i < _aEntries.Count(); i++ )
    {
        if ( ( _aEntries[i].sdidOrd == sdidOrd ) &&
             ( _aEntries[i].am      == am ) )
        {
            fGranted = _aEntries[i].fGranted;
            return TRUE;
        }
    }

    return FALSE;
} //_IsCached


//+---------------------------------------------------------------------------
//
//  Method:      CSecurityCache::IsGranted, public
//
//  Synopsis:    Determines whether a security ordinal is granted access given
//               the cache's security context, and caches the result.
//
//  Arguments:   [sdidOrdinal] -- security descriptor ordinal to test
//               [am]        -- access mask of the request, one or more of
//                              FILE_READ_ATTRIBUTES
//                              FILE_READ_DATA / FILE_LIST_DIRECTORY
//                              FILE_TRAVERSE
//
//  Returns:     TRUE if sdid was granted access, FALSE otherwise
//
//  History:     25-Sep-95       dlee    Created
//               22 Jan 96       Alanw   Modified for use in user mode
//
//----------------------------------------------------------------------------

BOOL CSecurityCache::IsGranted(
    ULONG           sdidOrdinal,
    ACCESS_MASK     am )
{
    // if nothing asked for, grant
    if ( 0 == am )
        return TRUE;

    if ( sdidNull == sdidOrdinal )
        return TRUE;

    if ( sdidInvalid == sdidOrdinal )
        return FALSE;

    BOOL fGranted;

    {
        CLock lock( _mutex );

        if ( _IsCached( sdidOrdinal, am, fGranted ) )
            return fGranted;
    }

    // do the security check

    fGranted = FALSE;
    BOOL fResult = _Cat.AccessCheck( sdidOrdinal,
                                     GetToken(),
                                     am,
                                     fGranted);

    if (! fResult)
    {
        DWORD dwError = GetLastError();
        Win4Assert( fResult && dwError == NO_ERROR );
    }

    // Not cached yet -- do so

    vqDebugOut(( DEB_ITRACE, "cacheing sdid %x, granted: %x\n",
                 sdidOrdinal, fGranted ));

    {
        CLock lock( _mutex );

        // check the cache again -- it may have slipped in via a different
        // thread while we weren't holding the lock.

        if ( !_IsCached( sdidOrdinal, am, fGranted ) )
        {
            unsigned i = _aEntries.Count();
            _aEntries[i].sdidOrd = sdidOrdinal;
            _aEntries[i].am = am;
            _aEntries[i].fGranted = fGranted;
        }
    }

    return fGranted;
} //IsGranted
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\cioplock.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       CIOPLOCK.CXX
//
//  Contents:   Oplock support for filtering documents
//
//  Classes:    CFilterOplock
//
//  History:    03-Jul-95    DwightKr   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntopen.hxx>
#include <cioplock.hxx>

const WCHAR * g_aOplockException[] =
{
    L"asx",
    L"mp2",
    L"mp3",
};

const unsigned g_cOplockException = sizeof g_aOplockException /
                                    sizeof g_aOplockException[0];

//+---------------------------------------------------------------------------
//
//  Function:   IsOplockException
//
//  Synopsis:   Checks if the extension on a file makes us want to not take
//              the oplock because filtering properties will open the file
//              in an incompatible mode.
//
//  Arguments:  [pwcPath]  -- The path of the file to check
//
//  History:    1-Feb-01  dlee  Created
//
//----------------------------------------------------------------------------

BOOL IsOplockException( WCHAR const * pwcPath )
{
    WCHAR const * pwc = wcsrchr( pwcPath, L'.' );

    if ( 0 == pwc )
        return FALSE;

    pwc++;

    for ( unsigned i = 0; i < g_cOplockException; i++ )
        if ( !wcscmp( pwc, g_aOplockException[i] ) )
            return TRUE;

    return FALSE;
} //IsOplockException

//+---------------------------------------------------------------------------
//
//  Member:     CFilterOplock::CFilterOplock
//
//  Synopsis:   Takes an oplock on the file object specified
//
//  Arguments:  [wcsFileName]  -- name of file to take oplock on
//
//  History:    03-Jul-95   DwightKr    Created
//              21-Feb-96   DwightKr    Add support for OPLocks on NTFS
//                                      directories
//
//  Notes:      NTFS doesn't support oplocks on directories.  Change
//              this routine's expectations when directory oplocks
//              are supported.
//
//----------------------------------------------------------------------------

CFilterOplock::CFilterOplock( const CFunnyPath & funnyFileName, BOOL fTakeOplock )
                              : _hFileOplock(INVALID_HANDLE_VALUE),
                                _hFileNormal(INVALID_HANDLE_VALUE),
                                _hLockEvent(INVALID_HANDLE_VALUE),
                                _funnyFileName( funnyFileName ),
                                _fWriteAccess( TRUE )
{
    const BOOL fDrivePath =  ( !funnyFileName.IsRemote() &&
                               funnyFileName.GetActualLength() > 2 );

    HANDLE handle = INVALID_HANDLE_VALUE;

    NTSTATUS Status;
    SHandle xLockHandle;      // save handle in a smart pointer

    fTakeOplock = fTakeOplock && fDrivePath;

    BOOL fAppendBackSlash = FALSE;

    // For volume \\?\D:, NtQueryInformationFile fails with the following
    // error: 0xC0000010L - STATUS_INVALID_DEVICE_REQUEST. Need to append a \,
    // to make it work. We need to append the '\'only in case of volume path.

    if ( !funnyFileName.IsRemote() && 2 == funnyFileName.GetActualLength() )
    {
        Win4Assert( L':'  == (funnyFileName.GetActualPath())[1] );
        ((CFunnyPath&)funnyFileName).AppendBackSlash();    // override const
        fAppendBackSlash = TRUE;
    }

    //
    // Major work-around here.  The shell IPropertySetStorage routines open
    // these filetypes through wmi which open the file GENERIC_WRITE.  This
    // will deadlock the filter thread with itself since it's incompatible
    // with the oplock.
    //

    if ( fTakeOplock && IsOplockException( funnyFileName.GetPath() ) )
        fTakeOplock = FALSE;

    //
    // Make this case work (for SPS): \\.\backofficestorage...
    // Funyypath treats it as a remote path.  Detect this and change
    //     \\?\UNC\.\backoffice
    // into
    //     \\?\UN\\.\backoffice
    // then pass this into Rtl: \\.\backoffice
    //

    WCHAR *pwcPath = (WCHAR *) funnyFileName.GetPath();

    BOOL fCtoBack = FALSE;

    if ( pwcPath[8] == L'.' &&
         pwcPath[6] == L'C' )
    {
        pwcPath[6] = L'\\';
        pwcPath = pwcPath + 6;
        fCtoBack = TRUE;
    }

    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( pwcPath,
                                        &uScope,
                                        0,
                                        0 ) )
    {
        ciDebugOut(( DEB_ERROR, "Error converting %ws to Nt path\n", funnyFileName.GetPath() ));
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    if ( fAppendBackSlash )
    {
        ((CFunnyPath&)funnyFileName).RemoveBackSlash();    // override const
    }

    if ( fCtoBack )
        pwcPath[6] = L'C';

    IO_STATUS_BLOCK   IoStatus;
    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    //
    // Don't try to take oplocks on UNC shares. Gibraltar doesn't support
    // redirected network drives. So, don't worry about redirected network
    // drives. Testing if a drive letter is a network drive is not very
    // cheap.
    //
    BOOL fOplockNotSupported = !fTakeOplock;
    SHandle xOplockHandle(INVALID_HANDLE_VALUE);

    if ( fTakeOplock )
    {
        ULONG modeAccess    = FILE_READ_ATTRIBUTES;
        ULONG modeShare     = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        ULONG modeCreate    = FILE_OPEN;
        ULONG modeAttribute = FILE_ATTRIBUTE_NORMAL;
        ULONG modeCreateOptions = FILE_RESERVE_OPFILTER;


        Status = NtCreateFile( &handle,           // Handle
                               modeAccess,        // Access
                               &ObjectAttr,       // Object Attributes
                               &IoStatus,         // I/O Status block
                               0,                 // Allocation Size
                               modeAttribute,     // File Attributes
                               modeShare,         // File Sharing
                               modeCreate,        // Create Disposition
                               modeCreateOptions, // Create Options
                               0,                 // EA Buffer
                               0 );               // EA Buffer Length

        if ( NT_SUCCESS(Status) )
            Status = IoStatus.Status;

        //
        //  Note: Keep uScope.Buffer around for the other open which occurs
        //        below.
        //


        if ( !NT_SUCCESS(Status) )
        {
            //
            // Failed to get oplock.  Continue on though; this may have been
            // due to a failure to get an oplock on a directory.
            //
            ciDebugOut(( DEB_IWARN,
                         "CFilterOplock failed to NtCreateFile(%ws) status = 0x%x\n",
                          funnyFileName.GetPath(),
                          Status ));
        }
        else
        {
            //
            //  Oplock open succeeded.  Try to actually get the oplock.
            //
            xOplockHandle.Set(handle);            // Save in the smart pointer

            //
            // Create event (signalled on oplock break)
            //

            Status = NtCreateEvent( &handle,
                                    EVENT_ALL_ACCESS,
                                    0,
                                    NotificationEvent,
                                    TRUE );

            if (! NT_SUCCESS(Status) )
            {
                ciDebugOut(( DEB_ERROR, "Error creating oplock event\n" ));
                THROW( CException(Status) );
            }

            xLockHandle.Set( handle );

            _IoStatus.Status = STATUS_SUCCESS;
            _IoStatus.Information = 0;

            Status = NtFsControlFile( xOplockHandle.Get(),
                                      xLockHandle.Get(),
                                      0,
                                      0,
                                      &_IoStatus,
                                      FSCTL_REQUEST_FILTER_OPLOCK,
                                      0,
                                      0,
                                      0,
                                      0 );

            if ( !NT_SUCCESS(Status) )
            {
                if ( STATUS_INVALID_DEVICE_REQUEST == Status )
                    fOplockNotSupported = TRUE;

                ciDebugOut(( DEB_IWARN,
                             "CFilterOplock failed to NtFsControlFile(%ws) status = 0x%x\n",
                              funnyFileName.GetPath(),
                              Status ));
                NtClose( xOplockHandle.Acquire() );
                NtClose( xLockHandle.Acquire() );
            }
        }

        #if CIDBG == 1

            if ( ( ! NT_SUCCESS(Status) ) && fDrivePath )
            {
                //
                //  If we failed to take a filter oplock this is okay as long
                //  as either:
                //     1.  the file type is a directory and the FS is NTFS.
                //     2.  the file system does not support filter oplocks.
                //

                WCHAR wcsDrive[4];
                wcsncpy( wcsDrive, funnyFileName.GetActualPath(), 3 );
                wcsDrive[3] = L'\0';
                Win4Assert( wcsDrive[1] == L':' && wcsDrive[2] == L'\\' );

                WCHAR wcsFileSystemName[10];
                wcsFileSystemName[0] = 0;

                if ( !GetVolumeInformation( wcsDrive,
                                            0,0,0,0,0,
                                            wcsFileSystemName,
                                            sizeof wcsFileSystemName / sizeof (WCHAR)
                                          ) )
                {
                    THROW( CException() );
                }

                if ( _wcsicmp(wcsFileSystemName, L"NTFS") == 0 )
                {
                    Win4Assert( !fOplockNotSupported &&
                                _wcsicmp(wcsFileSystemName, L"NTFS") == 0 );
                }

            }

        #endif // CIDBG == 1
    }

    //
    //  Now open the file handle for normal access to the file.
    //  The oplock handle should only be used for the oplock.
    //
    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    ULONG modeAccess    = READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
    ULONG modeShare     = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    ULONG modeCreate    = FILE_OPEN;
    ULONG modeAttribute = FILE_ATTRIBUTE_NORMAL;
    ULONG modeCreateOptions = 0;

    Status = NtCreateFile( &handle,           // Handle
                           modeAccess,        // Access
                           &ObjectAttr,       // Object Attributes
                           &IoStatus,         // I/O Status block
                           0,                 // Allocation Size
                           modeAttribute,     // File Attributes
                           modeShare,         // File Sharing
                           modeCreate,        // Create Disposition
                           modeCreateOptions, // Create Options
                           0,                 // EA Buffer
                           0 );               // EA Buffer Length

    if ( NT_SUCCESS(Status) )
        Status = IoStatus.Status;

    if ( STATUS_ACCESS_DENIED == Status )
    {
        // The open failed.  Try again without requesting FILE_WRITE_ATTRIBUTE
        // access.
        _fWriteAccess = FALSE;
        modeAccess &= ~FILE_WRITE_ATTRIBUTES;

        Status = NtCreateFile( &handle,           // Handle
                               modeAccess,        // Access
                               &ObjectAttr,       // Object Attributes
                               &IoStatus,         // I/O Status block
                               0,                 // Allocation Size
                               modeAttribute,     // File Attributes
                               modeShare,         // File Sharing
                               modeCreate,        // Create Disposition
                               modeCreateOptions, // Create Options
                               0,                 // EA Buffer
                               0 );               // EA Buffer Length

        if ( NT_SUCCESS(Status) )
            Status = IoStatus.Status;
    }

    RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

    if ( !NT_SUCCESS( Status ) )
    {
        ciDebugOut(( DEB_IERROR, "CFilterOplock - Error opening %ws as normal file\n", funnyFileName.GetPath() ));
        QUIETTHROW( CException(Status) );
    }

    SHandle xNormalHandle( handle );

    Status = NtQueryInformationFile( xNormalHandle.Get(),  // File handle
                                     &IoStatus,            // I/O Status
                                     &_BasicInfo,          // Buffer
                                     sizeof _BasicInfo,    // Buffer size
                                     FileBasicInformation );

    if ( NT_SUCCESS(Status) )
        Status = IoStatus.Status;

    if ( !NT_SUCCESS(Status) )
    {
        ciDebugOut(( DEB_IERROR, "CFilterOplock - Error 0x%x querying file info for %ws.\n",
                     Status, funnyFileName.GetPath() ));
        QUIETTHROW( CException(Status) );
    }

    _fDirectory = (_BasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

    if ( INVALID_HANDLE_VALUE == xOplockHandle.Get() &&
         ! ( _fDirectory || fOplockNotSupported ) )
    {
        ciDebugOut(( DEB_ITRACE,
                     "CFilterOplock failed to aquire oplock (%ws) %d %d\n",
                      funnyFileName.GetPath(), _fDirectory, fOplockNotSupported ));

        QUIETTHROW( CException(STATUS_OPLOCK_BREAK_IN_PROGRESS) );
    }

    _hLockEvent = xLockHandle.Acquire();
    _hFileOplock = xOplockHandle.Acquire();
    _hFileNormal = xNormalHandle.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterOplock::~CFilterOplock, public
//
//  Synopsis:   Destructor
//
//  History:    03-Jul-95   DwightKr    Created
//
//----------------------------------------------------------------------------

CFilterOplock::~CFilterOplock()
{
    if ( INVALID_HANDLE_VALUE != _hFileNormal )
        NtClose(_hFileNormal);

    //
    // Make sure this is the last file handle closed.
    //

    if ( INVALID_HANDLE_VALUE != _hFileOplock )
        NtClose(_hFileOplock);

    if ( INVALID_HANDLE_VALUE != _hLockEvent )
    {

        //
        // We MUST wait until the lock event has been completed to
        // prevent a race between APC call and the cleanup.
        //
        NTSTATUS Status = NtWaitForSingleObject( _hLockEvent,
                                                 FALSE,
                                                 0   // Infinite
                                                );
        NtClose( _hLockEvent );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterOplock::IsOplockBroken, public
//
//  Synopsis:   Tests for a broken oplock
//
//  History:    03-Jul-95   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL CFilterOplock::IsOplockBroken() const
{
    if ( INVALID_HANDLE_VALUE != _hLockEvent )
    {
        static LARGE_INTEGER li = {0,0};

        NTSTATUS Status = NtWaitForSingleObject( _hLockEvent,
                                                 FALSE,
                                                 &li );

        if ( STATUS_SUCCESS == Status )
        {
            if ( STATUS_NOT_IMPLEMENTED == _IoStatus.Status )
            {
                return FALSE;
            }
            else if ( STATUS_OPLOCK_NOT_GRANTED != _IoStatus.Status )
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterOplock::MaybeSetLastAccessTime, public
//
//  Synopsis:   Restores the last access time to value on oplock open
//
//  Arguments:  [ulDelay] -- If file is < [ulDelay] days old, time not written
//
//  History:    01-Jul-98  KyleP  Created
//
//----------------------------------------------------------------------------

void CFilterOplock::MaybeSetLastAccessTime( ULONG ulDelay )
{
    ULONGLONG const OneDay = 24i64 * 60i64 * 60i64 * 10000000i64;

    if ( _fWriteAccess && !IsOplockBroken() && !_funnyFileName.IsRemote() )
    {
        FILETIME ft;

        GetSystemTimeAsFileTime( &ft );

        ULONGLONG ftLastAccess = (ULONGLONG) _BasicInfo.LastAccessTime.QuadPart;

        if ( ( *(ULONGLONG *)&ft - ftLastAccess ) > (OneDay * ulDelay) )
        {
            do
            {
                //
                // The normal file handle may have been closed and will need reopening...
                //

                NTSTATUS Status = STATUS_SUCCESS;

                if ( INVALID_HANDLE_VALUE == _hFileNormal )
                {
                    Status = CiNtOpenNoThrow( _hFileNormal,
                                              _funnyFileName.GetActualPath(),
                                              READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                              0 );
                }

                if ( !NT_SUCCESS(Status) )
                {
                    ciDebugOut(( DEB_WARN,
                                 "CFilterOplock::MaybeSetLastAccessTime -- Error 0x%x re-opening %ws\n",
                                 Status, _funnyFileName.GetActualPath() ));

                    break;
                }

                //
                // Open volume.  Needed to mark USN Journal entry.
                //

                WCHAR wszVolumePath[] = L"\\\\.\\a:";
                wszVolumePath[4] = _funnyFileName.GetActualPath()[0];

                HANDLE hVolume = CreateFile( wszVolumePath,
                                             FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL );

                if ( hVolume == INVALID_HANDLE_VALUE )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "CFilterOplock::MaybeSetLastAccessTime -- Error %u opening volume\n",
                                 GetLastError() ));

                    break;
                }

                SWin32Handle xHandleVolume( hVolume );

                IO_STATUS_BLOCK  IoStatus;
                MARK_HANDLE_INFO hiCiIgnore = { USN_SOURCE_AUXILIARY_DATA, hVolume, 0 };

                Status = NtFsControlFile( _hFileNormal,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &IoStatus,
                                          FSCTL_MARK_HANDLE,
                                          &hiCiIgnore,
                                          sizeof( hiCiIgnore),
                                          0,
                                          0 );

                Win4Assert( STATUS_PENDING != Status );

                if ( !NT_SUCCESS( Status ) && STATUS_INVALID_DEVICE_REQUEST != Status )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "CFilterOplock::MaybeSetLastAccessTime -- Error 0x%x marking handle\n",
                                 Status ));

                    break;
                }

                //
                // We only want to update last access time.
                //

                _BasicInfo.CreationTime.QuadPart = -1;
                _BasicInfo.LastWriteTime.QuadPart = -1;
                _BasicInfo.ChangeTime.QuadPart = -1;
                _BasicInfo.FileAttributes = 0;

                Status = NtSetInformationFile( _hFileNormal,          // File handle
                                                &IoStatus,            // I/O Status
                                                &_BasicInfo,          // Buffer
                                                sizeof _BasicInfo,    // Buffer size
                                                FileBasicInformation );

                Win4Assert( STATUS_PENDING != Status );

                if ( !NT_SUCCESS( Status ) )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "CFilterOplock::MaybeSetLastAccessTime -- Error 0x%x resetting last-access time.\n",
                                 Status ));
                    break;
                }

            } while( FALSE ); // Polish loop
        } // if access time sufficiently stale
    } // if oplock broken
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\classf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       classf.cxx
//
//  Contents:   Class factory for standard Filter Object class
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "docname.hxx"
#include "classf.hxx"
#include "filterob.hxx"
#include <fsciclnt.h>
#include <dslookup.hxx>
//
//  We keep count of the number of filter objects that we've created
//  to let OLE know when this DLL is finally free.
//

extern long gulcInstances;

// {aa205a4d-681F-11d0-A243-08002B36FCA4}

extern "C" const GUID guidStorageFilterObject =
{ 0xaa205a4d, 0x681f, 0x11d0, { 0xa2, 0x43, 0x8, 0x0, 0x2b, 0x36, 0xfc, 0xa4 } };


extern "C" const GUID guidStorageDocStoreLocatorObject =  CLSID_StorageDocStoreLocator;


//+---------------------------------------------------------------------------
//
//  Construction and destruction
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::CStorageFilterObjectCF
//
//  Synopsis:   Storage Filter Object class factory constructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//+-------------------------------------------------------------------------

CStorageFilterObjectCF::CStorageFilterObjectCF()
    : _RefCount( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::~CStorageFilterObjectCF
//
//  Synopsis:   Storage Filter Object class factory destructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

CStorageFilterObjectCF::~CStorageFilterObjectCF()
{
    Win4Assert( _RefCount == 0);
    Win4Assert( gulcInstances != 0 );

    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStorageFilterObjectCF::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStorageFilterObjectCF::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;
}   //  Release

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObjectCF::QueryInterface(
    REFIID riid,
    PVOID* ppvObject )
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IClassFactory == riid)
        *ppvObject = (PVOID) ((IClassFactory *) this );
    else if ( IID_IUnknown == riid ) 
        *ppvObject = (PVOID) ((IUnknown *) this );
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::CreateInstance
//
//  Synopsis:   Create new CStorageFilterObject instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObjectCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    PVOID * ppvObject )
{
    CStorageFilterObject * pFilterObject = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        //
        //  Create the new object
        //

        pFilterObject = new CStorageFilterObject;

        //
        //  Obtain the new interface
        //

        sc = pFilterObject->QueryInterface( riid , ppvObject );

        //
        //  Regardless of whether the QueryInterface succeeded, we
        //  release the object.
        //

        pFilterObject->Release();
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pFilterObject );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageFilterObjectCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObjectCF::LockServer( BOOL fLock )
{
    if (fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}


//
// ======================== DocStoreLocator Class Factory ==================
//

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::CStorageDocStoreLocatorObjectCF
//
//  Synopsis:   Storage Filter Object class factory constructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//+-------------------------------------------------------------------------

CStorageDocStoreLocatorObjectCF::CStorageDocStoreLocatorObjectCF()
    : _RefCount( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::~CStorageDocStoreLocatorObjectCF
//
//  Synopsis:   Storage Filter Object class factory destructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

CStorageDocStoreLocatorObjectCF::~CStorageDocStoreLocatorObjectCF()
{
    Win4Assert( _RefCount == 0);
    Win4Assert( gulcInstances != 0 );

    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStorageDocStoreLocatorObjectCF::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStorageDocStoreLocatorObjectCF::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;

}   //  Release

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageDocStoreLocatorObjectCF::QueryInterface(
    REFIID riid,
    PVOID* ppvObject )
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IClassFactory == riid)
        *ppvObject = (PVOID) ((IClassFactory *) this );
    else if ( IID_IUnknown == riid )
        *ppvObject = (PVOID) ((IUnknown *) this );
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::CreateInstance
//
//  Synopsis:   Create new CStorageFilterObject instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageDocStoreLocatorObjectCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    PVOID * ppvObject )
{
    CClientDocStoreLocator * pObject = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        //
        //  Create the new object
        //

        pObject = new CClientDocStoreLocator;

        //
        //  Obtain the new interface
        //

        sc = pObject->QueryInterface( riid , ppvObject );

        //
        //  Regardless of whether the QueryInterface succeeded, we
        //  release the object.
        //

        pObject->Release();
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pObject );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStorageDocStoreLocatorObjectCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CStorageDocStoreLocatorObjectCF::LockServer( BOOL fLock )
{
    if (fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\dll\vrtenum.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       vrootenm.cxx
//
//  Contents:   Virtual roots enumerator
//
//  History:    12-Dec-96     SitaramR      Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vrtenum.hxx>
#include <catalog.hxx>
#include <smatch.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::CVRootEnum, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cat]              -- Catalog
//              [pQueryPropMapper] -- Pid Remapper associated with the query
//              [secCache]         -- Cache of AccessCheck() results
//              [fUsePathAlias]  -- TRUE if client is going through rdr/svr
//
//  History:    19-Aug-93  KyleP    Created
//
//--------------------------------------------------------------------------

CVRootEnum::CVRootEnum( PCatalog & cat,
                        ICiQueryPropertyMapper *pQueryPropMapper,
                        CSecurityCache & secCache,
                        BOOL fUsePathAlias )
        : CGenericPropRetriever( cat,
                                 pQueryPropMapper,
                                 secCache,
                                 0,          // Always return local roots.  No fixups.
                                 FALSE ),    // No per-root security check
          _iBmk( 0 )
{
    //
    // You must be an admin to use this cursor, since per-object
    // security checkin is turned off.  This function throws.
    //

    VerifyThreadHasAdminPrivilege();

    _Path.Buffer = (WCHAR*)_lcaseFunnyPath.GetActualPath(); // points to actual path
    _VPath.Buffer = _xwcsVPath.Get();

    //
    // No filename for roots.
    //

    _Name.Buffer = 0;
    _Name.Length = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::~CVRootEnum, public
//
//  Synopsis:   Clean up context index cursor
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

CVRootEnum::~CVRootEnum()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::NextObject, public
//
//  Synopsis:   Move to next object
//
//  Returns:    Work id of next valid object, or widInvalid if end of
//              iteration.
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

WORKID CVRootEnum::NextObject()
{
    PurgeCachedInfo();

    WORKID wid;
    unsigned ccVPath = 0;
    unsigned ccPPath = 0;

    _Type = _cat.EnumerateVRoot( _xwcsVPath, // Full virtual root
                                 ccVPath,    //   + max length / return length
                                 _lcaseFunnyPath, // Full physical root
                                 ccPPath,    //   + max length / return length
                                 _iBmk );    // Bookmark
    if ( _Type != PCatalog::EndRoot )
    {
        _VPath.Length = (USHORT)(ccVPath * sizeof(WCHAR));
        _VPath.Buffer = _xwcsVPath.Get();            // buffer might have reallocated
        _Path.Length  = (USHORT)((_lcaseFunnyPath.GetActualLength()) * sizeof(WCHAR));
        _Path.Buffer  = (WCHAR*)_lcaseFunnyPath.GetActualPath();  // buffer might have reallocated

        wid = _cat.PathToWorkId( _lcaseFunnyPath, TRUE );
    }
    else
        wid = widInvalid;

    return( wid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::GetPath, public
//
//  Returns:    A path to file
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CVRootEnum::GetPath()
{
    return &_Path;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::GetVirtualPath, public
//
//  Returns:    A virtual path to file, or 0 if none exists.
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

UNICODE_STRING const * CVRootEnum::GetVirtualPath()
{
    return &_VPath;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::GetShortName, public
//
//  Returns:    Shortname of physical path
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline UNICODE_STRING const * CVRootEnum::GetShortName()
{
    if ( !_fFindLoaded )
        Refresh( FALSE );

    _ShortName.Length = (USHORT)wcslen( _finddata.cAlternateFileName );

    if ( _ShortName.Length == 0 )
        return &_Name;

    _ShortName.MaximumLength = _ShortName.Length;
    _ShortName.Buffer = &_finddata.cAlternateFileName[0];

    return( &_ShortName );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::CreateTime, public
//
//  Returns:    Create time of physical path
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline LONGLONG CVRootEnum::CreateTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsCreate) )
    {
        //
        // Try property store?
        //

        if ( 0 == (_fFastStatNeverLoad & fsCreate) )
        {
            PROPVARIANT var;
            unsigned cb = sizeof(var);

            if ( FetchValue( pidCreateTime, &var, &cb ) )
            {
                _finddata.ftCreationTime.dwLowDateTime = var.hVal.LowPart;
                _finddata.ftCreationTime.dwHighDateTime = var.hVal.HighPart;
            }
            else
            {
                _fFastStatNeverLoad |= fsCreate;
                Refresh( TRUE );
            }
        }
        else
        {
            Win4Assert( !_fFastFindLoaded );
            Refresh( TRUE );
        }
    }

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftCreationTime.dwLowDateTime;
    li.HighPart = _finddata.ftCreationTime.dwHighDateTime;

    return( litoll(li) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::ModifyTime, public
//
//  Returns:    Last write time of physical path
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline LONGLONG CVRootEnum::ModifyTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsModify) )
    {
        //
        // Try property store?
        //

        if ( 0 == (_fFastStatNeverLoad & fsModify) )
        {
            PROPVARIANT var;
            unsigned cb = sizeof(var);

            if ( FetchValue( pidWriteTime, &var, &cb ) )
            {
                _finddata.ftLastWriteTime.dwLowDateTime = var.hVal.LowPart;
                _finddata.ftLastWriteTime.dwHighDateTime = var.hVal.HighPart;
            }
            else
            {
                _fFastStatNeverLoad |= fsModify;
                Refresh( TRUE );
            }
        }
        else
        {
            Win4Assert( !_fFastFindLoaded );
            Refresh( TRUE );
        }
    }

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftLastWriteTime.dwLowDateTime;
    li.HighPart = _finddata.ftLastWriteTime.dwHighDateTime;

    return( litoll(li) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::AccessTime, public
//
//  Returns:    Last access time of physical path
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline LONGLONG CVRootEnum::AccessTime()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsAccess) )
    {
        //
        // Try property store?
        //

        if ( 0 == (_fFastStatNeverLoad & fsAccess) )
        {
            PROPVARIANT var;
            unsigned cb = sizeof(var);

            if ( FetchValue( pidAccessTime, &var, &cb ) )
            {
                _finddata.ftLastAccessTime.dwLowDateTime = var.hVal.LowPart;
                _finddata.ftLastAccessTime.dwHighDateTime = var.hVal.HighPart;
            }
            else
            {
                _fFastStatNeverLoad |= fsAccess;
                Refresh( TRUE );
            }
        }
        else
        {
            Win4Assert( !_fFastFindLoaded );
            Refresh( TRUE );
        }
    }

    LARGE_INTEGER li;
    li.LowPart = _finddata.ftLastAccessTime.dwLowDateTime;
    li.HighPart = _finddata.ftLastAccessTime.dwHighDateTime;

    return( litoll(li) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::AccessTime, public
//
//  Returns:    Zero, which is always size of directory.
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline LONGLONG CVRootEnum::ObjectSize()
{
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::Attributes, public
//
//  Returns:    File attributes for physical root.
//
//  History:    07-Feb-96   KyleP       Added header
//
//----------------------------------------------------------------------------

inline ULONG CVRootEnum::Attributes()
{
    //
    // First, should we try a fast path?
    //

    if ( 0 == (_fFastStatLoaded & fsAttrib) )
    {
        //
        // Try property store?
        //

        if ( 0 == (_fFastStatNeverLoad & fsAttrib) )
        {
            PROPVARIANT var;
            unsigned cb = sizeof(var);

            if ( FetchValue( pidAttrib, &var, &cb ) )
            {
                _finddata.dwFileAttributes = var.ulVal;
            }
            else
            {
                _fFastStatNeverLoad |= fsAttrib;
                Refresh( TRUE );
            }
        }
        else
        {
            Win4Assert( !_fFastFindLoaded );
            Refresh( TRUE );
        }
    }

    return( _finddata.dwFileAttributes );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::GetVRootType, public
//
//  Returns:    Stat info for virtual root
//
//  History:    11-Apr-96   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CVRootEnum::GetVRootType( ULONG & ulType )
{
    ulType = _Type;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::Refresh, private
//
//  Synopsis:   Load stat properties for current object
//
//  Arguments:  [fFast] -- If TRUE, make fast call and don't load alternate
//                         file name.
//
//  Returns:    TRUE if load successful
//
//  History:    19-Aug-93 KyleP     Created
//              29-Feb-96 KyleP     Added GetFileAttributesEx support
//
//--------------------------------------------------------------------------

BOOL CVRootEnum::Refresh( BOOL fFast )
{
    if ( CImpersonateRemoteAccess::IsNetPath(_Path.Buffer) )
    {

        WCHAR const * pwszVPath = _VPath.Buffer;

        _remoteAccess.ImpersonateIf( _Path.Buffer,
                                     pwszVPath );
    }
    else if ( _remoteAccess.IsImpersonated() )
    {
        _remoteAccess.Release();
    }

    if ( fFast )
    {
        if ( !GetFileAttributesEx( _lcaseFunnyPath.GetPath(), GetFileExInfoStandard, &_finddata ) )
        {
            vqDebugOut(( DEB_ERROR, "Can't retrieve fast findfirst data for %ws.  Error = %d\n",
                         _lcaseFunnyPath.GetActualPath(), GetLastError() ));
            return FALSE;
        }

        _fFastFindLoaded = TRUE;
        _fFastStatLoaded = fsCreate | fsModify | fsAccess | fsSize | fsAttrib;

    }
    else
    {
        HANDLE h = FindFirstFile( _lcaseFunnyPath.GetPath(), &_finddata );

        if ( INVALID_HANDLE_VALUE == h )
        {
            vqDebugOut(( DEB_ERROR, "Can't retrieve findfirst data for %ws\n",
                         _lcaseFunnyPath.GetActualPath() ));
            return FALSE;
        }
        else
        {
            FindClose( h );
            _fFindLoaded = TRUE;
            _fFastFindLoaded = TRUE;
            _fFastStatLoaded = fsCreate | fsModify | fsAccess | fsSize | fsAttrib;
        }
    }

    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::BeginPropertyRetrieval
//
//  Synopsis:   Prime wid for property retrieval
//
//  Arguments:  [wid]    -- Wid to prime
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::BeginPropertyRetrieval( WORKID wid )
{
    //
    // Check that we are retrieving the property for the wid on
    // which we are currently positioned
    //
    Win4Assert( wid == _widCurrent );
    Win4Assert( _widPrimedForPropRetrieval == widInvalid );

    if ( wid == _widCurrent )
    {
        _widPrimedForPropRetrieval = _widCurrent;
        return S_OK;
    }
    else
        return E_FAIL;
}




//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::EndPropertyRetrieval
//
//  Synopsis:   Reset wid for property retrieval
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::EndPropertyRetrieval( )
{
    PurgeCachedInfo();

    SCODE sc = CGenericPropRetriever::EndPropertyRetrieval();

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::IsInScope
//
//  Synopsis:   Checks if current wid is in scope
//
//  Arguments:  [pfInScope]   -- Scope check result returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::IsInScope( BOOL *pfInScope )
{
    if ( widInvalid == _widPrimedForPropRetrieval )
        return CI_E_WORKID_NOTVALID;

    *pfInScope = TRUE;

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::Begin
//
//  Synopsis:   Begins an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::Begin()
{
    SCODE sc = S_OK;

    TRY
    {
        _iBmk = 0;
        _fFindLoaded = FALSE;
        _fFastFindLoaded = FALSE;
        _fFastStatLoaded = 0;
        _fFastStatNeverLoad = 0;

        _Path.Length = 0xFFFF;
        _VPath.Length = 0xFFFF;

        _widCurrent = NextObject();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CVRootEnum::Begin - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::CurrentDocument
//
//  Synopsis:   Returns current document
//
//  Arguments:  [pWorkId]  -- Wid of current doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::CurrentDocument( WORKID *pWorkId )
{
    *pWorkId = _widCurrent;
    if ( _widCurrent == widInvalid )
        return CI_S_END_OF_ENUMERATION;
    else
        return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::NextDocument
//
//  Synopsis:   Returns next document
//
//  Arguments:  [pWorkId]  -- Wid of next doc returned here
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::NextDocument( WORKID *pWorkId )
{
    SCODE sc = S_OK;

    TRY
    {
        _widCurrent = NextObject();

        sc = CurrentDocument( pWorkId );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CVRootEnum::NextDocument - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CVRootEnum::End
//
//  Synopsis:   Ends an enumeration
//
//  History:    12-Dec-96     SitaramR       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::End()
{
    _widCurrent = widInvalid;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CVRootEnum::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    12-Dec-1996      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CVRootEnum::AddRef()
{
    return CGenericPropRetriever::AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CVRootEnum::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    12-Dec-1996     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CVRootEnum::Release()
{
    return CGenericPropRetriever::Release();
}



//+-------------------------------------------------------------------------
//
//  Method:     CVRootEnum::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    12-Dec-1996     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::QueryInterface(
    REFIID riid,
    void  ** ppvObject)
{
    if ( IID_ICiCPropRetriever == riid )
        *ppvObject = (ICiCPropRetriever *)this;
    else if ( IID_ICiCScopeEnumerator == riid )
        *ppvObject = (ICiCScopeEnumerator *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(ICiCScopeEnumerator *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}




//+---------------------------------------------------------------------------
//
//  Member:     CVRootEnum::RatioFinished, public
//
//  Synopsis:   Returns query progress estimate
//
//  Arguments:  [denom] -- Denominator returned here
//              [num]   -- Numerator returned here
//
//  History:    12-Dec-96   SitaramR      Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CVRootEnum::RatioFinished (ULONG *pDenom, ULONG *pNum)
{
    *pNum = 50;
    *pDenom = 100;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\cisavtst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cisavtst.cxx
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#if CIDBG==1

#include <cisavtst.hxx>
#include <cicat.hxx>

CCiSaveTest::CCiSaveTest( WCHAR const * pwszSaveDir,
                          ICiPersistIncrFile * pICiPersistFile,
                          CiCat & cicat )
: _cicat(cicat),
  _pICiPersistFile(pICiPersistFile),
#pragma warning( disable : 4355 )      // this used in base initialization
  _thrSave( SaveThread, this, TRUE )  // create suspended
#pragma warning( default : 4355 )
{


    unsigned cwc = wcslen( pwszSaveDir ) + 1;
    _xwszSaveDir.Init( cwc );
    RtlCopyMemory( _xwszSaveDir.GetPointer(), pwszSaveDir, cwc * sizeof WCHAR );

    _pICiPersistFile->AddRef();

    _fAbort = FALSE;
    _evt.Reset();
    _thrSave.Resume();

    END_CONSTRUCTION( CCiSaveTest );
}

DWORD WINAPI CCiSaveTest::SaveThread( void * self )
{
   ciDebugOut(( DEB_ERROR, "Starting Save Thread\n" ));

   ((CCiSaveTest *) self)->DoIt();

   ciDebugOut(( DEB_ERROR, "Leaving Save Thread\n" ));

   return 0;
}


void CCiSaveTest::DoIt()
{
    TRY
    {
        DWORD dwWaitTime = 1 * 60 * 1000;   // 1 minute

        _evt.Wait( dwWaitTime );  // 1 minute
        _evt.Reset();

        dwWaitTime = 30 * 60 * 1000; // 30 minutes in milli seconds
        ULONG iCount = 1;

        while ( !_fAbort )
        {
            BOOL fFull = (iCount % 10) == 9;
            iCount++;


            ICiEnumWorkids * pICiEnumWorkids = 0;
            IEnumString * pIEnumString = 0;
            BOOL fCallerOwnsFiles;

            #if 1
            SCODE sc = _pICiPersistFile->Save(
                            _xwszSaveDir.GetPointer(),
                            fFull,
                            0,          // No progress notify
                            &_fAbort,
                            &pICiEnumWorkids,
                            &pIEnumString,
                            &fFull,
                            &fCallerOwnsFiles );
            #else
            SCODE sc = S_OK;
            #endif  // 0

            XInterface<ICiEnumWorkids> xEnumWorkids;
            XInterface<IEnumString> xEnumString;

            if ( SUCCEEDED(sc) )
            {

                xEnumWorkids.Set( pICiEnumWorkids );
                xEnumString.Set( pIEnumString );

                _cicat.MakeBackupOfPropStore( _xwszSaveDir.GetPointer(),
                                              0,    // IProgressNotify
                                              _fAbort,
                                              fFull ? 0 : pICiEnumWorkids );

                ciDebugOut(( DEB_ERROR, "%s Backup of CiData succeeded\n",
                             fFull ? "Full" : "Incremental" ));

                WCHAR *  pwszFileName;
                ULONG    cElements;

                xEnumString->Reset();
                while ( S_OK == xEnumString->Next( 1, &pwszFileName, &cElements ) )
                {
                    ciDebugOut(( DEB_ERROR, "File: (%ws) \n", pwszFileName ));        
                }
            }
            else
            {
                ciDebugOut(( DEB_ERROR, "%s Backup of CiData failed. Error 0x%X \n",
                             fFull ? "Full" : "Incremental", sc ));
            }

            if ( !_fAbort )
            {
                _evt.Wait( dwWaitTime );
                _evt.Reset();                                
            }
        }            
    }
    CATCH( CException , e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Error in Save Thread. 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    _pICiPersistFile->Release();
    ciDebugOut(( DEB_ERROR, "End of Save Thread\n" ));

}



#endif  // CIDBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\docname.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       docname.cxx
//
//  Contents:   Storage Client for document
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <docname.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::CCiCDocName
//
//  Synopsis:   Constructor which takes a path
//
//  Arguments:  [pwszPath] - Pointer to a NULL terminated path.
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

CCiCDocName::CCiCDocName( WCHAR const * pwszPath )
:_pwszPath(_wszBuffer),
 _refCount(1),
 _fIsInit(FALSE),
 _cwcMax(MAX_PATH-1),
 _cwcPath(0)
{
    if ( pwszPath )
    {
        ULONG cwc = wcslen( pwszPath );
        SetPath( pwszPath, cwc );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::CCiCDocName
//
//  Synopsis:   Constructor which takes a path and length
//
//  Arguments:  [pwszPath] - Pointer to a NULL terminated path.
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------
CCiCDocName::CCiCDocName( WCHAR const * pwszPath, ULONG cwc )
:_pwszPath(_wszBuffer),
 _refCount(1),
 _fIsInit(FALSE),
 _cwcMax(MAX_PATH-1),
 _cwcPath(0)
{
    if ( pwszPath )
        SetPath( pwszPath, cwc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::SetPath
//
//  Synopsis:   Stores the given path
//
//  Arguments:  [pwszPath] - Pointer to the path
//              [cwc]      - Number of characters in the path.
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiCDocName::SetPath( WCHAR const * pwszPath, ULONG cwc )
{
    if ( cwc && 0 != pwszPath )
    {
        if ( cwc > _cwcMax )
        {
            FreeResources();
            ULONG cwcMax = cwc + CWC_DELTA;

            _pwszPath = new WCHAR [cwcMax+1];
            _cwcMax = cwcMax;
        }

        RtlCopyMemory( _pwszPath, pwszPath, cwc*sizeof(WCHAR) );
        _cwcPath = cwc;
    }
    else
    {
        _cwcPath = 0;
    }

    _pwszPath[_cwcPath] = 0;

    _fIsInit = TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown and IID_ICiCDocName
//
//  Arguments:  [riid]      -
//              [ppvObject] -
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCDocName::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );
    *ppvObject = 0;

    if ( IID_ICiCDocName == riid )
        *ppvObject = (void *)((ICiCDocName *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiCDocName::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiCDocName::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release


//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Init
//
//  Synopsis:   Intiailizes with the given name data. The name must be a
//              serialized form of a WIDE-CHAR string. It MUST be a
//              NULL terminated string.
//
//  Arguments:  [pbData] - Pointer to the path.
//              [cbData] - Number of valid bytes, including the NULL
//              termination.
//
//  Returns:
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCDocName::Init(
    const BYTE * pbData,
    ULONG cbData )
{
    //
    // The number of bytes must be even.
    //
    Win4Assert( (cbData & 0x1) == 0 );

    if ( 0 != cbData%sizeof(WCHAR) )
        return E_INVALIDARG;

    if ( _fIsInit )
        return CI_E_ALREADY_INITIALIZED;

    WCHAR const * pwszPath = (WCHAR const *) pbData;
    ULONG cwc = cbData/sizeof(WCHAR);

    //
    // The data must be NULL terminated.
    //
    if ( cwc > 0 && 0 != pwszPath[cwc-1] )
        return E_INVALIDARG;

    SetPath( pwszPath, cwc-1 );

    return S_OK;
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Set
//
//  Synopsis:   Initializes this object with the given document name.
//
//  Arguments:  [pICiCDocName] - Pointer to the source document name.
//
//  Returns:
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCDocName::Set(
    const ICiCDocName * pICiCDocName )
{
    const CCiCDocName * pRhs = (CCiCDocName *) pICiCDocName;

    if ( !pRhs )
        return E_INVALIDARG;

    if ( _fIsInit )
        return CI_E_ALREADY_INITIALIZED;

    if ( pRhs->_fIsInit )
        SetPath( pRhs->_pwszPath, pRhs->_cwcPath );
    else
        _fIsInit = FALSE;

    return S_OK;

} //Set

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Clear
//
//  Synopsis:   Clears the data. The document name is "invalid" after this.
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::Clear()
{
    if ( !_fIsInit )
        return CI_E_NOT_INITIALIZED;

    _cwcPath = 0;
    _fIsInit = FALSE;

    return S_OK;
} //Clear

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::IsValid
//
//  Synopsis:   Tests if the document name is properly initialized or not.
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::IsValid(void)
{
    if ( _fIsInit )
        return S_OK;
    else return CI_E_NOT_INITIALIZED;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Duplicate
//
//  Synopsis:   Makes a duplicate copy of the data in this object.
//
//  Arguments:  [ppICiCDocName] -
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::Duplicate(
    ICiCDocName ** ppICiCDocName )
{
    if ( 0 == ppICiCDocName )
        return E_INVALIDARG;

    CCiCDocName * pRhs = 0;
    SCODE sc = S_OK;

    TRY
    {
        if ( _fIsInit )
            pRhs = new CCiCDocName( _pwszPath, _cwcPath );
        else
            pRhs = new CCiCDocName();
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    *ppICiCDocName = pRhs;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::GetBufSizeNeeded
//
//  Synopsis:
//
//  Arguments:  [pcbName] -
//
//  Returns:
//
//  Modifies:
//
//  History:    11-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::GetBufSizeNeeded(
    ULONG * pcbName )
{
    if ( !_fIsInit )
        return CI_E_NOT_INITIALIZED;

    Win4Assert( pcbName );

    *pcbName = ComputeBufSize();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Get
//
//  Synopsis:   Serializes the name into the buffers provided.
//
//  Arguments:  [pbName]  - Pointer to the buffer to copy.
//              [pcbName] - [in/out] In - Max Bytes to Copy
//                          [out] - Bytes copied or to be copied.
//
//  Returns:    S_OK if successful;
//              CI_E_BUFFERTOOSMALL if the buffer is not big enough.
//
//  History:    11-26-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::Get(
    BYTE  * pbName,
    ULONG * pcbName )
{
    Win4Assert( pcbName );

    if ( !_fIsInit )
        return CI_E_NOT_INITIALIZED;

    ULONG cbToCopy = ComputeBufSize();

    if ( *pcbName < cbToCopy )
    {
        *pcbName = cbToCopy;
        return CI_E_BUFFERTOOSMALL;
    }

    RtlCopyMemory( pbName, _pwszPath, cbToCopy );
    *pcbName = cbToCopy;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::GetNameBuffer
//
//  Synopsis:   Returns the internal buffer containing the name.
//
//  Arguments:  [ppbName] - On output, will point to the name buffer
//              [pcbName] - Number of valid bytes in the buffer
//
//  Returns:    S_OK if successful;
//              CI_E_NOT_INITIALIZED if not initialized.
//
//  History:    1-21-97   srikants   Created
//
//  Notes:      The buffer should not be written by the caller.
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCDocName::GetNameBuffer(
    BYTE  const * * ppbName,
    ULONG * pcbName )
{
    Win4Assert( pcbName );
    Win4Assert( ppbName );

    if ( !_fIsInit )
        return CI_E_NOT_INITIALIZED;

    *ppbName = (BYTE *) _pwszPath;
    *pcbName = ComputeBufSize();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\dmnstart.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dmnstart.cxx
//
//  Contents:   A class for providing startup data to the CiDaemon.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <frmutils.hxx>
#include <sizeser.hxx>
#include <memser.hxx>
#include <memdeser.hxx>
#include <dmnstart.hxx>
#include <imprsnat.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonStartupData::CDaemonStartupData
//
//  Synopsis:   Constructor on the sending side
//
//  Arguments:  [fIndexingW3Svc]  - Set to TRUE if W3Svc data is being
//              indexed.
//              [ipVirtualServer] - IP address of the virtual server.
//              [pwszCatDir]      - Catalog directory
//              [pwszName]        - Catalog name
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

CDaemonStartupData::CDaemonStartupData(
    WCHAR const * pwszCatDir,
    WCHAR const * pwszName )
:_sigDaemonStartup(eSigDaemonStartup),
 _fValid(TRUE)
{
    _xwszCatDir.Set( AllocHeapAndCopy( pwszCatDir ) );
    _xwszName.Set( AllocHeapAndCopy( pwszName ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonStartupData::CDaemonStartupData
//
//  Synopsis:   Constructor to be used on the receiving side.
//
//  Arguments:  [pbData] - Pointer to the data buffer.
//              [cbData] - Number of bytes in the data buffer.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

CDaemonStartupData::CDaemonStartupData( BYTE const * pbData, ULONG cbData )
:_fValid(FALSE)
{
    // Copy the buffer to guarantee alignment

    XArray<BYTE> xByte(cbData);
    RtlCopyMemory( xByte.GetPointer(), pbData, cbData );

    CMemDeSerStream stm( xByte.GetPointer(), cbData );
    _DeSerialize( stm );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonStartupData::_Serialize
//
//  Synopsis:   Serializes the data into the provided serializer
//
//  Arguments:  [stm] - The stream to serailize into.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonStartupData::_Serialize( PSerStream & stm ) const
{
    PutWString( stm, GetCatDir() );
    PutWString( stm, GetName() );

    ULARGE_INTEGER * pLi = (ULARGE_INTEGER *) &_sigDaemonStartup;

    stm.PutULong( pLi->LowPart );
    stm.PutULong( pLi->HighPart );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonStartupData::_DeSerialize
//
//  Synopsis:   Deserializes the data from the given de-serializer
//
//  Arguments:  [stm] - The stream to deserialize from.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonStartupData::_DeSerialize( PDeSerStream & stm )
{
    _xwszCatDir.Set( AllocHeapAndGetWString( stm ) );
    _xwszName.Set( AllocHeapAndGetWString( stm ) );

    ULARGE_INTEGER * pLi = (ULARGE_INTEGER *) &_sigDaemonStartup;

    pLi->LowPart = stm.GetULong();
    pLi->HighPart = stm.GetULong();

    _fValid =  eSigDaemonStartup == _sigDaemonStartup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonStartupData::Serialize
//
//  Synopsis:   Serializes the data into a buffer and returns the pointer
//              to the buffer. The memory is allocated using HEAP.
//
//  Arguments:  [cb] - on output, will have the number of bytes in the
//              serialized buffer.
//
//  Returns:    Pointer to a memory buffer. The caller owns it.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

BYTE * CDaemonStartupData::Serialize( ULONG & cb ) const
{
    cb = 0;
    Win4Assert( _fValid );

    //
    // First determine the size of the buffer needed.
    //
    CSizeSerStream  sizeSer;
    _Serialize( sizeSer );

    cb = sizeSer.Size();

    XArray<BYTE> xBuffer(cb);

    CMemSerStream memSer( xBuffer.GetPointer(), cb );
    _Serialize( memSer );

    return xBuffer.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiRegistryEvent::DoIt
//
//  Synopsis:   Refreshes the CI registry values.
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiRegistryEvent::DoIt(ICiAdminParams * pICiAdminParams)
{

    ciDebugOut(( DEB_ITRACE, "CiDaemon::Processing CI registry change\n" ));

    _regParams.Refresh(pICiAdminParams);

    //
    // It's ok for the QI to fail.  Don't always have a language cache.
    //

    XInterface<ICiAdmin> xICiAdmin;

    SCODE sc = pICiAdminParams->QueryInterface( IID_ICiAdmin, xICiAdmin.GetQIPointer() );

    Win4Assert( SUCCEEDED(sc) );

    if ( SUCCEEDED(sc) )
        xICiAdmin->InvalidateLangResources();

    //
    // Re-enable the notifications.
    //

    Reset();
} //DoIt()

//+---------------------------------------------------------------------------
//
//  Member:     CClientDaemonWorker::CClientDaemonWorker
//
//  Synopsis:   Constructor of the CClientDaemonWorker class.
//
//  Arguments:  [startupData]      - start data for the daemon worker
//              [nameGen]          - name generator for inter-proc events
//              [pICiAdminParams]  - registry/admin parameters
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

CClientDaemonWorker::CClientDaemonWorker( CDaemonStartupData & startupData,
                                          CSharedNameGen &     nameGen,
                                          ICiAdminParams     * pICiAdminParams )
: _cHandles(cTotal),
  _fShutdown(FALSE),
  _perfMon( startupData.GetName() ? startupData.GetName() : startupData.GetCatDir() ),
  _regParams( startupData.GetName() ),
  _tokenCache( startupData.GetName() ),
  _ciRegChange( _regParams ),
  _evtRescanTC( 0, nameGen.GetRescanTCEventName() ),
#pragma warning( disable : 4355 )           // this used in base initialization
  _controlThread( WorkerThread, this, TRUE )  // create suspended
#pragma warning( default : 4355 )

{
    pICiAdminParams->AddRef();
    _xICiAdminParams.Set(pICiAdminParams);

    _regParams.Refresh( pICiAdminParams );

    BOOL fIndexW3Roots = _regParams.IsIndexingW3Roots();
    BOOL fIndexNNTPRoots = _regParams.IsIndexingNNTPRoots();
    BOOL fIndexIMAPRoots = _regParams.IsIndexingIMAPRoots();
    ULONG W3SvcInstance = _regParams.GetW3SvcInstance();
    ULONG NNTPSvcInstance = _regParams.GetNNTPSvcInstance();
    ULONG IMAPSvcInstance = _regParams.GetIMAPSvcInstance();

    _tokenCache.Initialize( CI_DAEMON_NAME,
                            fIndexW3Roots,
                            fIndexNNTPRoots,
                            fIndexIMAPRoots,
                            W3SvcInstance,
                            NNTPSvcInstance,
                            IMAPSvcInstance );

    RtlZeroMemory( _aWait, sizeof(_aWait) );

    _aWait[iThreadControl] = _evtControl.GetHandle();
    _evtControl.Reset();

    _aWait[iCiRegistry] = _ciRegChange.GetEventHandle();

    _aWait[iRescanTC] = _evtRescanTC.GetHandle();

    _controlThread.Resume();
} //CClientDaemonWorker

//+---------------------------------------------------------------------------
//
//  Member:     CClientDaemonWorker::WorkerThread
//
//  Synopsis:   WIN32 Thread starting entry point.
//
//  Arguments:  [self] -
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD CClientDaemonWorker::WorkerThread( void * self )
{
    ((CClientDaemonWorker *) self)->_DoWork();

    ciDebugOut(( DEB_ITRACE, "CClientDaemonWorker::Terminating thread\n" ));
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDaemonWorker::_DoWork
//
//  Synopsis:   The main loop where the thread waits and tracks the registry
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CClientDaemonWorker::_DoWork()
{
    ciDebugOut(( DEB_ITRACE, "CClientDaemonWorker::_DoWork \n" ));

    do
    {
        DWORD status = WaitForMultipleObjectsEx( _cHandles, // num handles
                                                 _aWait,    // array of handles
                                                 FALSE,     // wake up if any is set
                                                 10000,     // Timeout
                                                 FALSE );   // Not Alertable

        TRY
        {
            if ( WAIT_FAILED == status )
            {
                ciDebugOut(( DEB_ERROR, "DLDaemon - WaitFailed. Error 0x%X\n",
                             GetLastError() ));
                _fShutdown = TRUE;
            }
            else if ( WAIT_TIMEOUT == status )
            {
                // See if a filter is out of control allocating memory.  We
                // may be using gobs of RAM, but we only care about page
                // file usage.

                VM_COUNTERS vmInfo;
                NTSTATUS s = NtQueryInformationProcess( GetCurrentProcess(),
                                                        ProcessVmCounters,
                                                        &vmInfo,
                                                        sizeof vmInfo,
                                                        0 );

                SIZE_T cbUsageInK = vmInfo.PagefileUsage / 1024;
                SIZE_T cbMaxInK = _regParams.GetMaxDaemonVmUse();

                if ( NT_SUCCESS( s ) && ( cbUsageInK > cbMaxInK ) )
                    TerminateProcess( GetCurrentProcess(), E_OUTOFMEMORY );
            }
            else
            {
                DWORD iWake = status - WAIT_OBJECT_0;

                if ( iThreadControl == iWake )
                {
                    ciDebugOut(( DEB_ITRACE, "DaemonWorkerThread - Control Event\n" ));
                    _evtControl.Reset();
                }
                else if ( iCiRegistry == iWake )
                {
                    ResetEvent( _aWait[iCiRegistry] );
                    _ciRegChange.DoIt( _xICiAdminParams.GetPointer() );
                }
                else
                {
                    ciDebugOut(( DEB_ITRACE, "daemon rescanning tokenCache\n" ));
                    Win4Assert( iRescanTC == iWake );
                    ResetEvent( _aWait[iRescanTC] );
                    _tokenCache.ReInitializeIISScopes();
                    _tokenCache.ReInitializeScopes();
                }
            }
        }
        CATCH( CException,e )
        {
            ciDebugOut(( DEB_ERROR, "Error 0x%X caught in daemon worker thread\n",
                         e.GetErrorCode() ));
        }
        END_CATCH
    }
    while ( !_fShutdown );
} //_DoWork
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\docstore.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       docstore.cxx
//
//  Contents:   Deals with the client side document store implementation.
//
//  Classes:    CClientDocStore
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

// for definition of CRequestQueue
#include <query.hxx>
#include <srequest.hxx>
#include <regacc.hxx>

#include <docstore.hxx>
#include <docname.hxx>
#include <qsession.hxx>
#include <cicat.hxx>
#include <cinulcat.hxx>
#include <seccache.hxx>
#include <dmnstart.hxx>
#include <propmap.hxx>
#include <notifyev.hxx>
#include <catalog.hxx>
#include <catarray.hxx>
#include <glbconst.hxx>
#include <cisvcex.hxx>
#include <cisvcfrm.hxx>
#include <cistore.hxx>
#include <enumstr.hxx>
#include <filterob.hxx>
#include <catadmin.hxx>

#include <fsci.hxx>

extern CCatArray Catalogs;

CRequestQueue * g_pFSCIRequestQueue = 0;

extern "C" const GUID clsidStorageFilterObject =
    { 0xaa205a4d, 0x681f, 0x11d0, { 0xa2, 0x43, 0x8, 0x0, 0x2b, 0x36, 0xfc, 0xa4 } };

extern "C" const GUID guidStorageDocStoreLocatorObject;

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown
//              IID_ICiCDocStore
//              IID_ICiCDocStoreEx
//              IID_ICiCPropertyStorage
//              IID_ICiCDocNameToWorkidTranslator
//              IID_ICiCDocNameToWorkidTranslatorEx
//              IID_ICiCAdviseStatus
//              IID_IFsCiAdmin
//              IID_ICiCLangRes
//
//  History:    12-03-96   srikants   Created
//              2-14-97    mohamedn   ICiCLangRes
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::QueryInterface( REFIID riid, void **ppvObject )
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiCDocStore == riid )
        *ppvObject = (void *)((ICiCDocStore *)this);
    else if ( IID_ICiCPropertyStorage == riid )
        *ppvObject = (void *)((ICiCPropertyStorage *)this);
    else if ( IID_ICiCDocNameToWorkidTranslator == riid )
        *ppvObject = (void *)((ICiCDocNameToWorkidTranslator *)this);
    else if ( IID_ICiCDocNameToWorkidTranslatorEx == riid )
        *ppvObject = (void *)((ICiCDocNameToWorkidTranslatorEx *)this);
    else if ( IID_ICiCAdviseStatus == riid )
        *ppvObject = (void *)((ICiCAdviseStatus *)this);
    else if ( IID_IFsCiAdmin == riid )
        *ppvObject = (void *)((IFsCiAdmin *)this);
    else if ( IID_ICiCLangRes == riid )
        *ppvObject = (void *) ((ICiCLangRes *)this);
    else if ( IID_ICiCDocStoreEx == riid )
        *ppvObject = (void *)((IUnknown *) (ICiCDocStoreEx *)this);
    else if ( IID_ICiCResourceMonitor == riid )
        *ppvObject = (void *)((IUnknown *) (ICiCResourceMonitor *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiCDocStore *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::AddRef
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClientDocStore::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::Release
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClientDocStore::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if ( refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::CClientDocStore
//
//  Synopsis:   Constructor of the NULL CiCDocStore object.
//
//  Arguments:  None
//
//  History:    Jul-09-97   KrishnaN   Created
//              01-Nov-98   KLam       Need to instantiate a CDiskFreeStatus
//
//----------------------------------------------------------------------------

CClientDocStore::CClientDocStore()
: _sigClientDocStore(eSigClientDocStore),
  _refCount(1),
  _fNoQuery( FALSE ),
  _state(eUpdatesDisabled),
  _pCiCat(0),
  _pCiNullCat(0)
{
    // Create the CiNullCat object.
    _pCiNullCat = new CiNullCat( *this );
    XPtr<CiNullCat> xCat( _pCiNullCat );

    // Map std props only (second param)
    _xPropMapper.Set( new CFwPropertyMapper( _pCiNullCat->GetPidLookupTable(), TRUE ) );

    // Create CI Manager object.
    _CreateCiManager();

    _pCiNullCat->StartupCiFrameWork( _xCiManager.GetPointer() );

    //
    // Startup content index.
    //
    ICiStartup * pCiStartup;
    SCODE sc = _xCiManager->QueryInterface( IID_ICiStartup, (void **) &pCiStartup );
    XInterface<ICiStartup> xStartup( pCiStartup );
    if ( S_OK != sc )
    {
        THROW( CException(sc) );
    }

    CI_STARTUP_INFO startupInfo;
    RtlZeroMemory( &startupInfo, sizeof(startupInfo) );

    startupInfo.clsidDaemonClientMgr = clsidStorageFilterObject;
    startupInfo.startupFlags = CI_CONFIG_ENABLE_QUERYING ;

    BOOL fAbort = FALSE;

    sc = pCiStartup->StartupNullContentIndex( &startupInfo,0, &fAbort );

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    xCat->SetAdviseStatus();
    xCat.Acquire();    
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::CClientDocStore
//
//  Synopsis:   Constructor of the CiCDocStore object.
//
//  Arguments:  [pwszPath] - Path of the directory where the files must be
//              created.
//              [pwszName] - Name of the Content Index.
//
//  History:    12-03-96   srikants   Created
//              02-17-98   kitmanh    Added code to deal with read-only
//                                    catalogs (the readOnly flag is
//                                    passed down from CiCat to startupInfo)
//              07-Jan-99  klam       Logged and event that initialization failed
//
//----------------------------------------------------------------------------

CClientDocStore::CClientDocStore( WCHAR const * pwszPath,
                                  BOOL fOpenForReadOnly,
                                  CDrvNotifArray & DrvNotifArray,
                                  WCHAR const * pwszName )
: _sigClientDocStore(eSigClientDocStore),
  _refCount(1),
  _state(eUpdatesDisabled),
  _pCiCat(0),
  _pCiNullCat(0),
  _fNoQuery( FALSE ),
  _pDrvNotifArray( &DrvNotifArray )
{
    ciDebugOut(( DEB_ITRACE, "CClientDocStore::CClinetDocStore.. fOpenForReadOnly == %d\n", fOpenForReadOnly ));
    ciDebugOut(( DEB_ITRACE, "CClientDocStore::CClinetDocStore.. pwszPath == %ws\n", pwszPath ));
    ciDebugOut(( DEB_ITRACE, "CClientDocStore::CClinetDocStore.. pwszName == %ws\n", pwszName ));

    // Check if the catalog directory exists

    if ( ( wcslen( pwszPath ) + wcslen( CAT_DIR ) ) >= MAX_PATH )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    WCHAR awcCatDir[ MAX_PATH ];
    wcscpy( awcCatDir, pwszPath );
    wcscat( awcCatDir, CAT_DIR );

    WIN32_FILE_ATTRIBUTE_DATA fData;
    if ( GetFileAttributesEx( awcCatDir, GetFileExInfoStandard, &fData ) )
    {
        // Is the catalog path a file or a directory?

        if ( 0 == ( fData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            THROW( CException( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) );
    }
    else
    {
        //
        // You can get back both errors depending on what parts of the
        // directory tree currently exist.
        //

        if ( ( ERROR_FILE_NOT_FOUND == GetLastError() ) ||
             ( ERROR_PATH_NOT_FOUND == GetLastError() ) )
        {
            // create the catalog directory with proper acls

            CMachineAdmin admin;
            admin.CreateSubdirs( pwszPath );
        }
        else
            THROW( CException() );
    }

    BOOL fLeaveCorruptCatalog;
    {
        // By default, delete corrupt catalogs.

        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
        fLeaveCorruptCatalog = reg.Read( wcsLeaveCorruptCatalog, (ULONG) FALSE );
    }

    //
    // Create the CiCat object.
    //
    BOOL fVersionChange = FALSE;

    _pCiCat = new CiCat( *this,
                         _workMan,
                         pwszPath,
                         fVersionChange,
                         fOpenForReadOnly,
                         *_pDrvNotifArray,
                         pwszName,
                         fLeaveCorruptCatalog );

    XPtr<CiCat> xCat( _pCiCat );

    // Create a CDiskFreeStatus object
    _xDiskStatus.Set( new CDiskFreeStatus( pwszPath,
                                           xCat->GetRegParams()->GetMinDiskSpaceToLeave() ) );

    // Map std props AND others (second param set to false)
    _xPropMapper.Set( new CFwPropertyMapper( xCat->GetPidLookupTable(), FALSE ) );

    //
    // Create the perform counters object. This must be done before
    // starting up rest of the content index.
    //
    Win4Assert( 0 != xCat->GetCatalogName() );
    CPerfMon * pPerfMon = new CPerfMon( xCat->GetCatalogName() );

    _xPerfMon.Set( pPerfMon );

    //
    // Create CI Manager object.
    //
    _CreateCiManager();

    xCat->StartupCiFrameWork( _xCiManager.GetPointer() );

    //
    // Startup content index.
    //

    ICiStartup * pCiStartup;
    SCODE sc = _xCiManager->QueryInterface( IID_ICiStartup,
                                            (void **) &pCiStartup );
    XInterface<ICiStartup> xStartup( pCiStartup );
    if ( S_OK != sc )
        THROW( CException(sc) );

    BOOL fFullScanNeeded = FALSE;

    CI_STARTUP_INFO startupInfo;
    RtlZeroMemory( &startupInfo, sizeof(startupInfo) );

    startupInfo.clsidDaemonClientMgr = clsidStorageFilterObject;
    startupInfo.startupFlags = CI_CONFIG_ENABLE_INDEXING |
                               CI_CONFIG_ENABLE_QUERYING ;

    if ( xCat->IsReadOnly() )
        startupInfo.startupFlags |= CI_CONFIG_READONLY;

    if ( xCat->IsCiDataCorrupt() || xCat->IsFsCiDataCorrupt() || fVersionChange )
    {
        if ( fLeaveCorruptCatalog )
        {
            Win4Assert( !"leaving corrupt catalog" );
            THROW( CException( CI_CORRUPT_CATALOG ) );
        }

        if ( xCat->IsCiDataCorrupt() ||
             xCat->IsFsCiDataCorrupt() )
        {
            ciDebugOut(( DEB_ERROR, "Persistent CI/FSCI Data Corruption. It will be emptied \n" ));
            //Win4Assert( !"Persistent CI/FSCI Data Corruption" );
        }

        startupInfo.startupFlags |= (ULONG) CI_CONFIG_EMPTY_DATA;
        xCat->LogEvent( CCiStatusMonitor::eCiRemoved );
        fFullScanNeeded = TRUE;
    }

    BOOL fAbort = FALSE;

    #if CIDBG==1
    #if 0
    _FillLoadFilesInfo( startupInfo );
    #endif  // 0
    #endif  // CIDBG==1

    sc = pCiStartup->StartupContentIndex( xCat->GetCatDir(), &startupInfo,0, &fAbort );

    #if CIDBG==1
    #if 0
    if ( SUCCEEDED(sc) )
    {
        WCHAR wszBackupPath[MAX_PATH];
        wcscpy( wszBackupPath, xCat->GetCatDir() );
        wcscat( wszBackupPath, L"\\backup");
        ICiPersistIncrFile * pIPersist = 0;
        sc = _xCiManager->QueryInterface( IID_ICiPersistIncrFile,
                                          (void **) &pIPersist );
        Win4Assert( SUCCEEDED(sc) );
        _xSaveTest.Set( new CCiSaveTest( wszBackupPath,
                                         pIPersist,
                                         xCat.GetReference() ) );
        pIPersist->Release();
    }
    _ClearLoadFilesInfo( startupInfo );
    #endif  // 0
    #endif  // CIDBG==1


    if ( FAILED(sc) )
    {
        if ( !IsCiCorruptStatus( sc ) && sc != CI_INCORRECT_VERSION )
        {
            ciDebugOut(( DEB_ERROR, "Failed to startupci. Error 0x%X\n", sc ));
            xCat->LogEvent ( CCiStatusMonitor::eCiError, sc );
            THROW( CException(sc) );
        }

        if ( fLeaveCorruptCatalog )
        {
            Win4Assert( !"leaving corrupt catalog" );
            THROW( CException( sc ) );
        }

        ciDebugOut(( DEB_ERROR, "ContentIndex is corrupt. It will be emptied\n" ));
        //Win4Assert( !"Startup CI Data Corruption" );
        xCat->LogEvent( CCiStatusMonitor::eCiRemoved );

        //
        // Content Index is corrupt. Ask CI to delete the contentIndex and
        // start afresh.
        //
        startupInfo.startupFlags |= CI_CONFIG_EMPTY_DATA;
        sc = pCiStartup->StartupContentIndex( xCat->GetCatDir(),
                                              &startupInfo,
                                              0,
                                              &fAbort );

        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        fFullScanNeeded = TRUE;
    }

    xCat->ClearCiDataCorrupt();

    xCat->InitIf( fLeaveCorruptCatalog );

    //
    // Optimization - we may want to just force an "add" of the documents in the
    // property store rather than a full scan of the corpus.
    //
    if ( fFullScanNeeded )
        xCat->MarkFullScanNeeded();

    xCat.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::_CreateCiManager
//
//  Synopsis:   Creates the CI manager by doing a CoCreateInstance of the
//              ICiControl.
//
//  History:    1-31-97   srikants   Created
//
//----------------------------------------------------------------------------

void CClientDocStore::_CreateCiManager()
{
    //
    // We have to create the ICiManager also now.
    //
    ICiControl * pICiControl = 0;
    GUID clsIdCiControl = CLSID_CiControl;
    SCODE sc = CoCreateInstance( clsIdCiControl,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_ICiControl,
                                 (void **) &pICiControl );

    if ( 0 == pICiControl )
    {
        ciDebugOut(( DEB_ERROR, "Cannot CoCreateInstance IID_ICiControl. Error (0x%X)\n",
                     sc ));
        THROW( CException(sc) );
    }

    XInterface<ICiControl>  xCiControl( pICiControl );

    ICiManager  * pICiManager  = 0;

    sc = xCiControl->CreateContentIndex( this, &pICiManager );
    if ( 0 == pICiManager )
    {
        ciDebugOut(( DEB_ERROR, "Cannot Get ContentIndex. Error 0x%X\n",
                     sc ));

        THROW( CException(sc) );
    }

    _xCiManager.Set( pICiManager );
} //_CreateCiManager

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::~CClientDocStore
//
//  Synopsis:   Destructor of the client document store.
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

CClientDocStore::~CClientDocStore()
{
    delete _pCiCat;
    delete _pCiNullCat;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::IsPropertyCached
//
//  Synopsis:   Tests if the given property is cached in the property
//              store or not.
//
//  Arguments:  [pPropSpec] - Property to test.
//              [pfValue]   - Set to TRUE if cached; FALSE o/w
//
//  Returns:    S_OK if successful;
//              Some other error code if not in a valid state.
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::IsPropertyCached(
    const FULLPROPSPEC * pPropSpec,
    BOOL  * pfValue )
{
    Win4Assert( 0 != pfValue );
    Win4Assert( 0 != pPropSpec );

    Win4Assert( 0 != _pCiCat );


    CFullPropSpec const & ps = *((CFullPropSpec const *) pPropSpec);

    SCODE sc = S_OK;

    TRY
    {
        *pfValue = _pCiCat->IsPropertyCached( ps );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   StoreProperty
//
//  Synopsis:   Stores the given property for the workid.
//
//  Arguments:  [workid]       -  WorkId of the document
//              [pPropSpec]    -  Property to be stored
//              [pPropVariant] -  Value of the property
//
//  Returns:    S_OK if successful
//              CI_E_PROPERTY_NOT_CACHED if it is not a cached property.
//              Other error code
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::StoreProperty(
    WORKID workid,
    const FULLPROPSPEC * pPropSpec,
    const PROPVARIANT * pPropVariant )
{
    Win4Assert( 0 != pPropSpec );
    Win4Assert( 0 != pPropVariant );

    Win4Assert( 0 != _pCiCat );

    CFullPropSpec const & ps = *((CFullPropSpec const *) pPropSpec);
    CStorageVariant const & var = *(ConvertToStgVariant( pPropVariant ));

    SCODE sc = S_OK;

    TRY
    {
        BOOL fStored = _pCiCat->StoreValue( workid, ps, var );
        if ( !fStored )
            sc = CI_E_PROPERTY_NOT_CACHED;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::FlushPropertyStore
//
//  Synopsis:   Causes the property store to flush.
//
//  History:    06-30-97   KrishnaN   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::FlushPropertyStore (void)
{
    SCODE sc = S_OK;

    Win4Assert(_pCiCat);

    TRY
    {
        //
        // Flushing the property store at this point (just before a shadow
        // merge) is necessary for Push model filtering, but not for clients
        // like fsci that do Pull model filtering.  The changelog,
        // scopetable, and property store are already tightly linked and
        // flushed appropriately.
        //

        // _pCiCat->FlushPropertyStore();
    }
    CATCH( CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetClientStatus
//
//  Synopsis:   Retrieves the client status information
//
//  Arguments:  [pStatus] - Will have the status information on output.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::GetClientStatus(
    CI_CLIENT_STATUS * pStatus )
{
    Win4Assert( 0 != pStatus );

    SCODE sc = S_OK;

    TRY
    {
        ULONG cPendingScans, state;
        if (_pCiNullCat)
            _pCiNullCat->CatalogState( pStatus->cDocuments,
                                   cPendingScans,
                                   state );
        else
            _pCiCat->CatalogState( pStatus->cDocuments,
                                   cPendingScans,
                                   state );
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetContentIndex
//
//  Synopsis:   Returns the ICiManager if there is one and we are not
//              in a shutdown sequence.
//
//  Arguments:  [ppICiManager] - ICiManager pointer
//
//
//  Returns:    S_OK if successful
//              CI_E_SHUTDOWN if shutdown
//              CI_E_NOT_INITIALIZED if not yet initialized
//
//  History:    12-10-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::GetContentIndex(
    ICiManager ** ppICiManager)
{
    Win4Assert( 0 != ppICiManager );

    SCODE sc = S_OK;

    CLock   lock(_mutex);

    if ( !_IsShutdown() && _xCiManager.GetPointer() )
    {
        _xCiManager->AddRef();
        *ppICiManager = _xCiManager.GetPointer();
    }
    else
    {
        *ppICiManager = 0;
        if ( _IsShutdown() )
            sc = CI_E_SHUTDOWN;
        else sc = CI_E_NOT_INITIALIZED;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::EnableUpdates
//
//  Synopsis:   Enables updates from document store.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::EnableUpdates()
{
    SCODE sc = S_OK;

    Win4Assert(_pCiCat);

    BOOL fEnableUpdateNotifies = FALSE;

    TRY
    {
        // =============================================================
        {
            CLock   lock(_mutex);
            if ( _IsShutdown() )
            {
                ciDebugOut(( DEB_ERROR,
                    "CClientDocStore::EnableUpdates called after shutdown\n" ));
                THROW( CException( CI_E_SHUTDOWN ) );
            }

            fEnableUpdateNotifies = _AreUpdatesDisabled();
            _state = eUpdatesEnabled;
        }
        // =============================================================

        //
        // Notifications are not disabled on DisableUpdates and so only scans/usns
        // need to be scheduled, which is done by NoLokClearDiskFull
        //

        if ( fEnableUpdateNotifies )
            _pCiCat->NoLokClearDiskFull();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "CClientDocStore::EnableUpdates caught error (0x%X)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    if ( S_OK != sc && fEnableUpdateNotifies )
    {
        //
        // There was a failure while enabling udpates. We must set
        // the state back to indicate that updates are not enabled.
        //
        CLock   lock(_mutex);
        _LokDisableUpdates();
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::DisableUpdates
//
//  Synopsis:   Disables further updates and prevents update notifications
//              until enabled via the "EnableUpdates" call.
//
//  History:    12-31-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CClientDocStore::DisableUpdates( BOOL fIncremental,
                                 CI_DISABLE_UPDATE_REASON dwReason )
{
    Win4Assert(_pCiCat);

    if ( _IsShutdown() )
        return CI_E_SHUTDOWN;

    SCODE sc = S_OK;

    TRY
    {
       {
          CLock   lock(_mutex);
          _LokDisableUpdates();
       }

       if ( fIncremental )
       {
          _pCiCat->MarkIncrScanNeeded();
          _pCiCat->NoLokProcessDiskFull();
       }
       else
       {
          if ( dwReason == CI_CORRUPT_INDEX )
             _pCiCat->HandleError( CI_CORRUPT_DATABASE );
          else
          {
             _pCiCat->MarkFullScanNeeded();
             _pCiCat->NoLokProcessDiskFull();
          }
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR,
                     "Error (0x%X) while disabling updates\n",
                     sc ));
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::ProcessCiDaemonTermination
//
//  Synopsis:   Processes the death of CiDaemon. Creates a work item to
//              restart the filter daemon.
//
//  History:    12-23-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::ProcessCiDaemonTermination( DWORD dwStatus )
{
    //
    // The CiDaemon process is dead; Just start filtering again.
    //
    SCODE sc = S_OK;

    TRY
    {
        CStartFilterDaemon * pWorkItem = new CStartFilterDaemon( *this, _workMan );
        _workMan.AddToWorkList( pWorkItem );

        pWorkItem->AddToWorkQueue();
        pWorkItem->Release();
    }
    CATCH( CException, e)
    {
        ciDebugOut(( DEB_ERROR,
         "Failed to create a work item for start filter daemon. Error 0x%X\n",
         e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::CheckPointChangesFlushed
//
//  Synopsis:   Processes a changelog flush.
//
//  History:    12-23-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::CheckPointChangesFlushed(
        FILETIME ftFlushed,
        ULONG cEntries,
        USN_FLUSH_INFO const * const *ppUsnEntries)
{
    SCODE sc = S_OK;

    Win4Assert(_pCiCat);

    TRY
    {
        _pCiCat->ProcessChangesFlush( ftFlushed, cEntries, ppUsnEntries );
    }
    CATCH( CException,e  )
    {
        ciDebugOut(( DEB_ERROR,
                     "CheckPointChangesFlushed failed. Error 0x%X\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::MarkDocUnReachable
//
//  Synopsis:   Marks that the document was not reachable when an attempt
//              was made to filter it.
//
//  Arguments:  [wid] - The WORKID which could not be reached.
//
//  History:    12-10-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::MarkDocUnReachable(
    WORKID wid )
{
    SCODE sc = S_OK;

    Win4Assert(_pCiCat);

    TRY
    {
        _pCiCat->MarkUnReachable( wid );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                    "CClientDocStore::MarkDocUnReachable caught exception (0x%X)\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::StoreSecurity
//
//  Synopsis:   Stores the given security data for the workid.
//
//  Arguments:  [wid]    - WorkId of the document
//              [pbData] - Security data buffer
//              [cbData] - NUmber of bytes in the security data buffer
//
//  History:    1-15-97   srikants   Created
//
//  Notes:      We may want to eliminate this call and instead have the
//              security be stored as a special property.
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::StoreSecurity(
    WORKID wid,
    BYTE const * pbData,
    ULONG cbData )
{
    SCODE sc = S_OK;

    Win4Assert(_pCiCat);

    TRY
    {
        _pCiCat->StoreSecurity( wid, (PSECURITY_DESCRIPTOR) pbData, cbData );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                    "CClientDocStore::MarkDocUnReachable caught exception (0x%X)\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::IsNoQuery
//
//  Synopsis:   Check if the docstore is set to NoQuery
//
//  Arguments:  [fNoQuery] - Output
//
//  History:    05-26-98   kitmanh   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::IsNoQuery(
    BOOL * fNoQuery )
{
    SCODE sc = S_OK;

    if ( !fNoQuery )
        sc = STATUS_INVALID_PARAMETER;
    else
        *fNoQuery = _fNoQuery;
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetPropertyMapper
//
//  Synopsis:   Retrieves the interface to IPropertyMapper.
//
//  Arguments:  [ppIPropertyMapper] - On output, will have the IPropertyMapper.
//
//  Returns:    S_OK if successful;
//              E_NOTIMPL if property mapper is not supported by doc store.
//              Other error code if there is a failure.
//  Modifies:
//
//  History:    12-31-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::GetPropertyMapper(
    IPropertyMapper ** ppIPropertyMapper)
{
    SCODE sc = S_OK;

    TRY
    {
        Win4Assert( 0 != _xPropMapper.GetPointer() );

        *ppIPropertyMapper = _xPropMapper.GetPointer();
        _xPropMapper->AddRef();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                    "CClientDocStore::MarkDocUnReachable caught exception (0x%X)\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ICiCDocNameToWorkidTranslatorEx methods.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::QueryDocName
//
//  Synopsis:   Creates a new doc name object and returns its interface.
//
//  Arguments:  [ppICiCDocName] - [out] Will have a pointer to the
//              ICiCDocName object filled in.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::QueryDocName(
        ICiCDocName ** ppICiCDocName )
{
    Win4Assert( 0 != ppICiCDocName );

    SCODE sc = S_OK;

    TRY
    {
        *ppICiCDocName = new CCiCDocName;
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::WorkIdToDocName
//
//  Synopsis:   Translates a WorkId to a document name.
//
//  Arguments:  [workid]       - [in]  WorkId to translate
//              [pICiCDocName] - [out] Will be filled in with the document
//              name on output.
//
//  Returns:    S_OK if successfully converted.
//              CI_E_BUFFERTOOSMALL if the buffer is not big enough
//              Other error code.
//
//  History:    12-05-96   srikants   Created
//
//  Notes:      This method may be one of the most frequently called methods.
//              Look for optimizations (esp. can the TRY/CATCH be avoided?)
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::WorkIdToDocName(
        WORKID workid,
        ICiCDocName * pICiCDocName )
{
    return InternalWorkIdToDocName( workid, pICiCDocName, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::DocNameToWorkId
//
//  Synopsis:   Converts a document name to a WorkId.
//
//  Arguments:  [pICiCDocName] - Document Name
//              [pWorkid]      - [out] Will have the workid on output.
//
//  Returns:    S_OK if successful; Error code otherwise.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::DocNameToWorkId(
    ICiCDocName const * pICiCDocName,
    WORKID * pWorkid )
{
    SCODE sc = S_OK;

    Win4Assert( 0 != pICiCDocName );
    Win4Assert( 0 != pWorkid );

    TRY
    {
        CCiCDocName const * pDocName = (CCiCDocName const *) pICiCDocName;
        *pWorkid = _pCiCat->PathToWorkId( pDocName->GetPath(), TRUE );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::WorkIdToAccurateDocName
//
//  Synopsis:   Translates a WorkId 'accurately' to a document name.
//
//  Arguments:  [workid]       - [in]  WorkId to translate
//              [pICiCDocName] - [out] Will be filled in with the document
//              name on output.
//
//  Returns:    S_OK if successfully converted.
//              CI_E_BUFFERTOOSMALL if the buffer is not big enough
//              Other error code.
//
//  History:    31-Dec-1998  KyleP   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::WorkIdToAccurateDocName(
        WORKID workid,
        ICiCDocName * pICiCDocName )
{
    return InternalWorkIdToDocName( workid, pICiCDocName, TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::_GetPerfIndex
//
//  Synopsis:   An internal helper function to get the offset of the perfmon
//              counter in the perfmon shared memory.
//
//  Arguments:  [name]  - Name of the counter.
//              [index] - Index of the name
//
//  Returns:    TRUE if successfully looked up; FALSE on failure.
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CClientDocStore::_GetPerfIndex( CI_PERF_COUNTER_NAME name, ULONG & index )
{
    BOOL fOk= TRUE;

    ULONG offset = 0;

    switch ( name )
    {
        case CI_PERF_NUM_WORDLIST:

            offset = NUM_WORDLIST;
            break;

        case CI_PERF_NUM_PERSISTENT_INDEXES:

            offset = NUM_PERSISTENT_INDEX;
            break;

        case CI_PERF_INDEX_SIZE:

            offset = INDEX_SIZE;
            break;

        case CI_PERF_FILES_TO_BE_FILTERED:

            offset = FILES_TO_BE_FILTERED;
            break;

        case CI_PERF_NUM_UNIQUE_KEY:

            offset = NUM_UNIQUE_KEY;
            break;

        case CI_PERF_RUNNING_QUERIES:

            offset = RUNNING_QUERIES;
            break;

        case CI_PERF_MERGE_PROGRESS:

            offset = MERGE_PROGRESS;
            break;

        case CI_PERF_DOCUMENTS_FILTERED:

            offset = DOCUMENTS_FILTERED;
            break;

        case CI_PERF_NUM_DOCUMENTS:

            offset = NUM_DOCUMENTS;
            break;

        case CI_PERF_TOTAL_QUERIES:

            offset = TOTAL_QUERIES;
            break;

        case CI_PERF_DEFERRED_FILTER_FILES:

            offset = DEFERRED_FILTER_FILES;
            break;

        default:

            fOk = FALSE;
    }

    if ( fOk )
        index = offset + KERNEL_USER_INDEX;

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::SetPerfCounterValue
//
//  Synopsis:   Sets the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//              [value] - Value to be set.
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::SetPerfCounterValue(
    CI_PERF_COUNTER_NAME  name,
    long value )
{
    // true for the NULL catalog

    if ( _xPerfMon.IsNull() )
        return S_OK;
    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _xPerfMon->Update( index, value );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::IncrementPerfCounterValue
//
//  Synopsis:   Increments the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    1-15-97   dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::IncrementPerfCounterValue(
    CI_PERF_COUNTER_NAME  name )
{
    // true for the NULL catalog

    if ( _xPerfMon.IsNull() )
        return S_OK;

    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _xPerfMon->Increment( index );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::DecrementPerfCounterValue
//
//  Synopsis:   Decrements the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    1-15-97   dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::DecrementPerfCounterValue(
    CI_PERF_COUNTER_NAME  name )
{
    // true for the NULL catalog

    if ( _xPerfMon.IsNull() )
        return S_OK;

    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _xPerfMon->Decrement( index );
    else
        sc = E_INVALIDARG;

    return sc;
} //DecrementPerfCounterValue

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetPerfCounterValue
//
//  Synopsis:   Retrieves the value of the perfmon counter.
//
//  Arguments:  [name]   - [see SetPerfCounterValue]
//              [pValue] -            "
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStore::GetPerfCounterValue(
    CI_PERF_COUNTER_NAME  name,
    long * pValue )
{
    // true for the NULL catalog

    if ( _xPerfMon.IsNull() )
        return S_OK;

    Win4Assert( pValue );

    ULONG index;
    SCODE sc = S_OK;

    if ( _GetPerfIndex( name, index ) )
        *pValue = _xPerfMon->GetCurrValue( index );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+------------------------------------------------------
//
//  Member:     CClientDocStore::NotifyEvent
//
//  Synopsis:   Reports the passed in event and arguments to eventlog
//
//  Arguments:  [fType  ] - Type of event
//              [eventId] - Message file event identifier
//              [nParams] - Number of substitution arguments being passed
//              [aParams] - pointer to PROPVARIANT array of substitution args.
//              [cbData ] - number of bytes in supplemental raw data.
//              [data   ] - pointer to block of supplemental data.
//
//  Returns:    S_OK upon success, value of the exception if an exception
//              is thrown.
//
//  History:    12-30-96   mohamedn   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::NotifyEvent( WORD  fType,
                                           DWORD eventId,
                                           ULONG nParams,
                                           const PROPVARIANT *aParams,
                                           ULONG cbData,
                                           void* data)

{

     SCODE sc = S_OK;

     TRY
     {
        CClientNotifyEvent  notifyEvent(fType,eventId,nParams,aParams,cbData,data);
     }
     CATCH( CException,e )
     {
        ciDebugOut(( DEB_ERROR, "Exception 0x%X in CClientDocStore::NotifyEvent()\n",
                                 e.GetErrorCode() ));

        sc = e.GetErrorCode();
     }
     END_CATCH

     return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::NotifyStatus
//
//  Synopsis:   When a special status is being notified.
//
//  Returns:    S_OK always.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::NotifyStatus(
    CI_NOTIFY_STATUS_VALUE status,
    ULONG nParams,
    const PROPVARIANT * aParams )
{

    SCODE sc = S_OK;

    switch ( status )
    {
        case CI_NOTIFY_FILTERING_FAILURE:

            Win4Assert( nParams == 1 );
            Win4Assert( aParams[0].vt == VT_I4 || aParams[0].vt == VT_UI4 );

            if ( 1 == nParams )
                _ReportFilteringFailure( aParams[0].ulVal );
            break;

        case CI_NOTIFY_FILTER_TOO_MANY_BLOCKS:
        case CI_NOTIFY_FILTER_EMBEDDING_FAILURE:
            //
            // This is possible in the in-proc filtering because
            // the advise status is provided by docstore for filtering
            // also.
            //
            {
                CStorageFilterObjNotifyStatus notify( this );
                sc = notify.NotifyStatus( status, nParams, aParams );
            }
            break;

        default:

            Win4Assert( !"Invalid Case Stmt" );
            break;
    };

    return sc;
}

//
// IFsCiAdmin methods.
//

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::ForceMerge
//
//  Synopsis:   Forces a master merge on the given partition id.
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::ForceMerge( PARTITIONID partId )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        sc = _pCiCat->ForceMerge( partId );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::ForceMerge\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::AbortMerge
//
//  Synopsis:   Aborts any in-progress merge on the given partition id.
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::AbortMerge( PARTITIONID partId )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        sc = _pCiCat->AbortMerge( partId );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::AbortMerge\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::CiState
//
//  Synopsis:   Retrieves the CI_STATE information.
//
//  Arguments:  [pCiState] - On output, will contain the cistate data.
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::CiState( CI_STATE * pCiState )
{

    SCODE sc = S_OK;

    TRY
    {
        if (_pCiNullCat)
            sc = _pCiNullCat->CiState( *pCiState );
        else
            sc = _pCiCat->CiState( *pCiState );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::CiState\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::UpdateDocuments
//
//  Synopsis:   Forces a scan on the given root.
//
//  Arguments:  [rootPath] - Root to force a scan on.
//              [flag]     - Indicating if this is a full scan or a partial
//              scan.
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::UpdateDocuments(
    const WCHAR *rootPath,
    ULONG flag )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        _pCiCat->UpdateDocuments( rootPath, flag);
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::UpdateDocuments\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::AddScopeToCI
//
//  Synopsis:   Adds the given scope to ContentIndex for indexing.
//
//  Arguments:  [rootPath] - Path to add
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::AddScopeToCI(
    const WCHAR *rootPath )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        _pCiCat->AddScopeToCI( rootPath );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::AddScopeToCI\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::RemoveScopeFromCI
//
//  Synopsis:   Removes the given scope from CI.
//
//  Arguments:  [rootPath] - Scope to remove.
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::RemoveScopeFromCI(
    const WCHAR *rootPath )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

       _pCiCat->RemoveScopeFromCI( rootPath, FALSE );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::RemoveScopeFromCI\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::BeginCacheTransaction
//
//  Synopsis:   Begins a property cache transaction.
//
//  Arguments:  [pulToken] - Output - Transaction "cookie".
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::BeginCacheTransaction(
    ULONG_PTR * pulToken )
{

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        *pulToken = _pCiCat->BeginCacheTransaction();
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::BeginCacheTransaction\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::SetupCache
//
//  Synopsis:   Sets up the property for storing the property cache.
//
//  Arguments:  [ps]       -
//              [vt]       -
//              [cbMaxLen] -
//              [ulToken]  -
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::SetupCache(
        const FULLPROPSPEC *ps,
        ULONG vt,
        ULONG cbMaxLen,
        ULONG_PTR ulToken,
        BOOL  fCanBeModified,
        DWORD dwStoreLevel)
{
    Win4Assert(PRIMARY_STORE == dwStoreLevel ||
               SECONDARY_STORE == dwStoreLevel);

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        CFullPropSpec * pFullPropSpec = (CFullPropSpec *)ps;
        _pCiCat->SetupCache( *pFullPropSpec,
                             vt,
                             cbMaxLen,
                             ulToken,
                             fCanBeModified,
                             dwStoreLevel );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::RemoveVirtualScope\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::EndCacheTransaction
//
//  Synopsis:   Ends the property cache transaction.
//
//  Arguments:  [ulToken] -
//              [fCommit] -
//
//  History:    2-12-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::EndCacheTransaction(
    ULONG_PTR ulToken,
    BOOL  fCommit )
{
    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pCiCat )
            THROW( CException( E_INVALIDARG ) );

        _pCiCat->EndCacheTransaction( ulToken, fCommit );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in CClientDocStore::RemoveVirtualScope\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CClientDocStore::IsIoHigh, public
//
//  Returns:    S_OK if system is in a high i/o state, S_FALSE if it is not.
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE CClientDocStore::IsIoHigh( BOOL * pfAbort )
{
    // Windows XP removed support for the IOCTL we used to measure disk
    // usage.

    return S_FALSE;

} //IsIoHigh

//
// Non-Interface methods.
//

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::_StartFiltering
//
//  Synopsis:   Asks the CiManager to start filter daemon and resume
//              filtering.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CClientDocStore::_StartFiltering()
{
    XInterface<ICiManager>  xManager;

    // =============================================
    {
        CLock   lock(_mutex);
        if ( !_IsShutdown() && _xCiManager.GetPointer() )
        {
            _xCiManager->AddRef();
            xManager.Set( _xCiManager.GetPointer() );
        }
        else
        {
            ciDebugOut(( DEB_WARN,
            "Already Shutdown or CI not started. Cannot start filtering\n" ));
            return;
        }
    }
    // =============================================

    //
    // Get the startup data and serialize it.
    //
    WCHAR const * pwszName = _pCiCat->GetName();
    WCHAR const * pwszCatDir = _pCiCat->GetDriveName();


    CDaemonStartupData  startupData( pwszCatDir,
                                     pwszName );

    ULONG cbData;
    BYTE * pbData = startupData.Serialize( cbData );
    XArray<BYTE> xBuf;
    xBuf.Set(cbData,pbData);

    xManager->StartFiltering(  cbData, pbData );

    //
    // Note: Should we be worried about StartFiltering failing ??
    //
}


//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::Shutdown
//
//  Synopsis:   Intiates a shutdown of the document store and the
//              CiManager associated with the document store.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

void CClientDocStore::Shutdown()
{
    TRY
    {
        Win4Assert( !_IsShutdown() );

        // =============================================
        {
            CLock   lock(_mutex);
            _LokMarkShutdown();
        }
        // =============================================

        #if CIDBG==1
        if ( !_xSaveTest.IsNull() )
            _xSaveTest->InitiateShutdown();
        #endif // CIDBG==1

        if (_pCiNullCat)
            _pCiNullCat->ShutdownPhase1();
        else
            _pCiCat->ShutdownPhase1();

        if ( _xCiManager.GetPointer() )
        {
            _xCiManager->Shutdown();
            _xCiManager.Free();
        }

        #if CIDBG==1
        if ( !_xSaveTest.IsNull() )
            _xSaveTest->WaitForDeath();
        #endif //CIDBG==1

        if (_pCiNullCat)
            _pCiNullCat->ShutdownPhase2();
        else
            _pCiCat->ShutdownPhase2();
    }
    CATCH( CException, e)
    {
        ciDebugOut(( DEB_ERROR, "Error (0x%X) in CClientDocStore::Shutdown\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetName
//
//  Synopsis:   Gets the catalog name (if any)
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR const * CClientDocStore::GetName()
{
    if (_pCiNullCat)
        return _pCiNullCat->GetName();
    else
        return _pCiCat->GetName();
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::_SetCiCatRecovered
//
//  Synopsis:   Sets that the CiCat is recovered and if updates were
//              enabled by Content Index, it asks CiCat to start scans
//              and notifications.
//
//  History:    12-09-96   srikants   Created
//              02-25-98   kitmanh    if catalog is read-only, don't filter
//
//  Notes:      This method MUST be called in SYSTEM context only. This
//              starts filtering which in turn creates the filter daemon
//              proxy thread and that must be in SYSTEM context.
//
//----------------------------------------------------------------------------

void CClientDocStore::_SetCiCatRecovered()
{
    Win4Assert( 0 != _pCiCat );

    Win4Assert( !CImpersonateSystem::IsImpersonated() );

    BOOL fEnableFilering = FALSE;

    //don't start filtering if catalog is read-only
    if ( !_pCiCat->IsReadOnly() )
    {

       // ==================================================
       {
          CLock   lock(_mutex);

          fEnableFilering = _AreUpdatesEnabled();
       }
       // ==================================================

       //
       // Since CiCat has been recovered fully, filtering can be started
       // if we are running with "indexing" enabled.
       //
       _StartFiltering();

       if ( fEnableFilering )
          _pCiCat->EnableUpdateNotifies();
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::IsLowOnDiskSpace
//
//  Synopsis:   Returns the status of free space on the disk used by
//              docstore (client) based on the last check.
//
//  Returns:    TRUE if low on free disk space; FALSE o/w
//
//  History:    12-10-96   srikants   Created
//
//  Notes:      This does not actually make an I/O. Just returns an in-memory
//              status.
//
//----------------------------------------------------------------------------

BOOL CClientDocStore::IsLowOnDiskSpace() const
{
    Win4Assert ( !_xDiskStatus.IsNull() );
    return _xDiskStatus->IsLow();
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::VerifyIfLowOnDiskSpace
//
//  Synopsis:   Verifies the free disk space situation by making an I/O call
//              to the O/S.
//
//  Returns:    TRUE if disk is getting to be full; FALSE o/w
//
//  History:    12-10-96   srikants   Created
//
//----------------------------------------------------------------------------


BOOL CClientDocStore::VerifyIfLowOnDiskSpace()
{
    Win4Assert ( !_xDiskStatus.IsNull() );
    _xDiskStatus->UpdateDiskLowInfo();
    return _xDiskStatus->IsLow();
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::_ReportFilteringFailure
//
//  Synopsis:   Reports that there was filtering failure on the given wid.
//
//  Arguments:  [wid] - Workid which failed to filter.
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

void CClientDocStore::_ReportFilteringFailure( WORKID wid )
{
    ciDebugOut(( DEB_IWARN,
        "Warning: unsuccessful attempts to filter workid 0x%X; "
        "cancelling\n", wid ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::GetQuerySession
//
//  Synopsis:   Returns a query session object
//
//  Returns:    [ppICiCQuerySession] -- Session object is returned here
//
//  History:    22-Jan-97   SitaramR   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CClientDocStore::GetQuerySession( ICiCQuerySession **ppICiCQuerySession)
{
    SCODE sc = S_OK;

    TRY
    {
        CQuerySession *pQuerySession = _pCiNullCat ? new CQuerySession(*_pCiNullCat) :
                                                     new CQuerySession(*_pCiCat );
        XInterface<CQuerySession> xSession( pQuerySession );

        sc = pQuerySession->QueryInterface( IID_ICiCQuerySession, (void **) ppICiCQuerySession );

        if ( FAILED(sc) ) {
            vqDebugOut(( DEB_ERROR, "GetQuerySession - QI failed 0x%x\n", sc ));
        }
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CClientDocStore::GetQuerySession - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH

    return sc;

} //GetQuerySession

//+-------------------------------------------------------------------------
//
//  Function:   RegisterDLL
//
//  Synopsis:   Calls DllRegisterServer on the fully qualified path
//
//  History:    19-Jun-97
//
//--------------------------------------------------------------------------

DWORD RegisterDLL( WCHAR const * pwcDLL )
{
    // All Index Server dlls are currently in system32

    DWORD dwErr = NO_ERROR;

    HINSTANCE hDll = LoadLibraryEx( pwcDLL,
                                    0,
                                    LOAD_WITH_ALTERED_SEARCH_PATH );

    if( 0 != hDll )
    {
        SCODE (STDAPICALLTYPE *pfnDllRegisterServer)();
        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hDll, "DllRegisterServer");

        if ( 0 != pfnDllRegisterServer )
        {
            TRY
            {
                SCODE sc = (*pfnDllRegisterServer)();
                if ( S_OK != sc )
                {
                    // no way to map a scode to a win32 error
                    dwErr = ERROR_INVALID_FUNCTION;
                }
            }
            CATCH( CException, e )
            {
                Win4Assert( !"DllRegisterServer threw an exception" );
                ciDebugOut(( DEB_ERROR, "caught 0x%x registering '%ws'\n",
                             e.GetErrorCode(), pwcDLL ));
            }
            END_CATCH;
        }
        else
            dwErr = GetLastError();

        FreeLibrary( hDll );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr;
} //RegisterDll

//+-------------------------------------------------------------------------
//
//  Function:   RegisterKnownDlls
//
//  Synopsis:   Gets the value of the DLL's from the registry and then
//              registers all of them if not done so already.
//
//  History:    19-Jun-97       t-elainc        Created
//
//--------------------------------------------------------------------------

void RegisterKnownDlls()
{
    static fKnownDllsRegistered = FALSE;

    if ( fKnownDllsRegistered )
        return;

    fKnownDllsRegistered = TRUE;

    TRY
    {
        // get registry value

        HKEY hkey;
        int errorcode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      wcsRegAdminSubKey,
                                      0,
                                      KEY_QUERY_VALUE |
                                      KEY_ENUMERATE_SUB_KEYS,
                                      &hkey );

        if (NO_ERROR == errorcode)
        {
            SRegKey xKey( hkey );

            WCHAR awcPath[4000];
            DWORD cwcPath = sizeof awcPath / sizeof WCHAR;

            int anothererrorcode = RegQueryValueEx( hkey,
                                                    L"DLLsToRegister",
                                                    0,
                                                    0,
                                                    (BYTE *)awcPath,
                                                    &cwcPath );
            if (NO_ERROR == anothererrorcode)
            {
                // parse the string
                WCHAR* pwcCurrFile = awcPath;

                //for each file call RegisterDLL
                while ( 0 != *pwcCurrFile )
                {
                    RegisterDLL(pwcCurrFile);
                    pwcCurrFile += wcslen( pwcCurrFile) + 1;
                }
            }
        }
    }
    CATCH( CException, ex )
    {
        ciDebugOut(( DEB_FORCE, "exception %#x registering dlls\n",
                     ex.GetErrorCode() ));
    }
    END_CATCH;
} //RegisterKnownDlls

//+-------------------------------------------------------------------------
//
//  Function:   OpenCatalogsOnRemovableDrives
//
//  Synopsis:   Opens the catalogs found on the roots of removable drives
//              that are not yet opened.
//
//  History:    28-Apr-99   dlee       Created.
//
//--------------------------------------------------------------------------

void OpenCatalogsOnRemovableDrives()
{
    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

    if ( 0 == reg.Read( wcsMountRemovableCatalogs,
                        CI_AUTO_MOUNT_CATALOGS_DEFAULT ) )
        return;

    // Determine which drives exist in this bitmask

    DWORD dwDriveMask = GetLogicalDrives();
    dwDriveMask >>= 2;

    WCHAR awcPath[5];
    wcscpy( awcPath, L"c:\\" );

    // loop through all the drives c-z

    for ( WCHAR wc = L'C'; wc <= L'Z'; wc++ )
    {
        DWORD dwTemp = ( dwDriveMask & 1 );
        dwDriveMask >>= 1;

        if ( 0 != dwTemp )
        {
            if ( IsRemovableDrive( wc ) )
            {
                awcPath[0] = wc;

                if ( 0 == Catalogs.GetDocStore( awcPath ) )
                    Catalogs.TryToStartCatalogOnRemovableVol( wc, g_pFSCIRequestQueue );
            }
        }
    }
} //OpenCatalogsOnRemovableDrives

//+-------------------------------------------------------------------------
//
//  Function:   OpenCatalogsInRegistry
//
//  Synopsis:   Opens the catalogs listed in the registry. If there are
//              problems opening a catalog, it is skipped -- no sense
//              bringing down the service over a messed-up registry entry.
//
//  History:    10-Oct-96   dlee       Created.
//
//--------------------------------------------------------------------------

void OpenCatalogsInRegistry( BOOL fOpenForReadOnly = FALSE )
{
    //
    // Side effect of starting up -- register dlls
    //

    RegisterKnownDlls();

    ciDebugOut(( DEB_ITRACE, "OpenCatalogsInRegistry: fOpenForReadOnly == %d\n",
                 fOpenForReadOnly ));

    HKEY hKey;
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        wcsRegCatalogsSubKey,
                                        0,
                                        KEY_QUERY_VALUE |
                                            KEY_ENUMERATE_SUB_KEYS,
                                        &hKey ) )
    {
        SRegKey xKey( hKey );
        DWORD iSubKey = 0;

        do
        {
            FILETIME ft;
            WCHAR awcName[MAX_PATH];
            DWORD cwcName = sizeof awcName / sizeof WCHAR;
            LONG err = RegEnumKeyEx( hKey,
                                     iSubKey,
                                     awcName,
                                     &cwcName,
                                     0, 0, 0, &ft );

            // either error or end of enumeration

            if ( ERROR_SUCCESS != err )
                break;

            iSubKey++;

            HKEY hCatName;
            if ( ERROR_SUCCESS == RegOpenKeyEx( hKey,
                                                awcName,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hCatName ) )
            {
                SRegKey xCatNameKey( hCatName );
                WCHAR awcPath[MAX_PATH];
                DWORD cbPath = sizeof awcPath;
                if ( ERROR_SUCCESS == RegQueryValueEx( hCatName,
                                                       wcsCatalogLocation,
                                                       0,
                                                       0,
                                                       (BYTE *)awcPath,
                                                       &cbPath ) )
                {
                    Catalogs.GetNamedOne( awcPath, awcName, fOpenForReadOnly );
                }
            }
        } while ( TRUE );
    }

    OpenCatalogsOnRemovableDrives();
} //OpenCatalogsInRegistry

//+-------------------------------------------------------------------------
//
//  Function:   OpenOneCatalog
//
//  Synopsis:   Opens the catalog specified for R/W or R/O.
//              set the fNoQuery flag in the docstore if fNoQuery (passed in)
//              is TRUE
//
//  Arguments:  [wcCatName] -- name of the catalog
//              [fReadOnly] -- opening for readOnly
//              [fNoQuery] -- opening the catalog as NoQuery
//
//  History:    27-Apr-98   kitmanh       Created.
//              12-May-98   kitmanh       Added fNoQuery
//
//--------------------------------------------------------------------------

void OpenOneCatalog( WCHAR const * wcCatName, BOOL fReadOnly, BOOL fNoQuery = FALSE )
{
    ciDebugOut(( DEB_ITRACE, "OpenOneCatalog\n" ));
    ciDebugOut(( DEB_ITRACE, "fNoQuery is %d\n", fNoQuery ));

    HKEY hKey;
    WCHAR wcsKey[MAX_PATH];

    if ( ( wcslen( wcsRegCatalogsSubKey ) + wcslen( wcCatName ) + 1 ) >= MAX_PATH )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    wcscpy( wcsKey, wcsRegCatalogsSubKey );
    wcscat( wcsKey, L"\\" );
    wcscat( wcsKey, wcCatName );

    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    wcsKey,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hKey ) )
    {
        SRegKey xKey( hKey );

        WCHAR awcPath[MAX_PATH];
        DWORD cwcPath = sizeof awcPath / sizeof WCHAR;
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                               wcsCatalogLocation,
                                               0,
                                               0,
                                               (BYTE *)awcPath,
                                               &cwcPath ) )
        {
            Catalogs.GetNamedOne( awcPath, wcCatName, fReadOnly, fNoQuery );
        }
    }
} //OpenOneCatalog

// Mutex and Event to synchronize start, stop, pause and continue
CStaticMutexSem g_mtxStartStop;
CEventSem * g_pevtPauseContinue = 0;

//+-------------------------------------------------------------------------
//
//  Function:   StartCiSvcWork
//
//  Synopsis:   Entry point for doing the CI service work.  The thread does
//              not exit until StopCiSvcWork is called.
//
//  Argument:   [DrvNotifArray] -- reference to the only one
//                                 DriveNotificationArray
//
//  History:    16-Sep-96   dlee       Created.
//              16-Sep-98   kitmanh    Added parameter DrvNotifArray
//
//--------------------------------------------------------------------------

void StartCiSvcWork( CDrvNotifArray & DrvNotifArray )
{
    TRY
    {
        //
        // This lock is released when cisvc is initialized enough that
        // StopCiSvcWork can safely be called.
        //

        CReleasableLock lock( g_mtxStartStop );
        ciDebugOut(( DEB_ITRACE, "StartCiSvcWork got the lock\n" ));

        Catalogs.Init();
        TheFrameworkClientWorkQueue.Init();

        XCom xcom;

        // Create the CRequestQueue here, so it'll stay around for
        // the whole time

        ULONG cMaxCachedServerItems, cMaxSimultaneousRequests,
              cmsDefaultClientTimeout, cMinClientIdleTime, cmsStartupDelay;
        BOOL fMinimizeWorkingSet;

        {
            CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
            cMaxCachedServerItems = reg.Read( wcsMaxCachedPipes,
                                              CI_MAX_CACHED_PIPES_DEFAULT,
                                              CI_MAX_CACHED_PIPES_MIN,
                                              CI_MAX_CACHED_PIPES_MAX );
            cMaxSimultaneousRequests = reg.Read( wcsMaxSimultaneousRequests,
                                                 CI_MAX_SIMULTANEOUS_REQUESTS_DEFAULT,
                                                 CI_MAX_SIMULTANEOUS_REQUESTS_MIN,
                                                 CI_MAX_SIMULTANEOUS_REQUESTS_MAX );
            cmsDefaultClientTimeout = reg.Read( wcsRequestTimeout,
                                                CI_REQUEST_TIMEOUT_DEFAULT,
                                                CI_REQUEST_TIMEOUT_MIN,
                                                CI_REQUEST_TIMEOUT_MAX );
            fMinimizeWorkingSet = reg.Read( wcsMinimizeWorkingSet,
                                            (DWORD)CI_MINIMIZE_WORKINGSET_DEFAULT );

            // convert seconds to milliseconds

            cMinClientIdleTime = 1000 * reg.Read( wcsMinClientIdleTime,
                                                  CI_MIN_CLIENT_IDLE_TIME );
            cmsStartupDelay = reg.Read( wcsStartupDelay,
                                        CI_STARTUP_DELAY_DEFAULT,
                                        CI_STARTUP_DELAY_MIN,
                                        CI_STARTUP_DELAY_MAX );
        }

        Catalogs.SetDrvNotifArray( &DrvNotifArray );

        // Create the CRequestQueue here, so it'll stay around for the
        // whole time.

        CRequestQueue queue( cMaxCachedServerItems,
                             cMaxSimultaneousRequests,
                             cmsDefaultClientTimeout,
                             fMinimizeWorkingSet,
                             cMinClientIdleTime,
                             cmsStartupDelay,
                             guidStorageDocStoreLocatorObject );

        g_pFSCIRequestQueue = &queue;

        while ( TRUE )
        {
            // request lock to prevent problems of sequence of
            // net pause, net stop and net start (in any order
            // and combo.)

            if ( !lock.IsHeld() )
                lock.Request();

            ciDebugOut(( DEB_ITRACE, "About to call StartFWCiSvcWork\n" ));

            StartFWCiSvcWork( lock, &queue, *g_pevtPauseContinue);

            ciDebugOut(( DEB_ITRACE, "StartCiSvcWork:: fell out from StartFWCiSvcWork\n" ));

            // In the case where a net pause happened
            // instead of checking IsNetPause and IsNetcontinue, loop thru the
            // dynarray to reopen docstores. and clear the SCarry when done
            // note if array.count == 0, work as normal.
            SCWorkItem * WorkItem;
            WCHAR wcCatName[MAX_PATH];

            if ( !queue.IsShutdown() )
            {
                // something is on the _stateChangeArray to be handled
                for ( unsigned i = 0; i < queue.SCArrayCount(); i++ )
                {
                    WorkItem = queue.GetSCItem(i);
                    if ( WorkItem->StoppedCat ) {
                        wcsncpy( wcCatName, WorkItem->StoppedCat, sizeof wcCatName / sizeof WCHAR );
                        wcCatName[ (sizeof wcCatName / sizeof WCHAR) - 1 ] = 0;
                    }
                    else if ( eNoCatWork != WorkItem->type ) {
                        wcsncpy( wcCatName, ( (CClientDocStore *)(WorkItem->pDocStore) )->GetName(), sizeof wcCatName / sizeof WCHAR );
                        wcCatName[ (sizeof wcCatName / sizeof WCHAR) - 1 ] = 0;
                    }
                    switch ( WorkItem->type )
                    {
                    case eCatRO:
                        //flush cat
                        if ( !WorkItem->StoppedCat )
                            Catalogs.FlushOne( WorkItem->pDocStore );
                        else
                            Catalogs.RmFromStopArray( wcCatName );

                        OpenOneCatalog( wcCatName, TRUE );
                        break;
                    case eCatW:
                        if ( !WorkItem->StoppedCat )
                            Catalogs.FlushOne( WorkItem->pDocStore );
                        else
                            Catalogs.RmFromStopArray( wcCatName );

                        OpenOneCatalog( wcCatName, FALSE );
                        break;
                    case eStopCat:
                        if ( !WorkItem->StoppedCat )
                        {
                            Catalogs.FlushOne( WorkItem->pDocStore );
                            ciDebugOut(( DEB_ITRACE, "Catalogs.IsCatStopped( %ws ) == %d\n",
                                         wcCatName, Catalogs.IsCatStopped( wcCatName ) ));
                        }
                        break;
                    case eNoQuery:
                        if ( !WorkItem->StoppedCat )
                            Catalogs.FlushOne( WorkItem->pDocStore );
                        else
                            Catalogs.RmFromStopArray( wcCatName );

                        OpenOneCatalog( wcCatName, !(WorkItem->fNoQueryRW), TRUE );
                        break;
                    case eNetPause:
                    case eNetContinue:
                    case eNetStop:
                    case eNoCatWork:
                    // These cases are handled later
                        break;
                    default:
                        Win4Assert( !"The eCisvcActionType specified is unknown" );
                    }
                }
            }

            if ( queue.IsNetPause() )
            {
                Win4Assert( !queue.IsNetContinue() );

                Catalogs.ClearStopArray();
                // reset the queue

                queue.ReStart();

                //closecatalog
                Catalogs.Flush();

                OpenCatalogsInRegistry( TRUE ); //reopen catalogs for r/o

                //Win4Assert( !"Done Pausing" );
            }
            // a net continue happened
            else if ( queue.IsNetContinue() )
            {
                Win4Assert( !queue.IsNetPause() );

                Catalogs.ClearStopArray();
                // reset the queue
                queue.ReStart();

                ciDebugOut(( DEB_ITRACE, "YES, net continued*********\n" ));
                ciDebugOut(( DEB_ITRACE, "About to flush catalogs.\n" ));
                //closecatalog
                Catalogs.Flush();
                ciDebugOut(( DEB_ITRACE, "About to OpenCatalogsInRegistry for r/w \n" ));

                OpenCatalogsInRegistry( FALSE ); //reopen catalogs for r/w

                ciDebugOut(( DEB_ITRACE, "Done opening catalogs in registry\n" ));

                //Win4Assert( !"Done Continuing" );
            }
            else
            {
                if ( !( queue.IsShutdown() || queue.IsNetStop() ) )
                    queue.ReStart();
                else
                {
                    ciDebugOut(( DEB_ITRACE, "StartCisvcWork: Breaking out of the loop and ready to shutdown the service\n" ));
                    Catalogs.ClearStopArray();
                    break;
                }
            }
        }
    }
    CATCH( CException, ex )
    {
        ciDebugOut(( DEB_WARN, "StartCiSvcWork2 exception error 0x%x\n",
                      ex.GetErrorCode() ));
    }
    END_CATCH;
} //StartCiSvcWork

//+-------------------------------------------------------------------------
//
//  Function:   StopCiSvcWork
//
//  Synopsis:   Entry point for stopping the CI service work.
//
//  Arguments:  [type]  -- type of work to do
//              [wcVol] -- volume letter (for eLockVol only)
//
//  History:    16-Sep-96   dlee       Created.
//              12-Aug-98   kitmanh    Returned an SCODE
//
//--------------------------------------------------------------------------

SCODE StopCiSvcWork( ECiSvcActionType type, WCHAR wcVol )
{
    ciDebugOut(( DEB_ITRACE, "StopCiSvcWork is trying to get the lock\n" ));
    CReleasableLock lock( g_mtxStartStop );
    ciDebugOut(( DEB_ITRACE, "StopCiSvcWork got the lock\n" ));

    // If the main SCM thread didn't get very far, this will be the case.

    if ( 0 == g_pevtPauseContinue )
        return S_OK;

    g_pevtPauseContinue->Reset();

    SCODE sc = StopFWCiSvcWork( type, &lock, g_pevtPauseContinue, wcVol );

    lock.Release();

    ciDebugOut(( DEB_ITRACE, "StopCiSvcWork.. After StopFwCiSvcWork has returned. type == %d\n", type ));

    // Do not block if shutdown has intialized
    if ( STATUS_TOO_LATE == sc )
        return S_OK;

    // block if pausing or continuing
    if ( eNetStop != type )
    {
        ciDebugOut(( DEB_ITRACE, "StopCiSvcWork.. After StopFwCiSvcWork has returned. Block on g_pevtPauseContinue\n" ));
        g_pevtPauseContinue->Wait();
        lock.Request();
        g_pevtPauseContinue->Reset();
        lock.Release();
        ciDebugOut(( DEB_ITRACE, "StopCiSvcWork.. After StopFwCiSvcWork has returned. Reusme on g_pevtPauseContinue\n" ));
    }

    return sc;
} //StopCiSvcWork

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::InternalWorkIdToDocName
//
//  Synopsis:   Translates a WorkId to a document name.
//
//  Arguments:  [workid]       - [in]  WorkId to translate
//              [pICiCDocName] - [out] Will be filled in with the document
//                               name on output.
//              [fAccurate]    - Use the slow and accurate call
//
//  Returns:    S_OK if successfully converted.
//              CI_E_BUFFERTOOSMALL if the buffer is not big enough
//              Other error code.
//
//  History:    31-Dec-1998   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CClientDocStore::InternalWorkIdToDocName( WORKID workid,
                                                ICiCDocName * pICiCDocName,
                                                BOOL fAccurate )
{
    Win4Assert( 0 != pICiCDocName );
    Win4Assert(_pCiCat);

    CCiCDocName * pDocName = (CCiCDocName *) pICiCDocName;

    CLowerFunnyPath funnyPath;

    SCODE sc = S_OK;

    TRY
    {
        //
        // We should avoid a memory copy here. Copy into the CCiCDocName
        // directly.  If this turns out to be a performance problem fix
        // it.  It isn't now.
        //

        unsigned cwc;

        if ( fAccurate )
            cwc = _pCiCat->WorkIdToAccuratePath( workid, funnyPath );
        else
            cwc = _pCiCat->WorkIdToPath( workid, funnyPath );
        //
        // CiCat::WorkIdToPath makes an EMPTY string when a doc
        // is deleted.
        //
        if ( cwc > 1 )
        {
            // this is not a deleted file.

            pDocName->SetPath( funnyPath.GetActualPath(), cwc );
        }
        else
        {
            // this is a deleted file.

            sc = CI_S_WORKID_DELETED;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::ClearNonStoragePropertiesForWid
//
//  Synopsis:   Clear non-storage properties from the property storage for wid
//
//  Arguments:  [wid] - workid
//
//  Returns:    S_OK if successful;
//
//  History:    10-06-2000   kitmanh   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStore::ClearNonStoragePropertiesForWid( WORKID wid )
{
    SCODE sc = S_OK; 
    
    TRY
    {
        _pCiCat->ClearNonStoragePropertiesForWid( wid );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\dslookup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       dslookup.cxx
//
//  Contents:   DocStoreLookUp code
//
//  Classes:    CClientDocStoreLocator
//
//  History:    1-16-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

// for definition of CRequestQueue
#include <query.hxx>
#include <srequest.hxx>

#include <dslookup.hxx>
#include <dbprputl.hxx>
#include <catarray.hxx>
#include <docstore.hxx>
#include <imprsnat.hxx>
#include <lang.hxx>
#include <ciole.hxx>
#include <fsci.hxx>
#include <acinotfy.hxx>
#include <cicat.hxx>
#include <regacc.hxx>
#include <ciregkey.hxx>
#include <drvnotif.hxx>
#include <driveinf.hxx>

#include <regscp.hxx>
#include <catreg.hxx>
#include <removcat.hxx>

extern CCatArray Catalogs;
extern void OpenCatalogsInRegistry( BOOL fOpenForReadyOnly = FALSE );

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStore::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown
//              IID_ICiCDocStoreLocator
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStoreLocator::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiCDocStoreLocator == riid )
        *ppvObject = (void *)((ICiCDocStoreLocator *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiCDocStore *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::AddRef
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClientDocStoreLocator::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::Release
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClientDocStoreLocator::Release()
{
    Win4Assert( _refCount > 0 );

    ciDebugOut(( DEB_ITRACE, "DocStoreLocator::Release.. _refCount == %d\n", _refCount ));
    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return refCount;
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::LookUpDocStore
//
//  Synopsis:   Locates the docStore that is specified in the db properties
//              and returns its pointer (if located).
//
//  Arguments:  [pIDBProperties] - 
//              [ppICiCDocStore] -
//              [fMustAlreadyExist] -- If TRUE, the docstore must already
//                                     be opened, or the call fails.
//
//  Returns:    S_OK if found;
//              CI_E_DOCSTORE_NOT_FOUND if not located.
//
//  History:    1-16-97   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CClientDocStoreLocator::LookUpDocStore(
    IDBProperties * pIDBProperties,
    ICiCDocStore ** ppICiCDocStore,
    BOOL            fMustAlreadyExist )
{
    SCODE sc = S_OK;

    TRY
    {
        CGetDbProps connectProps;

        connectProps.GetProperties( pIDBProperties,
                                    CGetDbProps::eCatalog|
                                    CGetDbProps::eScopesAndDepths );
    
        // if a catalog was passed (as a guess or actual), try to open it

        WCHAR const * pwcCatalog = connectProps.GetCatalog();

        //
        // Prevent a hacker from passing a bogus path name -- we trash
        // stack and/or AV in this circumstance!
        //

        if ( 0 == pwcCatalog )
            THROW( CException( CI_E_NOT_FOUND ) );

        unsigned cwc = wcslen( pwcCatalog );
        if ( ( 0 == cwc ) || ( cwc >= ( MAX_PATH - 1 ) ) )
            THROW( CException( CI_E_NOT_FOUND ) );

        CClientDocStore * pDocStore = 0;

        if ( 0 != pwcCatalog )
            pDocStore = Catalogs.GetDocStore( pwcCatalog, fMustAlreadyExist );

        if ( 0 != pDocStore )
        {
            sc = pDocStore->QueryInterface( IID_ICiCDocStore,
                                            (void **) ppICiCDocStore );
        }
        else
        {
            // special case: adminstration connection without a docstore associated

            if ( !wcscmp(CIADMIN, pwcCatalog) )
            {
                ciDebugOut(( DEB_ITRACE, 
                             "CClientDocStoreLocator::LookUpDocStore.. ADMINSTRATION connection is requested\n" ));
                sc = CI_S_NO_DOCSTORE;
            }
            else
                sc = CI_E_NOT_FOUND;            
        }
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //LookUpDocStore

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::Shutdown
//
//  Synopsis:   Shuts down the content index by closing all open catalogs.
//
//  History:    1-29-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::Shutdown()
{
    ciDebugOut(( DEB_ITRACE, "DocStoreLocator::Shutdown is called\n" ));
    return FsCiShutdown();
}

//+---------------------------------------------------------------------------
//
//  Function:   FsCiShutdown
//
//  Synopsis:   Does shutdown processing for the FsCi component.
//
//  History:    2-27-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE FsCiShutdown()
{
    SCODE sc = S_OK;

    TRY
    {
        Catalogs.Flush();
        CCiOle::Shutdown();
        g_LogonList.Empty();        
        TheFrameworkClientWorkQueue.Shutdown();
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();

        // If this assert hits, we took an exception while releasing
        // resources, which isn't allowed to happen.  It's a bug elsewhere.

        Win4Assert( !"FsCiShutdown failed, and it isn't allowed to" );
    }
    END_CATCH

    return sc;
} //FsCiShutdown

//+-------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::OpenAllDocStores
//
//  Synopsis:   Opens all the catalogs in the registry
//
//  History:    06-May-98   kitmanh       Created.
//
//--------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::OpenAllDocStores()
{
    SCODE sc = S_OK;

    TRY
    {
        OpenCatalogsInRegistry();
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //OpenAllDocStores

//+-------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::GetDocStoreState
//
//  Synopsis:   Gets the state of a docstore
//              (used when restarting a stopped catalog) or the directory is
//              unwritable
//
//  Arguments:  [pwcDocStore]   -- Name of the catalog
//              [ppICiDocStore] -- Returns the docstore
//              [pdwState]      -- Returns the state
//
//  History:    06-May-98   kitmanh       Created.
//
//--------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::GetDocStoreState( 
    WCHAR const *   pwcDocStore, 
    ICiCDocStore ** ppICiCDocStore,
    DWORD *         pdwState )
{
    SCODE sc = S_OK;

    TRY
    {
        if ( Catalogs.IsCatStopped( pwcDocStore ) )
        {
            *pdwState = CICAT_STOPPED;
            sc = CI_S_CAT_STOPPED;
            return sc;
        }
        
        CClientDocStore * pDocStore = 0;

        if ( 0 != pwcDocStore )
            pDocStore = Catalogs.GetDocStore( pwcDocStore );
  
        if ( 0 != pDocStore )
        {
            Win4Assert( pDocStore );

            // get the interface 
            sc = pDocStore->QueryInterface( IID_ICiCDocStore,
                                            (void **) ppICiCDocStore );
            
            // get the oldstate and flag

            CiCat * pCiCat = pDocStore->GetCiCat();

            // Is this the null catalog?

            if ( 0 == pCiCat )
                THROW( CException( CI_E_NOT_FOUND ) );
            
            if ( pCiCat->IsReadOnly() ) 
            {
                ciDebugOut(( DEB_ITRACE, "CClientDocStoreLocator::GetDocStoreState.. CiCatReadOnly == %d\n", 
                             pCiCat->IsReadOnly() ));
                *pdwState = CICAT_READONLY;
            }
            else
                *pdwState = CICAT_WRITABLE;
            
            BOOL fNoQuery;
            pDocStore->IsNoQuery( &fNoQuery );
            if ( fNoQuery ) 
               *pdwState |= CICAT_NO_QUERY; 
        }
        else 
            sc = CI_E_NOT_FOUND; //or some other error?
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //GetDocStoreState

BOOL IsDirectoryWritable( WCHAR const * pwcPath );

//+-------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::IsMarkedReadOnly
//
//  Synopsis:   Check if the catalog is marked for readonly in the registry
//              (used when restarting a stopped catalog) or the directory is
//              unwritable
//
//  Arguments:  [wcsCat] -- Name of the catalog
//              [pfReadOnly] -- output
//
//  History:    06-May-98   kitmanh       Created.
//
//--------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::IsMarkedReadOnly( WCHAR const * wcsCat, BOOL * pfReadOnly )
{
    SCODE sc = S_OK;

    TRY
    {
        unsigned cwcNeeded = wcslen( wcsRegJustCatalogsSubKey );
        cwcNeeded += 2; // "\\" + null termination
        cwcNeeded += wcslen( wcsCat );
    
        XArray<WCHAR> xKey( cwcNeeded );
        wcscpy( xKey.Get(), wcsRegJustCatalogsSubKey );
        wcscat( xKey.Get(), L"\\" );
        wcscat( xKey.Get(), wcsCat );
    
        CRegAccess reg( RTL_REGISTRY_CONTROL, xKey.Get() );

        BOOL fReadOnly = FALSE;
        *pfReadOnly = reg.Read(wcsIsReadOnly, fReadOnly );
        ciDebugOut(( DEB_ITRACE, "IsMarkedReadOnly is %d\n", *pfReadOnly ));
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //IsMarkedReadOnly

//+-------------------------------------------------------------------------
//
//  Member:     IsVolumeOrDirRO
//
//  Synopsis:   Check if the volume and the directory are unwritable
//
//  Arguments:  [wcsCat] -- Name of the catalog
//              [pfReadOnly] -- output
//
//  History:    07-May-98   kitmanh       Created.
//
//--------------------------------------------------------------------------
STDMETHODIMP CClientDocStoreLocator::IsVolumeOrDirRO( WCHAR const * wcsCat, 
                                                      BOOL * pfReadOnly )
{
    SCODE sc = S_OK;
    *pfReadOnly = FALSE;

    TRY
    {
        WCHAR wcsKey[MAX_PATH];
        wcscpy( wcsKey, wcsRegCatalogsSubKey );
        wcscat( wcsKey, L"\\" );

        unsigned cwc = wcslen( wcsKey ) + wcslen( wcsCat );

        if ( cwc >= MAX_PATH )
            THROW( CException( E_INVALIDARG ) );

        wcscat( wcsKey, wcsCat );

        HKEY hKey;
        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            wcsKey,
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKey ) )
        {
            SRegKey xKey( hKey );

            WCHAR awcPath[MAX_PATH];
            DWORD cbPath = sizeof awcPath;
            if ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                                   wcsCatalogLocation,
                                                   0,
                                                   0,
                                                   (BYTE *)awcPath,
                                                   &cbPath ) )
            {
                CDriveInfo driveInfo ( awcPath, 0 );
                wcscat( awcPath, L"Catalog.wci" );  //is there a constant for this?
                ciDebugOut(( DEB_ITRACE, "IsVolumeOrDirRO.. awcPath == %ws\n", awcPath ));
                ciDebugOut(( DEB_ITRACE, "Volume Writeprotected is %d\n", driveInfo.IsWriteProtected() ));
                ciDebugOut(( DEB_ITRACE, "Diretory Writable is %d\n", IsDirectoryWritable( awcPath ) )); 
                *pfReadOnly = ( driveInfo.IsWriteProtected() || !( IsDirectoryWritable( awcPath ) ) );
            }
        }
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //IsVolumeOrDirRO

//+---------------------------------------------------------------------------
//
//  Member:     StopCatalogsOnVol
//
//  Synopsis:   Stops all catalogs on the volume specified.
//
//  Arguments:  [wcVol] -- Volume letter 
//              [pRequestQ] -- Pointer to the RequestQueue
//
//  History:    07-05-98    kitmanh   Created
//              07-20-98    kitmanh   Stop the catalogs with scopes on 
//                                    volume being locked too
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::StopCatalogsOnVol( WCHAR wcVol, 
                                                        void * pRequestQ )          
{
    ciDebugOut(( DEB_ITRACE, "StopCatalogsOnVol %wc\n", wcVol ));

    //enumerate reg to find out who needs to stop
    //add a workitem for all of them 
        
    ciDebugOut(( DEB_ITRACE, "StopCatalogsOnVol is called\n" ));
    Win4Assert( 0 != pRequestQ );

    CRequestQueue * pRequestQueue = (CRequestQueue *)pRequestQ;
    SCWorkItem newItem;
    HKEY hKey;
    SCODE sc = S_OK;
    BOOL fFiledWorkItem = FALSE;
    
    TRY
    {
        if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            wcsRegCatalogsSubKey,
                                            0,
                                            KEY_QUERY_VALUE |
                                            KEY_ENUMERATE_SUB_KEYS,
                                            &hKey ) )
        {
            SRegKey xKey( hKey );
            DWORD iSubKey = 0;

            do
            {
                FILETIME ft;
                WCHAR awcName[MAX_PATH];
                DWORD cwcName = sizeof awcName / sizeof WCHAR;
                LONG err = RegEnumKeyEx( hKey,
                                         iSubKey,
                                         awcName,
                                         &cwcName,
                                         0, 0, 0, &ft );

                // either error or end of enumeration

                if ( ERROR_SUCCESS != err )
                    break;

                iSubKey++;

                HKEY hCatName;
                if ( ERROR_SUCCESS == RegOpenKeyEx( hKey,
                                                    awcName,
                                                    0,
                                                    KEY_QUERY_VALUE,
                                                    &hCatName ) )
                {
                    // enumerate the location registries
                    SRegKey xCatNameKey( hCatName );


                    // Check if the catalog is inactive and can be ignored
   
                    WCHAR awcKey[MAX_PATH];
                    wcscpy( awcKey, wcsRegJustCatalogsSubKey );
                    wcscat( awcKey, L"\\" );

                    unsigned cwc = wcslen( awcKey ) + wcslen( awcName );

                    if ( cwc >= MAX_PATH )
                        THROW( CException( E_INVALIDARG ) );

                    wcscat( awcKey, awcName );
    
                    CRegAccess reg( RTL_REGISTRY_CONTROL, awcKey );
                    BOOL fInactive = reg.Read( wcsCatalogInactive,
                                               CI_CATALOG_INACTIVE_DEFAULT );

                    BOOL fIsAutoMount = reg.Read( wcsIsRemovableCatalog, (ULONG) FALSE );

                    if ( !fInactive )
                    {
                        WCHAR awcPath[MAX_PATH];
                        DWORD cbPath = sizeof awcPath;
                        if ( ERROR_SUCCESS == RegQueryValueEx( hCatName,
                                                               wcsCatalogLocation,
                                                               0,
                                                               0,
                                                               (BYTE *)awcPath,
                                                               &cbPath ) )
                        {
                            if ( toupper(awcPath[0]) == toupper(wcVol) ) 
                            {
                                //check old state of docstore
                                DWORD dwOldState;
                                XInterface<ICiCDocStore> xDocStore;
                                    
                                sc = GetDocStoreState( awcName,
                                                       xDocStore.GetPPointer(),
                                                       &dwOldState );
                           
                                if ( SUCCEEDED(sc) )
                                {
                                    ciDebugOut(( DEB_ITRACE, "StopCatalogsOnVol: dwOldState is %d for catalog %ws\n",
                                                 dwOldState, awcName ));
    
                                    if ( 0 == (CICAT_STOPPED & dwOldState) )
                                    {
                                        ciDebugOut(( DEB_ITRACE, "CATALOG %ws WAS NOT STOPPED BEFORE\n", awcName ));
                                        ciDebugOut(( DEB_ITRACE, "Add old state %d\n", dwOldState ));

                                        if ( !fIsAutoMount )
                                            Catalogs.AddStoppedCat( dwOldState, awcName, wcVol );
                                        
                                        newItem.type = eStopCat;
                                        newItem.pDocStore = xDocStore.GetPointer();
                                    
                                        pRequestQueue->AddSCItem( &newItem , 0 );
                                        fFiledWorkItem = TRUE;
                                    }
                                    else
                                    {
                                        ciDebugOut(( DEB_ITRACE, "CATALOG %ws WAS STOPPED BEFORE\n", awcName ));
                                        BOOL fSucceeded = Catalogs.IncStopCount( awcName, wcVol );
                                        Win4Assert( fSucceeded );
                                    }
                                }
                            }
                            else  // enumerate the scopes to see if this catalog needs to stop
                            {
                                unsigned cwcNeeded = wcslen( wcsRegJustCatalogsSubKey );
                                cwcNeeded += 3; // "\\" x 2 + null termination
                                cwcNeeded += wcslen( awcName );
                                cwcNeeded += wcslen( wcsCatalogScopes );
                                    
                                XArray<WCHAR> xKey( cwcNeeded );
                                wcscpy( xKey.Get(), wcsRegJustCatalogsSubKey );
                                wcscat( xKey.Get(), L"\\" );
                                wcscat( xKey.Get(), awcName );
                                wcscat( xKey.Get(), L"\\" );
                                wcscat( xKey.Get(), wcsCatalogScopes );
                                    
                                CRegAccess regScopes( RTL_REGISTRY_CONTROL, xKey.Get() );
                                
                                CRegistryScopesCallBackToDismount callback( wcVol );
                                regScopes.EnumerateValues( 0, callback );
    
                                if ( callback.WasFound() )
                                {
                                    //check old state of docstore
                                    DWORD dwOldState;
                                    XInterface<ICiCDocStore> xDocStore;
                            
                                    sc = GetDocStoreState( awcName,
                                                           xDocStore.GetPPointer(),
                                                           &dwOldState );
    
                                    if ( SUCCEEDED(sc) )
                                    {
                                        if ( 0 == (CICAT_STOPPED & dwOldState) )
                                        {
                                            ciDebugOut(( DEB_ITRACE, "CATALOG %ws WAS NOT STOPPED BEFORE\n", awcName ));
                                            ciDebugOut(( DEB_ITRACE, "Creating an SCItem\n" ));

                                            if ( !fIsAutoMount )
                                                Catalogs.AddStoppedCat( dwOldState, awcName, wcVol );
                                            
                                            newItem.type = eStopCat;
                                            newItem.pDocStore = xDocStore.GetPointer();
                                            
                                            pRequestQueue->AddSCItem( &newItem , 0 );
                                            fFiledWorkItem = TRUE;
                                        }
                                        else
                                        {
                                            ciDebugOut(( DEB_ITRACE, "CATALOG %ws WAS STOPPED BEFORE\n", awcName ));
                                            BOOL fSucceeded = Catalogs.IncStopCount( awcName, wcVol );
                                            Win4Assert( fSucceeded );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } while ( TRUE );
        }

        //
        // If we filed a workitem to close a temporary catalog, delete
        // its registry entries.
        //

        if ( fFiledWorkItem )
        {
            //
            // If this is an auto-mount catalog, delete the temporary
            // registry entries.
            //

            if ( IsRemovableDrive( wcVol ) )
            {
                CRemovableCatalog cat( wcVol );
                cat.Destroy();
            }
        }
        else
        {
            ciDebugOut(( DEB_ITRACE, "no catalogs to stop on %wc\n", wcVol ));

            //
            // File a fake work item so we don't force closeed connections on
            // all docstores.  Otherwise queries will be aborted for no
            // reason.
            //

            newItem.type = eNoCatWork;
            newItem.pDocStore = (ICiCDocStore*)(~0);
            pRequestQueue->AddSCItem( &newItem , 0 );
        }
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //StopCatalogsOnVol

//+---------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::StartCatalogsOnVol
//
//  Synopsis:   Restore all catalogs on the volume specified to its previous
//              state before the volume was locked.
//
//  Arguments:  [wcVol] -- Volume letter 
//              [pRequestQ] -- Pointer to the RequestQueue
//
//  History:    07-07-98    kitmanh   Created
//              07-23-98    kitmanh   Restores catalogs from StoppedArray,
//                                    instead of enumerating registry
//              09-03-98    kitmanh   Delegated the work to CatArray
//
//----------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::StartCatalogsOnVol( WCHAR wcVol, 
                                                         void * pRequestQ )
{
    Win4Assert( 0 != pRequestQ );

    CRequestQueue * pRequestQueue = (CRequestQueue *)pRequestQ;
    
    SCODE sc = S_OK;
    
    TRY
    {
        Catalogs.StartCatalogsOnVol( wcVol, pRequestQueue );
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //StartCatalogsOnVol

//+-------------------------------------------------------------------------
//
//  Member:     CClientDocStoreLocator::AddStoppedCat, public
//  
//  Synopsis:   Add an item of COldCatState into the _aStopCatalogs array
//
//  Arguments:  [dwOldState] -- Old state of a docstore
//              [wcsCatName] -- Catalog name of the docstore
//
//  History:    16-July-98 KitmanH    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CClientDocStoreLocator::AddStoppedCat( DWORD dwOldState, 
                                                    WCHAR const * wcsCatName )
{
    SCODE sc = S_OK;
    
    TRY
    {
        Catalogs.AddStoppedCat( dwOldState, wcsCatName, 0 );
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
} //AddStoppedCat
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\ilangres.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       ilangres.cxx
//
//  Contents:   CLanguageResourceInterface - an object to expose ICiCLangRes
//
//  Classes:    CLanguageResourceInterface
//
//  History:    2-14-97     mohamedn    created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ilangres.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CLanguageResourceInterface::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown, IID_ICiCLangRes
//
//  History:    2-14-97    mohamedn    ICiCLangRes
//
//----------------------------------------------------------------------------

STDMETHODIMP CLanguageResourceInterface::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiCLangRes == riid )
        *ppvObject = (void *)((ICiCLangRes *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiCLangRes *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CLanguageResourceInterface::AddRef
//
//  History:    2-14-97    mohamedn    ICiCLangRes
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLanguageResourceInterface::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CLanguageResourceInterface::Release
//
//  History:    2-14-97    mohamedn    ICiCLangRes
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLanguageResourceInterface::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\filterob.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       filterob.cxx
//
//  Contents:   Code that encapsulates opening files on an Ntfs volume
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


#include "filterob.hxx"
#include "opendoc.hxx"
#include <dmnstart.hxx>
#include <perfci.hxx>
#include <notifyev.hxx>
#include <fwevent.hxx>
#include <cievtmsg.h>

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Construction/Destruction
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::CStorageFilterObject
//
//  Synopsis:   Default constructor.
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CStorageFilterObject::CStorageFilterObject( void )
    :_RefCount( 1 ),
     _pDaemonWorker( 0 ),
#pragma warning( disable : 4355 )           // this used in base initialization
     _notifyStatus( this )
#pragma warning( default : 4355 )
{
    InterlockedIncrement( &gulcInstances );
}

CStorageFilterObject::~CStorageFilterObject()
{
    Win4Assert( 0 == _RefCount );
    delete _pDaemonWorker;
    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown, IID_ICiCFilterClient, IID_ICiCAdviseStatus
//              and IID_ICiCLangRes
//
//  Arguments:  [riid]      - desired interface id
//              [ppvObject] - output interface pointer
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiCFilterClient == riid )
        *ppvObject = (void *)((ICiCFilterClient *)this);
    else if ( IID_ICiCAdviseStatus == riid )
        *ppvObject = (void *)((ICiCAdviseStatus *)this);
    else if ( IID_ICiCLangRes == riid )
        *ppvObject = (void *) ((ICiCLangRes *)this);
    else if ( IID_ICiCFilterStatus == riid )
        *ppvObject = (void *) ((ICiCFilterStatus *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)(IUnknown *) ((ICiCFilterClient *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::AddRef
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStorageFilterObject::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}   //  AddRef


//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::Release
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStorageFilterObject::Release()
{
    Win4Assert( _RefCount >= 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;
}   //  Release


//+---------------------------------------------------------------------------
//
//  ICiCFilterClient method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::GetOpenedDoc
//
//  Synopsis:   Return a new OpenedDoc instance
//
//  Arguments:  [ppICiCOpenedDoc] - output interface pointer
//
//  Returns:    S_OK if success, other error as appropriate
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::GetOpenedDoc(
    ICiCOpenedDoc ** ppICiCOpenedDoc )
{
    SCODE sc = S_OK;

    TRY
    {
        if ( _pDaemonWorker )
        {
            //
            //  Construct opened doc
            //
            *ppICiCOpenedDoc = new CCiCOpenedDoc( this, _pDaemonWorker );
        }
        else
        {
            ppICiCOpenedDoc = 0;
            sc = CI_E_NOT_INITIALIZED;
        }
    }
    CATCH ( CException, e )
    {
        //
        //  Grab status code and convert to SCODE.
        //

        sc = HRESULT_FROM_NT( e.GetErrorCode( ));
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::GetConfigInfo
//
//  Synopsis:   Return configuration info
//
//  Arguments:  [pConfigInfo] - output data structure
//
//  Returns:    S_OK if success, other error as appropriate
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::GetConfigInfo(
    CI_CLIENT_FILTER_CONFIG_INFO *pConfigInfo )
{
    Win4Assert( 0 != pConfigInfo );

    SCODE sc = CI_E_INVALID_STATE;

    if ( _pDaemonWorker )
    {
        pConfigInfo->fSupportsOpLocks = TRUE;
        pConfigInfo->fSupportsSecurity = TRUE;

        sc = S_OK;
    }

    return sc;
}

CPerfMon & CStorageFilterObject::_GetPerfMon()
{
    Win4Assert( 0 != _pDaemonWorker );
    return _pDaemonWorker->GetPerfMon();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::Init
//
//  Synopsis:   Initialize storage filtering
//
//  Arguments:  [pbData]            - input data, ignored
//              [cbData]            - length of data, ignored
//              [pICiAdminParams]   - interface for retrieving configuration
//
//  Returns:    S_OK if success, other error as appropriate
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::Init(
    const BYTE * pbData,
    ULONG cbData,
    ICiAdminParams *pICiAdminParams )
{

    SCODE sc = S_OK;

    TRY
    {
        CDaemonStartupData startupData( pbData, cbData );

        //
        // See if anyone is going to track filter status...
        //

        InitializeFilterTrackers( startupData );

        //
        // Create the object that manages the the client worker thread to
        // track the registry notifications, etc.
        //

        CSharedNameGen nameGen( startupData.GetCatDir() );

        ciDebugOut(( DEB_ITRACE, "making CClientDaemonWorker: '%ws'\n",
                     startupData.GetCatDir() ));

        _pDaemonWorker = new CClientDaemonWorker( startupData,
                                                  nameGen,
                                                  pICiAdminParams );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
            "Failed to create ClientDaemonWorker. Error (0x%X)\n", e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::_GetPerfIndex
//
//  Synopsis:   An internal helper function to get the offset of the perfmon
//              counter in the perfmon shared memory.
//
//  Arguments:  [name]  - Name of the counter.
//              [index] - Index of the name
//
//  Returns:    TRUE if successfully looked up; FALSE on failure.
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CStorageFilterObject::_GetPerfIndex( CI_PERF_COUNTER_NAME name, ULONG & index )
{
    BOOL fOk= TRUE;

    ULONG offset = 0;

    switch ( name )
    {
        case CI_PERF_FILTER_TIME_TOTAL:

            offset = FILTER_TIME_TOTAL;
            break;

        case CI_PERF_FILTER_TIME:

            offset = FILTER_TIME;
            break;

        case CI_PERF_BIND_TIME:

            offset = BIND_TIME;
            break;

        default:

            fOk = FALSE;
    }

    if ( fOk )
        index = offset;

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::SetPerfCounterValue
//
//  Synopsis:   Sets the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//              [value] - Value to be set.
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::SetPerfCounterValue(
    CI_PERF_COUNTER_NAME  name,
    long value )
{
    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _GetPerfMon().Update( index, value );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::IncrementPerfCounterValue
//
//  Synopsis:   Increments the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    1-15-97   dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::IncrementPerfCounterValue(
    CI_PERF_COUNTER_NAME  name )
{
    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _GetPerfMon().Increment( index );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::DecrementPerfCounterValue
//
//  Synopsis:   Decrements the value of the perfmon counter.
//
//  Arguments:  [name]  - Name of the counter
//
//  Returns:    S_OK if a valid perfmon name; E_INVALIDARG if the perfmon
//              name is not correct.
//
//  History:    1-15-97   dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::DecrementPerfCounterValue(
    CI_PERF_COUNTER_NAME  name )
{
    SCODE sc = S_OK;
    ULONG index;

    //
    // CPerfMon::Update must not throw.
    //

    if ( _GetPerfIndex( name, index ) )
        _GetPerfMon().Decrement( index );
    else
        sc = E_INVALIDARG;

    return sc;
} //DecrementPerfCounterValue

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::GetPerfCounterValue
//
//  Synopsis:   Retrieves the value of the perfmon counter.
//
//  Arguments:  [name]   - [see SetPerfCounterValue]
//              [pValue] -            "
//
//  Returns:                          "
//
//  History:    12-06-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CStorageFilterObject::GetPerfCounterValue(
    CI_PERF_COUNTER_NAME  name,
    long * pValue )
{
    Win4Assert( pValue );

    ULONG index;
    SCODE sc = S_OK;

    if ( _GetPerfIndex( name, index ) )
        *pValue = _GetPerfMon().GetCurrValue( index );
    else
        sc = E_INVALIDARG;

    return sc;
}

//+------------------------------------------------------
//
//  Member:     CStorageFilterObject::NotifyEvent
//
//  Synopsis:   Reports the passed in event and arguments to eventlog.
//
//  Arguments:  [fType  ] - Type of event
//              [eventId] - Message file event identifier
//              [nParams] - Number of substitution arguments being passed
//              [aParams] - pointer to PROPVARIANT array of substitution args.
//              [cbData ] - number of bytes in supplemental raw data.
//              [data   ] - pointer to block of supplemental data.
//
//  Returns:    S_OK upon success, value of the exception if an exception
//              is thrown.
//
//  History:    12-30-96   mohamedn   Created
//
//--------------------------------------------------------

STDMETHODIMP
CStorageFilterObject::NotifyEvent( WORD  fType,
                                  DWORD eventId,
                                  ULONG nParams,
                                  const PROPVARIANT *aParams,
                                  ULONG cbData,
                                  void* data)
{

     SCODE sc = S_OK;

     TRY
     {
        CClientNotifyEvent  notifyEvent(fType,eventId,nParams,aParams,cbData,data);
     }
     CATCH( CException,e )
     {
        ciDebugOut(( DEB_ERROR, "Exception 0x%X in CStorageFilterObject::NotifyEvent()\n",
                                 e.GetErrorCode() ));

        sc = e.GetErrorCode();
     }
     END_CATCH

     return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::NotifyStatus
//
//  Synopsis:   When a special status is being notified.
//
//  Returns:    S_OK always.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::NotifyStatus(
    CI_NOTIFY_STATUS_VALUE status,
    ULONG nParams,
    const PROPVARIANT * aParams )
{
    return _notifyStatus.NotifyStatus( status, nParams, aParams );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObjNotifyStatus::NotifyStatus
//
//  Synopsis:   When a special status is being notified.
//
//  Returns:    S_OK always.
//
//  History:    12-05-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObjNotifyStatus::NotifyStatus(
    CI_NOTIFY_STATUS_VALUE status,
    ULONG nParams,
    const PROPVARIANT * aParams )
{
    SCODE sc = S_OK;

    TRY
    {
        switch ( status )
        {
            case CI_NOTIFY_FILTER_TOO_MANY_BLOCKS:
                _ReportTooManyBlocksEvt( nParams, aParams );
                break;

            case CI_NOTIFY_FILTER_EMBEDDING_FAILURE:
                _ReportEmbeddingsFailureEvt( nParams, aParams );
                break;

            default:
                Win4Assert( !"Unknown Case Stmt" );
                sc = E_INVALIDARG;
                break;
        }
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::PreFilter, public
//
//  Synopsis:   Called by framework before filtering begins.
//
//  Arguments:  [pbName] -- Document name (in abstract framework form)
//              [cbName] -- Size in bytes of [pbName]
//
//  Returns:    Various, since it comes from 3rd party clients.
//
//  History:    15-Jan-1998   KyleP   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::PreFilter( BYTE const * pbName, ULONG cbName )
{
    SCODE sc = S_OK;

    //
    // I know this name should be a null-terminated string.
    //

    WCHAR const * pwszName = (WCHAR const *)pbName;

    Win4Assert( 0 == pwszName[cbName/sizeof(WCHAR) - 1] );

    CFunnyPath funnyName( pwszName, cbName/sizeof(WCHAR) - 1 );

    //
    // Hit all the drivers in order.
    //

    TRY
    {
        for ( unsigned i = 0; i < _aFilterStatus.Count(); i++ )
        {
            SCODE sc2 = _aFilterStatus[i]->PreFilter( funnyName.GetPath() );

            if ( FAILED(sc2) )
            {
                if ( SUCCEEDED(sc) )
                    sc = sc2;

                ciDebugOut(( DEB_WARN, "Filter tracker ::PreFilter(%ws) failed (0x%x)\n", funnyName.GetPath(), sc2 ));
            }
        }
    }
    CATCH( CException, e )
    {
        Win4Assert( !"Exception from client PreFilter" );
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%x calling 3rd party filter trackers (PreFilter)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::PostFilter, public
//
//  Synopsis:   Called by framework after filtering begins.
//
//  Arguments:  [pbName]         -- Document name (in abstract framework form)
//              [cbName]         -- Size in bytes of [pbName]
//              [scFilterStatus] -- Result of filtering.  Error indicates
//                                  failed filtering.
//
//  Returns:    Various, since it comes from 3rd party clients.
//
//  History:    15-Jan-1998   KyleP   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CStorageFilterObject::PostFilter( BYTE const * pbName,
                                               ULONG cbName,
                                               SCODE scFilterStatus )
{
    SCODE sc = S_OK;

    //
    // I know this name should be a null-terminated string.
    //

    WCHAR const * pwszName = (WCHAR const *)pbName;

    Win4Assert( 0 == pwszName[cbName/sizeof(WCHAR) - 1] );

    CFunnyPath funnyName( pwszName, cbName/sizeof(WCHAR) - 1 );

    //
    // Hit all the drivers in order.
    //

    TRY
    {
        for ( unsigned i = 0; i < _aFilterStatus.Count(); i++ )
        {
            SCODE sc2 = _aFilterStatus[i]->PostFilter( funnyName.GetPath(), scFilterStatus );

            if ( FAILED(sc2) )
            {
                if ( SUCCEEDED(sc) )
                    sc = sc2;

                ciDebugOut(( DEB_WARN, "Filter tracker ::PostFilter(%ws, 0x%x) failed (0x%x)\n",
                             funnyName.GetPath(), scFilterStatus, sc2 ));
            }
        }
    }
    CATCH( CException, e )
    {
        Win4Assert( !"Exception from client PostFilter" );
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%x calling 3rd party filter trackers (PostFilter)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH


    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::ReportFilterLoadFailure, public
//
//  Synopsis:   Called when an IFilter could not be loaded for a document.
//
//  Arguments:  [pwszName]  -- Path of document on which filter load attempted.
//              [scFailure] -- Status code returned from filter load.
//
//  History:    15-Jan-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void CStorageFilterObject::ReportFilterLoadFailure( WCHAR const * pwszName,
                                                    SCODE scFailure )
{
    //
    // Hit all the drivers in order.
    //

    TRY
    {
        for ( unsigned i = 0; i < _aFilterStatus.Count(); i++ )
        {
            SCODE sc = _aFilterStatus[i]->FilterLoad( pwszName, scFailure );

            if ( FAILED(sc) )
            {
                ciDebugOut(( DEB_WARN, "Filter tracker ::FilterLoad(%ws, 0x%x) failed (0x%x)\n",
                             pwszName, scFailure, sc ));
            }
        }
    }
    CATCH( CException, e )
    {
        Win4Assert( !"Exception from client FilterLoad" );
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%x calling 3rd party filter trackers (FilterLoad)\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::InitializeFilterTrackers, private
//
//  Synopsis:   Locates and loads filter trackers in registry.
//
//  Arguments:  [startupData] -- Daemon startup data
//
//  History:    15-Jan-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void CStorageFilterObject::InitializeFilterTrackers( CDaemonStartupData const & startupData )
{
    //
    // Get registry value
    //

    unsigned ccCat = wcslen( startupData.GetName() );
    unsigned const ccBase = sizeof(wcsRegCatalogsSubKey)/sizeof(WCHAR) - 1;

    XGrowable<WCHAR> xTemp;

    xTemp.SetSize( ccBase + 1 + ccCat + 1 );

    RtlCopyMemory( xTemp.Get(), wcsRegCatalogsSubKey, ccBase * sizeof(WCHAR) );
    xTemp[ccBase] = L'\\';
    RtlCopyMemory( xTemp.Get() + ccBase + 1, startupData.GetName(), (ccCat + 1) * sizeof(WCHAR) );

    HKEY hkey;

    DWORD dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  xTemp.Get(),
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hkey );

    if ( NO_ERROR == dwError )
    {
        SRegKey xKey( hkey );

        AddFilterTrackers( hkey );
    }

    //
    // Now get global registry value
    //

    RtlCopyMemory( xTemp.Get(), wcsRegAdminSubKey, sizeof(wcsRegAdminSubKey) );

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            xTemp.Get(),
                            0,
                            KEY_QUERY_VALUE,
                            &hkey );

    if ( NO_ERROR == dwError )
    {
        SRegKey xKey( hkey );

        AddFilterTrackers( hkey );
    }

    //
    // Initialize the lot.
    //

    for ( unsigned i = 0; i < _aFilterStatus.Count(); i++ )
    {
        SCODE sc = E_FAIL;

        #if CIDBG == 1
        TRY
        {
        #endif // CIDBG

            sc = _aFilterStatus[i]->Initialize( startupData.GetName(),
                                                startupData.GetCatDir() );
        #if CIDBG == 1
        }
        CATCH( CException, e )
        {
            Win4Assert( !"Exception during filter tracker initialization" );
            ciDebugOut(( DEB_ERROR,
                         "Exception 0x%x initializing filter tracker.\n",
                         e.GetErrorCode() ));

            sc = e.GetErrorCode();
        }
        END_CATCH
        #endif // CIDBG

        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_WARN, "Filter tracker failed to initialize\n" ));
            IFilterStatus * pfs = _aFilterStatus.AcquireAndShrink( i );
            pfs->Release();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObject::AddFilterTrackers, private
//
//  Synopsis:   Adds filter trackers from particular section (global or
//              per-catalog)
//
//  Arguments:  [hkey] -- Key below which filter trackers are registered.
//
//  History:    15-Jan-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void CStorageFilterObject::AddFilterTrackers( HKEY hkey )
{
    XGrowable<WCHAR> xBuf;
    DWORD cwc = xBuf.Count();

    DWORD dwError = RegQueryValueEx( hkey,
                                     wcsFilterTrackers,
                                     0,
                                     0,
                                     (BYTE *)xBuf.Get(),
                                     &cwc );

    if ( ERROR_MORE_DATA == dwError )
    {
        xBuf.SetSize( cwc / sizeof(WCHAR) );
        cwc = xBuf.Count();

        dwError = RegQueryValueEx( hkey,
                                   wcsFilterTrackers,
                                   0,
                                   0,
                                   (BYTE *)xBuf.Get(),
                                   &cwc );
    }

    if ( ERROR_SUCCESS == dwError )
    {
        WCHAR * pwcClsid = xBuf.Get();

        while ( 0 != *pwcClsid )
        {
            CLSID clsidServer;

            SCODE sc = CLSIDFromString( pwcClsid,
                                        &clsidServer );

            if ( SUCCEEDED(sc) )
            {
                XInterface<IFilterStatus> xFilterStatus;

                sc = CoCreateInstance( clsidServer,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IFilterStatus,
                                       xFilterStatus.GetQIPointer() );

                if ( SUCCEEDED(sc) )
                {
                    _aFilterStatus.Add( xFilterStatus.GetPointer(), _aFilterStatus.Count() );
                    xFilterStatus.Acquire();
                }
                else
                    ciDebugOut(( DEB_WARN, "Error 0x%x loading filter status tracker %ws\n", sc, pwcClsid ));
            }
            else
                ciDebugOut(( DEB_WARN, "Error 0x%x converting %ws to clsid\n", sc, pwcClsid ));

            pwcClsid += wcslen( pwcClsid ) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObjNotifyStatus::_GetFileName
//
//  Synopsis:   Retreives the NULL terminated file name from the variant
//              if it is a BYTE array.
//
//  Arguments:  [var] - Variant to extract the name from
//
//  History:    1-22-97   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR const * CStorageFilterObjNotifyStatus::_GetFileName( PROPVARIANT const & var )
{
    Win4Assert( var.vt == (VT_VECTOR|VT_UI1) );
    Win4Assert( (var.caub.cElems & 0x1) == 0 );

    ULONG cwc = var.caub.cElems/sizeof(WCHAR);
    WCHAR const * wcsFileName = (WCHAR const *) var.caub.pElems;

    //
    // Assert that the name is property NULL terminated.
    //
    Win4Assert( cwc > 0 );
    Win4Assert( wcsFileName[cwc-1] == 0 );

    return wcsFileName;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObjNotifyStatus::_ReportEmbeddingsFailureEvt
//
//  Synopsis:   Reports an embeddings failure event.
//
//  Arguments:  [nParams] - Number of parameters
//              [aParams] - An array of parameters.
//
//  History:    1-22-97   srikants   Created
//
//----------------------------------------------------------------------------

void CStorageFilterObjNotifyStatus::_ReportEmbeddingsFailureEvt(
    ULONG nParams,
    const PROPVARIANT * aParams )
{
    if ( 1 == nParams && aParams[0].vt == (VT_VECTOR|VT_UI1) )
    {
        WCHAR const * wcsFileName = _GetFileName( aParams[0] );

        if ( 0 != wcsFileName )
        {
            CFwEventItem item( EVENTLOG_WARNING_TYPE,
                               MSG_CI_EMBEDDINGS_COULD_NOT_BE_FILTERED,
                               1 );

            item.AddArg( wcsFileName );
            item.ReportEvent( *_pAdviseStatus );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStorageFilterObjNotifyStatus::_ReportTooManyBlocksEvt
//
//  Synopsis:   Reports that there were too many blocks for the specified
//              event.
//
//  Arguments:  [nParams] - Number of parameters.
//              [aParams] - Array of parameteres.
//
//  History:    1-22-97   srikants   Created
//
//----------------------------------------------------------------------------

void CStorageFilterObjNotifyStatus::_ReportTooManyBlocksEvt(
    ULONG nParams,
    const PROPVARIANT * aParams )
{
    if ( 2 == nParams )
    {
        WCHAR const * wcsFileName = 0;
        long maxMultiplier = -1;

        BOOL fOk = TRUE;

        for ( unsigned i = 0; i < nParams; i++ )
        {
            const PROPVARIANT & var = aParams[i];

            switch ( var.vt )
            {
                case VT_VECTOR | VT_UI1:
                    wcsFileName = _GetFileName( var );
                    break;

                case VT_UI4:
                case VT_I4:
                    maxMultiplier = var.lVal;
                    break;

                default:
                    Win4Assert( !"Unknown Variant Type" );
                    fOk = FALSE;
                    break;
            }
        }

        if ( fOk && wcsFileName && maxMultiplier > 0 )
        {
            CFwEventItem item( EVENTLOG_WARNING_TYPE,
                               MSG_CI_SERVICE_TOO_MANY_BLOCKS,
                               2 );

            item.AddArg( wcsFileName );
            item.AddArg( maxMultiplier );

            item.ReportEvent(*_pAdviseStatus);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\langres.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       langres.cxx
//
//  Contents:   Interacts with the registry to obtain locale specific info.
//
//  Classes:    CLangRes class
//
//  History:    2-14-97     mohamedn    created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <defbreak.hxx>
#include <lang.hxx>
#include <ciole.hxx>
#include <ciregkey.hxx>
#include <langres.hxx>
#include "isreg.hxx"

//+---------------------------------------------------------------------------
//
//  Class:      CLangReg
//
//  Purpose:    maintains lang. specific info for the passed in locale id.
//
//  History:    29-Aug-94   SitaramR    Created.
//              17 Apr 98   mohamedn    Switched from callback and doesn't
//                                      depend on InstalledLangs key.
//
//----------------------------------------------------------------------------

class CLangReg
{

public:
        CLangReg( LCID locale );

        //
        // For matching locale or language
        //
        BOOL LocaleFound() const        { return _fLocaleFound; }
        BOOL LangFound() const          { return _fLangFound; }

        WCHAR *GetWBreakerClass()       { return _wszWBreakerClass; }
        WCHAR *GetStemmerClass()        { return _wszStemmerClass; }
        WCHAR *GetNoiseFile()           { return _wszNoiseFile; }

private:
        void EnumLangEntries(void);

        void GetLangInfo(DWORD dwLocale, CWin32RegAccess & langKey);

        BOOL FillLangInfo( CWin32RegAccess & regLang );

        BOOL PrimaryLangsMatch( LCID lcid1, LCID lcid2 )
        {
            //
            // Do the primary languages of the two lcids match ?
            //
            return( PRIMARYLANGID( LANGIDFROMLCID( lcid1 ) )
                    == PRIMARYLANGID( LANGIDFROMLCID( lcid2 ) ) );
        }

        LCID  _locale;

        BOOL  _fLocaleFound;            // exact match with locale found
        BOOL  _fLangFound;              // primary language match

        WCHAR _wszWBreakerClass[MAX_REG_STR_LEN];
        WCHAR _wszStemmerClass[MAX_REG_STR_LEN];
        WCHAR _wszNoiseFile[MAX_PATH];
};

//+-------------------------------------------------------------------------
//
//  Method:     CLangReg::CLangReg
//
//  Arguments:  [locale] -- current locale
//
//  History:    29-Aug-94   SitaramR    Created.
//
//--------------------------------------------------------------------------

CLangReg::CLangReg( LCID locale )
   : _locale(locale),
     _fLocaleFound( FALSE ),
     _fLangFound( FALSE )
{
    EnumLangEntries();
}

//+-------------------------------------------------------------------------
//
//  Method:     EnumLangEntries, private
//
//  Synopsis:   enumerates CI lang subkeys.
//
//  Arguments:  none.
//
//  Returns:    none. sets internal values.
//
//  History:    4/17/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CLangReg::EnumLangEntries(void)
{

    CWin32RegAccess langKey ( HKEY_LOCAL_MACHINE, wcsRegAdminLanguage );
    WCHAR           wcsSubKeyName[MAX_PATH+1];
    DWORD           cwcName = sizeof wcsSubKeyName / sizeof WCHAR;

    while ( !_fLocaleFound && langKey.Enum( wcsSubKeyName, cwcName ) )
    {
        CWin32RegAccess langSubKey( langKey.GetHKey() , wcsSubKeyName );

        DWORD dwLocaleId = 0;

        if ( langSubKey.Get( L"Locale", dwLocaleId ) )
        {
            GetLangInfo( dwLocaleId, langSubKey );
        }
    }

}

//+-------------------------------------------------------------------------
//
//  Method:     GetLangInfo, private
//
//  Synopsis:   Gets language values from registry lang key.
//
//  Arguments:  [pwszLangKey]   -- language key to retrieve values from.
//
//  Returns:    none. sets internal flags.
//
//  History:    4/17/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CLangReg::GetLangInfo(DWORD dwLocale, CWin32RegAccess & regLang)
{
    if ( dwLocale == _locale )
    {
        _fLocaleFound = FillLangInfo( regLang );

    }
    else if ( !_fLangFound && PrimaryLangsMatch( dwLocale, _locale ) )
    {
        //
        // Approximate match with same primary language
        //
        _fLangFound = FillLangInfo( regLang );
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     FillLangInfo, private
//
//  Synopsis:   fills internal members with lang values from lang. subkey
//
//  Arguments:  [regLang]   -- reference to open lang key
//
//  Returns:    TRUE if succeeded, FALSE otherwise.
//
//  History:    4/17/98 mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CLangReg::FillLangInfo( CWin32RegAccess & regLang )
{
    BOOL fRetVal1 = FALSE;
    BOOL fRetVal2 = FALSE;
    BOOL fRetVal3 = FALSE;

    fRetVal1 = regLang.Get( L"WBreakerClass", _wszWBreakerClass,
                   sizeof (_wszWBreakerClass)/sizeof (_wszWBreakerClass[0]) );

    fRetVal2 = regLang.Get( L"StemmerClass", _wszStemmerClass,
                   sizeof (_wszStemmerClass)/sizeof (_wszStemmerClass[0]) );

    fRetVal3 = regLang.Get( L"NoiseFile", _wszNoiseFile,
                   sizeof (_wszNoiseFile)/sizeof (_wszNoiseFile[0]) );

    BOOL fRetVal = ( fRetVal1 || fRetVal2 || fRetVal3 );
    if ( ! fRetVal )
    {
        ciDebugOut(( DEB_ERROR, "CLangRes::FillLangInfo() Failed\n" ));
    }

    return fRetVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLangRes::GetNoiseWordList
//
//  Synopsis:   provides an IStream interface to the noise word list given
//              a locale and pid
//
//  arguments:  [locale]              [in] locale
//              [pid]                 [in] property id
//              [ppIStrmNoiseFile]    [out]IStream interface to the noise word list.
//
//  returns:    S_OK                    noise file found
//              CI_E_NOT_FOUND          no noise file found
//              CI_E_USE_DEFAULT_PID    only default pid is supported
//
//  History:    15-Aug-94   SitaramR     Renamed GetLang to BorrowLang and
//                                       added code to look up registry.
//              2-14-97     mohamedn     used to be in CLangList::BorrorwLang
//
//----------------------------------------------------------------------------

SCODE CLangRes::GetNoiseWordList( LCID      locale,
                                  PROPID    pid,
                                  IStream **ppIStrmNoiseFile)
{
    //
    // we only support default pid, except for Filename
    //
    if ( pid != CI_DEFAULT_PID )
    {
        if ( pidName == pid || pidRevName == pid )
        {
            *ppIStrmNoiseFile = 0;
            return S_OK;
        }
        else
            return CI_E_USE_DEFAULT_PID;
    }

    //
    // default to no noise file found
    //

    LANGID langid = LANGIDFROMLCID(locale);
    SCODE  sc     = CI_E_NOT_FOUND;

    *ppIStrmNoiseFile = 0;

    //
    // Try to bind to language object by looking up registry
    //
    CLangReg   langReg( langid );

    TRY
    {

       if ( langReg.LocaleFound() || langReg.LangFound() )
       {
            const WCHAR * pwszNoiseFile = langReg.GetNoiseFile();

            *ppIStrmNoiseFile = _GetIStrmNoiseFile( pwszNoiseFile );

            sc = S_OK;
       }

    }
    CATCH ( CException, e )
    {
       ciDebugOut (( DEB_ERROR,
                     "Exception 0x%x caught: Failed to get IStrmNoiseFile for langId(0x%x)\n",
                     e.GetErrorCode(), langid ));

       sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLangRes::_GetIStrmNoiseFile, private static
//
//  Synopsis:   provides an IStream interface given noise file name
//
//  Arguments:  [pwszNoiseFile] -- [in] noise file name
//
//  Returns:    IStream* -- IStream interface to the noise file.
//                          Throws value of GetLastError() upon failure.
//
//  History:     2-14-97     mohamedn    created
//
//  Notes:
//----------------------------------------------------------------------------

IStream *CLangRes::_GetIStrmNoiseFile(const WCHAR *pwszNoiseFile )
{
    SCODE   sc = S_OK;
    IStream *pIStrmNoiseFile = 0;

    Win4Assert( pwszNoiseFile );

    WCHAR wszNoisePath[MAX_PATH];

    if ( (pwszNoiseFile[0] != L'\\' || pwszNoiseFile[1] != L'\\') &&
         (! *pwszNoiseFile ||  pwszNoiseFile[1] != L':' || pwszNoiseFile[2] != L'\\') )
    {
        //
        // Form full path of noise file
        //
        const ULONG cchBufSize = sizeof wszNoisePath/sizeof wszNoisePath[0];
    
        ULONG len = GetSystemDirectory( wszNoisePath, cchBufSize );
        if  (len == 0 || len >= (cchBufSize-1))
        {
            sc = GetLastError();
            ciDebugOut (( DEB_ERROR,
                         "CLangRes: GetSystemDirectory(%ws) failed: %x\n",
                          wszNoisePath, sc ));

            THROW ( CException(sc) );
        }

        if ( wszNoisePath[len-1] != L'\\' )
        {
             wszNoisePath[len] = L'\\';
             len++;
             wszNoisePath[len] = L'\0';
        }

        if ( (len + wcslen( pwszNoiseFile ) + 1) >= cchBufSize )
        {
            ciDebugOut (( DEB_ERROR,
                         "CLangRes: Noise word file path too long: %ws\n",
                          pwszNoiseFile ));

            THROW ( CException( CI_E_BUFFERTOOSMALL ) );
        }
    }
    else
    {
        wszNoisePath[0] = L'\0';
    }
    wcscat( wszNoisePath, pwszNoiseFile );

    ciDebugOut(( DEB_ITRACE,
                 "Obtaining IStrmNoiseFile to file = %ws\n", wszNoisePath ));
    //
    // open noise file, and obtain its IStream
    //

    HANDLE hFile = CreateFile( wszNoisePath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               0,
                               OPEN_EXISTING,
                               0,
                               0 );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
         ciDebugOut (( DEB_ERROR, "CreateFile(%ws) failed: %x\n",
                      wszNoisePath, sc = GetLastError() ));

         THROW ( CException(sc) );
    }

    SWin32Handle    xhFile(hFile);


    ULONG cb = GetFileSize( hFile, NULL );
    if ( cb == 0xffffffff )
    {
         THROW( CException( sc = GetLastError() ) );
    }

    HGLOBAL hg = GlobalAlloc( GMEM_MOVEABLE | GMEM_NODISCARD, cb );
    if ( NULL == hg )
    {
         THROW( CException( sc = GetLastError() ) );
    }

    // store it in smart pointer to enable freeing in case of a THROW.
    // Upon success, it will be freed when pIStrmNoiseFile is freed.
    XGlobalAllocMem  xGlobalMem(hg);

    void * pb = GlobalLock( hg );
    if ( NULL == pb )
    {
         THROW( CException( sc = GetLastError() ));
    }

    ULONG cbRead;
    BOOL  fErr =  ReadFile( hFile, pb, cb, &cbRead, 0 );
    if ( 0 == fErr )
    {
         THROW( CException( sc = GetLastError() ));
    }

    fErr = GlobalUnlock( hg );
    if ( 0 == fErr && GetLastError() != NO_ERROR )
    {
         THROW( CException( sc = GetLastError() ));
    }

    sc = CreateStreamOnHGlobal( hg,                 //Memory handle for the stream object
                                TRUE,               //Whether to free memory when the object is released
                                &pIStrmNoiseFile ); //Indirect pointer to the new stream object
    if ( FAILED(sc) )
    {
         THROW( CException(sc) );
    }

    //
    // will be freed when pIStrmNoiseFile is released.
    //
    xGlobalMem.Acquire();

    return pIStrmNoiseFile;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLangRes::GetWordBreaker
//
//  Synopsis:   provides an IWordBreaker interface after scanning the registry.
//
//  arguments:  [locale]        [in] locale
//              [pid]           [in] property id
//              [ppwbBreaker]   [out]IWordBreaker interface
//
//  returns:    S_OK                    valid IWordBreaker is returned
//              CI_E_NOT_FOUND          no IWordBreaker found - use default
//              CI_E_USE_DEFAULT_PID    only default pid is supported
//
//  History:    15-Aug-94   SitaramR     Renamed GetLang to BorrowLang and
//                                       added code to look up registry.
//              2-14-97     mohamedn     Used to be in CLangList::BorrorwLang
//
//----------------------------------------------------------------------------

SCODE CLangRes::GetWordBreaker( LCID locale,
                                PROPID pid,
                                IWordBreaker ** ppwbBreaker )
{
    //
    // we only support default pid, except for Filename
    //

    if ( pid != CI_DEFAULT_PID )
    {
        if ( pidName == pid || pidRevName == pid )
            locale = LOCALE_NEUTRAL;
        else
            return CI_E_USE_DEFAULT_PID;
    }

    LANGID langid = LANGIDFROMLCID(locale);

    //
    // default to no word breaker found
    //
    XInterface<IWordBreaker> xWBreak;
    SCODE                    sc = CI_E_NOT_FOUND;

    //
    // Try to bind to language object by looking up registry
    //
    CLangReg langReg( langid );

    TRY
    {
        GUID guidClass;

        if ( ( langReg.LocaleFound() || langReg.LangFound() ) &&
             wcscmp( langReg.GetWBreakerClass(), L"" ) != 0 )
        {
            StringToCLSID( langReg.GetWBreakerClass(), guidClass );

            xWBreak.Set( CCiOle::NewWordBreaker( guidClass ) );

            if ( !xWBreak.IsNull() )
                sc = S_OK;
        }
    }
    CATCH ( CException, e )
    {
        ciDebugOut (( DEB_ERROR,
                      "Exception 0x%x caught: no such language (0x%x) found in registry\n",
                      e.GetErrorCode(), langid ));

        sc = e.GetErrorCode();
    }
    END_CATCH;

    //
    // set ppwbBreaker to what we found, or null if nothing is found
    //
    *ppwbBreaker = xWBreak.Acquire();

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLangRes::GetStemmer
//
//  Synopsis:   provides an IStemmer interface after scanning the registry.
//
//  arguments:  [locale]        [in] locale
//              [pid]           [in] property id
//              [ppStemmer]     [out]IStemmer interface
//
//  returns:    S_OK                    valid IStemmer is returned
//              CI_E_NOT_FOUND          no IStemmer found
//              CI_E_USE_DEFAULT_PID    only default pid is supported
//
//  History:    15-Aug-94   SitaramR     Renamed GetLang to BorrowLang and
//                                       added code to look up registry.
//              2-14-97     mohamedn     Used to be in CLangList::BorrorwLang
//
//----------------------------------------------------------------------------

SCODE CLangRes::GetStemmer( LCID locale,
                            PROPID pid,
                            IStemmer ** ppStemmer )
{
    GUID                guidClass;

    LANGID langid = LANGIDFROMLCID(locale);

    //
    // we only support default pid, except for Filename
    //
    if ( pid != CI_DEFAULT_PID )
    {
        if ( pidName == pid || pidRevName == pid )
        {
            *ppStemmer = 0;
            return S_OK;
        }
        else
            return CI_E_USE_DEFAULT_PID;
    }

    //
    // default to no stemmer
    //
    XInterface<IStemmer> _xStemmer;
    SCODE                sc = CI_E_NOT_FOUND;

    //
    // Try to bind to language object by looking up registry
    //
    CLangReg langReg( langid );
    TRY
    {
       if ( langReg.LocaleFound() || langReg.LangFound() )
       {
           // Is a stemmer available for given langid ?
           if ( wcscmp( langReg.GetStemmerClass(), L"" ) != 0 )
           {
               StringToCLSID( langReg.GetStemmerClass(), guidClass );

               _xStemmer.Set( CCiOle::NewStemmer( guidClass ) );

               sc = S_OK;
           }

       }
    }
    CATCH ( CException, e )
    {
       ciDebugOut (( DEB_ERROR,
                     "Exception 0x%x caught: no such language (0x%x) found in registry\n",
                     e.GetErrorCode(), langid ));
       sc = e.GetErrorCode();
    }
    END_CATCH;

    //
    // set ppStemmer to what we found, or null if nothing is found
    //
    *ppStemmer = _xStemmer.Acquire();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CLangList::StringToCLSID
//
//  Synopsis:   Convert string containing CLSID to CLSID
//
//  Arguments:  [wszClass] -- string containg CLSID
//              [guidClass] -- output guid
//
//  History:    15-Aug-94   SitaramR    Created.
//                          Algorithm copied from shtole.cxx
//
//--------------------------------------------------------------------------

void CLangRes::StringToCLSID( WCHAR *wszClass, GUID& guidClass )
{
    wszClass[9] = 0;
    guidClass.Data1 = wcstoul( &wszClass[1], 0, 16 );
    wszClass[14] = 0;
    guidClass.Data2 = (USHORT)wcstoul( &wszClass[10], 0, 16 );
    wszClass[19] = 0;
    guidClass.Data3 = (USHORT)wcstoul( &wszClass[15], 0, 16 );

    WCHAR wc = wszClass[22];
    wszClass[22] = 0;
    guidClass.Data4[0] = (unsigned char)wcstoul( &wszClass[20], 0, 16 );
    wszClass[22] = wc;
    wszClass[24] = 0;
    guidClass.Data4[1] = (unsigned char)wcstoul( &wszClass[22], 0, 16 );

    for ( int i = 0; i < 6; i++ )
    {
       wc = wszClass[27+i*2];
       wszClass[27+i*2] = 0;
       guidClass.Data4[2+i] = (unsigned char)wcstoul( &wszClass[25+i*2], 0, 16 );
       wszClass[27+i*2] = wc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\notifyev.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       notifyev.cxx
//
//  Contents:   CClientNotifyEvent class
//
//  History:    Jan-06-97  mohamedn  Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <eventlog.hxx>
#include <notifyev.hxx>
#include <cievtmsg.h>          // CI_SERVICE_CATEGORY

//+------------------------------------------------------
//
//  Member:     CClientNotifyEvent::CClientNotifyEvent
//
//
//  Synopsis:   Consturctor encapsulates creating a CEventLogItem object,
//              and calls CEventLog::ReportEvent on that event item.
//
//  Arguments:  [fType  ] - Type of event
//              [eventId] - Message file event identifier
//              [nParams] - Number of substitution arguments being passed
//              [aParams] - pointer to PROPVARIANT array of substitution args.
//              [cbData ] - number of bytes in supplemental raw data.
//              [data   ] - pointer to block of supplemental data.
//  
//  History:    Jan-06-97  mohamedn  Created
//
//----------------------------------------------------------------------------


CClientNotifyEvent::CClientNotifyEvent( WORD  fType,
                                        DWORD eventId,
                                        ULONG nParams,
                                        const PROPVARIANT *aParams,
                                        ULONG cbData,
                                        void* data   )

{

    CEventLog  eventLog(NULL,wcsCiEventSource);

    CEventItem item(fType, CI_SERVICE_CATEGORY, eventId, (WORD) nParams, cbData, data);

    for (WORD i = 0; i < nParams ; i++)
    {
        switch (aParams[i].vt)
        {

            case VT_LPSTR:
                            Win4Assert( FALSE );
                            break;                     
                                 
            case VT_LPWSTR:
                            item.AddArg(aParams[i].pwszVal);
                            break;

            case VT_UI4:
                            item.AddArg(aParams[i].ulVal);
                            break;

            default:
                            Win4Assert( !"Default case hit in CClientNotifyEvent" ); 
                                                                                        
                            THROW (CException(E_INVALIDARG));
        } // switch

    } // for

    eventLog.ReportEvent(item);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\opendoc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       opendoc.cxx
//
//  Contents:   Code that encapsulates an opened file on a Nt volume
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <docname.hxx>
#include <ciole.hxx>

#include <opendoc.hxx>
#include <statprop.hxx>
#include <imprsnat.hxx>
#include <dmnstart.hxx>
#include <queryexp.hxx>
#include <filterob.hxx>
#include <ntopen.hxx>

//+---------------------------------------------------------------------------
//
//  Class:      CImpersonatedOpenOpLock
//
//  Purpose:    Opens the oplock by doing any necessary impersonation. If there
//              are multiple alternative user-ids, it will try until one
//              succeeds or there are no more choices.
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

class CImpersonatedOpenOpLock : public PImpersonatedWorkItem
{
public:

    CImpersonatedOpenOpLock( const CFunnyPath & funnyDoc,
                             CImpersonateRemoteAccess * pRemoteAccess,
                             BOOL fTakeOpLock )
    : PImpersonatedWorkItem( funnyDoc.GetActualPath() ),
      _funnyDoc(funnyDoc),
      _fTakeOpLock( fTakeOpLock ),
      _pRemoteAccess( pRemoteAccess ),
      _fSharingViolation(FALSE)
    {
    }

    BOOL DoIt();    // virtual

    void Open()
    {
        if ( _pRemoteAccess )
        {
            ImpersonateAndDoWork( *_pRemoteAccess );
        }
        else
        {
            BOOL fSuccess = DoIt();
            Win4Assert( fSuccess );
        }
    }

    CFilterOplock * Acquire()
    {
        return _oplock.Acquire();
    }

    BOOL IsSharingViolation() const
    {
        return _fSharingViolation;
    }

    BOOL IsOffline() const
    {
        return _oplock->IsOffline();
    }

    BOOL IsNotContentIndexed() const
    {
        return _oplock->IsNotContentIndexed();
    }

private:

    const CFunnyPath &  _funnyDoc;
    BOOL _fTakeOpLock;
    CImpersonateRemoteAccess  * _pRemoteAccess;
    XPtr<CFilterOplock> _oplock;

    BOOL _fSharingViolation;
};

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonatedOpenOpLock::DoIt
//
//  Synopsis:   The virtual "DoIt" method that does the work under the
//              impersonated context (if necessary).
//
//  Returns:    TRUE if successful.
//              FALSE if another impersonation must be tried
//              THROWS if there is a failure and no impersonation to be
//              tried.
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonatedOpenOpLock::DoIt()
{
    BOOL fStatus = TRUE;
    BOOL fTryAgain = TRUE;

    for (;;)
    {
        TRY
        {
            _oplock.Set( new CFilterOplock( _funnyDoc, _fTakeOpLock ) );
            break;
        }
        CATCH( CException, e )
        {
            NTSTATUS Status = e.GetErrorCode();

            //
            // If the path was a net path, we may have to use a different impersonation
            // to gain access. We try until there are no more impersonation choices left.
            //

            if ( _fNetPath && 0 != _pRemoteAccess &&
                 IsRetryableError(Status) )
            {
                fStatus = FALSE;
                ciDebugOut(( DEB_WARN, "Trying another user-id for (%ws)\n",
                                         _funnyDoc.GetPath() ));
            }
            else
            {
                if ( fTryAgain && ::IsSharingViolation( Status ) )
                {
                    _fSharingViolation = TRUE;
                    _fTakeOpLock = FALSE;
                    fTryAgain = FALSE;
                    continue;
                }
                ciDebugOut(( DEB_IWARN, "Failed to filter (%ws). Error (0x%X)\n",
                                       _funnyDoc.GetPath(), e.GetErrorCode() ));
                RETHROW();
            }
            break;
        }
        END_CATCH
    }
    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Construction/Destruction
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::CCiCOpenedDoc
//
//  Synopsis:   Default constructor.  We initialize the minimal set of
//              members to indicate an inactive document
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CCiCOpenedDoc::CCiCOpenedDoc( CStorageFilterObject * pFilterObject,
                              CClientDaemonWorker * pWorker,
                              BOOL fTakeOpLock,
                              BOOL fFailIfNotContentIndexed )
        :_RefCount( 1 ),
         _TypeOfStorage( eUnknown ),
         _llFileSize(0),
         _pWorker( pWorker),
         _pRemoteImpersonation(0),
         _pFilterObject( pFilterObject ),
         _fTakeOpLock( fTakeOpLock ),
         _fSharingViolation( FALSE ),
         _fFailIfNotContentIndexed( fFailIfNotContentIndexed )
{
    if ( _pWorker )
    {
        _pRemoteImpersonation =
            new CImpersonateRemoteAccess( &(_pWorker->GetImpersonationCache()) );
    }
}

CCiCOpenedDoc::~CCiCOpenedDoc()
{
    Win4Assert( 0 == _RefCount );

    Close();

    delete _pRemoteImpersonation;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::_TooBigForDefault
//
//  Synopsis:   Checks if the given size is too big for using the default
//              filter.
//
//  Arguments:  [ll] - Size to check
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

inline BOOL CCiCOpenedDoc::_TooBigForDefault( LONGLONG const ll )
{
    Win4Assert( 0 != _pWorker );
    return( ll > (_pWorker->GetRegParams().GetMaxFilesizeFiltered() * 1024) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::_GetFileSize
//
//  Synopsis:   Retrieves the size of the current file.
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

LONGLONG CCiCOpenedDoc::_GetFileSize()
{
    Win4Assert( IsOpen( ) );

    IO_STATUS_BLOCK IoStatus;
    HANDLE FileHandle = _SafeOplock->GetFileHandle( );
    Win4Assert( INVALID_HANDLE_VALUE != FileHandle  );

    FILE_STANDARD_INFORMATION   stdInfo;

    NTSTATUS Status = NtQueryInformationFile( FileHandle,       //  File handle
                                              &IoStatus,        //  I/O Status
                                              &stdInfo,          //  Buffer
                                              sizeof( stdInfo ),//  Buffer size
                                              FileStandardInformation );

    Win4Assert( STATUS_DATATYPE_MISALIGNMENT != Status );

    if ( !NT_SUCCESS(Status) )
    {
        ciDebugOut(( DEB_IERROR, "Error 0x%x querying file info\n",
                     Status ));
        QUIETTHROW( CException( Status ));
    }

    return stdInfo.EndOfFile.QuadPart;
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown and IID_ICiCOpenedDoc
//
//  Arguments:  [riid]      - desired interface id
//              [ppvObject] - output interface pointer
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiCOpenedDoc == riid )
        *ppvObject = (void *)((ICiCOpenedDoc *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}   //  QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::AddRef
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiCOpenedDoc::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}   //  AddRef


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::Release
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiCOpenedDoc::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;

}   //  Release


//+---------------------------------------------------------------------------
//
//  ICiCOpenedDoc method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::Open
//
//  Synopsis:   Opens the specified file.  In general, the caller
//              passes an implementation-specific blob of data to the
//              ICiCOpenedDoc interface.  The selected implementation is
//              free to choose how it wants to interpret it.  This
//              implementation considers it to be a lpwstr.
//
//  Arguments:  [pbDocName] - Pointer to, presumably, lpwstr
//              [cbDocName] - Length in BYTES, not characters, of the name
//
//  Returns:    S_OK if successful
//              FILTER_E_ALREADY_OPEN if there is already an open document
//              FILTER_E_UNREACHABLE if there is a net failure
//              FILTER_E_IN_USE if the document is in use by another proess
//              other errors as appropriate
//
//----------------------------------------------------------------------------

SCODE CCiCOpenedDoc::Open ( BYTE const * pbDocName, ULONG cbDocName )
{
    //
    //  We cannot open if we're already open
    //

    if ( IsOpen() )
    {
        ciDebugOut(( DEB_IERROR, "CCiCOpenedDoc::Open - Document is already open\n" ));
        return FILTER_E_ALREADY_OPEN;
    }

    //
    // The docname  (Path) is always null terminated. It is an empty string
    // for a deleted document.
    //
    if ( cbDocName <= 2 )
        return CI_E_NOT_FOUND;

    SCODE sc = S_OK;

    TRY
    {
        //
        //  Safely construct each piece.
        //

        XInterface<CCiCDocName> LocalFileName( new CCiCDocName( (PWCHAR) pbDocName, cbDocName / sizeof( WCHAR )));
        _funnyFileName.SetPath( (const WCHAR*)pbDocName, (cbDocName/sizeof(WCHAR) - 1) );

#if DBG || CIDBG
        //
        //  Check that we haven't been asked to filter a file in a catalog.wci
        //  directory.
        //
        const WCHAR * pwszComponent = (WCHAR *)pbDocName;
        while (pwszComponent = wcschr(pwszComponent+1, L'\\'))
        {
            Win4Assert ( _wcsnicmp( pwszComponent,
                         L"\\catalog.wci\\",
                         wcslen(L"\\catalog.wci\\" )) != 0 );
        }
#endif // DBG || CIDBG


        //
        // We have to impersonate before accessing.
        //
        CImpersonatedOpenOpLock openDoc( _funnyFileName,
                                         _pRemoteImpersonation,
                                         _fTakeOpLock );
        openDoc.Open();

        //
        // Anything bad happen?
        //

        if ( openDoc.IsSharingViolation() )
            sc = FILTER_E_IN_USE;
        else if ( openDoc.IsOffline() )
            sc = FILTER_E_OFFLINE;
        else if ( _fFailIfNotContentIndexed && openDoc.IsNotContentIndexed() )
        {
            ciDebugOut(( DEB_ITRACE, "not indexing not-indexed file\n" ));
            sc = FILTER_E_IN_USE;
        }
        else
        {
            //
            //  At this point, everything is correctly opened.  We assign to the
            //  members.  This disconnects the objects from the safe pointers.
            //

            _FileName.Set( LocalFileName.Acquire( ));
            _SafeOplock.Set( openDoc.Acquire( ));
            _TypeOfStorage = eUnknown;
        }

    }
    CATCH ( CException, e )
    {
        //
        //  Grab status code and convert to SCODE.  Convert the status,
        //  if possible, to a known class of SCODE that the caller might,
        //  in some way, be able to deal with.
        //

        NTSTATUS Status =  e.GetErrorCode( );

        if (::IsSharingViolation( Status ))
        {

            ciDebugOut(( DEB_IERROR, "CCiCOpenedDoc::Open - sharing violation - %x\n", Status ));
            sc = FILTER_E_IN_USE;
            _fSharingViolation = TRUE;

        }
        else if (IsNetDisconnect( Status ))
        {

            ciDebugOut(( DEB_ERROR, "CCiCOpenedDoc::Open - net disconnect - %x\n", Status ));
            sc = FILTER_E_UNREACHABLE;
        }
        else
        {

            ciDebugOut(( DEB_ITRACE, "CCiCOpenedDoc::Open - other error - %x\n", Status ));
            sc = Status;
        }
    }
    END_CATCH

    return sc;
} //Open

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::Close
//
//  Synopsis:   Terminate all access to a file
//
//  Arguments:  None.
//
//  Returns:    S_OK if successful
//              FILTER_E_NOT_OPEN if there is no document
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::Close( void )
{
    //
    //  If there is no document open, reject this call
    //

    if ( !IsOpen() )
        return FILTER_E_NOT_OPEN;

    if ( 0 != _pWorker )
        _SafeOplock->MaybeSetLastAccessTime( _pWorker->GetRegParams().GetStompLastAccessDelay() );

    //
    //  Release pointers
    //

    _Storage.Free();
    _SafeOplock.Free( );
    _FileName.Free( );
    _funnyFileName.Truncate(0);
    _llFileSize = 0;

    return S_OK;
} //Close

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetDocumentName
//
//  Synopsis:   Returns the interface to the document name, if open.
//
//  Arguments:  [ppIDocName] - Pointer to the returned document name
//
//  Returns:    S_OK if successful
//              FILTER_E_NOT_OPEN if document is not currently open
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::GetDocumentName(
    ICiCDocName ** ppIDocName )
{
    //
    //  If there is no name, then we haven't opened a document yet.
    //

    if (!IsOpen( )) {

        return FILTER_E_NOT_OPEN;

    }

    //
    //  Set up return pointer and reference interface
    //

    *ppIDocName = _FileName.GetPointer( );
    (*ppIDocName)->AddRef( );

    return S_OK;

}   // GetDocumentName

void FunnyToNormalPath( const CFunnyPath & funnyPath,
                        WCHAR * awcPath );

SCODE ShellBindToItemByName(
    WCHAR const * pszFile,
    REFIID        riid,
    void **       ppv );

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetPropertySetStorage
//
//  Synopsis:   Returns the interface to the underlying IStorage if we have
//              a docfile.
//
//  Returns:    IStorage* of underlying docfile.
//              NULL if not a docfile or not open
//
//  History:    06-Apr-1998   KyleP  Use only for property set storage
//
//----------------------------------------------------------------------------

IPropertySetStorage * CCiCOpenedDoc::GetPropertySetStorage()
{
    // NTRAID#DB-NTBUG9-84131-2000/07/31-dlee Indexing Service contains workarounds for StgOpenStorage AV on > MAX_PATH paths

    if ( _funnyFileName.GetLength() >= MAX_PATH )
    {
        ciDebugOut(( DEB_WARN, "Not calling StgOpenStorage in CCiCOpenedDoc::GetPropertySetStorage for paths > MAX_PATH: \n(%ws)\n",
                               _funnyFileName.GetPath() ));
        _TypeOfStorage = eOther;
        Win4Assert( _Storage.IsNull() );
        return _Storage.GetPointer( );
    }

    //
    //  If we are open and we don't have a storage instance and we don't know
    //  the type of storage
    //

    if (IsOpen() && _Storage.IsNull( ) && _TypeOfStorage == eUnknown)
    {
        //
        //  Attempt to open docfile
        //

        Win4Assert( _Storage.IsNull() );
        Win4Assert( !_SafeOplock->IsOffline() );

#if 0
        SCODE sc = StgOpenStorageEx( _funnyFileName.GetPath( ),        // Path
                              STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,  // Flags (BChapman said use these)
                              STGFMT_ANY,                   // Format
                              0,                            // Reserved
                              0,                            // Reserved
                              0,                            // Reserved
                              IID_IPropertySetStorage,      // IID
                              _Storage.GetQIPointer() );
#else

        //
        // The shell expects the string not to change or go away until the
        // IPropertySetStorage is released, so make a copy of it.
        //

        FunnyToNormalPath( _funnyFileName, _awcPath );

        SCODE sc = ShellBindToItemByName( _awcPath,
                                          IID_IPropertySetStorage,
                                          _Storage.GetQIPointer() );

#endif

        //
        //  Set the type of storage based on what we found
        //

        if ( SUCCEEDED( sc ) )
            _TypeOfStorage = eDocfile;
        else
        {
            _TypeOfStorage = eOther;
            Win4Assert( _Storage.IsNull() );
        }
    }

    return _Storage.GetPointer( );
} //GetPropertySetStorage


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetStatPropertyEnum
//
//  Synopsis:   Return property storage for the "stat" (i.e., system storage)
//              property set.  This property set is not really stored in normal
//              property storage but is faked out of Nt file information.
//
//  Arguments:  [ppIStatPropEnum] - pointer to the returned IPropertyStorage
//                  interface
//
//  Returns:    S_OK -if successful
//              E_NOTIMPL if stat properties are not supported.  This
//                  implementation supports them.
//              FILTER_E_NOT_OPEN if there is no open document.
//              Other as appropriate
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCOpenedDoc::GetStatPropertyEnum(
    IPropertyStorage **ppIStatPropEnum )
{
    //
    //  Make sure the document is open
    //

    if (!IsOpen( )) {

        ciDebugOut(( DEB_IERROR, "Document is not open\n" ));
        return FILTER_E_NOT_OPEN;

    }

    //
    //  Return and interface
    //

    *ppIStatPropEnum = new CStatPropertyStorage( _SafeOplock->GetFileHandle( ),
                                                 _funnyFileName.GetLength() );

    return S_OK;

}   //  GetStatPropertyEnum


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetPropertySetEnum
//
//  Synopsis:   Returns the docfile property set storage interface on the
//              current doc.
//
//  Arguments:  [ppIPropSetEnum] - returned pointer to the Docfile property
//                  set storage
//
//  Returns:    S_OK if successful
//              FILTER_S_NO_PROPSETS if no property sets (beyond stat ones)
//                  available on this document
//              FILTER_E_NOT_OPEN if the document is not currently open
//              Other as appropriate
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCOpenedDoc::GetPropertySetEnum( IPropertySetStorage ** ppIPropSetEnum )
{
    //
    //  Make sure the document is open
    //

    if ( !IsOpen() )
        return FILTER_E_NOT_OPEN;

    //
    //  Make sure the extra file handle in the oplock is closed
    //

    _SafeOplock->CloseFileHandle();

    //
    //  Get the IStorage corresponding to this document
    //

    IPropertySetStorage * Storage = GetPropertySetStorage();

    //
    //  If we couldn't get the IStorage, then we certainly
    //  couldn't get the property set storage
    //

    if ( 0 == Storage )
        return FILTER_S_NO_PROPSETS;

    Storage->AddRef();
    *ppIPropSetEnum = Storage;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetPropertyEnum
//
//  Synopsis:   Return the property storage for a particular property set
//
//  Arguments:  [GuidPropSet] - GUID of the property set whose property
//                  storage is being requested
//              [ppIPropEnum] - returned pointer to property storage
//
//  Returns:    S_OK if successful
//              FILTER_E_NO_SUCH_PROPERTY - if property set with GUID not found
//              FILTER_E_NOT_OPEN if there is no open document
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::GetPropertyEnum(
    REFFMTID refGuidPropSet,
    IPropertyStorage **ppIPropEnum )
{
    //
    //  Get the property set storage interface
    //

    IPropertySetStorage *PropSetStorage;
    SCODE sc = GetPropertySetEnum( &PropSetStorage );

    if (!SUCCEEDED( sc )) {

        return sc;

    }

    //
    //  Attempt to open the named property set.
    //

    HRESULT hr = PropSetStorage->Open( refGuidPropSet,
                                       STGM_READ | STGM_SHARE_EXCLUSIVE, // BChapman said to use these
                                       ppIPropEnum );
    PropSetStorage->Release( );

    if (!SUCCEEDED( hr )) {

        return FILTER_E_NO_SUCH_PROPERTY;

    }

    return S_OK;
}   //  GetPropertyEnum

//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetIFilter
//
//  Synopsis:   Return the appropriate filter bound to the document
//
//  Arguments:  [ppIFilter] - returned IFilter
//
//  Returns:    S_OK if successful
//              FILTER_E_NOT_OPEN if there is no open document
//              E_NOT_IMPL if not implemented
//              Other as appropriate
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiCOpenedDoc::GetIFilter(
    IFilter ** ppIFilter )
{
    SCODE sc = S_OK;

    //
    //  We can't do anything if the document is not opened yet.
    //

    if ( !IsOpen() || IsSharingViolation() )
        return FILTER_E_NOT_OPEN;

    //
    //  Make sure the extra file handle in the oplock is closed
    //

    if ( INVALID_HANDLE_VALUE != _SafeOplock->GetFileHandle() )
    {
        _llFileSize = _GetFileSize();
        _SafeOplock->CloseFileHandle();
    }

    //
    //  Call Ole to perform the binding
    //
    TRY
    {
        sc = CCiOle::BindIFilter( _funnyFileName.GetPath(), NULL, ppIFilter, FALSE );

        if ( FAILED(sc) )
        {
            // MK_E_CANTOPENFILE is returned by the office filter. It should be
            // fixed to return FILTER_E_ACCESS/FILTER_E_PASSWORD in case it is not able
            // to open a file for filtering. Once that is done, we can get rid
            // of MK_E_CANTOPENFILE condition

            if ( FILTER_E_ACCESS == sc ||
                 ( MK_E_CANTOPENFILE == sc && ::IsSharingViolation( GetLastError() ))
               )
            {
                sc = FILTER_E_IN_USE ;
            }
            else if ( FILTER_E_PASSWORD == sc )
            {
                sc = FILTER_E_UNREACHABLE;
            }
            else if ( _pWorker->GetRegParams().FilterFilesWithUnknownExtensions() )
            {
                //
                // File with unknown extension. Does the registry say that we should
                // filter the file ?
                //
                ciDebugOut((DEB_IWARN, "Going to default filtering for %ws.\n",
                            _FileName->GetPath( ) ));

                // TSTART(_drep->timerNoBind);

                //
                // Verify file is of appropriate size for default filtering.
                //

                if ( _TooBigForDefault( _llFileSize ) )
                {
                    ciDebugOut(( DEB_IWARN,
                                 "%ws too large for default filtering\n",
                                 _FileName->GetPath( ) ));

                    //
                    // When this code was in CFilterDriver::Init we returned FILTER_E_TOO_BIG.
                    // Now we don't want to do that.  Properties should still be filtered.
                    //
                    //sc = FILTER_E_TOO_BIG;

                    sc = LoadBinaryFilter( _funnyFileName.GetPath(), ppIFilter );
                }
                else
                {
                    sc = LoadTextFilter( _funnyFileName.GetPath(), ppIFilter );
                }

                if ( FAILED(sc) )
                {
                    if ( FILTER_E_ACCESS == sc )
                    {
                        sc = FILTER_E_IN_USE ;
                    }
                    else if ( FILTER_E_PASSWORD == sc )
                    {
                        sc = FILTER_E_UNREACHABLE;
                    }
                }
                // TSTOP(_drep->timerNoBind);
            }
        }
    }
    CATCH ( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    if ( FAILED(sc) && 0 != _pFilterObject )
        _pFilterObject->ReportFilterLoadFailure( _FileName->GetPath(), sc );

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::GetSecurity
//
//  Synopsis:   Retrieves security
//
//  Arguments:  [pbData] - pointer to returned buffer containing security descriptor
//              [pcbData] - input:  size of buffer
//                          output: amount of buffer used, if successful, size needed
//                                  otherwise
//
//  Returns:    S_OK if successful
//              FILTER_E_NOT_OPEN if document not open
//              HRESULT_FROM_NT( STATUS_BUFFER_TOO_SMALL )
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::GetSecurity(
    BYTE * pbData,
    ULONG * pcbData )
{
    //
    //  Verify that the file is open
    //

    if (!IsOpen( )) {
        return FILTER_E_NOT_OPEN;

    }

    //
    // If it is a network file, don't store security.
    //
    if ( _pRemoteImpersonation &&
         _pRemoteImpersonation->IsImpersonated() )
    {
        *pcbData = 0;
        return S_OK;
    }

    //
    //  Attempt to get the security descriptor into the buffer
    //

    ULONG cbBuffer = *pcbData;
    NTSTATUS Status =
        NtQuerySecurityObject ( _SafeOplock->GetFileHandle(),
                                OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                pbData,
                                cbBuffer,
                                pcbData );

    //
    //  If we succeeded let caller know
    //

    if (NT_SUCCESS(Status))
    {
        *pcbData = GetSecurityDescriptorLength(pbData);
        return S_OK;
    }

    //
    //  Map status for caller
    //
    if ( STATUS_BUFFER_TOO_SMALL == Status )
        return CI_E_BUFFERTOOSMALL;
    else return HRESULT_FROM_NT( Status );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCOpenedDoc::IsInUseByAnotherProcess
//
//  Synopsis:   Tests to see if the document is wanted by another process
//
//  Arguments:  [pfInUse] - Returned flag, TRUE => someone wants this document
//
//  Returns:    S_OK if successful
//              FILTER_E_NOT_OPEN if document isn't open
//              E_NOTIMPL
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiCOpenedDoc::IsInUseByAnotherProcess(
    BOOL * pfInUse )
{
    //
    //  Verify that the file is open
    //

    if (!IsOpen( ) || IsSharingViolation() )
    {
        // If there was a sharing violation, then we never took the oplock.
        return FILTER_E_NOT_OPEN;

    }

    *pfInUse = _SafeOplock->IsOplockBroken( );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\fsci\indexing\statprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       statprop.cxx
//
//  Contents:   Code that encapsulates the stat property set on Nt file systems
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntopen.hxx>
#include "statprop.hxx"

//+---------------------------------------------------------------------------
//
//  Construction/Destruction
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::CStatPropertyStorage
//
//  Synopsis:   Construct a stat property enumerator by querying the
//              basic information from a handle
//
//  Arguments:  [FileHandle] - handle
//
//  History:    10-Dec-97    KyleP      Sum up streams to compute file size.
//
//----------------------------------------------------------------------------

CStatPropertyStorage::CStatPropertyStorage( HANDLE FileHandle, unsigned cPathLength )
        : _RefCount( 1 ),
          _xBuf( (unsigned int)(1 +
                   ( sizeof FILE_ALL_INFORMATION / sizeof LONGLONG ) +
                   ( __max(
                           (MAX_PATH * sizeof WCHAR) / sizeof LONGLONG,
                           (cPathLength * sizeof WCHAR) / sizeof LONGLONG ) ) ) )
{
    //
    //  We use the FileAllInformation info level which is a bit of overkill,
    //  but it has all the information we need to enumerate the properties.
    //
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = NtQueryInformationFile( FileHandle,       //  File handle
                                              &IoStatus,        //  I/O Status
                                              _xBuf.Get(),      //  Buffer
                                              _xBuf.SizeOf(),   //  Buffer size
                                              FileAllInformation );

    Win4Assert( STATUS_DATATYPE_MISALIGNMENT != Status );

    if ( !NT_SUCCESS(Status) )
    {
        ciDebugOut(( DEB_IERROR, "Error 0x%x querying file info\n",
                     Status ));
        QUIETTHROW( CException( Status ));
    }

    //
    // Null-terminate in scratch buffer just beyond path
    //

    WCHAR * pwcsPathName = GetInfo().NameInformation.FileName;
    pwcsPathName[GetInfo().NameInformation.FileNameLength/sizeof(WCHAR)] = 0;

    //
    // Setup filename by looking for a '\'
    //
    _FileName = pwcsPathName;
    for ( int i = GetInfo().NameInformation.FileNameLength/sizeof(WCHAR) - 1; i >= 0; i-- )
    {
        if ( pwcsPathName[i] == L'\\' )
        {
            _FileName = &pwcsPathName[i+1];
            break;
        }
    }

    //
    // No longer necessary to sum the streams, now that CNSS uses sparse files to make
    // docfiles look larger.  Using CiNtFileSize results in different file sizes depending
    // on which tool is used to look at the size (e.g. CI and 'dir' report differently).
    //

    #if 0
    //
    // Get the real file size (all streams)
    //

    LONGLONG llSize = CiNtFileSize( FileHandle );

    if ( -1 != llSize )
        GetInfo().StandardInformation.EndOfFile.QuadPart = llSize;
    #endif
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown and IID_IPropertyStorage
//
//  Arguments:  [riid]      - desired interface id
//              [ppvObject] - output interface pointer
//
//----------------------------------------------------------------------------

STDMETHODIMP CStatPropertyStorage::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IPropertyStorage == riid )
        *ppvObject = (void *)((IPropertyStorage *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::AddRef
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStatPropertyStorage::AddRef()
{
    return InterlockedIncrement(&_RefCount);
}   //  AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::Release
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStatPropertyStorage::Release()
{
    Win4Assert( _RefCount > 0 );

    LONG RefCount = InterlockedDecrement(&_RefCount);

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;
}   //  Release


//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::ReadMultiple
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    S_OK if successful
//
//
//----------------------------------------------------------------------------

STDMETHODIMP CStatPropertyStorage::ReadMultiple (
    THIS_ ULONG cpspec,
    const PROPSPEC __RPC_FAR rgpspec[  ],
    PROPVARIANT __RPC_FAR rgpropvar[  ] )
{
    //
    //  Walk through the prop specs looking for PID-identified
    //  properties
    //

    for (ULONG i = 0; i < cpspec; i++) {

        //
        //  String named properties are not found
        //

        PROPID PropertyId;

        if (rgpspec[i].ulKind == PRSPEC_LPWSTR) {
            PropertyId = 0xFFFFFFFF;
        } else {
            PropertyId = rgpspec[i].propid;
        }

        //
        //  Fetch the appropriate property value
        //

        switch (PropertyId) {
        case PID_STG_SIZE:
            rgpropvar[i].vt = VT_I8;
            rgpropvar[i].hVal = GetInfo().StandardInformation.EndOfFile;
            break;

        case PID_STG_NAME:
            rgpropvar[i].vt = VT_LPWSTR;
            rgpropvar[i].pwszVal =
                (WCHAR *) CoTaskMemAlloc( (wcslen( _FileName ) + 1) * sizeof( WCHAR ));

            if ( 0 == rgpropvar[i].pwszVal )
                return E_OUTOFMEMORY;

            wcscpy( rgpropvar[i].pwszVal, _FileName );
            break;

        case PID_STG_ATTRIBUTES:
            rgpropvar[i].vt = VT_UI4;
            rgpropvar[i].ulVal = GetInfo().BasicInformation.FileAttributes;
            break;

        case PID_STG_WRITETIME:
            rgpropvar[i].vt = VT_FILETIME;
            rgpropvar[i].filetime =
                *(UNALIGNED FILETIME *)&GetInfo().BasicInformation.LastWriteTime.QuadPart;
            break;

        case PID_STG_CREATETIME:
            rgpropvar[i].vt = VT_FILETIME;
            rgpropvar[i].filetime =
                *(UNALIGNED FILETIME *)&GetInfo().BasicInformation.CreationTime.QuadPart;
            break;

        case PID_STG_ACCESSTIME:
            rgpropvar[i].vt = VT_FILETIME;
            rgpropvar[i].filetime =
                *(UNALIGNED FILETIME *)&GetInfo().BasicInformation.LastAccessTime.QuadPart;
            break;

        case PID_STG_CHANGETIME:
            rgpropvar[i].vt = VT_FILETIME;
            rgpropvar[i].filetime =
                *(UNALIGNED FILETIME *)&GetInfo().BasicInformation.ChangeTime.QuadPart;
            break;

            //
            //  No other properties exist.  They are Not Found.
            //

        default:
            rgpropvar[i].vt = VT_EMPTY;
        }

    }

    return S_OK;
} //ReadMultiple

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyStorage::Enum
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    S_OK if successful
//
//
//----------------------------------------------------------------------------

STDMETHODIMP CStatPropertyStorage::Enum (
    THIS_ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum )
{
    *ppenum = new CStatPropertyEnum( IsNTFS() );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyEnum::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown and IID_IEnumSTATPROPSTG
//
//  Arguments:  [riid]      - desired interface id
//              [ppvObject] - output interface pointer
//
//----------------------------------------------------------------------------

STDMETHODIMP CStatPropertyEnum::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IEnumSTATPROPSTG == riid )
        *ppvObject = (void *)((IEnumSTATPROPSTG *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyEnum::AddRef
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStatPropertyEnum::AddRef()
{
    return InterlockedIncrement(&_RefCount);
}   //  AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyEnum::Release
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStatPropertyEnum::Release()
{
    Win4Assert( _RefCount > 0 );

    LONG RefCount = InterlockedDecrement(&_RefCount);

    if (  RefCount <= 0 )
        delete this;

    return RefCount;
}   //  Release


//+---------------------------------------------------------------------------
//
//  IEnumSTATPROPSTG method implementations
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CStatPropertyEnum::Enum
//
//  Synopsis:   Enumerate through the stat properties
//
//  Arguments:  [celt]      - maximum number of elements to return
//              [rgelt]     - output stat structures
//              [pceltFetched] - number of elements returned
//
//----------------------------------------------------------------------------

STDMETHODIMP CStatPropertyEnum::Next(
    ULONG celt,
    STATPROPSTG __RPC_FAR *rgelt,
    ULONG __RPC_FAR *pceltFetched )
{
    //
    //  We update the user's counter in place.  Start it off at zero
    //

    *pceltFetched = 0;

    //
    //  While we have more elements to return
    //

    while (celt--)
    {
        //
        //  No stat properties have names
        //

        rgelt->lpwstrName = NULL;

        //
        //  Retrieve the appropriate value from the enumeration
        //

        switch (_Index++)
        {
        case 0:
            rgelt->propid = PID_STG_CHANGETIME;
            rgelt->vt = VT_FILETIME;
            break;

        case 1:
            rgelt->propid = PID_STG_SIZE;
            rgelt->vt = VT_I8;
            break;

        case 2:
            rgelt->propid = PID_STG_NAME;
            rgelt->vt = VT_LPWSTR;
            break;

        case 3:
            rgelt->propid = PID_STG_ATTRIBUTES;
            rgelt->vt = VT_UI4;
            break;

        case 4:
            rgelt->propid = PID_STG_WRITETIME;
            rgelt->vt = VT_FILETIME;
            break;

        case 5:
            rgelt->propid = PID_STG_CREATETIME;
            rgelt->vt = VT_FILETIME;
            break;

        case 6:
            rgelt->propid = PID_STG_ACCESSTIME;
            rgelt->vt = VT_FILETIME;
            break;

        default:
            celt = 0;
            return S_OK;
        }

        //
        //  Note that we have fetched a value and advance to the next
        //  one.
        //

        (*pceltFetched)++;
        rgelt++;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\fnreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       FNReg.h
//
//  Contents:   Registration routines for IFilterNotify proxy.  Built
//              from macros in RPCProxy.h
//
//  History:    24-Mar-1999  KyleP        Created
//
//----------------------------------------------------------------------------

#pragma once

#if defined __cplusplus
extern "C" {
#endif

extern CLSID FNPrx_CLSID;
BOOL    STDAPICALLTYPE FNPrxDllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
HRESULT STDAPICALLTYPE FNPrxDllRegisterServer();
HRESULT STDAPICALLTYPE FNPrxDllUnregisterServer();
HRESULT STDAPICALLTYPE FNPrxDllGetClassObject ( const IID * const rclsid, const IID * const riid, void ** ppv );

#if defined __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\perfwci.h ===
#define CIISAPIOBJECT               0
#define NUM_CACHE_ITEMS             2
#define NUM_CACHE_HITS              4
#define NUM_CACHE_HITS_AND_MISSES_1 6
#define NUM_CACHE_MISSES            8
#define NUM_CACHE_HITS_AND_MISSES_2 10
#define NUM_RUNNING_QUERIES         12
#define NUM_TOTAL_QUERIES           14
#define NUM_QUERIES_PER_MINUTE      16
#define NUM_REQUESTS_QUEUED         18
#define NUM_REQUESTS_REJECTED       20
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\nlimport.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       nlimport.h
//
//  Contents:   An external file for Net Library DB definitions shared
//              with Tripoli and others.
//
//  History:    6-04-97   srikants   Created
//              11 Jun 1998  AlanW   Renamed to nlimport.h from nldbprop.h
//
//----------------------------------------------------------------------------

#pragma once


DEFINE_GUID(DBPROPSET_NLCOMMAND, 
            0x0b63e344, 0x9ccc, 0x11d0, 0xbc, 0xdb,
            0x00, 0x80, 0x5f, 0xcc, 0xce, 0x04);

// {0b63e367-9ccc-11d0-bcdb-00805fccce04}
DEFINE_GUID(DBPROPSET_NLCOLLATOR, 
            0x0b63e367, 0x9ccc, 0x11d0, 0xbc, 0xdb,
            0x00, 0x80, 0x5f, 0xcc, 0xce, 0x04);

#define NLDBPROP_CATALOGS       0x02L
#define NLDBPROP_STARTHIT       0x03L
#define NLDBPROP_GETHITCOUNT    0x04L

// {0b63e347-9ccc-11d0-bcdb-00805fccce04}
DEFINE_GUID(CLSID_Collator,
             0x0b63e347, 0x9ccc, 0x11d0, 0xbc, 0xdb,
             0x00, 0x80, 0x5f, 0xcc, 0xce, 0x04);

// 0b63e352-9ccc-11d0-bcdb-00805fccce04 
// DEFINE_GUID(CLSID_NlssoQuery,0x0b63e352,0x9ccc,0x11d0,0xbc,0xdb,0x00,0x80,0x5f,0xcc,0xce,0x04);

// 0b63e347-9ccc-11d0-bcdb-00805fccce04
DEFINE_GUID(CLSID_NlCommandCreator,
            0x0b63e347,0x9ccc,0x11d0,0xbc,0xdb,
            0x00,0x80,0x5f,0xcc,0xce,0x04 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\cidebnot.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       CIDEBNOT.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//
//----------------------------------------------------------------------------

#pragma once
#define __DEBNOT_H__

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//


#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (CIDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message
# define ASSRT_STRESSBREAK       0x00000008      // Unhandled exception to activate NTSD

# define ASSRT_STRESSEXCEPTION   0xABBAABBA      // This exception is not handled

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation
# define EXCEPT_VERBOSE          0x00000010      // Output message even for "quiet" exceptions


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


//
// Back to the info level stuff.
//

//
// For C++. and in a module which has access to GetProfileInt, automatically
//  initialise the info level from a setting in the [Cairo Infolevels] section
//  of win.ini
//

# if defined(__cplusplus) && defined(_CAIRO_) && !defined(KERNEL) && defined(GetProfileInt)

#  define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = GetProfileIntA (      \
                                                        "Cairo Infolevels", \
                                                        #comp,              \
                                                        DEF_INFOLEVEL );    \
        extern EXTRNC char *comp##InfoLevelString = #comp;

# else

// Simple initialisation
#  define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;        \
        extern EXTRNC char *comp##InfoLevelString = #comp;

# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\perffilt.h ===
#define FILTEROBJECT            0
#define FILTER_TIME_TOTAL       2
#define BIND_TIME               4
#define FILTER_TIME             6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\ci.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       CI.h
//
//  Contents:   Content index specific definitions
//
//  History:    04-Aug-92 KyleP     Moved from Win4p.h
//              12-Nov-99 KLam      Added assert to AlignBlock
//
//--------------------------------------------------------------------------

#pragma once

typedef ULONG WORKID;                   // Object ID of a file
typedef ULONG KEYID;                    // Key ID
typedef unsigned long PARTITIONID;      // Persistent ID of a partition
typedef unsigned long INDEXID;          // Persistent ID of a sub-index

typedef ULONGLONG FILEID;               // Ntfs file id of a file is 64 bits.

#ifdef __cplusplus

//
// These apparently aren't defined in C++ ( __min and __max are )
//

#ifndef max
#  define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#  define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif

#ifndef NUMELEM
# define NUMELEM(x) (sizeof(x)/sizeof(*x))
#endif

inline ULONG AlignBlock( ULONG x, ULONG align )
{
    ASSERT( ( align & (align-1) ) == 0 );
    return ( x + ( align - 1 ) ) & ~( align - 1 );
}

inline ULONG lltoul( IN const LONGLONG & ll )
{
    ASSERT( (ULONGLONG) ll <=  MAXULONG );
    return (ULONG) ll;
}

inline LONGLONG & litoll( IN LARGE_INTEGER &li )
{
    return(li.QuadPart);
}

inline LONG lltoHighPart( IN const LONGLONG & ll )
{
    return(((PLARGE_INTEGER) &ll)->HighPart);
}

inline ULONG lltoLowPart( IN const LONGLONG & ll)
{
    return ((PLARGE_INTEGER) &ll)->LowPart;
}

// CRT calls made by the Property Set code.

#define Prop_wcslen wcslen
#define Prop_wcsnicmp _wcsnicmp
#define Prop_wcscmp wcscmp
#define Prop_wcscpy wcscpy

//
// Convenience macros for signature creation
//

#if !defined( LONGSIG )
#define LONGSIG(c1, c2, c3, c4) \
    (((ULONG) (BYTE) (c1)) | \
    (((ULONG) (BYTE) (c2)) << 8) | \
    (((ULONG) (BYTE) (c3)) << 16) | \
    (((ULONG) (BYTE) (c4)) << 24))
#endif // LONGSIG

#if !defined( SHORTSIG )
#define SHORTSIG(c1, c2) \
    (((USHORT) (BYTE) (c1)) | \
    (((USHORT) (BYTE) (c2)) << 8))
#endif // SHORTSIG


//
// Invalid entries of various kinds.
//

const WORKID widInvalid = 0xFFFFFFFFL;     // Invalid WorkID
const WORKID widUnused = 0xFFFFFFFE;       // Useful for hash tables

const KEYID  kidInvalid = 0xFFFFFFFFL;     // Invalid KeyID
const FILEID fileIdInvalid = 0;            // Invalid file ID

const PARTITIONID partidInvalid = 0xFFFF;
const PARTITIONID partidKeyList = 0xFFFE;

//
// Internal generate method level(s)
//

const ULONG GENERATE_METHOD_MAX_USER         = 0x7FFFFFFF;  // No user fuzzy level bigger than this.
const ULONG GENERATE_METHOD_EXACTPREFIXMATCH = 0x80000000;  // Uses language-dependent noise-word list.

//
// Properties.  These are all the Property Ids that the CI understands.
//
// Note: the sorting algs. insist that pidInvalid == (unsigned) -1
//

#define MK_CISTGPROPID(propid)  ((propid) + 1)
#define MK_CIQUERYPROPID(propid) (((propid) + CSTORAGEPROPERTY) + 1)
#define IS_CIQUERYPROPID(propid) ( (propid) >= CSTORAGEPROPERTY + 1 && \
                                   (propid) <  CSTORAGEPROPERTY + CQUERYPROPERTY )
#define MK_CIQUERYMETAPROPID(propid) (((propid) + CSTORAGEPROPERTY + \
                                              CQUERYDISPIDS) + 1)
#define MK_CIDBCOLPROPID(propid) (((propid) + CSTORAGEPROPERTY + \
                                              CQUERYDISPIDS + CQUERYMETADISPIDS) + 1)
#define MK_CIDBBMKPROPID(propid) (((propid) + CSTORAGEPROPERTY + \
                                          CQUERYDISPIDS + CQUERYMETADISPIDS + \
                                          CDBCOLDISPIDS) + 1)

#define MK_CIDBSELFPROPID(propid) (((propid) + CSTORAGEPROPERTY + \
                                          CQUERYDISPIDS + CQUERYMETADISPIDS + \
                                          CDBCOLDISPIDS + CDBBMKDISPIDS) + 1)

// Property related type definitions


const PROPID pidInvalid     = 0xFFFFFFFF;
const PROPID pidAll         = 0;

// security is strictly an internally-used property

const PROPID pidSecurity    = MK_CISTGPROPID( PID_DICTIONARY );

const PROPID pidDirectory         =MK_CISTGPROPID( PID_STG_DIRECTORY );
const PROPID pidClassId           =MK_CISTGPROPID( PID_STG_CLASSID );
const PROPID pidStorageType       =MK_CISTGPROPID( PID_STG_STORAGETYPE );
const PROPID pidFileIndex         =MK_CISTGPROPID( PID_STG_FILEINDEX );
const PROPID pidVolumeId          =MK_CISTGPROPID( PID_STG_VOLUME_ID );
const PROPID pidParentWorkId      =MK_CISTGPROPID( PID_STG_PARENT_WORKID );
const PROPID pidSecondaryStorage  =MK_CISTGPROPID( PID_STG_SECONDARYSTORE );
const PROPID pidLastChangeUsn     =MK_CISTGPROPID( PID_STG_LASTCHANGEUSN );
const PROPID pidName              =MK_CISTGPROPID( PID_STG_NAME );
const PROPID pidPath              =MK_CISTGPROPID( PID_STG_PATH );
const PROPID pidSize              =MK_CISTGPROPID( PID_STG_SIZE );
const PROPID pidAttrib            =MK_CISTGPROPID( PID_STG_ATTRIBUTES );
const PROPID pidWriteTime         =MK_CISTGPROPID( PID_STG_WRITETIME );
const PROPID pidCreateTime        =MK_CISTGPROPID( PID_STG_CREATETIME );
const PROPID pidAccessTime        =MK_CISTGPROPID( PID_STG_ACCESSTIME);
const PROPID pidChangeTime        =MK_CISTGPROPID( PID_STG_CHANGETIME);
const PROPID pidContents          =MK_CISTGPROPID( PID_STG_CONTENTS );
const PROPID pidShortName         =MK_CISTGPROPID( PID_STG_SHORTNAME );

const PROPID pidRank         = MK_CIQUERYPROPID( DISPID_QUERY_RANK );
const PROPID pidHitCount     = MK_CIQUERYPROPID( DISPID_QUERY_HITCOUNT );
const PROPID pidRankVector   = MK_CIQUERYPROPID( DISPID_QUERY_RANKVECTOR );
const PROPID pidWorkId       = MK_CIQUERYPROPID( DISPID_QUERY_WORKID );
const PROPID pidUnfiltered   = MK_CIQUERYPROPID( DISPID_QUERY_UNFILTERED );
const PROPID pidRevName      = MK_CIQUERYPROPID( DISPID_QUERY_REVNAME );
const PROPID pidVirtualPath  = MK_CIQUERYPROPID( DISPID_QUERY_VIRTUALPATH );
const PROPID pidLastSeenTime = MK_CIQUERYPROPID( DISPID_QUERY_LASTSEENTIME );

const PROPID pidVRootUsed           = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_VROOTUSED );
const PROPID pidVRootAutomatic      = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_VROOTAUTOMATIC );
const PROPID pidVRootManual         = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_VROOTMANUAL );
const PROPID pidPropertyGuid        = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_PROPGUID );
const PROPID pidPropertyDispId      = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_PROPDISPID );
const PROPID pidPropertyName        = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_PROPNAME );
const PROPID pidPropertyStoreLevel  = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_STORELEVEL );
const PROPID pidPropDataModifiable  = MK_CIQUERYMETAPROPID( DISPID_QUERY_METADATA_PROPMODIFIABLE );

//
//  OLE-DB pseudo columns for the columns cursor, row status and bookmarks
//

const PROPID pidRowStatus   = MK_CIDBCOLPROPID( 27 );

const PROPID pidBookmark    = MK_CIDBBMKPROPID( PROPID_DBBMK_BOOKMARK );
const PROPID pidChapter     = MK_CIDBBMKPROPID( PROPID_DBBMK_CHAPTER );

const PROPID pidSelf        = MK_CIDBSELFPROPID( PROPID_DBSELF_SELF );


PROPID const INIT_DOWNLEVEL_PID = 0x1000;

inline BOOL IsUserDefinedPid( PROPID pid )
{
    return (pid >= INIT_DOWNLEVEL_PID);
}

//  Precomputed list of primes

static const ULONG g_aPrimes[] =
    { 17, 31, 43, 97, 199, 401, 809, 1621, 3253, 6521, 13049, 26111, 52237, 104479 };
const unsigned g_cPrimes = sizeof g_aPrimes / sizeof g_aPrimes[0];

#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\perfci.h ===
#define CIOBJECT                0
#define NUM_WORDLIST            2
#define NUM_PERSISTENT_INDEX    4
#define INDEX_SIZE              6
#define FILES_TO_BE_FILTERED    8
#define NUM_UNIQUE_KEY          10
#define RUNNING_QUERIES         12
#define MERGE_PROGRESS          14
#define DOCUMENTS_FILTERED      16
#define NUM_DOCUMENTS           18
#define TOTAL_QUERIES           20
#define DEFERRED_FILTER_FILES   22
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\h\srvprvdr.h ===
#pragma once

#include <oledb.h>
#include <cmdtree.h>

#if 0
DEFINE_GUID(IID_IService, 0xeef35580, 0x7b0a, 0x11d0, 0xad, 0x6b, 0x0, 0xa0, 0xc9, 0x5, 0x5d, 0x8f);

interface IService : public IUnknown
	{
public:
	virtual HRESULT STDMETHODCALLTYPE Cancel(void) = 0;

	virtual HRESULT STDMETHODCALLTYPE InvokeService(
		/* [in] */ REFIID riid,
		/* [in] */ IUnknown __RPC_FAR *punkNotSoFunctionalInterface,
		/* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkMoreFunctionalInterface) = 0;

	};

#endif

DEFINE_GUID(IID_IServiceProperties, 0xeef35581, 0x7b0a, 0x11d0, 0xad, 0x6b, 0x0, 0xa0, 0xc9, 0x5, 0x5d, 0x8f);

interface IServiceProperties : public IUnknown
    {
public:
    virtual HRESULT STDMETHODCALLTYPE GetProperties(
        /* [in] */ const ULONG cPropertyIDSets,
        /* [size_is][in] */ const DBPROPIDSET __RPC_FAR rgPropertyIDSets[  ],
        /* [out][in] */ ULONG __RPC_FAR *pcPropertySets,
        /* [size_is][size_is][out] */ DBPROPSET __RPC_FAR *__RPC_FAR *prgPropertySets) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetPropertyInfo(
        /* [in] */ ULONG cPropertyIDSets,
        /* [size_is][in] */ const DBPROPIDSET __RPC_FAR rgPropertyIDSets[  ],
        /* [out][in] */ ULONG __RPC_FAR *pcPropertyInfoSets,
        /* [size_is][size_is][out] */ DBPROPINFOSET __RPC_FAR *__RPC_FAR *prgPropertyInfoSets,
        /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppDescBuffer) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetRequestedProperties(
        /* [in] */ ULONG cPropertySets,
        /* [size_is][out][in] */ DBPROPSET __RPC_FAR rgPropertySets[  ]) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetSuppliedProperties(
        /* [in] */ ULONG cPropertySets,
        /* [size_is][out][in] */ DBPROPSET __RPC_FAR rgPropertySets[  ]) = 0;

    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\dbcolumn.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       DBColumn.cxx
//
//  Contents:   C++ wrappers for OLE-DB columns and sort keys
//
//  Classes:    CDbColumns
//              CDbSortKey
//              CDbSortSet
//
//  History:     20 Jul 1995   AlanW     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
// Methods for CDbColumns
//

CDbColumns::CDbColumns( unsigned size )
        : _size( size ),
          _cCol( 0 ),
          _aCol( 0 )
{
    if ( _size > 0 )
    {
        _aCol = (CDbColId *)CoTaskMemAlloc( _size * sizeof(CDbColId) );

        if ( 0 == _aCol )
        {
            _size = 0;
        }
        else
            memset( _aCol, DBKIND_GUID_PROPID, _size * sizeof( CDbColId ) );
    }
}

CDbColumns::CDbColumns( CDbColumns const & src )
       : _size( src._cCol ),
         _cCol( 0 )
{
    if ( _size > 0 )
    {
        _aCol = (CDbColId *)CoTaskMemAlloc( _size * sizeof( CDbColId ) );

        if ( 0 != _aCol )
        {
            memset( _aCol, DBKIND_GUID_PROPID, _size * sizeof( CDbColId ) );

            while( _cCol < src._cCol )
            {
                if ( !Add( src.Get( _cCol ), _cCol ) )
                    break;
            }
        }
        else
        {
            _size = 0;
        }
    }
}

CDbColumns::~CDbColumns()
{
    if ( _size > 0 )
    {
        for ( unsigned i = 0; i < _cCol; i++ )
            _aCol[i].CDbColId::~CDbColId();

        if ( _aCol )
            CoTaskMemFree( _aCol );
    }
}

#if 0   // NOTE: Marshall & Unmarshall not needed at this time.
void CDbColumns::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _cCol );

    for ( unsigned i = 0; i < _cCol; i++ )
    {
        _aCol[i].Marshall( stm );
    }
}

CDbColumns::CDbColumns( PDeSerStream & stm )
{
    _size = stm.GetULong();

    if ( _size > 0 )
    {
        _aCol = (CDbColId *)CoTaskMemAlloc( _size * sizeof( CDbColId ) );

        if ( 0 != _aCol )
        {
            for( _cCol = 0; _cCol < _size; _cCol++ )
            {
                CDbColId ps(stm);

                Add( ps, _cCol );
            }
        }
        else
        {
            _size = 0;
        }
    }
}
#endif // 0 - Marshall and Unmarshall not needed now.

BOOL CDbColumns::Add( CDbColId const & Property, unsigned pos )
{
    while ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 1;
        CDbColId * aNew =
            (CDbColId *)CoTaskMemAlloc( cNew * sizeof( CDbColId ) );

        if ( 0 == aNew )
            return FALSE;

        memcpy( aNew, _aCol, _cCol * sizeof( CDbColId ) );
        memset( aNew + _cCol, DBKIND_GUID_PROPID, (cNew - _cCol) * sizeof( CDbColId ) );

        if ( 0 != _aCol )
            CoTaskMemFree( _aCol );

        _aCol = aNew;
        _size = cNew;
    }

    _aCol[pos] = Property;

    if ( pos >= _cCol )
        _cCol = pos + 1;

    return( TRUE );
}

void CDbColumns::Remove( unsigned pos )
{
    if ( pos < _cCol )
    {
        _aCol[pos].CDbColId::~CDbColId();

        _cCol--;
        RtlMoveMemory( _aCol + pos,
                 _aCol + pos + 1,
                 (_cCol - pos) * sizeof( CDbColId ) );
    }
}

//
// Methods for CDbSortSet
//

CDbSortSet::CDbSortSet( unsigned size )
        : _size( size ),
          _csk( 0 ),
          _ask( 0 )
{
    if ( _size > 0 )
    {
        _ask = (CDbSortKey *)CoTaskMemAlloc( _size * sizeof( CDbSortKey ) );

        if ( _ask == 0 )
        {
            _size = 0;
        }
        else
        {
            memset( _ask, DBKIND_GUID_PROPID, _size * sizeof( CDbSortKey ) );
        }
    }
}

CDbSortSet::CDbSortSet( CDbSortSet const & src )
       : _size( src._csk ),
         _csk( 0 ),
         _ask( 0 )
{
    if ( _size > 0 )
    {
        _ask = (CDbSortKey *)CoTaskMemAlloc( _size * sizeof( CDbSortKey ) );

        if ( 0 != _ask )
        {
            memset( _ask, DBKIND_GUID_PROPID, _size * sizeof( CDbSortKey ) );
            while( _csk < src._csk )
            {
                if ( !Add( src.Get( _csk ), _csk ) )
                {
                    break;
                }
            }
        }
        else
        {
            _size = 0;
        }
    }
}

#if 0   // NOTE: Marshall & Unmarshall not needed at this time.
void CDbSortKey::Marshall( PSerStream & stm ) const
{
    //
    // NOTE: Order is important!
    //

    _property.Marshall( stm );
    stm.PutULong( _dwOrder );
}

CDbSortKey::CDbSortKey( PDeSerStream & stm )
        : _property( stm ),
          _dwOrder( stm.GetULong() )
{
}
#endif // 0 - Marshall and Unmarshall not needed now.

CDbSortSet::~CDbSortSet()
{
    if ( _size > 0 )
    {
        for ( unsigned i = 0; i < _csk; i++ )
        {
            _ask[i].GetProperty().CDbColId::~CDbColId();
        }

        if ( _ask )
        {
            CoTaskMemFree( _ask );
        }
    }
}

#if 0   // NOTE: Marshall & Unmarshall not needed at this time.
void CDbSortSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _csk );

    for ( unsigned i = 0; i < _csk; i++ )
    {
        _ask[i].Marshall( stm );
    }
}

CDbSortSet::CDbSortSet( PDeSerStream & stm )
        : _csk( stm.GetULong() ),
          _size( _csk )
{
    _ask = (CDbSortKey *)CoTaskMemAlloc( _csk * sizeof( CDbSortKey ) );

    for ( unsigned i = 0; i < _csk; i++ )
    {
        CDbSortKey sk(stm);

        Add( sk, i );
    }
}
#endif // 0 - Marshall and Unmarshall not needed now.

BOOL
CDbSortSet::Add( CDbSortKey const & sk, unsigned pos )
{
    while ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 1;
        CDbSortKey * aNew = (CDbSortKey *)CoTaskMemAlloc( cNew * sizeof( CDbSortKey ) );

        if ( 0 == aNew )
            return FALSE;

        memcpy( aNew, _ask, _csk * sizeof( CDbSortKey ) );
        memset( aNew + _csk, DBKIND_GUID_PROPID, (cNew - _csk) * sizeof( CDbSortKey ) );

        CoTaskMemFree( _ask );

        _ask = aNew;
        _size = cNew;

    }

    _ask[pos] = sk;

    if ( !_ask[pos].IsValid() )
        return FALSE;

    if ( pos >= _csk )
        _csk = pos + 1;

    return TRUE;
}


BOOL CDbSortSet::Add( CDbColId const & property, ULONG dwOrder, unsigned pos )
{
    CDbSortKey sk( property, dwOrder );

    if ( !sk.IsValid() )
        return FALSE;

    return Add( sk, pos );
}

void CDbSortSet::Remove( unsigned pos )
{
    if ( pos < _csk )
    {
        _ask[pos].GetProperty().CDbColId::~CDbColId();
        _csk--;
        RtlMoveMemory( _ask + pos,
                       _ask + pos + 1,
                       (_csk - pos) * sizeof( CDbSortKey ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\cmdprutl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cmdprutl.cxx
//
//  Contents:   A wrapper for scope properties around ICommand
//
//  History:    5-10-97     mohamedn        created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cmdprutl.hxx>
#include <fsciclnt.h>
#include <guidutil.hxx>

static GUID const guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;
static GUID const guidCiFsExt          = DBPROPSET_FSCIFRMWRK_EXT;
static const cFsCiProps = 4;
static const cInitProps = 2;
static const cScopePropSets = 2;

//
// utility functions
//
extern WCHAR **GetWCharFromVariant ( DBPROP & dbProp, ULONG *cElements );
extern DWORD * GetDepthsFromVariant( DBPROP & dbProp, ULONG *cElements, ULONG mask );

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::CGetCmdProps
//
//  Synopsis:   Constructor - Initializes all, calls GetProperties().
//
//  History:    5-10-97     mohamedn        created
//
//----------------------------------------------------------------------------

CGetCmdProps::CGetCmdProps( ICommand * pICommand )
:_fGuidValid(FALSE),
 _aDepths(0),
 _aPaths(0),
 _aCatalogs(0),
 _aMachines(0),
 _cDepths(0),
 _cScopes(0),
 _cCatalogs(0),
 _cMachines(0),
 _cGuids(0),
 _type(CiNormal),
 _cPropertySets(0),
 _cCardinality(0xffffffff)
{
    RtlZeroMemory( &_clientGuid, sizeof GUID );

    SCODE sc = pICommand->QueryInterface( IID_ICommandProperties,
                                          _xICmdProp.GetQIPointer() );
    if ( FAILED(sc) )
        THROW( CException(sc) );

    //
    // Populate our internal data structs
    //

    GetProperties();

    SetCardinalityValue();
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::GetProperties
//
//  Synopsis:   Retrieves all the properties from ICommandProperties interface.
//
//  Arguments:  none
//
//  Returns:    Throws upon failure.
//
//  History:    5-10-97     mohamedn        created
//
//----------------------------------------------------------------------------

//
// Hack #214: IID_ICommandProperties is intercepted by service layers, which
//            don't like us passing in the magic code to fetch hidden scope
//            properties.  But the controlling unknown doesn't recognize
//            IID_IKyleProp and sends it right to us.  Implementation is
//            identical to ICommandProperties.
//

GUID IID_IKyleProp = { 0xb4237bc2, 0xe09f, 0x11d1, 0x80, 0xc0, 0x00, 0xc0, 0x4f, 0xa3, 0x54, 0xba };

void CGetCmdProps::GetProperties()
{
    // get all properties including scope props

    XInterface<ICommandProperties> xTemp;
    SCODE sc = _xICmdProp->QueryInterface( IID_IKyleProp,
                                           xTemp.GetQIPointer() );

    const ULONG cPropIdSets = 3141592653;
    DBPROPSET * pDbPropSet;
    ULONG cPropertySets;

    if ( SUCCEEDED(sc) )
        sc =  xTemp->GetProperties( cPropIdSets,
                                    0,
                                    &cPropertySets,
                                    &pDbPropSet );

    if ( FAILED(sc) )
    {
        // On this failure, you have to free the properties returned!

        Win4Assert( DB_E_ERRORSOCCURRED != sc );

        ciDebugOut(( DEB_ERROR, "Failed to do GetProperties (0x%X)\n", sc ));
        THROW( CException( sc ) );
    }

    _xPropSet.Set( cPropertySets, (CDbPropSet *) pDbPropSet );
    _cPropertySets = cPropertySets;

    for ( ULONG i = 0; i < cPropertySets; i++ )
        ProcessPropSet( pDbPropSet[i] );
} //GetProperties

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::SetCardinalityValue
//
//  Synopsis:   validates and sets the Cardinality value
//
//  Arguments:  none
//
//  Returns:    none - throws upon failure.
//
//  History:    5-12-97     mohamedn    moved from CQuerySpec
//
//----------------------------------------------------------------------------

void CGetCmdProps::SetCardinalityValue()
{
    //
    // Final cardinality check...
    //

    if (  _cDepths   != _cScopes ||
         (_cScopes   != _cCatalogs && _cCatalogs != 1) ||
          _cCatalogs != _cMachines )
    {
        ciDebugOut(( DEB_ERROR, "CQuerySpec::QueryInternalQuery -- Cardinality mismatch\n" ));
        THROW( CException( CI_E_CARDINALITY_MISMATCH ) );
    }

    // The query is distributed if multiple machines or multiple catalogs
    // are present.  Multiple scopes on one catalog/machine are handled
    // by a non-distributed query.

    BOOL fDistributed = FALSE;

    if (_cCatalogs > 1)
    {
        for ( unsigned i = 0; !fDistributed && i < _cScopes-1; i++ )
        {
            if ( ( _wcsicmp( _aMachines[i], _aMachines[i+1] ) ) ||
                 ( _wcsicmp( _aCatalogs[i], _aCatalogs[i+1] ) ) )
            {
                fDistributed = TRUE;
            }
        }
    }

    // Win4Assert( !" Break here to set single/distributed query" );

    if ( fDistributed )
    {
        Win4Assert( _cCatalogs > 1 );

        _cCardinality = _cCatalogs;    // distributed case
    }
    else if ( 0 == _cCatalogs )
    {
        _cCardinality = 0;             // local case
    }
    else
    {
        _cCardinality = 1;             // single machine case.
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::PopulateDbProps
//
//  Synopsis:   Creates a new IDBProperties using ICommand properties
//
//  Arguments:  [pIDBProperties]    -- IDBProperties interface
//              [iElement]          -- specifies which of the distributed properties to use
//
//  Returns:    none - thorws upon failure.
//
//  History:    5-12-97     mohamedn    created
//
//----------------------------------------------------------------------------

void CGetCmdProps::PopulateDbProps(IDBProperties *pIDBProperties, ULONG iElement )
{
    Win4Assert( !_xICmdProp.IsNull() ); // src
    Win4Assert( pIDBProperties  != 0 ); // destination
    Win4Assert( _cPropertySets  != 0 ); // at least one property set exist.
    Win4Assert( _xPropSet.GetPointer() != 0 );

    DBPROPSET  * pPropSet  = 0;
    ULONG        cPropSets = 0;
    XArrayOLEInPlace<CDbPropSet> xPropSet;

    CreateNewPropSet(&cPropSets, &pPropSet, iElement);

    Win4Assert( pPropSet  != 0 );
    Win4Assert( cPropSets != 0 );

    xPropSet.Set(cPropSets,(CDbPropSet *)pPropSet);

    SCODE sc = pIDBProperties->SetProperties( cPropSets, xPropSet.GetPointer());

    if ( FAILED(sc) )
         THROW( CException(sc) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::CreateNewPropSet, private
//
//  Synopsis:   Creates new property sets on IDBProperties from ICommand properties.
//
//  Arguments:  [cPropSets]     -- count of property sets
//              [ppPropSet]     -- to return new property sets
//              [index]         -- specifies which of the distributed properties to use
//
//  Returns:    none - throws upon failure.
//
//  History:    05-12-97    mohamedn    created
//
//----------------------------------------------------------------------------
void CGetCmdProps::CreateNewPropSet(ULONG *cPropSets, DBPROPSET **ppPropSet, ULONG index)
{
    XArrayOLEInPlace<CDbPropSet>    xPropSet(_cPropertySets);
    ULONG                           cPropSetsCopied = 0;

    for ( unsigned i = 0; i < _cPropertySets; i++ )
    {
        if ( _xProp